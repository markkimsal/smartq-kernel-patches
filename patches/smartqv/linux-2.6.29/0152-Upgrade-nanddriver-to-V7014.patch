From 9714361dc936f8948179df93a5241c46092bde71 Mon Sep 17 00:00:00 2001
From: YouSheng <david.ysh@gmail.com>
Date: Mon, 8 Feb 2010 17:19:11 +0800
Subject: [PATCH] Upgrade nanddriver to V7014

---
 drivers/block/tcc/Makefile                         |    2 +-
 drivers/block/tcc/fwupgrade.c                      |   10 +-
 drivers/block/tcc/inc/def_tcc.h                    |    2 +-
 drivers/block/tcc/inc/fwdn/Disk.h                  |    1 +
 drivers/block/tcc/inc/fwdn/FSAPP.h                 |    9 +-
 drivers/block/tcc/inc/fwdn/fat.h                   |    5 +-
 drivers/block/tcc/inc/fwdn/file.h                  |    4 +-
 drivers/block/tcc/inc/fwdn/fwdn_drv_v3.h           |   23 +-
 drivers/block/tcc/inc/fwdn/fwdn_drv_v7.h           |  158 +
 drivers/block/tcc/inc/fwdn/fwdn_protocol_v3.h      |   67 +-
 drivers/block/tcc/inc/fwdn/fwdn_protocol_v7.h      |  121 +
 drivers/block/tcc/inc/fwdn/fwupgrade.h             |    6 +-
 drivers/block/tcc/inc/tnftl/kernel_nand_drv.h      |  138 +
 drivers/block/tcc/inc/tnftl/nand_drv.h             |   21 +-
 drivers/block/tcc/inc/tnftl/nand_io_v7.h           |  131 +-
 drivers/block/tcc/inc/tnftl/tnftl_v7.h             |   13 +-
 drivers/block/tcc/init_ddr2.c                      |  438 ++-
 drivers/block/tcc/init_mddr.c                      |   95 +-
 drivers/block/tcc/kernel_nand_drv.c                | 1417 +++++++--
 .../tcc/libtnftl/libtnftl_V7010_TCC8900.o_shipped  |  Bin 204076 -> 0 bytes
 .../tcc/libtnftl/libtnftl_V7014_TCC8900.o_shipped  |  Bin 0 -> 222203 bytes
 drivers/block/tcc/nand_drv_v7.c                    |  467 ++-
 drivers/block/tcc/nand_io_v7.c                     | 3445 +++++++++++++++-----
 kernel/sched.c                                     |    2 -
 24 files changed, 5144 insertions(+), 1431 deletions(-)
 create mode 100644 drivers/block/tcc/inc/fwdn/fwdn_drv_v7.h
 create mode 100644 drivers/block/tcc/inc/fwdn/fwdn_protocol_v7.h
 create mode 100644 drivers/block/tcc/inc/tnftl/kernel_nand_drv.h
 delete mode 100644 drivers/block/tcc/libtnftl/libtnftl_V7010_TCC8900.o_shipped
 create mode 100644 drivers/block/tcc/libtnftl/libtnftl_V7014_TCC8900.o_shipped

diff --git a/drivers/block/tcc/Makefile b/drivers/block/tcc/Makefile
index aa05924..b3c0814 100644
--- a/drivers/block/tcc/Makefile
+++ b/drivers/block/tcc/Makefile
@@ -18,7 +18,7 @@ $(TCC_ARCH)_nand-objs := nand_drv.o nand_io_v6.o
 endif
 
 ifneq ($(CONFIG_TCC_NAND_V7),)
-NAND_VER := V7010
+NAND_VER := V7014
 DEF_NAND += -DNAND_BOOT_REV
 obj-$(CONFIG_TCC_NAND_V7) := $(TCC_ARCH)_nand.o
 $(TCC_ARCH)_nand-objs := nand_drv_v7.o nand_io_v7.o
diff --git a/drivers/block/tcc/fwupgrade.c b/drivers/block/tcc/fwupgrade.c
index 31f893a..e2f6c64 100644
--- a/drivers/block/tcc/fwupgrade.c
+++ b/drivers/block/tcc/fwupgrade.c
@@ -108,7 +108,7 @@ extern int TCDB_SaveDBHeader(unsigned char ucAssociation, int iPartID);
 extern void ResetSystem(void);
 
 
-#define		MAXBUFFSIZE 8*1024 // 
+#define		MAXBUFFSIZE 16*1024 // 
 
 extern int		gSDUpgrading;
 
@@ -148,7 +148,7 @@ char *FWUG_GetTempBuffer(unsigned int *uiBufSize)
 // Description : Check Battery
 // 
 ///////////////////////////////////////////////////////////////////////////////////
-int FWUG_CheckBattery()
+int FWUG_CheckBattery(void)
 {
 #ifdef BATTERY_INCLUDE
 	unsigned int batteryValue = 0;
@@ -433,7 +433,7 @@ FWUG_FAIL:
 *  			= 
 *  REMARK  :	
 **************************************************************************/
-unsigned int FWUG_CalcCrc(unsigned int *base, unsigned int length, unsigned int *crctable)
+unsigned int FWUG_CalcCrc(unsigned int *base, unsigned int length, const unsigned int *crctable)
 {
 	unsigned int crcout = 0;
 	unsigned int cnt, i, code, tmp;
@@ -494,7 +494,7 @@ unsigned int FWUG_CalcCrc8(unsigned char *base, unsigned int length, const unsig
 *  			= 
 *  REMARK  :	
 **************************************************************************/
-unsigned int FWUG_CalcCrcI(unsigned uCRCIN, unsigned *base, unsigned int length, unsigned int *crctable)
+unsigned int FWUG_CalcCrcI(unsigned uCRCIN, unsigned *base, unsigned int length, const unsigned int *crctable)
 {
 	unsigned int crcout = uCRCIN;
 	unsigned int cnt, i, code, tmp;
@@ -526,7 +526,7 @@ unsigned int FWUG_CalcCrcI(unsigned uCRCIN, unsigned *base, unsigned int length,
 *  			= 
 *  REMARK  :	
 **************************************************************************/
-unsigned int FWUG_CalcCrc8I(unsigned uCRCIN, unsigned char *base, unsigned int length, unsigned int *crctable)
+unsigned int FWUG_CalcCrc8I(unsigned uCRCIN, unsigned char *base, unsigned int length, const unsigned int *crctable)
 {
 	unsigned int crcout = uCRCIN;
 	unsigned int cnt; 
diff --git a/drivers/block/tcc/inc/def_tcc.h b/drivers/block/tcc/inc/def_tcc.h
index 42b3ac7..b22123f 100644
--- a/drivers/block/tcc/inc/def_tcc.h
+++ b/drivers/block/tcc/inc/def_tcc.h
@@ -1,5 +1,5 @@
 #ifdef NAND_BOOT_REV
-#define NAND_VER "V7010"
+#define NAND_VER "V7014"
 #else
 #define NAND_VER "V6005"
 #endif
diff --git a/drivers/block/tcc/inc/fwdn/Disk.h b/drivers/block/tcc/inc/fwdn/Disk.h
index 4bff8ef..5bdff47 100644
--- a/drivers/block/tcc/inc/fwdn/Disk.h
+++ b/drivers/block/tcc/inc/fwdn/Disk.h
@@ -305,6 +305,7 @@ typedef enum
 	DEV_FORCE_FLUSH_CACHE_DATA,
 	DEV_SET_ALIGEN_CACHE,
 	DEV_SET_MULTISECTOR,			// twkwon: Han DR
+	DEV_SET_HIDDEN_SIZE,
 	DEV_END_OF_FUNCTION
 }IOCTL_FUNCTIONS;
 
diff --git a/drivers/block/tcc/inc/fwdn/FSAPP.h b/drivers/block/tcc/inc/fwdn/FSAPP.h
index a5c871f..285c387 100644
--- a/drivers/block/tcc/inc/fwdn/FSAPP.h
+++ b/drivers/block/tcc/inc/fwdn/FSAPP.h
@@ -111,9 +111,12 @@ extern int				FSAPP_cleanFATcache_PS(int drvTypeID, int partID, unsigned long FA
 extern int				FSAPP_changeFATcache_PS(int drvTypeID, int partID, unsigned long FAT1_PhySector, unsigned int Offset_Sector, unsigned char *fatBuff);
 extern int				FSAPP_fatWriteClus_PS(int drvTypeID, unsigned short nCount, unsigned long sector_addr, unsigned short nSector, unsigned short multi_sector, int multi_byte, unsigned char *temp_buff);
 extern unsigned int		FSAPP_FormatClear_PS(int drvTypeID, unsigned long sectorPerFAT, unsigned int nSector, unsigned char *pBuff, void *SecBuff);
-extern unsigned int		FSAPP_FormatDrive( DISK_DEVICE diskDevice, unsigned int *multiPartition_SectorSize);
+
+extern unsigned int		FSAPP_FormatDrive( DISK_DEVICE diskDevice, unsigned int *multiPartition_SectorSize, unsigned int *validFAT);
+
 extern int				FSAPP_FormatRootEntry_PS(int drvTypeID, int halfEntryNum, unsigned nSector, unsigned char writeVolume, void *pBuff, unsigned char *BS_VolLab);
-extern unsigned int		FSAPP_decide_MakeMBR(int drvTypeID, unsigned char SecPerClus, unsigned int *Partition, void *pBuff, struct _DISK_INFO *disk);
+
+extern unsigned int		FSAPP_decide_MakeMBR(int drvTypeID, unsigned char SecPerClus, unsigned int *numOfSecPR, unsigned int *validFAT, void *pBuff, struct _DISK_INFO *disk);
 extern unsigned char	FSAPP_decide_DrvNum(int drvTypeID);
 extern int				Initialize_FileSystem(DISK_DEVICE mDeviceNum, int partID);
 
@@ -122,4 +125,6 @@ extern int				Initialize_FileSystem(DISK_DEVICE mDeviceNum, int partID);
 extern unsigned char	*FSAPP_SetVolumeLabel(unsigned int partID, void* VolLab);
 extern unsigned char	*FSAPP_GetVolumeLabel(unsigned int partID);
 
+extern unsigned int FSAPP_PartitionWrite(DISK_DEVICE diskDevice, unsigned int partitionID, unsigned int lba, void *pBuff, unsigned short nSector);
+extern unsigned int FSAPP_PartitionRead(DISK_DEVICE diskDevice, unsigned int partitionID, unsigned int lba, void *pBuff, unsigned short nSector);
 #endif
diff --git a/drivers/block/tcc/inc/fwdn/fat.h b/drivers/block/tcc/inc/fwdn/fat.h
index fbff0fb..075ebc1 100644
--- a/drivers/block/tcc/inc/fwdn/fat.h
+++ b/drivers/block/tcc/inc/fwdn/fat.h
@@ -728,12 +728,13 @@ extern int				FAT_fatCache_Common(int drvTypeID, int partID, unsigned long FAT2_
 extern unsigned int		FAT_Format_ClearCommon(int drvTypeID, int sectorPerFAT, unsigned long nSector, unsigned char *pBuff, void *SecBuff, unsigned char multiFlag);
 extern int				FAT_FormatRE_Common(int drvTypeID, int halfEntryNum, unsigned nSector, unsigned char writeVolume, void *pBuff, unsigned char *BS_VolLab);
 						
-extern unsigned int		FAT_makeMBR(int drvTypeID, unsigned long numOfSecPR1, unsigned long numOfSecPR2, unsigned long numOfSecPR3, 
-									unsigned long numOfSecPR4, unsigned char SecPerClus, void *pBuff, struct _DISK_INFO *disk);
+extern unsigned int		FAT_makeMBR(int drvTypeID, unsigned int *numOfSecPR, unsigned int *validFAT, unsigned char SecPerClus, void *pBuff, struct _DISK_INFO *disk);
 
 extern int				FAT_CheckDirContentsExist(int drvTypeID, int partID, unsigned long start_cluster, int *file_count, int *subdir_count);
 extern short			getLongEntryName(int drvTypeID, int partID, struct _FDIRENT *pFDir, unsigned long sector_offset, int entry_offset, struct _FAT_LONG_DIR_ENTRY *entry, void *buff);
 extern unsigned long	cluster2sector(int partID, unsigned long cluster);
 
+extern int FDISK_PartitionWrite(int drvTypeID, unsigned int partitionID, unsigned int relativeLBA, void *pBuff, unsigned short nSector);
+extern int FDISK_PartitionRead(int drvTypeID, unsigned int partitionID, unsigned int relativeLBA, void *pBuff, unsigned short nSector);
 
 #endif	// __FAT_H__
diff --git a/drivers/block/tcc/inc/fwdn/file.h b/drivers/block/tcc/inc/fwdn/file.h
index 2123845..c7e395d 100644
--- a/drivers/block/tcc/inc/fwdn/file.h
+++ b/drivers/block/tcc/inc/fwdn/file.h
@@ -252,8 +252,8 @@ extern int				FILE_OpenDirWithCluster(int partID, unsigned long dir_cluster, int
 extern int				FILE_Copy(int dir_num, int sHandle, long *copy_status);
 extern int				FILE_Format(int drvTypeID, int partID, unsigned char writeVolume,
 									unsigned char SecPerClus, unsigned int CntOfClus, struct _DISK_INFO *disk);
-extern int				FILE_FormatMBR(int drvTypeID, unsigned char writeVolume,
-										unsigned char SecPerClus, unsigned int *Partition, struct _DISK_INFO *disk);
+
+extern int				FILE_FormatMBR(int drvTypeID, unsigned char writeVolume, unsigned char SecPerClus, unsigned int *numOfSecPR, unsigned int *validFAT, struct _DISK_INFO *disk);
 									
 
 extern int				FILE_DiskInfo(int partID, DRVINFOstruc *pDrive);
diff --git a/drivers/block/tcc/inc/fwdn/fwdn_drv_v3.h b/drivers/block/tcc/inc/fwdn/fwdn_drv_v3.h
index 2aa3f09..8471c96 100644
--- a/drivers/block/tcc/inc/fwdn/fwdn_drv_v3.h
+++ b/drivers/block/tcc/inc/fwdn/fwdn_drv_v3.h
@@ -22,7 +22,7 @@ enum
 {
 	ERR_FWDN_DRV_WRONG_PARAMETER = 0x10000000,
 	ERR_FWDN_DRV_DISK_IOCTRL_DEV_INITIALIZE,
-	ERR_FWDN_DRV_DISK_WRITE_COMPARE,
+	ERR_FWDN_DRV_DISK_COMPARE,
 	ERR_FWDN_DRV_DISK_WRITE,
 	ERR_FWDN_DRV_DISK_READ,
 };
@@ -61,6 +61,7 @@ enum
 
 
 typedef int (*fpFWDN_DRV_FirmwareWrite_ReadFromHost)(unsigned char *buff, unsigned int size, unsigned int srcAddr, unsigned int percent);
+typedef int (*FXN_FWDN_DRV_RquestData)(unsigned char *buff, unsigned int size);
 typedef unsigned int (*FXN_FWDN_DRV_ReadFromHost)(void *buff, unsigned int size);
 typedef unsigned int (*FXN_FWDN_DRV_SendToHost)(void *buff, unsigned int size);
 
@@ -97,6 +98,17 @@ typedef	struct	__NAND_DeviceInfo {
 	unsigned short int  SpareSize;		
 } NAND_DEVICE_INFO, *pNAND_DEVICE_INFO;
 
+#ifdef TRIFLASH_INCLUDE
+#define MMC_DISK_MAX_HIDDEN_NUMBER		4
+
+typedef struct _tag_MMC_DISK_INFO_T {
+        unsigned int    nTotalSector;
+        unsigned int    nBootSector;
+        unsigned int    nHiddenNum;
+        unsigned int    nHiddenSector[MMC_DISK_MAX_HIDDEN_NUMBER];
+        unsigned int    nBytePerSector;
+} MMC_DISK_INFO_T;
+#endif
 //==============================================================
 //
 //		Global Variables
@@ -136,15 +148,16 @@ int							FWDN_DRV_DISK_Write(unsigned int lba, unsigned int size, FXN_FWDN_DRV_
 
 void						FWDN_DRV_DISK_Hidden_InfoRead(void *pInfo, unsigned char *pSize);
 int							FWDN_DRV_DISK_Hidden_Clean(void);
-int							FWDN_DRV_DISK_Hidden_Write(unsigned int index, unsigned int startpage, unsigned int sizebyte, FXN_FWDN_DRV_ReadFromHost fxnFwdnDrvReadFromHost);
+int							FWDN_DRV_DISK_Hidden_Write(unsigned int index, unsigned int startpage, unsigned int sizebyte, FXN_FWDN_DRV_RquestData fxnFwdnDrvRequestData);
 int							FWDN_DRV_DISK_MTD_Write(unsigned int startpage, unsigned int sizebyte, FXN_FWDN_DRV_ReadFromHost fxnFwdnDrvReadFromHost);
 
-int							FWDN_DRV_DISK_FS_Partition(void *pMultiPartitionSizeArray, unsigned int length);
+int							FWDN_DRV_DISK_DATA_Partition(void *pMultiPartitionSizeArray, unsigned int length);
+int							FWDN_DRV_DISK_DATA_Image_Write(unsigned int nPartitionID, unsigned int offset, unsigned int size, FXN_FWDN_DRV_RquestData fxnFwdnDrvRequestData);
 int							FWDN_DRV_DISK_FS_Mount(unsigned int partID);
-int							FWDN_DRV_DISK_FS_Format(void *pMultiPartitionSizeArray, unsigned int length);
+int							FWDN_DRV_DISK_FS_Format(unsigned int partID, char *volumeParam);
 int							FWDN_DRV_DISK_FS_MkDir(unsigned char *name);
 int							FWDN_DRV_DISK_FS_ChDir(unsigned char *name);
-int							FWDN_DRV_DISK_FS_FileWrite(unsigned char *name, unsigned int size, FXN_FWDN_DRV_ReadFromHost fxnFwdnDrvReadFromHost);
+int							FWDN_DRV_DISK_FS_FileWrite(unsigned char *name, unsigned int size, FXN_FWDN_DRV_RquestData fxnFwdnDrvRequestData);
 
 unsigned char				FWDN_DRV_DISK_DUMP_InfoRead(unsigned char *pBuf);
 int							FWDN_DRV_DISK_DUMP_BlockRead(unsigned int Param0, unsigned int Param1, unsigned int Param2, FXN_FWDN_DRV_SendToHost fxnFwdnDrvSendToHost);
diff --git a/drivers/block/tcc/inc/fwdn/fwdn_drv_v7.h b/drivers/block/tcc/inc/fwdn/fwdn_drv_v7.h
new file mode 100644
index 0000000..ffd38bf
--- /dev/null
+++ b/drivers/block/tcc/inc/fwdn/fwdn_drv_v7.h
@@ -0,0 +1,158 @@
+/****************************************************************************
+ *   FileName    : Fwdn_drv_v7.h
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+
+#ifndef _FWDN_DRV_V7_H_
+#define _FWDN_DRV_V7_H_
+
+#define FWDN_DEVICE_INIT_BITMAP_LOW_FORMAT				(1<<0)
+#define FWDN_DEVICE_INIT_BITMAP_DUMP					(1<<1)
+#define FWDN_DEVICE_INIT_BITMAP_UPDATE					(1<<2)
+#define FWDN_DEVICE_INIT_BITMAP_LOW_FORMAT_LEVEL2		(1<<3)
+
+enum
+{
+	ERR_FWDN_DRV_WRONG_PARAMETER = 0x10000000,
+	ERR_FWDN_DRV_IOCTRL_DEV_INITIALIZE,
+	ERR_FWDN_DRV_AREA_WRITE_COMPARE,
+	ERR_FWDN_DRV_RESET_NOT_SUPPORT,
+	ERR_FWDN_DRV_INSUFFICIENT_MEMORY,
+	ERR_FWDN_DRV_AREA_WRITE,
+	ERR_FWDN_DRV_AREA_READ,
+};
+
+enum
+{
+	FWDN_DISK_NONE,
+	FWDN_DISK_HDD,
+	FWDN_DISK_MMC,
+	FWDN_DISK_UHP,
+	FWDN_DISK_NAND,
+	FWDN_DISK_TRIFLASH,
+	FWDN_DISK_NOR,
+	FWDN_DISK_SFLASH,
+	FWDN_DISK_MAX
+};
+
+enum
+{
+	SN_NOT_EXIST = 0,
+	SN_VALID_16,
+	SN_INVALID_16,
+	SN_VALID_32,
+	SN_INVALID_32
+};
+
+
+typedef int (*FXN_FWDN_DRV_FirmwareWrite_ReadFromHost)(unsigned char *buff, unsigned int size, unsigned int srcAddr, unsigned int percent);
+typedef unsigned int (*FXN_FWDN_DRV_ReadFromHost)(void *buff, unsigned int size);
+typedef unsigned int (*FXN_FWDN_DRV_SendToHost)(void *buff, unsigned int size);
+typedef void (*FXN_FWDN_DRV_Response_RequestData)(unsigned int dataSize);
+typedef int (*FXN_FWDN_DRV_RquestData)(unsigned char *buff, unsigned int size);
+typedef void (*FXN_FWDN_DRV_SendStatus)(unsigned int param0, unsigned int param1, unsigned int param2);
+typedef void (*FXN_FWDN_DRV_Progress)( unsigned int percent );
+
+typedef struct _tag_FWDN_AREA_T {
+	unsigned int		nSector;
+	char				name[16];
+} FWDN_AREA_T;
+
+#define FWDN_AREA_LIST_MAX		20
+typedef struct	 _tag_DeviceInfoType {
+	unsigned int		DevSerialNumberType;					// Device Serial Number type SN_NOT_EXIST..
+	unsigned char		DevSerialNumber[32];
+	FWDN_AREA_T			area[FWDN_AREA_LIST_MAX];				// Default Area = area[0]
+} FWDN_DEVICE_INFORMATION, *pFWDN_DEVICE_INFORMATION;
+
+typedef struct	 _tag_NAND_HiddenSizeInfo {
+	unsigned int				HiddenNum;						// Total Hidden Area Num	
+	unsigned int 				HiddenPageSize[12];				// Each Hidden Area's Size
+	unsigned int				RO_PageSize;
+} NAND_PARTITION_INFO, *pNAND_HIDDEN_INFO;
+
+ typedef	struct	__NAND_DeviceInfo {
+	unsigned short int	DevID[8];
+	unsigned int		MediaNums;			// Media Number of NANDFLASH
+	unsigned int		MAX_ROMSize;
+	unsigned int		ExtendedPartitionNum;
+	unsigned int		ExtPartitionSize[12];
+	unsigned int		ExtPartitionWCacheNum[12];
+	unsigned int		ROAreaSize;
+	unsigned short int  		PBpV;				// Physical all Block Number
+	unsigned short int  		PpB;				// Page Number Per Block
+	unsigned short int  		PageSize;			// Page Size
+	unsigned short int  SpareSize;		
+} NAND_DEVICE_INFO, *pNAND_DEVICE_INFO;
+
+typedef struct _tag_NAND_DISK_INFO_T {
+	unsigned int	bootSize_MB;
+	unsigned int	diskSize_MB;
+} NAND_DISK_INFO_T;
+
+//==============================================================
+//
+//		Global Variables
+//
+//==============================================================
+extern FWDN_DEVICE_INFORMATION		FWDN_DeviceInformation;
+extern unsigned int					gFWDN_DRV_ErrorCode;
+
+#define FWDN_DRV_GetErrorCode()		gFWDN_DRV_ErrorCode
+#define FWDN_DRV_ClearErrorCode()	gFWDN_DRV_ErrorCode = 0
+#define FWDN_DRV_SetErrorCode(a)	gFWDN_DRV_ErrorCode = a
+
+//==============================================================
+//
+//		Function Prototypes
+//
+//==============================================================
+void						initSourcePosition(void);
+
+//void						FWDN_CheckOption(void);
+
+// for Device
+void						FWDN_DRV_Reset(void);
+int							FWDN_DRV_SessionStart(void);
+int							FWDN_DRV_SessionEnd(unsigned int bSuccess);
+int							FWDN_DRV_Init(unsigned int bmFlag, const FXN_FWDN_DRV_Progress fxnFwdnDrvProgress, char *message, unsigned int messageSize);
+pFWDN_DEVICE_INFORMATION	FWDN_DRV_GetDeviceInfo(void);
+int							FWDN_DRV_SerialNumberWrite(unsigned char *serial, unsigned int overwrite);
+int							FWDN_DRV_FirmwareWrite(unsigned int fwSize, FXN_FWDN_DRV_FirmwareWrite_ReadFromHost fxnFWDN_DRV_FirmwareWrite_ReadFromHost);
+int							FWDN_DRV_FirmwareWrite_Read(unsigned char *buff, unsigned int size, unsigned int percent);
+
+#if 0//TNFTL_V7_INCLUDE
+int 						FWDN_DRV_NAND_GANG_Format(void);
+int							FWDN_DRV_NAND_GANG_Write( NAND_PART_INFO *sNandPartInfo, FXN_FWDN_DRV_RquestData fxnFwdnDrvRequestData );
+#endif
+
+// for Disk
+int							FWDN_DRV_AREA_Write(char *name, unsigned int lba, unsigned int nSector, FXN_FWDN_DRV_RquestData fxnFwdnDrvRequestData);
+int							FWDN_DRV_AREA_CalcCRC( char *name
+													,unsigned int lba
+													,unsigned int nSector
+													,unsigned int *pCrc
+													,FXN_FWDN_DRV_SendStatus fxnFwdnDrvSendStatus );
+
+unsigned char				FWDN_DRV_DUMP_InfoRead(void *pBuf);
+int							FWDN_DRV_DUMP_BlockRead(unsigned int Param0, unsigned int Param1, unsigned int Param2, 
+																	FXN_FWDN_DRV_Response_RequestData fxnFwdnDrvResponseRequestData,
+																	FXN_FWDN_DRV_SendToHost fxnFwdnDrvSendToHost);
+int							FWDN_DRV_DUMP_BlockWrite(unsigned int Param0, unsigned int Param1, unsigned int Param2, 
+																	FXN_FWDN_DRV_Response_RequestData fxnFwdnDrvResponseRequestData,
+																	FXN_FWDN_DRV_ReadFromHost fxnFwdnDrvReadFromHost);
+
+unsigned int				FWDN_FNT_SetSN(unsigned char* ucTempData, unsigned int uiSNOffset);
+void						FWDN_FNT_VerifySN(unsigned char* ucTempData, unsigned int uiSNOffset);
+void						FWDN_FNT_InsertSN(unsigned char *pSerialNumber);
+unsigned char				FWDN_DRV_FirmwareStorageID(void);
+#endif	// _FWDN_DRV_V7_H_
+
+/* end of file */
+
diff --git a/drivers/block/tcc/inc/fwdn/fwdn_protocol_v3.h b/drivers/block/tcc/inc/fwdn/fwdn_protocol_v3.h
index b0ffbae..f330e29 100644
--- a/drivers/block/tcc/inc/fwdn/fwdn_protocol_v3.h
+++ b/drivers/block/tcc/inc/fwdn/fwdn_protocol_v3.h
@@ -10,47 +10,48 @@
 ////////////////////////////////////////////////////////////////////////////
 //		FWDN Command
 ////////////////////////////////////////////////////////////////////////////
-#define FWDN_CMD_NONE						0x0000
-#define FWDN_CMD_UBS_PING					0x0001
-#define FWDN_CMD_UBS_INITCODE_LOAD			0x0002
-#define FWDN_CMD_UBS_ROM_LOAD				0x0003
-
-#define FWDN_CMD_PING						0x0100
-#define FWDN_CMD_DEVICE_RESET				0x0101
-#define FWDN_CMD_DEVICE_SETTING				0x0102
-#define FWDN_CMD_DEVICE_INFO_READ			0x0103
-#define FWDN_CMD_SERIAL_NUMBER_WRITE		0x0104
-#define FWDN_CMD_FIRMWARE_WRITE				0x0105
-#define FWDN_CMD_SESSION_START				0x0106
-#define FWDN_CMD_SESSION_END				0x0107
-
-#define FWDN_CMD_DISK_SELECT				0x0200
-#define FWDN_CMD_DISK_INIT					0x0201
-#define FWDN_CMD_DISK_INFO_READ				0x0202
-
-#define FWDN_CMD_DISK_HIDDEN_INFO_READ		0x0210
-#define FWDN_CMD_DISK_HIDDEN_CLEAN			0x0211
-#define FWDN_CMD_DISK_HIDDEN_WRITE			0x0212
-
-#define FWDN_CMD_DISK_MTD_WRITE				0x0214
-
-#define FWDN_CMD_DISK_READ					0x0220
-#define FWDN_CMD_DISK_WRITE					0x0221
-
-#define FWDN_CMD_DISK_FS_PARTITION			0x0230
-#define FWDN_CMD_DISK_FS_MOUNT				0x0231
-#define FWDN_CMD_DISK_FS_FORMAT				0x0232
-#define FWDN_CMD_DISK_FS_MKDIR				0x0233
-#define FWDN_CMD_DISK_FS_CHDIR				0x0234
-#define FWDN_CMD_DISK_FS_FILE_WRITE			0x0235
-
-#define FWDN_CMD_DISK_DUMP_INFO_READ		0x0240
-#define FWDN_CMD_DISK_DUMP_BLOCK_READ		0x0241
-
-#define	FWDN_CMD_TEST_SEND					0x0300
-#define FWDN_CMD_TEST_RECEIVE				0x0301
-
-#define FWDN_CMD_TNFTL_V5_DEBUG				0x0F00
+#define FWDN_CMD_NONE							0x0000
+#define FWDN_CMD_UBS_PING						0x0001
+#define FWDN_CMD_UBS_INITCODE_LOAD				0x0002
+#define FWDN_CMD_UBS_ROM_LOAD					0x0003
+
+#define FWDN_CMD_PING							0x0100
+#define FWDN_CMD_DEVICE_RESET					0x0101
+#define FWDN_CMD_DEVICE_SETTING					0x0102
+#define FWDN_CMD_DEVICE_INFO_READ				0x0103
+#define FWDN_CMD_SERIAL_NUMBER_WRITE			0x0104
+#define FWDN_CMD_FIRMWARE_WRITE					0x0105
+#define FWDN_CMD_SESSION_START					0x0106
+#define FWDN_CMD_SESSION_END					0x0107
+
+#define FWDN_CMD_DISK_SELECT					0x0200
+#define FWDN_CMD_DISK_INIT						0x0201
+#define FWDN_CMD_DISK_INFO_READ					0x0202
+
+#define FWDN_CMD_DISK_HIDDEN_INFO_READ			0x0210
+#define FWDN_CMD_DISK_HIDDEN_CLEAN				0x0211
+#define FWDN_CMD_DISK_HIDDEN_WRITE				0x0212
+#define FWDN_CMD_DISK_HIDDEN_READ				0x0213
+#define FWDN_CMD_DISK_MTD_WRITE					0x0214
+
+#define FWDN_CMD_DISK_DATA_PARTITION			0x0220
+#define FWDN_CMD_DISK_DATA_READ					0x0221
+#define FWDN_CMD_DISK_DATA_WRITE				0x0222
+#define FWDN_CMD_DISK_DATA_IMAGE_WRITE			0x0223
+
+#define FWDN_CMD_DISK_DATA_FS_MOUNT				0x0230
+#define FWDN_CMD_DISK_DATA_FS_FORMAT			0x0231
+#define FWDN_CMD_DISK_DATA_FS_MKDIR				0x0232
+#define FWDN_CMD_DISK_DATA_FS_CHDIR				0x0233
+#define FWDN_CMD_DISK_DATA_FS_FILE_WRITE		0x0234
+
+#define FWDN_CMD_DISK_DUMP_INFO_READ			0x0240
+#define FWDN_CMD_DISK_DUMP_BLOCK_READ			0x0241
+
+#define	FWDN_CMD_TEST_SEND						0x0300
+#define FWDN_CMD_TEST_RECEIVE					0x0301
+
+#define FWDN_CMD_TNFTL_V5_DEBUG					0x0F00
 
 
 ////////////////////////////////////////////////////////////////////////////
diff --git a/drivers/block/tcc/inc/fwdn/fwdn_protocol_v7.h b/drivers/block/tcc/inc/fwdn/fwdn_protocol_v7.h
new file mode 100644
index 0000000..a09e0dc
--- /dev/null
+++ b/drivers/block/tcc/inc/fwdn/fwdn_protocol_v7.h
@@ -0,0 +1,121 @@
+#ifndef __FWDN_PROTOCOL_V7__
+#define __FWDN_PROTOCOL_V7__
+
+////////////////////////////////////////////////////////////////////////////
+//
+//				FWDN Protocol V7
+//
+////////////////////////////////////////////////////////////////////////////
+#define FEATURE_FWDN_COMM_VTC
+
+
+////////////////////////////////////////////////////////////////////////////
+//		FWDN Command
+////////////////////////////////////////////////////////////////////////////
+#define FWDN_CMD_NONE							0x0000
+
+#define FWDN_CMD_UBS_PING						0x0001
+#define FWDN_CMD_UBS_INITCODE_LOAD				0x0002
+#define FWDN_CMD_UBS_ROM_LOAD					0x0003
+
+#define FWDN_CMD_DEVICE_RESET					0x0100
+#define FWDN_CMD_DEVICE_PING					0x0101
+#define FWDN_CMD_DEVICE_INIT					0x0102
+#define FWDN_CMD_DEVICE_INFO_READ				0x0103
+#define FWDN_CMD_DEVICE_SESSION_START			0x0104
+#define FWDN_CMD_DEVICE_SESSION_END				0x0105
+#define FWDN_CMD_DEVICE_SERIAL_NUMBER_WRITE		0x0106
+#define FWDN_CMD_DEVICE_FIRMWARE_WRITE			0x0107
+
+#define FWDN_CMD_AREA_INFO_READ					0x0200
+#define FWDN_CMD_AREA_WRITE						0x0201
+#define FWDN_CMD_AREA_READ						0x0202
+#define FWDN_CMD_AREA_CALC_CRC					0x0203
+
+#define FWDN_CMD_DUMP_INFO_READ					0x0300
+#define FWDN_CMD_DUMP_BLOCK_READ				0x0301
+#define FWDN_CMD_DUMP_BLOCK_WRITE				0x0302
+
+#define FWDN_CMD_TNFTL_V5_DEBUG					0x0F00
+
+#define FWDN_CMD_NAND_GANG_CLEAR				0x1000
+#define FWDN_CMD_NAND_GANG_WRITE				0x1001
+
+#define	FWDN_CMD_TEST_SEND						0xEF00
+#define FWDN_CMD_TEST_RECEIVE					0xEF01
+
+/////////////////////////////////////////////////////////
+//	0xF000 ~ 0xFFFF is reserved for vendor
+/////////////////////////////////////////////////////////
+
+
+////////////////////////////////////////////////////////////////////////////
+//		FWDN Response Ack Type
+////////////////////////////////////////////////////////////////////////////
+#define FWDN_RSP_NACK						0x00
+#define FWDN_RSP_ACK						0x01
+#define FWDN_RSP_NYET						0x02
+
+
+////////////////////////////////////////////////////////////////////////////
+//		FWDN Command / Response Signatures
+////////////////////////////////////////////////////////////////////////////
+#define FWDN_COMMAND_SIGNATURE				0x43445746L		//"FWDC" ; FWDn Command
+#define FWDN_RESPONSE_SIGNATURE				0x52445746L		//"FWDR" ; FWDn Response
+
+
+#define FWDN_EXTRA_RSP_MAX_SIZE				0xFF
+
+
+#if defined(_WINCE_)
+#pragma pack(push, 1)
+#endif
+
+typedef struct _tag_FWDN_COMMAND_T
+{
+	unsigned long	Signature;
+	unsigned short	CmdType;
+	unsigned short	SubCmdType;
+	unsigned long	ExtraCmdSize;
+	unsigned long	Param0;
+	unsigned long	Param1;
+	unsigned long	Param2;
+	unsigned long	Param3;
+	unsigned long	Param4;
+
+#if defined(_LINUX_)
+} __attribute__((packed)) FWDN_COMMAND_T;
+#else
+} FWDN_COMMAND_T;
+#endif
+
+typedef struct _tag_FWDN_RESPONSE_T
+{
+	unsigned long	Signature;
+	unsigned short	CmdType;
+	unsigned char	AckType;
+	unsigned char	reserved;
+ 	unsigned long	DataSize;
+	unsigned long	Param0;
+	unsigned long	Param1;
+	unsigned long	Param2;
+
+#if defined(_LINUX_)
+} __attribute__((packed)) FWDN_RESPONSE_T;
+#else
+} FWDN_RESPONSE_T;
+#endif
+
+#if defined(_WINCE_)
+#pragma pack(pop)
+#endif
+
+typedef enum {
+	FWDN_COMM_VTC,
+	FWDN_COMM_CDC
+} FWDN_COMM_T;
+
+void FWDN_PROT_SetComm(FWDN_COMM_T commType);
+void FWDN_PROT_CheckCommand(void);
+
+#endif //__FWDN_PROTOCOL_V4__
diff --git a/drivers/block/tcc/inc/fwdn/fwupgrade.h b/drivers/block/tcc/inc/fwdn/fwupgrade.h
index dfa4ff0..3ee0915 100644
--- a/drivers/block/tcc/inc/fwdn/fwupgrade.h
+++ b/drivers/block/tcc/inc/fwdn/fwupgrade.h
@@ -139,10 +139,10 @@ extern int						FWUG_ReadDATA(unsigned int uDest, void *uHandler, unsigned int u
 extern unsigned int				CalCRC_ROMFile(unsigned int *pBuffer,unsigned int size,unsigned int crcout, unsigned int mode);
 extern int						FWUG_VerifySerialNumber(unsigned char* ucBuf, unsigned int uiOffset);
 
-extern unsigned int				FWUG_CalcCrc(unsigned int *base, unsigned int length, unsigned int *crctable);
+extern unsigned int				FWUG_CalcCrc(unsigned int *base, unsigned int length, const unsigned int *crctable);
 extern unsigned int				FWUG_CalcCrc8(unsigned char *base, unsigned int length, const unsigned int *crctable);
-extern unsigned int				FWUG_CalcCrcI(unsigned uCRCIN, unsigned *base, unsigned int length, unsigned int *crctable);
-extern unsigned int				FWUG_CalcCrc8I(unsigned uCRCIN, unsigned char *base, unsigned int length, unsigned int *crctable);
+extern unsigned int				FWUG_CalcCrcI(unsigned uCRCIN, unsigned *base, unsigned int length, const unsigned int *crctable);
+extern unsigned int				FWUG_CalcCrc8I(unsigned uCRCIN, unsigned char *base, unsigned int length, const unsigned int *crctable);
 
 /* TFLASH */
 extern unsigned int				FwdnReadTriflashFirmware(unsigned int master);
diff --git a/drivers/block/tcc/inc/tnftl/kernel_nand_drv.h b/drivers/block/tcc/inc/tnftl/kernel_nand_drv.h
new file mode 100644
index 0000000..16d4070
--- /dev/null
+++ b/drivers/block/tcc/inc/tnftl/kernel_nand_drv.h
@@ -0,0 +1,138 @@
+/****************************************************************************
+ *   FileName    :  Kernel_nand_drv.h
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+#ifndef __TCC_NDD_H
+#define __TCC_NDD_H
+
+#include "nand_drv.h"
+#include "IO_TCCXXX.h"
+
+//*****************************************************************************
+//*
+//*
+//*                          [ INTERNAL DEFINATION ]
+//*
+//*
+//*****************************************************************************
+
+//===================================================================
+// IOCTL
+//===================================================================
+#define IOCTL_NDD_GET_INFO			_IO(NDD_DEV_MAJOR, 1)
+#define IOCTL_NDD_MULTI_HD_WRITE	_IO(NDD_DEV_MAJOR, 2)
+#define IOCTL_NDD_MULTI_HD_READ		_IO(NDD_DEV_MAJOR, 3)
+#define IOCTL_NDD_BOOT_WRITE		_IO(NDD_DEV_MAJOR, 4)
+#define IOCTL_NDD_HD_WRITE			_IO(NDD_DEV_MAJOR, 5)
+#define IOCTL_NDD_HD_READ			_IO(NDD_DEV_MAJOR, 6)
+#define IOCTL_NDD_ALIGN_CACHE		_IO(NDD_DEV_MAJOR, 7)
+#define IOCTL_NDD_GET_SERIALNUMBER  _IO(NDD_DEV_MAJOR, 8)
+
+#define INTR_MODE_NORMAL		0
+#define INTR_MODE_READ_PAGE		1
+#define INTR_MODE_READ_ECC		2
+#define INTR_MODE_WRITE_PAGE	3
+#define INTR_MODE_WRITE_ECC		4
+
+#define NDD_RB_INTR_MODE_NORMAL	0
+#define NDD_RB_INTR_MODE_READ	1
+#define NDD_RB_INTR_MODE_WRITE	2
+
+
+//*****************************************************************************
+//*
+//*
+//*                       [ INTERNAL STRUCT DEFINE ]
+//*
+//*
+//*****************************************************************************
+typedef struct _nand_priv_data_t
+{
+    struct task_struct *thread;
+    struct request_queue *req;
+	struct scatterlist	*sg;	
+} nand_priv_data_t;
+
+struct dma_buf 
+{
+	void 					*v_addr;
+	unsigned int 			dma_addr;
+	int 					buf_size;
+};
+
+struct ndd_data 
+{
+	loff_t 					i_size;
+};
+
+struct ndd_hidden_info 
+{
+	unsigned int 		 	DriveNum;		// # of multi-hidden area (0~2) - ONLY multi hidden
+	unsigned int  			HiddenAddress;	// start page offset
+	unsigned int  			SectorNum;		// write/read page size
+	unsigned char 			*DataBuffer;	// buffer
+	unsigned int  			DataBufferSize;	// buffer size
+};
+
+struct ndd_boot_info
+{
+	char 					*buf;			// bootloader buffer
+	unsigned int 			len;			// bootloader length
+};
+
+typedef struct __tag_ndd_dev
+{
+	int						size;
+	u8			 			*data;
+	short					users;
+	short					media_change;
+	struct request_queue 	*queue;
+	spinlock_t				lock;
+	struct gendisk 			*gd;
+	struct timer_list		timer;
+	char 					*buf;
+	ndd_work_info 			*nand_work_info;
+}Device;
+
+typedef struct __tag_NAND_intr_info_rb
+{
+    PNFC 					p_nfc;
+    PGPIO 					p_gpio;
+	PPIC 					pPIC;
+    wait_queue_head_t 		nd_busy_wait_q;
+    int 					is_nd_busy_complete;
+    int 					irq;
+	U32						current_nr_sectors;
+	U32						nSectorIndex;
+	U32 					nPageIndex;
+	U16 					nStartPPage;
+	U16 					nReadPPSize;
+	U16						nCurrPPage;
+	U8 						intr_mode;
+	U8 						*nPageBuffer;
+	U8 						*nSpareBuffer;
+	U8 						*nEccBuffer;
+	U8 						*nStuffPageBuffer;
+	NAND_IO_DEVINFO 		*nDevInfo;
+	ndd_work_info 			*nWorkInfo;
+	struct request_queue 	*request_q;
+	struct request 			*req;
+} nand_intr_info_rb;
+
+typedef struct __tag_NAND_intr_info
+{
+    PNFC 					p_nfc;
+    wait_queue_head_t 		tx_wait_q;
+    wait_queue_head_t 		rx_wait_q;
+    int 					is_rx_complete;
+	int						is_tx_complete;
+    int 					irq;
+} nand_intr_info;
+
+#endif
diff --git a/drivers/block/tcc/inc/tnftl/nand_drv.h b/drivers/block/tcc/inc/tnftl/nand_drv.h
index 5e155d2..18b4498 100644
--- a/drivers/block/tcc/inc/tnftl/nand_drv.h
+++ b/drivers/block/tcc/inc/tnftl/nand_drv.h
@@ -186,8 +186,8 @@ typedef enum
 #define NAND_TYPE_PURE_NAND							0
 #define NAND_TYPE_LBA_NAND							1
 
-#define TNFTL_MAX_SUPPORT_RCACHE_MEMORY_SIZE		16384
-#define TNFTL_MAX_SUPPORT_ALIGNCACHE_MEMORY_SIZE	16384					
+#define TNFTL_MAX_SUPPORT_RCACHE_MEMORY_SIZE		32768
+#define TNFTL_MAX_SUPPORT_ALIGNCACHE_MEMORY_SIZE	32768					
 
 #define	MAX_ROMSIZE_NAND							0x200000
 
@@ -195,7 +195,14 @@ typedef enum
 #define NAND_HIDDEN_DRIVE_DEFAULT_TOTAL_SECTOR_SIZE	((2*1024*1024UL)/512UL)
 
 #define	MAX_ROMSIZE_NAND							0x200000
-					
+
+#define TCC_NAND_TRACE_ALL           0x0F
+#define TCC_NAND_TRACE_DRV_WRITE     0x01
+#define TCC_NAND_TRACE_DRV_READ      0x02
+#define TCC_NAND_TRACE_DRV_ALL       0x03
+#define TCC_NAND_TRACE_TNFTL_ALL     0x07
+#define TCC_NAND_TRACE_OFF           0x00
+
 //*****************************************************************************
 //*
 //*
@@ -242,11 +249,11 @@ typedef	struct	__tag_TNFTL_HiddenSizeInfo
 //*****************************************************************************
 extern NAND_DRVINFO				gNAND_DrvInfo[MAX_NAND_DRIVE];
 extern TNFTL_EXT_PART_INFO		gTNFTL_ExtPartitionInfo[MAX_NAND_DRIVE];
-extern NAND_IO_DEVINFO			*gLBA_DevInfo;
+extern NAND_IO_DEVINFO*  gLBA_DevInfo[4];
 #else
 extern NAND_DRVINFO				gNAND_DrvInfo[MAX_NAND_DRIVE];
 extern TNFTL_HIDDEN_INFO		gTNFTL_HiddenInfo[MAX_NAND_DRIVE];
-extern NAND_IO_DEVINFO			*gLBA_DevInfo;
+extern NAND_IO_DEVINFO*  gLBA_DevInfo[4];
 #endif
 
 //*****************************************************************************
@@ -259,6 +266,7 @@ extern NAND_IO_DEVINFO			*gLBA_DevInfo;
 extern void			NAND_Init( void );
 extern void 		NAND_InitHiddenInfo( void );
 extern void 		NAND_SetFlagOfChangeAreaSize( unsigned char On_Off );
+extern int			NAND_LowLevelFormat( int mode );
 
 extern NAND_ERROR	NAND_InitDrive( int nDrvNo );
 
@@ -275,6 +283,8 @@ extern int			NAND_WriteMultiSectorStart( U32 LBA, U32 nSecSize );
 extern int			NAND_WriteMultiSectorStop( void );
 extern int			NAND_HDClearPages( U32 nHDStPageAddr, U32 nHDEdPageAddr );
 
+extern int 			NAND_ReadSectorIRQ( int nDrvNo, ndd_work_info* nand_work_info );
+extern int 			NAND_WriteSectorIRQ( int nDrvNo, ndd_work_info* nand_work_info );
 extern int			NAND_HDReadSector( int nDrvNo, U32 LBA, U32 nSecSize, void* nReadBuffer );
 extern int			NAND_HDWriteSector( int nDrvNo, U32 LBA, U32 nSecSize, void* nWriteBuffer );
 extern int			NAND_HDIoctl( int function, void *param );
@@ -282,6 +292,5 @@ extern int			NAND_HDIoctl( int function, void *param );
 extern U16			NAND_GetSerialNumber( U8* rSerialNumber, U16 nSize );
 extern U16			NAND_GetUniqueID( U8* rSerialNumber, U16 nSize );
 extern TNFTL_ERROR	NAND_SetUartDebug( unsigned int on_off );
-
 #endif
 
diff --git a/drivers/block/tcc/inc/tnftl/nand_io_v7.h b/drivers/block/tcc/inc/tnftl/nand_io_v7.h
index a41c835..aa12d22 100644
--- a/drivers/block/tcc/inc/tnftl/nand_io_v7.h
+++ b/drivers/block/tcc/inc/tnftl/nand_io_v7.h
@@ -11,6 +11,17 @@
 #ifndef __NAND_IO_H
 #define __NAND_IO_H
 
+#if defined(USE_V_ADDRESS)
+	#if defined(_LINUX_)
+	#define __USE_NAND_ISR__
+	//#define __USE_NAND_ISR_WRITE__
+	#elif defined(_WINCE_)
+	//#define __USE_NAND_ISR__
+	#endif
+#endif
+
+//#define NAND_GPIO_DEBUG
+
 //*****************************************************************************
 //*
 //*
@@ -51,6 +62,17 @@
 #endif
 
 //**********************************************************************
+//*		Define IRQ
+//**********************************************************************
+#define NAND_IRQ_NFC			IRQ_NFC
+
+#ifdef TCC89_92_BOARD
+#define NAND_IRQ_READY			IRQ_EI0		// External interrupt 3
+#else
+#define NAND_IRQ_READY			IRQ_EI0
+#endif
+
+//**********************************************************************
 //*		Define ECC Algorithm for ChipSet
 //**********************************************************************
 #if defined(TCC77X) || defined(TCC87XX) || defined(TCC82XX) || defined(TCC78X) || defined(TCC83XX) || defined(TCC79XX)
@@ -62,8 +84,11 @@
 #if defined(USE_V_ADDRESS)
 	#if defined(_LINUX_)
 	#define  ND_TRACE	printk
+	//#define n_printk(f, a...)    printk("[%s:%d] " f, __func__, __LINE__, ##a) 
+	#define n_printk(f, a...)
 	#elif defined(_WINCE_)
-	//#define  ND_TRACE(a)		RETAILMSG(1, a)
+		#define  ND_TRACE	printf
+//		#define  ND_TRACE
 	#endif
 #else
 	#if defined(_LINUX_)
@@ -233,7 +258,11 @@ typedef enum
 	ERR_NAND_IO_NOT_READY_DEVICE_IO,
 	ERR_NAND_IO_FAILED_WRITE,
 	ERR_NAND_IO_NOT_EXIST_LBA_HEADBLOCK,
-	ERR_NAND_IO_FAILED_LBA_PARTITION_CHANGE
+	ERR_LBA_NOT_EXIST_MEDIA_NUM_INFO,
+	ERR_LBA_NOT_EXIST_NANDFLASH,
+	ERR_NAND_IO_FAILED_LBA_GET_MEDIA_UID,
+	ERR_NAND_IO_FAILED_LBA_PARTITION_CHANGE,
+	ERR_LBA_FAILED_CONVERT_LBA_ADDR
 } NAND_IO_ERROR;
  
 //*****************************************************************************
@@ -252,6 +281,7 @@ enum SUPPORT_MAKER_NAND
 	HYNIX,
 	ST,
 	MICRON,
+	INTEL,
 	MAX_SUPPORT_MAKER_NAND
 };
 
@@ -291,12 +321,14 @@ enum LBA_NAND_HIDDEN_INFO
 #define HYNIX_NAND_MAKER_ID						0xAD
 #define ST_NAND_MAKER_ID						0x20
 #define MICRON_NAND_MAKER_ID					0x2C
+#define INTEL_NAND_MAKER_ID						0x89
 
-#define MAX_SUPPORT_SAMSUNG_NAND				26
+#define MAX_SUPPORT_SAMSUNG_NAND				28
 #define MAX_SUPPORT_TOSHIBA_NAND				17
-#define MAX_SUPPORT_HYNIX_NAND					25
-#define MAX_SUPPORT_ST_NAND						14
-#define MAX_SUPPORT_MICRON_NAND					12
+#define MAX_SUPPORT_HYNIX_NAND					27
+#define MAX_SUPPORT_ST_NAND						15
+#define MAX_SUPPORT_MICRON_NAND					13
+#define MAX_SUPPORT_INTEL_NAND					 1
 	
 /* LBA NAND FLASH */
 #define MAX_SUPPORT_TOSHIBA_LBA_NAND			3
@@ -310,7 +342,7 @@ enum LBA_NAND_HIDDEN_INFO
 #define A_MLC									0x00000020		// Multi Layer Cell
 #define A_MLC_8BIT								0x00000040		// 8Bit MLC ECC
 #define A_MLC_12BIT								0x00000080		// 12Bit MLC ECC
-#define A_MLC_16BIT								0x00000100		// 12Bit MLC ECC
+#define A_MLC_16BIT								0x00000100		// 16Bit MLC ECC
 
 #define A_PARALLEL								0x00000200		// Parallel Composition
 #define A_DATA_WITDH_08BIT						0x00000400		// Data 8Bit Bus
@@ -329,6 +361,7 @@ enum LBA_NAND_HIDDEN_INFO
 #define S_MP_READ								0x04000000		// MULTI PLANE READ
 #define S_LBA									0x08000000		// LBA NAND
 #define S_RAND_IO								0x10000000		// Random Data In/Out
+#define S_EB									0x20000000		// Extend Block 
 
 #define NAND_IO_NORMAL_PAGE_PROGRAM				0x00000001
 #define NAND_IO_CACHE_PROGRAM_1ST				0x00000002
@@ -359,6 +392,8 @@ enum LBA_NAND_HIDDEN_INFO
 
 #define	ECC_OFF                     			0
 #define	ECC_ON                      			1
+#define	ECC_ON_NON_CACHE_BUF           			3
+
 #define SLC_ECC_TYPE							0x0001			// 10 Byte
 #define MLC_ECC_4BIT_TYPE						0x0002			// BCH: 7 Byte( 52 bit)	turn: 2, byte remain: 3, register mask: 0x0F
 #define MLC_ECC_8BIT_TYPE						0x0004			// BCH:13 Byte (104 bit)	turn: 4, byte remain: 1, register mask: 0xFF
@@ -474,8 +509,11 @@ typedef struct {
 #define ECC_ENCODE								1
 #define	INTER_LEAVE_OFF                			0
 #define	INTER_LEAVE_ON                			1
-#define MULTI_PLANE_MID_PAGE					0
-#define MULTI_PLANE_LAST_PAGE					1
+#define MULTI_PLANE_NORMAL_PAGE					0
+#define MULTI_PLANE_START_PAGE					1
+#define MULTI_PLANE_MID_PAGE					2
+#define MULTI_PLANE_LAST_PAGE					3
+#define MULTI_PLANE_STUFF_PAGE					4
 #define MULTI_PLANE_GOOD_BLOCK					0
 #define MULTI_PLANE_BAD_BLOCK					1
 
@@ -493,6 +531,7 @@ typedef struct {
 #define NAND_IO_LOG_COLUMN_IN_SPARE				1
 
 /* LBA NAND DEFINATION : [STATUS READ 2] */
+#define LBA_MAX_SUPPORT_MULTI_NANDFLASH			4
 #define NAND_LBA_PNP							0x00
 #define NAND_LBA_BCM							0x02
 #define NAND_LBA_VFP							0x04
@@ -535,6 +574,8 @@ typedef struct {
 #define NAND_PROT2_WRITE_TYPE_A					0x00
 #define NAND_PROT2_WRITE_TYPE_B					0x04
 
+#define NAND_LBA_SYS_SECTION					2
+#define	NAND_LBA_MAX_NANDFLASH_UID_SIZE			16
 #define NAND_LBA_MAX_SUPPORT_MHD_AREA_NUM		10
 
 typedef void (*NAND_LBA_CALLBACK_HANDLER) ( U16 nDrvNo, U16 nStatusCode, U32 wParam );
@@ -686,11 +727,15 @@ typedef struct __tag_NAND_IO_LBADevInfo
 	unsigned char				SectorCount;
 	unsigned char 				DataTransferCheck;
 	unsigned char 				FlagOfChangeTotalSectorSize;
+	unsigned char				MediaUniqueID[NAND_LBA_MAX_NANDFLASH_UID_SIZE];
 
 	unsigned long int			VFPSectorSize;		// NBArea
 	
 	unsigned long int			MDPSectorSize;		// RWArea Totla Sector Size
+
 	unsigned long int			DTAreaSectorSize;	// RWArea
+	unsigned long int			DTAreaAddrOffSet;
+
 	unsigned long int			HDAreaSectorSize;	// RWArea
 	unsigned long int			HDAreaAddrOffSet;
 
@@ -755,12 +800,43 @@ typedef struct __tag_NAND_IO_DevInfo
 
 	unsigned long int			RemapPageWeight[4];
 
+	unsigned long int			PrePageAddr;
+	unsigned short int			PreStartPPage;
+	unsigned short int			PreChipNo;
+
+	unsigned char				DirectRead;
 	NAND_IO_WRITESTATUS			WriteStatus;
 		
 	NAND_IO_BADBLOCK			BadBlockInfo;
 	NAND_IO_LBADEVINFO			LBAInfo;
 } NAND_IO_DEVINFO;
 
+#define MAX_NAND_WORK_SECTOR_NUM	512
+
+typedef	struct __tag_WriteStuffInfo {
+	unsigned short int		StuffInfoNum;
+	unsigned short int		StartPPageNo[MAX_NAND_WORK_SECTOR_NUM];
+	unsigned short int		SectorSize[MAX_NAND_WORK_SECTOR_NUM];
+	unsigned char			*nStuffPageBuffer;
+} ndd_stuff_info;
+
+typedef	struct __tag_NanddWorkInfo {
+	unsigned int 			SectorNum;		// Total Sector Num
+	unsigned int			StartSector;
+	unsigned int			BufferAddr[MAX_NAND_WORK_SECTOR_NUM];
+
+	unsigned int			PhyPageNum;
+	unsigned int			PhyPageAddr[MAX_NAND_WORK_SECTOR_NUM];
+	unsigned char			ChipNo[MAX_NAND_WORK_SECTOR_NUM];
+	unsigned short int		StartPPageNo[1024];
+	unsigned short int		PPageSize[1024];	// TNFTL_MAX_SUPPORT_NAND_IO_PAGE_SIZE_PER_1BLOCK
+	unsigned int			FTLPPage;
+	unsigned char			PageWriteFunc[1024];
+	ndd_stuff_info			StuffInfo;
+	unsigned char			*nSpareBuffer;
+	NAND_IO_DEVINFO			*nDevInfo;
+} ndd_work_info;
+
 typedef struct __tag_NAND_IO_MakerInfo
 {
 	unsigned short int			MaxSupportNAND[MAX_SUPPORT_MAKER_NAND];
@@ -838,18 +914,49 @@ extern NAND_IO_ERROR		NAND_IO_GetUID( NAND_IO_DEVINFO *nDevInfo, U16 *nCmd, U8 *
 extern NAND_IO_ERROR		NAND_IO_WaitBusyCheckForWriteEnd( NAND_IO_DEVINFO *nDevInfo );
 
 extern NAND_IO_ERROR 		NAND_IO_EncDecodeBinary( unsigned int nEncDec, unsigned int nEccType, unsigned int nDataSize, U8 *nPageBuffer, U8 *nEccBuffer );
+extern void 				NAND_IO_SetInterLeavePageAddr(U32 nPageAddr );
+extern void 				NAND_IO_SetInterleaveStatus( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr );
+
+extern NAND_IO_ERROR 		NAND_IO_IRQ_ReadPagePreProcess( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U16 nStartPPage, U32 *rEccBuffer, U16 nChipNo );
+extern void 				NAND_IO_IRQ_ReadPagePostProcess( void );
+extern void 				NAND_IO_IRQ_Read512DataPreProcess( NAND_IO_DEVINFO *nDevInfo );
+extern NAND_IO_ERROR 		NAND_IO_IRQ_Read512DataPostProcess( NAND_IO_DEVINFO *nDevInfo, U8* nPageBuffer, U8* nSpareBuffer );
+
+extern NAND_IO_ERROR 		NAND_IO_IRQ_WritePagePreProcess( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U16 nStartPPage, U8 *nSpareBuffer, U32 *rEccBuffer, U16 nChipNo, U8 nWriteMode );
+extern void	 				NAND_IO_IRQ_WritePageMidProcess( NAND_IO_DEVINFO *nDevInfo, U8 nWriteMode );
+extern void				 	NAND_IO_IRQ_WritePagePostProcess( void );
+void 						NAND_IO_IRQ_Write512DataPreProcess( NAND_IO_DEVINFO *nDevInfo );
+extern NAND_IO_ERROR 		NAND_IO_IRQ_Write512DataPostProcess( NAND_IO_DEVINFO *nDevInfo, U8* nECCBuffer );
+
+extern NAND_IO_ERROR 		NAND_IO_IRQ_ExtInterruptClear(unsigned int irq);
+
+extern void 				NAND_IO_IRQ_ReadyBusySet( void );
+extern void 				NAND_IO_IRQ_ReadyBusyClear( void );
+
+extern void 				NAND_IO_IRQ_SetupDMA( void *pDST, int nMode );
+extern void 				NAND_IO_IRQ_SetupDMAForSpare( int nDSize );
 
+extern void 				NAND_IO_WriteColAddr( U32 nColumnAddr, NAND_IO_DEVINFO *nDevInfo );
+extern void					NAND_IO_SetCommCycleTime( void );
+extern void 				NAND_IO_SetReadCycleTime(void);
+extern NAND_IO_ERROR 		NAND_IO_WriteSpareData( NAND_IO_DEVINFO *nDevInfo, U8 *nSpareBuffer, int nPageEccOnOff );
 #if defined (NAND_LBA_INCLUDE)
 extern NAND_IO_ERROR 		NAND_IO_LBA_SetCallBackHandler( NAND_LBA_CALLBACK_HANDLER pCallBackHandler );
-extern U32  			    NAND_IO_LBA_GetSerialNumber( NAND_IO_DEVINFO *nDevInfo, U8* nPageBuffer, U8* rSerialNumber, U16 nSize );
+extern NAND_IO_ERROR        NAND_IO_LBA_GetSerialNumber( NAND_IO_DEVINFO *nDevInfo, U8* nPageBuffer, U8* rSerialNumber, U16 nSize );
 extern NAND_IO_ERROR		NAND_IO_LBA_PowerSaveMode( NAND_IO_DEVINFO *nDevInfo, int nOnOff );
+extern NAND_IO_ERROR		NAND_IO_LBA_HighSpeedMode( NAND_IO_DEVINFO *nDevInfo, int nOnOff );
 extern NAND_IO_ERROR 		NAND_IO_LBA_DeviceReboot( NAND_IO_DEVINFO *nDevInfo );
 
-extern NAND_IO_ERROR 		NAND_IO_LBA_GetDeviceInfo( NAND_IO_DEVINFO *nDevInfo );
-extern NAND_IO_ERROR 		NAND_IO_LBA_Init( NAND_IO_DEVINFO *nDevInfo );
+extern NAND_IO_ERROR 		NAND_IO_LBA_GetDeviceInfo( U16 nChipNo, NAND_IO_DEVINFO *nDevInfo );
+extern NAND_IO_ERROR 		NAND_IO_LBA_GetDeviceMDPSectorSize( NAND_IO_DEVINFO *nDevInfo, unsigned long int *rTotalSector );
+extern NAND_IO_ERROR 		NAND_IO_LBA_GetDeviceMediaNums( U16 *rMediaOrder );
+extern NAND_IO_ERROR 		NAND_IO_LBA_Init( U16 nChipNo, NAND_IO_DEVINFO *nDevInfo );
+extern NAND_IO_ERROR 		NAND_IO_LBA_InitDrive( NAND_IO_DEVINFO *nDevInfo );
 extern NAND_IO_ERROR 		NAND_IO_LBA_ReadSectorBy4Byte( NAND_IO_DEVINFO *nDevInfo, U8 nPartition, U32 nSectorAddr, U16 nOffset, U16 nReadSize, U8 *nReadBuffer );
 extern NAND_IO_ERROR 		NAND_IO_LBA_ReadSector( NAND_IO_DEVINFO *nDevInfo, U8 nPartition, U32 nSectorAddr, U16 nSecSize, U8 *nReadBuffer );
+extern NAND_IO_ERROR 		NAND_IO_LBA_ReadSysSectionOfVFP( NAND_IO_DEVINFO *nDevInfo, U32 nStarAddr, U32 nReadByteSize, U8 *nPageBuffer );
 extern NAND_IO_ERROR 		NAND_IO_LBA_WriteSector( NAND_IO_DEVINFO *nDevInfo,U8 nPartition, U32 nSectorAddr, U16 nSecSize, U8 *nWriteBuffer );
+extern NAND_IO_ERROR 		NAND_IO_LBA_WriteSysSectionOfVFP( NAND_IO_DEVINFO *nDevInfo, U32 nStarAddr, U32 nWriteByteSize, U8 *nPageBuffer );
 extern NAND_IO_ERROR 		NAND_IO_LBA_AREAClear( NAND_IO_DEVINFO *nDevInfo, U8 nPartition );
 extern NAND_IO_ERROR 		NAND_IO_LBA_ModeChange( NAND_IO_DEVINFO *nDevInfo, int nMode );
 extern NAND_IO_ERROR 		NAND_IO_LBA_ScanHeaderOfVFP( NAND_IO_DEVINFO *nDevInfo );
diff --git a/drivers/block/tcc/inc/tnftl/tnftl_v7.h b/drivers/block/tcc/inc/tnftl/tnftl_v7.h
index ed0fe05..d39380b 100644
--- a/drivers/block/tcc/inc/tnftl/tnftl_v7.h
+++ b/drivers/block/tcc/inc/tnftl/tnftl_v7.h
@@ -350,7 +350,6 @@ typedef unsigned long int		TNFTL_LPT_TABLE_VALUE;
 typedef unsigned long int		TNFTL_LPT_BLOCK;
 typedef unsigned long int		TNFTL_RCACHE_SLOT;
 
-
 typedef struct __tag_TNFTL_INIT_INFO
 {
 	U8	SerialNumber[64];
@@ -361,6 +360,14 @@ typedef struct __tag_TNFTL_INIT_INFO
 	U32 ROAreaStPB;
 } TNFTL_INIT_INFO;
 
+typedef struct __tag_TNFTL_PAGE_INFO
+{
+	unsigned int				PageIndex;
+	unsigned long int			FTLPageAddr[TNFTL_MAX_SUPPORT_NAND_IO_PAGE_SIZE_PER_1BLOCK];
+	unsigned short int			StartPPageNo[TNFTL_MAX_SUPPORT_NAND_IO_PAGE_SIZE_PER_1BLOCK];
+	unsigned short int			PPageSize[TNFTL_MAX_SUPPORT_NAND_IO_PAGE_SIZE_PER_1BLOCK];
+} TNFTL_PAGE_INFO;
+
 typedef struct __tag_TNFTL_LPT
 {
 	unsigned short int			Usable;
@@ -552,6 +559,7 @@ typedef struct __tag_TNFTL_DRVINFO
 	unsigned long int 			StPBForGetEmptyPB[TNFTL_MAX_SUPPORT_MULTI_PLANE];
 	NAND_IO_DEVINFO				MediaDevInfo[TNFTL_MAX_SUPPORT_MULTI_NANDFLASH];
 
+	TNFTL_PAGE_INFO				FTLPageInfo;
 	unsigned char				*FTLPageBuffer;
 	unsigned char				*AlignCacheBuffer;
 	unsigned int				*LPTBuffer;
@@ -590,6 +598,7 @@ extern TNFTL_ERROR 				TNFTL_AllocMemAndLinkForExtendedPartition( U16 nDrvNo, TN
 extern TNFTL_ERROR				TNFTL_SetStEdOfCS( U16 nDrvNo, U16 nStartCS, U16 nEndCS );
 extern TNFTL_ERROR				TNFTL_SetExtendedPartitionNums( U16 nDrvNo, U16 nExtPartitionNums );
 
+extern TNFTL_ERROR 				TNFTL_ScanDevice( TNFTL_DRVINFO *FTLInfo );
 extern void 					TNFTL_SetNBAreaEndPBAddr( int nPhyBlockAddr );
 extern void 					TNFTL_SetROAreaSize(TNFTL_DRVINFO * FTLInfo, int nROAreaSize, int nROAreaUsable);
 extern void						TNFTL_SetAreaProtectFlag( int value );
@@ -609,7 +618,9 @@ extern TNFTL_ERROR				TNFTL_AREAGetTotalSecAndCHS( TNFTL_DRVINFO *FTLInfo, TNFTL
 extern TNFTL_ERROR				TNFTL_AREASetTotalSectorSize( TNFTL_DRVINFO *FTLInfo, TNFTL_RW_AREA *nArea, U32 nTotalSectorSize );
 extern TNFTL_ERROR				TNFTL_AREAReadSectorBy4Byte( TNFTL_DRVINFO *FTLInfo, TNFTL_RW_AREA *nArea, U32 nSectorAddr, U16 nOffset, U16 nReadSize, U8 *nReadBuffer );
 extern TNFTL_ERROR				TNFTL_AREAReadSector( TNFTL_DRVINFO *FTLInfo, TNFTL_RW_AREA *nArea, U32 nSectorAddr, U32 nSecSize, U8 *nReadBuffer );
+extern TNFTL_ERROR 				TNFTL_AREAReadSectorIRQ( TNFTL_DRVINFO *FTLInfo, TNFTL_RW_AREA *nArea, ndd_work_info *nWorkInfo );
 extern TNFTL_ERROR				TNFTL_AREAWriteSector( TNFTL_DRVINFO *FTLInfo, TNFTL_RW_AREA *nArea, U32 nSectorAddr, U32 nSecSize, U8 *nWriteBuffer );
+extern TNFTL_ERROR 				TNFTL_AREAWriteSectorIRQ( TNFTL_DRVINFO *FTLInfo, TNFTL_RW_AREA *nArea, ndd_work_info *nWorkInfo );
 extern TNFTL_ERROR				TNFTL_AREAFormat( TNFTL_DRVINFO *FTLInfo, TNFTL_RW_AREA *nArea, U16 nFormatLevel );
 extern TNFTL_ERROR				TNFTL_NBGetCRCOfImageFile( TNFTL_DRVINFO *FTLInfo, U32 nFlagSelfChecking, U32 *nOrgCRCcode1, U32 *nOrgCRCcode2, U32 *nRomFileSize, U32 *rRstCRCcode1, U32 *rRstCRCcode2 );
 extern TNFTL_ERROR 				TNFTL_NBGetCRCValueOfImageFile( TNFTL_DRVINFO *FTLInfo, U32 *nOrgCRCcode1, U32 *nOrgCRCcode2, U32 *nRomFileSize );
diff --git a/drivers/block/tcc/init_ddr2.c b/drivers/block/tcc/init_ddr2.c
index 5f82db0..c2be81a 100644
--- a/drivers/block/tcc/init_ddr2.c
+++ b/drivers/block/tcc/init_ddr2.c
@@ -17,6 +17,10 @@
 
 #if defined(DRAM_DDR2)
 
+#define DDR2_SETRCD(x) (x>3? (((x-3)<<8)| x ) : ((1<<8) | x))
+#define DDR2_SETRFC(x) (x>3? (((x-3)<<8)| x ) : ((0<<8) | x))
+#define DDR2_SETRP(x)  (x>3? (((x-3)<<8)| x ) : ((1<<8) | x))
+
 #define DRAM_AUTOPD_ENABLE Hw13
 #define DRAM_AUTOPD_PERIOD 7<<7 // must larger than CAS latency
 #define DRAM_SET_AUTOPD DRAM_AUTOPD_ENABLE|DRAM_AUTOPD_PERIOD
@@ -101,10 +105,13 @@ volatile void InitRoutine_Start(void)
 // memory arb.
 		*(volatile unsigned long *) 0xf030200c=0x00140000|DRAM_SET_AUTOPD; // config0 - qos master bits set
 // memory arb. end
+#if defined(DRAM_ROW14)
+	// ELPIDA
+		*(volatile unsigned long *)0xF030200C = 0x0015001A|DRAM_SET_AUTOPD; 		// config0 cas 10bit, ras 13bit
+#else
 	// Samsung/ Hynix	
 		*(volatile unsigned long *)0xF030200C = 0x00150012|DRAM_SET_AUTOPD; 		// config0 cas 10bit, ras 13bit
-	// ELPIDA 256MB
-	//	*(volatile unsigned long *)0xF030200C = 0x0015001A; 		// config0 cas 10bit, ras 14bit
+#endif
 			
 		*(volatile unsigned long *) 0xf0302010=0x00000445; // refresh
 #if defined(DRAM_BANK3)
@@ -146,7 +153,9 @@ volatile void InitRoutine_Start(void)
 		#if defined(DRAM_SIZE_256)
 		*(volatile unsigned long *) 0xf0302200=0x000040F0; // config_chip0 - CS0 - 0x40000000~0x47ffffff
 		#endif
-
+		#if defined(DRAM_SIZE_512)
+		*(volatile unsigned long *) 0xf0302200=0x000040E0; // config_chip0 -
+		#endif
 
 		i = 3200;
 		while(i)
@@ -162,8 +171,12 @@ volatile void InitRoutine_Start(void)
 
 		 // - SOC
 	//	 *(volatile unsigned long *) 0xf0303004 |= 0x00800000; // bit23 enable -synopt enable
-		
+#if defined(DRAM_ROW14)
+		*(volatile unsigned long *) 0xf0303020=0x00010107; // emccfg_config0
+#else
 		*(volatile unsigned long *) 0xf0303020=0x00010103; // emccfg_config0
+#endif
+		
 		*(volatile unsigned long *) 0xf0303024=0x00000000; // phyctrl
 		*(volatile unsigned long *) 0xf0304400=0x00000000; // DDR2PHY_PHYMODE
 		*(volatile unsigned long *) 0xf0304404=0x00000001; // DLLCTRL - DLL ON
@@ -352,39 +365,39 @@ void init_clock(void)
 #endif
 // init Peri. Clock
 	tca_ckc_setperi(PERI_TCZ,ENABLE,120000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_ADC,ENABLE,390000,PCDIRECTPLL2);
+	tca_ckc_setperi(PERI_ADC,ENABLE,120000,PCDIRECTXIN);
 	tca_ckc_setperi(PERI_I2C,ENABLE,40000,PCDIRECTXIN);
 	tca_ckc_setperi(PERI_UART0,ENABLE,520000,PCDIRECTPLL2); 
 	tca_ckc_setperi(PERI_LCD1,ENABLE,1560000,PCDIRECTPLL2);
 
-	tca_ckc_setperi(PERI_LCD0,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_LCDSI,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_CIFMC,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_CIFSC,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_OUT0,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_OUT1,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_HDMI,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_SDMMC0,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_MSTICK,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_UART1,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_UART2,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_UART3,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_UART4,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_UART5,ENABLE,10000,PCDIRECTXIN);
-
-	tca_ckc_setperi(PERI_GPSB0,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_GPSB1,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_GPSB2,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_GPSB3,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_GPSB4,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_GPSB5,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_LCD0,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_LCDSI,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_CIFMC,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_CIFSC,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_OUT0,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_OUT1,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_HDMI,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_SDMMC0,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_MSTICK,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_UART1,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_UART2,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_UART3,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_UART4,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_UART5,DISABLE,10000,PCDIRECTXIN);
+
+	tca_ckc_setperi(PERI_GPSB0,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_GPSB1,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_GPSB2,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_GPSB3,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_GPSB4,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_GPSB5,DISABLE,10000,PCDIRECTXIN);
 
 //	tca_ckc_setperi(PERI_SPDIF,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_EHI0,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_EHI1,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_CAN,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_SDMMC1,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_DAI,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_EHI0,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_EHI1,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_CAN,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_SDMMC1,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_DAI,DISABLE,10000,PCDIRECTXIN);
 
 // init Io Bus
 	tca_ckc_setiobus(RB_USB11H, DISABLE);	
@@ -420,9 +433,7 @@ void init_clock(void)
 	tca_ckc_setddipwdn(DDIPWDN_MSCL1, DISABLE);	
 	tca_ckc_setddipwdn(DDIPWDN_HDMI, DISABLE);	
 	
-#if defined(_WINCE_)
-	enable_irq();
-#endif
+
 }
 
 /*	
@@ -684,23 +695,30 @@ volatile void init_bootddr(void)
 	*(volatile unsigned long *) 0xF0303000 |= 0x80800000;		// bit23 enable -synopt enable
 	*(volatile unsigned long *) 0xF0303010 |= 0x80800000;		// bit23 enable -synopt enable
 	
+#if defined(DRAM_ROW14)
+	// ELPIDA
+	*(volatile unsigned long *)0xF030200C = 0x0015001A|DRAM_SET_AUTOPD; 		// config0 cas 10bit, ras 13bit
+#else
 // Samsung/ Hynix	
 	*(volatile unsigned long *)0xF030200C = 0x00150012|DRAM_SET_AUTOPD; 		// config0 cas 10bit, ras 13bit
-// ELPIDA 256MB
-//	*(volatile unsigned long *)0xF030200C = 0x0015001A; 		// config0 cas 10bit, ras 14bit
+#endif
 
-	if(lmem_source == 1)
-	{
-		if((lpll1/lmem_div) == 330) 
-			*(volatile unsigned long *)0xf0302010 = 0x00000507; 	// refresh 
-		else
-			*(volatile unsigned long *)0xF0302010 = 0x00000445; 	// refresh 
-	}
-	else // Over Mem 330Mhz
-	{
-		*(volatile unsigned long *) 0xf0302010=0x00000618;		// refresh
-	}
-		
+#if defined(FMBUS_280MHZ_INCLUDE) 
+		*(volatile unsigned long *)0xF0302010 = 2184; 	// refresh 
+#elif defined(FMBUS_300MHZ_INCLUDE)
+		*(volatile unsigned long *)0xF0302010 = 2340; 	// refresh 
+#elif defined(FMBUS_330MHZ_INCLUDE) 
+		*(volatile unsigned long *)0xF0302010 = 2574; 	// refresh 
+#elif defined(FMBUS_352MHZ_INCLUDE) 
+		*(volatile unsigned long *)0xF0302010 = 2746; 	// refresh 
+#elif defined(FMBUS_360MHZ_INCLUDE) 
+		*(volatile unsigned long *)0xF0302010 = 2808; 	// refresh 
+#elif defined(FMBUS_400MHZ_INCLUDE) 
+		*(volatile unsigned long *)0xF0302010 = 3120; 	// refresh 
+#else
+		*(volatile unsigned long *)0xF0302010 = 2184; 	// refresh 
+#endif
+				
 #if defined(DRAM_BANK3)
 	*(volatile unsigned long *) 0xf030204c=0x00000571; // config2 - SOC
 #else
@@ -715,69 +733,176 @@ volatile void init_bootddr(void)
 #endif		
 				
 	*(volatile unsigned long *)0xF030201c = 0x00000003; 		// tMRD
+	#if  defined(FMBUS_400MHZ_INCLUDE)
+		*(volatile unsigned long *)0xF0302020 = 18; 			// tRAS - 45ns
+		*(volatile unsigned long *)0xF0302024 = 24; 			// tRC	- 60ns
+		*(volatile unsigned long *)0xF0302028 = DDR2_SETRCD(6);//((3)<<8 |6); // tRCD - 15ns
 
-	//lcycle = 450/ldiv;
-	if(lmem_source == 0)
-        lcycle = 450/(10000/(lpll0/lmem_div));
-	else
-        lcycle = 450/(10000/(lpll1/lmem_div));
-	*(volatile unsigned long *)0xF0302020 = lcycle+DDR_DELAY; 			// tRAS - 45ns
-	//lcycle = 600/ldiv;
-	if(lmem_source == 0)
-        lcycle = 600/(10000/(lpll0/lmem_div));
-	else
-        lcycle = 600/(10000/(lpll1/lmem_div));
-	*(volatile unsigned long *)0xF0302024 = lcycle+DDR_DELAY; 			// tRC	- 60ns
-	//lcycle = 150/ldiv;
-	if(lmem_source == 0)
-        lcycle = 150/(10000/(lpll0/lmem_div));
-	else
-        lcycle = 150/(10000/(lpll1/lmem_div));
-	*(volatile unsigned long *)0xF0302028 = ((lcycle+DDR_DELAY-3)<<8 | lcycle+DDR_DELAY); // tRCD - 15ns
-	//lcycle = 1050/ldiv;
-	if(lmem_source == 0)
-        lcycle = 1050/(10000/(lpll0/lmem_div));
-	else
-        lcycle = 1050/(10000/(lpll1/lmem_div));
-	*(volatile unsigned long *)0xF030202c = ((lcycle+DDR_DELAY-3)<<8 | lcycle+DDR_DELAY); // tRFC - 105ns
-	//lcycle = 150/ldiv;
-	if(lmem_source == 0)
-        lcycle = 150/(10000/(lpll0/lmem_div));
-	else
-        lcycle = 150/(10000/(lpll1/lmem_div));
-	*(volatile unsigned long *)0xF0302030 = ((lcycle+DDR_DELAY-3)<<8 | lcycle+DDR_DELAY); // tRP	- 15ns
-	//lcycle = 100/ldiv;
-	if(lmem_source == 0)
-        lcycle = 100/(10000/(lpll0/lmem_div));
-	else
-        lcycle = 100/(10000/(lpll1/lmem_div));
-	*(volatile unsigned long *)0xF0302034 = lcycle+DDR_DELAY; 			// tRRD - 10ns
-	//lcycle = 150/ldiv;
-	if(lmem_source == 0)
-        lcycle = 150/(10000/(lpll0/lmem_div));
-	else
-        lcycle = 150/(10000/(lpll1/lmem_div));
-	*(volatile unsigned long *)0xF0302038 = lcycle+DDR_DELAY; 			// tWR - 15ns
-	//lcycle = 75/ldiv;
-	if(lmem_source == 0)
-        lcycle = 75/(10000/(lpll0/lmem_div));
-	else
-        lcycle = 75/(10000/(lpll1/lmem_div));
-	*(volatile unsigned long *)0xF030203c = lcycle+DDR_DELAY; 			// tWTR - 7.5ns
-	*(volatile unsigned long *)0xF0302040 = 0x00000003; 		// tXP - min 2tCK
+		#if defined(DRAM_TYPE1) || defined(DRAM_TYPE2) || defined(DRAM_TYPE6)
+		*(volatile unsigned long *)0xF030202c = DDR2_SETRFC(42);// tRFC - 105ns
+		#endif
+		#if defined(DRAM_TYPE3) || defined(DRAM_TYPE4) || defined(DRAM_TYPE10)
+		*(volatile unsigned long *)0xF030202c = DDR2_SETRFC(51);// tRFC - 127.5ns
+		#endif
+		*(volatile unsigned long *)0xF0302030 = DDR2_SETRP(6);// tRP	- 15ns
+		*(volatile unsigned long *)0xF0302034 = 4; 			// tRRD - 10ns
+		*(volatile unsigned long *)0xF0302038 = 6; 			// tWR - 15ns
+		*(volatile unsigned long *)0xF030203c = 3; 			// tWTR - 7.5ns
+		*(volatile unsigned long *)0xF0302040 = 3; 		// tXP - min 2tCK
+		#if defined(DRAM_TYPE1) || defined(DRAM_TYPE2) || defined(DRAM_TYPE6)
+		*(volatile unsigned long *)0xF0302044 = 46; 	// tXSR - tXSNR
+		#endif
+		#if defined(DRAM_TYPE3) || defined(DRAM_TYPE4) || defined(DRAM_TYPE10)
+		*(volatile unsigned long *)0xF0302044 = 55; 	// tXSR - tXSNR
+		#endif
+		*(volatile unsigned long *)0xF0302054 = 0x0000191c; 	// tFAW
 
-	if(lmem_source == 1) // under 330Mhz
-	{
-		*(volatile unsigned long *)0xF0302044 = 0x00000022; 	// tXSR
-		*(volatile unsigned long *)0xF0302048 = 0x000000FA; 	// tESR
+	#elif  defined(FMBUS_360MHZ_INCLUDE)
+		*(volatile unsigned long *)0xF0302020 = 17; 			// tRAS - 45ns
+		*(volatile unsigned long *)0xF0302024 = 22; 			// tRC	- 60ns
+		*(volatile unsigned long *)0xF0302028 = DDR2_SETRCD(6);//((3)<<8 |6); // tRCD - 15ns
+
+		#if defined(DRAM_TYPE1) || defined(DRAM_TYPE2) || defined(DRAM_TYPE6)
+		*(volatile unsigned long *)0xF030202c = DDR2_SETRFC(37);// tRFC - 105ns
+		#endif
+		#if defined(DRAM_TYPE3) || defined(DRAM_TYPE4) || defined(DRAM_TYPE10)
+		*(volatile unsigned long *)0xF030202c = DDR2_SETRFC(46);// tRFC - 127.5ns
+		#endif
+		*(volatile unsigned long *)0xF0302030 = DDR2_SETRP(6);// tRP	- 15ns
+		*(volatile unsigned long *)0xF0302034 = 4; 			// tRRD - 10ns
+		*(volatile unsigned long *)0xF0302038 = 6; 			// tWR - 15ns
+		*(volatile unsigned long *)0xF030203c = 3; 			// tWTR - 7.5ns
+		*(volatile unsigned long *)0xF0302040 = 3; 		// tXP - min 2tCK
+
+		#if defined(DRAM_TYPE1) || defined(DRAM_TYPE2) || defined(DRAM_TYPE6)
+		*(volatile unsigned long *)0xF0302044 = 42; 	// tXSR - tXSNR
+		#endif
+		#if defined(DRAM_TYPE3) || defined(DRAM_TYPE4) || defined(DRAM_TYPE10)
+		*(volatile unsigned long *)0xF0302044 = 50; 	// tXSR - tXSNR
+		#endif
+		*(volatile unsigned long *)0xF0302054 = 0x0000191c; 	// tFAW
+	#elif defined(FMBUS_352MHZ_INCLUDE)
+		*(volatile unsigned long *)0xF0302020 = 16; 			// tRAS - 45ns
+		*(volatile unsigned long *)0xF0302024 = 22; 			// tRC	- 60ns
+		*(volatile unsigned long *)0xF0302028 = DDR2_SETRCD(6);//((3)<<8 |6); // tRCD - 15ns
+
+		#if defined(DRAM_TYPE1) || defined(DRAM_TYPE2) || defined(DRAM_TYPE6)
+		*(volatile unsigned long *)0xF030202c = DDR2_SETRFC(37);// tRFC - 105ns
+		#endif
+		#if defined(DRAM_TYPE3) || defined(DRAM_TYPE4) || defined(DRAM_TYPE10)
+		*(volatile unsigned long *)0xF030202c = DDR2_SETRFC(45);// tRFC - 127.5ns
+		#endif
+		*(volatile unsigned long *)0xF0302030 = DDR2_SETRP(6);// tRP	- 15ns
+		*(volatile unsigned long *)0xF0302034 = 4; 			// tRRD - 10ns
+		*(volatile unsigned long *)0xF0302038 = 6; 			// tWR - 15ns
+		*(volatile unsigned long *)0xF030203c = 3; 			// tWTR - 7.5ns
+		*(volatile unsigned long *)0xF0302040 = 3; 		// tXP - min 2tCK
+
+		#if defined(DRAM_TYPE1) || defined(DRAM_TYPE2) || defined(DRAM_TYPE6)
+		*(volatile unsigned long *)0xF0302044 = 41; 	// tXSR - tXSNR
+		#endif
+		#if defined(DRAM_TYPE3) || defined(DRAM_TYPE4) || defined(DRAM_TYPE10)
+		*(volatile unsigned long *)0xF0302044 = 49; 	// tXSR - tXSNR
+		#endif
+		*(volatile unsigned long *)0xF0302054 = 0x0000191c; 	// tFAW
+	#elif defined(FMBUS_330MHZ_INCLUDE)
+		*(volatile unsigned long *)0xF0302020 = 15; 			// tRAS - 45ns
+		*(volatile unsigned long *)0xF0302024 = 20; 			// tRC	- 60ns
+		*(volatile unsigned long *)0xF0302028 = DDR2_SETRCD(5);// tRCD - 15ns
+
+		#if defined(DRAM_TYPE1) || defined(DRAM_TYPE2) || defined(DRAM_TYPE6)
+		*(volatile unsigned long *)0xF030202c = DDR2_SETRFC(35);// tRFC - 105ns
+		#endif
+		#if defined(DRAM_TYPE3) || defined(DRAM_TYPE4) || defined(DRAM_TYPE10)
+		*(volatile unsigned long *)0xF030202c = DDR2_SETRFC(42);// tRFC - 127.5ns
+		#endif
+		*(volatile unsigned long *)0xF0302030 = DDR2_SETRP(5);// tRP	- 15ns
+		*(volatile unsigned long *)0xF0302034 = 4; 			// tRRD - 10ns
+		*(volatile unsigned long *)0xF0302038 = 5; 			// tWR - 15ns
+		*(volatile unsigned long *)0xF030203c = 3; 			// tWTR - 7.5ns
+		*(volatile unsigned long *)0xF0302040 = 3; 		// tXP - min 2tCK
+
+		#if defined(DRAM_TYPE1) || defined(DRAM_TYPE2) || defined(DRAM_TYPE6)
+		*(volatile unsigned long *)0xF0302044 = 38; 	// tXSR - tXSNR
+		#endif
+		#if defined(DRAM_TYPE3) || defined(DRAM_TYPE4) || defined(DRAM_TYPE10)
+		*(volatile unsigned long *)0xF0302044 = 46; 	// tXSR - tXSNR
+		#endif
 		*(volatile unsigned long *)0xF0302054 = 0x00001619; 	// tFAW
-	}
-	else // Over Mem 330Mhz
-	{
-		*(volatile unsigned long *) 0xf0302044=0x0000002E;		// tXSR
-		*(volatile unsigned long *) 0xf0302048=0x00000050;		// tESR
-		*(volatile unsigned long *) 0xf0302054=0x0000191c;		// tFAW
-	}
+	#elif defined(FMBUS_300MHZ_INCLUDE)
+		*(volatile unsigned long *)0xF0302020 = 14; 			// tRAS - 45ns
+		*(volatile unsigned long *)0xF0302024 = 18; 			// tRC	- 60ns
+		*(volatile unsigned long *)0xF0302028 = DDR2_SETRCD(5);// tRCD - 15ns
+
+		#if defined(DRAM_TYPE1) || defined(DRAM_TYPE2) || defined(DRAM_TYPE6)
+		*(volatile unsigned long *)0xF030202c = DDR2_SETRFC(32);// tRFC - 105ns
+		#endif
+		#if defined(DRAM_TYPE3) || defined(DRAM_TYPE4) || defined(DRAM_TYPE10)
+		*(volatile unsigned long *)0xF030202c = DDR2_SETRFC(39);// tRFC - 127.5ns
+		#endif
+		*(volatile unsigned long *)0xF0302030 = DDR2_SETRP(5);// tRP	- 15ns
+		*(volatile unsigned long *)0xF0302034 = 3; 			// tRRD - 10ns
+		*(volatile unsigned long *)0xF0302038 = 5; 			// tWR - 15ns
+		*(volatile unsigned long *)0xF030203c = 3; 			// tWTR - 7.5ns
+		*(volatile unsigned long *)0xF0302040 = 3; 		// tXP - min 2tCK
+
+		#if defined(DRAM_TYPE1) || defined(DRAM_TYPE2) || defined(DRAM_TYPE6)
+		*(volatile unsigned long *)0xF0302044 = 35; 	// tXSR - tXSNR
+		#endif
+		#if defined(DRAM_TYPE3) || defined(DRAM_TYPE4) || defined(DRAM_TYPE10)
+		*(volatile unsigned long *)0xF0302044 = 42; 	// tXSR - tXSNR
+		#endif
+		*(volatile unsigned long *)0xF0302054 = 0x00001619; 	// tFAW
+	#elif defined(FMBUS_280MHZ_INCLUDE)
+		*(volatile unsigned long *)0xF0302020 = 13; 			// tRAS - 45ns
+		*(volatile unsigned long *)0xF0302024 = 17; 			// tRC	- 60ns
+		*(volatile unsigned long *)0xF0302028 = DDR2_SETRCD(5);// tRCD - 15ns
+
+		#if defined(DRAM_TYPE1) || defined(DRAM_TYPE2) || defined(DRAM_TYPE6)
+		*(volatile unsigned long *)0xF030202c = DDR2_SETRFC(30);// tRFC - 105ns
+		#endif
+		#if defined(DRAM_TYPE3) || defined(DRAM_TYPE4) || defined(DRAM_TYPE10)
+		*(volatile unsigned long *)0xF030202c = DDR2_SETRFC(36);// tRFC - 127.5ns
+		#endif
+		*(volatile unsigned long *)0xF0302030 = DDR2_SETRP(5);// tRP	- 15ns
+		*(volatile unsigned long *)0xF0302034 = 3; 			// tRRD - 10ns
+		*(volatile unsigned long *)0xF0302038 = 5; 			// tWR - 15ns
+		*(volatile unsigned long *)0xF030203c = 3; 			// tWTR - 7.5ns
+		*(volatile unsigned long *)0xF0302040 = 3; 		// tXP - min 2tCK
+
+		#if defined(DRAM_TYPE1) || defined(DRAM_TYPE2) || defined(DRAM_TYPE6)
+		*(volatile unsigned long *)0xF0302044 = 33; 	// tXSR - tXSNR
+		#endif
+		#if defined(DRAM_TYPE3) || defined(DRAM_TYPE4) || defined(DRAM_TYPE10)
+		*(volatile unsigned long *)0xF0302044 = 39; 	// tXSR - tXSNR
+		#endif
+		*(volatile unsigned long *)0xF0302054 = 0x00001619; 	// tFAW
+	#else
+		*(volatile unsigned long *)0xF0302020 = 13; 			// tRAS - 45ns
+		*(volatile unsigned long *)0xF0302024 = 17; 			// tRC	- 60ns
+		*(volatile unsigned long *)0xF0302028 = DDR2_SETRCD(5);// tRCD - 15ns
+
+		#if defined(DRAM_TYPE1) || defined(DRAM_TYPE2) || defined(DRAM_TYPE6)
+		*(volatile unsigned long *)0xF030202c = DDR2_SETRFC(30);// tRFC - 105ns
+		#endif
+		#if defined(DRAM_TYPE3) || defined(DRAM_TYPE4) || defined(DRAM_TYPE10)
+		*(volatile unsigned long *)0xF030202c = DDR2_SETRFC(36);// tRFC - 127.5ns
+		#endif
+		*(volatile unsigned long *)0xF0302030 = DDR2_SETRP(5);// tRP	- 15ns
+		*(volatile unsigned long *)0xF0302034 = 3; 			// tRRD - 10ns
+		*(volatile unsigned long *)0xF0302038 = 5; 			// tWR - 15ns
+		*(volatile unsigned long *)0xF030203c = 3; 			// tWTR - 7.5ns
+		*(volatile unsigned long *)0xF0302040 = 3; 		// tXP - min 2tCK
+
+		#if defined(DRAM_TYPE1) || defined(DRAM_TYPE2) || defined(DRAM_TYPE6)
+		*(volatile unsigned long *)0xF0302044 = 33; 	// tXSR - tXSNR
+		#endif
+		#if defined(DRAM_TYPE3) || defined(DRAM_TYPE4) || defined(DRAM_TYPE10)
+		*(volatile unsigned long *)0xF0302044 = 39; 	// tXSR - tXSNR
+		#endif
+		*(volatile unsigned long *)0xF0302054 = 0x00001619; 	// tFAW
+	#endif
+		*(volatile unsigned long *)0xF0302048 = 200; 	// tESR
 
 	i = 3200;
 	while(i)
@@ -790,6 +915,9 @@ volatile void init_bootddr(void)
 	#if defined(DRAM_SIZE_256)
 	*(volatile unsigned long *) 0xf0302200=0x000040F0; // config_chip0 - CS0 - 0x40000000~0x47ffffff
 	#endif
+	#if defined(DRAM_SIZE_512)
+	*(volatile unsigned long *) 0xf0302200=0x000040E0; // config_chip0 -
+	#endif
 		
 	i = 3200;
 	while(i)
@@ -804,19 +932,21 @@ volatile void init_bootddr(void)
 
 
 	
-	*(volatile unsigned long *)0xF0303020 = 0x00010103; 		// emccfg_config0
+#if defined(DRAM_ROW14)
+	*(volatile unsigned long *) 0xF0303020=0x00010107; // emccfg_config0
+#else
+	*(volatile unsigned long *) 0xF0303020=0x00010103; // emccfg_config0
+#endif
 	*(volatile unsigned long *)0xF0303024 = 0x00000000; 		// SDRAM PHY Control Register 
 	*(volatile unsigned long *)0xF0304400 = 0x00000000; 		// DDR2PHY_PHYMODE
 	*(volatile unsigned long *)0xF0304404 = 0x00000001; 		// DLLCTRL
-	
-	if(lmem_source == 1) // under 330Mhz
-	{
-		*(volatile unsigned long *)0xF0304408 = 0x00001717; 	// DLLPDCFG
-	}
-	else // Over Mem 330Mhz
-	{
+
+#if defined(FMBUS_352MHZ_INCLUDE) || defined(FMBUS_360MHZ_INCLUDE) ||defined(FMBUS_400MHZ_INCLUDE) 
 		*(volatile unsigned long *)0xF0304408 = 0x00001212; 	// DLLPDCFG
-	}
+#else
+		*(volatile unsigned long *)0xF0304408 = 0x00001717; 	// DLLPDCFG
+#endif
+
 		
 	*(volatile unsigned long *)0xF0304404 = 0x00000003; 		// DLLCTRL
 	while (((*(volatile unsigned long *)0xF0304404) & (0x00000018)) != (0x00000018)); // Wait DLL Lock
@@ -920,35 +1050,21 @@ volatile void init_bootddr(void)
 	*(volatile unsigned long *)0xF0302008 = 0x000a0000; 		// Direct COmmnad Register 
 	*(volatile unsigned long *)0xF0302008 = 0x000b0000; 		// Direct COmmnad Register 
 	*(volatile unsigned long *)0xF0302008 = 0x00090000; 		// Direct COmmnad Register	  
-	
-	if(lmem_source == 1) // under 330Mhz
-	{
+
+#if defined(FMBUS_352MHZ_INCLUDE) || defined(FMBUS_360MHZ_INCLUDE) ||defined(FMBUS_400MHZ_INCLUDE) 
 		#if defined(DRAM_CAS6)
-			*(volatile unsigned long *)0xF0302008 = 0x00080962; 	// Direct COmmnad Register 
+				*(volatile unsigned long *)0xF0302008 = 0x00080B62; 	// Direct COmmnad Register
 		#else
-			*(volatile unsigned long *)0xF0302008 = 0x00080952; 	// Direct COmmnad Register 
-		#endif		
-	}
-	else // Over Mem 330Mhz
-	{
-		if((lpll0/lmem_div) <= 330)
-		{
-			#if defined(DRAM_CAS6)
-					*(volatile unsigned long *)0xF0302008 = 0x00080962; 	// Direct COmmnad Register
-			#else
-					*(volatile unsigned long *)0xF0302008 = 0x00080952; 	// Direct COmmnad Register
-			#endif
-		}
-		else
-		{
-			#if defined(DRAM_CAS6)
-					*(volatile unsigned long *)0xF0302008 = 0x00080762; 	// Direct COmmnad Register
-			#else
-					*(volatile unsigned long *)0xF0302008 = 0x00080752; 	// Direct COmmnad Register
-			#endif
-		}
-	}
-		
+				*(volatile unsigned long *)0xF0302008 = 0x00080B52; 	// Direct COmmnad Register
+		#endif
+#else
+		#if defined(DRAM_CAS6)
+				*(volatile unsigned long *)0xF0302008 = 0x00080962; 	// Direct COmmnad Register
+		#else
+				*(volatile unsigned long *)0xF0302008 = 0x00080952; 	// Direct COmmnad Register
+		#endif
+#endif
+	
 	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
 
 	//i = 100;
@@ -959,34 +1075,22 @@ volatile void init_bootddr(void)
 		*(volatile unsigned long *) 0xf0302008=0x00040000; // dir_cmd  //soc1-3
 		i--;
 	}
-	
-	if(lmem_source == 1) // under 330Mhz
-	{
+
+#if defined(FMBUS_352MHZ_INCLUDE) || defined(FMBUS_360MHZ_INCLUDE) ||defined(FMBUS_400MHZ_INCLUDE) 
+	#if defined(DRAM_CAS6)
+			*(volatile unsigned long *)0xF0302008 = 0x00080A62; 	// Direct COmmnad Register
+	#else
+			*(volatile unsigned long *)0xF0302008 = 0x00080A52; 	// Direct COmmnad Register
+	#endif
+#else
 	#if defined(DRAM_CAS6)
 			*(volatile unsigned long *)0xF0302008 = 0x00080862; 	// Direct COmmnad Register 
 	#else
 			*(volatile unsigned long *)0xF0302008 = 0x00080852; 	// Direct COmmnad Register 
 	#endif		
-	}
-	else // Over Mem 330Mhz
-	{
-		if((lpll0/lmem_div) <= 330)
-		{
-		#if defined(DRAM_CAS6)
-					*(volatile unsigned long *)0xF0302008 = 0x00080862; 	// Direct COmmnad Register
-		#else
-					*(volatile unsigned long *)0xF0302008 = 0x00080852; 	// Direct COmmnad Register
-		#endif
-		}
-		else
-		{
-		#if defined(DRAM_CAS6)
-					*(volatile unsigned long *)0xF0302008 = 0x00080662; 	// Direct COmmnad Register
-		#else
-					*(volatile unsigned long *)0xF0302008 = 0x00080652; 	// Direct COmmnad Register
-		#endif
-		}
-	}
+#endif
+
+
 	#if defined(DRAM_ODTOFF)
 
 	#else
diff --git a/drivers/block/tcc/init_mddr.c b/drivers/block/tcc/init_mddr.c
index 631ce53..ec223a2 100644
--- a/drivers/block/tcc/init_mddr.c
+++ b/drivers/block/tcc/init_mddr.c
@@ -111,12 +111,17 @@ volatile void InitRoutine_Start(void)
 	while (((*(volatile unsigned long *)0xF0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
 
 	// MEMCFG0
-#if defined(DRAM_RAS14)
+#if defined(DRAM_ROW14)
 	// clumn_bits=3, row_bits=2, ap_bit=0, mem_burst=2,active.chips=0
 	*(volatile unsigned long *)0xF030100c = 0x0001001A|DRAM_SET_AUTOPD;
 #else
+	#if defined(DRAM_COL9)
+	// clumn_bits=1, row_bits=2, ap_bit=0, mem_burst=2,active.chips=0
+	*(volatile unsigned long *)0xF030100c = 0x00010011|DRAM_SET_AUTOPD;
+	#else
 	// clumn_bits=2, row_bits=2, ap_bit=0, mem_burst=2,active.chips=0
 	*(volatile unsigned long *)0xF030100c = 0x00010012|DRAM_SET_AUTOPD;
+	#endif
 #endif
 
 	// MEMCFG1
@@ -141,6 +146,9 @@ volatile void InitRoutine_Start(void)
 	*(volatile unsigned long *)0xF0301048 = 0x00000032; // tESR=200
 	// CHIP0 address_match=0x40, address_mask=0x40
 	// 1CS
+	#if defined(DRAM_SIZE_64)
+	*(volatile unsigned long *) 0xF0301200=0x000040FC; // config_chip0 - CS0 - 0x40000000~0x47ffffff
+	#endif
 	#if defined(DRAM_SIZE_128)
 	*(volatile unsigned long *) 0xF0301200=0x000040F8; // config_chip0 - CS0 - 0x40000000~0x47ffffff
 	#endif
@@ -160,7 +168,7 @@ volatile void InitRoutine_Start(void)
 	*(volatile unsigned long *)0xF0303020 = 0x00010102;
 	//HwEMCCFG->uPHYCTRL.bReg.PL340_SEL = 1;
 	*(volatile unsigned long *)0xF0303024 = 0x00000100;
-	*(volatile unsigned long *)0xF030302C = 0x00000000;
+//	*(volatile unsigned long *)0xF030302C = 0x00000000;
 	//SSTL_IO_Init (IO_CMOS)
 	*(volatile unsigned long *) 0xF0304400=0x00000002; // DDR2PHY_PHYMODE
 	*(volatile unsigned long *) 0xF0304404=0x00004d69; // DLLCTRL - DLL ON
@@ -296,40 +304,40 @@ void init_clock(void)
 
 // init Peri. Clock
 	tca_ckc_setperi(PERI_TCZ,ENABLE,120000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_ADC,ENABLE,390000,PCDIRECTPLL2);
+	tca_ckc_setperi(PERI_ADC,ENABLE,120000,PCDIRECTXIN);
 	tca_ckc_setperi(PERI_I2C,ENABLE,40000,PCDIRECTXIN);
 	tca_ckc_setperi(PERI_UART0,ENABLE,520000,PCDIRECTPLL2); 
 	tca_ckc_setperi(PERI_LCD1,ENABLE,1560000,PCDIRECTPLL2);
 
-	tca_ckc_setperi(PERI_LCD0,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_LCDSI,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_CIFMC,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_CIFSC,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_OUT0,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_OUT1,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_HDMI,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_SDMMC0,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_MSTICK,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_UART1,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_UART2,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_UART3,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_UART4,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_UART5,ENABLE,10000,PCDIRECTXIN);
-
-	tca_ckc_setperi(PERI_GPSB0,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_GPSB1,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_GPSB2,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_GPSB3,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_GPSB4,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_GPSB5,ENABLE,10000,PCDIRECTXIN);
-
-	tca_ckc_setperi(PERI_SPDIF,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_EHI0,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_EHI1,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_CAN,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_SDMMC1,ENABLE,10000,PCDIRECTXIN);
-	tca_ckc_setperi(PERI_DAI,ENABLE,10000,PCDIRECTXIN);
-
+	tca_ckc_setperi(PERI_LCD0,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_LCDSI,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_CIFMC,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_CIFSC,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_OUT0,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_OUT1,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_HDMI,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_SDMMC0,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_MSTICK,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_UART1,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_UART2,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_UART3,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_UART4,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_UART5,DISABLE,10000,PCDIRECTXIN);
+
+	tca_ckc_setperi(PERI_GPSB0,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_GPSB1,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_GPSB2,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_GPSB3,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_GPSB4,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_GPSB5,DISABLE,10000,PCDIRECTXIN);
+
+//	tca_ckc_setperi(PERI_SPDIF,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_EHI0,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_EHI1,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_CAN,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_SDMMC1,DISABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_DAI,DISABLE,10000,PCDIRECTXIN);
+	
 // init Io Bus
 	tca_ckc_setiobus(RB_USB11H, DISABLE);	
 	tca_ckc_setiobus(RB_IDECONTROLLER, DISABLE);	
@@ -364,9 +372,7 @@ void init_clock(void)
 	tca_ckc_setddipwdn(DDIPWDN_MSCL1, DISABLE);	
 	tca_ckc_setddipwdn(DDIPWDN_HDMI, DISABLE);	
 	
-#if defined(_WINCE_)
-	enable_irq();
-#endif
+
 }
 
 /*	
@@ -599,12 +605,17 @@ void init_bootddr(void)
 	*(volatile unsigned long *) 0xF0301004=0x00000004;			// PL341_CONFIGURE
 	while (((*(volatile unsigned long *)0xF0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
 
-#if defined(DRAM_RAS14)
+#if defined(DRAM_ROW14)
 	// clumn_bits=3, row_bits=2, ap_bit=0, mem_burst=2,active.chips=0
 	*(volatile unsigned long *)0xF030100C = 0x0021001A|DRAM_SET_AUTOPD; 		// config0 cas 10bit, ras 13bit , AP bit 10, Burst 4, 2chips
 #else
+	#if defined(DRAM_COL9)
+	// clumn_bits=1, row_bits=2, ap_bit=0, mem_burst=2,active.chips=0
+	*(volatile unsigned long *)0xF030100c = 0x00210011|DRAM_SET_AUTOPD;
+	#else
 	// clumn_bits=2, row_bits=2, ap_bit=0, mem_burst=2,active.chips=0
-	*(volatile unsigned long *)0xF030100C = 0x00210012|DRAM_SET_AUTOPD; 		// config0 cas 10bit, ras 13bit , AP bit 10, Burst 4, 2chips
+	*(volatile unsigned long *)0xF030100c = 0x00210012|DRAM_SET_AUTOPD;
+	#endif
 #endif
 
 
@@ -644,6 +655,9 @@ void init_bootddr(void)
 		i--;
 
 	// 1CS
+	#if defined(DRAM_SIZE_64)
+	*(volatile unsigned long *) 0xF0301200=0x000040FC; // config_chip0 - CS0 - 0x40000000~0x47ffffff
+	#endif
 	#if defined(DRAM_SIZE_128)
 	*(volatile unsigned long *) 0xF0301200=0x000040F8; // config_chip0 - CS0 - 0x40000000~0x47ffffff
 	#endif
@@ -655,6 +669,7 @@ void init_bootddr(void)
 	while(i)
 		i--;		
 	
+#if !defined(DRAM_TYPE9)
 	*(volatile unsigned long *)0xF0301004 = 0x00000000; 		// PL341_GO
 	while (((*(volatile unsigned long *)0xF0301000) & (0x03)) != 1);	// Wait until READY
 	
@@ -663,7 +678,7 @@ void init_bootddr(void)
 
 	*(volatile unsigned long *)0xF0301004 = 0x00000001; 		// PL341_SLEEP
 	while (((*(volatile unsigned long *)0xF0301000) & (0x03)) != 3);	// Wait until SLEEP
-
+#endif
 	*(volatile unsigned long *)0xF030302c &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
 	*(volatile unsigned long *)0xF0303020 &=  ~(0x00000001);		// SW ? AXI_SEL     = 0
 	*(volatile unsigned long *)0xF0303020 |= 0x00000002; 		// SW ? IO_SEL      = 1;
@@ -716,14 +731,14 @@ void init_bootddr(void)
 	i = 3200;
 	while(i)
 		i--;	
-
+#if !defined(DRAM_TYPE9)
 	*(volatile unsigned long *)0xF0301004 = 0x00000002; 		// PL340_WAKEUP
 	while (((*(volatile unsigned long *)0xF0301000) & (0x03)) != 2);	// Wait until PAUSE
 
 	*(volatile unsigned long *)0xF0301004 = 0x00000004; 		// PL340_CONFIGURE
 	while (((*(volatile unsigned long *)0xF0301000) & (0x03)) != 0);	// Wait until CONFIGURE	
+#endif 
 
-	//HwPL340->direct_cmd = 		
 	#if defined(DRAM_CAS3)
 		*(volatile unsigned long *)0xF0301008 = 0x00000032; //MRS
 	#else
diff --git a/drivers/block/tcc/kernel_nand_drv.c b/drivers/block/tcc/kernel_nand_drv.c
index 3a153c2..dd9c37c 100644
--- a/drivers/block/tcc/kernel_nand_drv.c
+++ b/drivers/block/tcc/kernel_nand_drv.c
@@ -37,101 +37,75 @@
 #include <asm/memory.h>
 #include <asm/dma.h>
 
-#include "IO_TCCXXX.h"
-#include "nand_drv.h"
-#include "nand_io_v7.h"
+#include "kernel_nand_drv.h"
 #include "Disk.h"
 
 #include <linux/tcc_ioctl.h>
 
+#define NDD_DEV_NAME		"ndd"
+#define NDD_DEV_MAJOR 		240
+#define MAX_NDD_DEV			MAX_NAND_DRIVE	// # of NAND device: 1
+#define NDD_MAX_PARTITIONS  5				// Max # of partitions: 4
+
 #define __USE_TCC_NAND_WORK_Q__
+
 #ifdef __USE_TCC_NAND_WORK_Q__
 #include <linux/workqueue.h>
 #include <linux/slab.h>
-typedef struct _nand_priv_data_t {
-    struct work_struct nand_work;
-    struct semaphore sem;
-    struct mutex mutex;
-    struct workqueue_struct *wq_ptr;
-    struct request_queue *req;
-} nand_priv_data_t;
-
-nand_priv_data_t tcc_nand_data;
+#include <linux/kthread.h>
+nand_priv_data_t tcc_nand_data[MAX_NDD_DEV];
 #endif
 
-struct dma_buf {
-	void *v_addr;
-	unsigned int dma_addr;
-	int buf_size;
-};
+//=============================================================================
+//*
+//*
+//*                           [ CONST DATA DEFINE ]
+//*
+//*
+//=============================================================================
 struct dma_buf dma_t;
-
 static int ndevices = 2;
 module_param(ndevices, int, 0);
+#ifdef __USE_NAND_ISR__
+nand_intr_info_rb 	nand_intr_rb;
+nand_intr_info 		nand_intr;
+#endif
 
+//=============================================================================
+//*
+//*
+//*                           [ GLOBAL VARIABLE DEFINE ]
+//*
+//*
+//=============================================================================
+#ifdef __USE_NAND_ISR__
+int ndd_isr_rb_enable_flag = NDD_RB_INTR_MODE_NORMAL;
+#endif
 
-extern unsigned char *gNAND_PageBuffer;
-extern unsigned char gNAND_PartitionInfoLoadFlag;
-//void __iomem *virtadr;
-
-#define NDD_DEV_NAME		"ndd"
-#define NDD_DEV_MAJOR 		240
-#define MAX_NDD_DEV			MAX_NAND_DRIVE	// # of NAND device: 1
-#define NDD_MAX_PARTITIONS  5				// Max # of partitions: 4
-
-/* 
- * IOCTL
- */
-#define IOCTL_NDD_GET_INFO			_IO(NDD_DEV_MAJOR, 1)
-#define IOCTL_NDD_MULTI_HD_WRITE	_IO(NDD_DEV_MAJOR, 2)
-#define IOCTL_NDD_MULTI_HD_READ		_IO(NDD_DEV_MAJOR, 3)
-#define IOCTL_NDD_BOOT_WRITE		_IO(NDD_DEV_MAJOR, 4)
-#define IOCTL_NDD_HD_WRITE			_IO(NDD_DEV_MAJOR, 5)
-#define IOCTL_NDD_HD_READ			_IO(NDD_DEV_MAJOR, 6)
-#define IOCTL_NDD_ALIGN_CACHE		_IO(NDD_DEV_MAJOR, 7)
-
-struct ndd_data {
-	loff_t i_size;
-};
-
-struct ndd_hidden_info {
-	unsigned int  DriveNum;			// # of multi-hidden area (0~2) - ONLY multi hidden
-	unsigned int  HiddenAddress;	// start page offset
-	unsigned int  SectorNum;		// write/read page size
-	unsigned char *DataBuffer;		// buffer
-	unsigned int  DataBufferSize;	// buffer size
-};
-
-struct ndd_boot_info {
-	char *buf;						// bootloader buffer
-	unsigned int len;				// bootloader length
-};
-
-extern int FWUG_MainFunc(char *rom_buf, int iFileSize);
-//////////////////////////////////////
-
-typedef struct __tag_ndd_dev
-{
-	int						size;
-	u8			 			*data;
-	short					users;
-	short					media_change;
-	struct request_queue 	*queue;
-	spinlock_t				lock;
-	struct gendisk 			*gd;
-	struct timer_list		timer;
-	char 					*buf;
-}Device;
-
-static Device ndd_dev[MAX_NDD_DEV];
-
-static int ndd_open(struct block_device *bdev, fmode_t mode);
-static int ndd_release(struct gendisk *disk, fmode_t mode);
-static int ndd_ioctl (struct block_device *bdev, struct file *filp, unsigned int cmd, unsigned long arg);
-static void ndd_transfer(Device *dev, unsigned long sector, unsigned long nsect, char *buffer, int write);
-static void ndd_request(struct request_queue *q);
-static int ndd_getgeo(struct block_device *bdev, struct hd_geometry *geo);
+//=============================================================================
+//*
+//*
+//*                           [ LOCAL FUNCTIONS DEFINE ]
+//*
+//*
+//=============================================================================
+static int 		ndd_ioctl (struct block_device *bdev, struct file *filp, unsigned int cmd, unsigned long arg);
+static int 		ndd_getgeo(struct block_device *bdev, struct hd_geometry *geo);
+static int 		ndd_open(struct block_device *bdev, fmode_t mode);
+static int 		ndd_release(struct gendisk *disk, fmode_t mode);
+#ifdef __USE_NAND_ISR__
+static int		nand_isr_read( struct request_queue *request_q, struct request *req );
+#ifdef __USE_NAND_ISR_WRITE__
+static int 		nand_isr_write( struct request_queue *request_q, struct request *req );
+#endif
+#endif
+static void 	ndd_request(struct request_queue *q);
+static void 	ndd_transfer(Device *dev, unsigned long sector, unsigned long nsect, char *buffer, int write);
+#ifdef __USE_NAND_ISR__
+static void 	ndd_get_phypageinfo( ndd_work_info *nand_work_info, int nMode );
+#endif
 
+static Device 	ndd_dev[MAX_NDD_DEV];
 static struct block_device_operations ndd_fops = 
 {
 	.owner = THIS_MODULE,
@@ -141,25 +115,185 @@ static struct block_device_operations ndd_fops =
 	.getgeo = ndd_getgeo,
 };
 
+//=============================================================================
+//*
+//*
+//*                     [ EXTERN VARIABLE & FUNCTIONS DEFINE ]
+//*
+//*
+//=============================================================================
+extern unsigned char *gNAND_PageBuffer;
+extern unsigned char gNAND_PartitionInfoLoadFlag;
+extern int			 FWUG_MainFunc(char *rom_buf, int iFileSize);
 
 #ifdef __USE_TCC_NAND_WORK_Q__
-static void tcc_nand_func(struct work_struct *work)
+static int tcc_nand_issue(void *d)
 {
-    nand_priv_data_t *nand_data_ptr = container_of(work, nand_priv_data_t, nand_work);
-	struct request *req;
-    struct request_queue *q = nand_data_ptr->req;
-
-	unsigned int idx = 0, sector = 0;
-	int first = 1;
-	int xfer = 0;
-
-	while ((req = elv_next_request(q)) != NULL) {
-		Device *dev = req->rq_disk->private_data;
-		if( !blk_fs_request(req)) {
-			end_request(req, 0);
-		} else {
-			//printk("(%lu-%d/%lu)", req->sector, req->current_nr_sectors, req->nr_sectors);
-
+    nand_priv_data_t *nand_priv = (nand_priv_data_t *)d;
+	#ifdef __USE_NAND_ISR__
+	unsigned int	i = 0;
+	#endif
+	unsigned int 	idx = 0, sector = 0;
+	int 			first = 1;
+	int 			xfer = 0;
+    struct request_queue *q = nand_priv->req;
+
+	#ifdef __USE_NAND_ISR_WRITE__					
+	unsigned char	*pSpareBuffer, *pStuffPageBuffer;
+	#endif
+	
+    do {
+        struct request *req = NULL;
+
+        spin_lock_irq(q->queue_lock);
+        set_current_state(TASK_INTERRUPTIBLE);
+        if (!blk_queue_plugged(q)) {
+            req = elv_next_request(q);
+        }
+        spin_unlock_irq(q->queue_lock);
+
+        if (!req) {
+            first = 1;
+            if (kthread_should_stop()) {
+                set_current_state(TASK_RUNNING);
+                break;
+            }
+            schedule();
+            continue;
+        }
+
+        set_current_state(TASK_RUNNING);
+        {
+            Device *dev = req->rq_disk->private_data;
+            if (!blk_fs_request(req)) {
+                end_request(req, 0);
+            } else {
+#ifdef __USE_NAND_ISR__
+			/* read */
+                if (!rq_data_dir(req)) 
+				{
+					i =	req->sector;
+					n_printk("Read_Sector:[%d]-[%lu-%d]\n",i, req->nr_sectors, req->current_nr_sectors);
+
+					if ( ( req->nr_sectors > 8 ) && ( first == 1 ) )
+					{
+						n_printk("\n--IRQ_READ");
+						for ( i = 0; i < req->current_nr_sectors; ++i )
+							dev->nand_work_info->BufferAddr[ i ] = (unsigned int )( req->buffer + (i << 9));
+						
+						dev->nand_work_info->StartSector	= req->sector;
+						dev->nand_work_info->SectorNum 		= req->nr_sectors;
+
+						//========================================
+						// get phy page addr info
+						//========================================
+						ndd_get_phypageinfo( dev->nand_work_info, 0 );
+
+						// Read Start
+						nand_isr_read( q, req );
+
+						first = 1;
+					}
+					else
+					{
+						first = 0;
+						n_printk("\n--NORMAL_READ");
+
+						ndd_transfer(dev, req->sector, req->current_nr_sectors, req->buffer, 0);
+
+						if (req->current_nr_sectors == req->nr_sectors)
+							first = 1;
+					}
+
+               		end_request(req, 1);
+                } 
+				else 	
+				{
+					#ifdef __USE_NAND_ISR_WRITE__					
+					/* write */
+					pSpareBuffer 		= dev->nand_work_info->nSpareBuffer;
+					pStuffPageBuffer	= dev->nand_work_info->StuffInfo.nStuffPageBuffer;
+
+					i =	req->sector;
+					n_printk("Write_Sector:[%d]-[%lu-%d]\n",i, req->nr_sectors, req->current_nr_sectors);
+
+					if ( ( req->nr_sectors > 8 ) && ( req->current_nr_sectors == 8 ) && ( first == 1 ) )
+					{
+						n_printk("\n--IRQ_WRITE");
+						for ( i = 0; i < req->current_nr_sectors; ++i )
+							dev->nand_work_info->BufferAddr[ i ] = (unsigned int )( req->buffer + (i << 9));
+						
+						dev->nand_work_info->StartSector	= req->sector;
+						dev->nand_work_info->SectorNum 		= req->nr_sectors;
+
+						//========================================
+						// get phy page addr info
+						//========================================
+						ndd_get_phypageinfo( dev->nand_work_info, 1 );
+						dev->nand_work_info->nSpareBuffer = pSpareBuffer;
+						dev->nand_work_info->StuffInfo.nStuffPageBuffer = pStuffPageBuffer;
+
+						n_printk("\n[PhyPageNum:%d]:", dev->nand_work_info->PhyPageNum );
+						for ( i = 0; i < dev->nand_work_info->PhyPageNum; ++i )
+							n_printk(",%d", dev->nand_work_info->PPageSize[i] );
+
+						n_printk("\n");
+
+						// Write Start
+						nand_isr_write( q, req );
+
+						dev->nand_work_info->nSpareBuffer = pSpareBuffer;
+						dev->nand_work_info->StuffInfo.nStuffPageBuffer = pStuffPageBuffer;
+						
+						first = 1;
+					}
+					else
+					{
+						if (first)
+						{
+	                        idx = 0;
+	                        first = 0;
+	                        xfer = 0;
+	                        sector = req->sector;
+	                    }
+
+	                    memcpy(&dev->buf[idx * 512], req->buffer, req->current_nr_sectors * 512);
+	                    idx += req->current_nr_sectors;
+
+	                    if (req->current_nr_sectors == req->nr_sectors) {
+	                        xfer = 1;
+	                    }
+
+	                    if (xfer) {
+	                        ndd_transfer(dev, sector, idx, dev->buf, 1);
+	                        first = 1;
+	                    }
+					}
+               		end_request(req, 1);
+					#else
+					if (first)
+					{
+                        idx = 0;
+                        first = 0;
+                        xfer = 0;
+                        sector = req->sector;
+                    }
+
+                    memcpy(&dev->buf[idx * 512], req->buffer, req->current_nr_sectors * 512);
+                    idx += req->current_nr_sectors;
+
+                    if (req->current_nr_sectors == req->nr_sectors) {
+                        xfer = 1;
+                    }
+
+                    if (xfer) {
+                        ndd_transfer(dev, sector, idx, dev->buf, 1);
+                        first = 1;
+                    }
+                    end_request(req, 1);
+					#endif /* 0 */
+                }
+#else
 			/* read */
 			if (!rq_data_dir(req)) {
 				if (first) {
@@ -184,7 +318,6 @@ static void tcc_nand_func(struct work_struct *work)
 					xfer = 0;
 					sector = req->sector;
 				}
-
 				memcpy(&dev->buf[idx * 512], req->buffer, req->current_nr_sectors * 512);
 				idx += req->current_nr_sectors;
 
@@ -198,14 +331,17 @@ static void tcc_nand_func(struct work_struct *work)
 				}
 				end_request(req, 1);
 			}
+#endif			
 		}
-	}
 
-    up(&(nand_data_ptr->sem));
+        }
+    } while (1);
+
+    return 0;
 }
 #endif
 
-static int ndd_ioctl (struct block_device *bdev, struct file *filp, unsigned int cmd, unsigned long arg)
+static int ndd_ioctl(struct block_device *bdev, struct file *filp, unsigned int cmd, unsigned long arg)
 {
 	switch (cmd) {
 		case IOCTL_NDD_MULTI_HD_WRITE:
@@ -330,7 +466,13 @@ static int ndd_ioctl (struct block_device *bdev, struct file *filp, unsigned int
 			NAND_Ioctl(DEV_SET_ALIGEN_CACHE,(void *)arg);
 			break;
 		}
-
+		
+		case IOCTL_NDD_GET_SERIALNUMBER:
+		{
+			if ( !NAND_GetSerialNumber((unsigned char* )arg, 32 ))
+				return -EFAULT;
+			break;
+		}
 		case IOCTL_STORAGE_PING:
 		{
 			// ping
@@ -361,7 +503,7 @@ static int ndd_ioctl (struct block_device *bdev, struct file *filp, unsigned int
 				buf = sdArg.buf;
 			}
 			if ((sector + nsect) > (start_sect + nr_sects)) {
-				printk("beyond-end read (%d + %d >= %lu)\n", sector, nsect, start_sect + nr_sects);
+				printk("beyond-end read (%d + %d >= %lu)\n", sector, nsect, (long unsigned int)(start_sect + nr_sects));
 				return -EFAULT;
 			}
 			if (NAND_ReadSector(0, sector, nsect, buf)) {
@@ -402,7 +544,7 @@ static int ndd_ioctl (struct block_device *bdev, struct file *filp, unsigned int
 				buf = sdArg.buf;
 			}
 			if ((sector + nsect) > (start_sect + nr_sects)) {
-				printk("beyond-end write (%d + %d >= %lu)\n", sector, nsect, start_sect + nr_sects);
+				printk("beyond-end write (%d + %d >= %lu)\n", sector, nsect, (long unsigned int)(start_sect + nr_sects));
 				return -EFAULT;
 			}
 			if (NAND_WriteSector(0, sector, nsect, buf)) {
@@ -460,143 +602,791 @@ static int ndd_release(struct gendisk *disk, fmode_t mode)
 	return 0;
 }
 
-static int __init ndd_init(void)
+#ifdef __USE_NAND_ISR__
+static int nand_get_next_req( struct request_queue *q, struct request *req )
 {
-	int res, i;
+	unsigned int	i;
+	
+	end_request(req, 1);
 
-#ifdef __USE_TCC_NAND_WORK_Q__
-    mutex_init(&(tcc_nand_data.mutex));
-    sema_init(&(tcc_nand_data.sem), 0);
-    tcc_nand_data.wq_ptr = create_workqueue("nand_work_q");
-    if (tcc_nand_data.wq_ptr == NULL) {
-        return -ENOMEM;
+    spin_lock_irq(q->queue_lock);
+    if (!blk_queue_plugged(q))
+	{
+        req = elv_next_request(q);
     }
+    spin_unlock_irq(q->queue_lock);
+	
+	i =	req->sector;
+	n_printk("-req--:[%d]-[%lu-%d]\n",i, req->nr_sectors, req->current_nr_sectors);
 
-    INIT_WORK(&(tcc_nand_data.nand_work), tcc_nand_func);
-#endif
+	return 0;
+}
+
+static irqreturn_t nand_isr_rb(int irq, void *dev_id)
+{
+	#ifdef __USE_NAND_ISR_WRITE__					
+	unsigned int		i;
+	unsigned int		ret;
+	unsigned int		rEccBuffer;
+	unsigned char		*pPhy_Buffer;
+	#endif
 	
-	/* DTCM mapping */
-	//virtadr = (void __iomem *)ioremap(IO_NFC_BUFFER0_BASE, 512);
-	//printk("DTCM ioremap %s: 0x%08X -> 0x%08X\n", virtadr?"OK":"FAIL", IO_NFC_BUFFER0_BASE, virtadr);
-	//if (!virtadr) {
-	//	printk("ndd: ioremap failed\n");
-	//	iounmap((void *)virtadr);
-	//	return -EIO;
-	//}
+	if( ndd_isr_rb_enable_flag == NDD_RB_INTR_MODE_READ )
+	{
+		//==========================================
+		// R/B Interrupt Clear
+		//==========================================
+		ndd_isr_rb_enable_flag = NDD_RB_INTR_MODE_NORMAL;
+		NAND_IO_IRQ_ReadyBusyClear();
+	    n_printk("[Read]Ready Interrupt\n");
+		#ifdef NAND_GPIO_DEBUG
+		BITCLR(nand_intr_rb.p_gpio->GPFDAT, Hw21);
+		#endif	
+		
+		// NAND Ready--------------------------------------------------------------
+		nand_intr_rb.intr_mode 	= INTR_MODE_READ_ECC;
 
-	/* DMA alloc */
-	dma_t.buf_size = 1024;
-	dma_t.v_addr = dma_alloc_writecombine(0, dma_t.buf_size, &dma_t.dma_addr, GFP_KERNEL);
-	//printk("[tcc_nand] alloc DMA buffer @0x%08X(phy=0x%08X), size=%d\n", 
-	//		(unsigned int)dma_t.v_addr, dma_t.dma_addr, dma_t.buf_size);
+		NAND_IO_IRQ_SetupDMAForSpare( nand_intr_rb.nDevInfo->EccWholeDataSize );		
+	}
+	#ifdef __USE_NAND_ISR_WRITE__	
+	else if ( ndd_isr_rb_enable_flag == NDD_RB_INTR_MODE_WRITE )
+	{
+		//==========================================
+		// R/B Interrupt Clear
+		//==========================================
+		ndd_isr_rb_enable_flag = NDD_RB_INTR_MODE_NORMAL;
+		NAND_IO_IRQ_ReadyBusyClear();
+	    n_printk("[Write]Ready Interrupt\n");
+		#ifdef NAND_GPIO_DEBUG
+		BITCLR(nand_intr_rb.p_gpio->GPFDAT, Hw21);
+		#endif	
+
+		NAND_IO_IRQ_WritePagePostProcess();
+
+		nand_intr_rb.nPageIndex += 1;
+		
+		if ( nand_intr_rb.nPageIndex == nand_intr_rb.nWorkInfo->PhyPageNum )
+		{
+		    n_printk("[%d]Page Write Complete--Wake Up\n", nand_intr_rb.nWorkInfo->PhyPageNum );
+
+			nand_intr_rb.intr_mode = INTR_MODE_NORMAL;
+			nand_intr_rb.is_nd_busy_complete = 1;
+			#ifdef NAND_GPIO_DEBUG
+			BITSET(nand_intr_rb.p_gpio->GPFDAT, Hw17);
+			#endif					
+		    wake_up(&(nand_intr_rb.nd_busy_wait_q));
+		    return IRQ_HANDLED;					
+		}
+		else
+		{
+			if ( nand_intr_rb.current_nr_sectors == 0 )
+			{
+				n_printk("\n");
+				nand_get_next_req( nand_intr_rb.request_q, nand_intr_rb.req );
 
-	gNAND_PageBuffer = (unsigned char *)( ((unsigned int)gNAND_PageBuffer + 8) & 0xFFFFFFF8 );
+				for ( i = 0; i < nand_intr_rb.req->current_nr_sectors; ++i )
+				{
+					nand_intr_rb.nWorkInfo->BufferAddr[ nand_intr_rb.nSectorIndex + i ] = (unsigned int )( nand_intr_rb.req->buffer + (i << 9));
+				}
+				
+				nand_intr_rb.current_nr_sectors = nand_intr_rb.req->current_nr_sectors;
+			}
 
-	for (i = 0; i < MAX_NDD_DEV ; i++) {
-		/*
-		 * NAND INIT - NAND_Ioctl(DEV_INITIALIZE)
-		 */
+			nand_intr_rb.nStartPPage	= 0;//nWorkInfo->StartPPageNo[0];
+			nand_intr_rb.nReadPPSize 	= nand_intr_rb.nWorkInfo->FTLPPage;//PPageSize[0];
+			nand_intr_rb.intr_mode 		= INTR_MODE_WRITE_PAGE;
+			nand_intr_rb.nCurrPPage		= 0;
+	
+			ret = NAND_IO_IRQ_WritePagePreProcess( nand_intr_rb.nDevInfo, 
+				                 					  nand_intr_rb.nWorkInfo->PhyPageAddr[nand_intr_rb.nPageIndex], 
+													  nand_intr_rb.nWorkInfo->StartPPageNo[nand_intr_rb.nPageIndex],
+									  				  nand_intr_rb.nSpareBuffer, &rEccBuffer, 
+									  				  nand_intr_rb.nWorkInfo->ChipNo[nand_intr_rb.nPageIndex],
+									  				  nand_intr_rb.nWorkInfo->PageWriteFunc[nand_intr_rb.nPageIndex] );
+			if (ret != SUCCESS)
+			{
+				printk("\nNAND_IO_IRQ_WritePagePreProcess - ERROR!!!!!" );
+			}
+			nand_intr_rb.nEccBuffer = (unsigned char*)rEccBuffer;
 
-		NAND_Ioctl(DEV_INITIALIZE, NULL);
+			nand_intr_rb.intr_mode = INTR_MODE_WRITE_PAGE;
+			NAND_IO_IRQ_Write512DataPreProcess(nand_intr_rb.nDevInfo);		// ECC Setup
+
+			if (( nand_intr_rb.nCurrPPage >= nand_intr_rb.nWorkInfo->StartPPageNo[nand_intr_rb.nPageIndex] ) &&
+				( nand_intr_rb.nCurrPPage < nand_intr_rb.nWorkInfo->StartPPageNo[nand_intr_rb.nPageIndex] + nand_intr_rb.nWorkInfo->PPageSize[nand_intr_rb.nPageIndex] ))
+			{
+				pPhy_Buffer = (unsigned char*)virt_to_phys((unsigned char*)nand_intr_rb.nWorkInfo->BufferAddr[nand_intr_rb.nSectorIndex] );				
+				++nand_intr_rb.nSectorIndex;
+			}
+			else
+			{
+				if ( nand_intr_rb.nWorkInfo->PageWriteFunc[nand_intr_rb.nPageIndex] == MULTI_PLANE_STUFF_PAGE )
+				{
+					n_printk("CurrPPage:%d - StartPPage:%d, Size:%d", nand_intr_rb.nCurrPPage, nand_intr_rb.nWorkInfo->StartPPageNo[nand_intr_rb.nPageIndex], nand_intr_rb.nWorkInfo->PPageSize[nand_intr_rb.nPageIndex] );				
+				    n_printk("StuffPageCopy:0x%x\n", nand_intr_rb.nWorkInfo->StuffInfo.nStuffPageBuffer );					
+					memcpy( dma_t.v_addr, nand_intr_rb.nWorkInfo->StuffInfo.nStuffPageBuffer, 512 );
+					nand_intr_rb.nWorkInfo->StuffInfo.nStuffPageBuffer += 512;
+					pPhy_Buffer = (unsigned char*)dma_t.dma_addr;
+				}
+				else
+				{	
+					//null page
+					n_printk("[%s:%d] Null Page Write!!!\n", __func__, __LINE__);
+					memset( dma_t.v_addr, 0xFF, 512 );
+					pPhy_Buffer = (unsigned char*)dma_t.dma_addr;
+				}
+			}
 
-#if 0		/* 09.07.24 */
-		NAND_Init();
+			NAND_IO_IRQ_SetupDMA((U8*)pPhy_Buffer, NAND_IO_DMA_WRITE );
+		}
+	}
+	#endif	
+	else
+	{
+	    BITSET(nand_intr_rb.pPIC->IEN0, ( 1 << NAND_IRQ_READY ));
+	    BITCLR(nand_intr_rb.pPIC->IRQ0, ( 1 << NAND_IRQ_READY ));
 	
-		if ( gNAND_PartitionInfoLoadFlag == DISABLE )
-			NAND_InitExtPartitionInfo();
-		else
-			TNFTL_SetExtendedPartitionNums( NAND_DRV_0, (U16)gTNFTL_ExtPartitionInfo[NAND_DRV_0].ExtendedPartitionNum );
+	    printk("Dumy-Ready Interrupt-!!!!!!!!!!!!!!!!\n");		
 		
-		for ( i = 0; i < gTNFTL_ExtPartitionInfo[NAND_DRV_0].ExtendedPartitionNum; ++i )
+	}
+	
+    return IRQ_HANDLED;
+}
+
+static irqreturn_t nand_isr(int irq, void *dev_id)
+{
+	unsigned int		i;
+	unsigned int		current_req_sector, nPPageSize;
+	unsigned char		*pPhy_Buffer;
+    nand_intr_info *p_nand = (nand_intr_info *)dev_id;
+	unsigned int		ColumnAddr;
+	U32					rEccBuffer;
+	#ifdef __USE_NAND_ISR_WRITE__
+	U32 				ret;
+	#endif
+
+   n_printk("start---------> pNFC->NFC_IREQ [0x%08X]\n", p_nand->p_nfc->NFC_IREQ);
+	//===============================================
+	// DMA Read IRQ
+	//===============================================
+    if (p_nand->p_nfc->NFC_IREQ & Hw0)
+	{
+        BITSET(p_nand->p_nfc->NFC_IREQ, Hw0);
+
+		#ifdef NAND_GPIO_DEBUG
+		BITCLR(nand_intr_rb.p_gpio->GPFDAT, Hw21);
+		#endif
+	
+		if ( nand_intr_rb.intr_mode == INTR_MODE_NORMAL )
 		{
-			TNFTL_AREASetTotalSectorSize( gNAND_DrvInfo[0].NFTLDrvInfo,
-										  &gNAND_DrvInfo[0].NFTLDrvInfo->ExtPartition[i],
-										  gTNFTL_ExtPartitionInfo[NAND_DRV_0].ExtPartitionSize[i] );
+	        n_printk("RX interrupt in nand \n");
+
+	        //BITSET(p_nand->p_nfc->NFC_IREQ, Hw0);
+	        p_nand->is_rx_complete = 1;
+	        //wake_up(&(p_nand->rx_wait_q));
+		}
+		else if ( nand_intr_rb.intr_mode == INTR_MODE_READ_PAGE )
+		{
+		    n_printk("PostProcess_Page:%d\n\n", (nand_intr_rb.nReadPPSize) );
+			// ECC Correction
+			NAND_IO_IRQ_Read512DataPostProcess( nand_intr_rb.nDevInfo, (U8*)nand_intr_rb.nWorkInfo->BufferAddr[nand_intr_rb.nSectorIndex], nand_intr_rb.nEccBuffer);		// 11us
+			nand_intr_rb.nSectorIndex 		+= 1;
+			nand_intr_rb.nEccBuffer  		+= nand_intr_rb.nDevInfo->EccDataSize;
+			nand_intr_rb.nReadPPSize 		-= 1;
+			nand_intr_rb.current_nr_sectors -= 1;
+
+			if ( nand_intr_rb.nReadPPSize )
+			{
+				//-------------------------
+				// Next PPage Read
+				//-------------------------
+			    n_printk("Read_DMA_Page:%d\n", nand_intr_rb.nReadPPSize  );
+				NAND_IO_IRQ_Read512DataPreProcess( nand_intr_rb.nDevInfo );
+
+				if ( nand_intr_rb.current_nr_sectors == 0 )
+				{
+					n_printk("\n");
+					nand_get_next_req( nand_intr_rb.request_q, nand_intr_rb.req );
+
+					for ( i = 0; i < nand_intr_rb.req->current_nr_sectors; ++i )
+					{
+						nand_intr_rb.nWorkInfo->BufferAddr[ nand_intr_rb.nSectorIndex + i ] = (unsigned int )( nand_intr_rb.req->buffer + (i << 9));
+					}
+					
+					nand_intr_rb.current_nr_sectors = nand_intr_rb.req->current_nr_sectors;
+				}
+
+				// DMA Setup & Start				
+				pPhy_Buffer = (unsigned char*)virt_to_phys((unsigned char*)nand_intr_rb.nWorkInfo->BufferAddr[nand_intr_rb.nSectorIndex] );
+				NAND_IO_IRQ_SetupDMA((void*)pPhy_Buffer, NAND_IO_DMA_READ );
+			}
+			else
+			{
+		        //BITSET(p_nand->p_nfc->NFC_IREQ, Hw0);
+
+				nand_intr_rb.nPageIndex += 1;
+				if ( nand_intr_rb.nPageIndex == nand_intr_rb.nWorkInfo->PhyPageNum )
+				{
+				    n_printk("[%d]Page Read Complete--Wake Up\n", nand_intr_rb.nWorkInfo->PhyPageNum );
+
+					nand_intr_rb.intr_mode = INTR_MODE_NORMAL;
+					nand_intr_rb.is_nd_busy_complete = 1;
+					#ifdef NAND_GPIO_DEBUG
+					BITSET(nand_intr_rb.p_gpio->GPFDAT, Hw17);
+					#endif					
+				    wake_up(&(nand_intr_rb.nd_busy_wait_q));
+				    return IRQ_HANDLED;					
+				}
+				else
+				{
+					current_req_sector = nand_intr_rb.current_nr_sectors;
+					
+					while( nand_intr_rb.nWorkInfo->PhyPageAddr[nand_intr_rb.nPageIndex] == TNFTL_U32_NULL )
+					{
+						n_printk("NULL Page Memset\n");
+
+						if ( nand_intr_rb.nWorkInfo->PPageSize[nand_intr_rb.nPageIndex] <= current_req_sector )
+							nPPageSize = nand_intr_rb.nWorkInfo->PPageSize[nand_intr_rb.nPageIndex];
+						else
+							nPPageSize = current_req_sector;
+
+						for ( i = 0; i < nPPageSize; ++i )
+						{
+							memset( (void*)nand_intr_rb.nWorkInfo->BufferAddr[ nand_intr_rb.nSectorIndex ], 0xFF, 512 );
+							nand_intr_rb.nSectorIndex += 1;
+							current_req_sector -= 1;
+						}
+
+						nand_intr_rb.nPageIndex += 1;
+
+						if( nand_intr_rb.nPageIndex == nand_intr_rb.nWorkInfo->PhyPageNum )
+						{
+						    n_printk("[%d]Page Read Complete--Wake Up\n", nand_intr_rb.nWorkInfo->PhyPageNum );
+
+							nand_intr_rb.intr_mode = INTR_MODE_NORMAL;
+							nand_intr_rb.is_nd_busy_complete = 1;
+							#ifdef NAND_GPIO_DEBUG
+							BITSET(nand_intr_rb.p_gpio->GPFDAT, Hw17);
+							#endif
+						    wake_up(&(nand_intr_rb.nd_busy_wait_q));
+						    return IRQ_HANDLED;
+						}
+
+						if ( current_req_sector == 0 )
+						{
+							n_printk("\n");
+							nand_get_next_req( nand_intr_rb.request_q, nand_intr_rb.req );
+
+							for ( i = 0; i < nand_intr_rb.req->current_nr_sectors; ++i )
+							{
+								nand_intr_rb.nWorkInfo->BufferAddr[ nand_intr_rb.nSectorIndex + i ] = (unsigned int )( nand_intr_rb.req->buffer + (i << 9));
+							}
+							
+							nand_intr_rb.current_nr_sectors = nand_intr_rb.req->current_nr_sectors;
+							current_req_sector = nand_intr_rb.current_nr_sectors;
+						}
+					}
+
+					if ( nand_intr_rb.nPageIndex == nand_intr_rb.nWorkInfo->PhyPageNum )
+					{
+					    n_printk("[%d]Page Read Complete--Wake Up\n", nand_intr_rb.nWorkInfo->PhyPageNum );
+						nand_intr_rb.intr_mode = INTR_MODE_NORMAL;
+						nand_intr_rb.is_nd_busy_complete = 1;
+						#ifdef NAND_GPIO_DEBUG
+						BITSET(nand_intr_rb.p_gpio->GPFDAT, Hw17);
+						#endif
+					    wake_up(&(nand_intr_rb.nd_busy_wait_q));
+					    return IRQ_HANDLED;
+					}
+
+					n_printk("Read Page Start+++++++++++\n");
+				    n_printk("[%d/%d]Page Read -- Next Page Read Start\n", nand_intr_rb.nPageIndex, nand_intr_rb.nWorkInfo->PhyPageNum );
+
+					//==================================================
+					// Set Work Info
+					//==================================================
+				//	nand_intr_rb.nDevInfo->ChipNo 	= nand_intr_rb.nWorkInfo->ChipNo[ nand_intr_rb.nPageIndex ];
+					nand_intr_rb.nStartPPage		= nand_intr_rb.nWorkInfo->StartPPageNo[ nand_intr_rb.nPageIndex ];
+					nand_intr_rb.nReadPPSize 		= nand_intr_rb.nWorkInfo->PPageSize[ nand_intr_rb.nPageIndex ];
+					nand_intr_rb.intr_mode 			= INTR_MODE_READ_ECC;
+			
+					//===================================================
+					// Read PreProcess
+					//===================================================
+					NAND_IO_IRQ_ReadPagePreProcess( nand_intr_rb.nDevInfo, 
+													   nand_intr_rb.nWorkInfo->PhyPageAddr[nand_intr_rb.nPageIndex],
+													   nand_intr_rb.nWorkInfo->StartPPageNo[nand_intr_rb.nPageIndex], 
+													   &rEccBuffer,
+													   nand_intr_rb.nWorkInfo->ChipNo[ nand_intr_rb.nPageIndex ]);
+
+					nand_intr_rb.nEccBuffer = (unsigned char*)rEccBuffer;
+
+					ndd_isr_rb_enable_flag = NDD_RB_INTR_MODE_READ;
+					NAND_IO_IRQ_ReadyBusySet();
+				}
+			}
 		}
+		else if ( nand_intr_rb.intr_mode == INTR_MODE_READ_ECC )
+		{
+		    n_printk("Read_ECC_Data Complete\n\n" );
+			/* Change Cycle */
+			NAND_IO_SetCommCycleTime();
+			
+			/* Command Random Data Output [ 0x05 ] for Advance NandFlash */
+			nand_intr_rb.p_nfc->NFC_CMD = nand_intr_rb.nDevInfo->CmdMask & 0x0505;
+			
+			ColumnAddr = ( nand_intr_rb.nStartPPage<< 9 );
+			ColumnAddr	= ( nand_intr_rb.nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT ) ? (ColumnAddr >> 1) : ColumnAddr;
+	
+			NAND_IO_WriteColAddr( ColumnAddr, nand_intr_rb.nDevInfo );
 
-		gNAND_DrvInfo[i].DrvStatus = DISABLE;
+			/* Command Random Data Output [ 0xE0 ] for Advance NandFlash */
+			nand_intr_rb.p_nfc->NFC_CMD = nand_intr_rb.nDevInfo->CmdMask & 0xE0E0;
 
-		res = NAND_InitDrive(i); 
-		if (res != SUCCESS) {
-			printk("ndd: TNFTL(%s, %s) init failed(0x%08x)\n", TCC_ARCH, NAND_VER, res);
-			return EINITFAIL;
+			/* Change Cycle */
+			NAND_IO_SetReadCycleTime();
+
+			nand_intr_rb.intr_mode = INTR_MODE_READ_PAGE;
+		    n_printk("Read_DMA_Page:%d\n", nand_intr_rb.nReadPPSize  );
+			NAND_IO_IRQ_Read512DataPreProcess( nand_intr_rb.nDevInfo );
+
+			if ( nand_intr_rb.current_nr_sectors == 0 )
+			{
+				n_printk("\n");
+				nand_get_next_req( nand_intr_rb.request_q, nand_intr_rb.req );
+
+				for ( i = 0; i < nand_intr_rb.req->current_nr_sectors; ++i )
+				{
+					nand_intr_rb.nWorkInfo->BufferAddr[ nand_intr_rb.nSectorIndex + i ] = (unsigned int )( nand_intr_rb.req->buffer + (i << 9));
+				}
+				
+				nand_intr_rb.current_nr_sectors = nand_intr_rb.req->current_nr_sectors;
+			}
+
+			// DMA Setup & Start
+			pPhy_Buffer = (unsigned char*)virt_to_phys( (unsigned char*)nand_intr_rb.nWorkInfo->BufferAddr[nand_intr_rb.nSectorIndex] );
+			NAND_IO_IRQ_SetupDMA((void*)pPhy_Buffer, NAND_IO_DMA_READ );
 		}
+    }
+	else if (p_nand->p_nfc->NFC_IREQ & Hw1)
+	{
+		BITSET(p_nand->p_nfc->NFC_IREQ, Hw1);
+		n_printk("TX interrupt in nand \n");
+        //p_nand->is_tx_complete = 1;
+		#ifdef __USE_NAND_ISR_WRITE__
+		//===============================================
+		// DMA Write IRQ
+		//===============================================
+		if ( nand_intr_rb.intr_mode == INTR_MODE_WRITE_PAGE )
+		{
+			NAND_IO_IRQ_Write512DataPostProcess(nand_intr_rb.nDevInfo, nand_intr_rb.nEccBuffer);
+			nand_intr_rb.nEccBuffer 		+= nand_intr_rb.nDevInfo->EccDataSize;
+			nand_intr_rb.nCurrPPage 		+= 1;
+			nand_intr_rb.nReadPPSize 		-= 1;
+			nand_intr_rb.current_nr_sectors -= 1;
+
+			if ( nand_intr_rb.nReadPPSize )
+			{
+				//======================
+				// Next PPage Writ
+				//======================
+//				if ( nand_intr_rb.current_nr_sectors == 0 )
+				if (( nand_intr_rb.current_nr_sectors == 0 ) && 
+					( nand_intr_rb.req->current_nr_sectors == nand_intr_rb.nWorkInfo->FTLPPage ) &&
+					(nand_intr_rb.req->current_nr_sectors != nand_intr_rb.req->nr_sectors))
+				{
+					n_printk("\n");
+					nand_get_next_req( nand_intr_rb.request_q, nand_intr_rb.req );
+
+					for ( i = 0; i < nand_intr_rb.req->current_nr_sectors; ++i )
+					{
+						nand_intr_rb.nWorkInfo->BufferAddr[ nand_intr_rb.nSectorIndex + i ] = (unsigned int )( nand_intr_rb.req->buffer + (i << 9));
+					}
+					
+					nand_intr_rb.current_nr_sectors = nand_intr_rb.req->current_nr_sectors;
+				}
+
+			    n_printk("Write_DMA_Page:%d\n", nand_intr_rb.nReadPPSize );
+				
+				nand_intr_rb.intr_mode = INTR_MODE_WRITE_PAGE;
+				NAND_IO_IRQ_Write512DataPreProcess(nand_intr_rb.nDevInfo);		// ECC Setup
+
+				if (( nand_intr_rb.nCurrPPage >= nand_intr_rb.nWorkInfo->StartPPageNo[nand_intr_rb.nPageIndex] ) &&
+					( nand_intr_rb.nCurrPPage < ( nand_intr_rb.nWorkInfo->StartPPageNo[nand_intr_rb.nPageIndex] + nand_intr_rb.nWorkInfo->PPageSize[nand_intr_rb.nPageIndex] )))
+				{
+					pPhy_Buffer = (unsigned char*)virt_to_phys((unsigned char*)nand_intr_rb.nWorkInfo->BufferAddr[nand_intr_rb.nSectorIndex] );
+					++nand_intr_rb.nSectorIndex;
+				}
+				else
+				{
+					if ( nand_intr_rb.nWorkInfo->PageWriteFunc[nand_intr_rb.nPageIndex] == MULTI_PLANE_STUFF_PAGE )
+					{
+						n_printk("CurrPPage:%d - StartPPage:%d, Size:%d", nand_intr_rb.nCurrPPage, nand_intr_rb.nWorkInfo->StartPPageNo[nand_intr_rb.nPageIndex], nand_intr_rb.nWorkInfo->PPageSize[nand_intr_rb.nPageIndex] );						
+					    n_printk("StuffPageCopy:0x%x\n", nand_intr_rb.nWorkInfo->StuffInfo.nStuffPageBuffer );
+						memcpy( dma_t.v_addr, nand_intr_rb.nWorkInfo->StuffInfo.nStuffPageBuffer, 512 );
+						nand_intr_rb.nWorkInfo->StuffInfo.nStuffPageBuffer += 512;
+						pPhy_Buffer = (unsigned char*)dma_t.dma_addr;
+					}
+					else
+					{	
+						//null page
+						n_printk("[%s:%d] Null Page Write!!!\n", __func__, __LINE__);
+						memset( dma_t.v_addr, 0xFF, 512 );
+						pPhy_Buffer = (unsigned char*)dma_t.dma_addr;
+					}
+				}
+
+				NAND_IO_IRQ_SetupDMA((U8*)pPhy_Buffer, NAND_IO_DMA_WRITE );				
+			}
+			else
+			{
+				//======================
+				// Write Spare
+				//======================
+				n_printk("Write Spare + ECC Data\n");
+				NAND_IO_WriteSpareData(nand_intr_rb.nDevInfo, nand_intr_rb.nWorkInfo->nSpareBuffer, PAGE_ECC_ON );
+				nand_intr_rb.nWorkInfo->nSpareBuffer += 16;
+				NAND_IO_IRQ_WritePageMidProcess( nand_intr_rb.nDevInfo, nand_intr_rb.nWorkInfo->PageWriteFunc[nand_intr_rb.nPageIndex] );
+
+				if ( !( ( nand_intr_rb.nDevInfo->Feature.MediaType & S_IL ) || ( nand_intr_rb.nDevInfo->ExtInterleaveUsable == TRUE ) ) )
+				{
+					ndd_isr_rb_enable_flag = NDD_RB_INTR_MODE_WRITE;
+					NAND_IO_IRQ_ReadyBusySet();
+				    return IRQ_HANDLED;					
+				}
+
+				if (( nand_intr_rb.nWorkInfo->PageWriteFunc[nand_intr_rb.nPageIndex] == MULTI_PLANE_NORMAL_PAGE ) || 
+					( nand_intr_rb.nWorkInfo->PageWriteFunc[nand_intr_rb.nPageIndex] == MULTI_PLANE_STUFF_PAGE ) ||
+					( nand_intr_rb.nWorkInfo->PageWriteFunc[nand_intr_rb.nPageIndex] == MULTI_PLANE_MID_PAGE ) ||
+					( nand_intr_rb.nWorkInfo->PageWriteFunc[nand_intr_rb.nPageIndex] == MULTI_PLANE_LAST_PAGE ))
+				{
+					NAND_IO_SetInterleaveStatus( nand_intr_rb.nDevInfo, nand_intr_rb.nWorkInfo->PhyPageAddr[nand_intr_rb.nPageIndex] );
+					NAND_IO_SetInterLeavePageAddr( nand_intr_rb.nWorkInfo->PhyPageAddr[nand_intr_rb.nPageIndex] );
+				}
+
+				// Next PPage Write Start~~~~~
+				NAND_IO_IRQ_WritePagePostProcess();
+
+				nand_intr_rb.nPageIndex += 1;
+				
+				if ( nand_intr_rb.nPageIndex == nand_intr_rb.nWorkInfo->PhyPageNum )
+				{
+				    n_printk("[%d]Page Write Complete--Wake Up\n", nand_intr_rb.nWorkInfo->PhyPageNum );
+
+					nand_intr_rb.intr_mode = INTR_MODE_NORMAL;
+					nand_intr_rb.is_nd_busy_complete = 1;
+					#ifdef NAND_GPIO_DEBUG
+					BITSET(nand_intr_rb.p_gpio->GPFDAT, Hw17);
+					#endif
+				    wake_up(&(nand_intr_rb.nd_busy_wait_q));
+				    return IRQ_HANDLED;				
+				}
+				else
+				{
+					if ( nand_intr_rb.current_nr_sectors == 0 )
+					{
+						n_printk("\n");
+						nand_get_next_req( nand_intr_rb.request_q, nand_intr_rb.req );
+
+						for ( i = 0; i < nand_intr_rb.req->current_nr_sectors; ++i )
+						{
+							nand_intr_rb.nWorkInfo->BufferAddr[ nand_intr_rb.nSectorIndex + i ] = (unsigned int )( nand_intr_rb.req->buffer + (i << 9));
+						}
+						
+						nand_intr_rb.current_nr_sectors = nand_intr_rb.req->current_nr_sectors;
+					}
+
+					nand_intr_rb.nStartPPage	= 0;//nWorkInfo->StartPPageNo[0];
+					nand_intr_rb.nReadPPSize 	= nand_intr_rb.nWorkInfo->FTLPPage;//PPageSize[0];
+					nand_intr_rb.intr_mode 		= INTR_MODE_WRITE_PAGE;
+					nand_intr_rb.nCurrPPage		= 0;
+			
+					ret = NAND_IO_IRQ_WritePagePreProcess( nand_intr_rb.nDevInfo, 
+						                 					  nand_intr_rb.nWorkInfo->PhyPageAddr[nand_intr_rb.nPageIndex], 
+															  nand_intr_rb.nWorkInfo->StartPPageNo[nand_intr_rb.nPageIndex],
+											  				  nand_intr_rb.nSpareBuffer, &rEccBuffer, 
+											  				  nand_intr_rb.nWorkInfo->ChipNo[nand_intr_rb.nPageIndex],
+											  				  nand_intr_rb.nWorkInfo->PageWriteFunc[nand_intr_rb.nPageIndex] );
+					if (ret != SUCCESS)
+					{
+						printk("\nNAND_IO_IRQ_WritePagePreProcess - ERROR!!!!!" );
+					}
+					nand_intr_rb.nEccBuffer = (unsigned char*)rEccBuffer;
+
+					nand_intr_rb.intr_mode = INTR_MODE_WRITE_PAGE;
+					NAND_IO_IRQ_Write512DataPreProcess(nand_intr_rb.nDevInfo);		// ECC Setup
+
+					if (( nand_intr_rb.nCurrPPage >= nand_intr_rb.nWorkInfo->StartPPageNo[nand_intr_rb.nPageIndex] ) &&
+						( nand_intr_rb.nCurrPPage < nand_intr_rb.nWorkInfo->StartPPageNo[nand_intr_rb.nPageIndex] + nand_intr_rb.nWorkInfo->PPageSize[nand_intr_rb.nPageIndex] ))
+					{
+						pPhy_Buffer = (unsigned char*)virt_to_phys((unsigned char*)nand_intr_rb.nWorkInfo->BufferAddr[nand_intr_rb.nSectorIndex] );				
+						++nand_intr_rb.nSectorIndex;
+					}
+					else
+					{
+						if ( nand_intr_rb.nWorkInfo->PageWriteFunc[nand_intr_rb.nPageIndex] == MULTI_PLANE_STUFF_PAGE )
+						{
+							n_printk("CurrPPage:%d - StartPPage:%d, Size:%d", nand_intr_rb.nCurrPPage, nand_intr_rb.nWorkInfo->StartPPageNo[nand_intr_rb.nPageIndex], nand_intr_rb.nWorkInfo->PPageSize[nand_intr_rb.nPageIndex] );
+						    //n_printk("StuffPageCopy:0x%x\n", nand_intr_rb.nWorkInfo->StuffInfo.nStuffPageBuffer );						
+							memcpy( dma_t.v_addr, nand_intr_rb.nWorkInfo->StuffInfo.nStuffPageBuffer, 512 );
+							nand_intr_rb.nWorkInfo->StuffInfo.nStuffPageBuffer += 512;
+							pPhy_Buffer = (unsigned char*)dma_t.dma_addr;
+						}
+						else
+						{	
+							//null page
+							printk("[%s:%d] Error!!!\n", __func__, __LINE__);
+							pPhy_Buffer = NULL;
+						}
+					}
+
+					NAND_IO_IRQ_SetupDMA((U8*)pPhy_Buffer, NAND_IO_DMA_WRITE );
+				}
+				return IRQ_HANDLED;				
+			}
+		}
+		else
+		#endif			
+		{
+	        printk("unknown TX interrupt in nand !!!\n");
+		}
+    }
+	else 
+	{
+        printk("unknown interrupt in nand !!!\n");
+    }
 	
-		TNFTL_AREAGetTotalSecAndCHS( gNAND_DrvInfo[0].NFTLDrvInfo,
-					 			     &gNAND_DrvInfo[0].NFTLDrvInfo->PriPartition,
-					 			     (U32 *)&gNAND_DrvInfo[0].TotalDiskSector,
-					 			     &gNAND_DrvInfo[0].Cylinder,
-					 			     &gNAND_DrvInfo[0].Head,
-					 			     &gNAND_DrvInfo[0].Sector );
+    return IRQ_HANDLED;
+}
 
-		gNAND_DrvInfo[i].DrvStatus = ENABLE;
-#endif /* 0 */
-		//<-- end of NAND_INIT
+#ifdef __USE_NAND_ISR_WRITE__
+static int nand_isr_write( struct request_queue *request_q, struct request *req )
+{
+	unsigned int		current_req_sector;
+    int 				ret = 0;
+	unsigned char		*pPhy_Buffer;
+	U32					rEccBuffer;
+	Device 				*dev;
+	ndd_work_info 		*nWorkInfo;
+
+	dev = req->rq_disk->private_data;
+	nWorkInfo = dev->nand_work_info;
+
+    n_printk("Nand Write Start+++++++++++++++++++++++++++++++++++++++++++++++++++++++ \n");
+
+	#ifdef NAND_GPIO_DEBUG		/* 09.12.22 */
+	BITSET(nand_intr_rb.p_gpio->GPFDAT, Hw16);
+	#endif /* NAND_GPIO_DEBUG */
+				
+	//==================================================
+	// Set Work Info
+	//==================================================
+	nand_intr_rb.nDevInfo 		= nWorkInfo->nDevInfo;
+	nand_intr_rb.nStartPPage	= 0;//nWorkInfo->StartPPageNo[0];
+	nand_intr_rb.nReadPPSize 	= nWorkInfo->FTLPPage;//PPageSize[0];
+	nand_intr_rb.intr_mode 		= INTR_MODE_WRITE_PAGE;
+	nand_intr_rb.nSectorIndex	= 0;
+	nand_intr_rb.nPageIndex		= 0;
+	nand_intr_rb.nCurrPPage		= 0;
+	nand_intr_rb.nWorkInfo		= nWorkInfo;
+	nand_intr_rb.request_q		= request_q;
+	nand_intr_rb.req			= req;
+	nand_intr_rb.current_nr_sectors = req->current_nr_sectors;
+
+	current_req_sector = nand_intr_rb.current_nr_sectors;
+
+	if ( nand_intr_rb.nPageIndex == nand_intr_rb.nWorkInfo->PhyPageNum ) 
+		return 0;
+
+	ret = NAND_IO_IRQ_WritePagePreProcess( nand_intr_rb.nDevInfo, 
+											  nWorkInfo->PhyPageAddr[nand_intr_rb.nPageIndex], 
+											  nWorkInfo->StartPPageNo[nand_intr_rb.nPageIndex],
+											  nand_intr_rb.nSpareBuffer, &rEccBuffer, 
+											  nWorkInfo->ChipNo[nand_intr_rb.nPageIndex],
+											  nWorkInfo->PageWriteFunc[nand_intr_rb.nPageIndex] );
+	if (ret != SUCCESS)
+	{
+		printk("\nNAND_IO_IRQ_WritePagePreProcess - ERROR!!!!!" );
+	}
+	nand_intr_rb.nEccBuffer = (unsigned char*)rEccBuffer;
 
-		res = register_blkdev(NDD_DEV_MAJOR, NDD_DEV_NAME); 
-		if (res < 0) {
-			printk(KERN_WARNING "ndd: unable to get major number.\n");
-			return -EBUSY;
+	nand_intr_rb.intr_mode = INTR_MODE_WRITE_PAGE;
+	NAND_IO_IRQ_Write512DataPreProcess(nand_intr_rb.nDevInfo);		// ECC Setup
+
+	if (( nand_intr_rb.nCurrPPage >= nWorkInfo->StartPPageNo[nand_intr_rb.nPageIndex] ) &&
+		( nand_intr_rb.nCurrPPage < nWorkInfo->StartPPageNo[nand_intr_rb.nPageIndex] + nWorkInfo->PPageSize[nand_intr_rb.nPageIndex] ))
+	{
+		n_printk("\n");
+		
+		pPhy_Buffer = (unsigned char*)virt_to_phys((unsigned char*)nWorkInfo->BufferAddr[nand_intr_rb.nSectorIndex] );		
+		++nand_intr_rb.nSectorIndex;
+	}
+	else
+	{
+		if ( nWorkInfo->PageWriteFunc[nand_intr_rb.nPageIndex] == MULTI_PLANE_STUFF_PAGE )
+		{
+			n_printk("CurrPPage:%d - StartPPage:%d, Size:%d", nand_intr_rb.nCurrPPage, nWorkInfo->StartPPageNo[nand_intr_rb.nPageIndex], nWorkInfo->PPageSize[nand_intr_rb.nPageIndex] );
+		    n_printk("StuffPageCopy:0x%x\n", nWorkInfo->StuffInfo.nStuffPageBuffer );
+			memcpy( dma_t.v_addr, nWorkInfo->StuffInfo.nStuffPageBuffer, 512 );
+			nWorkInfo->StuffInfo.nStuffPageBuffer += 512;
+			pPhy_Buffer = (unsigned char*)dma_t.dma_addr;
+		}
+		else
+		{	
+			//null page
+			printk("[%s:%d] Error!!!\n", __func__, __LINE__);
+			pPhy_Buffer = NULL;
 		}
+	}
 
-		ndd_dev[i].size = gNAND_DrvInfo[i].TotalDiskSector;
-		ndd_dev[i].data = kmalloc(sizeof(Device), GFP_KERNEL);	//size should be less than 128*1024
-		ndd_dev[i].buf = kmalloc((sizeof(char) * 256 * 512), GFP_KERNEL);
-		if (!ndd_dev[i].data || !ndd_dev[i].buf) {
-			printk("ndd: Unable to allocate NAND device structure.\n");
-			kfree(ndd_dev[i].data);
-			kfree(ndd_dev[i].buf);
-			return 0;
+	NAND_IO_IRQ_SetupDMA((U8*)pPhy_Buffer, NAND_IO_DMA_WRITE );
+
+	ret =  wait_event_interruptible(nand_intr_rb.nd_busy_wait_q, nand_intr_rb.is_nd_busy_complete );
+	if (ret){
+		printk("[%s:%d] wait Nand Read Page Error!!!\n", __func__, __LINE__);
+        ret = -1;
+    }
+
+	req = nand_intr_rb.req;
+
+	#ifdef NAND_GPIO_DEBUG
+	BITCLR(nand_intr_rb.p_gpio->GPFDAT, Hw17);
+	#endif
+
+    n_printk("Nand Read Complete & wake_up------------------------------------------ \n\n");
+	NAND_IO_IRQ_ReadPagePostProcess();
+
+	#ifdef NAND_GPIO_DEBUG		/* 09.12.22 */
+	BITCLR(nand_intr_rb.p_gpio->GPFDAT, Hw16);							
+	#endif /* NAND_GPIO_DEBUG */
+	
+    nand_intr_rb.is_nd_busy_complete = 0;
+    return ret;
+}
+#endif
+
+static int nand_isr_read( struct request_queue *request_q, struct request *req )
+{
+	unsigned int		i;
+	unsigned int		current_req_sector;
+	unsigned int		nPPageSize;
+    int 				ret = 0;
+	U32					rEccBuffer;
+	Device 				*dev;
+	ndd_work_info 		*nWorkInfo;
+
+	dev = req->rq_disk->private_data;
+	nWorkInfo = dev->nand_work_info;
+
+    n_printk("Nand Read Start+++++++++++++++++++++++++++++++++++++++++++++++++++++++ \n");
+
+	#ifdef NAND_GPIO_DEBUG		/* 09.12.22 */
+	BITSET(nand_intr_rb.p_gpio->GPFDAT, Hw16);
+	#endif /* NAND_GPIO_DEBUG */
+				
+	//==================================================
+	// Set Work Info
+	//==================================================
+	nand_intr_rb.nDevInfo 		= nWorkInfo->nDevInfo;
+	nand_intr_rb.nStartPPage	= nWorkInfo->StartPPageNo[0];
+	nand_intr_rb.nReadPPSize 	= nWorkInfo->PPageSize[0];
+	nand_intr_rb.intr_mode 		= INTR_MODE_READ_ECC;
+	nand_intr_rb.nSectorIndex	= 0;
+	nand_intr_rb.nPageIndex		= 0;
+	nand_intr_rb.nWorkInfo		= nWorkInfo;
+	nand_intr_rb.request_q		= request_q;
+	nand_intr_rb.req			= req;
+	nand_intr_rb.current_nr_sectors = req->current_nr_sectors;
+
+	current_req_sector = nand_intr_rb.current_nr_sectors;
+	//===================================================
+	// Read PreProcess
+	//===================================================
+	while( nWorkInfo->PhyPageAddr[nand_intr_rb.nPageIndex] == TNFTL_U32_NULL )
+	{
+		if ( nWorkInfo->PPageSize[nand_intr_rb.nPageIndex] <= current_req_sector )
+			nPPageSize = nWorkInfo->PPageSize[nand_intr_rb.nPageIndex];
+		else
+			nPPageSize = current_req_sector;
+			
+		for ( i = 0; i < nPPageSize; ++i )
+		{
+			n_printk("Null Page memset\n");
+			
+			memset( (void*)nWorkInfo->BufferAddr[ nand_intr_rb.nSectorIndex ], 0xFF, 512 );
+			nand_intr_rb.nSectorIndex += 1;
+			current_req_sector -= 1;
 		}
-		memset(ndd_dev[i].data, 0, sizeof(Device));
+		
+		nand_intr_rb.nPageIndex += 1;
 
-		// init gendisk
-		ndd_dev[i].gd = alloc_disk(NDD_MAX_PARTITIONS);
-		if (!ndd_dev[i].gd) {
-			printk("ndd: allocate gendisk failed.\n");
+		if( nand_intr_rb.nPageIndex == nand_intr_rb.nWorkInfo->PhyPageNum )
 			return 0;
-		}
 
-		spin_lock_init(&(ndd_dev[i].lock));
-		ndd_dev[i].queue 			= blk_init_queue(ndd_request, &(ndd_dev[i].lock));
-		ndd_dev[i].gd->major 		= NDD_DEV_MAJOR;
-		ndd_dev[i].gd->first_minor 	= i * NDD_MAX_PARTITIONS;
-		ndd_dev[i].gd->fops 		= &ndd_fops;
-		ndd_dev[i].gd->private_data = &ndd_dev[i];
-		sprintf(ndd_dev[i].gd->disk_name, "ndd%c", 'a' + i);
-		set_capacity(ndd_dev[i].gd, gNAND_DrvInfo[0].TotalDiskSector);
-		ndd_dev[i].gd->queue 		= ndd_dev[i].queue;
+		if ( current_req_sector == 0 )
+		{
+			n_printk("\n");
+			
+			nand_get_next_req( request_q, nand_intr_rb.req );
 
-//		ndd_dev[i].queue->queue_flags |= (1<<QUEUE_FLAG_WRITEFULL) | (1<<QUEUE_FLAG_READFULL) | (1<<QUEUE_FLAG_ELVSWITCH);
+			for ( i = 0; i < nand_intr_rb.req->current_nr_sectors; ++i )
+			{
+				dev->nand_work_info->BufferAddr[ nand_intr_rb.nSectorIndex + i ] = (unsigned int )( nand_intr_rb.req->buffer + (i << 9));
+			}
+			
+			nand_intr_rb.current_nr_sectors = nand_intr_rb.req->current_nr_sectors;
+			current_req_sector = nand_intr_rb.current_nr_sectors;
+		}
+	}
 
-		// add gendisk
-		add_disk(ndd_dev[i].gd);
+	if ( nand_intr_rb.nPageIndex == nand_intr_rb.nWorkInfo->PhyPageNum ) 
+		return 0;
+	
+	ret = NAND_IO_IRQ_ReadPagePreProcess( nand_intr_rb.nDevInfo, 
+											 nWorkInfo->PhyPageAddr[nand_intr_rb.nPageIndex], 
+											 nWorkInfo->StartPPageNo[nand_intr_rb.nPageIndex], 
+											 &rEccBuffer, 
+											 nWorkInfo->ChipNo[nand_intr_rb.nPageIndex] );
+
+	if (ret != SUCCESS)
+	{
+		printk("\nNAND_IO_IRQ_ReadPagePreProcess - ERROR!!!!!" );
 	}
+	nand_intr_rb.nEccBuffer = (unsigned char*)rEccBuffer;
 
-#if 0
-	printk("DrvStatus       0x%08x\n", gNAND_DrvInfo[0].DrvStatus);
-	printk("TotalDiskSector 0x%08x\n", gNAND_DrvInfo[0].TotalDiskSector);
-	printk("Cylinder        0x%08x\n", gNAND_DrvInfo[0].Cylinder);
-	printk("Head            0x%08x\n", gNAND_DrvInfo[0].Head);
-	printk("Sector          0x%08x\n", gNAND_DrvInfo[0].Sector);
-#endif
+	ndd_isr_rb_enable_flag = NDD_RB_INTR_MODE_READ;
+	NAND_IO_IRQ_ReadyBusySet();
 
-	printk("[tcc_nand] init ndd(%s, %s)\n", TCC_ARCH, NAND_VER);
-	return 0;
+	ret =  wait_event_interruptible(nand_intr_rb.nd_busy_wait_q, nand_intr_rb.is_nd_busy_complete );
+	if (ret){
+		printk("[%s:%d] wait Nand Read Page Error!!!\n", __func__, __LINE__);
+        ret = -1;
+    }
+
+	req = nand_intr_rb.req;
+
+	#ifdef NAND_GPIO_DEBUG
+	BITCLR(nand_intr_rb.p_gpio->GPFDAT, Hw17);
+	#endif
+
+    n_printk("Nand Read Complete & wake_up------------------------------------------ \n\n");
+	NAND_IO_IRQ_ReadPagePostProcess();
+
+	#ifdef NAND_GPIO_DEBUG		/* 09.12.22 */
+	BITCLR(nand_intr_rb.p_gpio->GPFDAT, Hw16);							
+	#endif /* NAND_GPIO_DEBUG */
+	
+    nand_intr_rb.is_nd_busy_complete = 0;
+    return ret;
 }
 
+#endif
+
 static void ndd_request(struct request_queue *q)
 {
 #ifdef __USE_TCC_NAND_WORK_Q__
-    mutex_lock(&(tcc_nand_data.mutex));
-    tcc_nand_data.req = q;
-
-    queue_work(tcc_nand_data.wq_ptr, &(tcc_nand_data.nand_work));
-    if (down_interruptible(&(tcc_nand_data.sem))) {
-        flush_workqueue(tcc_nand_data.wq_ptr);
-        sema_init(&(tcc_nand_data.sem), 0);
-    }
-    mutex_unlock(&(tcc_nand_data.mutex));
+    nand_priv_data_t *nq = (nand_priv_data_t *)q->queuedata;
+    wake_up_process(nq->thread);
 #else
 	struct request *req;
 		
@@ -617,7 +1407,6 @@ static void ndd_request(struct request_queue *q)
 static void ndd_transfer(Device *dev, unsigned long sector,
 		unsigned long nsect, char *buffer, int write)
 {	
-	//printk("%s: sector(%lu), nsect(%lu)\n", write?"write":"read", sector, nsect);
 	if( (sector + nsect) > dev->size ) {
 		printk(KERN_NOTICE "beyond-end write (%lu %lu %d)\n",
 				sector, nsect, dev->size);
@@ -633,30 +1422,234 @@ static void ndd_transfer(Device *dev, unsigned long sector,
 	}
 }
 
+#ifdef __USE_NAND_ISR__
+static void ndd_get_phypageinfo( ndd_work_info *nand_work_info, int nMode )
+{	
+	n_printk("\n");
+	if ( nMode == 0 )
+		NAND_ReadSectorIRQ(0, nand_work_info );		
+	else
+		NAND_WriteSectorIRQ(0, nand_work_info );		
+}
+#endif
+
+static int __init ndd_init(void)
+{
+	int res, i;
+    int ret = 0;
+	
+	#ifdef __USE_NAND_ISR__
+    nand_intr_rb.p_nfc = (PNFC)tcc_p2v(HwNFC_BASE);
+    nand_intr_rb.p_gpio = (PGPIO)tcc_p2v(HwGPIO_BASE);
+	nand_intr_rb.pPIC 	=(PPIC)tcc_p2v(HwPIC_BASE);
+
+    init_waitqueue_head(&(nand_intr_rb.nd_busy_wait_q));
+    nand_intr_rb.is_nd_busy_complete = 0;
+    nand_intr_rb.irq = NAND_IRQ_READY;
+
+	ndd_isr_rb_enable_flag = NDD_RB_INTR_MODE_NORMAL;
+	#if 1		/* 010.01.12 */
+    BITSET(nand_intr_rb.pPIC->IEN0, ( 1 << NAND_IRQ_READY ));
+    BITCLR(nand_intr_rb.pPIC->CLR0, ( 1 << NAND_IRQ_READY ));
+    BITCLR(nand_intr_rb.pPIC->MODE0, ( 1 << NAND_IRQ_READY ));
+	#else
+	NAND_IO_IRQ_Mask(NAND_IRQ_READY);
+	NAND_IO_IRQ_Disable(NAND_IRQ_READY);
+	NAND_IO_IRQ_ExtInterruptClear(NAND_IRQ_READY);
+	#endif /* 0 */
+    ret = request_irq(nand_intr_rb.irq,
+                      nand_isr_rb,
+                      IRQF_DISABLED,    /* flags */
+                      "nand-isr-rb",    /* in /proc/interrupts */
+                      &nand_intr_rb); 	/* user data passed to ISR */
+    if (ret) {
+        printk("[%s:%d] cannot request irq !!!\n", __func__, __LINE__);
+        return -1;
+    }
+	
+    nand_intr.p_nfc = (PNFC)tcc_p2v(HwNFC_BASE);
+
+	init_waitqueue_head(&(nand_intr.tx_wait_q));    
+	init_waitqueue_head(&(nand_intr.rx_wait_q));    
+	nand_intr.is_rx_complete = nand_intr.is_tx_complete = 0;   
+	nand_intr.irq = NAND_IRQ_NFC;
+
+	ret = request_irq(nand_intr.irq,   
+					  nand_isr,
+					  IRQF_DISABLED,   	/* flags */
+					  "nand-isr",    	/* in /proc/interrupts */
+					  &nand_intr); 		/* user data passed to ISR */
+	if (ret) {
+		printk("[%s:%d] cannot request irq !!!\n", __func__, __LINE__);        
+		return -1;    
+	}
+	#endif
+
+	#ifdef NAND_GPIO_DEBUG
+	BITCSET(nand_intr_rb.p_gpio->GPFFN2, 0x0FF000FF, 0x00000000);
+	BITSET(nand_intr_rb.p_gpio->GPFEN, Hw16);
+	BITSET(nand_intr_rb.p_gpio->GPFEN, Hw17);
+	BITSET(nand_intr_rb.p_gpio->GPFEN, Hw21);
+	BITSET(nand_intr_rb.p_gpio->GPFEN, Hw22);
+
+	// Clear
+	BITCLR(nand_intr_rb.p_gpio->GPFDAT, Hw16);
+	BITCLR(nand_intr_rb.p_gpio->GPFDAT, Hw17);
+	BITCLR(nand_intr_rb.p_gpio->GPFDAT, Hw21);
+	BITCLR(nand_intr_rb.p_gpio->GPFDAT, Hw22);
+	#endif	
+
+	/* DMA alloc */
+	dma_t.buf_size = 1536;
+	dma_t.v_addr = dma_alloc_writecombine(0, dma_t.buf_size, &dma_t.dma_addr, GFP_KERNEL);
+
+	gNAND_PageBuffer = (unsigned char *)( ((unsigned int)gNAND_PageBuffer + 8) & 0xFFFFFFF8 );
+
+	for (i = 0; i < MAX_NDD_DEV ; i++) 
+	{
+		NAND_Ioctl(DEV_INITIALIZE, NULL);
+		
+		res = register_blkdev(NDD_DEV_MAJOR, NDD_DEV_NAME); 
+		if (res < 0) {
+			printk(KERN_WARNING "ndd: unable to get major number.\n");
+            goto out;
+		}
+
+		ndd_dev[i].size = gNAND_DrvInfo[i].TotalDiskSector;
+		ndd_dev[i].data = kmalloc(sizeof(Device), GFP_KERNEL);	//size should be less than 128*1024
+		ndd_dev[i].nand_work_info  = kmalloc(sizeof(ndd_work_info), GFP_KERNEL);
+		ndd_dev[i].buf = kmalloc((sizeof(char) * 256 * 512), GFP_KERNEL);
+
+		#ifdef __USE_NAND_ISR_WRITE__
+		ndd_dev[i].nand_work_info->nSpareBuffer = kmalloc((sizeof(char) * 16 * MAX_NAND_WORK_SECTOR_NUM), GFP_KERNEL);
+		ndd_dev[i].nand_work_info->StuffInfo.nStuffPageBuffer = kmalloc((sizeof(char) * 512 * 32 * 4), GFP_KERNEL);
+
+		if (!ndd_dev[i].data || 
+			!ndd_dev[i].buf || 
+			!ndd_dev[i].nand_work_info || 
+			!ndd_dev[i].nand_work_info->nSpareBuffer || 
+			!ndd_dev[i].nand_work_info->StuffInfo.nStuffPageBuffer) 
+		{
+			printk("ndd: Unable to allocate NAND device structure.\n");
+            goto out;
+		}
+		#else
+		if (!ndd_dev[i].data || 
+			!ndd_dev[i].buf || 
+			!ndd_dev[i].nand_work_info) 
+		{
+			printk("ndd: Unable to allocate NAND device structure.\n");
+            goto out;
+		}
+		#endif
+
+		memset(ndd_dev[i].data, 0, sizeof(Device));
+
+		// init gendisk
+		ndd_dev[i].gd = alloc_disk(NDD_MAX_PARTITIONS);
+		if (!ndd_dev[i].gd) {
+			printk("ndd: allocate gendisk failed.\n");
+            goto out;
+		}
+
+		spin_lock_init(&(ndd_dev[i].lock));
+		ndd_dev[i].queue 			= blk_init_queue(ndd_request, &(ndd_dev[i].lock));
+		ndd_dev[i].gd->major 		= NDD_DEV_MAJOR;
+		ndd_dev[i].gd->first_minor 	= i * NDD_MAX_PARTITIONS;
+		ndd_dev[i].gd->fops 		= &ndd_fops;
+		ndd_dev[i].gd->private_data = &ndd_dev[i];
+		sprintf(ndd_dev[i].gd->disk_name, "ndd%c", 'a' + i);
+		set_capacity(ndd_dev[i].gd, gNAND_DrvInfo[0].TotalDiskSector);
+		ndd_dev[i].gd->queue 		= ndd_dev[i].queue;
+
+//		ndd_dev[i].queue->queue_flags |= (1<<QUEUE_FLAG_WRITEFULL) | (1<<QUEUE_FLAG_READFULL) | (1<<QUEUE_FLAG_ELVSWITCH);
+
+        tcc_nand_data[i].req = ndd_dev[i].queue;
+        ndd_dev[i].queue->queuedata = &(tcc_nand_data[i]);
+		// add gendisk
+
+		tcc_nand_data[i].sg = kmalloc(sizeof(struct scatterlist) *
+			128, GFP_KERNEL);
+		if (!tcc_nand_data[i].sg) {
+			ret = -ENOMEM;
+			goto out;
+		}
+		sg_init_table(tcc_nand_data[i].sg, 128);
+
+
+		#ifdef __USE_TCC_NAND_WORK_Q__
+        tcc_nand_data[i].thread = kthread_run(tcc_nand_issue, &(tcc_nand_data[i]), ndd_dev[i].gd->disk_name);
+        if (IS_ERR(tcc_nand_data[i].thread)) {
+            printk("[%s:%d] cannot run kernel_thread !!!! \n", __func__, __LINE__);
+            goto out;
+        }
+		#endif
+		add_disk(ndd_dev[i].gd);
+	}
+
+	printk("[tcc_nand] init ndd(%s, %s)\n", TCC_ARCH, NAND_VER);
+	return 0;
+
+out:
+    if (dma_t.v_addr) {
+        dma_free_writecombine(0, dma_t.buf_size, dma_t.v_addr, dma_t.dma_addr);
+    }
+    memset(&dma_t, 0, sizeof(struct dma_buf));
+
+    for (i = 0; i < MAX_NDD_DEV; i++) {
+        if (tcc_nand_data[i].thread) {
+            kthread_stop(tcc_nand_data[i].thread);
+            tcc_nand_data[i].thread = NULL;
+        }
+        memset(&(tcc_nand_data[i]), 0, sizeof(nand_priv_data_t));
+
+        if (ndd_dev[i].data) { kfree(ndd_dev[i].data); }
+        if (ndd_dev[i].nand_work_info) { kfree(ndd_dev[i].nand_work_info); }
+        if (ndd_dev[i].buf) { kfree(ndd_dev[i].buf); }
+		#ifdef __USE_NAND_ISR_WRITE__
+		if (ndd_dev[i].nand_work_info->nSpareBuffer) { kfree(ndd_dev[i].nand_work_info->nSpareBuffer);}
+		if (ndd_dev[i].nand_work_info->StuffInfo.nStuffPageBuffer) { kfree(ndd_dev[i].nand_work_info->StuffInfo.nStuffPageBuffer);}
+		#endif		
+        memset(&(ndd_dev[i]), 0, sizeof(Device));
+    }
+
+    return -1;
+}
+
 static void __exit ndd_exit(void)
 {
 	int i;
 	printk("[tcc_nand]: exit ndd\n");
 
-#ifdef __USE_TCC_NAND_WORK_Q__
-    if (tcc_nand_data.wq_ptr) {
-        flush_workqueue(tcc_nand_data.wq_ptr);
-        destroy_workqueue(tcc_nand_data.wq_ptr);
-        tcc_nand_data.wq_ptr = NULL;
+	#ifdef __USE_TCC_NAND_WORK_Q__
+    for (i = 0; i < MAX_NDD_DEV; i++) {
+        if (tcc_nand_data[i].thread) {
+            kthread_stop(tcc_nand_data[i].thread);
+            tcc_nand_data[i].thread = NULL;
+        }
+        memset(&(tcc_nand_data[i]), 0, sizeof(nand_priv_data_t));
     }
-    memset(&tcc_nand_data, 0, sizeof(nand_priv_data_t));
-#endif
+	#endif
 	
 	for(i = 0; i < MAX_NDD_DEV; i++) {	
 		del_gendisk(ndd_dev[i].gd);
 		put_disk(ndd_dev[i].gd);
 		blk_cleanup_queue(ndd_dev[i].queue);
 		kfree(ndd_dev[i].data);
+		kfree(ndd_dev[i].nand_work_info);
 		kfree(ndd_dev[i].buf);
 	}
 
+	#ifdef __USE_NAND_ISR__
+    free_irq(nand_intr_rb.irq, &nand_intr_rb);
+    free_irq(nand_intr.irq, &nand_intr);
+	#endif
+
 	//iounmap(virtadr);
-	dma_free_writecombine(0, dma_t.buf_size, dma_t.v_addr, dma_t.dma_addr);
+    if (dma_t.v_addr) {
+        dma_free_writecombine(0, dma_t.buf_size, dma_t.v_addr, dma_t.dma_addr);
+    }
+    memset(&dma_t, 0, sizeof(struct dma_buf));
 	unregister_blkdev(NDD_DEV_MAJOR, NDD_DEV_NAME);
 }
 
diff --git a/drivers/block/tcc/libtnftl/libtnftl_V7010_TCC8900.o_shipped b/drivers/block/tcc/libtnftl/libtnftl_V7010_TCC8900.o_shipped
deleted file mode 100644
index 1d08de90a99228d073a077c9f931b1400198ba56..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 204076
zcmd444Rl@Cb?5i+K?#On`$~cx7(${a5wc+#wjU)(f@#`@EjmFWrll=5!$e#O60sdl
z%O+g4l3{0<h9c<|jzW91L{7re$_UF+S}liNMHv)9u`nzwF^wisS~k?As;wCVq#$t^
zHBmE~S?Y`u_W#@W?1znu`yN0__6*ko-@WJTv(G;J>+G}7x%d9s7q|XsOG`_||Fu*G
zDob~j%Jx5OrE1-f0Sr{SD(|UOMnC>9+b6zu;mEn4yl|v)!{X8GhQ&&4{9;!v|LxH4
z;oAKd+A8A<m2CWCRvo|iH&?Fw`NN@XccCoSAIWZ6EViNkaP|HR;Mh?+bfHza+p_Tm
zhx7h2^#`ozS%8j?$}OVrmc=90TNYbHBXwQ1TNa_M{oMT*Do6gwB_GeY#&bgBd18&@
zIUdI2bgXrZC*H*|LI>l7A5UnU$bxY?eX%e2f}G$%rSiZ<Nw=5lag|B#mn*gTi(HQv
zc$9VIGKWXw;t};DwPTBY33iLFd(!o&uDjFqR$XVh-aq`L`dreFA5mW&bGIyZ2v1fy
zbfH6ZgR}L<W3T;Ib^c;yqvSIp9jYCkZ>=4guVjZ7>*W>752W&AR^C+t-;oJt;z!HI
zgRjw7i*(2I!uoyS;y=G~rT6_BGi47$6Xk-TuQqVTzN*J^zG+Nt*}?g4;m!o#R=s_`
z$9`Mq?Y?&Vd|UOA`976FJ3Qk0;^6p#!PO308GYRt`^p&CBl);eU+t=|r2cx;U$^yh
zyWwuDw$9sq>W{wZ4}Np~(1!5^`fXExl+oW!vA@XQ)L%#FuTTBu<GMW`m-@@;&&NmK
z^oOjuzW5Q@W9pAG`nx&ySHjD#&|jwhj9&3GA7^Vm&NM#yra$zI>xb?bU&zOQ(8|zb
zWQU&7H@tIMqwBw3BJ0)oU&ebIV}bW8Wc~4#vi@M?MG5bttRwH87m@cxSzr9vN?G3$
z`zzsnly&62^`r6Sx>GLehd#Pe*30asM3<wiqwVA}Uv4`qWc}f*mvtsTi2U~?yIvRh
zQNsU*vTk6{4}D^#jNxfB-w|cJ!k!!0@x>B5z9IHg!t188P5q!((S9EqSSi!@#ePb7
z7G)ZBD7VX8cZ#yS*uR=A?^|ZK|4?@8vizka%Vs=wIp%gcpZnbE!Q?B-ee**l_IiCB
zdkK%DEOQ&3&;70XYG$hsmDuWPe2((W?Q=f&wd$*xon9=F=`uSg@e5I=xoytpyi;Gf
ze{UeyRsHdDxgM2VEsoIKllOCQKEFR?vA`CU=VQ&ww^Z};QI+TX&dWzr`Bs(ZGSADm
zs+<@v>-Z;^e&ot07YJe7CqBMdQS92SI3`mZgU%8!ZLb})w%ZeqZE8z7{^L4yF4NqS
zU>n5}{~A3N%t-A?{RyA0hjqOr;T~ZgujX=tW@sgD@-pbHocoOnl|*mL`Y-<NfAG71
z@|PZ;4vXfRXdcRLSRAhESM3Kx->`oB^$WdK{nm89O?VG|dVJw2{Skjq$Gi#bA;mS!
z&juHGncp9>^6l9%gMI3K;|t5+Dqmg@uJwwg?;-{x&Y^z0Xh(*(*4i#G*RHQrI%^s~
zWl!CySY3S*hd{#z#82c}Q6B?>sp^`#O6|OOk<Vk`x#=#osXk)1R1tpQh~F4vzg^#V
zfpOCZ_Th1s)1cV46FBI(AlW!A9v@}Zht&R-#r4ppakbXQHxfHQcc$`4v#l9!8(#pv
zt@;b|@R2sVE0sr=)zyAs9-1gSbbCG)d@QtmQsXX;cd&N<vT+sbKekH!hE?i6TBt`>
zBh^C};6L<tRw^e&!-bxT?zMhsPwO)3@o&hBv9#3gv$%?D`1u0-6ravYzriCLIaw2q
zH{Z6k*G0w)juEv3hw)AAe*4OmM{g<N19leWTcq=S!Vf-l#`LV(ra40KCAt-KB<ccv
zLO1f@8oJxi3DG^Qd+2`o%9TyN4!pv`H?3`}vbCyg4Vthe?1k&?x<-HSKW<;Xo-#dW
zT`C<0mbDE0x>d9uko`HW)KzXfWOeARx4-_q4_p)pC#&M)H^s-Q=%k-v`46tq$<17=
z{$%1aeEXpI2~Ok+PfTyC*jl~@Zw+z<ZbyW}CaWvqz!TR>?c&{{WbV9jK4r;|c4zpL
zCuN8Enwxe1fBngP9m?7?%WhfhOuA(>#`QOjIr077!neZDYdl7qeu)n{H6GT!#1+Uk
zU;F0QHn)hr=!+wL9ny;~jW?4IrY-PYX^gC6S$jL5igdsy;9J!HZIZQJOGm+jkA}t{
zl02C^j8DlgzDIUkFUt<jb8U2{`bzEFR&QmJ{d;N;3g5Ga!{r$Jf=+{#4P2BB#IZWf
zeL=Q88mrTnMfxf^Ep=M6^NYmx^?Q7J?Y8-^)c*3-N^Nc#J<xznV~3X;(7-$mzct?|
z*K@-neCSaBv@IJWHiFH&kH_Z!mGri3e2&{?*_H5`j}zTR{^fo!x7V_M{&J1|^wN*$
ztW?jZe1do+9!MWgYMiEz*mMJ!4diIhm-i+Zm+xxyEkIwwpUZx^j=S8qisvKZ`4;Kw
zXp%ep92L#iiMQ^r;4^+6zHOEd!S|Z)k$#RyKJ|Ok(PQH0BUa|^s7F5H+qa;LdBW-A
z7u>Ru%UiOfCz^kaZsE)Od1QWBzbpF5V}e}o51EZIXThh$?{DRNFyHnauJLp2@(buC
ze2p~4w#Qp4-+~`4VJ>~`%9TI*dQ0VUE{FRr+~YZ<xOR|Ut&<L~t3J3mc+Znsf1Q7g
z`^~yvC!1~4+RW;8y;<ds>yY#xdhQiYuG<^neCh5boS!bi`RRajXchX723(s;aBT{>
zpbMEaqH84J`cw(7PYD-3tq-`3$BZYrjU6&uZpNPu$*fQFI<|w(bQkqeK5B)Yq&T9b
z_Rt0Bt|%51zb_E0+4@mFt5Q3V^fkqnL3duga%D!!d-?m_XP5f?=I6#0n;x2fPICA7
z82wdD`$xrkY-=@HOy0GmBgOWmZRMw;Zm!y<dPq8)&p$<2=v&P$x|`5f+IAKCR<v1#
zzO~xgo;w@!u_=yK=xx|`6}nfm=h=;o=`C%$3Y{z3G^H>3;vbN0{)aw)XpSkJKZ<k8
zfAKe0{wT&Sgv$K$x!Us>#Fh9W=H_pR$M{m4=U5+UUi7$p&+WwMns<rI(we-Y9Kep7
z@^a>wrMgFQU#NWi=2R~~R9at6^=)PKn$z&5b(+*K{doUQ+qv7yX`8*VIc?*qz7cJQ
zQ~g?KbK5(Vc;mDUHK47!3T^GH&~_=y$F>&Q+9XSIb5Wj8RLgmGB;jo&&poNW5zn@*
zfv!9@N$XeXTOLb&dEw_YH<syauDSX@t@TC}XAUdQ+$`N4QJh)T{EPn96x*;qM=wWA
zSC3g-MEqD2OnY|7>Mj48VCuP8)3qF~Bf(kjG{M#Lr~$4k!CBrj!PRr132tQIN%gJx
z%xy;TLrrBLi)C6@wq>`?_o@8DCFLC|zpYrVID>rF{70T#9E^3se@<l|iDe1@tjcdM
zDSt-gA1{^*KQYk()eXct;oqyW^|37B->LFXl$4LE{G-Kk;U`9}s;)oQ34f-tPsXx@
z|LqSyxwxUE{F2J=D3%Mqt<UA#Sc80Bz772#2f`YI7!kY3^M~k3Rla6PPx>NU!SCd8
z-V!|eLLSWV7JWex9=+)f@X<aaY`ex))SWl)DA%2Nm6z$x3o37<J5Q^ws5{41R;D`#
zR9>b#dsN;?cebdms5?U{E7P5-%FA@8OXZDp=av4Iy7QvS%5-N=<z>2aO684oC$1y7
zX1(xVUb*re(<A8+KIXAn+Gh`b0YAf<kNV>!^`<YW{zOT==|`%6VnsdcJ*@+!@2{+X
za<L^FxAhZxET1hM&ew^=&mK$TYrM@wvo@lab*Z;QpS<0^Rob<NcIcb88(F1YTWE(a
zdb^HQ+O>yv=&QFor#Ph{Pc*)Dp&k0{?M|%H?z+$pefM@_tF*g5w8Iv>-M}jCIzl__
z#oN81c%s?(-V@qkPu^~Nm3Ez>9rot!4y@AdhR_Z_?(IfbY1b9nVXxjUTczE5Lp$u*
z+r6ZCrWs$}7usR(-fn!AcJB}E$faY`<H07GgWcAj4&}_9?9&7POekm0BhN|ssZh>b
zMI5uaqIoGBub)rzd~iJmN*5l-4=NU7zo9?7L3?7Ng*i^RiGc<RwB~uVJPrcJ;~?N7
z?GA^Z0?y+g;Nn;u4u1ul$3eiwu>sewaS@mFiT5!Unp4^PV_BN(PpSN-lJXNO|3I-^
zb3N+>_G;QIhc4_EOizSSOtC{{x5Tp4&lZ)xucW-D@*9igp`Q-*QxQyegi$|lXwLqj
zSeE*ES>?SY<<G19y~Xm-PnY^RA($+}sGlP$yE&GnejZl&2TRJwRQ{o2dFtmqY5n(v
zVkGn@-}B1%SmRnS#wLBzRd{VYM~_9*fb`nnOXDTai*e>KZ)bWH+LgymOYPtV{h6MH
zb}Qqjqz}@$or)idI=5A2WjZ&k@-m(4SNUo>_om{AqRtVYl<C|#m6z$<tjbr@xub$9
z>fC;nmFe7Wm6z$<c9pNDbNzxT>Rh+V%5<)x@-m%!U2}LNoy*sNVNXD@mDYcMRM)@c
zzc?F~>m9iO_5pJLRoA-&*IfdK{{k-hubvV({8wGC6286_aB0p^4!S4g8QBx|cnO`d
zc||a9h8!QbV_b!fIot~cxEM#Fa}M`(0WQW(=$*suFTlk(30-u!?FG0P7onRDH&}p+
zaS*!daP0-S826yB4)^lLrCg%Prn(ewqQee1S%8ai4La>`M+<N<jzPyAZdU;=#x3Z%
z!)-3W#W)4scew5XT#QSw1&4dRwtT!X4#74Yj`I+{rvqPN+|i$LPG@OOkM=-0>ka!w
zXOsRG^BUBb*@M{zb4Oag09R%Y=5qsF(>x6^O3KyrC_dr56nRGWf-NqB7R5Whk9VE+
z%{o*zDf(F#v**u#1^eOaG$&EVc#3uP*r-8Ywq{d5<PX`GtLO}bpC1KZtM=-NwTRQ`
z%V>~3dVgL&5zZe#BhLVIYTZ?~U*9D;+VczHJQnQmc&$tPU|*VjXka;?ROIFN8+OJ1
zwfLRysf+gP;A`+JE1~UqZQ%bP#sYm6?OFN$`c&=yg{j(u3!HsmuY0FxBVOh_!BqC(
z!ZyY5HlOIM{#5nB1<uj6-gfLY<PU!-8>CF<Y6b)guG6(gIFDxg;d%a1dwD@-@2^yK
z#HmvG$Lhr85$P(@#CbjPOxHtGp+9JAtv&J@{rUNVqK<ffM?!y`qi`ND-l@uRK5SN>
ztS30vz!<(#z49u3o$h~bf%QM*AC=D2FL3#piRI($*EoHAtMvz8!J{X6mi0GryZX!I
zqr_YK^szSUb6Xf^<SS=2ioA{TrXS?Zn2;g&ThcxKaz7mCfDgdV-1%%%dBcaF6-{IM
z+ZAZLR-Q~>15dVwej`tc{CKCj##qtqqaR(;?W-9lJRTB{(K+WicC}X7!{glz##)!Z
zY-oG3S+{Tc!nV+RY?=O^(wXof-Rmr$)m2j+y68H>Z_(Zu|6>~eanW&f4Ya^>`efX0
z&(PxiRSV-U>+iVwyHwH_@}17^Uzn*bx9@H06Mw;Z9s1gmXc$pn)5(WLUo)uknc&+R
z`5Kr1xM=xipoh6hyjp0{+-o!y=z$09vy}Nbrw3m9IiDgAyx$Y*)8hlqOZI3!)E?wQ
zRklB~@qV*Y;sf?2&xkjiX~K8?<_~MnD0}3>8I7@RXnf%}Kf_$D+`DX?{3mmIOPbTW
z(wxnBI4i`NUgmZ7wZIJyuEBpsyq(!7oH`rviq4Y(N1I=2sdO?PVD1wQwCTyzm-Y>4
zdt7U3uKn4o$=Z2)cF^EN)4mU?UUV+yW{)kl-rIHo-14El4!5lg?w%aZ>1J*0bTi(*
zk~S@OH)u2W;6k1Dv^IZ9YuYx>NvG$=rbRn37h}J<HIIpAKOlKW`YVST^6mFIhbLam
zidWEgSm$wmulD%DjP8+Rl;?&LUXDUf;N?{HyxKmfvuzJ7=$zOF=m&Rw97zUQv7N?2
zpE~!uLSC%L8}%VRTMW9Iew@=dXKs7Y_=LV3mtMJ!9Hmd`(yVBu?yIVE8Sm|0sSEG~
zSopQASg$x9S%Bv&IxFsY`ipRi$zAR@(x1y(IN!Q?WuGnUp1VkYFRQL7Tl#w{>6z0t
zUBnUS`eKp`_>LCgM3?LOO$EBf%3!b0>DsaiU7P`TUi6gVNp@4@#p^e%<VEXsd7tN0
zw-#QUD&h#dkp65qt~D@c#yLmfH13OSbk4<mi()eB%lywTO25{teYB+^;ccruuIEsf
z`$X@fJNCgIP@qeG<|J@++mWnZxp5^g+_#j`gimyRc&0&Hw}BrHW8Ytd4Rk4Ht^2>R
z2qzwaYqIw20`rWIadQC%p8`xHKI-}0O?vkHGXA<<dkWz6nBRTWyyi1}ROBnX_dcJ`
z0-pk1Rxi9h4;<CJyUecyUyA+SP?SMvOKekY+e{Y!m&V0D1oD{B_!*Z!r@(ycYvLn!
zR4SADds%<~Sbyz``OfM0Mg95Q>u2V{!JPf~bOx1}ig}gwKCyGF;w#P&LKAC5_`Xg0
zOAN$1{U-!l6D-evFh}`(G9mwsuAk9bgx`tV^7~otg@-<O3Xflph3j46dN<c<KM?$h
z&On*3wz6dJZ_39wocqJirLr?a=NHy%-eY|fX_{3zdl6o4v_Y%n_qyh2$<1(bKd5`@
zWBvYr(0yCDuj;<DC8uj*<M{=6;dp1#nA;QYe9Sg}`V+j*y<=LhLgTFZ#20_1cI8#C
zJ1u(iXPfeQdRKzomFz0V!<nsH7I&-eRq3*g_pbA{cK%Ni-+oa1_)zNa9rGjUi|Ivy
zUySoq8mH^nYW$uNKN|7W_+RL+89e<n?;D>bACp;$o<)6lr+T&;U-dki+32czRv2g0
zL&o(}4fxs!e=|N^3t#VXz9#*>HR$hE@j3Y(*Nam66EB+iA;mE!=c1muPh7_DHQ+;M
zX8Lo#xLrQ9HLYDd7de~ieyXI7XUp8b{7gyxnbbDE^8~#3ZRU9VJ$XLXugrni19i+-
zzxp><9>qV$`Q+{XrFkRfbb({72(IT7u4&y%N0-edtW#|+(LBmp5!|g=p5qk`TcgRJ
z_FA4#^nr7oZ~&XuZ@qhjpPUls^eJZ?^fjG5X#KNZW-OGqRlc<FFEm$zk7qL!pPeL6
zKzq#}m&pTD=W}SxRrwss`j~l>HS#+BX38^n=o#RCtyu@OW@YTGu?I5ki+^k>#uyME
zeGVmW_aoY~8mNf3h4E^9oy@mse0Du3`17rbL9`zAac}!H=d^BE{F78()iX0ie7@E%
z;+jisTJ&73Jxe8C^r&BGpVeAhaq{KaZ!11je*@ylrQQ(p*m)ww@me!b_k!w*aWd`T
zH@MDdUBo?Wwtp$!pSdx|d18~~k{vYsN4c&(z5tJoDR%g*+D5&fxKnM!Pmis}HWcEc
z?7ZRGns653YX$h}1Yd0cUn#&(Cipi$wM6qg*V3z}v=;tKcI8!g@lvQim+Hw~;0xdd
zI_f-~{Lpfq&ak#kd{RuY!QqY;;S>XaGxC_eN9j*IbY2sm!?SH4RsKhKiE~W{KTZsH
z@B%#YJOuhk-mVx=)yq;mb(?eqoE723Um8yJ{f6Gh<MO*t@?)Pg$`AUcfx)Lp-?^Vl
z_ctov;QTvI89Jdpp4R!+7CoCrevkVTc0X?S@R728DkFY!I(Dx{huUmao3?<Lv$$=-
zK|elTj}?jSp!My0bJ}gbPO`p4nP`QN(T>!nmo~4bHu%sS2LJPAbl_WVXG*x%_2IXE
zSiaTsDrsFYqgcKu=P~dGIsb*^{4>Ji^7Q-{G+6#CJ7lsp|0nz_>Lsg2`7zO2_X*cR
z>!hAZE7Hny>(B~)kCo)BT2sD?wYtL<d4oN{8|N#y8o}JG{@w|{-ymmI;CCrq@{2RF
zP4=T)2hOH^SJayc%A_|=Q_<J%|G;v;z`ky4`yunSW2(CvUyF_GRxXUb&~NYaEPD6(
zTn0VRQ_1}X@a|*ZF6PBFwm4UPr6Qjv_@DU9;R}P(p%rVr%5$c>In1GQ7~!m@dHC#5
zKA(L^>rJQau*%A48!OO8j<rae`A?&-ao@)(ZS!#)rEAu;j3d+hQ@dsHAIbN@i&@Qi
z2W9uHk=?e4vm#BUeFZ#2tKpH(?=9rIrYq-{@w~K;BCoWTB+hZ#{?TXUyOTUw2e*+6
zmOt{na%_!f>e{N0zh--f*}-|rDwJuT*zoB7#X|nca><JCydT%I<2v)owe=%@Axq?9
zG)YGto}5Cdo-rQr+V?SI{75{B{@o!R<()X_Xnjn?F_l9$ZjV)L9LlRjdmmyR)p*|8
zn3p5xFNl^+!q+PNu6Mw^RDjuB0y6<jm<OlR{g=W#$g_1G8y!gXma9l}&v>eLKQwyd
zN}ti5-kqX6xy{*omGA2Cxl%mY#hKc0zeD%er~8`x1LN#a+3DJ`1<trDH+K?V4iwt;
z>E7|apLXIymS{#U)IA{i`W%0Wcs#{@&)Bu%KJ+D&pW_-Hsr>=9=Uo@xemcON;#$5L
zT8TS8QRH_eKf?jteafl%c=3b8&Vy=)j&z*Udwulo#wSv2PmYYWjpfT!Hl@GQ`kU6@
zN!2~3zX@G`M}IHtZ(e_|=#MqQDgE7}b-|zM_a*(kp}#lv_ZRw`)!*y-^SyQ7&$ay~
z)-K}n9`gEH7ui`SomZF_t?kNpQHI>}GYq_&=b-s@a&YjSdUS>Q{rYXolp7XbAJ+A;
z);4>$P6y)^FRR!>%AukAmRnT&k<@;Rex3i;MsbUtQ8v2zfYF|3zvK=dnOEq$J(Y7-
zn{r|@%3qg^fPY*3kMPKw@=HlBt+j6(o>|H@24b?2G;Z{SGTKiK<@rr$)|$n}eI(T%
z)~}Cyzpj1UwChi}I5z;U9RZd#Vua;f0OO9l=}+wj^jqYO^2(3Kb0S(5S2(k=M}O>V
zKBGVOli623slOGu)=GYEC`<Y(dey&jtD?czZd?<m|1FJ~@vv5BKZ`Z?4&;?RzK{vV
z*O)O+8|R?nS|54(czms|b=sp&OYyfEZ8hjw!x%m+IAls}lg{td-zA}Z&YE!W-lw(n
zrF`w0;93L+UwtivU+^`*<vAoaw_8821w3%eWS`ERc^-W&G{QG<`5q-Q#SV%xosm6x
z?mfzsJyCR(_Ov}fTlq!bE4BBbB>bEkpu9`@0%-I33%R<kai#!15c3ytV+RrUpKE?>
z#<v#vLgyR)&fj-~KC{ok{F3@L9Uy0+{V99z1v&PlAD#3;opLr-*CXBW{6<j*_;I%}
z&Jq;Q8e%8RTd{BEES}r=jPSD#>{0&w%Fw*z`{f0pvv=!IW^s`6pavrv*59kSNx5Cl
zElyOQTWGI-W3grP_(gI^9l9P7-MsrnQ^w_1U6Y$a$Gs2Bdui^Eu>`Up*JXLH8y>i*
z{vRb*2CVrh_UJV?IxReF;(06j2d>!vI`v68YZ1$j>AI!sfs1-))k%2E*m+(f>OFkq
zd`6l4IFo}6IalR;Bv;pw<!8RY$sFKk&U(^()l62qC96^8(6(kbNH=a+Jbm~53tQo9
z(1Qb76YLPJy;>)1Qypihfk7XT6*;}J1aqTcCTrg{{Zf9f^Yq=CSF7K(xcorA?)c77
zg1t_#(0u03`xn3qKRRmPu(PS%f*~Hw^ow0=6~8-l&Hn3%?nib1w&Gv>DDR{|AK<0!
z)6`n$Pv3R_0x&Np7-UENU7CvrQv0)^ZXneWqtNbD0XOxIdqTK3E0;K0QEnr<WpPmO
ztToUf<_LT`_Qm*pe7y6A`9)`JFOM{68|R;UC0B1dB7E?=rSg@Fdhc>4_tUqZU+5Bz
z@LxGz>t|T_r9PKOMANWfx`{bT_5&yG%5#H~TQ74y{I9AVZSZN}u|Dq1<9y2L=MwRV
z@(7Ggd5T_OrbLJ1(|8~Cvc2q;=ep5L3`ieZqnkZ)Em-p@;A#;rhXFtS=OZfHoGHg9
z-uAIRketa|vBx^G{z3hUrs~1@)6ePLhOR5MubF>n*Dts_^ox90o9GOZ<pW(t_%QU+
z)+NcNS#P1Yl<~|l?a&$8;Jcu6hxp7jwm?h(t;(@p97w$A&W;(qd(!;=@0;GiK<~#A
zy=|gbvhL*>=?U@f^hM?|{N>lo&%!_aWRZXGlWxCL{%Ji^=O4Nd`F$nRyq@@t-oxV^
zq9gjo>*W{y>{{hOrNY@&)(6D+Gx}q_aOFy+J`er+ztG$#|F)y!hQ*ydH!O|~+_1Q7
zSl0tO<GwlfCEImRf77z*9m7kpT#x$Ssr%>$539{?!S}XRE{_SvF4d!hz%BEI2`&>H
zb?vg<OngVrcXZ^wVoc@uA#kA6?aA*!3x4oz?HBA&A3eeqeO&ZIQ$wOzFmGvJ!sAKz
zV>RKRZa&o2#83R+P^x=A)w%zq-hJF;!u_<jmpy>*cxZ#XXwxQt+mbyrPyL=$kM7Tk
zr?axvsUg`(?V)+UH`~QG=zX1(ZIeHQFFSiU&${GGJ=Tc6^t9;0m*Qv9p|5^c&mqbG
zm$e6GR=)0x`uJ_}6W&fCXVE#A_CK7q8I{k7R^ZKVi8jh?%n5cT`AyC1y|XtzXm$Ik
zlW!uI0B(FyF{fWIOF4bTTAh>PNz7s6i>HJi--n(!tz~7CXLFunv(SXi#_@LrTa9yy
z^1yYx=v!OLSLl6(z1YO8_A{7Yy<B<H-m1oPNM}!gZ>=1f2ktm<TI+IslsyoQ{}6d}
zy-OB)xQ_nw1LA!do~;4TmNnpM6P^yygU{7EG#`uULoQeP#*U%ut+dyH47s1zeOo1`
znQOBb=`?jOrh9bO#-aD(@_Y<))H1r2zoH!3<a(%>Q~mpV|7Fp%UG_ZLFWu;nT?jw(
ztNTq~cTq-rxvR@Xc;eL}JY~Q`5A#o)Gbu+$DEpN3YP-gh>((LdGhTTWI$RcwXkiTG
z?3=Z1L>Fz#=%W0z_%I<o$DXj6({`Po0nW?qx~`L~LFflNB2FqBtJ?**;OEzbcUz`8
zS>t|_y$|Aq_2UchfV~*vIp@!RCjJ0-HtmtPJ&z?_+A3Jh@t4i!<Wul(#JSLam)a8N
z*}d|w;MotJxySAO-Pq!7pUHhum)c^J(8@f@{Mwalw4!({+9$CsxN3>^+>VyNceviK
z#?z7=x&VA-mA*X&LjGlaBJVohG@euJOEekJYB-^5H#qA4VEH)U9eHl}JSAW2y#1!)
z%J0B;>C4P>4>sgy?0--)FY?iS4{~E|$X)>UN<4#od|NW)nmPQVT6>^F_!7O7#_X2(
zjWL|kI%6$*v>!Ou{IWmx+OJiQSPwPh`_<^trL=BYs~$}Q{|;ncrboNpAx>maZ8DB#
zdNle2&?C*Gbv^nm_2+&~XKs7VhcZ9EB3;HW%kI%d{6X{&_yzaPtWRQmjZaujmz9UC
z)9@>z!QolE#8}$Pi#Fl&=qE&TSuDVw$y#E8BfzCtfL!>J?LRU<t??IQ0p`4Ab83ny
z$b&nc;Wgj^H*>rDcEtm>1|}wE{-qrMPaHdSa~`Yt9tZP0`2vge^uBjuP=~So4dxKR
zz%yvYj}Vh<Unh?t>4W)4z6|`txbWFyT;j;sj(+ezKl|5Lde5ki7#*C%|J++VoZdUn
zHLzFS&foQmuiCAcBCdm2_xM_<xc=dJuAkB0Pw8)`{&wik&r3a_wa`B0diG~}pO|tz
zht>Z+_2>C(#)z*OO~1SK%UO>p<%ITY?mO_gTqpLZe81Yowb5?X9Z~teyRLHifM5@+
zp0yEhac#6E!TrC2qc7Gzz|1Juz<iDkabNvpp5vm-W4$rKk{^YZc4*Ol=otO5XR5wf
z7gUt<q72yp5A4gI&Giy_8ocK7|3`Dq{!Dq4Pb}@7ObgEQ;}7c$F?9IaZLjY43D?<x
z>wxO-x@mlY@+VUHM(NF#G^T#7`;g_&w^Ta8)vsLU7X1=W>};t#3XjOO(0(MfXS{z`
zJfN(mGHinD0j`P76=TycIDT4rH|n~m6ECb>b2(*iekQ@|{M~<?;N~fFIJN(A<!gX_
zp7PYsSzTkpv7gUXDw}{CkL{(e%;S_FP37j7s}Iea?1f*k+(vW>eHevi+2aA-A5Qn!
z3pyD6k8I4wJ`!-|bJ@XpaF{=-@SfstXe@b7g8c^Q=(>tF<drP`Nc?&st+P3=s5s*`
z_CCQ$o`Ahm8^5mG=5u*G;qY_0{2!xE^1<Klt0*?iZdrVv=<^t5pYC@KF6mm`MpFM<
zXs^9|;6?%*{ZfZae4UP*eVsld+XQCN=~17ims;nKB>7y@njG3_&)OgOw|!kN_#xr*
zya0J2?$Iw~F`{eMspzrtH@!2;n{oYjbd8*yPe;KgK0PE^L>xb-b9MB$E79QadsF{5
zCaqK2YAy3#H<EDKxKg`Fdo{I1{zj{G(Z|(asPl0F=i|`%VatE{I5n5n$E7&m^l#SA
zDL!tzJ)73}oR@GKpRoFa3(8Yoj=0yWz1>&uy8!RtqjI)pKf43Yy(KtD6Hdmx+3U52
z<bFW+X8+Pp`M{Hu^%#6kqn)cX9eJou<6Eq$(OuE;y3P;!o`LpTI-||O5AeOfdc2bB
zH@Se^4~#DiGY;{%o(ISdnU6WKY|WnAB4?|>bs*r{y9Qk30+wQj92a;7!ION`K!PFH
zL|tZexy^7slJx=mAJo0=YkcX5`6JPfufaAp>(_m+`4rD@Xig??M*Fkm3uH5c>3)*?
zM8_$|EqxeJ{ioLDV}2r)yPa-UUqw4T>}^FC_2{SD>5fo`?oh{E0zIPz+|)bn>Er|Y
zy?xS|?$8EXF?~$AI&i*~&Px*Ou<vvF4#hFDZ~U^~o9vS>r)-yUb?)D`2#4n?$d~qr
zCVa!)(l20m@4wgYo?B`ME$$Z;18A+b^bQi`!8-edhgjlLyY|nLztK9QbN8J5s_K}N
ziQkAH@V5gR2k~`B^=pz@zSiC%xGeZ$Vr<}{2R-Q*evfVZdko;;tMNr2&KRB6N2J?(
z8jPQqeb*}O87n!>ZqWvxZj;@4jzc~|=jz$BIcEDj<SMvle`Qo_ef-GJt8A~zW_51a
z>e!!Ax%L1zP`*dBPTl^e3$xl2bvXFP+Elrzlg07wQk&hP=YEaLY5H)WNxm$nfqs%s
z&877{I?i0VInnL=Q^V<gR|9#&BY4<|$M6VVIz9cOfot?(m-NBQ*#~ppY5wmmj#v4k
zhU4Yz&ehU^UOF9L5FNI!DSP;cuF<PAS_fcLCp;&R>}WzT6S6DYZ%TGV8L)d2>_n2$
zI*sG>2OhM#oz%&ne@V6p?y7hY^UBJVS#FlHmXudk9<E;28gk9(Krz>RCgsms)W+#|
z-ntB@MK^Yg?AImRK|aK&l8fo<8LhP(=DGq5aXWf?t-63doBann-mJU;HVi$iOE_CW
zzg)96ppDtav*#CzZQYK&?UeY!Gbwi{w%?uUY`faN=zERIA<~|hmDpn94|wl`>^9Ic
zAb7_KKe6f8r6<=atFNjpvS8ivs~U^RDCHr?)Hk;NfMD1ovHKJ|_CvFBIJHC{>r4D0
zevUi?@+sy3@wtrm(z3O7zMsR|lzEUov@d!AI_O*He|qbEi!bCN!SOUWn)DAH<UbqH
zp}pkGWq7wXzzdIJUbPY4y;;sD<_ec3b0%v;erIdnUXYG1^_}=>=OUYo=W6?-ANa)i
zxESLguVuVWYgTN^<^8K#r~XyiyFxFtmb)C+|J${`=RG;RGlzeid3#KMoO}B^*B{N_
zFEgoY_DIPWut&;XDf^~nI;MDVg^rEXZfz>#Mm!-Ntjjj>_vkg^f``x3R({d*n~{f&
z<PHDfr{@GBf6s`&C&k}>)nmW%A@#L@_7^)>v-=tONMM@T-jMXr{RI9K+r#IVjzMEY
zS7&vW>0!}@k6I_Xx>{3wkR8kY)W)0->~*+q<EM-s{8r-iTM3T2`U_!fTGMx$e--Vv
zrjvaRiU;@&{D=Du_Ksrg1gz5yJm)5SEUgv!4~>=h4j(-YZukQ|@)y_~{u4h+Kj;kW
zWbo4`ZI;2$U3ry0XjA6X;A@#*b9$g7>W9xKQ+GbQ@PzXJ^}Z6X`tQnl3a=jg0q|$f
zobq0gKO=e0;S_Xa+E<8m=C|^-T`XTF3;Av4>`L~v6>{v792Ni7<$^7B59Q-sO(wvO
z04tyP{gTJ9<Uv2r&`<So(;4E{J2f}^-1>gy(W=siYl(v<Bu}4PpOH^;zh`SG>52Q>
z|4MN1(C(E}M3>6=<N8|kZM*Nz`P9rGl<6#Ef10)pd|RC+*%9aOR-+60*D`na+|!)i
zYn{9IHo&{qxf^~=f};UH_Q>`bW23o!>dtR3aOSDbw`-8)(7nxh(`e3v_Pw;dO4^~>
z<W>>~d|C6<FKIlk!#{SFV{?7SCz@_6o-3Q@2Zpb0%w_ZZ!`Fxl{!P&K8u?c?&;OqI
zcWdI=YPPeM`Mk`A*D~)^-G2?`In}?<JfpIyu*QD+Q~B6^jV+&K>!>W{27WQM;T|1i
zeWrKCS#E<lj(kR@eUM!mFY&{5iXW6aSarRoHEw<mQ|ry!)E2sYUC+J@_nbQ&-E^z1
zMTnJ<)pp$@EB0Ypl=no}ST88N{3HAa>sQukz#fRO*?kubCu5ghT08kS%fW}X#W)2%
z6F&e?oPw|Q^@YU~X`b^~3pipseYdmoOn1J%ZvS*nGr2FHLu0If-*9>uQ(Z<Hm-5Bm
z!T&^<d|jb)$eO3IW3A;cH_`{EM|lXFlgQymT;%hd&QpO-e4XVHl*=R+r+mEm18Xmy
zp!c*Tk4NA2Jf5x@|BL_bihUQ8Yvl?$cZ+WxgLy7*Qf<jgvMwP{%Dv}**{kB3_Rs#?
ze1DR>%n_BbKk3hO`F`VZ?Kke#e&fR#Yfbj~^8H2DG59g`;$i8;KKAmIYu%;ty}}ju
zBOlg%+-KY-*aL!lFy&my2eS7ET-;|IOmJTk9DR}R+b0;tL>tCJ4xDxFUTh}OK)#pz
zH`r5CzL)Dux;Fhz`QCellk%5Rd0D;}`2aKLZKdDv)$_g79S?OQsg8Uvb%zVMskc}~
z`CIZwz>Il&*+2K&LL2OfHhwmf`k_>h&d-SVGg@b&Pw0u?o2;ed?A=keQ@Ogm6+P3I
z@qX8(d~Pw{3rx)Sjw%1=?VzQ&{^=8K=#l4pk?E_-rJ=W!lkXjyQ@?^M=6iQ(pAY*l
z%lCSpam|7c@_a8k=lNdn?@qZ$Z&%FslJAantWoeQ<S2Kp(jK^G`Cjs`G2hEQ`CiT$
z<3E2s*(mv5s|)#FY<E|6Dc{RIaAx-*-y6rfQ!v<GvwUy8pQKa1Pv~<I`CedrULaS<
z{musRhDY#_7&`JX>O)z+7k&7JCi&jtcs<`+HeT|*S4)TId!b`Qbj)ZDnU(I`k@CHq
zGr^`_WDid36}O{ll~2pAfJcVd5oN$WlVGP+$J$17MDL8|BkJtkESf{f_kz0~CxrKu
zdf96EUUZ<C@8z5`dD|BCi9e)|nD0e~<f)NSqkOOFhQ{VFW%=HBq6_G=*?-WLecI#0
z=E&J1ThI4$O}>{lMwjxv#kQ_v-j;cne6OBk>K)4zqpK}@i1>E$D75!{@ATQFe6Q<m
z%=f}i{FMH?<~6C#uG;*+Lpt_Vjm2b?^1VAG5A=sT1ZzyYSDpfz$Jp0vlAna$viOv?
zzDIb-&TB8vkI)BeM(Ch#&-Ys2tUI$q7r-&kzG0L8@wdcdjp*=vZxQd226)lenD1?b
zmmEGgiIZHGd0e)X?}h#<{WMrxR3(QZzu!n_Z5yrWua+M2k<f9XaOOA0pC${%bLa-=
zVvSdl$uDaib1CJ6sgpl0)f->iS-Ye+1J^hXU)x1oFS8HWL<bu2gmI6jJ;X8{Y$QW?
zM*qaPMV_1yPo65|aPi03Cpp~JY?*i&m}c@V%i-e3OUIxwqJQLYe^qqhcgW%DIS898
zIcE$Xj;B4oqVF+!u)!p^y$Q~9xIQ*=xaKqeAdlmiV+X~fn8QU5#T+i}oo?XC;rduw
z701UME^FaBJ@NtAQ_P2fpV%<waF@Y1$>GwrQ4ZJXA$E**;d2Bz+~460H?j-7+LF!<
zdk**e%^&uW>omY0<#3VhEPHa9;sU2H@lM~XxAQr%e3>k??qVJ;=5XOv%;6#z`q@rD
z@@1>Z1lR#!WwXc}_<^J=_-p*@JC(=hB@g<UW8bd&xXFb$=hK>ReZK5@2RYpTCCr!q
zQv<)ZUoh~`e3jOP=tdcD7&~!A(bw}%jcfI5&o|lMtJ5SsAb-0WUC<xrV&$%E@72Zy
zjx-l<r_UyS7}++Pi*=4-*?uD5qG+^NSm#yff3U$`-dg8u^kr|8J-uC7^Eut~ymkIw
zgUsJ(FotLsjpC`nw7=#yyv$cMpdFe`z9n<nkB2-j^Bj5Js~KBa3|STnyaL@#^afv0
zHs-QepmyiA;X?L%XxktbYb1N;Us){Rd0u$7nvJbx&M)HucuVE2@i6Z*H~Ctvb!aKi
zYwMJh=Vk0;?DJ{tzP2XM3rx)O`aSZ9d0ytVnCB(N@I0^e(`23Id0y6lw@JT%_w_t^
zUhc{BwrekrbpUx@=*`%h6TP12^>u>hdBMl}4A{*PR(W2-nex2WPCg{&d1+gmtKl=T
z4Dd0}3ok6@P=3YpG3==WN6bf_cd9#|ALkMsjq<$ciPJ-#*LaumEaZ97!3dMDCzj`V
z8|j17<9S|kf)N*aJg3w44aHmNWc_0K1Lb+i!Fit7+DpICd)kt}qwjkDE{*@s3VGf!
z$<ukZMY4fsvuaB|((}CB59^+DzQf`r*YNUe%JY&3IY7PQL(lX2`(FG##F^@O4{4WR
zpRO%EOQAKDopU^%-djQ*;ugw8%VEKBrk-m*AJaCcyqWIzQm4Ey^LJJu{#kyeUUQ7}
zqWqmr%B@_^1kd+?n2R_U%&+H~;`1~W{qu7(erCqUHmV%<uyWX&Grb2#{qZb0c<eh4
z>A4>D)p<tOjElU{kYZ5sxPK@b;IZegIX^$FaozVBz3V{Zf)?&O1kXLWLYKAIy`h+m
zI(!86%t_GT{c+}RSiI@hSm7D<CSSGVSr%ldbNrpBxSu;_{qYS;d(V;J$pN81=v0ej
zD<5-_n0xb;Pima=7pHlLu3)e)`KQa|ZQDLQzOY_@;Qr6U*g2C~OSwL1>Jv@)Pp7FU
zFP&TM><|q-j8T3@@6_n!TiNfgJ$Lav`nEdPSJVgd*L!rmS+MQZ#}|nyw+fcBdDZ_o
z^`edMHjDO)6`ce2{(WBze+<2!P5g4&+<!zpY7stYM#g;K0l9L<bS?O4>-y1G;IBQW
zbX)$8$~JzpL-WY2L<V)gHYNT~>)n=9dY>>nl27WKPqxK)q%WO3*XFYI7<5W)Ovfcp
zWJ!BuiTsc?^2A<=MNOu{{p*T7&@1qYpS?bI<yK2|%*VN{K+i~^hi_HcoFUy>CtA>l
zT(`zAVk28bL$t+yz2oDoCX`e9;~(GsYprCRZjbmHzEjmDS$9|OzmO^K+*1*bZ22BT
zlqWXXp?(;%<YVs;;5r|-&c&Qlep>G$^ge3pBYw*p-SIss@G@@N_p2OUF`w?!x`Dl;
z9l}rfuibUuh0on{--Y#?md-P`rE6%3@AyBxQSaYu<$Zy`=KNsI?z)LTy_z=CU6Uc>
z?h-!a4Gyjksm`z4QaR&s-_j#E-t$Hoez#A2W)7~3#}&!1NBY_$JWd<qM?XxLgbzIE
zG<~73($5XRLj$;3uh=to(mTq5xhTDhZAABmn&9B4{M%*hi1k`U?*M}?%2~q}^#*<U
zA?c6HaaeNX{qTdC-VHDK?dknv?x#m3vzl<RA40wR>2>1Up!&>tkiYX0xX&lP;G2PG
z?}qVmP5cC3;RE9&#|iIjon2YtT_azpK6}x}q)&F%9G=lv<e$ki@NO~j&h$nx74%eP
z6So)o?lPI=It9I5dKMAAhX3-zC*ycU%jIg~d6&l3s%QG(xAPxf)U552?fe_rX;<L=
zHu1hD-VbHWahgAAlX%K|()_wZ=M?<9D_nDafw|FTfbaKferNO!DQIxJgy-Nn$6TWM
zvYPJaxYsj}@DMvAzmM(Od|>*W=gW`_F($qQJ#RK|xjz{Zp5yRJxRDdTTapcMeUskn
zi%uXLz6CX$<~jD>y^Nd;GEkn<Y-m7m(8_mbD3`z50BwwSCcPU=^2%W)n*re$J(pjR
zE@M~Rznreo^PdnbI<r@Gygv**Ll@xTUh&wkABOjWds;Ta_m9y-Vhd}V9W&nYjc1-w
z1nz*r>HVOB+o<svfBBA&d|2zJ^Y_QH=ZZ|W(@rw!*EKd9eH$?K@v1Gp)5i^sh9eVy
z)gN`d`xKhdVWU}fyyujA>e!<(9FjA<s8s|j824BB?+(F2H}MDUj4s8!2Cw$?+nscg
zdfualE^^KD#f-mej&~#H_Dvt?Oxz!Goi_aj9{y{6LEB7zjC$mXEs$5CPjK^#UX2JY
z`Zw}24?J++_AlrUKgU1bYx=zY&gt(3{rNis`G%;!e=!ptw-Lq;esmHZ#B-F$x?Yx^
z9nm}PZQitJOwv2zH8)rpzVceW&9p7`6ThnjJ<?N~m(Qec%&bpvKd5gcVN;ABx}fL7
zi5|YC!~N~){#wUf#IHEc#_RaC#$Go5B0M%8>FbuxV4K*A=HE@Mb@=Y+pyo}p1O4I?
ziFc4W*Vq|472lo8dvZ6(Z{Hhy_iFD^<!lD)u`-)---thy4A=A?SiQf{XoSz?4>FBy
zO!Ra923zO7!Tzpb8?&B^tjf>wK4tDbzM&m)gT<TjCC(qci}g`>2TdMddCYf2<KLsd
z6Z)&^J+fW;t_<(Q9Mjx2rZyfE;Gf5Yze{_s{@wwb8?|=AZ%AI3fq(rY@L%7zRvGtQ
z@}0D^HJ^MZ*UxMJk+E?-XV-c8blR81=OHuZS@Lc87hs=A?eHDPb!|M+nWP@|aesCG
zVnyfgx++=&>HSr#>noZ3jA(#AHfO7y`&YgT1AXor;0=9@&_|j-xvz1r`4hgaW&Y&b
z@c6>w{7GDbFT(GlBV6xN+3#x4psH);N_5nCqJ7G?+MmA0{B@`Jj-O=yLw~m<eja5n
zlU$U}>XWl_erc_E8611TAs)l4-MWsvf+xhWH;FH88y|ly<)Lid=5dAd3|v+3OFBhc
zY>v3gZOdufn`mpNZ}AYkpVU~P4VXdEwrni5V|t&3@#Ex+>z>qk%^Mc~w)kP=R9)g#
zFSOEbi}c;=cn%%f?E9|SLCZ-XWBiJZUwf?e@$1^gpFN`Ix|WZ<r}oG)9WnfhL42Hg
z*YKkrcYId+IL_ydqLY3)LO&Jnr}D@=b+2pR(rI`_*HH%4Q-%yTD(BT*J7BV(4s9k%
z+DxW4E%IZm`S3yF%>umAnza+W4+k7PV`=^By&2uL$ITX)+kx8};I=qiqP-UC2E0zT
z#@;P$sdw75L_6=J_3^%`Yag$-siZc|Xy<)Qj$^`ci1sYePFzg?j|I3R4k!9D$!;L&
zXjLHs_U^i}LvXwgz-5SU0T+9w-Y3sjMqR<LkhfUoSEQRoy}{0+Z|M;p?ECjpAM?by
z$sS+QwaWxri2I>~JyVC7beL_qE{%t}6JDqBc8%n^N?vxXBHK(lA-sz956^eizG}F~
zLi-)welEwoCDd*9I&fExSzDg3bh>yKt;>}>J-)W9cGTeBw)i;rIdAIP;F3Pghq{-%
zjy{BA{oTs>ivBYj=N8}t-y!h+P8DEd?oBa+>HFaTzu)1dGiNsbspX1u+|L?r-dpdu
zw>hlnINg5U>UsB)*VjV*8P-mfZ92DB*)Y<Q`zp?!Krefy-sWwetJAnIrFk6vAaCWo
z>zd1XOTNn6&V_pVBUjN@J1QRKzTt@gd)#3)PJAPAG_>psFnb*aKD%9boG-hGK7O-c
zJ#KK{_rIm@@1e)|`dTF)_b#(9*~Gc~FVvJbB3DJuiWtJ<3F38+&#zZ(#j}<?d&x7H
zJbU?3m8}mk*R*1eXXO8%5pJK8iHDxinDAlDC(O~@^K3YCGVzVi$;_{`^>~H&k$d!u
z^{&rVTtAa39{D&qtbEM`&Mt7uKDlnU>w|V}K23c&kEwqhKO(=){7mkLeqLOk$34$f
zavNm+$2S9SK212Vb>w7gU#+z>wIjC#Zr0viYFo)x#ty7oIt1&nLx<o_iC6!pWCE_6
zK5^*6xYlC6w%ix`_VXY+g@gWyt%wo&g#+69lJ8>;$hGSyG1X1A0~fxL{9k(^uEN)$
zKj7P`w(k3QM>cqQjvSdWCv*RNx*ya%ISIyu{8(?0+b3UfLUgr?M#~v#Jn#m7!jr0S
z5GQ%e4KMzIcyBt8*4@<Ktk{@13SRQfWzT>6*gvj5XfyrX`KEH{S6gK0XDIQf(9AgL
z8@U_r6}OF7SMr{i#dxCq__g#$PM}eL&S&s=-qiX1$Kto^jgPevPn-v=OWrN|)-twc
zylghMf5zA}X1+H}UZt6Q(J}Jy_yxCB#*56>X}q*`J>wb~K6K@Zt$9xg=9J2c`3CoE
z__P=Ghks+O^t}FF&|k0om**V#&ICCJ^}TRf`wZT9Cc5yg_?FY!lNbs<d4hdbdv_bU
zg)d6qw@$Rgb*lSSf3{>${gK-p5Ptfa-T3SR*KcEI;=zD$3@FcHzp`cOeBZ4_`An~;
zE#G$JjJTC)&IfiHJfe9<G*9T-{Q~~9658{fM`Q>N+8q(By%SXB>{GGMGQ4VM^St(U
zxu048oIUeQZY9p?l9lD8$P0j%z2FFc=8pWkXZDR>twWfPd(<a>MQ5Kb4^)<X1b)DH
z!u%{>wEhG6cOc);J^uSxOPgZi9LC}k@eP}1eWQGk<?YEcAQy0<N8q#gM6j$CyslsV
zioRp~Rkr4X&MylO{+9OaHyfS0_S`4^GcMv2;D6L*ljiWjB-cUR8x2Vw_3|X|?ljIA
zZ%f{`ZeSd5raAvuORMQavHeS_p7WW=pqBcrCH%96`k_?cr~EwdL&_0WNAADCcW3eG
zw<MnqpYV5_ne=C}p$EG)JyyN@`9?hS`5gWX!bh!#d|#ee#O(!}CC<Q>C-nE0{ywhz
z@939Ugt(+=!*$ygUehzt*`aH<Pv&jPEj}x$n^oOf?b`Qh24v6dxq08!O!)zQr;dB}
z?z!KgdwAq~`S511bi-g|f4A%UwCs+(D)f-~#QBK7(|gW4u@!&EqjapdOZUv-e@|`c
zqZ0azxO{F=U*bg}9uYsl@pn@H*eyPgIU8HC=R=Y|_%rzf`WaU~+sEegE01n|+T%a`
zWvkvz2H(4cpSi&H1?J>qRo9dBit#p@Kam?_*H}BbhEAOuwiw_Hdkm7F<Mnlj`8t)G
zeaaTu!$al?PcJb&JkXx_<(G90&J87FpT<6P4irA(3;$4KcY5%1;DlGM<HVD{p>N~B
zp99Kex~xt1@m_r0nrsi6wC?YP2QKSI@^PDi-aLL-+P`{QcF=JLS@lY#MfSmb$2X|h
z*BaEl>#6T4A~X8o7vKNiYy1NmkIRmEBgzi@Chqe%o_pq%vN+!5(Iz<?9`%9$;QRqG
zq5F@rc**(e^2R@WU9_Q#;3by0N%@vWF(Thg{+Qr%JIVVZx7?L%4<7TaO>nIiLpIV$
z+M8~@!`P7TRH8r73_W}go-%apf0wQyo3e41@d8-zNaUB_HTvEupPGzMvEin&aTMeJ
zVtg{1Y|_7b{iR@&QD@v%;{4({bJn)JLrA({HsZE1l43GqK=Pflx98vC=39&C`#9@H
z`2+Ha$VmNdB9B#*j{fta{oKCXerDAMTbG^n(*8%Z<|xJ+?w^n)IG-0zzTe*3`M^cx
zVSCvJ?AJQg{R;Oz;T|2bJ+aOCnN7t&b`A(%PMZn+lIOSfx~3n>Xy@y=8PScc;`6Z8
z3H`FRjW$cW2EMAEU;S_4hv?fE<|Epn&p(!EfUnTPn*JV@xlO`r%V|{<2kUwmKciTd
z>zb}D&!L=1rINoV2E4xh_H$8T-FI<PV`N{3_OEL`!)HxuT<oP+YUk~Y7P<o-Xabgc
zY?HQ=Eqdp*+S*)5&R%mf_s^vGtWC6#ThjL~XU^!n6>{WU6Zr{nFg~+ya!{I=C?`gI
zR_h~&XFkEF01uDsT6iWkpE!(Y>?Oa2ZhT%eLa(n?kR!ShpPM9yLRpsHe=D1)>x022
zJt3}e{ovdOy2@OpT)eH%SJSEM)uyOZqV@8_vQ=pPpstHLHv4RIJ&VsjYn&FdnEr=(
zl(_=@HRI>fT*$n~IV|Qw=0$%dU`p3F6y`!=HqkD5>YG}!dFH@mhqjJs*&rLy`zY~M
zyU;!2fnfhUzfzy0)Yj+E(*^sd{UCa*bqs43?#acL&7a5>9gq&$UdjiRA7Wj@b55LT
z<lBHnUE#Y}|4O<79QI3Wa<#cB#Y1+U@d!2|{gnRLJvrHQ-%BjRcY#g!(wS6fW#5Lg
zC(u==*Y@zvFaD5nQ0;T9A&%O2q2YI<G3dSKCyO#5PCy3qNzB5zB-RVBXL^pl5F<<U
zoveF+L+7IID$X*QB45rl(+~N^taj+4uT$v<zB>)rrNhZKm%%w5drIiQR%zFo^ru7D
zu2)>6GqT6al{uXUn_F4~`5fgsjP7!Nutk69bGsf`C%)^_ug_bY@%3|JHS}2LYcuhv
zM?A-G^R1CQPF^~bR~BOqi>B|0rkm8ZFSYe&>4HBkT|dzFkJWZUF#~f4`XY1d<-TX0
zvx|z|p37|>UlDcF=N4=}en$ct^)C6#%t6p^aX4pvB|ovEcjDVQZtC&Jvo}dkc`jIf
zU9y_z`{Cq_PU{;5*hE>sJd;-JleNiO=|v~wTzG#2dcUZ%_(giV-X(e&KjUQX>Ph{>
zk5f06^Mh|JuSFKcu`v&MKk$fq;-Cwf$KDCg@aydbpTby(<FO(4sn8wQBtECG&Y+I<
z1#)(MTFd$Zz19Bvn%0x#9novq_J$quF|@_+<$Te5MnyAx=ln49g!AW56r(am&hn#!
ztpD)=v>!H{OLG_B3HLRdeM2~X8+c4MKBBp5RBcXo^No=E7e>^Vy_20eiRUO%OuD1@
z$;EBi4U7L!&+bwV+^EWmwt-EJrZH(RZj;0IHGs8uuBY+8srL?S6D_}@K1PJYWyCkL
zqKxSK9Pc?#^B(te+$#n{esTYYx@Xe+4BSUY85?f#4;gQktnncumBzUPWE0!-%@c5}
zwLLPb`|M2lY4LQE#>-hwqdl!fExr>S#GamKp?<aXWhK*CG=CL+>jyup`A$BZ?}Yli
z{{<WOvx|JIlr!&M{*$4c=PkW_TPSY}<=azv=@`~Pb4h${^TAri+me-!7hlVm)`Fwa
znw++Au3x8ln=<t4Da9M?A#atw5|?^8_ge+S_gwiFDmg#D9@hHI_v4a(zc?#6d?IT@
ze#yh|%ib3_d4J98oYlGM(EL-{$D+?e>bob^Ltiz;;-bUieXr+xKyHt`V+mP;b2S}m
z#1GC4#ph>sa6fl!5gXg4Yo4FsyU*Bve17IS$p|{?&(CPAzzk^&e~qtWZJ@b^cxg!G
zjFERV!4uZCe0vc-alKyrq?~a?*)VqM89ViklYYSoKI~5C^m?5yl)oE%0S~x|ZLtCF
zli#$ptHnhcC*P<ve<-_Vy~i2XqMhO&ZcOrI4K-c+uC1E}L^phXDeZF`Un&RZDLWg>
zSbt{c7iYCrm{U3DmhC$twZD9|Qk%0JAL~K%OuW#yxO4o(Rp8neaV7k_Vp+gXd5-@P
z>1B=|`diW(P-hrBXA^#%^D_KB0T*<%r9L<Zg#Tt-Rv!9!OZkxEIP$$a?Ima&Je%SD
zXdm19;hfMie5s!k#q!Y4@p?Z?<Eih-<ZG7=Rq=@RNSd=Z@m)9OtbZExxUO^6*7>>~
zs=c1U>@D+=%k=T~w3ZiL@6=w=uV{<5|4?|=s?1)|O^-jPWJ}Z1r77%CW6=E9$+;o-
z1LP#Oai9FasIJMSOsNgN?t0n2J!_@*)53*qAYW{sxgQ@*8Mxop*^)ZH3U({rnQdYB
zp08z&{C@F{^=TaA9`4f^cj?;lMH*j+#>af?&u^8@+hsDx$HRm5(wjcX$#_tGXXgUe
z;@ivKErNfFasiK@DR9}a?_M?za;q^$!N1+3d5#z=>XG@tERT1#nY@?cQ(u=7r?NIB
zzjEtW|NKi@joPzr{POSSkZ0jM@~C20#l8#Mv_9pT;8F3>zW+l$Rdjgl+M#!h?a&zi
zzTzzG;qCC<AI%%)qpAN&s`t2)XNhCn3I4Mo?&N;5LEPzjiZ5Wi%rnf{&^4lU@Mz)>
zXD-4VVBdrvO1@-N{JKwPN!}-WAtzz>tGpn4UpzZQjNDeceg4YOa~GL^q)WZnPt$ga
z7p@HDxm?bxfWz-2FKXh&s<`Sjw2FotC-X464L@&9IIwq%fo>9Q8ZY1bA$I31@L8>6
zD0?`S5eJ|@n*)yme@gQN^wqAu;CYM*)`=FALx|V53syAN<2CNLt6e?TNbv>pP)&3c
z<F#q|Fvf>p%;%~+ZedRFxP?0Nmzu|c=bE^M@*<7!i+bV~>WRhC8StSqXOx4*?kK-g
zdsO%r`iGx-=*46teX#HHg8N!yyEF3F<ZtoApO#(}>6C7Dn*J-!V_wb2m&Y2+57R2I
z&(YamzDn8CUM4vcUzqGe`#8@7|FFZ?`0iPbW6aBhgXe5qw~pwnHTZ@CKFhr;_5l~~
z^(xZS?PbCh_4Jp8E1!3go=P70<d*8e3;2-Vk&eO--)A<zAQ`ac8%k?N?730gOiWZ?
z^XVFW-Jw47_-|=GBPPS2ayIJSTJsS%&x#-2>X%%vulXz=AJ%Zb=A*o9%}06Jny+*W
z>T5MUY;^uB@@ltYLU{FF@oFu)-IA5B1=-hrr)$AT*Ez*}(Dj<^&u#JNzE8GD++Vas
z#kgjR!zq@<7R{Cv<6;whC)jPYXk$I9tJ_72*=h5-;x=zXOitNLu`I>O*cRtFi#W>k
z0H0!K3f_fSHu9f%6aN2t;(2|3DcJ2v*)8%Zv#T<CU6#uCU#`>s4r4O#tVMSl`Htw9
zz{7q%W%wobyUWH=^dZCp{l#3U`~tbqQQ`D>2U=siLx1k`sN0fqp;znc)|w05qW;pl
zYQsL|JCU*FLX&<o=b6v<TxjA0xlqP9QpknUeuv>)8EdldL9EHyFV2D0<4aw5uGIHJ
zR(tl3xdi>}R)1Qjm`|8d-j?%|Gs<W4Tp+Qq`*i79X&gg)<xH&&It>oaiuR}Rf(yBG
zeiB^;9=}eE68CtVZhtQXu>|j+AqMXezQ@3)HJbMUu1t08sj|nHavAnsbZ_?_)zOw5
zHT&k!#o1cUMScD=_gxrN+}5Vp)cUCC8K^8jdjvlE0soBh>D(jZSG1m>-$*;>^8AdR
zpK1N^@9EtZEuwqllAiW34&6f=Jm|SiJkq<$>tj-$lW$LxlW0>6b)VjwLSN+O^uD~y
zTjLl59vh=@b@ASFjd82S$TyXXW28^;ZP)K!;p-OM>w1qkZMN(B6<z1&#dMxPaCW|5
z<<AEg-hu8g#Gk~Dr+E%QaN_~)M1TVq&rSogKfpY^3})V*9Rg-YfZ;vp-k-lC3mD#i
z?sN|pV0b1Bm@L3_6kvD`9GKVn&ajVP*Rij@1moXS-Y)pL0?hQC&sto4TI)ET!2;)r
zfb%hj&-7f5)==G&J!>N3X7rBOhH=4b>d`rHo$l6to@Ba3?a>c|SNzAh3iu8ja>S18
z?6qQV%F)pyNk^%_J<&ABd&m|48jN&{_v}X*kC)bKuR8JIK!bXh>sW(&-kVyacRIa0
z%<0uR%16;{#)Pi(&2{b>%jZ=GAN;&Gb0YU|rf&(8N8{eVi_AKM`<GKa=OCwLSL9n#
zEZckbh9?*MWSg(({omLl=U-><$=65lo@Yu-78RX85w1yaNk`Z(Ii+jU5y|e%jprAB
zPW$->B+K|r-9+}>GFgISv)b8t3CS2=_-gWn<lvA4{c_fZe!+>nyE3ig&=IYh*_-z@
zIrp?%rZ1um-vQ5bZeSB@clL(mmrvTY{M@woT38oaULL+riAU_gvnR(jG||T`ZTY-_
zE^!vXWTspk`xLIbyz3y!nDOpZ?xL=5qUjCEaZ2<-(`nI!JZ4ir;C?3Iu8+OK*z;$f
z89TB&todp-$?*|g(`Ow%@=ALTz`<u74cG+S|0tf4hp5ZR?2fgNXs_tK7L9Phcj*xG
z;P-^1?78fQZ4(`wi)XA&`^nBP{9WNM)1^}UiGKXXPr<v@#vuP-Jkgl}9}he!9nWgG
zR^vyr_AVRI!LzK$uhE#{$1*$6m>C0OMnB=H_8Lql%jK)_CEY}JCV$rx<KI$!y)W0h
zz+d?9{ubZFJ$A--oOBk^;wE%hYo6t_EbD9h-O;sXyj?|y%Es`g8Ut$`=>KW0S8Z(J
zop4`jsdV1=x%@0aPmAC(#aWua@DrYECq^PZ!baO=mk|z_5#jCJn7{u`KBV{hbiGd3
z*QIO4qP^?V^^p1mo_ELnsA8b}y6wUjb$ws;!NnidyW-&ghL*}EVnoZG4dr<}o%!he
zqUx^~Ey}y};)^QEpID5Q-Dm#%bv@h8y}zH4@#)-?otJRheSH5`xZbaP7-!1lAA8$0
zZs?#7%1$P_vyJyJGM4x2m+`$%zv$?D^_yvq84{0%syge=Gxnlgd^%b0OZ<dS|3>=5
z*w$-)CI%#@sI`mUL-gR1|8kuom#Um7?*W3Rz|?izbvVF$Pkd>JNBPhp@e#WIS*7x5
zLtFt)=bKKhicfxzal;4ZH}<=jvzpPVShjN+OdN0OpZO2GasJyPz2F|7ulG4@vhnyl
z75G5zcv+q79G%Bc{HEx0nYeCGi0)<Z2^Vn82@YrPag=YE5DiJbn;e&~pZ*)+Z-&d^
zmca!2eo^hwJB^Wd;rBAHV{^N8UF_?j1dAQW&derwZ#`>1aPWRv%^PNOYt`N3<W(Bz
z?vJUzRdu&SFIVVply}naT2Xf+o}iN-F6wT?72x`k?!vn^cvrHP;=Sj@eCXA*u8H~L
zda+yj2Or6$!h7D?$@&1<p%cPe*Cm(hcGbBLwtZmbF)4$m<LUYITCx}7;Qv`TR$KG+
zBsy91Wew;A$BOwe*aSAW3?}kTG9ZS=-iQyeWw+_=DnqC7vHMwH*B*b3vk;8Q_Y}DA
z*8ODvb6Wf8SLcL|&gnd6;u$e*+$V{1$p=Lj^Ge^w8y5dR%^|F_x9X2);*Ni`Qn{qx
z+qAd#*LrqAJg>Z>d!B=PQ-6P<zc=*f>vEor<5_*4b=aogLH$9`Xm+eFH}der2yJ=~
z!BN%W6B@!OF0ZI<KK5Jd^T}Y6AO4O!6?01*tIsQ}B?i?;+uXr<aLm?(W90FLKF#mG
z_IrV{G*7{&8t_h|Vq<g<{PFxKeQ}PHIl5hI2=`BsulN9RJFJ185?`Yqg_e<x>NlLD
zBTq%&EuYTcJ+z%`&6mg@y{X4eL2rD$0xbId%Zf9ArCo82_eIs=%c$EXoKy0n+|%xR
zZ|C_I+Uyan;Am#Id?OjV#U3hm-dbw6tkG@FJ@o8?%LaZWUR`8dqv{K|A>r`+z~+RH
zH5ub$EyMQ^fZG}1b_F<|F&+@UBef+x7!Z7!T>b=Kr18ag=0B3Gz&{)CpAGo^n`2wl
z7Pwae-0Kb}eLf<*<VAcg=J`b6yYE^WU!SghZQDI}tgeS!RPK6+J;!(uU2~oGIE^_+
z^HYl9+Ac8f$RF14iJO!k?R`&*_lW&E(zWIT8!z8YcD_$KT^a|v$~)PMI{OMV2A#F%
z6Vn*q3b-mmX^e>{yn_cm^r_tY>vtH*+25u9?L^m>0Jk;3@s9Of)JbQj1RMP%zJR@P
z`Z*lhANBTGgWQmO^aSgrgtwY#cs}4bw-y|%VdX!Dl1+*CC!r;~duhx)x;EK2qeXb|
z{gL<J*%9!JIUey2o&ZZs_P@%9*!TnN(Ew}TObs;tr#e>*{A7Tib$H2+u`tJ=3qO;1
zJ0D;#1z2R^xy<%^md4zrYa6rh;iqCQb1=XS1vqed&TCtM*|7{}DVO<hfZ1Pwaosx+
zV8#nDp39sKFlP%ep39sMFqaB2p37{%H;iA`K7RZmyoBci0j5@fA>RqF-2Zp$x|n~Q
zP%P8P*MD7g9&h1$iJ_zKWv=g2JVu_%pMm#%0iM_88KwR#e}6mY4p_UM(cTh!iRhVp
z$tK<f%sjkRdO`g}|FU{JH$%OArq%m<D)B=+d(0j${+YI;iW}|B0C9osB_6Zqm3VI2
zeIk1Y=tY-)*)!@854+Tsxt()&ybI~~<{vj&w`z`K%#@!>IPw@Mf8UG6AF>_hcAlw;
zb33&8-0sh5&=0bpZ*cA`;KUz&hc&+H7{`R>Jg%Yl%w734{(Dx}l);xlXczx|Z{{P4
zv5Ik(?{jRGO#Geto7E0p^P9h8%AOC{^rqx7BD_4mLLD(6JQx-oFRKndvexBXjn-%1
zau~+Nd}H^DA0;1akG>F3I$TZhB=3mdoQZDvkVf&O+FLvcEu2B2{e)=Yz3e>O13kQ_
z!sXg6ICw%%nOKf@#KwMn-os}4gbR6tgE*X64*V`}%HIyM0sdz4@TOO}yulykO<ykW
zrm>uGF{WEZBY5E(G}GtNLZ9fv3(^N@Gu`IwjO(^y75YRrzGhhgr+ourL1JUh_qZPM
z3k`O*E7&f&<L{@4ak<-cRr=%ax9!n+IOygK3;u{ch=*8zOlwb(Yg<>O{M3}nrqezp
z>n~)F-A<{Dd)^7zE?sdRlQ$q{XAf|{_~K`|wElUtX&do{m=piNGuKtoc!PM|w2k}*
zvheq8(}p!)v@6yzw}?N^3-&#Wym(i~uUvxBlwuzA7axG^B3)(lz_UU0I(vKpeebvH
zgLcgtl-P^8;Pap1ncYJ=f0XCUJ<i2P`dJ8KLFDs__PyzwcihtUMcwnhRd_9#SUgMp
z4D*uUrxU!tGlc!r+a(9+Ig#Y~RJYzgse9im=6#gpnJHs$-rt#szhuvv^4+ve&)}G@
zNXK3OqJIUJcOKy%&^7b%vM24g*q*TM?`j;8m(!B*Pw8(=e?P0g9s1j)KYve4e?jKF
ze*#|2XpfBb#klwY@5#M*zv#rxI&aN$|9n@F`hBUMoF=@saiucwd{}tkCF559!^XW;
z^~=W1{3g9cPWTC(127p3guWRweha@mS^KWdiO%14;If0JPw4ws)K8Irub?Xh{(V>c
zgWeaC9&xsxx%}r915Q@ID;rloX`H9Lz2=Ia)?DFZ^1au6s$VfC*>C-Q>7w81we!%T
zSGu->&duIWkhAvejLvFFopKdcXTG2D$%ir~e=m{GZ|zD^pv#wnE^Do1@^~@nmd$%f
zXDxORjo^9$J=NNl>t|dKQ@+A%E7^73=O-G_Z=ci3<hGT1`Vd`1q6@!(jkW3*Ig<CG
zEc&qcJ}-aw(DtO;==jg*4}C}Xv4NfXbHB1fI?wZaTQaS)<@2|ykFAmmd%LzSmkl7-
zVY`=)lAq_DROl|{(4p_sT;2kI$)}4a#6INpef{d|bNT6B;9dxDX9FDXk|fSc`rf%t
zczI6uY2al88oRy~qc}k{S<X(rjsCY#miDo8zn;fgW#u*L1~|7RoOj6oLDO)eiMm>#
z$$X{i;W_IT;x**krFT+cbF8oBL+yQUoF{-UU80-1wAQvd{4jNli8^w=%wgd2Z#(f$
z?or({*Z!p7IRDO>B%lA`H#wPGl@EdD!#wYj_`P4(&TnXb*J(4la@%FRkyiXZz6E~;
z{m4qOcc+!f-Wdlr=<^TX%ki;!S@C;3vdxnY<KtI8BJU^Q^twookNs}Z={mZ>+h(Fi
zyxV@)lJ7%j+>de=mw2DPkva6;soXOAPRLq1-0AnoSN@`Yk4%|Qy`J0(bLU32=X*=Y
zyOyqjqhEXgIxuznbIWuZ8YhFVcfD5r@6q4ZSX{q^v(xqIw`{!g_Fj=tZ#=+m70=go
z4;hZA-)(vi%IVrMJrkVUIrgM|`kc>+S8>i+E3Z7y<h+14-H8{&+DC&A_v$x)K3e*r
z`EI&R?{vw?jTO%2kb9}*{DEIQzYIL@Kp}33I7-{w{&9Y;2m0~pj1wOF8iN?Zd93`%
zqm%Lj#8~L^=fz`WL=J`ciZbUr<CLy;`g>Vip3{;iW%Tn2(FpER+8CR1IlM20XVs^f
zSA<_a)%3&8(5OAJBJ);59Li1k`@qn-rtpCu4rj5x`XJuZcZ1B&(jW9gJLS?n(<OXR
zo)cbLmwFzboWAGxeU2el5Z?nq-ip0j*Eya~7*rpp<-_Ucvgqf&Uv|!!Ym>Kl@=NmF
z*z<&P4V;S{l>FZ2nGgBE37su{Q`hbT;VHPVxe2Yc=|i@9nQP<^4*HmoOerJA(f15C
z70VvezBYZrANo6*o-yeVZLCRcUJx!@ld67Cpl4U0r$fGxSQ6PP=eG%5BLQ|ez*_!I
z{*v6Ze^=gP7IL+;Z4YhVzISQd%%OGOX`J+@dGjP=WDL#5&%3?A{fzLzQ`Uat0e8RF
z_PoR3YTny%UUL;X2LC^!>pE?cYc25uUk{IG<%5tlXI52a?=PUtWFp<5oNuQslm9(I
z{<>}^fBat@KRUyCSa_uO@o$RvH%adF<#Ios`kB@FQ@)Yl{kR_3H{Ft65f8yfo;z{f
z<T>Yhn-X2HXHb$J4+hw%3q2|)c642kTurx&a*gA7Imz_J6yG3I;xDJ=T4egOL8i}Z
ztZtJ!?_uNK?Xi^jJLY{UuM1pNu?@W05@0qvjB;()Vz&z=cKc1)nA<JC#1~Gd)+$CP
z&o;Y!_&$R3B=Y=el}DZ{bT<3**b83QW3S31^NfvWP8{!8z+1(i+1zu$crX&+h65b)
zjD06Tdg=Xj2Uy-IZnUQUc(&R5dqdYg4*F{k{qf9+!#yA1*cT(VQC}y`{sSEEmWzEI
z4RwdTPI9BKw$xX&v7$d6Px{FF!^!#34%xULMTe$ZH1~>+_6$n037$EL<Kn$$n)^4<
zm)qzYtf3S9C0$2&`e;U%>5%$7m2hAuPX`>=VkgHn7WaMbH*3O6Ov(60QeS5@?+<%l
zvXh$pBHwNR#@@xHF#*#ZU|5^6X93Jx#3Tvk4PD!~g{LEZ+k!n3;LZiO=L4LtZGd4-
z@3@{0Fhin={SRR5JzS~30|5q_*#7{A^}OTRS%6{x1DKHjGhBd~yz^PpfxZCKU4UW#
z13YgLGx_*+ZR5`#nP>idh4pmunfV^ox2?_D&}P=#h-dDj+*gpxppWALo;AJqfljT6
zS3`Uib#CG&JyR%LJo5leoTntuu3W|pebho91Kx*d;u&|(U9t`zws~`9?B!=F%Ju_B
zw6@=(w!~fT3)!>TEL<_};@;yf|2C?}UDGM<+ALak@XWG!J}v*ZP1kN~(SJ{iH}pZ=
z#WlVU9P~llMVZH4#WIh($V1TICE}gh<F7H_V(;iIxQM%`e?G-S&@&feDdMg^<5wPc
z0sBONJsx1)?~|)PpmNt6WJKIW+p*AgM`%mjRp*_?>2VihWDL#5PuvA=kLk!U#F*}C
z_f$sJ-(}6w<Wk^2aaWx-#a$zbA0BtHjzZR~L5RD!rp#obxQlYuGRx$jVnmaFh!M-=
zPuvy9PaA(18*x{>C+?yzm-`zjhGIQ-Da1vt2fprtHsUV$IGfslcQUpq(S^qX?2!N)
zb>U%^M_nN9DwAs*2XPm))DnJV%Jal-C)XlVo-uZrdfdghnKS8&T$<bDtjAQrrvWn_
zU`{wpA?{*qYq4AAOw*BI%N}<jKYS>0KflmP+yxDNfrjotL*zN%yox+04x;URii6<w
zOCb)j@rSxuuS>Cs$6dfZ5#WvoIO49O)TOu!*u4RkxX$EPd1Rit?V)a~*QNeE?gDNw
z!1V{X7<U2J9^m*sOzi6t@lx`)^In(w^0+J7SWzy-UGzab=W!RZaX*R<ol)Ec%>K~V
z!^OT*+~xWY{MG<ZT<1DYY)2o>=rSD=j*f%_JE;U5*J3BXtFgG9_#QF29^x+OeImtO
zykCaB9HUouf?p)=0){;t_zle707FihxC@x=0fzk>#}nf&;06O+zr&3@G7oJd+0yy5
zwz+Ywb@TkA)2%(zRrk>G_rI8IYc9o0&^;aEC6DoJ`~l{8fFV{V#<TGUn7skUV>}yw
zfZ1ArA;try7GMSnFvNJkbOo690t_)8Fqcwn#JJ`|Yy>@=l>x?MI$#>bboe1+I^aE~
z13t!d=xei>F6#62O^V%xt1PCY50B~SqftzU{PMi{(m5N?r+G~0xir3^&Uf1TGR~Oj
zETi;^eTBpNCGStJF3!RDUVJfY5$YyWUQF}6<@jdg^K9=?K95|P!yifTex{K+^1$GF
zB-Kr+ZKg8(<*%fCC1v!(o+;&fwMOHfZ}s(vAD1Lw{5pH1S)$kczVtj39C=-QwbxDG
zq@1hTO{R7!7BifDONu&l*m07Rqd$MH(Q<Bv^S%qz-I8eUlW$@lQqMu;dDet$^eS-C
zH|rDnCV!mw^$YWs7gRs+l55~tqx|07<F-%D{sQ^rc)p~k0*~bTbVkC@%rFk)jr@Y~
z036!er#$~&PX3;8+VcJ+-ct)+{2cIy*U%^5ASmk-8Ia318kEcSKB~eCe%BNHY}{kl
z&SIr<AV1sPpUx_w!|Xfyy5z8Qc(-(TPo`&|rNa-4M~-i|o|UfYewTg+^*g5DVg2sZ
z?~s0Xt3Q9&0KDC+`=Y+@Q~CGwJSlaqzkk+V>EzzekoHOL+%xC%d^WnuyYeW@l5P-l
zaPM)+ZjGJivSVDLwT*qRYd~#Uhw|s1WGkJv&bs^lg%3#&@V!&I*1ojS)C~XOHR9J9
zB*Up#)V^&7et0;o->JLvXFLBpori{gbY-`6B<{g6*X&Aj4Rw1m#X1_F>z;6#eP(K(
z^5}M63*H_PZ+8hEe!P&LiN>BcCwXMDCF&+Z-PTlxAE54dsKft3C-zL;zEHO%)w#Wj
z-zKBJ1iLlBjtEx!T9?t0%^%PAwJ3ux>|^lD+L7NL{nA%=YLESns2$ITdYdu9uy0t`
z0l|y`BVCdI++^j_pR+t~tuoe#R<CEBh6UG}9h%>&KCDbWsG@Je4*9*#wNwR@zw_|f
zMV>b<wjFiYlD2)JE$y&Z=w(bJqQ`xb;S_D`8!~QShSe9>J9Ry%>z!)9H^Wv+_T4mJ
zz#GS-ecfLA;F)gkgZ7MH`?DvDV_=`!>eCp=1r%Y3%_2<XQIBvtkAPvE&<*e1$9w;r
zr2}{5#ZaKr$H4xc^I|5^gN|$8zO&x9(R<!>U+dRS!>hG3c`!S>rtdS*=Bq`Sr*m!a
zXj0Ez<MV53gU=_viasB^i@ujO2T~ixXFgu-+&;+>xqbRL+g#V^cP_V|&EOb$d;xql
zuE{m={&C3>TF^`Cx>FtRx1bLC@^g9lyn^52`xW$GJo`xd7nS!h9f<Aca@^C@iH5Rq
z#P4$vBbi*XgGSQ<+Fb?D>g^@3mbpV0plfsL+s2=0EFFKUTW$RCp{oHOrt!7XN&IfS
zzD;^nr%hwCF-BP_7XiP~3;2s%e0^fDj3>jUbA4VW=LT(K|M40el55>RR8wv%+Vy8-
z6Ud6W33`|-{A>l~%%jC}?tR{Xc9-?8In52Jjy_yxcUAR{KH(yl`B!?^9`ls)e;4&0
zGn=P;-q@#n5_-j)vMt%V&l@{K9rF!#Jdl1p=YWs<5#>sthj_G~TvhI~ds_uRDOtgj
z)B5F^b%P^bO@0n}0<Vu7Y$(=IE`MO(PIo-ym1zUM-x0oIAH;<gAKaVA2gKg>vU~C}
zo!u}W<8v)>71zHe*lpsQ=|r-To#dmg!bY$Ia!<sLE~82{w{e%#m|)OH<XG=7*wiKR
zF|ucHy_|A0Wi~aJ>Q=KU`Yrkt)AeM-`^xZ)<i2Gmbxp?7%)eA=dlkH^+i>8;%gWO@
zFV1n@z`stWy485m%)fBHrA~w7Uzd&Ihcf>W?LJ=rE#dJwf19pP%l39kmgeuJXT+=n
zN$2j8&Yiv^J@==6Y<^9;NABrr_y-<qKbQM=@=vSD&h?PCn?)1v$B8uTyh<7rmt8Ky
zwPK8G;3;%q>%<_FJ~sJ;Z>88H`q^o%jctBReg)t0f9shWY_Or9)f{d%Dj$!$m>=3@
zt8S<0Hsy7HD>&fYKjV+Ru3L5PZ+}z%5P!>=w6A`j)&&REhp!8Ky&l&E?!!-nHFh!f
z-yiB$i~Y9+*b&LYWB(Dor;amil)<aM^y@KyJTp8Z-W6kht@~EQsH3tK^TF~1#W=oC
zI6Ou*9~S1?N!H*gKVa>p1Fwbnb0pa1kgn0MwZ`Ii$WHOco_k{cGCNTp8pEowIA^F>
zuCrdZe`>_}EzS_LUT58IG<)2lxbfYJ)%DKa6|wrh+N~>i_4|QW-_Kb6E&9HSc>%r;
zZp_=%=hPI-VS{Up)%SuU&8z#lZZMaeNOh~tC1vv}w7yi<KE>*9CK}4d(QGaqyz}aK
zR-eaYLmsQ|1&5EH>qg^Gb*qiP*<2du!+8B4a;$#zuAC<xn=*%ZtnNNP#_B##kjwFT
zfOX_rVsdg2%n|LHBNTV!xuZ4CFZ7GwqECD-d7^#tW#k6^*-?MahHsj8DF4@$<<B8K
zq30a%*D3bxeM~-+{I7C!m%B6$@NxD&zn<4x?4WX;l;>w){F=QBzvdi@U$YnC*X$Me
zHG2#Bb$%|5e&{z#bjRl^o{%qW4bO)a^YDD5kMHksMzN~)@SL0}vPnEyAm_&S&zRF=
zKGoMp>ffFhB8Thi0Ipfz@GNVlF@w8D>nHNC(90P3rC*&*xA%VXExZ-EoT~Bz;un16
z%p)-jZDumP+fcar(>&#8QeM}Y6!6kFabe8yGB5akMDaN})-~i~dCrNLl6@QIU*<M)
zIi7!Ar#inczT1>?&-XbT_bcFx2l<&J#=!WHwO>1Lcs3E<@Qh$j)|@xMz#H03i8t_^
zeH-&jk`Mb2&Kt(X+#h+<CLM|V*(P1DN!N!m<=vF)p3!^K_ABpzp6$~wdpFR{c?-Tj
zg4|nVd-$>0+8<jUksLK=Y_NUSj=Wp2R?+i88q2WgL%)Ut&xi}S_xu=md1k97*e=g`
zXdK!LnE?)61z%BDbDW1vUt@o(=__&9?ONZ{A7^cd_l+LyBcM~9Ef9^i9+}iNdonx^
zJ*@Gp&|BrT&?ji)eQ%S3V~+?q;G<|~=T{oF4|-2qWJ{luwnr$wh^ODv-Z*$n?yAda
zU3yOaMb%rGas(5!O>)w6IK7N<mYjsf=+DZ1NaYiTukC`xg_3Ev^xeNNqy0xak6k+6
zK(F@+UF^j;4|Cl48FuIAzZMUnWiZhK3}>s9Z{0vU><)dUoIUw<k^|>@SYJ|)eNhh%
z&e<>?V2O=^zb?VUr&&D**i!w1z1RNh8W-)mvSaqHQ0kG7y}#kxde3K;=NVjo@VBl%
z^mUlNQhbap@hqi%Lm=rZXQ+wGGS0xsZ*~bL=1{>KbEw9HgwyjAv}K)})qcay&S4iT
zc-ku8E&Zy~KPP@?=;MJ4+Jj$uM=bg{_uO*WB%2xOcOza{f65b`UIS0|-rayF;ww2p
z#yAR06TWyHROAozm5yI>YpG~Xh&)Jnt*=}SFT73QNz~VP{h6eD*Qz_Co?p?rr%ZP^
zYtxKJYv#?nq#JSUru*bELcAOG6g?!DfUnHYGvvN%oqQ2CkB|MQ;veVYhJ*({rf+d|
zf_EV0SU4Mp574@}?gLl@6IZ#-b5EN$$yLbaX@kw<Q+f9;aO6;#bHJtf=TR@4O?&@5
zOGX(v4e)8+w|2y*+|w3(&`q4=KI`+)FJEFdC;EGZd+H{^`g6v~&&zjyi`WVq@;HlU
zAeQV~c`U6>;S;`@@5U|F<+k6VIFvc0buiDJ@P3Af6CQAm+I>-v#)B_1ekga9!>;Vp
z%Y9vff5O*5i~Bxok$n{OjhrX<%-M{aF(G66f0+Iy1CzaYt+nqa@DmekO|s>jjr-<n
z_3s@4N726{N8$nVQ=%E!;cuaxc%$gQIdkJYTV{jGrJa5@e^+}WzuhWcMBh!{jeJw1
zxf1$_X^Dfl=KTb2ABv+a#=uraggeG*mhU)_=R5p-0(lRQYX=m!`THNHZqwe5^mj_O
zHZA|%nPT`Z{lc3}yy5JI&ui-6WcG2{MJBo)OZ@g{jWj3Q_psUTrrzW(KR~XmL$tCE
zBaUW|oBHjv5B0?ClyhdD@)q9TE5B>;yy92ZimV&Rn?mp8{C9Ql^XE5~&7aVY99ZZ3
zdu)i+=^wl2EU??Xmpw0;<8O3!#`ZDTw}GBhNf&NhukR4yN3OAd*}L^mzR<@1F5yKl
zq7EQ;WKPb@&!+5@+~f1`d=so&F)XoBreFM7mwwr6>d<dhzt}T2>~W#|pPi%Hrn<jU
zPIOefjBBD76{Au2=c?m7K+o$QetJ9l#E0^oFZ=`dz=1!)f#W*~KQbUUcYydW>B_L`
z=^H(xZda(|EDd$O&XP`c+I@l@4zM-Bl3T@w`ahDd)hPoW8G*Yaz;kW~UUNQ&-%P*2
zSX?RE(9fFM;(NfuIC+1x{J-%Ez4Ld5GvCk;W#fwL7{BbJmwNU@*(byI&nj-ge-L|;
zpXHvlGVeu4Z#_RtJ9tWez&KCm<!kAOwbpRzXR~<XwB0S*7z^vS4ai1#MzaR%6@Ra`
ze7NRX`<5i{L%?s-4tvsBi4Dau5PJ=Y1|I`wCCXrO-mM&G7RE_GraPk7$K`$h9~x^T
zKKy~|a=lwxyT~6HAL{(p{KmU`kZDhfL-GBV*U)c_&v}kM`uLf%`gWb#agG~)KpXRo
z??(c^C1ak+zhA~YiSDx}#2S{iPp7zUt$mWaXH4XN^06hGN_y8O8-gFi9loxS{e7!7
z*)`8E6zes&*cu(XFV-nfZQo;)oG<=<(pBbg&X?5n5+0^AB%CiXdFXtJ>1?R`YEjn%
z@1IEfU~A>W>~lHqccu7nExb3nWG~BPKbOnC4?H7}n>;hFW!oNiK@)a~yeziF?$bFD
zVk=^#Vtj<`i+jTL{^xW)OSqo#J++8yB=6^Fiea0L%irCF9HLHbqwSpD`6}AhqQ~|2
z@;BtNp{)xXi650jXBj_UN%Qt<{9s<;+({W<$eGk>kX^v1WinFU7Cti;+A}U}son;<
zGyGugC)U*V|7Y)9z^tsQ|9|F!jKio07z;<#0}MLis7D=j#8F2<9R+PvGEy{DOe{)F
zD>70pnuMq*q=clHR9I9KjzolnLS~AELP|<DGm7Admx|O3<^TQccds*hUd|Z?wO`Ng
z|BHut&U@LHwbxqvyVhR&^7^#IBH%G+RvZ?`s6aorVz+mOr(QpuPnqf*He}l4v0=(i
z)(JMi1F(T##$0jR@b>%Bn5$m4s$T8Jhp?Eo`H}8dzC^j=e>R6^ex=2|duQ<}@o(JP
zVD%3$g0U29a_u}W&i+{}Uy3u=h!YZ*EYkO}u|@d3*fwmIog0A<(I6h+uk@2_NJn1g
z`Z%8rKQ(KNO*YGXJ+O_mcBUJ4gfiOdifkC?B`nf@_!`xRUG5?r<6FSQP@#>wp+n_q
zA8bSudI<mGv2}P>EZ!Nf;%9L=|4Vrb{oHQIt2cx5o2U~Xx{vBC6>rx;oAz-O>3X%U
zZEuSCWAZiKxmxhd(#;Rjv9FJQMEf{bgECoHZE43_TJ0Zk*rC|GY<p{w^1wG}fo~0p
zIc5BEmG!LVHM2dJ{H9i_Oy^gs9NNP*b|D+zY@a~yfOnyu;S-Dt=2uL=M#XrBtQ|c;
z?4G*uch&C9cpy#NMZf4QCOvDTU94O(CvC*5?D93)LZ8k5;3F<eMRjvVjMhuLZxs@+
zWPN^x>S0WcjyoAebvyr>`uf6a$z+!3a`uO@4Cy_;?W`E$#Tu_X4yKaN#u%L6qQ2qk
z#K#=k*1k*~w4XA0PkH!n$jQn=zl~Sf+K+C71=jvhx6y0Hm*9ZyB?xu9DEQ`H)OVt9
z^ul}N(cxYe@MyiKUt`Z=XhQ!~wbRGW^nJC<`8DVq`zhmkY<%T8day})Oq>YX@OR*)
z(+kmJcv2`{*)zim>VZD$(fiDqX2#2obRK@%I6Xf91Rn=`T_E1WeYL-zkyp?}A2b;;
z?!_jG4ma+mZx@KBa?K&xd8>xu+3KTBh9hcE@dVX_ZZVEA-h;c8I~uuo92%)>!=VzL
zsbcX1XtNkXobPe`(D(bMQb*Y5jOMPw0>cH<xeycVY)`OZT^2lD8R#5!5Le)rvshS5
zMSD0KfV2HL_r&=z@+aU0x{GXiPChq=(X|_Md5l3%c~3uL|1W$DpOtHEJ$1PA0n*g5
z#>t2N1`Vv)<UQ+n;xxE#O^T1EpX$2<j27~2Mh-E$t$fnuqO%1$m7f>~`CTl>`JnQn
zM3=M0dOt18d-Tn|-8Lr6d-{%@V?8v>`-u0l^(wzI%lq(rfNVB`?=+YmgxC}6K`M(L
zl*IG^ED;_%-f!`AI6lJ%FMsBJ8S_Fb_7+}+X$k{-D%^1Cu($Da;l6#@Q<skZ)h?al
zOV;*mHaCt{tG&&QKbO8vtx(xuPG|53e(n?4+mgVZ(bf?$d&`+!b%DLLH3#TSbRB)$
z&#uu0yXKpH$UmE04U@*H{^6Qq9;x}|QEJ1IJ%==p)t)BeF8E{kjhrb+In{c`FYzCK
zEmkwq-;;m1WLKs9E?yC>(Z=2l<olRo^!_C6{~4}!+CHo$S_he5uGqSKf9A8vzm@Mj
zs_%kN+`DgEN*A!B3-v8^^ab0`y;~byQ_uo-;6qxP`-IEHHAgF*>UTDnyxfnb9L2>r
z)1Gr;?fT5r_TO9QdqA`mzn))WIQ$M(Id`bs=nVZqZjN=R%B9YNbiVseoEul^>_5uj
zx}WNzoH*U0&yC?Hi)P+0gD&9^<?#)6zK2cx1)JGlY2)vyld%W15eK4tzJCpNFopvo
z!?+6H=f!@7u@$w+;Uqc;FSX{O7~kk>?Qx=B`F`$xblZK|@TBxrd!^t9V~u#b4pAQD
zS4kdllQu|p34J4dndmIn^UQag^}ThTCGDAfE_IbMCx8D<O7erTVHr(&7cXO#JyRKq
zw-r~4hNYCDcI@wbWZ7!P|FB`i_~0`-Ua4QoN3VrLt<*g>s5`88wAJCi6%Xyh?3wB%
zUPHZueZ9gM`Q|&W7h0eJ{VLJ5*(9Dr|HZ-~p2znDWS;pw0k5lm<Wk|w!M<+xawRSI
zmAaRWb$y2Wl<twUz5j{sFOv*R-#;Us422Hk9piQR+W4WQA+C)*%9GBcL&W$i!t~-b
z@9CTHyWP9w<feA_zU;iJ$-<wBE-ieaJp)CDm1A|+={fr)>%#gdLpFo71?j#`+p1Q)
z2wjqm&i@YDp}O1M`?~Xe-PmZ_MjB|KF2?>9lp&dL4uS2t&^&6^Hg~qYRwrd!d*Qk1
z#8A~+>Fd2q^?pfhHhIlb+rAjcOS0RcyvVy$-%SN?;1hUb{xkMicGl^erC}_|+-Ahn
zizUx!d<kC}AMzZT@m%tce0zV--g)xpr3UFd+o;|in(v91#aJL-78p)C_!G*USk`v3
z%OZ36o;#Mg&$q3r0F052P88oemObl#O!oL1PA9B?czrk7??|3AR2KQcANWHb&pR^e
zOYi0A&td<iKZpI7{ya-GSy}nP9-_=Mj~Cb=V%B^o4?o8FrMkAhKT*$yil&bGK4ltS
z@%_BBH799$g-x{nhipUrMo&A=8|fLe(Dy1kDf9hQPo$3#54B#YxSg)#==XU?M3@ul
z+s@_9_jz}uH=NsKdUHSyy>a{!PR85NPRG=ScK05;a<!pd+8lYU4W!+X&VEhp80O`N
z4FQAd)gIHE(>kFyv~OGa3dO4<{lQOiew46P`aN*F=N_w=1N{FL3w|D8!IC|r`G%_!
z+g`>eIsLeaE%=J~Bb;pve-`WeC*bw@p7+>ElR;evGH`j1Y>)rOQ*55~x&Ldnb>U9(
z-@ZM>oE_tvv_Bi0_3+q*B^nDMpDwbe$S|!r9>zHMLX4|y?8voCD<8_%e=hdeZ{sfK
z8+w^W`Y^doAJhlI+$zz)n2J0@b#49w<1Oy-TV9th8PzqYrK56et{q(n_3Fe9^s2Yo
zSWP|B(QNue+z%fr?b9%p7<ByPmfhuFv1ZbJze8tK(T0o<Cz{147h{b3V>@a`oo};z
zwW)@?_ykp=!C|84%t^ye+VNjXcj&W}o2$>l%TS)grI-iWssI-AK+_In&p=Y!h?B)d
z{duFcCWVQ_0u74Z(H}DGNM@apeWvY6wOxD|nch!v#z`Bw9>cZ9Y!)Md-Z9dpv!PSh
z=%D!Ld;<9PZOM)?Xg1lQ2hf9V=h8*3i+3@}k5addPU7|W&Gd<a#3VP~Yv;$v?{m7k
z+;m_<c0F7^xgGtXFRpVq2g1)v>hSz*IINAIOS#U%&oPdsw(~e`Ezw}bWx}=pHR2uZ
zAuhvSs4y-=EQELTO=xg!5e;cw*Lj>_4nscP>>AzID%}+E1b)yruhBJfW`AcN^$Gf9
zFOOdqlcRj%G4$JBdY?{q&|l@ZV$ZSb;Ed{ZaeXidTFK8f<w0YEkHzww^y1}I^lV?P
zk>l)K)(>(<5x8bCZq9mh?UX!O^G!Kpy5F;*fU_#pmsNh#Vz5wW&e86{s)Kf)?%QhP
z(`C(yL)3D{xXMr+r|Y{%X|KnTjg2q}-=<)>&Q<s8_n>L_q~sRRBpxZI&}{>K8Ggb$
z>0a5tqYh#hv;n`JYucu<XDgUv&x!jO&z%pcb|LSKjwl9dGP+hgN3Y1kcm;V=X07gt
zAKIKX_yaz@<#A{_*i?7$D}@a=x7b<zX~h!3wk17=I1IE{Uy+_suAL!UqI={P^~<xH
zhpH{;9`ws^bl*2IyV_Uxv~AA*(Hb)BY8O3QqBX9J7m=}BbECDEW=pB3NO|J1lFTzd
z_K|%qh6ZdgbXSNb)^RZ>2&N%Z`RJ{b&$S@h&28<dT#bK=tu7nKSzY+JRu^Zghjl4F
z;reDs&wQVT`eg>(_>61X%2<PIc$d=eIa-s%I2%5mkr%~*=y&iQ`M;|?A>WlS!}pdL
z-@oARchuHT`L@zeEY3vRxwklz-4j=0oND(e-D}>f48E^qeHQC|)URBuLGcLm1U=37
zaV2<&e^H`m^!0qL=OztvhUohet*ct7HkK%j({H7*_q^kbN2{Ch$`4gHb;au;2I}fn
zyn^(^K!{gRFZRsJv^q6k<jS>J33-W?#M46q<t-uZA`G#zt<A(>X5{6o{I+_oRoNkp
zzK@sDX3EnUdhYC9qvcDUmL19Ml0XhSk{fag<%S$9yxdCs8ZK)C-^77Gv<(_e|Amba
zPrWSVLpVKfaRc!J9a!$yKb;lE4}?{5c^{)T@(f)tc~oV2cBtotjZY5>blT`5Hemb>
z<&jN>#GE>tc4y^G-?p;p+jb4kRV1YE;t_g{eX;px(}i4k4}Y)`*j6oAc5{(-e{#T!
zFg|2*%l8<0r1%qJ25STis|WZpI@9;F>5%%f>-&#s9<5#9SKo1K&$TXwGiIU5WQbku
z3~%8dYssw~)?=~;is#rl*^PGhU?hGjeVH`$ComQJ!1rWadE(;_bQTBel1Ll*A#FY!
zKKygCkL&f<L$=cFW1aWu*vpAOx3H)7Zm3+dkMtMnH>~Cxg4L2;jnW`H>?3s{Z|ozw
zAKFLC8td0sn|)lUIg`*nQl{BQt|=pq5t(O!eS`+=5p<&mC4S8|_7OkM>?7CM$4nU=
z#2m4Ymd^Si*iK#8N2`mq+h!jrANv@mXS`3td$W&Rn|<UO-Z5^RBKv4#z)9XdVn5+M
zvQF!L$oJ-e?=Qsoe!0Kj5f9JtZM8nqHMoz*ZNXLSA$&Hw53WKpxQc$DhoL=8DJ}iq
z>>+9Rt|a=qQ1gP=!&0Sj`YU^A?|FwkL=M)su!qzYuLpbR>W#(ksTcgUGObSf5apUZ
zBro<bo*o)VXZA46107}$!+hAokVeBm+Dv)a!?69>L(1KeoUn(aGda;_yEi|^?hVWA
z-s~ZA<6A0*Wue?i8@Gp{EU|~AF?&c^^L$xm51kB!X>oaD4|#?zm^`qD@n_gWqZ$7P
zdl;t+duaT1^!PcVY%;_ib~Y_#?Tno1%T_jh*{)q&LbQv{GBB<}bNB26U|fccMAz|)
z%|<fzI7InvT(&d$Qa&FzO21sFx!!Obn4hCQ>=Sw^GvLN9T(keAv-Dz{_@)Zuu#0tV
z<>`5*JYBo-AAJrCLq2A+(1TvO$96ofb;#I!XgFE<P2Qo+&pZokeu#tEe6v5;eA0i=
zeuB+Mw?mtcY{3V!)!2Ni13ks&bH5|~p`2_spXZ^?w|j6O9)njrgMZiwYz#Kvl_wrv
zDVv{?%_nUwb!c2{>*hk6&-ggC1G^tzTjR!W;s@UpVC{^z+r%ygUax0^RcBc{yQDpm
z(tCI~x-@s(gMH5A?WVk;uYnGS>uxB=?RnPNi@1fxb8cTQ_OMQTaXRZ`G4wBV%VII`
zk8!1ZL^ns<VQfgTwhDL`%*V@LaPxE><|C$570t!Tb~^pHdyPrT&~57j>Tf$i2lJ9q
zx$(Z#+m}h(;E(&xfMR$&r%$a=%p~k@nZ6=y<~eB^lm=P5zUSjA$U`>P>9(^+9jsqM
z*F={~%lakLJ@%Bcwx2k;UH8qhe#v4jnLX6_l%fr}eqH5K2K%Ayylz{+MEYnycR>qf
zaE(vK^9)XSy5Sq|C(A$NJ^PMr9Ej~^{gQpNMeBl#<L_<#lKYNj_h|i+TjwR8hq@a5
znlIvS$l-e8g_=8IZ4+ym62ZCW(naA%+c(OgZMf3I^V75NT)OARHSSvjl5N!HNp6i2
zdv;kT8m=$m8Q&am&-@xCXnIq)Kzx_{=plX>>zqi>y6Sit;GUJCv%TA4cn{G@nR9|N
z!}3@s8ZU30J&WSJ?aJGcj(#JDjt+J@+#ch=He!Aj|6`uwV_+Tsd>oMd&wOWqZw!=+
z?@PMt+d#3kgp751sf|sd+pQH8-(+7M-m&(RShnm<D>xJ3@1!RDIr20nbK@P~WgxHg
z%#Gi`Rq(*&O{h-_yOJs+?i&QQwHTd4hR_(|N`@BoZ=Tb?S;J1-$YXI+>US6yvk%5Q
z<5RZrV4P287dA`h;&x%Zo`DBr)xHe&B--r4^6t6$G}q_7h`gd5-(6#rR_sDA;e1&T
z=QjVw@V-}4@qh7f6g0_RuxA_oqNDI^fb!ypl_(uJ5c*&tpZTVT!!y-8z<=AgQdoYV
zzm{qV=cDf*Yu#Si0sgw5uJ`xX^3BTn`)ke@FZb8@Y5n}QVoqg!{WU&BAAha&NQ(PK
z<;(9b+s|Li=P%pWU*o6j<FC8uy0^a;u9WTFcHOSO;cufq@H8VA^Vg*_-_O$D4A<j6
zh3O1?&G9M1`60fG8^+qP!|2O-TC<zd_mR)j{eJpI7cIuHL}yEw-G@GCU8uDK$SJLB
z#+Qtht8|U8DF3^xRI)_oCP(VvJ$}ObdXL}0IzaB(k80_`<uK3RC1+?P?(mwfbER{(
zQe}bNN!4Agc5e20IZtSXu89*iXk1i~(0Y35UeA=yc1vpguFV;1e=PQbbbNQxjm6aW
zxu0P7O3R*6(^0;Y==|m7(b#J7pfxUiov(+yHC!ie-^ev*r?_%eP9hPVRYdzZuY<P5
z_oL=2e-m?bY6oSm=h~OQ*2h6<Q)kLYmZ3jUBmP0pQt=EdrTp=fFFUo=_g8FGhJOk8
zHzAsHhkt=BNv0<|-J%S>H)&;rwyrbf<kdvwAmgNu0n2}j`j7V~<VTi4AF(B9Uz*4G
zPIChuZ@_Tw7u&t~!#v-kI(JSu;dG3Aj2}ohMd^%Qv!k7&)wda1S<`CkF?RFx(e{wO
za-+x7*URobeb0-&xQvK*g}l%hq#ZA)i!pGV27F-VETMruLAecmw8sp-$&MaHoHwQq
zJE{xZ%T^b-2fwI`zU!{lKX>1@Z8mg)6Rxi&r5nliYgw=@;ryYzgakfAqws8z{>&Dp
z<TKcrDeNtw9_;khS^R@hdWQdspG1FMs5vHgeu-!VFW9R_pAKW>ai0)7L>a^s=p$T5
zK6{(LLkt)EH5!MDMmyhQsM0SgAJUAE#26Utg9n?0h4p$@rSVp+=y&IRYdp6|>mkj*
zS>@9lq%?+yq#bme*1gED1z)+JuXNmFQ_0WwzF23Gb&ZVh7dbG$vct3*gCRHk7s-5f
zXVT-}kY4)PaeA$laXR70I`~4H=!eSh^`wmYkgxn+_Z;4-T(@S>>6dVrG}MRwhq|Y9
znYdm&EjBq!YjS-=d5|sj3lm(L4tbf3&M2q^>&5?qRG#xa!47OAvf<1EFvamDm7jT!
zO_dCs>^FOybi5AIPzH2%h6c_oh|@qF=smvmWYy*T<74MG_tPJ3{Hk<-^${kstF-2f
zdz1MUiYZik|Bn6r<w@~IwmO$je2I8=l=pQ;>iP(OeSxkI_t)p?`Y?a}DP33l>y)mK
z_Sg7lNBV30vnqcrere4~<cHy(9qO;~&kpg|_-6<EYjCR4U*n%0<gdHv+Wbg#!Td;Y
zFKnmzBq1gc&sriogKY6j!`N+s{DDYTxz`2lP@d{@CJ*{hhv|bp#2O>yYhw$rMSOJn
z#h$j1PGY|31h^l@t-d0EGaLiDYw5``!f*N|xK2N%?d%b>GI>WI+(Y@x^_;rv-Lp1~
zED$~#POcPQHtBCaJ+nQ7;d#AD;X1fGI?EonVc{M(r3o>WeZT0uY@V}&JrY-ewHg~l
z&%tnX+x%JVP5g`i=#<<udl{k2><xB?vgl{TLExXoL2Q3|yv&yZ+hyxsDwEM1lI?k2
zrv0YGoR=jd|AjaJyydJe>S28oF%0H)E0f5f&0h|66aNUlK~q|M=%X^7U#Idl@NQ-A
z>0a`G3uFH8Hp!Si5$;XpdJjGSt7LE2;^oxvTwnI7JHJBZ<3GV0#-6r+{c+YeDh;%x
zMHjrWIOtOGg?-OvGm`<IcTszD?OEpB2jtKzDLDjdxENQ2<u~?kEBmv5IiqEIUbhW1
zyLa0#t4}wbm8Lad!Cq8!1U}6<tlNgO#HZ6$|DZn%Q69xvyNho52sWmjs&|+8ce7&e
zI74Vjb!3lJX0eqi|GIU0AMIE4a;3bPqTz@hbDMeoQt*5h&o#CxNcU+f@P04!A#?P_
z{1C2b#~lYN{*ao~;_CJMKqs7>BtNmZtVDI77mVKymrnKDb8hpr__HHbXXM9ct&99_
z%upT0K&3CmR)^6C|BODa=ZL;gCY*20_|*D*e7`t-bA8a~O)kV$HQsmgl5X6U=-Y%2
z@ZAH(KwK~IJUooGAn8Pt`4HLoMm;vpwf+;fP5bFHZPOgGTR-65`#Eaii|c3ZnV$ne
z-qZ!H#sjXS81VKu!}>Vp{j>2RKh4>8kzYH~+Zgj3(J9J3L;Ro}gQdsB_-L<eXfeES
zG0ODQ@<;p`dBSFuc^J4rdnp57QEhWPjqHtLGResHZ;=etuif~rP~*EqdbzVn^mUg{
zb)XMmzSf2hG|Yjn13X=gDkDzUT;%m3=;Az)4@y^OWKt~5U=4LQ{Z;7CWMg};C0{pw
zC{p`}d3}TL!re0VU)PF0c*`DF`UdYbPAcYIg`<7$i}~q?H!6KA&q{rIp2h9ZZ0Uw!
zW7aWGA{xIC2MqlbY*L}Hkn?mG>#Q;S2W$s2vU4Pf(HNdVZ`en3)ro95#}56mu@mcK
z!n*03w3$8=($Q6Q#A#riF21DEAz#hSKO5}@oygN!+MWL|K7_P)#J6m9!?Tdy4^nr?
z6RQJ%DU?eu>4fnlUI%_jcrHmcy+GcyGptK}-|_#$)YVJ&+0N6!KVuGtv+S6!LAGEK
z?I@C7f+J0;)9Xf7{lXVYDPC8eWF4*SmDVQG-p2G3&G?;J@wuvP{*AQw6^spgYd*`)
z9!;r!#wlPi^{3QV2m8JX9#*JqVwd0;F;0hl8n00Xd5IYr-P!yW?3cw>tJDT!tN3%o
zS6NSDZ7^T0H0UGvo#m=$@$%=Jm)1Vt+;G_Qj(3r)BL9vUdiXsQ{3`rf^R?5S{-nwx
z1`ppEZ&I$U`!o9K*R~!Tx~*?#<2_@C(3fWJi1ssvur~EF+M7b!?{ad7cSgIN@e1$j
z0@{uD=qJ1fliXOjlf1__&*eYZ`MKD?SsDw&FR%z7f;0QTue;P1_?1<+ysuR!yk<>E
zv~S{(%or)W&rj;CGU@$QsW)B*6N&e!9qu=ge%P%q<_sC+TA(@25{)|(>8Pwi-FNf%
z=q!3jx-NQN9HiSNNXPrGv2u!ZAJVjI?7ld5-z|1u61(3mcE5Y<evjb(RPmAZ#I%vN
zMf_^xRkrpqw;Q$(zF0b^|GE$P1V6&|!H@91>kec<ng2;1(Pz-PT>hW>Xr@1c<MzGv
zWjd#;L0H(JxpBsY%wsNBA0mci>j|XO130IQF}&QA)@6!EkPiRK;e;@Rd*(Q89O?JB
zJjeVm`G`G{W~}8AHd4M}<Ff8indaxPrVM(P=`23OO#Ajs+?LX>sl&yagh4juvppev
z_ltha7|<}u=7Ra=d^R2omLDAFL6x3S&nW>9!q__Pv)DRgY2yLoF!EI^U+Hq@G9vqE
z-^<Ah{1VC0*;Cr&@x=N5<gXxq@Z4n5*YkGH4tRULe{Z~n-ckOUTWcYIow*=vl5Duf
zHF@p~?grW3k5Uf%3s>W^u$V_C#;$f6ZY~i``Ti^(upHjl+#vj5ZI&CSC0S1$oiXFm
zus%b2M!cQ#RNUG;`3!t}5PQvh82&?N{H#stGflF+FC`T>mhEj)J-z*2G{gO*aDTJt
z`-bE(RO9wll68~He<=wrw~gt^Yvbsp#FPCv+KqMe&W-cDedsOwuu9KZPl8-FNoL;O
zIz6FpkUr1PQJt&wn@Atv7xy9Fav$O?_aWY%Ec&T)z3imb8`k-(Fc><pG2|tt_l&nC
z+=IP;4DP|+^}#(h>G|Lu?0qh{2Yde%++&N@1@|G&QeS9`xDRa+_n|G~{=@L5NcqEl
ziM$!>@to_;`VGf7#31se?}j_?1bVdS5UrIup1)}9hVPI_%zbgQ^lXjFL{EnGYyTaw
zx}MT8>EIK3zvz(jU0(KeHc1|7oA-_4D$kYc9-5Xb?QrSix=!dL-;fLS5!%3E^lY)#
z+8Rz!cN{11(OtTJYn-3XH!Hvn_spLIpjd`mE4f%{7O8BTds?gV*NN6$MC-bw&ZSiO
z<XfbC?z|4oRq}qZo;S!BAQm9L4}d=E!2U6R0S=s_nB!#OS7D-U-WXq#y$9m)?2;Z4
z53lh&w!Y}{Cfny_{7>GHC!|}WI#}b@F1D#yI^URRXy*G8cd36c4vzfQ68(ZVcE(ls
zZGt%FO9`Sgt*}9Ar^fH@euTf*{9;+ob|$0qwKDVtJRoKX9)U$+e+Jv(De`hQ*T)hx
z_u$qXafSmr-;;WkpRyD2wu3?PkuvYXdXtk~Jjbn<Q{C`{Ie{X5y9gQEnmUKmdS2+C
zqazmEmD~n!jjVO;)*YgcCVO-bo)9xa4@e8m*KFJ7VkPvM&3d1$Z{i;?pKANst*?Gj
zaoo9z<IYnY7hNB(c~5lefz*WNtGQ0;Iyp&tdYAN0XVuyJ^mJFZ=qyVl=f1c=`AamX
zI#=<@+Vb}Oxk~p76eBLw``(s6HNCl%>!iw0-==;xscEj_rzLvk{4L+V6F%=heE&X0
zapJjoT9@BFlCh2J=c!)!GE4M+)~BI8_8z*d55)UFYgAmD)uwDXfG%<NdWKe=r$gMY
zGg!dfs>24!ITh4nm{2OZdMU1}d9v1CYSUKP*NFeqx5Ea~HSr#vrEYWj?EB7u$9Rsc
zG)6Oh=`2>v5mq3-IiextQ)jV)_Bs1}L=;QFo|CsuzQcC-k&Mn|=8O*aPP&#^_hQ(h
zehRM8S6uwV;|kwd;#_s`#pG(ZqWw&6J;GYWZnvw`%FTjVl)1B*H7<r(V|D_ws*Jv{
z-NF@g`om(@I%1zWFl(v33+w$4V%BhvS?JvY^??wxE);N&(4YAghFzQWY>fWm7}i;T
z;|=Ku{>I9fzp=PyWGfZ$-_GA~-#u5K^7A;)%~T)8-&n7-|MfT8{EhL#5bVz#p2vo@
z9~46rgLD{@vGKyZ%=*F(`g3P|5W|X0*<qjfkY$_iywm<o(7uNM`Zw+Tn+rdLf3r?w
zk<}V&td(xA)0lR(`u{3nVffu*VnOTGrw^3w+L(5=Y|PqZdmn?mrq}T??JB*qapbyG
zTddsdlj()l(l|f2UUg!-wT8g?2V+?C>Bi5*k7jJ3eqz6In?O0xx?aB_W*Sx&>&zna
z?K+E#zw&){OKhya$@l38^gccgTP=Sh^wU=A9$cKSwEtIdF^q9^7UxKp!JVMbbI#UB
zF|IQGs`frfF8yMRluf_>e;y~@z7sg|LHZH<{Ll%;J0ZSQlt#9(K=0%IC>a~?6zZOS
z^v?gGe&qU&#@ijmGd6oHTIjLLaJaMm&c-OV=hnt$ZrtM6o3P&^lg>Y@^6`O%-Pbe|
ze;OU&o_rJ+qxg69=SsD+9aemVKFW6f&%Y6eYW|Bu+r?{6+6f$Dt^NnWqTM_e)x@wU
z?Xjp!7A)!&!y;laV9~q(#Ud9Uwb<$wk426D!&r1w42#AFSj5`;c6hOqeL9S-;1^_z
z-F{F^>P(E~gJM!=%8vWq|HY*3W5~51F(xrr!8~TRd7qbkznL40!_4$?m>2Xu?k9~`
z+$9`ujP-FC=8*ocj5j*tCk^-5bn^$qCYw{x`2=oW#Q8^ljqd;Un9P62Mp{RkV-D%E
zo#_7`#2;z$`Zy)l=g0d#zb;Fkci+1WVz0w}pMUbdeZHMPQtSKtjUTYje;B`^GjqMx
z@8<k>EU?{J;G61qj5(Qq=M1ybU<{h)ahJUlnQ>|CyqaZvFEcT>IZt!2ni_ePJ;bE7
z=giIWoVD?tnI8`OcGo|*%?;1j{OtnGKQcc!Kh}rm6x_3+L37CT@e%1EEvM#~qn)F7
zm-%<|HP;!%JEM8}r8*mb=`qoo2hAxL4;3ynXl{r#Aj}Kbs_#4duNWzFz3lVhc}4Ji
zKF?$Od^E3GHc#nz$GJ!LeI(|sSs%ro5UsIr>v6db=RX}i!MY{tTk3soJEMpBVtk#<
zTyQX7Z)+9r+(B$(r1~#yolaXtr^Pl{J9uX&)@qQh!sb(R`2EbWg>$O5Hmo!K*XA-F
z^ZnP>YAp5ltkrO|W^1SBGI%#-C+0m#Kg!bo8`@)dRJa2?Vor8vVx$^_xqfPEJ>WTO
zK<GF0Nn0E8Vb_4bAJ#gcU*@lk!hY*{gX(HP*M$kTM%3m8SpUHqQRY)e2lJ?#bWOjv
zHTYL*O~`!pXXa)b)bATrCOXdg`1$GstWlsZ+M2*O^Y7WPSm_^>{*F=~KTUmnzIeBw
zd;2~<Pwy`G?;2w78uvfHxp81y|DUTqu~_xb^?j3b7U;v)H(XlZH`xOKT{a$e=R#-=
z0sR@e*{i}DO4ibFUKh`7Ev@y<k|4eouA}PZ>9|&Og!Quy*ZQXAjjyA!J+b)E`F@Wd
zKD0YK!ml-=oTXmZ+nu4JbrQUrXYT^~SmVSQC*j->vN=FBl4q>tiS?Z&TDP@WYaklM
z$81<Ynenkd<@L7mLK-w*;mSL)bLADLBb;ZifUPY|CM6Te7`i#Di}nAk&q8jjg(n?-
z3fWnof_C~8I?3~Feagw2wRe=K^Eia{1Gq-^x_0Y}LtQ{WXeWINy|B8qciWw9w^(&8
zR=xBo+xrprDf$zAh(2X=Z`sz;&WhPh)*abe0%FUVvvFkOUJ^a58%M6;_!gdpb~BuV
zimz*0r!uUMVkfEVVYQ!h)Yq%0<{*6^LU$YGgZMp>&NiaI*v5SI7q00ytSMrS51)~;
z`$;}l-ec-3VR_LvAaq6^^@(o2?@%Qk7iujyv3{G+r@z&+mR#*dKalT-X?Mm~>frq2
zqdivJ8P2TxgI_j>Yip3>{LM>W(n1>({A!O-iTIH%-w5$2+jFDM&RjlQbg;h$ou$0t
zskSw&;rg{W9meNe_1CC==LfQ$RdUkYcGmVurtQ|^v$qm?F^BEeQ7RTFwSF~Te`om+
zFCYA)d|P81uSd2yE8pVf<f0S3q#vWFuKilqiC*!X`SyC9r+^;Q7dE?R+uKQOWMA3J
z)%_Ehy%bGaN3c%o2-YXPyoHJ39A84dM3c(o9AMhC#qT+w?)9pNzFaTau3j$rCPa()
zYHQfg6SHd#;!P-9Xr(V`T+qt;1Jh5|^COoyUxaUNF9o!S*R88X3w&ts=Qys`bNU!O
zqFm}@Epmt7Uh(}B{{7kWkMhxpY<>p(GaTfcy>LHYmGV_6pY3}<f7y?>K={NN5a0~=
zbGY|syg2Mv-+<mqy-QPXD*7gYdndZo?%89Mr&?*&s@>EvGQit%@dZA(vz?c_y&rD>
zrp{_>VT~dC{1_|6_DQts8`ZHg@S(AzJ5z>ios$oA{z!C&G$HGqEl;@Bu3aC5Ces;c
zy1~=r^hI({iD!KC-t{N($oA}d-E;e~4)%HY?lCw<8_+TM3O%;IGQL0Abl3T_!YHka
zcYB<XF*X3*s!B@Ux~INg`X#N&en<7;%Vd*h=s#!rhT7`NmM%Tvbv#>}!}K9<kRATG
z?4jEO_EFGDT{~)Hhdfmuho+EbYvUi)#_)OA7BD81Gvf+$qZ-~zCN{3%EHTCu^Md|f
ztNtGDL9SFj$`1Q`N^)#s{gdzS+^^<7OMmC=B>J++JnZl6%}cBNKH@q2M_vy9wU?$d
zyvwB@wAXx8uBn6d+2}U(pqrHm(Iou>tI$nL=ddXYkK*SZkiI&$4vjW|hZ<kIy*9o5
zd!ErAcppF0fcas=+Qs61gKSh|QvRyex-C^c$~51tL3<$SkBj`iaK==PDtCd>E!Hpi
zx>Uc^*PwPa`0pOUi_6tFDT_Vje2bcIqEKD~zsbEf^p|g!^=vea6W|*>gN_9%mwRl<
z>Fl}eWPZMb80Kf30NpOX$}HMb`jf?%oguod4s2Xy4*wILEJ&!$o}P|;)uen?>V_YS
zl~3`H*2T(~m(U(&{r*sKknPr>Ys|*p5#G5q+TmDA>#$vZ(MEY(FVbG_ywpi8j9)hD
z?81vY&#~Lc0QtE2dYujAzr)r19i1DZ^S@kQAPsvsKd79@M_nIQ#(j~oXvH=YGr;fb
zjJ}w>$!mMQ_}0|U<TYJ0U7-&<UIjdK=X?e{<lCd@fFB3VM#l6L8wYXSApJEwYml76
zeVf)tzU}MEstf89^#4Wr_A6%xfzi;FNgL{hPrFopY`*$Gm;>IZAIqnW<qOCA(zoaw
zt%8<?(go^U;=eW9OV`9n8}*!e`5q(qlE0k&N*YrK-=yuCKi8cpPW<>|;u~W(blb*m
z?u@9^gr-Kyk&l*0PjhW!OviTvB>(Ns`jPLRd6wtbSuxJ1Zu?#db_yEl5AA47PHt*<
zFI-6^B7VAW6Qmf=M0;oXUKo7||Ajp!d{Z3Ru}=cu9T^*a_2QTMTJ%i|<q6Lm#Xmx>
z^ac7l7|ONc@(!oT%i0jm#^ZeT`y?B9pQ{XX$;v?2*pCc8QYLMitTrS?C;NGM-;jR9
zJ-5EkIS-5U91Oiw`U-8KU4C5S7RD}o7r|^pFWCmp8sVG~aCAvhb!ksrW)GjR4||wY
ze*>S<F@9N>%DFr2Ax8J?UA#`SZ{?~d+~<sLla{pr{Bphl{vzj}xpPDHOH899`++>+
z4`pyJ0{66CIx_&;I+Gtf3G;&q@ByEaGT<@a>T+%N=Vx**sn*XrTH!sk!yh}7jW&SK
z@)rm8k}pDfe4V(RMh?5nPYQVyKck&KX_x|?w9#S{@(0TBJ1Cp82(`b;VLWyko-zl)
zxS3cmep^Spbp2esBroY{m)j31UErJ>_^R*04lMEY;dc=mOXxdbCiBn-u{PORgYEQ7
z<%1g?*;2;G=z358ZK563Q|bLn&bO&l8y5B$;>IY(yM-}44*96~bOv{99cYL}_Pw=<
z9*b=MeTC=)i_jN*)sg=DThMOr=<`Xvr#`Tc@A-B0<#2D`nX>oH^&RHvv3k%w_&}NH
zEBFqc#Bl^&QGakT4s>E|@Lf*UwYoeiU*oCS(7RaQ=fc+pSA1SqHuYsI8=atT-ruJ_
zPZ?wUH@-M;o-)vjO8p|QGo*XgE-?Qz-!8*)%7K6A9O>*iy4X|CC#y_r^JMYS+RZgQ
z4rwM&M>L1!TfN98SKS3VbHTO8^P90J_w+N)^MJ09rjF{4^SxI7b2h$*b&w~OjQU6}
z-_*s*bY>;AL^fUfPjwG=H>6fHAF8#SwA;-y1ToLdGjC&e$%|~PThnu7v{&<*4s@OT
zozdl#WL|GFm#)KaN2g?m48RoG#;KG?{3U$PGxWcQkN;MXUb3i=uAp~Yyx$o1HToIl
zhO%Ie+|ldL!?1D+x<~p;e97jI9o|Uq6vNbfaCH9aZjv?iO%KvhM$aBz|AXgYe(0p$
zc)P6K>Vs1$hyF@hWY0bNHC=Uv_tRqiXo~SvF<jbj`kYIb!+vBwUD!{r_T?MiKu3sc
zQ~bPMoY%C^^gwcq`0Oz)#5nXowkq@9zR4Ds6)`JUW+<!V#ZB;^^F@$T_nr~ow<xZf
zRc;#N8~z;cWw$m+OWRC#eB*k%GE$dh@avEm-v@jMz8hBjPvX=^fg$^f2Vpt6=4mpz
zAv<OK5A%Ic49n(Q5J$#$s*x|dK8SPR%f@}oBE@m-3`Kl87ccaBTZCREge%D?#>YFW
z&th5sTl{3spa)B~8;ALE;*R{}9p(SO<R^E;3;Hj-1Z)2%{p4ydTX4k2*kCXHZfE>t
z#$g?eG2-V<(I3ozwQ<L79tU^iSA5p+Ty%EE?>$oG;$s!|kH+DQoz=ag?+55wws<yu
znD03lZsX^&=8NZR^&GznKcXNtF*81qEpoB<hIl?<m5pI2C-fT_+cOrY?TpKf5AKXt
z(ZYMKi4Ex5tp}k0ksf)3epr$B!;lw#aA96F-Y|dHwLyLdI)#3Pd7Zsb9{KN6v5l68
z=Zp!+Tadaq)7IBStILyW|9$j$x)<Sz^4i)1i&M}h;vb5MIbO5&!0}Xi7M0O9?o+#4
z!||uf8+?-moA2TXiVfk9KC1NGbLJcOkLaE@?MRQl6Vs!e^)(KZe4xEE@-=#F9$s-B
z=aa<!IL8b5uZjaia*=F9|JA*hzslGjeK6fXPb&g{igfr|q|@31#}Ct!BSd#7b4zP}
zUg)ojj)+e06SmV2PY2J?PtF;2Iugk_qQ8TD^q-tM6_njs{&J=gI<|Kfxv&m^HZS(E
zMr$+tLBEJ&>}XD!{NdQa^S_C<hx!`tr}#Qy9UWn=qbtCVFkd<cR@-=uyxGQU=6i&3
z6#N`~9L{sJm<ng%GMCma)*-zb4ZbO6jo(H5N&R!+a6L<_-Mb5es5e(Uq(bi)U&Ff{
z^~ZBQWPjuvB47{t!W@#uLhhda0}bw7)nqqsr@3{9Q{lUO|4wm|cKzkxSbw1$`j%lb
zI;Z~JPT$c1aFnzbTj3dW3BMvbeSLd+TC9Gx!<})P7sJ|kS=fkpSzssWtSsZZ;g05O
zTtBe!mHJ@jJ{~h-d?oDYR18b?7U#>Zu`b!-&0JHzTLU4S=bUMG?wqcpw(vdH6)(aQ
z@!ZjoJ8cx7B41urB;PK|!#!nW<a<OU--riMI@S}%)8+eg8XLAkqhX`Q^-eb1%2z0c
z9MRrS^AE0H375sMf!jULv?rpG_l8Bnopw4&yv)6i&5dN}_d3DcQAg=azVvOwZS$k>
zZRnE?e%=8atnxB(I`PfL>1O#karyvdFxOz^G1tH~@pNc$F}YyQ+<aB$O^9ibj##M8
z_y0}v{n#Y%op~DC7sjC|8~jM~KGA-j8Eh(7{2FW;+P@8-><oX-SBE$Dot$`n%|c}6
zA@+aajF$TRZX3o4uZX8|#vJ{&zK3Fr+N%s5?(Ba3GAAqfv@Ys#eslfddvB=Md$p~J
zc@fSnF4Wna%!ANg(sI3@c&oO~CcR-G@$^cqyRz?w*XN7YWc#%~PPQGaUvX!s#_|x?
z=%Mi#vVv}CDDm_%e+#ek6Kgik(K@6;)t{H1=4ogB;P$kiAlly$?Khn;MBlH}cWfnx
zQ9U`=t!=FreX~%ylT>{Tst@0lIZ5@Y)-Yc>OFrpMahN8VB@Jb#Vr2`{obFK{?W8_i
z!+e3#^Q=+thACa6WH4F!i%bfH$#b<YAv~ip!8td*nR`?^z3;Ac<4Gg_6u=+J*QKeJ
zZ=dYr<`qfTL+OTPD~mb*AYD(TtISrOzWrizQRu$OOLIsO&9V({PECDdv)1;-Y3{3U
zd4gG-PtNyD*-O&LKkHXIx4BR1eD{sS{KIB!<U2Fe5!X$={qv&a%RCch5f>FU7sq)D
zHozZv2wxj?-A_DVyufp8{yfdmm<&$vGC=>p3D*v#pK+*osyIFO@R0Zi@^^hmy2X9c
z>sCl>SRc=+?-f7KNFB_H@tk?oc4vd~T@$qtJ0F%uU!Y9d`=-hX?=^4b)_`!{I~c(C
zsp$Xo-~Ki9Ev-R#<ou{DqB&nQvp3z%fs2kf@34D(n_$@Cemu8)?u)}7>85-5-L`hg
zVbTO87M}5al6CKG+g2(kq__Uc^~b-(dbX!<&tgM8gk34^b4Yd98FCfvu?l&ERrswb
ztrefI_m0m2Rv~j_N?NYb2e67Z@NAEK;kxn~Zh_a~+5#}j`~-BQPIc5(M>1Hb@1xY}
zzBaf=w=ECjQSy{3O)5xJqWjX|USqCI9^$tfHHK|E;GPXzH0On^sb`(;HwE{nN~cbd
zuGt*1kFPbO3(qP)?E~wN^YQ}k@#&b$O{z`Uqd6)wu1m%0Utt=32eswuEa`StI?ll_
zNH;Z;$Jz}2*xpjrQIjPf@4-agJGo>@v#ZkJBNVHD?@Arg;V!y|Zt~C;u92m_%{AMu
zm1ZjCrj&-ZbImuwmMM*0&(4c{RFkQ2w%BM#UQc@3yQz%vn&XS}2R$6E=kyoKELOT<
zInoUd((S5rl{wO-f^<bnSC}K+R>f|t-mXfwUiaDPTNk9;Md=!Iq~p1j#~6BAmUIpS
z`7VU|vFR8*7$3`9pC#`e8iU01)dl$qRA;X&`Eu2njOAS~-z47tY;}^(+F7VN=Vi&4
zt4`8}c}Hi-o2|~VLB1}kGo2-0t~#q@dAH!pv|DGiW<$0*3xj-M_|h!-a@Dy?X|0{)
zoscDOwmOM%k?(sk47=O+qv|Z>pg-k7eXdXENS6rGp`)AdGh)1;y!Co+^rKhHbEI1w
zq(c{G<w!R(NQeB!=19kLtCzmU`McTZ8ycje@1}C3V^67-2Nt}8UzDZ2g+V&7Wp$2p
zO?qzSfmQQ!q+>svr33pW<VZIwNQa&b&ynuxAl+_Cm(G!{K1jz})}kEgDuZ-;C|y$)
zKL|Y_KkYC~CpPZ<YrSJEc%tkg?}@uv8gQQ&0{N#Y%}G8D_w~BR?<Ws7wOsqsu-Bnq
zk<va$`$h?K2IgmOdT-m*2}ymUL;LN@4{PrW*|*u)!<J5~K>c2NX(Dmnd5Oe>59+*K
zIaPb@l}K>@Zl!#sgY|ca{tne&T7QS>?{NJcp}#8q9jU*g^mnxWs`Yn_{s!vrSp6}U
zER|1XdrgOEuW5yRs!GvCoAA-$N2S`~#;)>T?He`W*p_Q-?iSh83bn^<C_c_A+3{8K
zPuQ2aFg>AprS4a9@BJ6nPgx%Gi)Ja!ydckX-Omd0;8$B7?>Cf<Qkro=o)Nkq6XX%w
zT3IWUmYg0}T&~CQ+8ZxFsX}{W@x9H4;U_KkeiDA5`APT<_(}MI*mwM-Qq^JmO>L~S
zyL_H74Sv#Q+3j}wN#&dGrgXb|KZ!hHd+?Lcl}7T3Z>*QJ^36{&J)54TZ1a<Lm!Gs-
z;3q*hm})+d`AIzIx{LfI%EeDIzu5dFo^$;*`AJ4AeF#6v?vdXrPdiw#MRqw(Kf1(t
zyHa|>8f?l1e;&({mTygwF5jmE&*pZJuE3`QAIEi&uF$6gZ}Cs!G+Mn~d^+&EqJwn1
z)JE;V4kbtz!{uzYHIZKF+SWD5yHa*KPD|XjTD~HmuRwK9Bi~NcxoeP@I8JBlEcW@Z
zkG*!X&Tc{8^|IZat+T}E!`99t-%hl1w;=E6ov3qnpAS2h-pM-m2=a1<Z)e(hZw$}A
zYyF@6vG!)`KlJG-S?V%9w*G^Dj_e?v^&fPqx`TAqf6#+u2kET;AiGVnzj0m|eY+&1
z{zE@o-a)#qJ{|oQe<N3UMLr!k!2bJO>2~$$z?HfV(iQu3;8d!EblrS9u<srD2f6Ak
z@#)a7)g7eU&8Ndpn%_aX-F-UzqzN6Q+ry{BPa2*h9kJN7>_77qX~k}^muc^#*nWF_
z4}6o?bND9s6mROC&7JWbWcd@#rAgLr===xSQ2YzldGpJ+#aT1Wx39;FE@GD0*M?Nv
z_gL`5$VVFT$yT}a=)QfM92@qUd=S!bEt@~PTy4OX(H`nDyT<r4obw~b)LnEN&BW7{
zzPXERa~IiAE6-hP{A$m!welmU@|-zHVrRslMQ<z5jt-u=cz>+kus-$#bS8dpd9r<9
z8a=VS(D01)_%rp4wi7RMeuHRs{FLowUBHsQE1FqfYjRm~cqA8M^~4u>&Uf<I6Nqo@
z_MBvV!AUO0gB(at+DfIhwIVLP;xv-WRA`9vowFN8>F+}QS!}OJyoVPh$!Ki`bBK!N
zySbsEYD<24#zy=!+F;)#X1+uIW@}pSiNkX*xwH}o!?%O4)E~}^*m|>>)Xl%TgI_6Z
zxVgo?)$Za-s)spq@}g(VM~+eZ63H3vTXyWZ>5UF*&3>L_8~BnhE>?Q{&c)J4_{05T
zrK4XFyL!j#YN*4s^<_ObUKx#$w@nQ;+1q>%{3Q>(ux~KaM(WMh=D5yVdA3H0?-Qo9
zo}aTfm?tBq1}*4xr7N>--io;aeaqf`8wPo(PPg_1dNgiuXK5w1Ppm-qniH9g{+IfD
z&Hc@G>r(Viec7e$<=?5VI$fb`WI&vM7yMYo`RR8&BhF9%Vr?z!iDcU}HkqL`eVU+|
zy5K8xmq;gV?(O%Ad6Pe`hsFon(_r82tyKOBr3W|Q1HSW7;)5FlsBU;<byJsHdlTaY
z?IS&NjT&;f7-tt<_X+qVU3F=8(Q~!m=^N!yC+%S_mUhs8;RAh*YxsZ;Y$K*7dMb5o
z^w``7yy&O78On1yExuT+6xnQ&zO@@0s2+HVj;<8HT%9>^D~>^o8OLjlFS4-MIkZBf
zTjSu@9~`K*LyKq?&aT<;rk*oyVr&pT$Ny!H#-11W^d(*o@IlDmP50~p0)HbMi^{=Q
z;Ju~C$FTI&gKxq;v1)it{2D$-Yp5o>^KeLK<;3Z<=W#m2I?+R`GaHT82BXp1NSi`l
z<f0L}<N6F<m`<CF7IxPjV|{;>GkwNsJ=Bh5RELZl@3l|X%Y|<*S`5I^mQ);BYZvIF
zoYfQmRxs-t++Hp5F#J|9dBbl7!*A11zRzgi(j{H^tzhoMZv}H7exH&1@cWG1hu>%9
zKKwo-_u=;$xevcx$$j|kO76pNSDvbVX>H{Dz7fA7-Gf*54dAeSe6KQWU-+$H%7-uZ
ztzhoqN67Q=Tfw}?FYZVNr1?+sXh-_Vel?|O#@@4M&G}Y}U9h(=zt4<~;1_$FBHp&Q
z;c<IrHhiSYtdkEhRAtty%*V86D%5xIuaRe3tKH!DWP$N>{j)hdlfMJ+?93Cee~O-?
zr}z}mY}jV@51bpO_qQv?M7z_v=C@kEUzM&5ReqcMuGO>4^(?JC)r#X}{9dhV<Xh|Z
z{c~GaSE2N*ov%p3kG6FPxoEgjG}NkW^bj5{bmvpL?>jns+gli2sWR~uc)vvTau2;V
z`qk8H>pbn7;tUbaBb%dr{Y|P@=ZCrTZZh8!uJrfRRXMrkOuYv$oUf^QWAN`J<x8Yi
zM9-8aKQ*bPTIs=yOj<qH9C-^g+jH8>JTCm^e1{snV;&v3a2^MBIQsM(o^e7x=BMG4
zo$cddmZAs#Qx0^|&Ki|lseA0*BeHkMgLlZz@lV&tD#OFn+-9DW{#N<5w1f1>m^2OW
zS!sAqnu$tddIZn5C56{|Pn(8n%?<RBZ@A=v-$nfuim!as`oKD6lkI7`#>VHB$ls`$
z+mE%Li?#09WZj_kD99RL+WF6-oAXUr>%_g|pVzAq_+4tJThFEUDV2+icK3R~JvxZ2
zSTD4P)(atXo`Z$<{4>FGFwvgx>z{v=x?pQk*?SDn@i83T8h6I^1KEraPB`6DI~yd=
zS>As7eqT0C_w@Uj;_G<cDZP`q-%q!*eRq<V6?(@xR=r()Q9ms0(Ox#xv!lLHn~X5S
z`a-SpK)YMhC)t+h{W!@R*@k=`>eF?RPl`NPV}-9#r}VWxJ^hmMK4`xrFa3wM(iS`K
z$dxI6|62U6z^BZ?Q(_j3W1$`Wrkwr7vrUZCJa#oD+w<(h()>Yr-cdWB1}7v7@I7n~
zdNmCGitpigkTZY6e`<e1|1<x(24m`a*~4nt!<wWpP4=(?I~ViOOL+#5^~?SPY-GYe
z+sgh~KmIp+h#iFAU<bcu>(KSji~p;X2b*c{v_8$PhhD50c{^;=IwsafVmr;&VT;qc
z2REvD9@sAKv0e02Y!~;~F7Bxd8;0!~=4}^eC=HF-F8ExURQcX^A<xiux%-&yvNYJP
z3Z>83D4!SG1<m%H*aPtw^pdenrQXp;Xea%Z^3YH4CA3}Si`y<YJ`+9glXB1_+R3_6
z?3&rGlz)dzpoMhECBsA69iEf^F8Y;EgUm={wu|SaxmjtT7n#Ge&~|N=y?`F_VY`f{
zX4~9z-)F&nvj>(Q*}{X+CfGadg1s}lVDGRE_Reer?dFWRf45%kC%xj#T_-p3gYVC@
zvy+m?hmo`K8XmefDy~643}p@<ut%;Q$>=%B=xRsP42S9J6J>lGYq0W76TQQEr}VCD
zZ;$9-=o!9Mh&AX6_NJFBFZ#Z3vPb(iQqGR_H?49*-z%*=W^d4wYP~mm6ZR7@pLAW+
z2HJ1-rbg*g9^>gtl=ngV5_zp(&=#{du1s%l%DuhG#<RG+foIs8m%P0JZ`Q}`&4;D=
zgYvwic4BX`=>U2&82)x(Z#uFyY1ta~%FK~(8`>D`#T1@N7q8bZHU|7)-8s+3@+`}_
zb6_9+4Sfi45<Vjf^vwL!bfGXQDNOOWo>G}^d?cOWj4ooMB`RlOpEb_jG-^*A_l^F3
zk-z6#@Q&yHzQMm=V)uT(JZTg^h|2VN8v6J${ry7Sv+p_YaN>uGQ|p?u4SI2{{Jn&o
z+l14^=xi)tIvHVmwAL0oqISBm1^Iegz3S881!>uP!`futFH~IL{mOQlpUOS`-MteX
z`LdS{iudyzI<`J?&xWn}l0$6lBp$mo<*L)QMfoZ`{S`@%Eq>fXS=bSG)>CStvv-x`
z)ALHz0k*sA;2ALvdq!+(v}maGvZdWtf7;iNov-q|<hnYzt_iMdb&Y%%nY_y**(^4B
z>z;EC3Ozp7seIB``1_&$ev#j+2aWZfhP=bHo>}Gdopa7R$k#arydTbcem|gGNBHuc
zP4jI*PK`%B;&jz?!|Ac~FyeC*i>A-wJ2;+6SHOAFbv6(B<#omF3j#kVqnFAsy;`(?
zq*uri8%|qCi{`c9pXb{c&x4UlbKMCVGpL;Vvgo&yjkigr!(khs$NB{4glE!doW>q7
z^7A}j?GEN%GJRyM=OsFFwRp*IE?hh5oI%4@X`yz`e|~<5b2X!}a$AfWY@4q>4c1Tx
zz8UjTm7;H^`6X`7ESmS^IlMI=?rP=5-(n3q=kv9boA^e%kwM5C)zgfh2M?TlbEFGp
z8v2JtqKkVl5g8Jn#}9;l^QCw5adF1Ttfl0gr8i&kF?<E_xk6>o9_=Y_b>m~{LX`ey
z+3V<RU*wcXia)|0cwl;p&S`F>jJ}V};GQ|H(W;Yl)X7>g#_4rR1Fy8VVJa~R-d~m2
z_A+}-CW<F+?l`f+;UPSxEiTrfYuaIBf69=rG>|n?q@%4|v$iskx?N+7bJ){XO!+1&
z_*AKO@r?YMADL?J;hnvQ7ry+dD~^cbe~f?Ts_eO7g+KGGMCo$%P3&HW@|I4JAK%<C
zAf6|e>{-WPvPVYn#pKstbguJ#d1vHTDtRHF`O2G3KCGeKS^0?n1B}0}PpQ2j|JRED
zF?kL!erq1h#k;E2HhkuIzqfw=T9-tkqkeDmD8#8b>jXc9IZo-$)B?#CA4W?uTd#&^
z(%o?0YgB-Vjlwz3n8cq)Pwea;$_w|*GQUn5o|g(=S;Jswu~C=Fc)QrQZ;;VzbHqvU
zo%-lQ@jUUg#NavW*3y^i8Xe1)m+IpAcc!lYWZI;c6*`fNC!8aQJuB63LHg;9+0xz>
z#8_DOz`B4)UNh9c$ank3Jk??Tl;NE#Ysy2L;Ng^@4D+2IqpU!eN+kD2o{63YUoN`9
zxywA8!?O?RJEK>Ox6FoNgLai(6Z3VpC#k)vx<)th(`z=eev9W|qxlHzo3wpY@%~1<
z%GMfRt-dr|eQAXB&G1Kf-ddhi|CU{1zAG>N$i{ZKt-4r;^AFj`64}U*Kk(umXNP8N
z*n)i!-@*Nt{Ie#Wi9fW_;#bgYzU6Q|_jo;EvC@vzyYGvh;fcsbVZUlqLs}9E`47p+
zzpB==@V-j-gOx_|&ZMc)v+$m_)~RfMhg$uzS;UO$y{-L(|2@<Ho}u4Lm0Q1D>y>MV
zwA4|r#zRB(%Xp|Lb+aq4MAwv?)Gu^nXW5^p`I?MBXt-iN9vDMgKc}{?WXvm_1KUOk
z%STAolt-+dUyCV`w?uZaN_n}KjufYrmV2{#X<d_EHocYST=&s6&&k7Ff#uiQhT@??
z-NO8`DwW5#VW9`V+LbMzk8)W5T~*uWI~2y=D}Sb*!hlZMgEFJb**?)Bohz<WUECY(
zBXpgoF%t7tTr+nMPl%OcN1$K6NO6t77WQj-OD6uD!EVxVmWlD0vkNT0_*Z86;U79;
z*pN#`X3s{72P0KC{ma(mfg}8*kE#7CKKSST*7#Xn&}?&SlCQ>hkzImr@vRJ+a=n-B
zbNl1yW4ozc7W)GqtQ}!_VR~x^d3*bIWa8SM)|Bvp^@6<=t0o=vnSVyR8RHkG?&`2E
zbVcrbv|cNPJSRK<j`qnnFB|T$6Aa_sP=60i+@nV|u{5mR0&gvi^@~V<+Q;Vu3AjtM
zm09Pz<#$4t^wF(pGn-p2`-}cyf4hjD%D^6%2k)T6*_72cwIqrj+O+SsL!0CE+uZnx
z`j%i~`P}A)0*!l{geA#aHqP&<>x8f>HDTji;csDbh|V^fxN(+nwlFoM<$>jsnu%G2
zm}_<dedYV0lvR+vd*c}8Zx@HvdK2gG_?QW6A@I@d3=i-)K7PaA(I#ZSK<y^K`N_mz
zqdno%Ws}cl?PA$W^8LYh=q^a#wh@~IJ^ATdHm>sH7V_k$Cu{`YEgk#8;<PsCy~9EI
zUh}w?F3jOqwteCu!d#sNU!=eBl%qNxNZ+k7&CMDwM0UPOx>g|C=?4pSp0sOwFvhJR
zpJ*vai+<Tu-V;ydj3URw)ZK2~0XzcdCu*-sq1MI~=`W0b5xYyME}PTKR@Z7_Xtuf>
z)=Q7wcLZfCsV8q>R1fR$I;sb`U^~;23u`jyKg423Q<vwzTZ5Kdvta}nu6jo57yIkd
zx_0U8fy7zO;Ak~z#M@BDtf{dvO$p_S&*+xZ8}S+2R*;J9TDE-fCiJ;pN@`tb@sO5u
zGO<Ar*>0bflaJR;N1t@+F=C@?m-7`=4}Fj}q3h$-@5TuSjIU1De18EKxOdnl-q4TH
z(KEHKph$QHo>)HmbcvqfHyYoZpDq684G^vA{D|gsQf0JZOOp<!Sg*fz`g>V_VLu1|
zWlu`1uMZcFN?y%2?{}npiK<vXrmr26R(+`<Er%}`pH&wzB-`7MyuscYwFSAq<N8yR
zivzqFTyF}ln{>@O5!!R4$2Q?tG1q?VRLt0kSo8NK53?EgL6zR`ImrJG@V^J@7e6Q^
z8twcLepx?<zVgjMzHc)|zxYCo<?)4BbK!g;@xkf|ZIgTyckUc*?5KR=gzoz}J6XQu
zQM}yu1Lk(o3C{B2Y$}Ht(yu)63fj;)crr2zPe=n#jGxX%>siPj#Z26omuIBk5zp|k
zXcK*KXLx4z99oI@Fh<}zGGHa+@%8??Lf5PO^*Z$%bP1hU9b6MH03(+BbW4MG^v90k
zhs$)9h2aE!&vX}Fs{J~rS9=aP??OB-<-NB%JTtsDogmF%PXlz)wruktVSlsh*QMOq
z{+Z2ZT`~R8))ns~`K&@G<llzzg2i4>8ue@QBlG+-;znR-2A9+p@CbezU*Wf1?-TSp
zuETy;seETjZuKgY{%>hhvZc=VkUY={unQmBp0N&tXWAE;Ntg7`q!U_$4*o?lCeLWK
z4=jXcJHIND)7j0H?9Who?hW^#t3q@cz5RlEEUpyNGfVP<9(-`4ae{xAl^(T=bc>Es
zELr>m&qCS^|0PaG8}}h?_^yM5ThLjlciDU{TbFT;;>pC6ZOl8u>i}yKPnP`g1IkrS
zwSGfAfF^tabhkI}L^HqW13qn$f5xxbR2$R6>!E=ToE+!?*P#y7D=p(b)48RRBl|Wi
z4QDlz<|3sbZ<VmOI=g*nH|7Bwu$SaLTX~189NL%EA3iQ};Ti8w*L(V<lZX1Bjq~6y
z*J=G8t2D^L;$>-F+c}*0E$C0^uYmX1FMK0(k^X&*XdfurkF6cjQY)L`^7(Y(7<r)D
z*(4g-^Kq=MSs$-4MA<P~j|vZn2@~h6Rh_g&V>)-97<)iyV}<B-c%rscC=I%)_6`^$
zous|&b3#76Gri(Da|N^u-+?wWo{sd(t$!Mbk3hP5SLXKPKClP9<NIG4{FP`-R#Ft4
zm&3RJSpPFuI+Ij6bI>8tYuEz@RI5(Ij`3c{#_2cI32bYP(%vq5NsInY)irS%XS>Dc
zwD@c|9QY9J#+TQKZ@oMXrWarKIKzC-WX)ydcXQ*==a3<N0)K)&!9IKXuuG?J2IL<b
zjeU^0VL9n74SApy+3c^p%sueVtu?am9W2*=ZraeaP5ZZ^vatuq3Hvfx^`O)FiOEg)
zvh>MO`YlM_?$#&U+?1s+;EbpA#HK{z=61TtoOOxUO|6G<^pXd;Lm&8Q7^K*?+p9wS
z;STBA!QvS-kd|ks>6x(7J+pljEA$M^Bwc||H%!lT&Su$S=@8@e#w57W#w##|^w+ub
z)4cDhd)jDm5$UZflRcF@uXgVzN54V8o-AxcKZ?D6aLqV69>)V?u2dY)($_$5qRq!e
zpZRC{Y?!)Lg_&<VS~^`XogS9dcX<^j7@@k5b8r2QJ_f&r@Aab7YlNjk+_mwpr@uG8
z_3-z`v+lYtO+WAYxNL#;>^$ENJBh&@r!%64QNG$Doh*AtXE)KOXq(6^-psvtRj)MQ
z1~{<Jr=c&e_Se=2>6a%7n}{KvlBEw3@38*KSi-K`;&hWX^b|%xk78BDysuK3U<+6}
zSu!ut*qilMykj3F&*2H_h`A*hn+vlP!yRaC8=$t8`f^oP8ST05h(RqU95tw=-@s^o
z*4cD_&6%#mJ&7+_tQ5>8o@DnmstXKt_?VvChyF_Jh_ZPmp3kNq#OsmmZ{1P-Mt5JY
zvlcgKtjg^xiXYlX)_(nIN9pk`;j?5~yq#`~pOl4Mcn8iyH+03Huk`CM(U})SFLI$j
z@(Ug`XkP%=W-G9ZMJfls3Ynd&a@muBo;iKRmlv<GhxzJHiKKKubRcKLM(93Sb@lKv
zmG9*2weg9xU>;Zzj-lZZb^?6#I$vBu-N|UJb3DJ~-EN#NtZHp?YceB0fcf3kS_?{j
zv@fOiroY0EV#XAvkBW;80E<E$CLd>yqQ|^LkKtX2r=)>rZa-ImQ}iXP7tBRY=$-oQ
z0G?<11oVoxJfjcar+yKpR~rV#%U&T21Rsv{dq6^YR{FBjdY{%cGOSm-SNb(jJ0nBR
z8tncN$gqyOJ1Il;sf>(d6N)o)uZsVetb`E*GSB5>@2t#<ghAk_?_XtLU1wx9g}6o_
ztNXLaDlGd6@y}%SxY`x(dr8U1#_6HFKB2UwzOJ2-*YO{byk_Ayby8k^L~GbLtbfT(
zbhw3Vc+VV*$xrc$0rZE=JFQj7CBv|<#rs7lw=SY1>Q{pzTch%k?}BaHw6D9pyiF#T
zW|4`dC3X_Zgt6=d@0ab2Oc=+06gXH&-JO&PIG0T(*z9(E4`dSdDb|jB5P5`{mrEW$
zkvwwY8Dn4i2-r4K^2_G0$vbQJ&&IxepFg9e(T{)YIX5XuEdJq*`Ns^=8m>VtQ}l=5
z)^~5+Cr@mds=vMm=~{92Y5MDXY?SU6rNge^>la9Ov1x@m*C`y!l&YL9vP<|Bo4jr0
zm+>?9cddWMZ+uP|tY$x8iF`2T{LxYIzL@=h&|HvyY9qE<xbNbZ`3DYZnOB{^LFY$m
z{l}1&>y<C`d&cWoct1|}Q<O$+$oN7N^entj2X#@u=10q}_WcEaW4yn{ezIr7XwcbA
zt-QnMX3W%IKJ4{At>jjqXFaR+j<c-C1?5c$%3CRWoWGaaRFSvgQkBO$%0upyHziAX
z6J#TeH_$6z$I)A$bA$Wo4;v?1U7g`G{JZ$LpFT}p*lh4(lztCY-cnuL_<xkHdun{e
zo<#f;+mm*)_<GCoAuYGo4r!SQ-{k|Plm=Z1$N0C%W;TgV=AduYHDi2ue6y|_{kcZ@
zsi!vL4`>`+HdFoqcAI-)V_9Vqx}r5_vy^_K{32pW4O(+%_8t03gC9W~MyU+!J!M4S
zsBCMym5olZAJF94Mf^7&4O1ELWtwDwY;V#p_f!4vxAgmtY*Hu(=}H-Cc}L&nn)K7e
zr_timSkEJVErz~YWe^WuMOpf#4r1sv;^Q#2+vb||yj{!(+Od~L`!lMqzxPd`W31lQ
zstwRF#$Qu*ou1X{zCJc*Sg+?{e$o#1`9~`~*Ms$&isc)s=cFB>U)G4gj|bAXIjnGF
zOv#CP$2Vm|?Ond`#KtAGYq&21xqa8`p82*TR3|b-U#uSJN6yxk>oxZ=*>pm2e%b=9
zq%pc#*BGXOZgkx0sn_+4{QM?YpM0yqM(^_5qVMOR+e#D0z330<dO~q8lT&}it)MUL
z3r%`oARd98VVy%`buxG8c(jvsc2ws0pv(~aq0cZLTd<>c!F%iwV~UaLTg0U!-Jckp
zm8ZE!d{AenBy(Z_%r`RDaqE<2t8>zcjz}jGN%6_snC;URG#UQDZ+JOH@fFj5VM{A@
zBXj5^CT;pgnT{^$(H}I=h>S^x&c-ogxZa^}7s!{T%~rm{=<4oz*A@%B;;U_Qfy7IM
z!wLmz&6WRUj^b*i`HKF=U8l5ut;I=N55So>=>D{Wqxs4F^zx0=hdmsxXIwK!$(n$%
zb}tOcPfy!8%I*`<{Q7XpP<qC6^~c?_VUNBAEkpIo+)&+a_qaV|`3FTjtJd=p)ltQJ
z`TQ0OA$HSS&yxB*aUbE6{DDgSop`XW<qxFwcj9s27XIY+J^}JrUSspBPdPg-W;i^=
z20o^D)W;Z`bX=F~x<dTs{6qRC{)2eeI?umHM&z9p<eeVm9nZDKAC$p&O~P_Yq>H0n
z+DRK~eYz5*(^(I0JYA^zwXaS6HhR`ONTahGHl$tN85^*#w4*$@mz;}BgY+q-?<%^f
zGm_yX=}Dq>^RW?q)Ipk;xL3Wb>*v`r?QOx{*!@!7uZ*Q(Z%eh(fOYa$TkBK@_xXuS
zn!uS^2L-s6TqC;+KPNbTIvbf>(M&pc>F`qT9lxaGuPPqM7{Zk&AD8nXORavb?~clv
z*jAS8ZJ1uM*_M|EMs33HxGHIR+ShM<S$NnZ&6|CC_{v(X`MSq{gm2I%d*2GZ*ZSCK
zspw;^gPq6Gt}RN(`b5@0UaWjGgR)Oo*+XMxqg!<ewU>0s84jmM4Zu&0Fsx7*_NkP<
zt)YIVZ@IhgRmg@nvmP&7z3|WIR{X@#?eeQ%hG&R!j;ElYEL$0WRT(^|9Xjt+*fgYN
zOsXxOPrp(f&G1VQv&8CSUW0t?_>`RFbmB7KhVYvbtR2l(Kj*i}wzj4ezYXO;%s*@S
zl1G)&+IrM%W$HTzvrCm`Rgv&yulBKTeA7mqyI&>Rw;nxd!!*TYqxBi99cHNCl&#b=
z&a_=pHH19}tuuYxc7gJRHk|kH0~|5F@QckqM)~T=Cw!Q$U&bBy1g!s|52f{t?^Q&5
zhacWh?$eG6($Z%veZr^TR#V{ijak0UjD=K3Wsr{;x8-|G@2O{7werzN-1!?1Z)o)S
z__jcXwjkehpRZp{TOR1gZ=`+g_^$TMryTX^hsFCMr8B=~iI2g?*XO_|eCAT+!_KgV
zi}@d6%xwHt-X-*ow!Nt_PxOtFIUDagQe#2cz|eogzD8rb$s78M@6_+ko)WLnTVjg~
zD8u!O=^O7;`fPJZ*glQ@S|^Yeno^=E%Ul!bMi@=0IoqXieOC3#4=%=MLyqJz9bw$Y
zb#FbZ<h{~1O7BuCllG3(FJssIW23Vd*n@5MlYRN5sj)PB>#R-xj6MG3!<T_SmdA7w
z-^uBqzPIwtV2v5;obW5C$G%D8(rI6U(?R_bw~hFxvxzmIu%FgzgG(-*#%7$ewSY8E
zmclbX=Mbjh?5ruI5xzNWh^3(}bZe`|M6RyXbk}Ey!>*P;lufUYeYtpuz7tbr?IJw5
zYWcR8R}<$Huae>q&+s|Jc85M^d~IEab;%y^%{S9Y>T0Aem2W;uMa-wA{J5`<To`K~
zB)OD(T1V-ZImX`VQ#O9VJ|tutm_u>nMXklhx78x#;>{ZKU`slrH@&@on=O63kG|A1
zT0?ie*3hjLjnIRPpm~Jqb?uk_^BfsHDH$OP(twFem4`Og>iR){jeI|h9@eo|)%D}t
zddN2gcBF@VPhdxS$R7I-qK7r)3-qu~_vqmi{erc<(O1djqtr*%b%y#_PMse@A7`pO
zXl9>lNBYPb5^S;Q;|TKooAhy5_cnb@$MlgkXW8@-Jr8Yx{N&=fq;)zJ*#hJN27<@(
zlN1BfdyoI&yHK}ly`H1nwd$APJofKo^?^G74u8_tlk<!|GU5GbT*rFP>sjylIKRE!
zxX#wZ->5a7GxaxJf7A5WF2LHs&7G&M7}mk-M1_o_{oAI%3}ePwZ%5_JMrPKKvKC+c
zwwX0+o5YK7oW}Uf){co+#kOt>TUVfYF#5fUZDr3A`m;d4;d&ByPnwj{khfI*q}Os`
zw(Jl1m}~tA<s(b-vabTaocNPl)4?9Q1U5i^svny}KjTcsIrsqN=bHS)q`)Pvo$XNF
z#(Vf<YY=QLAN%TPN63dF<(=c7VZRxpL7%N3<{BT!)+*Xw!TUrP&!CNVWY3e=gby)U
z=X>VM_A<6CNMF=6S#}#ewRYWijMC`O?%`p4Z=1>6+G1xz+Fpyed})`_lwW+#i>w3T
zKI}spBe`=Ti^N0bVv$AO!04Je{R#d#>jJE-yxe7#v8J5(ft7{N#WiKs`sa)XD2sC%
zkUQTtc4cc{zl+uQd(L%WOv`&@oQ)^Oi=EjoxwHER-Fe7a<S|QqFsz?%iXcDMp~8F4
zH^%=ZmQv;Q3;iYD%6Y%=mUq(U_UHWu`#`qtk!UixTg-=e4`aD$L79?IG3SSacg!)-
zx8ZF+>D^e;DP}O*r{_$~5&qe5<*E12^J^|?apyzJo;f{CXl#?zxJ$C5KE~dZiM@00
zb>G|N)f$P_8t3{wkr{gZ#qMvaPb*$kr1P1HR~3r>#TpN|d79*;jSZSpl6-ZBWHhhD
z_d~+|Nn2*>8Dq*RejLFsejqr1wSUGhHrZhbdjdo!aiEc1qqr5{6`>uqO6ThKb40?v
zvcZ(0c#6$&3{^hGW?Iu(o}-J50fvefBlUZ-(z!bQSsug(nd2}VL-(nd_!o0xdlLUT
zL)W!~TRx`06Q9)e@}Vss*B?G7b85Zyht0S3kcBC*A(}IrtFb{8FMVoblk`dZFv_O$
z%=sx#%YL8pBKv9>`?z$P58>=e%Y*IG*sN@nJ=568Y@YC-ER~F6uk6b&*BX|Is@KJT
z6tf{6J|XR=ui6}t<;Nz|e$v33Le+uo;2HHc%BE(^N1s?P-yT~!PPX(SjjQJCo^#|M
z!{?VhW;~xzJR+}5X;OI`hWoKst?EH0!~^&>TQFMVlW>e*q4zgvtOS3FJ=!?Q&YLmb
zN9SC(A47%mtx#K7!y1-l{uyPHKOB#s2R2>+51cMkpTD6%<8j73#4ltE++5p9JlEJh
z{(KP6{TUHq`oTPpmBD*(hS(x?$&R`@JP!vXlH#HE3yn(_Z0IT;o*d9p>uG_frv$Ww
z&rc0#37^+_TEb_@gE2<_F>_z6_wpI$e+TOqTI<z6%x7@)O5cY2cRa68M*Rmnn%477
z|5m%|l|P=h(w9F%zr)oxM<|W=8!|Cu{DyqdMobtQ(bc13{n+F@m^zY^gsIV9uR_LY
z(rJFdn_;{c*6c_J@Mo+KhixD~z5sloF8U6<A&tde91ZFN^6kp-b8KA3^@P}b6najZ
zC}X5gOZ%8>Ax427a5gw&8`{AySc)Ev^ka>D&v(YD#B@zA$da<56~00Td}h7ea9{TK
zRCZd|@O+eXFl;N&;T7|E_ME!H7!b1GS(%JwtfIE?`=5|Wo##cJXh$ZSWmn_alS?MX
zH)K*JKGwq{$*7Cg@*uyCbeFwsw3}a(VdTq3YX~{ZEt?E^MnCnKP&`KY4SVrN&{e}(
z_nU4%Uo}f(nR|lqjIHqv_tN}G@9)>&kM%dtr)56NMnQ_tm6-p;9vjXbvpqKO3fs+Z
zseb#4rc&t5a&A9q@DYeT<D=j+c681@{hI#f?7jcSFyo1S!dLtn^b)<MOs=t~9i6kk
zPI7Z~N{>UI-P#uaK7-NAFZJyyy73X9A;OX9+YHpbqwgoAlqPHoG*b@rQ#Sly+>4wy
zh|Z`z+3AdrCweP?NF#n=oJQImr;%s<O548iVB_vMze5_GY(0$~@iML_U_Je<pT<`B
z+|Y~OfaR{7n7+WDN~QOGDmouX@>O4RXXM&<9>{Coc_2OGLfKQ7Cj8C=<xwX(ivGbP
z^b7ri|6Ich_-5aEV2xHNGw>R@pnsGHFW?PjMtq6%51M#R`_Pvn-5Zv>I%E20;{{>>
zoPA^CMC6K0;DP#}TQinl6z%PyE%1>!DC{HG^66TkIj?J!1|Np!W<$BA-IZ=E5aAAc
z{EbGl9Znw|&F#nN3=_u9``okV{^GZro*$bkfBp9lJ^Zsh#{Xl$qc@(~^OW@byl<cK
z-nv;6F8|rvgKzrz`P;TFdv?UP`gWiG`59NvdheD&U;9CyqQ=uM?!WI_wGY%TKkK{;
z_y5sv7rk;p^3Z3_DIJ_Y@#TBhJ@&6P8()61xz96Qk6v-(ZhzeJTIqQwcX{Q-``@|m
zjjeymzv8l~LkHY^(lPIDoA}n1H}<{gyI&}&-tgYw)@AeV|HBJIMh^MaTVt30dfB7b
z-c|AL0r$4vkbYxrmwl!b9<zGwpEi8w`Ip}r|GoV#J$J#%!F><ha_6=IgMQd==8un=
zJ7epLPoID3?W;;|{l=Czwmo&h^*4Ot+WA*By<GWz>7cy(?(JT5=A>)SdHcw}4SeWV
zPd_{0wl&{;^^Czsrr^UR<G=d#zkU9S-=y;{JLvsqfBcolC;jdl?|%B!H-EDBdq0~q
z?@P;n@!pL6k2>M)RaM{L@YgHX9kyrTZ~Lw2bw`)kU3*MudG&yWU*2_cW!c_eJa6vV
z$3FAGfiE6<{W(u1UQ2EL`T3uFV%agL4;}u8)o=XhUxUs#;)av|nSWh<%{}way07-u
z+rL}=kEM&A>yzB}_otsM>ACqccMkse${${P+^7rox@zRaPpt1dVEU9(USC}L!iC+Q
zZ#sNn@oBr1k9cIwf{Sna_Df&e_}I~3xcQG~-aqEtEv=Vc^V6aw<N6=c`v;AWZu;}p
z`we;Mrm16(fAF()1#j(s(UG6}<u@PR=kDfrW_7>(Pq)mxYu_7R`TZv={xa>}Z|(N$
zmrojf;&%?-qhZ*uKKAG(mwf-7@#C+5{i|R7&Rbvq`pw(^_P5=h`TXY}df|#Ietz3;
zelu)jI$fWimsjxn%PzbB+=CAK#>V&G-|N9=pS}2uAOHB}&0qP->{}my{N(*6P5SP)
ze)qfDcfawC8{c^M-8~n6`qQu8a_XtS``4Rqc02JWKiT}i+O?N`=6m0J@8qBTthL{q
zIln$<-n_S8`qG!~xNG_H^S}IyUp&(M-g~`|n=#|3L-*hRb7PJ=>bz@DIN`*9y#03m
z<W;LaF}kX1#980}{+6dUY^eI@U;kRva^;mXe!OnoRTm$2*f|6C-1CH@!oreo|Ms_M
zpVF`2rQcn#;=**VUKK~*amT&IUApXX=<L}K?%uWQuH`*?9JTj^33vUarRBIMUww7|
zGY>f6^6M5Ze6sb+U%scuuDkBN&*aH>53j7ex~i<~kfZkA`{4Co{NlpK^Uizy{JC@g
zHSg@R-}=h2$DZ+vXP&v}8xK72`?C)`@aunm@x|jWJoL~jdtQJ2oj*9|oPYfCsi#Jx
zOAo*HT4il2HS)!+Tlf3g&wu{dqVvyxZSChix9sL8o;c;QWy}8brDKj6GV}D)Uzjy?
z=-P(i!#CaVhd-SDtJSMN|C=}781RW7{b<8$|N7U*zBy>nZ)Try#<QP2;)qXnzu|_N
zQ%^qm53l_5pUJ}f{9WF^?z)L{>+9bfS5q^%|2_9C88UzVi{CrztiNAy-+k{-sI6Vz
z<<?uLo^bo^Kk4(`?=Br%U0wIrfBd8HlBG-k^3_F)9{$;L&wcr%K7B4pC6j5{rLy<_
z{`cK~{q)mcnE2$ALwl8!l<wcN=aDNmZ$5O{XFk(><ehhZZ_41os}A}2$B&t@a^<H!
z`NJRnZR@qyPP*o}<4%2S)TjkZF1TRh;d||M(92g{_3h;&N6y`A;>1~Zf8rBQ-M4=I
zb%Xo%{p_#-1Fk)G`t%=nn=)ncv{O!b{I{>ae&FX9FJ4noT3YkN7hd?<(hDza`B=AZ
z`~2kj=fCoNQ`51d4nO?ds|OA|v$VK)-`h_+?fH^jb}6naFCVjb#E6&fdE}7`9$K^J
zi-Q&{cw^<o7ysax+ishG*tfquZ_P_D9sRejeeI?{ZrphIO^-b`=!-`m{pshv@P%LG
z-F)-3pa1cXqvo7>=F_L$e}B`uF=HARoO|xOf8VmD>mOQM`#*l^r9azp%{8~2`qQ7j
zk}N9fb;Xh;e|&S?xGAUi?|;RJLk{^;b?@HgpZdWM{(4no<8SYL^wG1P*tDtNy?_4m
z_)S+|J?HrS_Um)UkRgA*=%I(!?{?Eo-`r#B)Ek<{j-5XK_~TEy^1%mJuKMg}e>A<W
zZrv^g1zp~L>#e-ryYJrPk&7<6?{h~U`I(=7>Qn!`{FlF6{qb*p^S19i{P6IB`|NYT
z0e9d1%Re<YSHJqsJ3SAYHS2-C-Mb(0^yQcT>i$3dX>8Y9Zu!;`GiUzr;JfZxRI~5C
zefPZa#@m1Q$}6cGfB*Z_e)P#tZmX}T82A0Z{N<X0Y13}~^u71Kv+K9MHKA;`-9CQl
zuYdjAvoF7V*!3r!^yuo*qZdy)@x&Dee&;(4=N)|TSNGjxkM3V@Xn11&uwh%j@T*@v
zQ~9xv4g9_U;CcbTcLV@83jlT#06ZiB__+XJm;j(&08k(RxL*M94FSMj0)UGJ051yw
zW(xpL765!#08lFcxKRMGrvTtp0l@DB0Nn%tn*{)u2>{*`0JI7Kek}laTL5r}0N{K9
zz#{^H-U5K13IIMQ060$oaH0SpUjXn40l)|Wz!m{Ol>nef05C%UaFqby909-y0)P?$
zz}W(TO9cQI3IHku0QU+2_7DI(C;-@10C1E5;4T5caRPw-1pt=|0G<>8+#>+kTL5sk
z0N`o?z##&Fg9QK!1pu!L0RANacuN3qh5+Cq0l@DC0ACjX94`R4QUGwL0N@`2fYAZ~
z`hTSWV59(GKLNmF0)W>90Lugbrw9Q4Bmfv90C+(FuvP%DNdR!V0O0cifB^!44FZ6V
z2>^a00C-ja@JRu{OaZ_j1OQ0^z%BxSi2{H(1ptEu080b_FA4zuE&zC60I*yDFjWBX
z69K?d0YIGqpiltt7XiS-0)Q_I04@;#qy+$F0)X8G0ACOQ3>5&B3IL82030d+Xcho`
zPXMq=0C0=|;8OyCzX<>)2>?zN04xvyY!m<-Bmnrf0AQ{FV3q*jDFMKB0)Wp70In4P
z{8#`mSpe|30N_9Yz#0KSjR4?l0)Q3)z&-+iuLuB+6#$$o060?su&)5%c>zGN0AP#&
z;3WaT1p<IC3IN^^0Q^7zFkb*LPXKVV0N^G8z~KUbK>~nJ3jls00GK8K7$pFBS^&@_
z0B95dyek0cDgfv&0Qi{z;1&VED*}LC0)RgX0Hz24t`GoxNdQnT0Qjo_;I{&RvjhPB
z1OVd&0CNNYeFOl1767al0DMybaDxC~x&YuL0l-QDz>fp~>jVH@1ORygfF1&X`vd@=
z5di#C0I*sBaGL;NxB%b)0l+T>0M!D3o&tae1OP_}0DdI^7%KqymH^;~0)RyVfW88N
z+XVnA0l;YjfNcVRaRPvA1OT@R0NxP*Ob`HkTmbN#0N^kIz@q|y#R7m80)Peqz*hwT
z-30(o2mrPU0G<&53={xdA^;dK0Qjl^;Ohc_zX<?7F95hg0Pq_DKw1EhCjhui0C121
z;C%tWvjTu03jn?%0C-#gFi8OLI|0Bq1OV>}06r}MI8^}frU2k40)VvwfbR(aekK5z
zBLJ8u0QiysV7UO`7XpCy1OPJx0Q(C7juHTzAOLt<0I*5`P$dBPz5rl@0N}3zfGY(6
z>jVIY2>|vK02B%Uek%azCjeL>0O%zExI+NYMF22c0MJzc&_e()K>*Mq0C-gZaDV_{
zp#b2^0)Slw0Fwm(l>&e=0l?k@fG-LF&JzI46#$$q0610v@QeW90Rg~)0)Q6<0EY?y
zt``8DBLH|x06_nLO#qM*0BjWi{9FKVz5w8J0)Qt30Lugb#|QvU7XS<u01OuZ{6PS)
zS^)5d0N_UgfPV=91_=Pp5C9w@0JuQ_aIyg4p8|k<0l;+vfO-KyjR4>t0l<6#z*z!-
z`vd^B0)Sfu0JjSOzAFHz76AN10I*a5ut)&#oB*JY03ay<*d_q@y8z&60l<?2fD!>f
zPXWMY0l;Sj0Cx%i1`7Z_E&y050QjK*;93E|aRPu*0)Pty0DB1lt`Y!@6aY*V0DM9K
zuwDSrR{$_T05DwuFhu}xiU8ns0l;DbK&b%W1p&Z?0)TD;fae7OO#*<!1posD0L21;
z(*yv!2ms0j03!qdj|c$P2mlrc04^2)+$I3{wgBKI0l?P;02>7Wj|l*d765!f0C2Ma
z;Ew`;GX((m3joFl0L~QvY!Lvo3IHw@09+#g_^AM(NC2=z05DDf&|d&>hyb9s0N@7#
zfJOnpqXK|U0)RgY0In7Q>?Z&iA^><u0C1B4V5$IMtN`G60l<R-fX@m5>I47<0)V#!
z0J{qSE)oD7DFFDC0N|GbfNu%_9u@%XBLKKt0MIM|ct-#*O90Sa0C2eg;7<a8TLb_z
z1ps#m0QMCC+$aEeMF8-70l+5(02Km&zX$-P2>|XD0DMaTu$utj*8+f-1pp@r07eS{
zP80xqM*wiJ0ALRRK!X5am;m5c0)USR0ObBZD);{#x&N=r{eMgD|2Db*&&d6MLGJ%;
za{oul{m+;C|9iRr=gR%xDEI$Cx&LR#{ogG2|5myG`^o+PmfZh$<^I1R_kW?>|6An#
z|4Z)wiE{rRko*4`x&J52{qHCD{~WphFUkGCOYZ-d<^DIz{r`XMy?=a_bNv7Ry7r@1
zrcN~^E2o6ekM%>6aQ35LtU9&z1F@~P+O*o*7DYI#MOds9AvzI4C_)H}5W*sau(b}A
zFoY0&?~m)cPCLc>ef!+LpMO8Qna6ov*Xw#+ub+?W@qDaZJ0JO<j{Gk~{$G#${}uT^
z7x|x${2z(@--`VI1Npxb`Tscbe**IVOyqwY@_z~Pe-QHjKIDHA^8Xy<e{<x259EIf
z<bP-6|4GRIuaW=nA^(RX|8GG4??wK%M*g=){*Occ_d)*mMgH$V{;xy+Uxxf&iTu9`
z`Tsof|2pLVDCGZ_$p0&l|80=}4<r9yu=hU%fc*C%|Lc+evylJKA^*1_{}&+tCnNt$
zkpGL3|4WhoYmoo*kpC|s|KC9Vk3jx^kNm$8`F{`ce-iS)74rWU<o_Pze+=^fALM@!
z`9Bl+e=73-V&wk=$p6cc{{iHGEb{+C<bOxxe=+j^C*=P`<p0&k|EG}uDad~>@;`+9
z{~P)LD)PS^`QH}#e;V@tb>#mm$p5pE|MQXm-I4!yApb`r{|_SnuR;EAM*hEu{O^VQ
z{|5PAjr>0m`F}t1|3Tz`8uC9A`F|er{}|+dCG!6*<o^`pe;4HcBgp>^$p7P!|4$(Q
zzd-)yBLB;f{|U(dMachn<o^)l|9a&Aa^(NZ$p2L2|0d-Bxyb*X$p4R!|34%DKSuuF
ziu|93{Qn&JZz2EJBL9~m|A!*~w<G^oBmaLv{(pe{e+T)$ANfBR`R_sg7a{)}kpCAU
z|HmW$`yv0wBL7Q~|92t(-$nkfK>qJW{$GInzZ3bNgZw`h`QH-xUyJ;ojr^aE{NIB7
zuR{JeLH_@a{7*#wzlQw368Zlm^1lH2e**IVZsdP|<p1f&|Id*B-y#3cLjHF`{(p%4
ze-!!O6#3s9`QHusKLGiE9P<Bd<o`{`|HqL3e&qi{$p2{M|0T%(X2}0`$p1X#|EI|R
z3gmwc@_!EU{|w~+rO5vd$p34R|ErMyQ<48&NA7>be|>UZM!OSMzTW@zEABk+@hR_~
zeBZ#IR{uHf@r&!D@9-x5Ir@pKrv5g6%T)`1jY>atMCj9lZ=Ct=r>C8r7I=2TgSUUR
z_R^uJzIf8)fqPplz5Ji*y4QQmh$>HSXuV+2T@OzA=#Mv}Z_oPnxJApBygK!o@0N_Z
z<nwK>%<VR=tm8*RYYWb}?d{EJGhVy-%Kf*^ntAuQ3#Od@!t^g+sT=WJ!~7>sc-y;r
z(sl3mUpMjVi`s_T^_+9p$llo#GHw{SHuvh<m!>>f@lSa$@sGH(78ei6A9wq}zfWBJ
zRpCveu08Pl<E0;+QgU(B&ia#YA3JIE<7YnoU6-ako_#I)#y76L=c9At9!lzR)6b{8
z`q0x+(O16s{qb|g-||7?S&z(Gx9FFqKQ|07*tsI_^ZoBNiGAhct$ik(yy@Y8Zt2rK
z<Gu%e86AwhrLNb?-@co1%-ntF`m%p~?275jo4h>DGxCCtxBPMEmrc(9@`BhWhkf(%
zpoN(Wo}Iqw^4ORr+lsRN#~nIx>0g~cd3n!WH~UhzO#bZttJmyKdAaG$x6c3e#LN24
z+Wf;8D`qzzJUgZ3o&yyf-WG>63*0!j*IC~W>Cmcpb>XEY!~bq^=&zRZ`i(jN$&Wkq
z?RM_z&0Bt!n?L^Hj`v=cxwUiO?)~GNPhNY+*l$~|`{B+HPr7&E{ekK?M&#`9K5*&P
z7Z)V9Zg>37J6>#F9XvBMpi^yX>yu7s-=f*E$NYTjTTgU*Zq*A39Uk30_NNo)JvF0g
z`VV)1`O<?oWdHrUb=varCBJS+n{?hAm;H5ppIcMUxa!?g-rVur_XqRW@A_%tr#*MP
zlQMChr_EiRd=+oD^3J=c^K~D-bpC-S|LE1~tut0kZGV4{i+4Po^vkg~j@ozi#`>DG
zo;kko(c%~GZnb#GpM&@0c3O3?a#OJ3!ggb>>$<&D@2Vef8an)~&-!iMSozKa|18~h
zOy7rpE&t%5Yrg98`SZ7(cHtARuI$?XzFq#Ai;lfAYs<Zv*AJTT+k!T)Rc&9tyZgDn
zUoq$Pr+!_2dEk|Tnmc9}ecbKQ4^D0U%;wd1pXX_N-6Ok~O`P_{c`sf2-f1(NO}nJ+
z{(bj6Z_OQX&#G^hOv`)h&^On2-0(r%kH_u)=EZOC{p_NmzVGi{-fY_$Yi57abLG=d
zoq6FYJ>Pt2anjijOsXy$zTupMbKZHlwyI`L??<*D_fyQ$i<0+!{`(E@`CFW@@V6dU
z4f|w4>W^!NZFy{1=B_(qzP^9!v-Rm$&Od2m*OS)|${TsZeOK&_u`18L{Lh=pO8+`0
zx%)Gd+h4lqiw{Tb@r>y`^^?JE?)fyQ@|+d%*IaTS;kNJE47mCIM^FFZ`JA`Uu1gGk
zf6d^v1D1XG^(CW!F1@gA!uzvI-#X{jjNjkeoAvi&mwkPHQNql$FK&G2sb9)p$lr89
zzs`NSzV@Im>-hGsmu%R1YJ8UgLvKBF?2_bjS6S2J;-C3y`?_7ra>s0}y7t|QoR51w
zS3IO}d|A!<u_=BCAOiw;9Rj!$0(ch!_z41d90Irl0vHVe{00FmgaA&301iR`pF#iu
z2;g=IU?>DI83I@e0n|YNQ4m0D2;e~o;7thNTL@qY1n?aM@Hqs~4FdQG0yqN#NP_^b
zgaBqj08=1<FCl>EAb=AffJqR*ItZXG1TY5z$c6w0LIAZ8Km`Pl2mvgH0LDQ8Cqe)>
zK>*J~0H;6zJ0XCv5WtxbKvM`H8UnZn0(b}l_!$Ct8UlC`0vHbgoCN_af&dyIfE5tH
zdl10K5WvY0z%3BKeGotp0_X(+%zyySg#aFd0GdDmBO!o4Ab|5BfF~h<K@h;R5I`&h
zPy_)Sf&e;00CzzETOfd|A%K@5fcX$WKM3Fp2w*S-um=Ko8v@Y&p9=vDfdE!R0K*}G
zzaW4y5I_eA;B*Ke7Xs)A0c?c;`a=L~A%K<;z=sgP{Sd$i2;cz-pa23m9s+0%0fZoc
zR0yCw1aJ%l@B{?#0tB!b0+<H@q(cBNK>&Y40LvkO4G_Q^5I`RY;3^1U2LzB00ZfDd
z-hlu-5P%N?@InCBK>!CJfL0K|R0!Z=2;dh8U>^if0|6950Cz(Ge?kDAAb?E}KsyLv
zI|T3}1n?FFun_|I2Lk8|0ek=fbb$a)g8)`S0J|W7V<CWhA%F=Gz-th|ZV2EC2;f%;
z;1vj9HU#h}1n>+5a2^Ek2m~+<0=O0eXa)i7hX5=HU=;+A2LW6U0mMN7-#`GLK>+VV
z0NWsdPauG&Ab_3_KoSH{4FQ}30Xz%=tbqWIg8(jq0Dgx6T0j6jAb<rBz%U3P69V`e
z0;q=oPJ#f|LjX5G05K52<q$wA1kfD<xD)~y1p)Mi0NOwRl@P!+5WsB^z|9cA4-mlF
z5Wx2kzyJu~5(wZz2w)Zj@G1nb7Xr8p0!V-WZiE2JA%F`YfUXcg76ecN0mMT9w?Y8P
z5WsW@;427V83a%T0pvgc#SlOl1dsv&JOTmaK>#ZufGZ$?DG<Ow2w)rp5DfwR2?0!n
z0Iq@n(jkCPA%J%wfHVl;K?vYd2;d|Lpald_4FSx602&~GyC8r+Ab>0gU>O8(4Fqrr
z1TYr@=m-H6KmeN|fSVzJSrEVl5WsW@U<3s41O%`e0_YC`Tm%91gaCR&05?DYS3>|#
zLI6Ps;4BCr9|HIr0w{z44nP1OK>$$@!0iyg;}Ad>2;emc;93YE4g$Cd0(b}lxDo=G
z0|6vL0P7%tpCN#q5Ws#2;1vj90tE061dss%jD`T}Ab{^6fPE0aj}X9e2*3jY+yVhK
zfdFD5fR`bF1rWgH5WqGF;5Z22F9=`{1ds{=+z$byKmfNw0GB}kKR^J@A%K<;KnDmw
z`~OA=;Cl$57y>AP01iO_{UCskA%JrsfX^U+harGW2%tLzFc|{)76P~v0$2zEya54t
zA%Ke^fOZhTix9w>5I`*iZ~_EyEClct1h5JMcoYIS5dvrm0elGoWJ3U_K>)u(0Ovsf
z*FykjKmcz-00$v}pCEu85WqYLpc4ep3Iga10h|v3^nw6ZKma`;fFuZD6a-KY0UQqj
zyZ`|VfdFzLfJzA9LI|KM1W*M542J-=LI4jy0LMT8<q*JE5WsB^z^f3zeGtGR2w)2Y
zFbD!@0|Bgu0Dgx6o`L`Z5WpP}KsN}WH3V=s1aKV$FcAWH2?Cf20knkxo`(SLfdHmK
z0N+3WA3y-RA%J@!fW8nwGYDWd1n@Kja0&#l7y_6C0c?N(-hlvWAb{-<z)}d{a|pl>
z0sIC5d;$TifdGa<05K52vk<_12;gK0U?c>v7XmmN0w{w3k|BWh5Wt5Jz!(T%Fa(eT
z0mMT92@t>l2;g)G;B5#X1Ocpt0KSF*N+E#vA%JrrfcGGP#~^?r2;d6{;1>vB69mu)
z0`NfquR{Q*LI6V{fF%%s1pzz*0qlYRHbMXu5WsT~z<3B?EChi3ABp_G9{Jx6`QIP;
ze;)GxWaR&9<p0IUe=qX?3FQBL<o~b8{}IUlH<16QA^)F6{(pu1KNa~u5cz*O^8a<@
ze>w7h0rGze@;@5+e;o4vRpkE?<o`D0|2X9TP~`t@$p0D0|NY4SyOIB=BmZAP{x=~1
z-$wplhy0(2{0|}j??V1hK>n{q{=bC${|EX12lBrd`F}g|e=+iZ6!QOZ<bMhBzaIHN
z3Hkpt^1lc2|3>8hN67yq<o_wi|0v}D_sIWSkpGV$|9?UL4@dszA^)2o|F<IlHzEJ~
zApajg{>LK!S0ew9LH_%Y|5qUYUq=34fc(D``Tr&Ie;D$AA@YAZ@;?UopN;%K5&8cK
z^8aS!|77I<8svXd<o~zG|5?cY70CbD$o~V{|H%Jl$p2o*{|?CiLgfG7$p4ne|MQXm
zeUbmok^lL~|9g@Doss|X$p1T#|Lc(dCn5g>$p0MV|E0+PMCAWY<bO5te*p5oHS)g&
z^8aV#e>dcR0`h+>^8YF1{}0Ij2a*53Bmc)E|I?8Fmm&XeMgG5w{C^JlzaIJjDe^xB
z`QHZlUxECehy4E#`Tr#H|1IQyd*uHP<o~hA|ErPzXCeO|MgF%!{trg}uR{I@k^f_m
z|DBNkHzEH&L;hDH|Cb{FA4dK^g#7;;`F|nuzbo?JkNm$9`JajW{|)(Hh5YZ1{GWsT
zUyl4QK>imY|35(fZ$|!mkpH`p|6d^g-$VXSL;mkW{?A4Je}nvg4Ef&?`TryG|3&2g
zMaciX$p15t|2>iaXCnXKME;+R{4YcPA4LAwBL90M|9?XMCnNuFK>nYA{J#qMpNjn7
zg8biw{J$UhpN{<Bi2NUf{J#(RZz2ExME?JU{C@`dzX<ui2l+o0`F{`c{~YB1CCLBp
zkpJ%^|DQ+x*CGF}LH;j8{*Olfw?+P!BL6dx|5?cYuaW;Vk^k=?|6f4<_e1`_hWtMs
z`M&}A-v#-92>E|5@;?swza9CXi~PS9`TsHUe+crwW>m8)KThiVP`_7w58hw?%cp<M
zu0MCqy*&=y)aSO;v`t^_c{lUg#l0SW?UeI>NMCYH%Ac<fkL$i-QkTy<KYi6@4-B1p
z>(*0C4*ZsTWB$_Px2+t%<?_7e78Mo`@&En(3!h(c+@P_KEV!?tYWw4+a>GZ>f8RAO
zcKtI0o78meaQizKwv5{N)XULUn_H&zU)U;n#N-`&@A~<J_Z!xIQ+ns>vQFPVarV5O
zf1I;BamLrv2LIG<diyipxVh;02`wIL`^rfN$6Rpnn;*{d-t$HEKQrIEbpOd;uIfF%
z>03S5w)R|ddSG8x_Q)F^J@MI#j_nq@X89d&FZ(fAd)}}o&-``G=I>q_FgN4woD<H9
zx&FngKRK<gAYtO@j`7!N&nYKXuB`l6d6e>O<<`mr<uAw|Q7$h3L3xw%I_09uv6UAp
zcUF$5yjppd@_l&+%FUFkDkoHat9(`YuX0@F>&iWqqbeU$?kvwkzJ+`V<!;I~<!2}#
zR!*oqPr1HwN_iggS>)F!PnCC~{8fI7a&LJ!%DLs?$eU4~uN+f3q<j_S%kl~2?I`b;
zuM+lX<SodrP;M??L%xafS>@OAVw9)Kdy!Wl&qMjId?e+i@^h49DkqoUA>TrIv+`~E
zF!E94p~x2r=g-PxmES8rl?Nk#MP8142zfEeU*%89uaMs&4@cgCya9PH@(twU$d8Z@
zA%8)>kMdyU`|<*mf6Hf*U!}ZPxw3M0<?`~h<XtJZmM0_MLOziEEBOKPA>^0HH<CXi
z|3;pc{1*8)@=xRiDYuu8C9g`ph`bZ|NXpgaL&zIb-Y@S*UYh&><^S@o<WI?Clh-8g
zO+J{sBKZ>X736!!Ba+u5e?>lld>wfN@+jnW$rqA0BmY7ElzbEUMe?HL3&=x|w<Iq}
z{)xOj`6BX&<hjXHlRqc#MLvo=5cv=CE95K5uagHR|3qGpJR$i{^3vqF$g`4PCLdA$
zgFHfcTk_-Ng~^AJuOz=k9-urRc^~p9<P*t9l-DJ{ME;VzBzZ>i3gtz~2a)e0e@(ui
z{1f?6@{i<E$(NL;Bkx3hp1d=8d-9*;8OpDeUnGxCUXVOW?SJLO%9WKLE00p1t=w99
zp!@~-Bg)0)KPYcfUZ-4CIkxgb<<80xl~*gzQob+mK)IQ6Rpo@rZ<Vhq|5c8wd|kPx
za#ZDG%AMtT$hVL$q1;Wmru+=$!^#Pj=PB1$PAShrK8ySs<*D*cl)uVvQSL1dM>)4V
z9C<U!^Oa*Nhm^0Pd|5t$ydCBJ@>Rkfjl2c<70S)!YsfcIKCAp%UX1coc`xz`<asFn
zm5-#nRDO<fOy%VAJLFp^Z&to7A4WckJQVpN;rv;7tnz#1r}ALrugJ@h4<Ro``K$aX
z`4#e8<l)FWkT)RjMZST29QhIQA>=Q}_fa0Kd|zIG@^AS}@~f2hDpyv{u3TQ8mb@$F
z*79WJTgV5Je<eRaK7{-d`9|_*<lo5ClHVf#M*fMsAm#S*vE)_B7m;@&A4$2od<c1C
z%KPR0$V-zSp!{FnmHa7rZ1S4qy~ziYS0rCTzJh!Yc|`JB<gdslkgp?;Kpus>F8M<8
zX5>G}pOSAPzerw`d;xg~@|NTU$v=^|CtpM!kvunfYVzmgy~szA2O|GLeuaD``E~NZ
z<e$h3k|!kpNnV;f7kO6l%j6@<e~?EgZ%clhyfFDN@|EPb$ODuIB=18Wg?u9Ui1NDR
zm&jj|mn6?fUZK1w`5^LL<gdvWlz$>WO8${ND*2M~bmX1L&y#m1Z%_V{JVW`F@{8or
z$qSN4sr|2<Sh=$DW93oGvz1#b50t+ke?+;s{0HSt%IlPiD#un{sN7jOqVj6xS<3h2
z9Vj<buBx0+`K|I*<-f{tm9H!JRF0~AOu4f>5BV1IC6v1<*OZ^3d{{Z5@;v4G$|>b}
z$Y+sXqdZmKiSk$ZEy}&+;V9>pha+!BdA@Q?<&g4KlrPICkhi0}U%pD%qmj2Dze2gW
zd=2>~%4d~d%ZpK-D(^*Jfjkf8zw(ikmy*uCrW{i_x%>|K7RsBIZ_9^~k0K96zDPKK
zRvxSTUiqm!82Kyma^yqEi&6e6e@cFZ{1$mQ@($z;$a|4*ARkA5gnS733-W!G2P@x~
z7ohxGK9l?^<-N+4m9s0Cm!~D~O1ZT>8Tl6Sf#hGw50DQbzeK)~{2BQ-^0ef)$iI<)
zA}>g}y?iWrRq{pToybR0t}Y)!-k9=!c|Y>f<OeAKmv<$9N*<fMCV6l2!Q>UmmyoX@
z-$NdeycYQ@@(JYY$Rm(PA+Jlmkh~fB5Avtvo5(Mc7bRan9)i3jc|r0|<n759kw+xY
zO`e+kIe9PgQRIQhe~@1xUrBzQJTUnu@`B_E$$yfUCeKBlmHaaKi1Hug5z5<=A15zN
zK8$=N`7QDQ<pIh2kVhe(NIs&xF8L+$m*geMGr}sUl@}!+M81psHTi<_Pvl3*Kaxi!
zUs9fqyc79(^3LS#$$ye(D8EvEkvuwiLGmcI|CJLfS5|(kJW6@Ca%<&*@)zWfC>NLi
zpu9<WopMp-*vbo)J1a+2UadS!`M$gZ<z~uNl@ltzRlchHS2?cob>*JQQI(G=cb4ZN
z-$K5GayR9g@-vhVD<@Q*r(9n-r92P$Eb?oVr^-7~{wlvkxwkwV<=pac<jpA0SB|M1
zQof4vW%&g1c9i$aR|$JG@)qP*C^wg{A>Ty#tnzDlG0Icry~rz&=b`*pK9cfM`8mol
zm6OZwkZ+;9S^2hn82KpjP~?k*^JnF;%I}q*%7c-=A}>ciguEE#ukxqlSIBRXha>Mm
z-hjLp`3CZF<VVPdkiQ_`M|rUFeR%=OzvVN@uTtKtTv<80a(Q`L@~)Iy%af6BAs<No
zmHYtt5b{gp8_A!Me<M#zevAAY`6u#%l-tY4l2;{PMBa&fB<1SzA>@rI@0a%@FHL@c
z@_%_(@~7mn$!n7LCLc^*k$egH3i3VV5y@+jzapPNzK%Qsc@*-x<O|80k^dlnO1_Ew
zB6(5r1>_;fTap(f|3u!Nd=Ys>^4#R9$)A(=A|FK_i2Min74ntj*U1Bue<CkPo{;<}
zd1>-o<XOotlaDC>K^~#JE%|Zs!sNrqSCZc%4^SSEybpO4@`>al%IlI}B7aF<k~|}M
zh4P~0gUEN0zb0Q${)zl3`A71o<V(uak#{0LPu`ilJ^4@a43YoO$}f^fCof1IrN#c|
z_wV%nN5k*t=>3nz%eRm30N?y=8`GEXLcX{2{W#yl_`Zj4-nDD4;G1{#n2CJ9$+rXr
zf8)zs$v5x)G0*TVli^Rkf8_fOz8CVHF?4XsCCNiZ3?H18IebuNdRF?-;iJc8Wu~U~
zJ9pf;tTE>#_2e}z7Hx~6T^`!xQ+tj&5FMXXeejnLc)7h@$&jIGX#<B-byiC1kffg6
z#yLK0bb98{!zYI)XO12<P$&7atc6upRL6xTdW~hpBrh_tHBqKXcC^*>r#q~;^2Mf^
zCx*Aa#9GJnTw>y@n^?z=ywhq?cb92d+|=?|cbisK%}i@=oYiLSQj_32#yW26z1HzL
z_m~qJnwz$PW33Zg-DkC1vCN#56mKPNTyEO?Tbd5FEv%EL-*0)XIi_P(YtzZw#yVx~
zT+`X-u}<9@uujV<H>WqWGF<}4TW7So(K>U*P3Ekm6RfTqD@-?kg6Up+oYiCcJd<Qj
zvU)DO)#}yp7Snr8JF8Ff&F1Wy6HVXjw$?d6&A0lM-)_$JoNW3BJ6PxSyv+=#Zf~7G
za)EV0U8T9OIMMQ1>r8T0XOrSR)k<CatV#2oW)0l>oHZ!tc{8}-bTcI2wT8A@V_mdj
zt+_a<qm{n#X*0~<$qcVO#TqgF8RIwItdR>}wnlZ_U^3QpwK9`mHKS{Km@(Pit+7A7
zVvQ?*!Cc}w!(1BdVqMmAy%}G9mUa2am#i!5UNl+7XPRu&*UDM=ur;CMBWB{7bFAFt
zl_syIkC~Kxwl(>uhphba2TXydm$@?7+nUnzK~q?rWKA6zw5HXqFh#{ZtzzpbGrj6U
zQ{uhADqZ`eDf69g&Di>cbyd!4b9KW2Gc$0WHLKO*)-@|0GuI~dw`OmA)LiF3*IZxQ
z&$?myDl1@ZH|14B%pC7fYwp_5Ooi_vYu?t+ts8T`FgG<^Y~}~jt(#lzux?rLrMWd}
zm{qy)E3?2q+}u_>!n%F>*QUxOTMHL%wH9@(F?X!-S&NfDGD~Vw&7IjP)?Gh+Xe}-O
z*xc<IXzmH7S@-tbW|mbCw(cAGsdazdCuVu^AQLo~S}PX5V?EIEUGw0Y%dC~jo6SQt
z<IKa^mspSd^tQFC{C)GN=L+*!Fw1(p=LcqW^?2)vkz1@M>)ta@6<=<xv0gW8t1`^f
z-ci;wYhN?#d?T%Aw{Ena%c(ZcH~7u^z*y^rR&QA^u6WbDlr+ZLu<;G^vVXLBr8d)g
zb^0b#Z3?Z83lCbab^P1BzGkYmDfu7sM$I(yW_FSF)=!75&E*Ho+n#*$PO!jwx91;b
zOZAo3dn5m}-mm-1d{8{as<D1GTdVTShu&Q4qqY0ZHs56H<E_72pXB^zK5dv}wg+;o
z&szOteZHc>e36uG?b!H>`O-hpd{sNa`g;1$ys72~Q&)Ap+3CH(s$ct~+2xyUg|_aq
zzRCICeA{rH*&VpX+S6*UwRgpL=DVb8t$iDJoA3QI%@4J+tRJWEF%9Nw>nHwx>(3p(
zF~6+2%G#eCGQZZ$Fu!G&S-=0Z%Q{eAZ~pL<nm>aj)?Yn$nuFETt-nXsS^w14nnV1%
z^<jSdok!qcalxenM~x5;8k@$S2ry=F@^JgOI8yIrH^yIE+ps*;;On+$hu(eCK3Lyi
zp5EPHg1bGQkvsq59~L$QUf%8Dysu@jeuHOuXoHV;v*>r5lYG3ly-odtNgX{8CIv0a
zJ8I{jl(&q3r|DVoEq|xHorh~x_xxghH`>qpdVKS0qqBKGo*7*i<5{wc-;r#t&+v5f
zXm9M!81Dq$+0n7q{yop0cYW)PIi<EEzx%1W4^UsU|Bd=slUerz?+sSF4rO)Q)3P>L
zXBv3d#B%<gd`+-U?@IBFpnbl~oqy{ZQ(dp~6_))d@Mw>CPBfl|!QJ-EHp@f2^Ygoz
z+5An@0N+*oE_iXU{`erj0~@@V-|xIT6o}z^b2IP4y*p&u2kSbX%>6v`L!GDJ7;5S>
zJB@W`$nuz-Cm6FcII_I1A9Wf}RVdoCvEK49U!FkdYs-8GbL;OtoD^+hcOEq6yKfF1
z+WRHn<^pz&*VC}2E$#F98jQ!&aEP`g1?~$)1^K=HV*1aR86WqKHQ%M1#r)ptf}K&u
zQy*yIiPk$4)_J$J;(g^iV+>>Kp{zF;eSft1PI0{FKIZGb(CzNE{qE%bHeB1M$#Q;e
z`sU-Vrfn+M#yziddQWsy>e2B@F|^&krjCbKJBu==3H@U{w0;ioevml+##dbRBKjPx
zKeR7czpnF+I*Z>!Hl14p4kej6yf3yq-h1;rZ%nY9@tE@)bGIqhsYAc-OCR+9`NQ|S
z$h}_z_u~aJ{7ujW_Iq5^Kl)X#{@Lw1s()i?TbkRKT3zQ2)~OH8>BB6_8h@~EE5~Dr
zJv9q<Hr({`?%zjr+oR)|#cM(dRaGJTJ<tK(FX;>FZ#?dOG5B%ab4@<3vpn<py9^6L
zcQ-$#mi1j%99$A>vV-;fO)~qv@|pwQ*~Hl2THBQS>K+U9-Vo!jKb?N0n<e&`>s?XN
zW?Lx6yDiitX<I1D!*@)et|@VJ=Q(w;9E<KUNAH%|+mv(aul@J!xhBrM$L|Yo<DI<k
zh1Q!d>vTMd>zaGt3q^y?K-C)uYQF2u$od4&eX+FHiZi2_I@4~Qp)c7t?rd5dsBLb>
z=>6OM<5_3wV;ud8rhQh`%{vQeZ!_Xon5*zPU9a{8PU77aoWH<c(|+~_e{0Ls)+cIA
zZ-06B!Q^gxwv{r!jH3zM6w=zQ;r)VIA93DAp>=&eWPN1R#RqPhr}Y45+!9_p&$;JJ
zAJ$H_nG>Hhw>&=SrX$u)x>;n8Wm&Y=?@h<e<{ctF+NC+r?_R4e%kZ}XnCskV-M1>_
zYwzsC_&^}^5_>P&9ItY1EKiUwkF0Ov4_Zxp!B#`K&f~p{wLP*v##@n~clpFH&N1FE
znTt0<u}NQstfV)XyDvjgU{f#}jPcKd3;jEJMMJyf3-#Xg8*8;r<1{A8FYoqIZ-4$?
z+CQwfZM<uQ`!Y9kLR(rd4{hxD8eBLhw29A~IG4-k<hJ6x*Xr{5JfZEJ+KqfJ<g<^l
z*YRRLFVnSrR(YYyR&p%&f#sn>>WT5(5{l#7<Gm$R(sd5+O}Zsi%<+Ct^ByQZ>mB@l
z@2&j3%!MJp=T`RE!cd?^>v~_`*Q0%X=e99P<*c{X{M~qtcbyX*==xe4<1G)FmchCp
z-@G0<)Fn#$_}0)Q#x%~{6G|*u9@>$!Jk-Ts6*@)x$84*M4Fv0!m}a#<Yrkp_JAB2v
z1{UmW#u#ZYmqs}p6bDzuuy%8qJMo;j$YkGo91ky>qxMoqn3sHf);-frm0d2Hbr@wn
z4b`#d^gJO4*xS^N$pxBQ%u$^0o={injb&|r%DU6_UAbPd#azF@n&x-y_h!-uQw7(+
z4e&0{9QCE9E|&H#^?7S~ui<yTEau!-u~T)7XN|@14pN?Zw;1zD=n!qN%qPczZK7O^
zc2WDNLC*-rjlZq=o%UO_xum|Hz1W1Y82S&q;oehR62m>W=@@m|{c!KO?)VzU&bg=B
z5RNlV)p7rfc)9KQ{~T&J&+Shf&)@;9!I|7I&AxXP_g5Qvj~dT(aPJV1G2H7n%y%<S
z{lP<rn#b{s^(l^VV)p7@V=ik*;$aX=M{0Ry)z&J<x~#!eWi*)VtcK%y(Mr>*m7Zy>
z_%i2k+Mm_1GCB}#zqh2H@yz7imC_V3tT|K5H~T@{6737tom`!>v-cL(e|7xM#Ex^|
z-twJZ_9M^#7o$8Cj7Qb(0TzFUQ}3&(4TKtgoXc7dg!Z327e4G>8|Mv#4)ox?@}7>h
z@f<(Map@3`?#Xq!&*D}A-ltq%x435@q|dbp&avHnK=;_PR#l;zB+7f{hJt+F#OD}3
zFYXu!bvV?cE^y39ap7F`L(gVoM(O>4&4bmNTc<y)!@Vt&JUcD#oG87oqGeJv@8eze
zt*Kqi-*WHH`%@~ujWGdnN8Ntr-*V?WA*o`g>Uiq!L*IEki>Ys99mCx&fwdc62T8Oc
zJcr_6^-<T@sPW_);<b$5)9APt)n@iuz3_mv1{#Qbi}cv4)m+8#w_K`P^BiZaHTUAu
zs$TjV?Q?h+*P>k(dN3v_uuGayb?ks!11IyYFvi$wTVB@%G$&PsDiYw@lL8?xpEtn!
zQJ(TTFR_O`lG>rX-b1;>wpF3(lge#<l-M>9TH1!cSH$rOP<@Cq<)Nyma(kSMHNG4h
z%~+Iiz6`!sY&zcYt?5|)t;P7Uf9qMBFOC=Av!69Cab{ucp}6YktK$OE+BZ=gV|};d
zc!=Zmfw+KupRVC&#K{|Nt(M(X&krBt@7FlIvmcI&r|m7#a#~M%p3o<|tlk5bz_B=v
zG0ydId|nSX><}+<EO4?@t_EKA9m6}W=~ph_F?=r_CGE7tZmY(-(l^i6Z_Bv8lH(0A
z{(3m9c}v<M?OV+J#wG>ps(edAi?f%6mim{3W>c>-7ISNt@oWu`M-12e!FbT`y|E@(
zcN2A5rnnxh)5`Lt@v8q!yH4><vG3*Gz5YJ5H=Z_o8M~Hf*)F}9+qhs|d8a$R4K@$f
z`A(ZtU*2i%x6XR=wYI#$Hl+HVZ5_oOBgK#Hw1+GCX`;%oKCG%J=e>-TVECBcpBwL)
zgO1bR3H9%c@s=N6PxCn!WA0$w_*>{bf_0s`1!`0H`?Tzxopas})D?0s&)d}X_M%Y5
zrpkK5XU&scwq>B!X9erZHmW@Vd+vB{y%FOnf6aI+-=N%UjK@3L%UZjM)KwX!weGZ4
zV;Eyt>q#GmvdL*E(<%UZ%!i?4Js*blvG>trybp-Kqrx7RUe!KPKbtt%swHLVQ+<tD
z&T!0$ZR)N$)m3YA?i~L1)Q60*zus$tb6cC&<|)>FUximI;SJvJr}wkBtLk0}C%`YQ
z7c~u>xG|b_i*6iQufNB{v2Oz>mUC{-x9F3-EvO@wbEfUG*c&=*jJ`qkS5&!W;wob;
zu4~4*IND>HEeln|1nNz*N_!0SOh~6)YY!g!PTcQf4B}arajb`qw8zt4+%USq%!ym<
z@x+^zCmYXFctd$g7x+AeZ{zVb)QC%tp`2%Q!)kq2K4UT(l=o@R`Su2*W2%GEdWVkq
zQESt;Cm0>aG5Xq^heN$@cQ87hxCybw$M<b8x&^V;zfbWu!DtV$K2wHQeY5|4{CzUt
zd-ncs$8q+5|6}3L)qd@XMLb`Ykh4{2d|79U&^&zhuHl_J4)VigJNCNRS;+eDVk$z5
z;n^0(Q>T4d<rU|m0g8Dx)kf`%H&?)`wR2eyx8N3PPMVu)<(uLyy}#(LP<+QZwSMkt
zRafqOz{;q5VC2@Dnr27MNf>i#;DM1FZ)#!2+kEepK4f3(IhrJ%OWMjcTSGCmTkUrk
z#`l?98%4azN1wdRPc`qRr%bHJIp2cw7S9zuBNEVSRXk6dvOe{$CGu_k9bW!k?ZVK5
zJp;9-_9Jv2=RMZW<680T@x0D@<vnGTr7!JNho}0;Iu2iNaeY!v#Pz3eeKqUVx!%qJ
zytVKZ?-z9Yqxnzp-xo^vRfWdY(*ELL{R7p~dkOk`!Oa6L66$%saVuZTQT3+ywzF9a
z{R4bXGRsfp8_V^!P@qRjCtr`0UabGUl(Ds*@<m;zy==VmLK;7562D*Gr!jU;7a(so
zZR^{z=9rf{J1<av07ub|Hde88KcB1k&gPr3()iwhURr8v+Of=KRVXeyXvM*q(wH%U
zU@PfS`rJ-!h%ufvF<PH3J@p=6MO3`6qP5P)fvRhsJvL+Oy=dAdYl2qn8rsZW^m4uZ
zH}BOJ+O(!)4cb$mgY{Y5zb*Ioa6kL`;pQ!Bx1K#Q;$_Nu;7DV}*2j3}**S{Gvw-I-
zIg01aP%Cm3%ll@iH5di90i(ef@;-5{auhu9y=s>@1`XOyf9u{Jn~3&UwC6n9GvE53
z+Y?0@^%aeZ_F1s|7@kk6C!1^HxK?cp6x|pV$eP#Mr(^Uhtk)UCXgrg4jAQ*N+C!A>
ztY<)wF%Je?NvkyWbN*5N+~oFiliSZtZa+7LV$jFoe#ZH3*|`~xv+v9EIL5Tn9&NtH
z(wO_5_c;e|+1VV8eGF^2J<rKzRe?IZhrLzqb>Xrsn0C_QD%XZ`@X+2u$^^*wRDX<@
zbDUTCSJCULNBpXDPjf8B7pP4jx6$*g562V8D|K$Yr=~6ntyZesLF1`)%9z^o!5Dmw
zW^cwlJBusGuf-L%-e%2v`96qO6ivTa%XO^lBiB0Dv%cF{*{t^fpZ$FM`1S_tH&L%K
zW9rlKwVIOuHuY)DJ@p9>&^CL2YK_CwCfLT~xrg;OhIw{#V%A%Xz23-)?e#`ZY_B(R
zVtc(EnG<WT9mH?ZURlo^d$j-5Px>3L{mA(!+N3_;PrH_~R<!<`wk~HqNpm^tUu}pp
zH|_NDtS1+<n2%N-uiLi&pZR)IZ+WfZ8ERM$@|-O9bCmfomSfS;F2=YR>tYiZo4R;B
z*EZ$7v--O-@L>G~%Gm<7^_UcUoqX`aSTI`k3RSOA^$Jz5Q1uGMGt?d8GxLBy7E$-<
z)EyTH)IDu|R=3{sSsg!rvh~mZ^*k{jN3XyB%m-_r?lw2~3+H-mS;KzjsN?ahJH7*G
z`}t^KKl3GxB~EVZRhdP0nIWuol{2Qi&X48^myy1g|C->tFXXAcFXXSjGvs@tvOf3i
z%6fnGjUm=-T{ia`SB-Y04&x7mqF5Ko`8-K*V(Z)Lq``gd_&Yf|##-@$ovQ<(0G{=D
zb7Sag<|7-_IvfXPn>*oHC#RLJR$KS*u(S6T?U4_m^`Q6IAD|Bj=m{@<^_{TMuG{%s
zZh!W0PHVL#ey`T5hx)`VU|a3A4YWPpM_xetP3^K!^>??`o7zh1=NWx`&|>`b*lMn4
zHqTKwhJ1qZc&OA@6&vd*kA|<wU!2%?Qh7A@iPgELoYP*7anA)J&Nbtlw23EtUAxBX
zj^P~q)!fH9yPfJAn$p>8POcN~i^fE`eLQ+k8YR=myTHe5o#6Fus^K|1zAkE0Y~WCB
z)SMR8mF4l(74tfE#_LU*YkR%M8?1k>k2o%)&gw(CYRmQYD(2zsm&1p4xg>WUTJu9l
z#=+MjVfq@QPkc9v^6J@M-K!ZpA?gq|LetneQ9c7$0>e&qi}FK`)YSgoE*V8LN+#x&
z%<>LC>nv}2L0O)+S5i{H>Akz1)9VaxpYFZ8_xgV&|Bpr~`E<rNCogA0fw9_asQX@Q
znly{ETE`?<$5|&tx3x~R+C_C}V!D^knp&1K0W2$VFhBgMB(Jc0S>DVt)4il9H>WJe
zba(zgp|sR=pI9_?YTh)?O)DzP>ppn+=x(KDITNRt?#ZKub<Zg)D=C;Tqb#qKTmK(_
zolHrs2iCa#)rbH0D}zzpFIJKLrGE=R4t4me&)ZQZiHi{<_Vp@<UNEP+akz$J>gw8$
zgYK8g=!>5R*w>*I?5}03qs$HjR`@G?-`*V1HQ{nI--t5ndC-Ty!u9DE>PPrX<@^x`
z!XJ|<5dN&Po8Jt#)VVTzZX_Z1EOw4M<+_9eFkB9ydbn*m-9UXg`rv+r%Lyazl)F31
ztl@!&zPJ0Q{*px6V;t@)p-K2B%CyxaxnJS>G*5|_88gJiOyPcG@`cO!`<=pjaCn3l
z!REqImi_NF5})PYd{B|DZ|h=L7yAjRCtXNA<Al^xCZwJUA@!^jQqOwfnIH=xiVoI7
zq$;<bL`hidVplq+`wbBO$P)vM>SWAp_jsjyJgDO*S;ou2CjP*A7GBg~oC@Lf#w2wB
z5zKvrgIKG=lPxnqNE?#agSzhkFbYxb6RtKUO?WHgCFCC4dw^q%*&%#|b_&xhvrD+%
znBBq;sV|B8Vl9&{WC1J_2KaX`Lhe%|Jl-+~z^Ki}bnXfE;Hf5zvdnDZR%12^&tZKC
zU*j4`HEM-1YlKf3<7J@>E6;Y3e|V$#po^7Ut2l;*E-VHU-!i7lK+sG7T+DSb;9>$}
zl*r<U84R9*n<Zq@y(}DES3A_feEOoe>SB<3*9-%9u@3lwf^fHx^GPEdoGIjZrr*I$
zLeB4Yaoi{;&K54<-viMGwL5M!F>~n=@+2=5rZBF;Mf?pNA!E5(cnjAF|6rXmSBW`1
z?1Yd<zVI<)R)HGlU5csCHx{J63gJ)O=MqruWbGxsNB@N7#vB+AKFNCvF9#WmRYKw&
zZrtw*;z6`e$oXZ$9mZ6HQC~2hE(WqVei!>I8>IePA@%Q~t%*DNw^I{9u3zV3@kHVh
z%DZ^b#eTWY@rpdKDeFo20pmXjq+MIWIN3Sx%XiK%7IHqJz`><L+PzyyduLt=a{p=<
zw@h<lQ{-T=@Nf1xZBn_FE~Y~u>QA9?r7`n`8J0OHTx(398Q^x>C#1h+!aKR&Rp8D1
zeJJ6ltm~^C>^Bqq)|l}wRtPD#Qb@UKA$1>g(LalLII)mADy{+fyu-!xYl;74AA?cJ
z#$?YXX05Ci4zSFS>p-rbDWqJ#>p{jPS4cmX3g2XX2{}LR2IqW*kn;!KxNE>Emn)>)
z5c;a?<_l?8tsDF15YxV;E+))%%4G_<uEC9mR1nk7#X{PdIL|4UE~MOc;R%+BzY%1-
zb_w%Y|MNkf>;u>nnwRlH=4GakdD$mqUOK~ZnwJ4W+LkM1Uh*qJ#(Tby@%Aimu*+>A
z_epoLOh~!KLdvZXGB5jF^xaN8oLETz%c?;7y~V}x3yJARXZEuCSuCWV@pph+H$cew
zgF@z`%VLo69xr5EmkK$bxP))c4-s;{+Kn58l<PvDR4(o=CmtfCJwZ1%ONnV$z{P_?
zt{ZSS$aUL=#7Xynqj}B<X=lv6&hb7%%2f-QkNrZ%Y0EN@`7rl`%*Q4n`^U4~S%<Y?
zVzgz-g5XT%UD%&LKCl9$9>0)yrEnL#{QyY$RbbSwtZ&7vfmIJW=XVIbmPuo-6ECsM
zc2Ligz(d5Ru^)va;ju@+*6fp2AocDS_Owj)qt5wi(0&dH&!Ife#Kd^kvv4Rs@o?k9
zCyA+N%NmgT&R^?b?bG1ztfS|^O4=u++%6&Wv*CG=_B99@tEBbL`D`KQgTiwyvqQ*v
z-wV$9*+P!j2svK+63AZ3-T>}}r-k&V>SeG!<0kxv_4f+c%`*L7b+A_W8}nKXc41#_
zq@S<xd<NC71U{?&0m6N(TOsY=AmsiB-SgvLcaAR;a(uUt>uNTEKQX><fC;Qy){d^<
z_m&f<z3s%FcR-FUb@3o5T@>@Kg9E_CR+gFRVy%$+GPgKb<zftbT*nJt+~i`?`y8jA
zi8XxFukk|mQcy@cw+U(2eAbBCzez|O_n{LP3%&5kN6zu2Z4S;BHnYs;Pe88od<rt|
zG25MZoRIq03#o6vdpzwk=lD1w<FgplI$kDhL%W2d(Qlt~{!GgRzX0jKcLzv2_6w=c
z{}o7o77Mx0W+BICe+|-}8X<8)trG`?#Ea{kc%P8#(sw$?D}`LQUC8kP^&sPB=#$zL
zC!~E{K<S2jA?qnK1g_(G!P-;*Xa4}sq#r`|@Aw~`c(agr9DPpgMgLq}CFFRGiwQqF
zafOSEe<A*e{UfB@=KUc2y^b+UWDR>YxA0Cndo3}>GV6uR{rm$U?bv+KIX>=hFqL&H
zWY4xe1X52xNIm<6)HB|&7r2kd0;$h~RuTq<jQ@DFw9b2(d-bD_i{phHpXuT@A@?`O
zIJmzBcr)$6f)F;eaj*+(Ht~COLt7{I;S%b6etQRlLeBT=0IuZzLY^h*ok03AU&!97
z7SjIR!pB*Mr|{3eSvzqquI$WluHP)=`T^SWT%Ru-&UJ2_bcPcb3$Lb~!ddVSYcY|&
z%yw~`kpAv-@t~0VCY}YBvd&15RR1QSo+GRk#Z^M$8X@)jyMxpp5T43-lMAR^x{z{<
zh4gEikoylv0=aLY5H6T6<bE53^siP(|JE@#>i>EdHwZIj^f<V?H|4lbLLYEA_Yo5B
zaO1?YiD}<5A?@2I<o;dyIv5brjw&JjUL&L(yIqVqhj_SU+V%r!*8m~yN@I`N?RRlz
ze_}XqlaO-zgp})gKA6t>6w(eK|0qszP)K|7FLdG!LdIuRGRSkIYYIp|_6aFJfHkl4
zt3i#&8W&^IINq203Mrp9(7|Oc@~^z@<C#LugOGZbUF00E5pvvru@kQn67Lq$-hA$@
zb_Ruv+YT283?t@##X`!j5mN7dQ0+V5;z1$vWf()@I`*pgWeA_OKdLSP*^jd?1>v=r
ze9FOrULkzdbqdGf&1xaf{mzBpFm!kc*bE+;<s7dPa(uHJ$6Z4l50A_SS=0XOLGF`w
z1IQRx2b}uL%899G)f{jn>qf|$T3G@5c&-ZXW&h7}Fd&4xYlY{Mcijlm?%ngLZ!GP(
znV3G#uLS9P;R2BL6;}nqBL{`YvHuo=SMa=aG2u>P_#s_*CFA18+uS(rF6Vf<ka87n
zyxYahrOx@)E_S_}csM#(*pGcA<hp%A>hFAyb9|MMxYmuA-cL;b3zvianTMbg?-SBb
z{|b<HFBX0bFFoL3?Sszo?1w<gZ5LXM^CQmjS{K(pN<5VP`j}I$Qb;-fYNy<;C%``J
zlP8_?>xG=}yv8{{PFTcx6mmR&t#f?+)8M(RvuB*+Yt}i(=RXH_Cr=h~-uJwN^MzbL
z;02KWB)$ZmLS7-H+%^{zH#p_CzwDHo`6~DzJSL=EVm05?vt=VlJ?XDI#}^AZzIhYa
z&N8(w=Dy*S3%D5n7BS;hA*B2cA@z3N?8LcmgVY;val<>rXq~q2f?Ss`r2P6VPPsMj
zIoS4na1!(7V!n$(A@$X`@c|+0+xr2?{l^K3=eu#xjW@gT>>B6#^+L)ed<b5`buO+F
z-oZL^vCl_NxiTT`T`7d$b_r>Bmu=4ZN+IVr3pt+nv2#4;6X&>3$aQNz2fgUpFLm59
zNy4to$G0H+szKNQPwxiLp<Tj6@_}F3pJ)y98}VQ8hfwViqFZ;kXnuEM^9RWN*15PJ
zw0X_NxIc-}xA87|TucxyVch@X`b)U}Z!nATaIwojPMq!HG8ebG=sDz^AL3$#iyK^=
z853pKTiXPr-nLC0%yhBR#mz37IOqHT7t35+<Kk`?XU6kSf=*{091D&`54PaCyVwt4
zR5H&O#W6ewTM|Eo&Jm6yPvu{)D&BpZg9DBSzu`FsCK~wr1dw&IN;r+@xR7ye+ZJqr
z{~$aU{UL-`2b>5}ezB19D}|Kr+zzCCu8{J(g_KJ=38Y-EkogP<DPJk1{2DiI5OUps
zM3C!pg{oi3b=!rUk8kgs?*gh{Ny0wpL*WMWn{YnQ5n(aUF(H~Ww}Vq(nUMQ$6LSBA
zlR@fTC8U3wg`D5u1-bu0A?Igy1Zh`L$nkAL+SMSW{6Qi0c{@3Awvg*q3%PEakn0jo
z0l997kn^*JoL>s6KS3e=SSh3*YlQS;osfPE=<HmdF66$6r-EMc6XB)oyVD%pFXZ@;
z(?Oo+vxUU*T^#fYIbICvzB7f4V}<Z@_(e!NDusDG?}X<u??T$MR5+bH<qW4DzmWPH
zgqN@m&vK5Z3pu_<$npHHT*v(ih1{=LNIz!_`=i5z^s_=Zj&=ySZ>5m?Rtd*5&)q=k
z86f<b=aG>16bhebJqyX1Rtw3Ew+k;ozjOyX!%M=k=zQUB>0$?03#qpjl%LSx#xr{m
zYaN0*Uz|idh4Bz}V*LoOWB&+Wz^8EI9d6tp?7)8N37&?2>;<0B&pm`m<V!C0>rMS<
z(=Q?S86u?J=|cMD7t+r%F!4L?@8Txm9%GXFfX}gx!6<UeEyBBbo(NmA4u$X258*`W
zJ=;0&7jiyR$oX+X&YQl}$2!>}Wc~I#2V~s_g^Wj1Kal5ArjT{q=UlF%-Tj2j>i{9`
zr~(tuMRy7rhwT0!<52D5L18rO^E~JLVj<^;3;<a_WkT8!1Xce^;nU2sFpYT@_GO(3
zJECKS+<$|R{#Og>-zFjb+bpDiTkPZLpbLnpce9Xnx#mLd$9!h`K>9gbn9KD-<~=Ey
za$nG2q53Q2x^1AY^QC}6){l_u3sb?f(V1z^b@4*3OBAx-+79GA<Fifp0?%I;%LWnC
z@0CKvVf<i_eY8}_cyAXn{@$U^@$o{AFB5XS<|5~K{Kd}kbRoxc)1Bi%A?0g@9A7`o
z>Bj~k>#bV&GyN87e1z=JEkf2|(r~V$-CKn8dxwzrH@LAG;l%y?AbK=g$T+SX2{OO4
zM}hP&Jp<G@30Y^=Le^R5Oy~Gwq1q>;y}r>-d(woAyI=S+>sH9T?*ql>X=6azH$=FU
z^>YcBiY~hp#M9b;8AyEt#)Gt@!o}4t)(9E*u9t(<mn|H^zH{TnR}j<A147zgmIczz
zr9$dW%m%rxa}G$k`9jLYOaLj@MM$~M6KQuxV&RG0PY7=%3EQ#Ggj#39yJ@emCF3A`
zntlpd*F%J?YrpV#)~^sA94Fia-w9h<CR@lj<qF}!d?CD8EQEi`gsjU7;TJr&a%rdb
zgOK)CfojkAJO{Idte0FN>!Ns)b9|Zb7v|H&eeUsblR5qX*9&P^A((g(`dY~N#^gKa
z<Amp-<Am_PM@abuA>*<V)c7VAfUK`vVJ`drO6T}?7rRU$X51GG*}rLp;4bbjWPSr~
z+-0g$ZijFn<2%hMw?WAD!6N7Qeo*~CAY}cSVvzBS6Q<E#A$;T&G9F!p+UI4?^?g9a
z|Jzrzq27qEXcHX~>F4_~N5!#6#Z8Win;sR%*>~98n}4*#nO4+z3RpvYoEu*V#`WNT
z+)C#M@$q01{Q+BZHA89IKEZm4bK(l(l^)igd;U%^{Ka8IQ8RvnT^;qsnm38#TJS%&
z{`dIUh5HwSs-H*N;V)hPC*SXIUOiWPNGZ&CFMcvwU*&m}n#`V!?HfuwAmV-*#FeaR
z52*6_;Qom6*Ao}Fj52ZVdF%nRh3oZ?A=KW7i5udh3@NaE{j0<)FEJ+Djdu`_L${=Z
zs{a5OWX*SW&m%95m-@rw!(-oUIVQ?r?b_v`Ewd@2y(~-nYZvwC{#UuN4r)9W6MJ>B
z+rHJr`$rLjy8rWF=d>uZx|tK#5I@ZLc`2gt`+?ZU^Elo;AIlP}X5DkCeSIh5E^W}E
z98!Hfi5r;o;zTDNOq~A}&pr426~r4}WDY=;F9U1%<~DZwEBUO+Q`^-ae#hB($;mR^
z`>!R={e<V7Ti<5l&hSyO8}o~wW-;+>H|9+khrd*3H{w;>8|zOcZaW-4b^DV;ypK9`
zneJcChiy-xzlhb|#l-n=SiD>QN#eLG(Gzq)=U>u=?w9WOE^+mS#`<;>S4PB9Y{_kH
z!{=knDa3wql0vqo>hncxS=Bdzcy~nmu0QJhy>47XSzW)HI6dNiZxfF%VST#o-$fip
z-Wc9r-x06t9%a(p>#Yci(Ea0%iaQcl!+ZH|`6S|+J1n!zt$z@48S6XD2UCeR1$d6R
z=jRhA-bJ3{UcZ8Pd=UT6jh`jn5Yhe*iDU2t!uQ)l-1b3qhg;vD#C>Rg_<kovP@3A`
zlepi@%qL^0@fkuKNBhJ5A3@wT;(k{V&yI)}5r@B2-wNWT?3bB*R(;jPxzsn_jXxl+
zh`3(=26e#KjqT?bw@o$cIgxhj`nJRY_@mgp{!HS7$3~fe8xJIIyPCl5?`0|<QUA5X
zxe@VV;#K@s!%DaO<HX@Fwf}{q;!lYSA;Iwde<O}3?^^HfzZT$*ZjIyHgE;11d@^_a
zUr4-+Xa5%JR)2Dd*F=<`N1U*WJjgwNCvke4D1NTvlz)sk{H6B2d{q1aabZON_7HnV
z@$a16{xxmR`a(BVajov(iFm_6_=0{Y_7OMWj|ANFmlDTCte5ME+pe<=zgupXzl(Uw
zef)ggt^X<FmFpcIP<`(a^ZQX+KJZ11`J6cBQpU)={x@QOa+KNT_OJCZlpnwwg4{TX
zIL=)^;@fkH_h&Lb?)`=mZ--x3vu<?1D~QuZ;Dfm5XApb%`9Y=IpZgWR(#U_W5NFfB
z&hGiIiN`<8d3XK)NnG0_%I0C!-!h)_XGhr_sQ7f^Et}{M<-~_RV(%&3Ji%$tSmH|V
zx618L9&sFf)_|x#g~XkgqX*slT}M10(a_Ib@5_nB(fnuE|2*-5`HlPkBjTDd+|KRq
z9^$U8;3&60hlq3W1~*WF+S~eA=DQGG<&M{x#I;v&4^ZbX1Y`O%wr?cyvN1eg-1-ZN
zhulwp-TLPcXQMe;a`yGhiN{5(zZZyipijbl_7-vYOY8S@;@K_Oe|*;c_Y&_yPnWrI
zQ?AY2iZ9}hPkZ8G#=6jryGr}GU#jn1VwDY#*DzvVM0+M3RsK5S{M*?dT&w%vrt^LH
zH>+;Enz(}Xk>tj26W8z=sc)D6lDI6Q{$GiAzz^a5dptSDmR;;Q_xiJl_w{4^-Ro0{
z?PmrJ)_S;zxEMb0x#cGj4|$O1l-u8{iTCqaw50WR6LBJ5HC5W}xu3Y=?#BB+MVuMY
zzW0ffSPz<F_4iwykAjEX>kkp{XCV8z=a1#{5Il$Z?)}do-X5`^M-az#ps?HiF~r;O
z0A{=Ey^Oe)^;qH7cO9|kSpEFjx&J-HTx$58O8OIHo+e&Z!vQ*|{(V3kM;;cg{}Yv8
z%Fl1y`hFlzpaRvQ@-f_N2lE$j&!0l9FXw!W=}%l$8f8{-O#L5DoE9-YlZiV=#IuRB
z?{xlst;*j+9RA|gW(9Eoema%Un!o3X53pW#6RZ5k#JkSHw{XYzN8)PQzsWt{jAvmV
za+@7)+<|yK*M;@dxy0EK?a9#j$9W#oA=O_@9R5;!77*`>SpSa^$93Wa_gDMY60dH;
ze7pSe7V&_4cs@}?^?gMg{!)Dn#AzQluGd(&cK-3`Rd@b65HE%t;@tV}OI%acs6U4i
zhrd+cXku?yKFoLKEB~nTMa27#i!zxMQG2RXUXz#LlwV1lNkxA5{PV<ZIj<s`|M!Ty
z@-s(<*uMS;;`R7q``z}%QBPIGczTJ$Uus`>VsFIxfy9f6yKqkRPuBU7RPNS4kGM}n
z`IW@J<H?U)etm_wb|oC=mj9GEk(^sPM*Z7QTufub{W*rjvF0|~&;4}1J@LLC@SPiX
zAs(01xSx6x=k9IPOBWOSn9Q)=xRf~jrT$GOPKs#n&BPmc9<Ae??sq4#v|o5UpCT?E
zM|)VeI=`7Xo&2QOEx(6&bI-<nQJ%@V2WXRfz728B8g!(~AEy%UAj!*j&krD8+?9Vb
z@5bYZv*+vQEzbQ)iS;&v%oCjWM&f=E?SGJXS(hktz^(rk;#Hq9Ui3-r{e-wSqCW?S
z<KA`lh|b4R@2-Qi!JVJ>#ObFS6LjaN4{?`>{;3`NNn$rKK)QY^aoj01o>=><Oyw)^
z4c+teiK_>(M&h0FcN2T~*=V@EPZIAdN3Xc+^KIg^2tD{c@ebzO>yA$ocrrht|DB1~
z_iCJv;l!)>8R2-hd>-*i^mL5dpX-QcdU&3>{arx3?|o+ts6Wey3wPriy62xEt~iPF
zZu{OPPTxZR-0}X3IKCh2+g<N}5f_q#dwCA3KHf8S_)F`r12NT`U3_albs?_W)0qEW
zNW3|sf1`;#eVAjnKV`&mXA!vLeJyeLOZ8V04~e*b74e2sqD-wjAJxRm`Zn&TTH-Dd
z<zw4XKR=63bNkncc-yt;5BK`>h?kO&h4*6yai5LsX}A0&U4IUJqAlwGOya5r{C@ZP
z+lal)*HZWV6T|^O=iT@%V*e&b!|3`?iNjy&-%rFlxEIyg<CnnP)C`L<%iQtrM!fw|
zIKZ8+fyC?3H;L|ijwLoL*pKe{0%HB!KSQkfxPjO+z47_DgxDW3K2H;Gfp0dE2djPW
z5U(D?Gm|P5hls;pYVYsFGb64~NMwAtmpY*RauRW$jrf-C`1K{;L_VBE5!IJLToxT=
z#<}Y^pLjLvVWxZjR^rUw_%m+2f;jx8`@cxMX;I_zG(<e}pT_a|gE&rO?6$|WXD@AN
z9N)IYn^GMgO6}=RtY<kN?e_N}PW!TPzg$dQ`7C>$`cyubct8CKub1nI1MtZZs?hmG
z#QT=u^SJR^;+p%(uiW{1kJyWT*yNrM5f@TE;Kng%ulW(}ZBN|!*eLtGuB!h$;ur?P
z@0K4<yzFN5pF4j!#9sDn`1v}M_|4wo{zsd|#7kMv;r2a4ye(q=)evuwh(p9XN*OPA
zJ^oF+p7pfSy}$GF)-3z&ty#|NTeFf!4NT6;D40Agr))+^o?GI7IG385HM);mBqOhE
z;Iy0xg?Xv@c@w7$%PE_fKdNZzpn}4@5z~gJxP=DJEc54-logZ}O&gq7HgwvgBEt)5
zv(ieYCg+u2oHr|@;F>%$Jb8Fp*3c1I!*ZtNr4$vFr4&rdDVb#^4;njqaF%_tXDQW8
z&KoglQfXe9T|;KL8Oeo(MH7eRO--Jbn_e(&%Alf>blyQ3u5wgfPOh$Wn=_~|XEG&H
za&l9+YRZU7DZ~8ksj;a!6Z7*170xKl*9CUe*wf)D$t8I?1E=NsQ<8IYOU&dkWfL=U
zQzuR4)t2E#QscmqoYK5usg2hS$|<GS1!cOido(qtaAIo7#D0<e8%D9bl2mREG+sTr
z)EQhqzlE4rGR-}q31jdxi^_5eGx8>u6_wbd=)Ck-CmHGRNk%1gNXC(k<g}VIV$z_3
znR&U)nYtEH1$B>R&eHNG%m}xcOEU5cCY6oJDV&kV0IFNVW)zkc_zRDir}UKMtii)l
zvxbizW+o>O%(!^qC0RWWPsZ31ehoJB>LPz(&a}LAs<3BfveWR4{G5`!jAH(mGGo%D
z!=s?VJF@wj(pk=YghxtE8<eAwplx=$iVJgQ+3TdF;L2&aIeCQxr%f!GRb1AySHJK@
z6LY4e<y}=UF^|p-%gZgu39ru7QJGm&^QKOmTHGsQ#O=mA!|fhTEt+;!UP;-oLH^{j
zBL3$d_Lmfdm%QEh8Kn~j6_iZ9nx3T<T|KR^C?|JVQEr|I_d9PQ+b&f{oPkjP?DmWv
zn&uwT<P=RBTvV8wH!Wf{|9k1{<PpR7?;@k@mF*Ua+$R5?n8u~;j$UJnoZT|ClmSWO
z_i2aP&GM&&JLRmeQ6sdnpn$w-xuZ)(6>fiqj&Md(vwh^`vi2CfoT+(@`#{SzCBtYe
zM-|N|E0~s-#XgMOJudB}7hRoKl3p;C1rtFX?n!&U4=;*5<1{k0sCd@EnFXa(Jejf)
z&B;i~vYVOCjOCSRs1C1WwaH#@v!Ie;IVCWO-@e0<1CU$@t=i*l&v<yWVSvIEe#1C5
zKWEzHys@ce1yl3P;Jj(>C=bt>mdn&f^dYG%e|Snp8JjYtaEi@8jZ*{bP+#h()KMdb
ziG1x<Ke|^$KT-?xa!Q7zX)cV`b@8mj{m@zq&%3j*Qd7grzj#)7`D^#*l@#O@4xce~
z0z31Fn=@noE1Ph!KP97RlD(u;W~B}pn0j$|S!@19`dUKH@Htyx=m<5;pFhhXh{pT5
zlR3J$I6TwN1>vm-JF^v2!dr28ifXqz-dM-s2E(o_UpC(nlS6wQT5#yVev`VpUhSC-
z4^vj=*^yJ^jDhn&w4VYITP9*A^>}mElhz&UF}x<YZR76x_pTkAn#{;)Zr$lA%`58_
zd4HaO+9Ba(e&n#&3^mMun4;X_I{GkeNJ&kzIX*l?w5l}ksAcTb9r0whY3@He`QKZz
z7mrbh%6*zg%#7B9+cu*WkUDE(VP2+oM|ha*p|v{+(}!2C+gOK_m|iU>d$$}x*Y0T^
z5_!5iWEFAe@FH&9g^jaeKa{kPA}(OpF<Q=a56hY9u1otN`mb7#W*BGuP#&Z5CY9us
z=0{Z9c&l)SBZxAR0qyQZ&c7D9c+u4-&OMwi+xpCT9ffni9WQi}_CjX5ODZEKrH5sk
zdm&47SWdw-e@a<V#*7J!m{YBDO#8#87JH-otJfnY9lZ^li`~5xo;znd*}Kf{ytd!J
z*uWly@D+!JgMG^}14m^H9WmT(nbeOKjx+Hov-+gWD*N}eWu&DJ8a$|^Xeu(bvE9y;
zW|WCvbrK!pD2RzgVdbS6NGmD0$|2dXw2+KNI_4g+4DCT5I*r{EZrZ<eYU8##;*lMp
z9~cZRsS%ShW|a<#Y%3=m!a0(|oDt?xfws|t7%@r9C}qTm%!q#aS^p(P6Z3fWMPujf
z5tazi1(EA&a8Z$?mD71d9??TvDo4s>R<z9o68M?D!`)^^*s4==!WXM;VS+8N2fOis
ze}p6&l{b~O7okhF;ieXs%^JjdrOG4LvNPPJ_JiEk^t2)6lFY18c}TR<JS~IL@Z(Gi
z#C{rO92QtqJ$RH&D<hl-RYdC>*OPmYXKn9ZS((Wx=@7ELaw9f`a-k!qJuCt2@roF7
z)|*HrVpm6wI~kAL9y{ep8#OFzSlZcHgGh}E|AP(PhS-`tO9_zEu%ohpBU6P&J!#Lr
z3EyLMac&N~CM(N+=}J~XZoyTDWldx{6T$cyGm49gO3E_Qh7KRvn0z^lN@-QZE@!B1
z{m--SKbGHrE>12<ol#Q4J6g0lGiMd&nK9^*NwfY(!K6H-*V%oiWHDFnP&mtFko{Jk
z#-*E;oSyC$aD=g@LtE#Ft8AKc9~$=Rj+9q$=;0Nt^do#jSH$qBF_Vj(=}0TN>IhZQ
z_%ypTuY}CFkp`U^i5OwlL!$%?=fO^SM#mMDLr{)|hf}9;hb9%#MCZPTQ*ZuidBpIu
z6t&7{9cF>ZmFPU=BuXV-MocT5CA}p2vFS0h-;otDSv(E3ZC!@dfQ=h5D!lugdC<xq
zo_DpQjd{8lkyKXth~%_^qYnSc8We40L)65h=txY{H*(xmFU#NFI^jj@h&=m=naXQ^
z{%h40k&C*V=yH(O0Ef!RukEfjUd57fcSywaWaN^xXzkd16?vj;;LJQ*vPaCWTIq}f
zk5#9wPQvMSCB0xm2@XgWtGu*;r%&U}8Qn-JZnL#h@e$)1UaLnfsKzI2V~xzc>qvxe
z?$6{dN6CVS9--bMnaR1kv)KRjh*taL>_`GB;|UkA`M@3NMr$R1mR+$kT1;)m*>02E
zvEs=Q`Mk09g1uyU3Z^6{AEreu6#Jxmc_Y#3%n@})u0!`kBbguGHuf+wDE3ps=AX!C
zK=`R81H*liGn=ItRgI$@&L#DTjo>)<(#*W6#bHm%-c*i1#{JP2S?GLs?bz9hZNz9H
zI|sEQ9QL)nICr2U2-l$jJ$5q+i;%2kM_OyHbcHct<S^&Ya7aI*{b{3;hat@;6-+*2
zOFD+%;azzIF*&nF`-YZ=GhICkBCr215fgD!Hvvb9MJ)8;DO9QLX^+?xa?*%#)@s%x
znE5%J4>xWCd$v=Y4R?6-SUFO@<cuu2oV-%oB62=X$-_jlFL$$&VdR!&MZ*x;?s2q+
zeLpjKSn{|mZkaLk(t-c(;lG@=@UzwtOwKJ_5>KC)n^sWj7+CfR?m>^k>m%X;aySKp
zBeV=6q+)o%*aH>GW6p`;DMvl$TvZ;iY{ESzYjoVLh<VB5S)>^V=Ns-|NNv~~)ZUaw
zBwui{2HzR_2r^-6#S3|(u}_Y6HrO++Msn`fIOKF_GMQ6pn1`KC{cjJd@Ibm(I2X_;
zXJNXm!lZ{aeOlhpc40W%JNiNBw(3X%bjFeTM)!2jGe4sa+aT^S?MX)pAFd=!lo1ob
zm5~NYhM!@MSn-g=e|OxiGc&KS(0!hSA14vxuVl)e6x}ejXvSe$`L_k(_;`7w?(*~X
zSaL?uT_{KIj3d^MJkoG+$Nuge)&s0=N9_DZZMKsWF)Oekk}tD}**QF7jT*{5)Htds
z1(PS|VN}c9jTkW&m3>E)TKM@iDo=DBcC5oq3wOcpn%WXMa41aI=yn?Z?*SWi*t5wR
z-TO#tomzB+fq8`ee<Y!?2_l{s|I@9sx1{<b8t71~vo!w8)fhS=yw;9*C_8sJYR%ah
zmA!=y8x&-ukvvL?fvI6#<kZ2!%qSa}J7Q95MtJHS!~7_d?%xAvr`RR#MTegv$y2pF
zdDMrW;M_A65+YRzPoq7pM|8)1ayr9cGxe~ee^AxPYkGLdl}i~qRjS?ThGSxjTkXpa
zt80cxZHd^Z4h1;EBVr;P^>LI*qFepP&w-9m`4Oryyb|r9(?iH@oc^Ag{bMt`#Y0dx
zwC{+~u-g~WnnnZCo<5%Wc0v=TsYs{uNTbEBm1fg#`-e-ovru+vc$B!cm=QW_G|v7#
zvyIv+Vn6yL)OWb;5^4;u{gbVTA?D^0V#oan6hBM~FXf1$Y=_1)&*|hjk^4g_B9Hoi
zr-&J4{QSwO2<ka%?K+leBbyz51Q$(Xz5mA~ON<=pQBkgOO}WE&cw0HEU3ZV%UG{1E
zF8zL3Yq^&?SJ)Y<^D$gy*dlTsagD4Uu^3$KXD|B0>8E4)vavJ=PJ)JL{kJR)FB#f(
z*p@l0RHcRaaco!*J6lPVM23902a!L1WmNw4fPo21!!;gOiuNw_yFU<hxA*AeQJJ>&
dp;B)DY1UxpXEI?+=g5uj?!KYZif5FW{|}`;f`kA7

diff --git a/drivers/block/tcc/libtnftl/libtnftl_V7014_TCC8900.o_shipped b/drivers/block/tcc/libtnftl/libtnftl_V7014_TCC8900.o_shipped
new file mode 100644
index 0000000000000000000000000000000000000000..e7eb93ccc3c437e1130c473bf96a091719ff891f
GIT binary patch
literal 222203
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

literal 0
HcmV?d00001

diff --git a/drivers/block/tcc/nand_drv_v7.c b/drivers/block/tcc/nand_drv_v7.c
index f99b8d5..8d97229 100644
--- a/drivers/block/tcc/nand_drv_v7.c
+++ b/drivers/block/tcc/nand_drv_v7.c
@@ -60,55 +60,61 @@
 #ifndef WITHOUT_FILESYSTEM
 
 #if defined( FWDN_DOWNLOADER_INCLUDE )
-const unsigned char	NANDDRV_Library_Version[] = { "SIGBYAHONG_NANDDRV_FWDN_V007010" };
+const unsigned char	NANDDRV_Library_Version[] = { "SIGBYAHONG_NANDDRV_FWDN_V007014" };
 #elif defined(TCC92XX)
-const unsigned char	NANDDRV_Library_Version[] = { "SIGBYAHONG_NANDDRV_TCC92XX_V007010" };
+const unsigned char	NANDDRV_Library_Version[] = { "SIGBYAHONG_NANDDRV_TCC92XX_V007014" };
 #elif defined(TCC89XX)
-const unsigned char	NANDDRV_Library_Version[] = { "SIGBYAHONG_NANDDRV_TCC89XX_V007010" };
+const unsigned char	NANDDRV_Library_Version[] = { "SIGBYAHONG_NANDDRV_TCC89XX_V007014" };
 #endif
 
 //=============================================================================
 //*
 //*
-//*                           [ CONST DATA DEFINE ]
+//*                           [ DEFINITIONS ]
 //*
 //*
 //=============================================================================
-#define NAND_DRV_HIDDEN_INFO_SIZE	( 19 + 8 + 1*4 )
+#if defined(_WINCE_)
+#define TNFTL_EXTENDED_PARTITION_MAX_NUM			4
+#define TNFTL_EXTENDED_PARTITION_NUM				2
 
-const unsigned char gNAND_HiddenInfoSignature[ NAND_DRV_HIDDEN_INFO_SIZE ] =
-{
-	'T','N','F','T','L','H','I','D','D','E','N','S','I','Z','E','I','N','F','O',
-    
-    #ifndef NU_FILE_INCLUDE
-	#ifdef AUDIOUI_INCLUDE	
-	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE+AUI_HD_OCCPAGE) >>  0) & 0xFF,
-	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE+AUI_HD_OCCPAGE) >>  8) & 0xFF,
-	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE+AUI_HD_OCCPAGE) >> 16) & 0xFF,
-	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE+AUI_HD_OCCPAGE) >> 24) & 0xFF,
-	#else
-	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE) >>  0) & 0xFF,
-	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE) >>  8) & 0xFF,
-	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE) >> 16) & 0xFF,
-	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE)>> 24) & 0xFF,
-    #endif
-    #else
-    ((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE) >>  0) & 0xFF,
-	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE) >>  8) & 0xFF,
-	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE) >> 16) & 0xFF,
-	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE) >> 24) & 0xFF,
-	#endif
+#define NAND_HIDDEN_0_PAGESIZE						(33/*MB*/*1024*2)
+#define NAND_HIDDEN_1_PAGESIZE						(3/*MB*/*1024*2)	// for LOGO
+#define NAND_HIDDEN_2_PAGESIZE						(2/*MB*/*1024*2)
+#define NAND_HIDDEN_3_PAGESIZE						(3/*MB*/*1024*2)
 
-	((unsigned long int)TNFTL_EXTENDED_PARTITION_NUM >>  0) & 0xFF,
-	((unsigned long int)TNFTL_EXTENDED_PARTITION_NUM >>  8) & 0xFF,
-	((unsigned long int)TNFTL_EXTENDED_PARTITION_NUM >> 16) & 0xFF,
-	((unsigned long int)TNFTL_EXTENDED_PARTITION_NUM >> 24) & 0xFF,
+#define NAND_RO_AREA_SIZE_MB						0
+#elif defined(_LINUX_)
+#define TNFTL_EXTENDED_PARTITION_MAX_NUM			4
+#define TNFTL_EXTENDED_PARTITION_NUM				1
 
-	((unsigned long int)NAND_HIDDEN_DRIVE_DEFAULT_TOTAL_SECTOR_SIZE >>  0) & 0xFF,
-	((unsigned long int)NAND_HIDDEN_DRIVE_DEFAULT_TOTAL_SECTOR_SIZE >>  8) & 0xFF,
-	((unsigned long int)NAND_HIDDEN_DRIVE_DEFAULT_TOTAL_SECTOR_SIZE >> 16) & 0xFF,
-	((unsigned long int)NAND_HIDDEN_DRIVE_DEFAULT_TOTAL_SECTOR_SIZE >> 24) & 0xFF
-};
+#define NAND_HIDDEN_0_PAGESIZE						(32*1024*2)
+#define NAND_HIDDEN_1_PAGESIZE						(1*1024*2)
+#define NAND_HIDDEN_2_PAGESIZE						(2*1024*2)
+#define NAND_HIDDEN_3_PAGESIZE						(3*1024*2)
+
+#define NAND_RO_AREA_SIZE_MB						0	// MTD Area
+#else
+#ifdef INTERNAL_HIDDEN_STORAGE_INCLUDE
+#define TNFTL_EXTENDED_PARTITION_MAX_NUM			1
+#define TNFTL_EXTENDED_PARTITION_NUM				1
+
+#define NAND_HIDDEN_0_PAGESIZE						(4096)
+#else
+#define TNFTL_EXTENDED_PARTITION_MAX_NUM			1
+#define TNFTL_EXTENDED_PARTITION_NUM				0
+
+#define NAND_RO_AREA_SIZE_MB						0
+#endif
+#endif
+
+//=============================================================================
+//*
+//*
+//*                           [ CONST DATA DEFINE ]
+//*
+//*
+//=============================================================================
 
 //=============================================================================
 //*
@@ -137,9 +143,9 @@ TNFTL_RCACHE_SLOT	gTNFTL_ExtPartitionRCache[MAX_NAND_DRIVE][TNFTL_EXTENDED_PARTI
 TNFTL_MAINPB_INFO 	gTNFTL_PriPartitionMainPBInfo[MAX_NAND_DRIVE][TNFTL_WCACHE_NUM_For_PRIMARY_PARTITION];
 TNFTL_MAINPB_INFO 	gTNFTL_ExtPartitionMainPBInfo[MAX_NAND_DRIVE][TNFTL_EXTENDED_PARTITION_MAX_NUM][TNFTL_WCACHE_NUM_For_EXTENDED_PARTITION];
 
-NAND_IO_DEVINFO		*gLBA_DevInfo;
+NAND_IO_DEVINFO*	gLBA_DevInfo[LBA_MAX_SUPPORT_MULTI_NANDFLASH];
 
-unsigned char		gNAND_UARTDebugFlag = DISABLE;
+unsigned char		gNAND_UARTDebugFlag = TCC_NAND_TRACE_OFF;
 unsigned char		gNAND_PartitionInfoLoadFlag = DISABLE;
 #if defined(_LINUX_) || defined(_WINCE_)
 unsigned char		gNAND_SetFlagOfChangeAreaSize = DISABLE;
@@ -160,7 +166,6 @@ tSYSTEM_PARAM  		*pSYS_PARAM_NAND_DRV;
 //*
 //*
 //=============================================================================
-int		NAND_LowLevelFormat( void);
 
 //=============================================================================
 //*
@@ -192,7 +197,6 @@ extern unsigned int		fat_cbuffer[];
 extern unsigned char	gFormatType;
 #endif
 	
-extern unsigned short				usbFirmwareDownloadMode;
 
 #if !defined(FWDN_DOWNLOADER_INCLUDE) && !defined(_LINUX_) && !defined(_WINCE_)
 	#ifdef MTP_INCLUDE
@@ -218,10 +222,10 @@ extern void B_RETAILMSG(const char * fmt, ...);
 *	Description :
 *
 *******************************************************************************/
-unsigned char*	NAND_TellLibraryVersion( void )
-{
-	return (unsigned char*)gNAND_HiddenInfoSignature;
-}	
+//unsigned char*	NAND_TellLibraryVersion( void )
+//{
+//	return (unsigned char*)gNAND_HiddenInfoSignature;
+//}	
 
 /******************************************************************************
 *
@@ -340,11 +344,14 @@ void NAND_Init( void )
 	#endif
 
 	#ifdef NAND_LBA_INCLUDE
-	gLBA_DevInfo = &gNAND_DrvInfo[0].NFTLDrvInfo->MediaDevInfo[0];
+	gLBA_DevInfo[0] = &gNAND_DrvInfo[0].NFTLDrvInfo->MediaDevInfo[0];
+	gLBA_DevInfo[1] = &gNAND_DrvInfo[0].NFTLDrvInfo->MediaDevInfo[1];
+	gLBA_DevInfo[2] = &gNAND_DrvInfo[0].NFTLDrvInfo->MediaDevInfo[2];
+	gLBA_DevInfo[3] = &gNAND_DrvInfo[0].NFTLDrvInfo->MediaDevInfo[3];
 	
-	gLBA_DevInfo->LBAInfo.FlagOfChangeTotalSectorSize = DISABLE;
-	res = NAND_IO_LBA_GetDeviceInfo( gLBA_DevInfo );
-	if ( ( res == SUCCESS ) || ( gLBA_DevInfo->Feature.MediaType & S_LBA ) )
+	gLBA_DevInfo[0]->LBAInfo.FlagOfChangeTotalSectorSize = DISABLE;
+	res = NAND_IO_LBA_GetDeviceInfo( 0, gLBA_DevInfo[0] );
+	if ( ( res == SUCCESS ) || ( gLBA_DevInfo[0]->Feature.MediaType & S_LBA ) )
 		gNAND_DrvInfo[0].NFTLDrvInfo->NANDType = NAND_TYPE_LBA_NAND;
 	else
 		gNAND_DrvInfo[0].NFTLDrvInfo->NANDType = NAND_TYPE_PURE_NAND;
@@ -384,20 +391,22 @@ void NAND_Init( void )
 **************************************************************************/
 void NAND_InitExtPartitionInfo( void )
 {
-	unsigned int i;
-
 	gTNFTL_ExtPartitionInfo[NAND_DRV_0].ExtendedPartitionNum = TNFTL_EXTENDED_PARTITION_NUM;
-	gTNFTL_ExtPartitionInfo[NAND_DRV_0].ROAreaSize			 = 0;
 
-	#if defined(_LINUX_) || defined(_WINCE_)
-	for ( i = 0; i < TNFTL_EXTENDED_PARTITION_NUM; ++i )
-		gTNFTL_ExtPartitionInfo[NAND_DRV_0].ExtPartitionSize[i] =  4096;
+#if (TNFTL_EXTENDED_PARTITION_NUM>0)
+	gTNFTL_ExtPartitionInfo[NAND_DRV_0].ExtPartitionSize[0] =  NAND_HIDDEN_0_PAGESIZE;
+#endif
+#if (TNFTL_EXTENDED_PARTITION_NUM>1)
+	gTNFTL_ExtPartitionInfo[NAND_DRV_0].ExtPartitionSize[1] =  NAND_HIDDEN_1_PAGESIZE;
+#endif
+#if (TNFTL_EXTENDED_PARTITION_NUM>2)
+	gTNFTL_ExtPartitionInfo[NAND_DRV_0].ExtPartitionSize[2] =  NAND_HIDDEN_2_PAGESIZE;
+#endif
+#if (TNFTL_EXTENDED_PARTITION_NUM>3)
+	gTNFTL_ExtPartitionInfo[NAND_DRV_0].ExtPartitionSize[3] =  NAND_HIDDEN_3_PAGESIZE;
+#endif
 
-	#else
-	for ( i = 0; i < TNFTL_EXTENDED_PARTITION_MAX_NUM; ++i )
-		gTNFTL_ExtPartitionInfo[NAND_DRV_0].ExtPartitionSize[i] =  NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE;
-	#endif
-	return;
+	gTNFTL_ExtPartitionInfo[NAND_DRV_0].ROAreaSize = NAND_RO_AREA_SIZE_MB;
 }
 
 /**************************************************************************
@@ -499,15 +508,6 @@ NAND_ERROR NAND_InitDrive( int nDrvNo )
 			TNFTL_SetAreaProtectFlag(DISABLE);		// Set Flag Only FWDN_MODE
 		}
 	    
-	    // Check if low-level format option is enabled.	/*	[1255]  */
-	    if (usbFirmwareDownloadMode & Hw8)
-	    {
-		    BITCLR(usbFirmwareDownloadMode, Hw8);
-		    //TNFTL_BMPRefresh( gNAND_DrvInfo[0].NFTLDrvInfo);
-
-			NAND_LowLevelFormat();
-	    }
-
 		//=========================================================
 		// Linux MTD Include
 		//=========================================================
@@ -517,13 +517,6 @@ NAND_ERROR NAND_InitDrive( int nDrvNo )
 		TNFTL_SetROAreaSize( gNAND_DrvInfo[nDrvNo].NFTLDrvInfo, 0, DISABLE );
 		#endif
 		
-		NAND_IO_GetDeviceInfo( 0, &gNAND_DrvInfo[0].NFTLDrvInfo->MediaDevInfo[0] );
-		nTemp 	= gMAX_ROMSIZE >> gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->MediaDevInfo[0].ShiftPageSize;
-		nTemp 	= nTemp >> gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->MediaDevInfo[0].ShiftPpB;
-		nTemp 	= nTemp << 2;
-		nTemp 	+= 20;
-		TNFTL_SetNBAreaEndPBAddr(nTemp);		// 1 ~ n Block No...
-		
 		#if defined(_WINCE_)
 		#if defined(USE_V_ADDRESS)
 		// Boot Loader - Init Info Restoration
@@ -535,6 +528,13 @@ NAND_ERROR NAND_InitDrive( int nDrvNo )
 		#endif
 		#endif
 		
+		NAND_IO_GetDeviceInfo( 0, &gNAND_DrvInfo[0].NFTLDrvInfo->MediaDevInfo[0] );
+		nTemp 	= gMAX_ROMSIZE >> gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->MediaDevInfo[0].ShiftPageSize;
+		nTemp 	= nTemp >> gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->MediaDevInfo[0].ShiftPpB;
+		nTemp 	= nTemp << 2;
+		nTemp 	+= 20;
+		TNFTL_SetNBAreaEndPBAddr(nTemp);		// 1 ~ n Block No...
+				
 	    res = TNFTL_InitDrive( gNAND_DrvInfo[nDrvNo].NFTLDrvInfo );
 
 		#if defined(USE_V_ADDRESS) && defined(_WINCE_)
@@ -586,13 +586,13 @@ NAND_ERROR NAND_InitDrive( int nDrvNo )
 			//--------------------------			
 			#if 1
 			ND_TRACE( "[NAND        ] [NB Area:%dMB][DT Area:%dMB]", 
-			(gMAX_ROMSIZE * 2) >> 20,
-			gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->PriPartition.TotalSectorSize >> 11);
+			(int)(gMAX_ROMSIZE * 2) >> 20,
+			(int)(gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->PriPartition.TotalSectorSize >> 11));
 			for ( i = 0; i < gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->ExtendedPartitionNo; ++i )
-				ND_TRACE( "[HD Area%d:%dMB]", i, gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->ExtPartition[i].TotalSectorSize >> 11 );
+				ND_TRACE( "[HD Area%d:%dMB]", i, (int)gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->ExtPartition[i].TotalSectorSize >> 11 );
 			#if defined(_LINUX_)
 			if ( gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->ROAreaSize != 0 )
-				ND_TRACE("[MTD Size:%dMB]", gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->ROAreaSize >> 20 );
+				ND_TRACE("[MTD Size:%dMB]", (int)gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->ROAreaSize >> 20 );
 			#endif
 			ND_TRACE("\n");
 			#endif
@@ -637,15 +637,15 @@ NAND_ERROR NAND_InitDrive( int nDrvNo )
 		gNAND_DrvInfo[nDrvNo].DrvStatus = DISABLE;
 		
 		if ( gNAND_SetFlagOfChangeAreaSize == DISABLE )
-			gLBA_DevInfo->LBAInfo.FlagOfChangeTotalSectorSize = DISABLE;
+			gLBA_DevInfo[0]->LBAInfo.FlagOfChangeTotalSectorSize = DISABLE;
 		else
-			gLBA_DevInfo->LBAInfo.FlagOfChangeTotalSectorSize = ENABLE;
+			gLBA_DevInfo[0]->LBAInfo.FlagOfChangeTotalSectorSize = ENABLE;
 
-		res = NAND_IO_LBA_Init( gLBA_DevInfo );
+		res = NAND_IO_LBA_InitDrive( *gLBA_DevInfo );
 		if ( res != SUCCESS )
 			return ERR_NAND_INIT_FAILED;
 
-		NAND_IO_LBA_GetTotalSecAndCHS( gLBA_DevInfo,
+		NAND_IO_LBA_GetTotalSecAndCHS( *gLBA_DevInfo,
 									   NAND_LBA_DATA_AREA,
 									   (U32)&gNAND_DrvInfo[nDrvNo].TotalDiskSector,
 									   &gNAND_DrvInfo[nDrvNo].Cylinder,
@@ -681,8 +681,8 @@ int NAND_ReadSector( int nDrvNo, U32 LBA, U32 nSecSize, void* nReadBuffer )
 		HwTCNT4 = 0;
 		#endif
 		#ifdef NAND_DRV_UART_DEBUG
-		if ( gNAND_UARTDebugFlag == ENABLE )
-			PRINTF( "\n\nNAND_ReadSector( %08d, %08d ) -------------------------- ", LBA, nSecSize );
+		if ( gNAND_UARTDebugFlag & TCC_NAND_TRACE_DRV_READ )
+			ND_TRACE( "\nNAND_ReadSector( %08d, %08d ) ---------------\n ", LBA, nSecSize );
 		#endif
 
 		#ifdef NAND_DRV_UART_DEBUG
@@ -694,7 +694,7 @@ int NAND_ReadSector( int nDrvNo, U32 LBA, U32 nSecSize, void* nReadBuffer )
 			#endif
 		#endif
 		//==============================================================================
-		
+
 		if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
 		{
 	        res = TNFTL_AREAReadSector( gNAND_DrvInfo[nDrvNo].NFTLDrvInfo,
@@ -704,7 +704,7 @@ int NAND_ReadSector( int nDrvNo, U32 LBA, U32 nSecSize, void* nReadBuffer )
 		else
 		{
 			#ifdef NAND_LBA_INCLUDE
-			res = NAND_IO_LBA_ReadSector( gLBA_DevInfo,
+			res = NAND_IO_LBA_ReadSector( *gLBA_DevInfo,
 										  NAND_LBA_DATA_AREA, 
 										  LBA, nSecSize, nReadBuffer);
 			#endif
@@ -713,7 +713,7 @@ int NAND_ReadSector( int nDrvNo, U32 LBA, U32 nSecSize, void* nReadBuffer )
 		//=================[ For DEBUG ]================================================
 		#ifdef NAND_DRV_UART_MEASURE
 		count = HwTCNT4;
-		PRINTF( "\n[NAND_READ Sector %08d - %05d ] ( %d uS ) -------------------------- ",
+		ND_TRACE( "\n[NAND_READ Sector %08d - %05d ] ( %d uS ) -------------------------- ",
 		LBA,
 		nSecSize,
 		(count*267)/100);
@@ -724,7 +724,7 @@ int NAND_ReadSector( int nDrvNo, U32 LBA, U32 nSecSize, void* nReadBuffer )
 	{
 		#ifdef NAND_DRV_UART_DEBUG
 		if ( gNAND_UARTDebugFlag == ENABLE )
-			PRINTF( " FAIL %08X", res );
+			ND_TRACE( " FAIL %08X", res );
 		#endif
 
 		return -1;
@@ -738,6 +738,57 @@ int NAND_ReadSector( int nDrvNo, U32 LBA, U32 nSecSize, void* nReadBuffer )
 
 /******************************************************************************
 *
+*	int				NAND_ReadSectorIRQ
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+int NAND_ReadSectorIRQ( int nDrvNo, ndd_work_info* nand_work_info )
+{
+	#ifdef NAND_INCLUDE
+	TNFTL_ERROR		res = SUCCESS;
+
+	//=================[ For DEBUG ]================================================
+	#ifdef NAND_DRV_UART_DEBUG
+		#if defined(USE_V_ADDRESS)
+			#if define(LINUX)
+			printk("\nSectorNum:%d ---------------------------------", nand_work_info->SectorNum);
+			for ( i = 0; i < nand_work_info->SectorNum; ++i )
+				printk("\nBuf:0x%X", nand_work_info->BufferAddr[i]);
+
+			printk("\n");
+			#endif
+		#endif
+	#endif
+	//==============================================================================
+	res = TNFTL_AREAReadSectorIRQ( gNAND_DrvInfo[nDrvNo].NFTLDrvInfo,
+									   &gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->PriPartition, 
+									   nand_work_info );
+
+	if ( res != SUCCESS )
+	{
+		#ifdef NAND_DRV_UART_DEBUG
+		if ( gNAND_UARTDebugFlag == ENABLE )
+			ND_TRACE( " FAIL %08X", res );
+		#endif
+
+		ND_TRACE( " FAIL %08X", res );
+
+		return -1;
+	}
+
+	return 0;
+	#else
+	return NOT_SUPPORT_NAND;
+	#endif
+}
+
+/******************************************************************************
+*
 *	int				NAND_WriteSector
 *
 *	Input	:
@@ -758,8 +809,8 @@ int NAND_WriteSector( int nDrvNo, U32 LBA, U32 nSecSize, void* nWriteBuffer )
 		HwTCNT4 = 0;
 		#endif
 		#ifdef NAND_DRV_UART_DEBUG
-		if ( gNAND_UARTDebugFlag == ENABLE )
-			PRINTF( "\n\nNAND_WriteSector( %08d, %08d ) -----------------------------------", LBA, nSecSize );
+		if ( gNAND_UARTDebugFlag & TCC_NAND_TRACE_DRV_WRITE )
+			ND_TRACE( "\n\nNAND_WriteSector( %08d, %08d ) -----------------------------------", LBA, nSecSize );
 		#endif
 
 		#ifdef NAND_DRV_UART_DEBUG
@@ -781,7 +832,7 @@ int NAND_WriteSector( int nDrvNo, U32 LBA, U32 nSecSize, void* nWriteBuffer )
 		else
 		{
 			#ifdef NAND_LBA_INCLUDE
-			res = NAND_IO_LBA_WriteSector( gLBA_DevInfo,
+			res = NAND_IO_LBA_WriteSector( *gLBA_DevInfo,
 										  NAND_LBA_DATA_AREA, 
 										  LBA, nSecSize, nWriteBuffer );
 			#endif
@@ -790,7 +841,7 @@ int NAND_WriteSector( int nDrvNo, U32 LBA, U32 nSecSize, void* nWriteBuffer )
 		//=================[ For DEBUG ]================================================
 		#ifdef NAND_DRV_UART_MEASURE
 		count = HwTCNT4;
-		PRINTF( "\n[NAND_WRITE Sector %08d - %05d ] ( %d uS ) -------------------------- ",
+		ND_TRACE( "\n[NAND_WRITE Sector %08d - %05d ] ( %d uS ) -------------------------- ",
 		LBA,
 		nSecSize,
 		(count*267)/100);
@@ -801,7 +852,7 @@ int NAND_WriteSector( int nDrvNo, U32 LBA, U32 nSecSize, void* nWriteBuffer )
 	{
 		#ifdef NAND_DRV_UART_DEBUG
 		if ( gNAND_UARTDebugFlag == ENABLE )
-			PRINTF( "\nFAIL : %08X ", res );
+			ND_TRACE( "\nFAIL : %08X ", res );
 		#endif
 
 		return -1;
@@ -811,7 +862,56 @@ int NAND_WriteSector( int nDrvNo, U32 LBA, U32 nSecSize, void* nWriteBuffer )
 	#else
 	return NOT_SUPPORT_NAND;
 	#endif
-}	
+}
+
+/******************************************************************************
+*
+*	int				NAND_WriteSectorIRQ
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+int NAND_WriteSectorIRQ( int nDrvNo, ndd_work_info* nand_work_info )
+{
+	#ifdef NAND_INCLUDE
+	TNFTL_ERROR		res = SUCCESS;
+	
+	//=================[ For DEBUG ]================================================
+	#ifdef NAND_DRV_UART_DEBUG
+		#if defined(USE_V_ADDRESS)
+			#if define(LINUX)
+			printk("\nSectorNum:%d ---------------------------------", nand_work_info->SectorNum);
+			for ( i = 0; i < nand_work_info->SectorNum; ++i )
+				printk("\nBuf:0x%X", nand_work_info->BufferAddr[i]);
+
+			printk("\n");
+			#endif
+		#endif
+	#endif
+	//==============================================================================
+	res = TNFTL_AREAWriteSectorIRQ( gNAND_DrvInfo[nDrvNo].NFTLDrvInfo,
+							 		&gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->PriPartition, 
+							 		nand_work_info );
+
+	if ( res != SUCCESS )
+	{
+		#ifdef NAND_DRV_UART_DEBUG
+		if ( gNAND_UARTDebugFlag == ENABLE )
+			ND_TRACE( "\nFAIL : %08X ", res );
+		#endif
+
+		return -1;
+	}	
+
+	return 0;
+	#else
+	return NOT_SUPPORT_NAND;
+	#endif
+}
 
 /******************************************************************************
 *
@@ -844,8 +944,7 @@ int NAND_HDReadSector( int nDrvNo, U32 LBA, U32 nSecSize, void* nReadBuffer )
 	else
 	{
 		#ifdef NAND_LBA_INCLUDE
-	
-		res = NAND_IO_LBA_ReadSector( gLBA_DevInfo,
+		res = NAND_IO_LBA_ReadSector( *gLBA_DevInfo,
 									  NAND_LBA_MULTI_HIDDEN_AREA_0, 
 									  LBA, nSecSize, nReadBuffer);
 		#endif
@@ -855,7 +954,7 @@ int NAND_HDReadSector( int nDrvNo, U32 LBA, U32 nSecSize, void* nReadBuffer )
 	{
 		#ifdef NAND_DRV_UART_DEBUG
 		if ( gNAND_UARTDebugFlag == ENABLE )
-			PRINTF( " FAIL %08X", res );
+			ND_TRACE( " FAIL %08X", res );
 		#endif
 
 		return -1;
@@ -898,7 +997,7 @@ int NAND_HDWriteSector( int nDrvNo, U32 LBA, U32 nSecSize, void* nWriteBuffer )
 	else
 	{
 		#ifdef NAND_LBA_INCLUDE	
-		res = NAND_IO_LBA_WriteSector( gLBA_DevInfo,
+		res = NAND_IO_LBA_WriteSector( *gLBA_DevInfo,
 									  NAND_LBA_MULTI_HIDDEN_AREA_0, 
 									  LBA, nSecSize, nWriteBuffer );
 		#endif
@@ -908,7 +1007,7 @@ int NAND_HDWriteSector( int nDrvNo, U32 LBA, U32 nSecSize, void* nWriteBuffer )
 	{
 		#ifdef NAND_DRV_UART_DEBUG
 		if ( gNAND_UARTDebugFlag == ENABLE )
-			PRINTF( "\nFAIL : %08X ", res );
+			ND_TRACE( "\nFAIL : %08X ", res );
 		#endif
 
 		return -1;
@@ -943,7 +1042,7 @@ int NAND_HDReadPage( U32 nHDPageAddr, U32 nPageSize, void* nReadBuffer )
 		#endif
 		#ifdef NAND_DRV_UART_DEBUG
 		if ( gNAND_UARTDebugFlag == ENABLE )
-			PRINTF( "\n\nNAND_HDReadPage( %08d, %08d ) -----", nHDPageAddr, nPageSize );
+			ND_TRACE( "\n\nNAND_HDReadPage( %08d, %08d ) -----", nHDPageAddr, nPageSize );
 		#endif
 		//==============================================================================
 
@@ -956,7 +1055,7 @@ int NAND_HDReadPage( U32 nHDPageAddr, U32 nPageSize, void* nReadBuffer )
 		else
 		{
 			#ifdef NAND_LBA_INCLUDE
-			res = NAND_IO_LBA_ReadSector( gLBA_DevInfo,
+			res = NAND_IO_LBA_ReadSector( *gLBA_DevInfo,
 										  NAND_LBA_HIDDEN_AREA, 
 										  nHDPageAddr, nPageSize, nReadBuffer );
 			#endif
@@ -965,7 +1064,7 @@ int NAND_HDReadPage( U32 nHDPageAddr, U32 nPageSize, void* nReadBuffer )
 		//=================[ For DEBUG ]================================================
 		#ifdef NAND_DRV_UART_MEASURE
 		count = HwTCNT4;
-		PRINTF( "\n[NAND_HDReadPage %08d - %05d ] ( %d uS ) ---- ",
+		ND_TRACE( "\n[NAND_HDReadPage %08d - %05d ] ( %d uS ) ---- ",
 		LBA,
 		nSecSize,
 		(count*267)/100);
@@ -976,7 +1075,7 @@ int NAND_HDReadPage( U32 nHDPageAddr, U32 nPageSize, void* nReadBuffer )
 	{
 		#ifdef NAND_DRV_UART_DEBUG
 		if ( gNAND_UARTDebugFlag == ENABLE )
-			PRINTF( "\nFAIL : %08X ", res );
+			ND_TRACE( "\nFAIL : %08X ", res );
 		#endif
 
 		return -1;
@@ -1010,8 +1109,8 @@ int NAND_HDWritePage( U32 nHDPageAddr, U32 nPageSize, void* nWriteBuffer )
 		HwTCNT4 = 0;
 		#endif
 		#ifdef NAND_DRV_UART_DEBUG
-		if ( gNAND_UARTDebugFlag == ENABLE )
-			PRINTF( "\n\nNAND_HDWritePage( %08d, %08d ) ----", nHDPageAddr, nPageSize );
+		if ( gNAND_UARTDebugFlag & TCC_NAND_TRACE_DRV_WRITE )
+			ND_TRACE( "\n\nNAND_HDWritePage( %08d, %08d ) ----", nHDPageAddr, nPageSize );
 		#endif
 		//==============================================================================
 
@@ -1024,7 +1123,7 @@ int NAND_HDWritePage( U32 nHDPageAddr, U32 nPageSize, void* nWriteBuffer )
 		else
 		{
 			#ifdef NAND_LBA_INCLUDE
-			res = NAND_IO_LBA_WriteSector( gLBA_DevInfo,
+			res = NAND_IO_LBA_WriteSector( *gLBA_DevInfo,
 										  NAND_LBA_HIDDEN_AREA, 
 										  nHDPageAddr, nPageSize, nWriteBuffer );
 			#endif
@@ -1033,7 +1132,7 @@ int NAND_HDWritePage( U32 nHDPageAddr, U32 nPageSize, void* nWriteBuffer )
 		//=================[ For DEBUG ]================================================
 		#ifdef NAND_DRV_UART_MEASURE
 		count = HwTCNT4;
-		PRINTF( "\n[NAND_HDWritePage %08d - %05d ] ( %d uS ) ---- ",
+		ND_TRACE( "\n[NAND_HDWritePage %08d - %05d ] ( %d uS ) ---- ",
 		LBA,
 		nSecSize,
 		(count*267)/100);
@@ -1044,7 +1143,7 @@ int NAND_HDWritePage( U32 nHDPageAddr, U32 nPageSize, void* nWriteBuffer )
 	{
 		#ifdef NAND_DRV_UART_DEBUG
 		if ( gNAND_UARTDebugFlag == ENABLE )
-			PRINTF( "\nFAIL : %08X ", res );
+			ND_TRACE( "\nFAIL : %08X ", res );
 		#endif
 	
 		return -1;
@@ -1078,10 +1177,9 @@ int NAND_PhyReadPage( U32 nBlkAddr, U16 nPageAddr, U16 nCSorder, void* nReadBuff
 {
 	TNFTL_ERROR		res = SUCCESS;
 	#if defined(NAND_INCLUDE)
-
 	#ifdef NAND_DRV_UART_DEBUG
 	if ( gNAND_UARTDebugFlag == ENABLE )
-		PRINTF( "\nNAND_PhyReadPage( %08d, %08d ) ----", nBlkAddr, nPageAddr );
+		ND_TRACE( "\nNAND_PhyReadPage( %08d, %08d ) ----", nBlkAddr, nPageAddr );
 	#endif
 
 	res = TNFTL_IOReadPhyPage( gNAND_DrvInfo[0].NFTLDrvInfo,
@@ -1091,7 +1189,7 @@ int NAND_PhyReadPage( U32 nBlkAddr, U16 nPageAddr, U16 nCSorder, void* nReadBuff
 	{
 		#ifdef NAND_DRV_UART_DEBUG
 		if ( gNAND_UARTDebugFlag == ENABLE )
-			PRINTF( "\nFAIL : %08X ", res );
+			ND_TRACE( "\nFAIL : %08X ", res );
 		#endif
 	
 		return -1;
@@ -1108,6 +1206,7 @@ int NAND_MTD_Init( U32* rMTDStBlk, U32* rMTDEdBlk )
 	unsigned int		nMTDStBlk, nMTDEdBlk;
 	NAND_IO_DEVINFO		sDevInfo;
 	NAND_IO_DEVINFO 	*nDevInfo;
+	NAND_IO_ERROR	res;
 
 	NAND_IO_GetDeviceInfo( 0, &sDevInfo);
 	nDevInfo = &sDevInfo;
@@ -1122,7 +1221,9 @@ int NAND_MTD_Init( U32* rMTDStBlk, U32* rMTDEdBlk )
 	{
 		nBlockPageAddr = i << nDevInfo->ShiftPpB;
 
-		NAND_IO_EraseBlock( nDevInfo, nBlockPageAddr, INTER_LEAVE_OFF );
+		res = NAND_IO_EraseBlock( nDevInfo, nBlockPageAddr, INTER_LEAVE_OFF );
+		if (res != SUCCESS)
+			ND_TRACE("\nBadBlock:%d", i);
 	}
 	
 	*rMTDStBlk = nMTDStBlk;
@@ -1167,60 +1268,53 @@ int NAND_MTD_ReadPage( U32 nPageAddr, U8* nPageBuffer )
 	return res;	
 }
 
-int NAND_LowLevelFormat( void )
+int NAND_LowLevelFormat( int mode )
 {
-	unsigned int		i, j;
-	unsigned int		nBadBlockNum;
-	unsigned int		nBlockPageAddr;
+	unsigned int		i;
 	unsigned int		nMediaNum;
 	NAND_IO_DEVINFO		sDevInfo[NAND_IO_DRV0_END_CS+1];
 	NAND_IO_DEVINFO		*nDevInfo;
-	NAND_IO_ERROR		res;
 
-#if defined(USE_V_ADDRESS) && defined(_WINCE_)
-	RETAILMSG(1, (TEXT( "\n[NAND        ][LowLevelFormat]\n") ));
-#else
-	ND_TRACE("\n[NAND        ] [LowLevelFormat]\n" );
-#endif
+	TNFTL_ERROR	res;
 
 	NAND_Init();
 
-	nBadBlockNum	= 0;
-	nMediaNum 		= 0;
-	
-	for ( i = NAND_IO_DRV0_START_CS; i < (unsigned int)( NAND_IO_DRV0_END_CS + 1 ); ++i )
+	if ( ( mode == 1 ) || ( mode == 2 ) )
 	{
-		if ( NAND_IO_GetDeviceInfo( i, &sDevInfo[nMediaNum] ) == SUCCESS )
+		for ( i = NAND_IO_DRV0_START_CS; i < (unsigned int)( NAND_IO_DRV0_END_CS + 1 ); ++i )
 		{
-			++nMediaNum;
+			if ( NAND_IO_GetDeviceInfo( i, &sDevInfo[nMediaNum] ) == SUCCESS )
+			{
+				++nMediaNum;
+			}
+			else
+			{
+				if ( i == 0 )
+					return ERR_TNFTL_NOT_EXIST_NANDFLASH;
+			}
 		}
-		else
+
+		for ( i = 0; i < nMediaNum; ++i )
 		{
-			if ( i == 0 )
-				return ERR_TNFTL_NOT_EXIST_NANDFLASH;
+			nDevInfo = &sDevInfo[i];
+			
+			NAND_IO_EraseBlock( nDevInfo, 0, INTER_LEAVE_OFF );
 		}
-	}
 
+		if ( mode == 2 )
+			TNFTL_SetUseCheckPattern( ENABLE );
 
+		res = TNFTL_BMPRefresh( gNAND_DrvInfo[0].NFTLDrvInfo );
+			if ( res != SUCCESS )
+			return res;
 
-	for ( i = 0; i < nMediaNum; ++i )
+		TNFTL_SetUseCheckPattern( DISABLE );	
+	}
+	else if ( mode == 3 )
 	{
-		nDevInfo = &sDevInfo[i];
-		
-		for ( j = 0; j < nDevInfo->Feature.PBpV; ++j )
-		{
-
-#if defined(USE_V_ADDRESS) && defined(_WINCE_)
-			RETAILMSG(1, (TEXT( "\n[BlkAddr:%d]\n"), j ));
-#else
-			ND_TRACE("\n[BlkAddr:%d]\n", j);
-#endif
-
-			nBlockPageAddr = j << nDevInfo->ShiftPpB;
-			res = NAND_IO_EraseBlock( nDevInfo, nBlockPageAddr, INTER_LEAVE_OFF );
-			if ( res != SUCCESS )
-				++nBadBlockNum;
-		}
+		res = TNFTL_ScanDevice( gNAND_DrvInfo[0].NFTLDrvInfo );
+		if ( res != SUCCESS )
+			return res;
 	}
 
 	return SUCCESS;
@@ -1369,7 +1463,6 @@ int NAND_Ioctl( int function, void *param )
 	{
 		case	DEV_INITIALIZE:
 			{
-
 				#if defined(_WINCE_)
 				#if defined(USE_V_ADDRESS)
 				pSYS_PARAM_NAND_DRV	= (tSYSTEM_PARAM*)tcc_allocbaseaddress((unsigned int)SYSTEM_PARAM_BASEADDRESS);
@@ -1403,25 +1496,19 @@ int NAND_Ioctl( int function, void *param )
 					#if defined(_WINCE_)
 					#if defined(USE_V_ADDRESS)
 					if ( pSYS_PARAM_NAND_DRV->NAND_INFO.sNandInitStatus != ENABLE )
+					#endif
+					#endif
 					{
-						for ( i = 0; i < gTNFTL_ExtPartitionInfo[NAND_DRV_0].ExtendedPartitionNum; ++i )
-						{
-							TNFTL_AREASetTotalSectorSize( gNAND_DrvInfo[0].NFTLDrvInfo,
-														  &gNAND_DrvInfo[0].NFTLDrvInfo->ExtPartition[i],
-														  gTNFTL_ExtPartitionInfo[NAND_DRV_0].ExtPartitionSize[i] );
-						}
+					for ( i = 0; i < gTNFTL_ExtPartitionInfo[NAND_DRV_0].ExtendedPartitionNum; ++i )
+					{
+						TNFTL_AREASetTotalSectorSize( gNAND_DrvInfo[0].NFTLDrvInfo,
+													  &gNAND_DrvInfo[0].NFTLDrvInfo->ExtPartition[i],
+													  gTNFTL_ExtPartitionInfo[NAND_DRV_0].ExtPartitionSize[i] );
+					}
 
-						 if (usbFirmwareDownloadMode & Hw7)
-					    {
-						    BITCLR(usbFirmwareDownloadMode, Hw7);
 
-							TNFTL_ScanDevice( gNAND_DrvInfo[0].NFTLDrvInfo );
-							return SUCCESS;
-					    }
 					}
-					#endif
-					#endif
-					
+	    
 				    gNAND_DrvInfo[0].DrvStatus = DISABLE;
 
 				    if ( NAND_InitDrive(0) != SUCCESS )
@@ -1451,8 +1538,7 @@ int NAND_Ioctl( int function, void *param )
 					#ifdef NAND_LBA_INCLUDE
 				
 					#ifdef BRWS_STR_NAND_INCLUDE
-					gLBA_DevInfo->LBAInfo.HDAreaSectorSize = ( gTNFTL_HiddenInfo[NAND_DRV_0].HiddenPageSize
-																						  + BRWS_NAME_AREA_SIZE
+					gLBA_DevInfo[0]->LBAInfo.HDAreaSectorSize = ( gTNFTL_ExtPartitionInfo[NAND_DRV_0].ExtPartitionSize[0] + BRWS_NAME_AREA_SIZE
 																						#ifndef NU_FILE_INCLUDE
 																						#ifdef AUDIOUI_INCLUDE
 																						  + AUI_HD_OCCPAGE
@@ -1460,7 +1546,7 @@ int NAND_Ioctl( int function, void *param )
 																						#endif
 																						);
 					#else
-					gLBA_DevInfo->LBAInfo.HDAreaSectorSize = ( gTNFTL_HiddenInfo[NAND_DRV_0].HiddenPageSize
+					gLBA_DevInfo[0]->LBAInfo.HDAreaSectorSize = ( gTNFTL_ExtPartitionInfo[NAND_DRV_0].ExtPartitionSize[0]
 																						#ifndef NU_FILE_INCLUDE
 																						#ifdef AUDIOUI_INCLUDE
 																						  + AUI_HD_OCCPAGE
@@ -1469,11 +1555,11 @@ int NAND_Ioctl( int function, void *param )
 																						);
 					#endif
 					
-					gLBA_DevInfo->LBAInfo.MHDAreaNums = TNFTL_MULTI_HIDDEN_AREA_NUM;			
+					gLBA_DevInfo[0]->LBAInfo.MHDAreaNums = TNFTL_EXTENDED_PARTITION_NUM;			
 					
 					#ifdef INTERNAL_HIDDEN_STORAGE_INCLUDE					
-					for ( i = 0; i < TNFTL_MULTI_HIDDEN_AREA_NUM; ++i )
-						gLBA_DevInfo->LBAInfo.MHDAreaSectorSize[i] = gTNFTL_HiddenInfo[NAND_DRV_0].MultiHiddenSize[i];
+					for ( i = 0; i < TNFTL_EXTENDED_PARTITION_NUM - 1; ++i )
+						gLBA_DevInfo[0]->LBAInfo.MHDAreaSectorSize[i+1] = gTNFTL_ExtPartitionInfo[NAND_DRV_0].ExtPartitionSize[i+1];
 					#endif
 					
 					gNAND_DrvInfo[0].DrvStatus = DISABLE;
@@ -1569,7 +1655,7 @@ int NAND_Ioctl( int function, void *param )
 				else
 				{
 					#ifdef NAND_LBA_INCLUDE
-					NAND_IO_LBA_ReadSectorBy4Byte( gLBA_DevInfo,
+					NAND_IO_LBA_ReadSectorBy4Byte( *gLBA_DevInfo,
 												   NAND_LBA_VFP,
 												   (U32)hd_r->start_page,
 												   (U16)hd_r->page_offset,
@@ -1584,6 +1670,8 @@ int NAND_Ioctl( int function, void *param )
 			{
 				#ifdef NAND_LBA_INCLUDE			
 				unsigned short	mode = *((unsigned short *)param);
+				unsigned short int	wCSorder;
+				unsigned short int	wMediaNums;
 				#endif
 				
 				if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
@@ -1593,14 +1681,23 @@ int NAND_Ioctl( int function, void *param )
 				else
 				{
 					#ifdef NAND_LBA_INCLUDE
+					NAND_IO_LBA_GetDeviceMediaNums( &wMediaNums );
 
 					if ( mode == DISK_STATE_STANDBY )
 					{
-						NAND_IO_LBA_PowerSaveMode( gLBA_DevInfo, DISABLE );
+						for ( wCSorder = 0; wCSorder < wMediaNums; ++wCSorder )
+						{
+							NAND_IO_LBA_PowerSaveMode( gLBA_DevInfo[wCSorder], DISABLE );
+							NAND_IO_LBA_HighSpeedMode( gLBA_DevInfo[wCSorder], ENABLE );
+						}
 					}
 					else if ( mode == DISK_STATE_IDLE )
 					{
-						NAND_IO_LBA_PowerSaveMode( gLBA_DevInfo, ENABLE );						
+						for ( wCSorder = 0; wCSorder < wMediaNums; ++wCSorder )
+						{
+							NAND_IO_LBA_PowerSaveMode( gLBA_DevInfo[wCSorder], ENABLE );	
+							NAND_IO_LBA_HighSpeedMode( gLBA_DevInfo[wCSorder], DISABLE );
+						}
 					}
 					#endif
 				}					
@@ -1681,6 +1778,21 @@ int NAND_Ioctl( int function, void *param )
 		case	DEV_SET_ALIGEN_CACHE:
 			{
 				unsigned short	mode = *((unsigned short *)param);
+
+				#if defined(USE_V_ADDRESS)				
+				#if defined(_WINCE_)
+				if ( mode == ENABLE )
+		 			RETAILMSG(0, (TEXT("[NAND        ]Align Cache Turn On\r\n")));
+				else
+		 			RETAILMSG(0, (TEXT("[NAND        ]Align Cache Turn Off\r\n")));
+				#else
+				if ( mode == ENABLE )
+					ND_TRACE("\n[NAND        ]Align Cache Turn On");
+				else
+					ND_TRACE("\n[NAND        ]Align Cache Turn Off");					
+				#endif
+				#endif
+				
 				return TNFTL_SetUseAlignCacheMode( gNAND_DrvInfo[0].NFTLDrvInfo, mode );
 			}
 			break;
@@ -1693,7 +1805,7 @@ int NAND_Ioctl( int function, void *param )
 		#ifdef NU_FILE_INCLUDE
 		case	DEV_GET_HIDDEN_SIZE:
 			if (gNAND_DrvInfo[0].DrvStatus == ENABLE)
-				*(int *)param	= NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE;
+				*(int *)param	= NAND_HIDDEN_0_PAGESIZE;
 			else
 				*(int *)param	= -1;
 			break;
@@ -1778,9 +1890,12 @@ int NAND_HDIoctl( int function, void *param )
 			{
 				unsigned short	mode = *((unsigned short *)param);
 
+				if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+				{
 				TNFTL_AREAFormat( gNAND_DrvInfo[0].NFTLDrvInfo,
 								  &gNAND_DrvInfo[0].NFTLDrvInfo->ExtPartition[1],
 								  mode );
+				}
 
 				return NAND_InitDrive(0);
 			}
diff --git a/drivers/block/tcc/nand_io_v7.c b/drivers/block/tcc/nand_io_v7.c
index 6a221d5..19a5bee 100644
--- a/drivers/block/tcc/nand_io_v7.c
+++ b/drivers/block/tcc/nand_io_v7.c
@@ -31,6 +31,7 @@
 #elif defined(_LINUX_)
 #if defined(USE_V_ADDRESS)
 #include <mach/tca_ckc.h>
+#include <mach/irqs.h>
 #else
 #include "ckc.h"
 #endif
@@ -53,7 +54,7 @@
 // Version Signature
 //
 //=============================================================================
-#define NAND_IO_VERSION		'V','7','0','1','1'
+#define NAND_IO_VERSION		'V','7','0','2','2'
 
 static const unsigned char 	NANDIO_Library_Version[] = 
 { 	
@@ -144,39 +145,39 @@ const NAND_IO_FEATURE	TOSHIBA_NAND_DevInfo[] =
     //* 1st, 2nd,  3rd,  4th,  5th,  6th,  PBpV,BBpZ, PpB, Page,Spare,Col,Low,Twc, Ws, Wp, Wh, Rs, Rp, Rh
     //*=======================================================================================================================================================
     // [ 32MB] TC58DVM82A1FT
-    { 0x98, 0x75, 0x00, 0x00, 0x00, 0x00, 2048,  20,  32,  512,   16,  1,  2, 50,	 0, 25, 15,  0, 25, 15, A_08BIT|A_SLC	  	|A_SMALL|S_NOR			   	},
+    { {{0x98, 0x75, 0x00, 0x00, 0x00, 0x00}}, 2048,  20,  32,  512,   16,  1,  2, 50,	 0, 25, 15,  0, 25, 15, (A_08BIT|A_SLC	  	|A_SMALL|S_NOR)			   	},
     // [ 64MB] TC58DVM92A1FT
-    { 0x98, 0x76, 0x00, 0x00, 0x00, 0x00, 4096,  20,  32,  512,   16,  1,  3, 50,	 0, 25, 15,  0, 25, 15, A_08BIT|A_SLC	  	|A_SMALL|S_NOR			  	},
+    { {{0x98, 0x76, 0x00, 0x00, 0x00, 0x00}}, 4096,  20,  32,  512,   16,  1,  3, 50,	 0, 25, 15,  0, 25, 15, (A_08BIT|A_SLC	  	|A_SMALL|S_NOR)			  	},
     // [ 64MB] TC58NWM9S3B
-    { 0x98, 0xF0, 0x00, 0x00, 0x00, 0x00,  512,  10,  64, 2048,   64,  2,  2, 50,	 0, 25, 15,  0, 25, 15, A_08BIT|A_SLC	  	|A_BIG  |S_NOR			   	},
+    { {{0x98, 0xF0, 0x00, 0x00, 0x00, 0x00}},  512,  10,  64, 2048,   64,  2,  2, 50,	 0, 25, 15,  0, 25, 15, (A_08BIT|A_SLC	  	|A_BIG  |S_NOR)			   	},
     // [128MB] TC58DVG02A1FT
-    { 0x98, 0x79, 0x00, 0x00, 0x00, 0x00, 8192,  20,  32,  512,   16,  1,  3, 50,	 0, 25, 15,  0, 25, 15, A_08BIT|A_SLC	  	|A_SMALL|S_NOR			   	},	
+    { {{0x98, 0x79, 0x00, 0x00, 0x00, 0x00}}, 8192,  20,  32,  512,   16,  1,  3, 50,	 0, 25, 15,  0, 25, 15, (A_08BIT|A_SLC	  	|A_SMALL|S_NOR)			   	},	
     // [128MB] TC58NVG0S3AFT
-    { 0x98, 0xF1, 0x00, 0x00, 0x00, 0x00, 1024,  20,  64, 2048,   64,  2,  2, 50,	 0, 25, 15,  0, 25, 15, A_08BIT|A_SLC	  	|A_BIG  |S_NOR			   	},	
+    { {{0x98, 0xF1, 0x00, 0x00, 0x00, 0x00}}, 1024,  20,  64, 2048,   64,  2,  2, 50,	 0, 25, 15,  0, 25, 15, (A_08BIT|A_SLC	  	|A_BIG  |S_NOR)			   	},	
     // [256MB] TH58NVG1S3AFT
-    { 0x98, 0xDA, 0x00, 0x00, 0x00, 0x00, 2048,  20,  64, 2048,   64,  2,  3, 50,	 0, 25, 15,  0, 25, 15, A_08BIT|A_SLC	  	|A_BIG  |S_NOR			   	},
+    { {{0x98, 0xDA, 0x00, 0x00, 0x00, 0x00}}, 2048,  20,  64, 2048,   64,  2,  3, 50,	 0, 25, 15,  0, 25, 15, (A_08BIT|A_SLC	  	|A_BIG  |S_NOR)			   	},
     // [512MB] THGVN0G4D1DTG00
-    { 0x98, 0xDC, 0x00, 0x15, 0x00, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 50,	 0, 25, 15,  0, 35, 15, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_LBA		},
+    { {{0x98, 0xDC, 0x00, 0x15, 0x00, 0x00}}, 4096,  20,  64, 2048,   64,  2,  3, 50,	 0, 25, 15,  0, 35, 15, (A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_LBA)		},
     // [512MB] TH58NYG2S8C
-    { 0x98, 0xBC, 0x91, 0xD5, 0x49, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 50,	 0, 25, 15,  0, 35, 15, A_16BIT|A_SLC	  	|A_BIG  |S_NOR			   	},
+    { {{0x98, 0xBC, 0x91, 0xD5, 0x49, 0x00}}, 4096,  20,  64, 2048,   64,  2,  3, 50,	 0, 25, 15,  0, 35, 15, (A_16BIT|A_SLC	  	|A_BIG  |S_NOR)			   	},
     // [512MB] TH58NYG2S8E
-    { 0x98, 0xBC, 0x90, 0x55, 0x76, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 50,	 0, 25, 15,  0, 35, 15, A_16BIT|A_SLC	  	|A_BIG  |S_NOR			   	},
+    { {{0x98, 0xBC, 0x90, 0x55, 0x76, 0x00}}, 4096,  20,  64, 2048,   64,  2,  3, 50,	 0, 25, 15,  0, 35, 15, (A_16BIT|A_SLC	  	|A_BIG  |S_NOR)			   	},
     // [512MB] TH58NVG2D4CTG00
-    { 0x98, 0xDC, 0x84, 0xA5, 0x60, 0x00, 2048,  40, 128, 2048,   64,  2,  3, 50,	 0, 25, 15,  0, 25, 15, A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP2	   	},
+    { {{0x98, 0xDC, 0x84, 0xA5, 0x60, 0x00}}, 2048,  40, 128, 2048,   64,  2,  3, 50,	 0, 25, 15,  0, 25, 15, (A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP2)	   	},
     // [512MB] TH58NVG2D4BFT00
-    { 0x98, 0xDC, 0x84, 0xA5, 0x54, 0x00, 2048,  40, 128, 2048,   64,  2,  3, 50,	 0, 25, 15,  0, 25, 15, A_08BIT|A_MLC	  	|A_BIG  |S_NOR			   	},
+    { {{0x98, 0xDC, 0x84, 0xA5, 0x54, 0x00}}, 2048,  40, 128, 2048,   64,  2,  3, 50,	 0, 25, 15,  0, 25, 15, (A_08BIT|A_MLC	  	|A_BIG  |S_NOR) 		   	},
     // [  1GB] TH58NVG3D4BFT00
-    { 0x98, 0xD3, 0x85, 0xA5, 0x58, 0x00, 4096,  40, 128, 2048,   64,  2,  3, 50,	 0, 25, 15,  0, 25, 15, A_08BIT|A_MLC	  	|A_BIG  |S_NOR		  	    },
+    { {{0x98, 0xD3, 0x85, 0xA5, 0x58, 0x00}}, 4096,  40, 128, 2048,   64,  2,  3, 50,	 0, 25, 15,  0, 25, 15, (A_08BIT|A_MLC	  	|A_BIG  |S_NOR) 	  	    },
     // [  1GB] TC58NVG3D4CTG00
-    { 0x98, 0xD3, 0x84, 0xA5, 0x66, 0x00, 4096,  40, 128, 2048,   64,  2,  3, 30,	 0, 20, 10,  0, 20, 10, A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP	 		},
+    { {{0x98, 0xD3, 0x84, 0xA5, 0x66, 0x00}}, 4096,  40, 128, 2048,   64,  2,  3, 30,	 0, 20, 10,  0, 20, 10, (A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP) 		},
     // [  2GB] TH58NVG4D4CFT00	[  4GB] TH58NVG5D4CTG20
-    { 0x98, 0xD5, 0x85, 0xA5, 0x00, 0x00, 8192,  40, 128, 2048,   64,  2,  3, 30,	 0, 20, 10,  0, 20, 10, A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP     	},
+    { {{0x98, 0xD5, 0x85, 0xA5, 0x00, 0x00}}, 8192,  40, 128, 2048,   64,  2,  3, 30,	 0, 20, 10,  0, 20, 10, (A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP)    	},
     // [  1GB] TH58NVG3D1DTG00	// 4k Page
-    { 0x98, 0xD3, 0x94, 0xBA, 0x64, 0x00, 2048,  40, 128, 4096,  218,  2,  3, 30,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC_8BIT	|A_BIG  |S_NOR|S_MP			},
+    { {{0x98, 0xD3, 0x94, 0xBA, 0x64, 0x00}}, 2048,  40, 128, 4096,  218,  2,  3, 30,	 0, 15, 10,  0, 15, 10, (A_08BIT|A_MLC_8BIT	|A_BIG  |S_NOR|S_MP)		},
 	// [  2GB] TH58NVG4D1DTG00	[  4GB] TH58NVG5D1DTG20	
-    { 0x98, 0xD5, 0x94, 0x00, 0x00, 0x00, 4096,  40, 128, 4096,  218,  2,  3, 30,	 0, 20, 10,  0, 15, 15, A_08BIT|A_MLC_8BIT	|A_BIG  |S_NOR|S_MP			},
+    { {{0x98, 0xD5, 0x94, 0x00, 0x00, 0x00}}, 4096,  40, 128, 4096,  218,  2,  3, 30,	 0, 20, 10,  0, 15, 15, (A_08BIT|A_MLC_8BIT	|A_BIG  |S_NOR|S_MP)		},
     // [  8GB] TH58NVG6D1DTG20	// 4k Page
-    { 0x98, 0xD7, 0x00, 0x00, 0x00, 0x00, 8192,  40, 128, 4096,  218,  2,  3, 30,	 0, 20, 10,  0, 15, 15, A_08BIT|A_MLC_8BIT	|A_BIG  |S_NOR|S_MP 		}
+    { {{0x98, 0xD7, 0x00, 0x00, 0x00, 0x00}}, 8192,  40, 128, 4096,  218,  2,  3, 30,	 0, 20, 10,  0, 15, 15, (A_08BIT|A_MLC_8BIT	|A_BIG  |S_NOR|S_MP) 		}
 };
 
 const NAND_IO_FEATURE	TOSHIBA_LBA_NAND_DevInfo[] =
@@ -187,11 +188,11 @@ const NAND_IO_FEATURE	TOSHIBA_LBA_NAND_DevInfo[] =
     //* 1st, 2nd,  3rd,  4th,  5th,  6th,  PBpV,BBpZ, PpB, Page,Spare,Col,Low,Twc, Ws, Wp, Wh, Rs, Rp, Rh
     //*=======================================================================================================================================================
     // [  2GB] THGVN0G4D1DTG00
-    { 0x98, 0x21, 0x01, 0x55, 0xAA, 0x00, 8192,  40, 128, 4096,  218,  2,  3, 30,	 0, 20, 10,  0, 15, 15, A_08BIT|A_MLC_8BIT	|A_BIG  |S_NOR|S_MP			},
+    { {{0x98, 0x21, 0x01, 0x55, 0xAA, 0x00}}, 8192,  40, 128, 4096,  218,  2,  3, 30,	 0, 20, 10,  0, 15, 15, (A_08BIT|A_MLC_8BIT	|A_BIG  |S_NOR|S_MP)		},
     // [  8GB] THGVN1G6D4ELA02
-    { 0x98, 0x21, 0x03, 0x55, 0xAA, 0x00, 8192,  40, 128, 4096,  218,  2,  3, 30,	 0, 20, 10,  0, 15, 15, A_08BIT|A_MLC_8BIT	|A_BIG  |S_NOR|S_MP			},
+    { {{0x98, 0x21, 0x03, 0x55, 0xAA, 0x00}}, 8192,  40, 128, 4096,  218,  2,  3, 30,	 0, 20, 10,  0, 15, 15, (A_08BIT|A_MLC_8BIT	|A_BIG  |S_NOR|S_MP)		},
     // [  16GB] THGVN1G7D8ELA09
-    { 0x98, 0x21, 0x04, 0x55, 0xAA, 0x00, 8192,  40, 128, 4096,  218,  2,  3, 30,	 0, 20, 10,  0, 15, 15, A_08BIT|A_MLC_8BIT	|A_BIG  |S_NOR|S_MP			}
+    { {{0x98, 0x21, 0x04, 0x55, 0xAA, 0x00}}, 8192,  40, 128, 4096,  218,  2,  3, 30,	 0, 20, 10,  0, 15, 15, (A_08BIT|A_MLC_8BIT	|A_BIG  |S_NOR|S_MP) 		}
 };
 
 const NAND_IO_FEATURE	HYNIX_NAND_DevInfo[] =
@@ -202,55 +203,59 @@ const NAND_IO_FEATURE	HYNIX_NAND_DevInfo[] =
     //* 1st, 2nd,  3rd,  4th,  5th,  6th,  PBpV,BBpZ, PpB, Page,Spare,Col,Low,Twc, Ws, Wp, Wh, Rs, Rp, Rh
     //*=======================================================================================================================================================
     // [ 32MB] HY27US08561M
-    { 0xAD, 0x75, 0x00, 0x00, 0x00, 0x00, 2048,  20,  32,  512,   16,  1,  2, 50,	 0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	  	|A_SMALL|S_NOR|S_CB        	},
+    { {{0xAD, 0x75, 0x00, 0x00, 0x00, 0x00}}, 2048,  20,  32,  512,   16,  1,  2, 50,	 0, 35, 15,  0, 35, 15, (A_08BIT|A_SLC	  	|A_SMALL|S_NOR|S_CB)       	},
     // [ 64MB] HY27US08121M
-    { 0xAD, 0x76, 0x00, 0x00, 0x00, 0x00, 4096,  20,  32,  512,   16,  1,  3, 60,	 0, 40, 20,  0, 40, 20, A_08BIT|A_SLC	  	|A_SMALL|S_NOR|S_CB        	},
+    { {{0xAD, 0x76, 0x00, 0x00, 0x00, 0x00}}, 4096,  20,  32,  512,   16,  1,  3, 60,	 0, 40, 20,  0, 40, 20, (A_08BIT|A_SLC	  	|A_SMALL|S_NOR|S_CB)       	},
 	// [ 64MB] HY27SS16122A
-    { 0xAD, 0x46, 0xAD, 0x46, 0xAD, 0x00, 4096,  20,  32,  512,   16,  1,  3, 60,	 0, 40, 20,  0, 50, 20, A_16BIT|A_SLC	  	|A_SMALL|S_NOR|S_CB	       	},
+    { {{0xAD, 0x46, 0xAD, 0x46, 0xAD, 0x00}}, 4096,  20,  32,  512,   16,  1,  3, 60,	 0, 40, 20,  0, 50, 20, (A_16BIT|A_SLC	  	|A_SMALL|S_NOR|S_CB)       	},
     // [128MB] HY27UA081G1M
-    { 0xAD, 0x79, 0x00, 0x00, 0x00, 0x00, 8192,  20,  32,  512,   16,  1,  3, 60,	 0, 40, 15,  0, 40, 15, A_08BIT|A_SLC	  	|A_SMALL|S_NOR|S_CB	    	},
+    { {{0xAD, 0x79, 0x00, 0x00, 0x00, 0x00}}, 8192,  20,  32,  512,   16,  1,  3, 60,	 0, 40, 15,  0, 40, 15, (A_08BIT|A_SLC	  	|A_SMALL|S_NOR|S_CB)    	},
     // [128MB] HY27UF081G2M, HY27UF081G2A 
-    { 0xAD, 0xF1, 0x00, 0x00, 0x00, 0x00, 1024,  20,  64, 2048,   64,  2,  2, 50,	 0, 35, 20,  0, 35, 20, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP   	},
+    { {{0xAD, 0xF1, 0x00, 0x00, 0x00, 0x00}}, 1024,  20,  64, 2048,   64,  2,  2, 50,	 0, 35, 20,  0, 35, 20, (A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP ) 	},
 	// [256MB] HY27UF082G2M, HY27UG082G2M
-	{ 0xAD, 0xDA, 0x80, 0x15, 0x00, 0x00, 2048,  20,  64, 2048,   64,  2,  3, 50,	 0, 35, 20,  0, 35, 20, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP   	},
+	{ {{0xAD, 0xDA, 0x80, 0x15, 0x00, 0x00}}, 2048,  20,  64, 2048,   64,  2,  3, 50,	 0, 35, 20,  0, 35, 20, (A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP)  	},
 	// [256MB] HY27UF082G2A
-	{ 0xAD, 0xDA, 0x80, 0x1D, 0x00, 0x00, 2048,  20,  64, 2048,   64,  2,  3, 50,	 0, 35, 20,  0, 35, 20, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP   	},
+	{ {{0xAD, 0xDA, 0x80, 0x1D, 0x00, 0x00}}, 2048,  20,  64, 2048,   64,  2,  3, 50,	 0, 35, 20,  0, 35, 20, (A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP ) 	},
 	// [256MB] HY27UF082G2B
-	{ 0xAD, 0xDA, 0x10, 0x95, 0x44, 0x00, 2048,  20,  64, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_MP			},
+	{ {{0xAD, 0xDA, 0x10, 0x95, 0x44, 0x00}}, 2048,  20,  64, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, (A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_MP)		},
     // [512MB] HY27UF084G2M
-    { 0xAD, 0xDC, 0x80, 0x95, 0x00, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 30,	 0, 20, 10,  0, 20, 10, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP   	},
+    { {{0xAD, 0xDC, 0x80, 0x95, 0x00, 0x00}}, 4096,  20,  64, 2048,   64,  2,  3, 30,	 0, 20, 10,  0, 20, 10, (A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP)  	},
 	// [512MB] HY27UF084G2B
-    { 0xAD, 0xDC, 0x10, 0x95, 0x00, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_MP	},
+    { {{0xAD, 0xDC, 0x10, 0x95, 0x00, 0x00}}, 4096,  20,  64, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, (A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_MP)	},
     // [512MB] HY27UG084G2M, HY27UH084G2M
-    { 0xAD, 0xDC, 0x80, 0x15, 0x00, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 60,	 0, 35, 20,  0, 35, 20, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP   	},
+    { {{0xAD, 0xDC, 0x80, 0x15, 0x00, 0x00}}, 4096,  20,  64, 2048,   64,  2,  3, 60,	 0, 35, 20,  0, 35, 20, (A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP)  	},
     // [512MB] HY27UT084G2M
-    { 0xAD, 0xDC, 0x84, 0x25, 0x00, 0x00, 2048,  40, 128, 2048,   64,  2,  3, 50,	 0, 35, 15,  0, 35, 15, A_08BIT|A_MLC	  	|A_BIG  |S_NOR				},
+    { {{0xAD, 0xDC, 0x84, 0x25, 0x00, 0x00}}, 2048,  40, 128, 2048,   64,  2,  3, 50,	 0, 35, 15,  0, 35, 15, (A_08BIT|A_MLC	  	|A_BIG  |S_NOR)				},
     // [512MB] HY27UT084G2A
-    { 0xAD, 0xDC, 0x14, 0xA5, 0x24, 0x00, 2048,  25, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP			},
+    { {{0xAD, 0xDC, 0x14, 0xA5, 0x24, 0x00}}, 2048,  25, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, (A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP)		},
+    // [512MB] H8BCS0UN0MCR
+    { {{0xAD, 0xBC, 0x10, 0x55, 0x54, 0x00}}, 2048,  25, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, (A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP)		},
     // [  1GB] HY27UH088G2M
-    { 0xAD, 0xD3, 0x80, 0x15, 0x00, 0x00, 8192,  20,  64, 2048,   64,  2,  3, 60,	 0, 35, 20,  0, 35, 20, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP   	},
+    { {{0xAD, 0xD3, 0x80, 0x15, 0x00, 0x00}}, 8192,  20,  64, 2048,   64,  2,  3, 60,	 0, 35, 20,  0, 35, 20, (A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP)  	},
     // [  1GB] HY27UG088G2M  	[  2GB] HY27UH08AG5M
-    { 0xAD, 0xD3, 0xC1, 0x95, 0x00, 0x00, 8192,  20,  64, 2048,   64,  2,  3, 30,	 0, 20, 10,  0, 20, 10, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP 	},
+    { {{0xAD, 0xD3, 0xC1, 0x95, 0x00, 0x00}}, 8192,  20,  64, 2048,   64,  2,  3, 30,	 0, 20, 10,  0, 20, 10, (A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP) 	},
+    // [  2GB] HY27UH08AG5B
+    { {{0xAD, 0xD3, 0x51, 0x95, 0x58, 0x00}}, 8192,  20,  64, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, (A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_MP)	 	},
     // [  1GB] H27U8G8F2M
-    { 0xAD, 0xD3, 0x10, 0xA6, 0x34, 0x00, 4096,  20,  64, 4096,  128,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_MP	 	 	},	
+    { {{0xAD, 0xD3, 0x10, 0xA6, 0x34, 0x00}}, 4096,  20,  64, 4096,  128,  2,  3, 25,	 0, 15, 10,  0, 15, 10, (A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_MP)	 	},	
     // [  1GB] HY27UU088G2M
-    { 0xAD, 0xD3, 0x85, 0x25, 0x00, 0x00, 4096,  40, 128, 2048,   64,  2,  3, 50,	 0, 35, 15,  0, 35, 15, A_08BIT|A_MLC	  	|A_BIG  |S_NOR				},
+    { {{0xAD, 0xD3, 0x85, 0x25, 0x00, 0x00}}, 4096,  40, 128, 2048,   64,  2,  3, 50,	 0, 35, 15,  0, 35, 15, (A_08BIT|A_MLC	  	|A_BIG  |S_NOR)				},
     // [  1GB] HY27UT088G2M  	[  2GB] HY27UU08AG5M
-    { 0xAD, 0xD3, 0x14, 0xA5, 0x64, 0xAD, 4096,  25, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP			},
+    { {{0xAD, 0xD3, 0x14, 0xA5, 0x64, 0xAD}}, 4096,  25, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, (A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP)		},
     // [  1GB] HY27UT088G2A
-    { 0xAD, 0xD3, 0x14, 0xA5, 0x34, 0x00, 4096,  25, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP			},
+    { {{0xAD, 0xD3, 0x14, 0xA5, 0x34, 0x00}}, 4096,  25, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, (A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP)		},
     // [  4GB] HY27UV08BG5M	 	[  8GB] HY27UW08CGFM
-    { 0xAD, 0xD5, 0x55, 0xA5, 0x68,	0x00, 8192,  25, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP			},
+    { {{0xAD, 0xD5, 0x55, 0xA5, 0x68, 0x00}}, 8192,  25, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, (A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP)		},
     // [  4GB] HY27UV08BG5A	 
-    { 0xAD, 0xD5, 0x55, 0xA5, 0x38,	0x00, 8192,  25, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP			},
+    { {{0xAD, 0xD5, 0x55, 0xA5, 0x38, 0x00}}, 8192,  25, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, (A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP)		},
 	// [  2GB] HY27UAG8T2MTR
-    { 0xAD, 0xD5, 0x14, 0xB6, 0x44,	0x00, 4096,  25, 128, 4096,  128,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP		 	},
+    { {{0xAD, 0xD5, 0x14, 0xB6, 0x44, 0x00}}, 4096,  25, 128, 4096,  128,  2,  3, 25,	 0, 15, 10,  0, 15, 10, (A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP)	 	},
     // [  8GB] HY27UCG8V5MTR
-    { 0xAD, 0xD7, 0x55, 0xB6, 0x48,	0x00, 8192,  25, 128, 4096,  128,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP			},
+    { {{0xAD, 0xD7, 0x55, 0xB6, 0x48, 0x00}}, 8192,  25, 128, 4096,  128,  2,  3, 25,	 0, 15, 10,  0, 15, 10, (A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP)		},
 	// [  4GB] HY27UBG8U5A
-    { 0xAD, 0xD5, 0x94, 0x25, 0x44,	0x41, 4096,  25, 128, 4096,  224,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC_12BIT |A_BIG  |S_NOR|S_MCP		},
+    { {{0xAD, 0xD5, 0x94, 0x25, 0x44, 0x41}}, 4096,  25, 128, 4096,  224,  2,  3, 25,	 0, 15, 10,  0, 15, 10, (A_08BIT|A_MLC_12BIT|A_BIG  |S_NOR|S_MCP)		},
 	// [  8GB] HY27UCG8V5A
-    { 0xAD, 0xD7, 0x95, 0x25, 0x48,	0x41, 8192,  25, 128, 4096,  224,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC_12BIT |A_BIG  |S_NOR|S_MCP		}
+    { {{0xAD, 0xD7, 0x95, 0x25, 0x48, 0x41}}, 8192,  25, 128, 4096,  224,  2,  3, 25,	 0, 15, 10,  0, 15, 10, (A_08BIT|A_MLC_12BIT|A_BIG  |S_NOR|S_MCP)		}
 };
 
 const NAND_IO_FEATURE	ST_NAND_DevInfo[] =
@@ -261,33 +266,35 @@ const NAND_IO_FEATURE	ST_NAND_DevInfo[] =
     //* 1st, 2nd,  3rd,  4th,  5th,  6th,  PBpV,BBpZ, PpB, Page,Spare,Col,Low,Twc, Ws, Wp, Wh, Rs, Rp, Rh
     //*=======================================================================================================================================================
     // [ 32MB] NAND256W3A
-    { 0x20, 0x75, 0x00, 0x00, 0x00, 0x00, 2048,  20,  32,  512,   16,  1,  2, 50,  	 0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	  	|A_SMALL|S_NOR			   	},
+    { {{0x20, 0x75, 0x00, 0x00, 0x00, 0x00}}, 2048,  20,  32,  512,   16,  1,  2, 50,  	 0, 35, 15,  0, 35, 15, (A_08BIT|A_SLC	  	|A_SMALL|S_NOR)			   	},
     // [ 64MB] NAND512W3A
-    { 0x20, 0x76, 0x00, 0x00, 0x00, 0x00, 4096,  20,  32,  512,   16,  1,  3, 50,	 0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	  	|A_SMALL|S_NOR			   	},
+    { {{0x20, 0x76, 0x00, 0x00, 0x00, 0x00}}, 4096,  20,  32,  512,   16,  1,  3, 50,	 0, 35, 15,  0, 35, 15, (A_08BIT|A_SLC	  	|A_SMALL|S_NOR)			   	},
     // [128MB] NAND01GW3A
-    { 0x20, 0x79, 0x00, 0x00, 0x00, 0x00, 8192,  20,  32,  512,   16,  1,  3, 50,	 0, 35, 20,  0, 25, 20, A_08BIT|A_SLC	  	|A_SMALL|S_NOR|S_CB|S_CP   	},
+    { {{0x20, 0x79, 0x00, 0x00, 0x00, 0x00}}, 8192,  20,  32,  512,   16,  1,  3, 50,	 0, 35, 20,  0, 25, 20, (A_08BIT|A_SLC	  	|A_SMALL|S_NOR|S_CB|S_CP)  	},
     // [128MB] NAND01GW3B2C
-    { 0x20, 0xF1, 0x00, 0x1D, 0x00, 0x00, 1024,  20,  64, 2048,   64,  2,  2, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_SLC	  	|A_BIG  |S_NOR			 	},
+    { {{0x20, 0xF1, 0x00, 0x1D, 0x00, 0x00}}, 1024,  20,  64, 2048,   64,  2,  2, 25,	 0, 15, 10,  0, 15, 10, (A_08BIT|A_SLC	  	|A_BIG  |S_NOR)			 	},
     // [128MB] NAND01GW3B
-    { 0x20, 0xF1, 0x00, 0x00, 0x00, 0x00, 1024,  20,  64, 2048,   64,  2,  2, 50,	 0, 35, 20,  0, 35, 20, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP   	},
+    { {{0x20, 0xF1, 0x00, 0x00, 0x00, 0x00}}, 1024,  20,  64, 2048,   64,  2,  2, 50,	 0, 35, 20,  0, 35, 20, (A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP)  	},
 	// [256MB] NAND02GW3B2D
-    { 0x20, 0xDA, 0x10, 0x95, 0x44, 0x00, 2048,  20,  64, 2048,   64,  2,  3, 45,	 0, 25, 20,  0, 25, 20, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_MP		   	},
+    { {{0x20, 0xDA, 0x10, 0x95, 0x44, 0x00}}, 2048,  20,  64, 2048,   64,  2,  3, 45,	 0, 25, 20,  0, 25, 20, (A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_MP)	   	},
     // [256MB] NAND02GW3B
-    { 0x20, 0xDA, 0x00, 0x00, 0x00, 0x00, 2048,  20,  64, 2048,   64,  2,  3, 50,	 0, 35, 20,  0, 35, 20, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP   	},
+    { {{0x20, 0xDA, 0x00, 0x00, 0x00, 0x00}}, 2048,  20,  64, 2048,   64,  2,  3, 50,	 0, 35, 20,  0, 35, 20, (A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP)  	},
     // [256MB] NAND02GR4B2DDI6 
-    { 0x20, 0xBA, 0x10, 0x55, 0x44, 0x00, 2048,  20,  64, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_16BIT|A_SLC	  	|A_BIG  |S_NOR|S_MP		  	},
+    { {{0x20, 0xBA, 0x10, 0x55, 0x44, 0x00}}, 2048,  20,  64, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, (A_16BIT|A_SLC	  	|A_BIG  |S_NOR|S_MP)		},
+    // [512MB] NAND04GR4B2DDI6 
+    { {{0x20, 0xBC, 0x10, 0x55, 0x54, 0x00}}, 4096,  20,  64, 2048,   64,  2,  3, 45,	 0, 30, 15,  0, 30, 15, (A_16BIT|A_SLC	  	|A_BIG  |S_NOR|S_MP)		},
 	// [512MB] NAND04GW3B2D
-    { 0x20, 0xDC, 0x10, 0x95, 0x54, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_MP		  	},
+    { {{0x20, 0xDC, 0x10, 0x95, 0x54, 0x00}}, 4096,  20,  64, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, (A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_MP)		},
     // [512MB] NAND04GW3B
-    { 0x20, 0xDC, 0x80, 0x95, 0x00, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 50,	 0, 35, 20,  0, 35, 20, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP   	},
+    { {{0x20, 0xDC, 0x80, 0x95, 0x00, 0x00}}, 4096,  20,  64, 2048,   64,  2,  3, 50,	 0, 35, 20,  0, 35, 20, (A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP)   },
     // [512MB] NAND04GW3C2A
-    { 0x20, 0xDC, 0x84, 0x25, 0x00, 0x00, 2048,  40, 128, 2048,   64,  2,  3, 60,	 0, 40, 20,  0, 40, 20, A_08BIT|A_MLC	  	|A_BIG  |S_NOR				},
+    { {{0x20, 0xDC, 0x84, 0x25, 0x00, 0x00}}, 2048,  40, 128, 2048,   64,  2,  3, 60,	 0, 40, 20,  0, 40, 20, (A_08BIT|A_MLC	  	|A_BIG  |S_NOR)				},
 	// [  1GB] NAND08GW3B2CN6
-    { 0x20, 0xD3, 0x51, 0x95, 0x58, 0x00, 8192,  20,  64, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_MP	|S_IL	},
+    { {{0x20, 0xD3, 0x51, 0x95, 0x58, 0x00}}, 8192,  20,  64, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, (A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_MP	|S_IL)	},
     // [  1GB] NAND08GW3B
-    { 0x20, 0xD3, 0x85, 0x25, 0x00, 0x00, 8192,  20,  64, 2048,   64,  2,  3, 50,	 0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP   	},
+    { {{0x20, 0xD3, 0x85, 0x25, 0x00, 0x00}}, 8192,  20,  64, 2048,   64,  2,  3, 50,	 0, 35, 15,  0, 35, 15, (A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP)  	},
 	// [  1GB] NAND08GW3C2A,	[ 2GB] NAND16GW3C4A 
-    { 0x20, 0xD3, 0x14, 0xA5, 0x00, 0x00, 4096,  20, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP		  	}
+    { {{0x20, 0xD3, 0x14, 0xA5, 0x00, 0x00}}, 4096,  20, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, (A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP)	  	}
 };
 
 const NAND_IO_FEATURE	SAMSUNG_NAND_DevInfo[] =
@@ -298,57 +305,61 @@ const NAND_IO_FEATURE	SAMSUNG_NAND_DevInfo[] =
     //* 1st, 2nd,  3rd,  4th,  5th,  6th,  PBpV,BBpZ, PpB, Page,Spare,Col,Low,Twc, Ws, Wp, Wh, Rs, Rp, Rh
     //*=======================================================================================================================================================
 	// [ 32MB] K9F5608U0B/C/D ~TEST(C) ~TEST(D)   
-    { 0xEC, 0x75, 0x00, 0x00, 0x00, 0x00, 2048,  20,  32,  512,   16,  1,  2, 50,  	0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	 	|A_SMALL|S_NOR|S_CB        	},
+    { {{0xEC, 0x75, 0x00, 0x00, 0x00, 0x00}}, 2048,  20,  32,  512,   16,  1,  2, 50,  	0, 35, 15,  0, 35, 15, (A_08BIT|A_SLC	 	|A_SMALL|S_NOR|S_CB)       	},
     // [ 64MB] K9F1208U0M/A/B
-    { 0xEC, 0x76, 0xA5, 0xC0, 0x00, 0x00, 4096,  20,  32,  512,   16,  1,  3, 50,  	0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	 	|A_SMALL|S_NOR|S_CB    	 	},
+    { {{0xEC, 0x76, 0xA5, 0xC0, 0x00, 0x00}}, 4096,  20,  32,  512,   16,  1,  3, 50,  	0, 35, 15,  0, 35, 15, (A_08BIT|A_SLC	 	|A_SMALL|S_NOR|S_CB)   	 	},
     // [ 64MB] K9F1208U0C: ~TEST(C) WC: 42 WP: 21 WH: 15 
-    { 0xEC, 0x76, 0x5A, 0x3F, 0x00, 0x00, 4096,  20,  32,  512,   16,  1,  3, 50,  	0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	 	|A_SMALL|S_NOR		   	 	},
+    { {{0xEC, 0x76, 0x5A, 0x3F, 0x00, 0x00}}, 4096,  20,  32,  512,   16,  1,  3, 50,  	0, 35, 15,  0, 35, 15, (A_08BIT|A_SLC	 	|A_SMALL|S_NOR)		   	 	},
     // [128MB] K9K1G08U0M/A/B: ~TEST(B) 
-    { 0xEC, 0x79, 0xA5, 0xC0, 0x00, 0x00, 8192,  20,  32,  512,   16,  1,  3, 50,  	0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	 	|A_SMALL|S_NOR|S_CB    	 	},
+    { {{0xEC, 0x79, 0xA5, 0xC0, 0x00, 0x00}}, 8192,  20,  32,  512,   16,  1,  3, 50,  	0, 35, 15,  0, 35, 15, (A_08BIT|A_SLC	 	|A_SMALL|S_NOR|S_CB)   	 	},
     // [128MB] K9F1G08U0M,A
-    { 0xEC, 0xF1, 0x80, 0x15, 0x40, 0x00, 1024,  20,  64, 2048,   64,  2,  2, 50,  	0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	 	|A_BIG  |S_NOR|S_CB|S_CP	},
+    { {{0xEC, 0xF1, 0x80, 0x15, 0x40, 0x00}}, 1024,  20,  64, 2048,   64,  2,  2, 50,  	0, 35, 15,  0, 35, 15, (A_08BIT|A_SLC	 	|A_BIG  |S_NOR|S_CB|S_CP)	},
     // [128MB] K9F1G08U0C	K9F1G08U0B[ Twc:50 Ws: 0 Wp: 35 Wh: 15]
-    { 0xEC, 0xF1, 0x00, 0x95, 0x40, 0x00, 1024,  20,  64, 2048,   64,  2,  2, 25,  	0, 15, 10,  0, 15, 10, A_08BIT|A_SLC	 	|A_BIG  |S_NOR|S_CB	 	  	},
+    { {{0xEC, 0xF1, 0x00, 0x95, 0x40, 0x00}}, 1024,  20,  64, 2048,   64,  2,  2, 50,  	0, 35, 15,  0, 35, 15, (A_08BIT|A_SLC	 	|A_BIG  |S_NOR|S_CB) 	  	},
     // [256MB] KBE00S00AB	MCP MEMORY - Supply Voltage: Vcc 2.5 ~ 2.9 
-    { 0xEC, 0x71, 0x5A, 0x3F, 0x00, 0x00,16384,  20,  32,  512,   16,  1,  3, 50,  	0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	 	|A_SMALL|S_NOR	    	 	},
+    { {{0xEC, 0x71, 0x5A, 0x3F, 0x00, 0x00}},16384,  20,  32,  512,   16,  1,  3, 50,  	0, 35, 15,  0, 35, 15, (A_08BIT|A_SLC	 	|A_SMALL|S_NOR)     	 	},
 	// [256MB] K9F2G08U0M, K9K2G08U0M/A ~TEST(A)
-    { 0xEC, 0xDA, 0x00, 0x15, 0x00, 0x00, 2048,  20,  64, 2048,   64,  2,  3, 50,  	0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	 	|A_BIG  |S_NOR|S_CB|S_CP 	},
+    { {{0xEC, 0xDA, 0x00, 0x15, 0x00, 0x00}}, 2048,  20,  64, 2048,   64,  2,  3, 50,  	0, 35, 15,  0, 35, 15, (A_08BIT|A_SLC	 	|A_BIG  |S_NOR|S_CB|S_CP)	},
 	// [256MB] K9F2G08U0A
-    { 0xEC, 0xDA, 0x10, 0x95, 0x44, 0x00, 2048,  20,  64, 2048,   64,  2,  3, 25,  	0, 15, 10,  0, 15, 10, A_08BIT|A_SLC     	|A_BIG  |S_NOR|S_MP	  		},
-    // [512MB] K524G2GACB (mddr MCP)
-    { 0xEC, 0xBC, 0x00, 0x55, 0x54, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 40,  	0, 21, 10,  0, 21, 10, A_16BIT|A_SLC	 	|A_BIG  |S_NOR			   	},
+    { {{0xEC, 0xDA, 0x10, 0x95, 0x44, 0x00}}, 2048,  20,  64, 2048,   64,  2,  3, 25,  	0, 15, 10,  0, 15, 10, (A_08BIT|A_SLC     	|A_BIG  |S_NOR|S_MP)  		},
+    // [512MB] K524G2GACB (mddr MCP)	YKG038QX
+    { {{0xEC, 0xBC, 0x00, 0x55, 0x54, 0x00}}, 4096,  20,  64, 2048,   64,  2,  3, 40,  	0, 21, 10,  0, 21, 10, (A_16BIT|A_SLC	 	|A_BIG  |S_NOR)			   	},
+    // [512MB] K524G2GACB (mddr MCP)	YKG040A3
+    { {{0xEC, 0xBC, 0x00, 0x55, 0x56, 0x00}}, 4096,  20,  64, 2048,   64,  2,  3, 40,  	0, 21, 10,  0, 21, 10, (A_16BIT|A_SLC	 	|A_BIG  |S_NOR) 		   	},
     // [512MB] K9K4G08U0M
-    { 0xEC, 0xDC, 0xC1, 0x15, 0x00, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 30,  	0, 20, 10,  0, 20, 10, A_08BIT|A_SLC	 	|A_BIG  |S_NOR|S_CB|S_CP   	},
+    { {{0xEC, 0xDC, 0xC1, 0x15, 0x00, 0x00}}, 4096,  20,  64, 2048,   64,  2,  3, 30,  	0, 20, 10,  0, 20, 10, (A_08BIT|A_SLC	 	|A_BIG  |S_NOR|S_CB|S_CP)  	},
     // [512MB] K9F4G08U0M
-    { 0xEC, 0xDC, 0x10, 0x95, 0x00, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 25,  	0, 15, 10,  0, 15, 10, A_08BIT|A_SLC	 	|A_BIG  |S_NOR|S_CB		    },
+    { {{0xEC, 0xDC, 0x10, 0x95, 0x00, 0x00}}, 4096,  20,  64, 2048,   64,  2,  3, 25,  	0, 15, 10,  0, 15, 10, (A_08BIT|A_SLC	 	|A_BIG  |S_NOR|S_CB)	    },
     // [256MB] K9G2G08U0M
-	{ 0xEC, 0xDA, 0x14, 0x25, 0x44, 0x00, 1024,  25, 128, 2048,   64,  2,  3, 30,  	0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	 	|A_BIG  |S_NOR|S_MP	 		},	
+	{ {{0xEC, 0xDA, 0x14, 0x25, 0x44, 0x00}}, 1024,  25, 128, 2048,   64,  2,  3, 30,  	0, 15, 10,  0, 15, 10, (A_08BIT|A_MLC	 	|A_BIG  |S_NOR|S_MP) 		},	
     // [512MB] K9G4G08U0M/A		[  1GB] K9L8G08U1M
-    { 0xEC, 0xDC, 0x14, 0x25, 0x54, 0x00, 2048,  40, 128, 2048,   64,  2,  3, 30,  	0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	 	|A_BIG  |S_NOR|S_MP	    	},
+    { {{0xEC, 0xDC, 0x14, 0x25, 0x54, 0x00}}, 2048,  40, 128, 2048,   64,  2,  3, 30,  	0, 15, 10,  0, 15, 10, (A_08BIT|A_MLC	 	|A_BIG  |S_NOR|S_MP)    	},
     // [512MB] K9G4G08U0B
-    { 0xEC, 0xDC, 0x14, 0xA5, 0x54, 0x00, 2048,  25, 128, 2048,   64,  2,  3, 25,  	0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	 	|A_BIG  |S_NOR|S_MP	    	},
+    { {{0xEC, 0xDC, 0x14, 0xA5, 0x54, 0x00}}, 2048,  25, 128, 2048,   64,  2,  3, 25,  	0, 15, 10,  0, 15, 10, (A_08BIT|A_MLC	 	|A_BIG  |S_NOR|S_MP)    	},
     // [  1GB] K9K8G08UOM		[  2GB] K9WAG08U1M 	
-    { 0xEC, 0xD3, 0x51, 0x95, 0x00, 0x00, 8192,  20,  64, 2048,   64,  2,  3, 25,  	0, 15, 10,  0, 15, 10, A_08BIT|A_SLC	 	|A_BIG  |S_NOR|S_CB			},
+    { {{0xEC, 0xD3, 0x51, 0x95, 0x00, 0x00}}, 8192,  20,  64, 2048,   64,  2,  3, 25,  	0, 15, 10,  0, 15, 10, (A_08BIT|A_SLC	 	|A_BIG  |S_NOR|S_CB)		},
     // [  1GB] K9L8G08UOM		[  2GB] K9HAG08U1M
-    { 0xEC, 0xD3, 0x55, 0x25, 0x00, 0x00, 4096,  40, 128, 2048,   64,  2,  3, 35,  	0, 25, 10,  0, 25, 10, A_08BIT|A_MLC	 	|A_BIG  |S_NOR|S_MP|S_IL   	},
+    { {{0xEC, 0xD3, 0x55, 0x25, 0x00, 0x00}}, 4096,  40, 128, 2048,   64,  2,  3, 35,  	0, 25, 10,  0, 25, 10, (A_08BIT|A_MLC	 	|A_BIG  |S_NOR|S_MP|S_IL)  	},
     // [  1GB] K9G8G08UOM		[  2GB] K9LAG08U1M 
-    { 0xEC, 0xD3, 0x14, 0x25, 0x64, 0x00, 4096,  40, 128, 2048,   64,  2,  3, 35,  	0, 25, 10,  0, 25, 10, A_08BIT|A_MLC	 	|A_BIG  |S_NOR|S_MP			},
+    { {{0xEC, 0xD3, 0x14, 0x25, 0x64, 0x00}}, 4096,  40, 128, 2048,   64,  2,  3, 35,  	0, 25, 10,  0, 25, 10, (A_08BIT|A_MLC	 	|A_BIG  |S_NOR|S_MP)		},
     // [  1GB] K9G8G08UOA/B		[  2GB] K9LAG08U1A 
-    { 0xEC, 0xD3, 0x14, 0xA5, 0x64, 0x00, 4096,  25, 128, 2048,   64,  2,  3, 50,  	0, 30, 20,  0, 30, 20, A_08BIT|A_MLC	 	|A_BIG  |S_NOR|S_MP			},	
+    { {{0xEC, 0xD3, 0x14, 0xA5, 0x64, 0x00}}, 4096,  25, 128, 2048,   64,  2,  3, 50,  	0, 30, 20,  0, 30, 20, (A_08BIT|A_MLC	 	|A_BIG  |S_NOR|S_MP)		},	
     // [  2GB] K9LAG08UOM	  	[  4GB] K9HBG08U1M	  [  8GB] K9MCG08U5M
-    { 0xEC, 0xD5, 0x55, 0x25, 0x68, 0x00, 8192,  40, 128, 2048,   64,  2,  3, 30,  	0, 20, 10,  0, 20, 10, A_08BIT|A_MLC	 	|A_BIG  |S_NOR|S_MP|S_IL	},
+    { {{0xEC, 0xD5, 0x55, 0x25, 0x68, 0x00}}, 8192,  40, 128, 2048,   64,  2,  3, 30,  	0, 20, 10,  0, 20, 10, (A_08BIT|A_MLC	 	|A_BIG  |S_NOR|S_MP|S_IL)	},
 	// [  2GB] K9LAG08UOA/B	 
-	{ 0xEC, 0xD5, 0x55, 0xA5, 0x68, 0x00, 8192,  25, 128, 2048,   64,  2,  3, 25,  	0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	 	|A_BIG  |S_NOR|S_MP|S_IL	},
+	{ {{0xEC, 0xD5, 0x55, 0xA5, 0x68, 0x00}}, 8192,  25, 128, 2048,   64,  2,  3, 25,  	0, 15, 10,  0, 15, 10, (A_08BIT|A_MLC	 	|A_BIG  |S_NOR|S_MP|S_IL)	},
     // [  2GB] K9GAG08UOM	// 4K Page
-    { 0xEC, 0xD5, 0x14, 0xB6, 0x74, 0x00, 4096,  25, 128, 4096,  128,  2,  3, 25,  	0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	 	|A_BIG  |S_NOR|S_MP			},
+    { {{0xEC, 0xD5, 0x14, 0xB6, 0x74, 0x00}}, 4096,  25, 128, 4096,  128,  2,  3, 25,  	0, 15, 10,  0, 15, 10, (A_08BIT|A_MLC	 	|A_BIG  |S_NOR|S_MP)		},
     // [  4GB] K9LBG08UOM		[  8GB] K9HCG08U1M    [ 16G] K9MDG08U5M
-    { 0xEC, 0xD7, 0x55, 0xB6, 0x78, 0x00, 8192,  25, 128, 4096,  128,  2,  3, 25,  	0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	 	|A_BIG  |S_NOR|S_MP|S_IL	},
+    { {{0xEC, 0xD7, 0x55, 0xB6, 0x78, 0x00}}, 8192,  25, 128, 4096,  128,  2,  3, 25,  	0, 15, 10,  0, 15, 10, (A_08BIT|A_MLC	 	|A_BIG  |S_NOR|S_MP|S_IL)	},
     // [  2GB] K9GAG08UOD		[ 4GB] K9LBG08U1D	  [ 8GB] K9HCG08U5D
-    { 0xEC, 0xD5, 0x94, 0x29, 0x34, 0x41, 4096,  25, 128, 4096,  218,  2,  3, 30,   0, 15, 10,  0, 15, 10, A_08BIT|A_MLC_8BIT	|A_BIG  |S_NOR|S_MCP		},
+    { {{0xEC, 0xD5, 0x94, 0x29, 0x34, 0x41}}, 4096,  25, 128, 4096,  218,  2,  3, 30,   0, 15, 10,  0, 15, 10, (A_08BIT|A_MLC_8BIT	|A_BIG  |S_NOR|S_MCP)		},
     // [  4GB] K9LBG08UOD		[  8GB] K9HCG08U1D	  [ 16G] K9MDG08U5D   [ 32G] K9PDG08U5D
-    { 0xEC, 0xD7, 0xD5, 0x29, 0x38, 0x41, 8192,  25, 128, 4096,  218,  2,  3, 30,  	0, 20, 10,  0, 20, 10, A_08BIT|A_MLC_8BIT	|A_BIG  |S_NOR|S_MP|S_IL	},
+    { {{0xEC, 0xD7, 0xD5, 0x29, 0x38, 0x41}}, 8192,  25, 128, 4096,  218,  2,  3, 30,  	0, 20, 10,  0, 20, 10, (A_08BIT|A_MLC_8BIT	|A_BIG  |S_NOR|S_MP|S_IL)	},
     // [  4GB] K9GBG08U0M		[  8GB] K9LCG08U1M		[ 16GB] K9HDG08U5M
-    { 0xEC, 0xD7, 0x94, 0x72, 0x54, 0x42, 4096,  20, 128, 8192,  436,  2,  3, 30,  	0, 20, 10,  0, 20, 10, A_08BIT|A_MLC_16BIT  |A_BIG  |S_NOR|S_MCP		}
+    { {{0xEC, 0xD7, 0x94, 0x72, 0x54, 0x42}}, 4096,  20, 128, 8192,  436,  2,  3, 30,  	0, 20, 10,  0, 20, 10, (A_08BIT|A_MLC_16BIT |A_BIG  |S_NOR|S_MCP)		},
+	// [  32GB] K9PFG08U5M
+    { {{0xEC, 0xDE, 0xD5, 0x72, 0x58, 0x42}}, 8192,  15, 128, 8192,  436,  2,  3, 30,  	0, 20, 10,  0, 20, 10, (A_08BIT|A_MLC_16BIT |A_BIG  |S_NOR|S_MP|S_IL|S_EB)	}
 };
 
 const NAND_IO_FEATURE	MICRON_NAND_DevInfo[] =
@@ -359,61 +370,78 @@ const NAND_IO_FEATURE	MICRON_NAND_DevInfo[] =
     //* 1st, 2nd,  3rd,  4th,  5th,  6th,  PBpV,BBpZ, PpB, Page,Spare,Col,Low,Twc, Ws, Wp, Wh, Rs, Rp, Rh
     //*=======================================================================================================================================================
     // [256MB] 29F2G08AAC		
-    { 0x2C, 0xDA, 0x00, 0x00, 0x00, 0x00, 2048,  20,  64, 2048,   64,  2,  3, 30,	 0, 25, 15,  0, 25, 15, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CP    	    },
+    { {{0x2C, 0xDA, 0x00, 0x00, 0x00, 0x00}}, 2048,  20,  64, 2048,   64,  2,  3, 30,	 0, 25, 15,  0, 25, 15, (A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CP)   	    },
     // [512MB] 29F4G08BAC,		[  1GB] 29F8G08FAC
-    { 0x2C, 0xDC, 0x80, 0x15, 0x50, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 30,	 0, 25, 15,  0, 25, 15, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CP		    },
+    { {{0x2C, 0xDC, 0x80, 0x15, 0x50, 0x00}}, 4096,  20,  64, 2048,   64,  2,  3, 30,	 0, 25, 15,  0, 25, 15, (A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CP)	    },
     // [512MB] 29F4G08AAA/C		[  1GB] 29F8G08DAA
-    { 0x2C, 0xDC, 0x90, 0x95, 0x54, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 30,	 0, 25, 15,  0, 25, 15, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_MP			},
+    { {{0x2C, 0xDC, 0x90, 0x95, 0x54, 0x00}}, 4096,  20,  64, 2048,   64,  2,  3, 30,	 0, 25, 15,  0, 25, 15, (A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_MP)		},
     // [  2GB] 29F16G08FAA
-    { 0x2C, 0xD3, 0xD1, 0x95, 0x58, 0x00, 8192,  20,  64, 2048,   64,  2,  3, 30,	 0, 25, 15,  0, 25, 15, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP	},
+    { {{0x2C, 0xD3, 0xD1, 0x95, 0x58, 0x00}}, 8192,  20,  64, 2048,   64,  2,  3, 30,	 0, 25, 15,  0, 25, 15, (A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP)	},
+    // [  1GB] MT29F8G08ABA (4Bit/540Bytes)		
+    { {{0x2C, 0x38, 0x00, 0x26, 0x85, 0x00}}, 2048,  20, 128, 4096,  224,  2,  3, 25,	 0, 15, 10,  0, 15, 10, (A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_MP)		},
     // [  1GB] 29F08G08MAA   	[  2GB] 29F16G08QAA
-    { 0x2C, 0xD3, 0x94, 0xA5, 0x64, 0x00, 4096,  40, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP			},
+    { {{0x2C, 0xD3, 0x94, 0xA5, 0x64, 0x00}}, 4096,  40, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, (A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP)		},
     // [  4GB] 29F32G08TAA
-    { 0x2C, 0xD5, 0xD5, 0xA5, 0x68, 0x00, 8192,  40, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP			},
+    { {{0x2C, 0xD5, 0xD5, 0xA5, 0x68, 0x00}}, 8192,  40, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, (A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP)		},
     // [  2GB] 29F16G08MAA		[  4GB] 29F32G08QAA 
-	{ 0x2C, 0xD5, 0x94, 0x3E, 0x74, 0x00, 4096,  25, 128, 4096,  218,  2,  3, 30,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC_8BIT	|A_BIG  |S_NOR|S_MP			},
+	{ {{0x2C, 0xD5, 0x94, 0x3E, 0x74, 0x00}}, 4096,  25, 128, 4096,  218,  2,  3, 30,	 0, 15, 10,  0, 15, 10, (A_08BIT|A_MLC_8BIT	|A_BIG  |S_NOR|S_MP)		},
 	// [  8GB] 29F64G08TAA
-	{ 0x2C, 0xD7, 0xD5, 0x3E, 0x78, 0x00, 8192,  25, 128, 4096,  218,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC_8BIT	|A_BIG  |S_NOR|S_MP|S_IL	},
+	{ {{0x2C, 0xD7, 0xD5, 0x3E, 0x78, 0x00}}, 8192,  25, 128, 4096,  218,  2,  3, 25,	 0, 15, 10,  0, 15, 10, (A_08BIT|A_MLC_8BIT	|A_BIG  |S_NOR|S_MP|S_IL)	},
 	// [  4GB] 29F32G08CBAAA, 	[  8GB] 29F64G08CFAAA 
-	{ 0x2C, 0xD7, 0x94, 0x3E, 0x84, 0x00, 8192,  25, 128, 4096,  218,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC_12BIT	|A_BIG  |S_NOR|S_MCP		},
+	{ {{0x2C, 0xD7, 0x94, 0x3E, 0x84, 0x00}}, 8192,  25, 128, 4096,  218,  2,  3, 25,	 0, 15, 10,  0, 15, 10, (A_08BIT|A_MLC_12BIT|A_BIG  |S_NOR|S_MCP)		},
 	// [  4GB] 29F32G08CBABA, 	[  8GB] 29F64G08CFABA 
-	{ 0x2C, 0x68, 0x04, 0x46, 0x89, 0x00, 4096,  25, 256, 4096,  224,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC_12BIT	|A_BIG  |S_NOR|S_MCP		},
+	{ {{0x2C, 0x68, 0x04, 0x46, 0x89, 0x00}}, 4096,  25, 256, 4096,  224,  2,  3, 25,	 0, 15, 10,  0, 15, 10, (A_08BIT|A_MLC_12BIT|A_BIG  |S_NOR|S_MCP)		},
 	// [ 16GB] 29F128G08CJAA 
-	{ 0x2C, 0xD9, 0xD5, 0x3E, 0x88, 0x00,16384,  25, 128, 4096,  218,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC_12BIT	|A_BIG  |S_NOR|S_MP|S_IL	},
+	{ {{0x2C, 0xD9, 0xD5, 0x3E, 0x88, 0x00}},16384,  25, 128, 4096,  218,  2,  3, 25,	 0, 15, 10,  0, 15, 10, (A_08BIT|A_MLC_12BIT|A_BIG  |S_NOR|S_MP|S_IL)	},
 	// [ 16GB] 29F128G08CJBA 
-	{ 0x2C, 0x88, 0x05, 0xC6, 0x89, 0x00, 8192,  25, 256, 4096,  224,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC_12BIT	|A_BIG  |S_NOR|S_MP|S_IL	}	
+	{ {{0x2C, 0x88, 0x05, 0xC6, 0x89, 0x00}}, 8192,  25, 256, 4096,  224,  2,  3, 25,	 0, 15, 10,  0, 15, 10, (A_08BIT|A_MLC_12BIT|A_BIG  |S_NOR|S_MP|S_IL)	}	
+};
+
+const NAND_IO_FEATURE	INTEL_NAND_DevInfo[] =
+{
+	//*=======================================================================================================================================================
+    //*[        DEVICE CODE       ][           SIZE            ][               Cycle                     ][               		   ATTRIBUTE                 ]
+    //*-------------------------------------------------------------------------------------------------------------------------------------------------------
+    //* 1st, 2nd,  3rd,  4th,  5th,  6th,  PBpV,BBpZ, PpB, Page,Spare,Col,Low,Twc, Ws, Wp, Wh, Rs, Rp, Rh
+    //*=======================================================================================================================================================
+    // [  4GB] JS29F32G08AAMD1 	[  8GB] JS29F64G08CAMD1 	[ 16GB] JS29F16B08JAMD1
+	{ {{0x89, 0xD7, 0x94, 0x3E, 0x84, 0x00}}, 8192,  40, 128, 4096,  218,  2,  3, 25,	 0, 15, 10,  0, 15, 10, (A_08BIT|A_MLC_12BIT|A_BIG  |S_NOR|S_MCP)		}
 };
 
 const NAND_IO_MAKERINFO	NAND_SupportMakerInfo =
  {
 	// MAXIMUM SUPPORT NANDFLASH
-	MAX_SUPPORT_SAMSUNG_NAND,
+	{MAX_SUPPORT_SAMSUNG_NAND,
 	MAX_SUPPORT_TOSHIBA_NAND,
 	MAX_SUPPORT_HYNIX_NAND,
 	MAX_SUPPORT_ST_NAND,
 	MAX_SUPPORT_MICRON_NAND,
+	MAX_SUPPORT_INTEL_NAND},
 	// NAND MAKER ID
-	SAMSUNG_NAND_MAKER_ID,
+	{SAMSUNG_NAND_MAKER_ID,
 	TOSHIBA_NAND_MAKER_ID,
 	HYNIX_NAND_MAKER_ID,
 	ST_NAND_MAKER_ID,
 	MICRON_NAND_MAKER_ID,
+	INTEL_NAND_MAKER_ID},
+	
 	// POINTER OF NANDFLASH INFOMATION
-	(NAND_IO_FEATURE*)SAMSUNG_NAND_DevInfo,
+	{(NAND_IO_FEATURE*)SAMSUNG_NAND_DevInfo,
 	(NAND_IO_FEATURE*)TOSHIBA_NAND_DevInfo,
 	(NAND_IO_FEATURE*)HYNIX_NAND_DevInfo,
 	(NAND_IO_FEATURE*)ST_NAND_DevInfo,
-	(NAND_IO_FEATURE*)MICRON_NAND_DevInfo	
+	(NAND_IO_FEATURE*)MICRON_NAND_DevInfo,
+	(NAND_IO_FEATURE*)INTEL_NAND_DevInfo}
 };
 
 const NAND_IO_LBA_MAKERINFO	LBA_NAND_SupportMakerInfo =
  {
 	// MAXIMUM SUPPORT NANDFLASH
-	MAX_SUPPORT_TOSHIBA_LBA_NAND,
+	{MAX_SUPPORT_TOSHIBA_LBA_NAND},
 	// NAND MAKER ID
-	TOSHIBA_NAND_MAKER_ID,
+	{TOSHIBA_NAND_MAKER_ID},
 	// POINTER OF NANDFLASH INFOMATION
-	(NAND_IO_FEATURE*)TOSHIBA_LBA_NAND_DevInfo
+	{(NAND_IO_FEATURE*)TOSHIBA_LBA_NAND_DevInfo}
 };
 
 const unsigned char NAND_LBA_VFP_AREA_Signature[] =
@@ -593,13 +621,13 @@ NAND_IO_ECC_INFO	gMLC_ECC_12Bit;
 NAND_IO_ECC_INFO	gMLC_ECC_14Bit;
 NAND_IO_ECC_INFO	gMLC_ECC_16Bit;
 
-	
 unsigned int		gNAND_IO_DataBusType;
 
 PGPIO 				pGPIO;
 PNFC				pNFC;
 PECC				pECC;
 PIOBUSCFG			pIOBUSCFG_T;
+PPIC 				pPIC;
 #if defined(_WINCE_)
 tSYSTEM_PARAM  		*pSYS_PARAM;
 #endif
@@ -643,6 +671,13 @@ sDRV_GDMA			gDRV_GDMA_NAND	=
 };
 #endif
 
+#if defined(USE_V_ADDRESS) && defined(_WINCE_)
+DWORD		gNFC_IRQ_Intr;
+DWORD		gEXT_IRQ_Intr;
+HANDLE 		gNFC_IRQ_Handle = NULL;
+HANDLE 		gEXT_IRQ_Handle = NULL;
+#endif
+
 //#define SPEED_CHECK
 #if defined(SPEED_CHECK)
 //#define READ_SPEED_CHECK
@@ -655,7 +690,12 @@ unsigned char				gNAND_IO_ShareEccBuffer[ 1024 ];
 unsigned char				gNAND_IO_TempBuffer[ 32 ];
 #pragma pack()
 #elif defined(_LINUX_)
+#if defined(USE_V_ADDRESS)
+unsigned char				*gNAND_IO_ShareEccBuffer;
+unsigned char				*gNAND_IO_ShareEccBuffer_w;
+#else
 unsigned char				gNAND_IO_ShareEccBuffer[ 1024 ] __attribute__((aligned(8)));
+#endif
 unsigned char				gNAND_IO_TempBuffer[ 32 ] __attribute__((aligned(8)));
 #else
 __align(8) unsigned char	gNAND_IO_ShareEccBuffer[ 1024 ];
@@ -675,9 +715,7 @@ static __inline void				NAND_IO_SetDataWidth( U32 width );
 static __inline void				NAND_IO_PreProcess( void );
 static __inline void				NAND_IO_PostProcess( void );
 static __inline void				NAND_IO_SetBasicCycleTime( void );
-static __inline void				NAND_IO_SetCommCycleTime( void );
 static __inline void				NAND_IO_SetWriteCycleTime(void);
-static __inline void				NAND_IO_SetReadCycleTime(void);
 static __inline void				NAND_IO_EnableChipSelect( U16 nChipNo );
 static __inline void				NAND_IO_DisableChipSelect( void );
 static __inline void				NAND_IO_EnableWriteProtect( void );
@@ -686,10 +724,7 @@ static __inline U32					NAND_IO_CheckReadyAndBusy( U16 nChipNo);
 static __inline void				NAND_IO_WaitBusy( U16 nChipNo );
 static __inline void				NAND_IO_WaitBusyForProgramAndErase( NAND_IO_DEVINFO *nDevInfo );
 static __inline void				NAND_IO_WaitBusyForCacheProgram( NAND_IO_DEVINFO *nDevInfo );
-
 static __inline void 				NAND_IO_ClearInterleaveStatus( NAND_IO_DEVINFO *nDevInfo );
-static __inline void 				NAND_IO_SetInterleaveStatus( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr );
-
 static __inline void				NAND_IO_Delay( void );
 
 static __inline NAND_IO_ERROR  		NAND_IO_WaitBusyForInterleave( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr );
@@ -703,44 +738,44 @@ static __inline NAND_IO_ERROR		NAND_IO_GenerateRowColAddrForRead( U32 nPageAddr,
 static __inline NAND_IO_ERROR		NAND_IO_GenerateRowColAddrForWrite( U32 nPageAddr, U16 nColumnAddr, U32* rRowAddr, U32* rColumnAddr, NAND_IO_DEVINFO *nDevInfo );
 static __inline NAND_IO_ERROR		NAND_IO_GenerateRowColAddrForCBandCP( U32 nPageAddr, U16 nColumnAddr, U32* rRowAddr, U32* rColumnAddr, NAND_IO_DEVINFO *nDevInfo );
 static __inline void				NAND_IO_WriteRowColAddr( U32 nRowAddr, U32 nColumnAddr, NAND_IO_DEVINFO *nDevInfo );
-static __inline void 				NAND_IO_WriteColAddr( U32 nColumnAddr, NAND_IO_DEVINFO *nDevInfo );
 static __inline void				NAND_IO_WriteBlockPageAddr( U32 nBlockPageAddr, NAND_IO_DEVINFO *nDevInfo );
 static __inline void				NAND_IO_BusControl( NAND_IO_DEVINFO *nDevInfo );
 
-#if defined(NAND_IO_USE_DMA_ACCESS)
 static __inline void 				NAND_IO_SetupDMA(void * pSRC, unsigned uSrcInc, unsigned uSrcMask, void * pDST, unsigned uDstInc, unsigned uDstMask, int nMode, int nDSize );
+static __inline void 				NAND_IO_SetupDMA_kernel(void * pSRC, unsigned uSrcInc, unsigned uSrcMask, void * pDST, unsigned uDstInc, unsigned uDstMask, int nMode, int nDSize );
 static __inline void 				NAND_IO_SetupDMADoubleBuf(  int nMode, int nDMACh );
-#endif
+
 static __inline void				NAND_IO_SetupECC( U16 nEccOnOff, U16 nEncDec, U16 nEccType, U16 nAccessType, U32 EccBaseAddr );
 static __inline NAND_IO_ERROR 		NAND_IO_EncodeECC( U16 nEccType, U8* nSpareBuffer );
 static __inline NAND_IO_ERROR		NAND_IO_CorrectionSLC( U8* nPageBuffer, U8* nSpareBuffer );
+static __inline NAND_IO_ERROR 		NAND_IO_CorrectionMLC_IRQ( U16 nEccType, U8* nPageBuffer, U8* nSpareBuffer, U16 nDataSize );
 static __inline NAND_IO_ERROR 		NAND_IO_CorrectionMLC( U16 nEccType, U8* nPageBuffer, U8* nSpareBuffer, U16 nDataSize );
 static __inline NAND_IO_ERROR 		NAND_IO_EncodeBootBinary( NAND_IO_DEVINFO *nDevInfo, U8 *nPageBuffer, int nEccOnOff );
 
 static __inline NAND_IO_ERROR 		NAND_IO_ReadSpareData( NAND_IO_DEVINFO *nDevInfo, U8 *nSpareBuffer, int nPageEccOnOff );
-#if defined( NAND_IO_USE_DMA_ACCESS )
 static __inline NAND_IO_ERROR		NAND_IO_Read512DataDoubleBuf( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nReadPPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff, int nSpareOnOff );
-#endif
 static __inline NAND_IO_ERROR		NAND_IO_Read512Data( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nReadPPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff, int nSpareOnOff );
 static __inline NAND_IO_ERROR 		NAND_IO_ReadSpareDataMTD( NAND_IO_DEVINFO *nDevInfo, U8 *nSpareBuffer, int nPageEccOnOff );
 static __inline NAND_IO_ERROR		NAND_IO_ReadUserSizeData( NAND_IO_DEVINFO *nDevInfo, U16 nColumnAddr, U32 nReadSize, U8 *nReadBuffer );
 static __inline NAND_IO_ERROR 		NAND_IO_Read512DataMTD( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nReadPPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff, int nSpareOnOff );
 
-static __inline NAND_IO_ERROR 		NAND_IO_WriteSpareData( NAND_IO_DEVINFO *nDevInfo, U8 *nSpareBuffer, int nPageEccOnOff );
-#if defined( NAND_IO_USE_DMA_ACCESS )
 static __inline NAND_IO_ERROR		NAND_IO_Write512DataDoubleBuf( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nWritePPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
-#endif
 static __inline NAND_IO_ERROR		NAND_IO_Write512Data( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nWritePPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
 static __inline NAND_IO_ERROR		NAND_IO_WriteUserSizeData( NAND_IO_DEVINFO *nDevInfo, U16 nColumnAddr, U32 nWriteSize, U8 *nWriteBuffer );
 static __inline NAND_IO_ERROR 		NAND_IO_Write512DataMTD( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nWritePPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
 
+static __inline	void 				NAND_IO_CheckForExtendBlockAccess( NAND_IO_DEVINFO *nDevInfo, U32* nPageAddr );
+
 static __inline NAND_IO_ERROR		NAND_IO_GetShiftValueForFastMultiPly( U16 nValue, U16* rFactor );
 
 #if defined (NAND_LBA_INCLUDE)
+static __inline void 				NAND_IO_LBA_WaitBusy( U16 nChipNo );
+static __inline NAND_IO_ERROR NAND_IO_LBA_ReadData_VFP( NAND_IO_DEVINFO *nDevInfo, U16 nReadPPSize, U8 *nPageBuffer, U8 *nSpareBuffer );
 static __inline NAND_IO_ERROR 		NAND_IO_LBA_ReadData( NAND_IO_DEVINFO *nDevInfo, U16 nReadPPSize, U8 *nPageBuffer, U8 *nSpareBuffer );
 static __inline NAND_IO_ERROR 		NAND_IO_LBA_WriteData( NAND_IO_DEVINFO *nDevInfo, U16 nWritePPSize, U8 *nPageBuffer, U8 *nSpareBuffer );
 static __inline NAND_IO_ERROR 		NAND_IO_LBA_WriteDummyData( NAND_IO_DEVINFO *nDevInfo, U16 nWritePPSize );
 
+NAND_IO_ERROR 						NAND_IO_LBA_ConvertMPPA( NAND_IO_DEVINFO *nDevInfo, U8 nPartition, U32 nSectorAddr, U32 nSecSize, U32 *nConvertAddr, U32 *nConvertSize, U16 *rMediaOrder );
 NAND_IO_ERROR 						NAND_IO_LBA_VFPInitArea( NAND_IO_DEVINFO *nDevInfo );
 NAND_IO_ERROR						NAND_IO_LBA_MDPGetTotalSectorSize(NAND_IO_DEVINFO * nDevInfo, unsigned long int * rTotalSector);
 NAND_IO_ERROR						NAND_IO_LBA_VFPGetTotalSectorSize(NAND_IO_DEVINFO * nDevInfo, U32 * rTotalSector);
@@ -748,11 +783,12 @@ NAND_IO_ERROR						NAND_IO_LBA_VFPChangeSectorSize(NAND_IO_DEVINFO * nDevInfo, U
 NAND_IO_ERROR						NAND_IO_LBA_SetTransferProtocol(NAND_IO_DEVINFO * nDevInfo, U8 nProtocol1, U8 nProtocol2);
 NAND_IO_ERROR 						NAND_IO_LBA_SetBootModeChange( NAND_IO_DEVINFO *nDevInfo, U8 nBootMode );
 NAND_IO_ERROR 						NAND_IO_LBA_SetRebootCmdChange( NAND_IO_DEVINFO *nDevInfo, U8 nRebootCmd );
+NAND_IO_ERROR						NAND_IO_LBA_SetAreaPartition( NAND_IO_DEVINFO *nDevInfo, NAND_IO_FEATURE * sDevFeatureInfo );
 NAND_IO_ERROR 						NAND_IO_LBA_GetPersistentFunction( NAND_IO_DEVINFO *nDevInfo, U8 *rBootMode, U8 *rRebootCmd );
 NAND_IO_ERROR 						NAND_IO_LBA_GetTransferProtocol( NAND_IO_DEVINFO *nDevInfo, U8 *rProtocol1, U8 *rProtocol2 );
 NAND_IO_ERROR 						NAND_IO_LBA_GetBootMode( NAND_IO_DEVINFO *nDevInfo, U8 *rBootMode );
-NAND_IO_ERROR		 				NAND_IO_LBA_HighSpeedMode( NAND_IO_DEVINFO *nDevInfo, int nOnOff );
 NAND_IO_ERROR 						NAND_IO_LBA_ReadID( NAND_IO_DEVINFO *nDevInfo, NAND_IO_DEVID *nDeviceCode );
+NAND_IO_ERROR 						NAND_IO_LBA_ReadUID( NAND_IO_DEVINFO *nDevInfo );
 NAND_IO_ERROR 						NAND_IO_LBA_Reset( NAND_IO_DEVINFO *nDevInfo );
 #endif
 
@@ -966,6 +1002,32 @@ NAND_IO_ERROR NAND_IO_CallBackChangeWCtime( unsigned short int TotalMediaNum, NA
 			}
 		}
 		//**************************************************************
+		// Case on K9MDG08U5D Samsung NANDFLASH
+		//**************************************************************
+		else if ( nDevInfo->Feature.DeviceID.Code[0] == 0xEC &&
+			 	  nDevInfo->Feature.DeviceID.Code[1] == 0xDE &&
+			 	  nDevInfo->Feature.DeviceID.Code[2] == 0xD5 &&
+			 	  nDevInfo->Feature.DeviceID.Code[3] == 0x72 &&
+			 	  nDevInfo->Feature.DeviceID.Code[4] == 0x58 && 
+			 	  nDevInfo->Feature.DeviceID.Code[5] == 0x42)
+		{
+			if ( ( TotalMediaNum >= 2 ) || ( nDevInfo->Feature.MediaType & A_PARALLEL ) )
+			{
+				nDevInfo->Feature.WCtime = 45;
+
+				nDevInfo->Feature.WriteSTP 	= 0;
+				nDevInfo->Feature.WriteWP 	= 30;
+				nDevInfo->Feature.WriteHLD 	= 15;
+
+				nDevInfo->Feature.ReadSTP	= 0;
+				nDevInfo->Feature.ReadPW 	= 30;
+				nDevInfo->Feature.ReadHLD 	= 15;
+
+				NAND_IO_SetCycle( nDevInfo );
+			}
+		}
+		
+		//**************************************************************
 		// Case on TH58NVG5D4CTG20 Toshiba NANDFLASH
 		//**************************************************************
 		else if ( nDevInfo->Feature.DeviceID.Code[0] == 0x98 &&
@@ -1105,8 +1167,6 @@ NAND_IO_ERROR NAND_IO_SetCycle( NAND_IO_DEVINFO *nDevInfo )
 	ReadCycleTime.STP	= (U8)(nMCycleSTP + nSCycleSTP);
 	ReadCycleTime.HLD	= (U8)(nMCycleHLD + nSCycleHLD);
 	ReadCycleTime.PW	= (U8)(nMCyclePW + nSCyclePW + (( nDevInfo->Feature.MediaType & A_PARALLEL ) ? 1: 0 ));
-	if ( nMaxBusClkMHZ < 100 )
-		ReadCycleTime.PW += 1;
 
 	/* Write Cycle */
 	nDevSTP				= nDevInfo->Feature.WriteSTP * nTickRange;
@@ -1171,6 +1231,11 @@ NAND_IO_ERROR NAND_IO_SetCycle( NAND_IO_DEVINFO *nDevInfo )
 	if (CommCycleTime.HLD >= 16)
 		CommCycleTime.HLD	= 15;
 
+	if ( ReadCycleTime.PW < 2 )
+		ReadCycleTime.PW  = 2;
+	if ( ReadCycleTime.HLD < 2 )
+		ReadCycleTime.HLD  = 2;
+		
 	if ( gNAND_IO_DataBusType == NAND_IO_NFC_BUS )
 	{
 		WriteCycleTime.RegValue	= ( WriteCycleTime.STP << 8 ) + ( WriteCycleTime.PW << 4 ) + WriteCycleTime.HLD;
@@ -1568,10 +1633,12 @@ void NAND_IO_InitDMABuffer( void )
 	gpDMA_WorkBuffer1 	= (unsigned int*)pSYS_PARAM->DMA2.CH1_BUFFER;		// Physical Address	
 	#elif defined(_LINUX_)
 	#ifdef KERNEL_DRIVER
-	gpDMA_PhyBuffer0 	= dma_t.dma_addr;
+	gpDMA_PhyBuffer0 	= (unsigned int*)dma_t.dma_addr;
 	gpDMA_WorkBuffer0	= (unsigned int*)dma_t.v_addr;
-	gpDMA_PhyBuffer1 	= (unsigned char*)gpDMA_PhyBuffer0 + 512;
-	gpDMA_WorkBuffer1	= (unsigned char*)gpDMA_WorkBuffer0 + 512;
+	gpDMA_PhyBuffer1 	= (unsigned int*)((unsigned char*)gpDMA_PhyBuffer0 + 512);
+	gpDMA_WorkBuffer1	= (unsigned int*)((unsigned char*)gpDMA_WorkBuffer0 + 512);
+	gNAND_IO_ShareEccBuffer_w	= (unsigned char*)gpDMA_PhyBuffer1 + 512;
+	gNAND_IO_ShareEccBuffer		= (unsigned char*)gpDMA_WorkBuffer1 + 512;
 	#else
 	gpDMA_PhyBuffer0 	= (unsigned int*)DMA_ADDR;
 	gpDMA_WorkBuffer0	= (unsigned int*)DMA_ADDR;
@@ -1584,6 +1651,11 @@ void NAND_IO_InitDMABuffer( void )
 	gpDMA_PhyBuffer1 	= (unsigned char*)gpDMA_PhyBuffer0 + 512;
 	gpDMA_WorkBuffer1	= (unsigned char*)gpDMA_WorkBuffer0 + 512;
 	#endif
+
+//	ND_TRACE("\nDMA_PhyBufferAddr0:0x%X", gpDMA_PhyBuffer0);
+//	ND_TRACE("\nDMA_WorkBufferAddr0:0x%X", gpDMA_WorkBuffer0);
+//	ND_TRACE("\nDMA_PhyBufferAddr1:0x%X", gpDMA_PhyBuffer1);
+//	ND_TRACE("\nDMA_WorkBufferAdd1r:0x%X", gpDMA_WorkBuffer1);
 }
 
 /******************************************************************************
@@ -1601,7 +1673,6 @@ void NAND_IO_Init( void )
 {
 	unsigned int		i;
 	PEDI				pEDI;
-	PPIC 				pPIC;
 	NAND_IO_DEVINFO		sDevInfo;
 	NAND_IO_ERROR		res;
 	
@@ -1665,12 +1736,12 @@ void NAND_IO_Init( void )
 			pEDI->EDI_RDYCFG 	= 0x00000001;
 			//pEDI->EDI_CSNCFG0	= 0x00403265;
 			BITCSET(pEDI->EDI_CSNCFG0, 0xFFFF, 0x8765 );
-			
+
 			pGPIO->GPBFN0           = 0x11112222;   //NANDXD[7:4]
 			pGPIO->GPBFN1           = 0x00221111;   //NANDXD[3:0]
 			pGPIO->GPBFN2           = 0x10111010;   //NANDXD[11:8],[7:4]
 			pGPIO->GPBFN3           = 0x00010111;   //NANDXD[15:12],[3:0]
-
+			
 			// Write Protect Pin: Output Mode
 			BITSET( pGPIO->GPBEN, NAND_IO_NFC_nWPBit );
 
@@ -1683,17 +1754,32 @@ void NAND_IO_Init( void )
 			BITCLR(pGPIO->GPBEN, Hw31);
 			#endif
 	    
+			#ifdef __USE_NAND_ISR__
+			NAND_IO_IRQ_ReadyBusyClear();
+			#endif
+			
 		    gNAND_IO_DataBusType	= NAND_IO_NFC_BUS;
 
 		    /* Make Reset */
 		    pNFC->NFC_RST = 0;
 
 		    /* Set Default NFC Configuration */
+			#ifdef __USE_NAND_ISR__
+		    pNFC->NFC_CTRL	= HwNFC_CTRL_PROGIEN_EN |
+                              HwNFC_CTRL_READIEN_EN |
+                              HwNFC_CTRL_DEN_EN		|
+					          HwNFC_CTRL_CFG_NOACT	|
+					          HwNFC_CTRL_BSIZE_1	|
+						      (4 << 4)				|		// pw = 5
+					          (1 << 0);						// hold = 1
+
+			#else
 		    pNFC->NFC_CTRL	= HwNFC_CTRL_DEN_EN		|
 					          HwNFC_CTRL_CFG_NOACT	|
 					          HwNFC_CTRL_BSIZE_1	|
 						      (4 << 4)				|		// pw = 5
 					          (1 << 0);						// hold = 1
+			#endif
 
 			/* GPIO B Arbitration ENABLE */
 			pNFC->NFC_CTRL1 |= Hw31;
@@ -1701,7 +1787,7 @@ void NAND_IO_Init( void )
 
 		    /* Enable Interrupt */
 			pNFC->NFC_IREQ = 0x77;				// Clear Interrupt
-			pPIC->CLR1		= HwINT1_NFC;
+			BITSET( pPIC->CLR1,HwINT1_NFC );
 		    BITSET( pPIC->SEL1, HwINT1_NFC);				// Set NFC as IRQ interrupt
 		    BITSET( pPIC->MODE1, HwINT1_NFC );	// Level type for NFC interrupt, IO_INT_HwNFC );	// Level type for NFC interrupt
 
@@ -1710,13 +1796,18 @@ void NAND_IO_Init( void )
 		    /* Searching NANDFLASH */
 		    res = NAND_IO_GetDeviceInfo( 0, &sDevInfo );
 
-			#ifdef SPEED_CHECK
-			{
-				pGPIO->GPFFN0 = 0xFFFFFFFF;
-				pGPIO->GPFEN  = 0xFFFFFFFF;
-				//pGPIO->GPFDAT = 0xFFFFFFFF;
-				pGPIO->GPFDAT = HwZERO;
-			}
+			#ifdef NAND_GPIO_DEBUG
+			BITCSET(pGPIO->GPFFN2, 0x0FF000FF, 0x00000000);
+			BITSET(pGPIO->GPFEN, Hw16);
+			BITSET(pGPIO->GPFEN, Hw17);
+			BITSET(pGPIO->GPFEN, Hw21);
+			BITSET(pGPIO->GPFEN, Hw22);
+
+			// Clear
+			BITCLR(pGPIO->GPFDAT, Hw16);
+			BITCLR(pGPIO->GPFDAT, Hw17);
+			BITCLR(pGPIO->GPFDAT, Hw21);
+			BITCLR(pGPIO->GPFDAT, Hw22);
 			#endif
 
 		    if ( res == SUCCESS )
@@ -1923,7 +2014,6 @@ void NAND_IO_ReadID( U16 nChipNo, NAND_IO_DEVID *nDeviceCode, int nMode )
 
 	/* Post Process */
 	NAND_IO_PostProcess();
-	
 }
 
 /******************************************************************************
@@ -1970,6 +2060,8 @@ NAND_IO_ERROR NAND_IO_ReadSpare( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U8 *n
 
 	NAND_IO_EnableWriteProtect();
 
+	NAND_IO_CheckForExtendBlockAccess( nDevInfo, &nPageAddr );
+	
 	//=============================================
 	// Read Data
 	//=============================================	
@@ -2047,6 +2139,8 @@ NAND_IO_ERROR NAND_IO_ReadPage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
 	NAND_IO_BusControl(nDevInfo);
 	NAND_IO_SetCommCycleTime();
 	
+	NAND_IO_CheckForExtendBlockAccess( nDevInfo, &nPageAddr );
+
 	//=============================================
 	// Read Status
 	//=============================================
@@ -2059,11 +2153,6 @@ NAND_IO_ERROR NAND_IO_ReadPage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
 
 	NAND_IO_EnableWriteProtect();
 
-	#ifdef READ_SPEED_CHECK
-	BITCLR(pGPIO->GPBDAT, Hw13);
-	BITCLR(pGPIO->GPBDAT, Hw15);
-	#endif
-
 	//=============================================
 	// Read Data
 	//=============================================	
@@ -2082,17 +2171,9 @@ NAND_IO_ERROR NAND_IO_ReadPage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
 	if ( nDevInfo->Feature.MediaType & A_BIG )
 		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
 
-	#ifdef READ_SPEED_CHECK
-	NAND_IO_GPIO_Toggle(Hw15);
-	#endif
-	
 	/* Wait until it is ready */
 	NAND_IO_WaitBusy( nDevInfo->ChipNo );
 
-	#ifdef READ_SPEED_CHECK
-	NAND_IO_GPIO_Toggle(Hw15);
-	#endif
-	
 	/* Change Cycle */
 	NAND_IO_SetReadCycleTime();
 
@@ -2145,11 +2226,6 @@ NAND_IO_ERROR NAND_IO_ReadPage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
 		NAND_IO_SetReadCycleTime();
 	}
 
-	#ifdef READ_SPEED_CHECK
-	BITCLR(pGPIO->GPBDAT, Hw15);
-	NAND_IO_GPIO_Toggle(Hw15);
-	#endif
-
 	#if defined(NAND_IO_USE_DMA_DOUBLE_BUF)
 	res = NAND_IO_Read512DataDoubleBuf( nDevInfo,
 									    nStartPPage,
@@ -2167,11 +2243,6 @@ NAND_IO_ERROR NAND_IO_ReadPage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
 							   nEccOnOff,
 							   TNFTL_READ_SPARE_ON );		
 	#endif
-	
-	#ifdef READ_SPEED_CHECK
-	NAND_IO_GPIO_Toggle(Hw15);
-	#endif
-
 	/* Change Cycle */
 	NAND_IO_SetCommCycleTime();
 							
@@ -2182,14 +2253,13 @@ ErrorReadPage:
 	//=============================================	
 	NAND_IO_DisableChipSelect();
 	NAND_IO_PostProcess();
-	
+
 	if ( res != SUCCESS )
 		return res;
 
    	return (NAND_IO_ERROR)SUCCESS;
 }
 
-
 /******************************************************************************
 *
 *	NAND_IO_ERROR	NAND_IO_ReadPhyPage
@@ -2228,6 +2298,8 @@ NAND_IO_ERROR NAND_IO_ReadPhyPage(	NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
 	NAND_IO_BusControl(nDevInfo);
 	NAND_IO_SetCommCycleTime();
 	
+	NAND_IO_CheckForExtendBlockAccess( nDevInfo, &nPageAddr );
+	
 	//=============================================
 	// Read Status
 	//=============================================
@@ -2240,11 +2312,6 @@ NAND_IO_ERROR NAND_IO_ReadPhyPage(	NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
 
 	NAND_IO_EnableWriteProtect();
 
-	#ifdef READ_SPEED_CHECK
-	BITCLR(pGPIO->GPBDAT, Hw13);
-	BITCLR(pGPIO->GPBDAT, Hw15);
-	#endif
-
 	//=============================================
 	// Read Data
 	//=============================================	
@@ -2263,17 +2330,9 @@ NAND_IO_ERROR NAND_IO_ReadPhyPage(	NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
 	if ( nDevInfo->Feature.MediaType & A_BIG )
 		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
 
-	#ifdef READ_SPEED_CHECK
-	NAND_IO_GPIO_Toggle(Hw15);
-	#endif
-	
 	/* Wait until it is ready */
 	NAND_IO_WaitBusy( nDevInfo->ChipNo );
 
-	#ifdef READ_SPEED_CHECK
-	NAND_IO_GPIO_Toggle(Hw15);
-	#endif
-	
 	/* Change Cycle */
 	NAND_IO_SetReadCycleTime();
 
@@ -2327,11 +2386,6 @@ NAND_IO_ERROR NAND_IO_ReadPhyPage(	NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
 		NAND_IO_SetReadCycleTime();
 	}
 	
-	#ifdef READ_SPEED_CHECK
-	BITCLR(pGPIO->GPBDAT, Hw15);
-	NAND_IO_GPIO_Toggle(Hw15);
-	#endif
-
 	#if defined(NAND_IO_USE_DMA_DOUBLE_BUF)
 	res = NAND_IO_Read512DataDoubleBuf( nDevInfo,
 									    nStartPPage,
@@ -2350,10 +2404,6 @@ NAND_IO_ERROR NAND_IO_ReadPhyPage(	NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
 							   TNFTL_READ_SPARE_ON );		
 	#endif
 	
-	#ifdef READ_SPEED_CHECK
-	NAND_IO_GPIO_Toggle(Hw15);
-	#endif
-
 	/* Change Cycle */
 	NAND_IO_SetCommCycleTime();
 							
@@ -2371,7 +2421,6 @@ ErrorReadPage:
    	return (NAND_IO_ERROR)SUCCESS;
 }
 
-
 /******************************************************************************
 *
 *	NAND_IO_ERROR	NAND_IO_ReadPageMTD
@@ -2410,6 +2459,8 @@ NAND_IO_ERROR NAND_IO_ReadPageMTD( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
 	NAND_IO_BusControl(nDevInfo);
 	NAND_IO_SetCommCycleTime();
 	
+	NAND_IO_CheckForExtendBlockAccess( nDevInfo, &nPageAddr );
+	
 	//=============================================
 	// Read Status
 	//=============================================
@@ -2557,6 +2608,8 @@ NAND_IO_ERROR NAND_IO_ReadTwoPlanePage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr
 	NAND_IO_BusControl(nDevInfo);
 	NAND_IO_SetCommCycleTime();
 
+	NAND_IO_CheckForExtendBlockAccess( nDevInfo, &nPageAddr );
+	
 	//=============================================
 	// Read Status
 	//=============================================
@@ -2696,6 +2749,8 @@ NAND_IO_ERROR NAND_IO_ReadTwoPlaneLastPage( NAND_IO_DEVINFO *nDevInfo, U32 nPage
 
 	NAND_IO_EnableWriteProtect();
 
+	NAND_IO_CheckForExtendBlockAccess( nDevInfo, &nPageAddr );
+	
 	//=============================================
 	// Read Data
 	//=============================================	
@@ -2788,6 +2843,8 @@ NAND_IO_ERROR NAND_IO_ReadUserSizePage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr
 	NAND_IO_BusControl(nDevInfo);
 	NAND_IO_SetCommCycleTime();
 
+	NAND_IO_CheckForExtendBlockAccess( nDevInfo, &nPageAddr );
+	
 	//=============================================
 	// Read Status
 	//=============================================
@@ -2881,6 +2938,8 @@ NAND_IO_ERROR NAND_IO_WriteSpare( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
 	NAND_IO_BusControl(nDevInfo);
 	NAND_IO_SetCommCycleTime();
 
+	NAND_IO_CheckForExtendBlockAccess( nDevInfo, &nPageAddr );
+	
 	//=============================================
 	// Read Status
 	//=============================================
@@ -3003,6 +3062,8 @@ NAND_IO_ERROR NAND_IO_WritePage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
 	NAND_IO_BusControl(nDevInfo);
 	NAND_IO_SetCommCycleTime();
 
+	NAND_IO_CheckForExtendBlockAccess( nDevInfo, &nPageAddr );
+	
 	//=============================================
 	// Read Status
 	//=============================================
@@ -3142,6 +3203,8 @@ NAND_IO_ERROR NAND_IO_WritePageMTD( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
 	NAND_IO_BusControl(nDevInfo);
 	NAND_IO_SetCommCycleTime();
 
+	NAND_IO_CheckForExtendBlockAccess( nDevInfo, &nPageAddr );
+	
 	//=============================================
 	// Read Status
 	//=============================================
@@ -3275,6 +3338,8 @@ NAND_IO_ERROR NAND_IO_WriteCachePage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
 	NAND_IO_BusControl(nDevInfo);
 	NAND_IO_SetCommCycleTime();
 	
+	NAND_IO_CheckForExtendBlockAccess( nDevInfo, &nPageAddr );
+	
 	//=============================================
 	// Read Status
 	//=============================================
@@ -3401,6 +3466,8 @@ NAND_IO_ERROR NAND_IO_WriteTwoPlanePage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAdd
 	NAND_IO_BusControl(nDevInfo);
 	NAND_IO_SetCommCycleTime();
 
+	NAND_IO_CheckForExtendBlockAccess( nDevInfo, &nPageAddr );
+	
 	//=============================================
 	// Read Status
 	//=============================================
@@ -3531,6 +3598,8 @@ NAND_IO_ERROR NAND_IO_WriteTwoPlaneLastPage( NAND_IO_DEVINFO *nDevInfo, U32 nPag
 	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
 	NAND_IO_DisableWriteProtect();
 
+	NAND_IO_CheckForExtendBlockAccess( nDevInfo, &nPageAddr );
+	
 	//=============================================
 	// Write Data
 	//=============================================
@@ -3543,7 +3612,7 @@ NAND_IO_ERROR NAND_IO_WriteTwoPlaneLastPage( NAND_IO_DEVINFO *nDevInfo, U32 nPag
 	/* Command Page Program #1 [ 0x80 ] */
 	if ( ( nDevInfo->Feature.DeviceID.Code[0] == SAMSUNG_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == HYNIX_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == ST_NAND_MAKER_ID ) )
 		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8181;
-	else if ( ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID ) )
+	else if ( ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == INTEL_NAND_MAKER_ID ))
 		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8080;
 	
 	/* Write Row and Column Address */
@@ -3576,17 +3645,16 @@ NAND_IO_ERROR NAND_IO_WriteTwoPlaneLastPage( NAND_IO_DEVINFO *nDevInfo, U32 nPag
 		goto ErrorWritePage;
 	
 	/* Command Page Program #2 [ 0x10 ] */
-	if ( ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID )	 || ( nDevInfo->Feature.DeviceID.Code[0] == ST_NAND_MAKER_ID ) )
-		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
-	else if ( ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID ) )	
+	if ( ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID ) )	
 	{
 		if ( ( LastPage == MULTI_PLANE_LAST_PAGE ) || ( nDevInfo->ExtInterleaveUsable == TRUE ) )
 			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
 		else if ( LastPage == MULTI_PLANE_MID_PAGE )
 			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1515;
 	}
-	else if ( ( nDevInfo->Feature.DeviceID.Code[0] == SAMSUNG_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == HYNIX_NAND_MAKER_ID ) )	
+	else	
 	{
+		// SAMSUNG, HYNIX, MICRON, INTEL, ST Maker TwoPlane Write Function
 		if ( nDevInfo->Feature.MediaType & S_MCP )
 		{
 			if ( LastPage == MULTI_PLANE_LAST_PAGE )
@@ -3676,6 +3744,8 @@ NAND_IO_ERROR NAND_IO_WriteUserSizePage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAdd
 	NAND_IO_BusControl(nDevInfo);
 	NAND_IO_SetCommCycleTime();
 
+	NAND_IO_CheckForExtendBlockAccess( nDevInfo, &nPageAddr );
+	
 	//=============================================
 	// Read Status
 	//=============================================
@@ -4142,6 +4212,8 @@ NAND_IO_ERROR NAND_IO_EraseBlock( NAND_IO_DEVINFO *nDevInfo, U32 nBlockPageAddr,
 	NAND_IO_BusControl(nDevInfo);
 	NAND_IO_SetCommCycleTime();
 
+	NAND_IO_CheckForExtendBlockAccess( nDevInfo, &nBlockPageAddr );
+	
 	//=============================================
 	// Read Status
 	//=============================================
@@ -4220,8 +4292,8 @@ ErrorEraseBlock:
 *******************************************************************************/
 NAND_IO_ERROR NAND_IO_EraseBlockForTwoPlane( NAND_IO_DEVINFO *nDevInfo, U32 nBlockPageAddr, int nFormatMode )
 {
-	unsigned int		nReBlockPageAddr;
 	unsigned long int	dwTempBlockPageAddr, dwAddSecondPageAddr;
+	unsigned long int   nReBlockPageAddr = 0;
 	NAND_IO_ERROR		res;
 	
 	//=============================================	
@@ -4242,6 +4314,8 @@ NAND_IO_ERROR NAND_IO_EraseBlockForTwoPlane( NAND_IO_DEVINFO *nDevInfo, U32 nBlo
 	NAND_IO_BusControl(nDevInfo);
 	NAND_IO_SetCommCycleTime();
 
+    NAND_IO_CheckForExtendBlockAccess( nDevInfo, &nBlockPageAddr );
+
 	//=============================================
 	// Read Status
 	//=============================================
@@ -4273,10 +4347,10 @@ NAND_IO_ERROR NAND_IO_EraseBlockForTwoPlane( NAND_IO_DEVINFO *nDevInfo, U32 nBlo
 			//	SAMSUNG MLC(4BIT) ROW ADDR: FIXED LOW
 			//	HYNIX MLC(4BIT, 12BIT) ROW ADDR: FIXED LOW
 			//---------------------------------------------
- 	    if ( nBlockPageAddr & dwTempBlockPageAddr )
- 		    nReBlockPageAddr = dwTempBlockPageAddr;
-	    else
-		    nReBlockPageAddr = 0;
+	 	    if ( nBlockPageAddr & dwTempBlockPageAddr )
+	 		    nReBlockPageAddr = dwTempBlockPageAddr;
+		    else
+			    nReBlockPageAddr = 0;
 		}
 		else if ( ( nDevInfo->Feature.MediaType & A_MLC_8BIT ) || ( nDevInfo->Feature.MediaType & A_MLC_16BIT ) )
 		{
@@ -4293,7 +4367,7 @@ NAND_IO_ERROR NAND_IO_EraseBlockForTwoPlane( NAND_IO_DEVINFO *nDevInfo, U32 nBlo
 	    nReBlockPageAddr = nBlockPageAddr;
 		dwAddSecondPageAddr = ( nDevInfo->DistrictNum << nDevInfo->ShiftPpB );
     }
-	else if ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID ) 
+	else if ( ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == INTEL_NAND_MAKER_ID ) )
 	{
 		nReBlockPageAddr = nBlockPageAddr;
 		dwAddSecondPageAddr = nDevInfo->Feature.PpB;
@@ -4434,6 +4508,8 @@ NAND_IO_ERROR NAND_IO_GetFactoryBadMarkOfPBlock( NAND_IO_DEVINFO *nDevInfo, U32
 	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
 		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
 
+	NAND_IO_CheckForExtendBlockAccess( nDevInfo, &nBlockPageAddr );
+	
 	//=============================================	
 	// Get Factory Bad Mark Page Default 
 	//=============================================	
@@ -4454,7 +4530,7 @@ NAND_IO_ERROR NAND_IO_GetFactoryBadMarkOfPBlock( NAND_IO_DEVINFO *nDevInfo, U32
 	//=============================================
 	// Exception: Micron  
 	//=============================================
-	if ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID )
+	if ( ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == INTEL_NAND_MAKER_ID ) )
 	{
 		if ( ( nDevInfo->Feature.MediaType & A_MLC_8BIT ) || ( nDevInfo->Feature.MediaType & A_MLC_12BIT ) )
 		{	
@@ -4635,6 +4711,40 @@ ErrorGetUID:
 
 }
 
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_CheckForExtendBlockAccess( void );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			None
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline	void NAND_IO_CheckForExtendBlockAccess( NAND_IO_DEVINFO *nDevInfo, U32* nPageAddr )
+{
+	unsigned long int		dwPhyBlkNo;
+	unsigned long int		dwPhyPageNo;
+	unsigned long int		dwPHYPageAddr;
+	
+	if ( nDevInfo->Feature.MediaType & S_EB )
+	{
+		dwPHYPageAddr = *nPageAddr;
+		dwPhyBlkNo	  = dwPHYPageAddr >> nDevInfo->ShiftPpB;
+		dwPhyPageNo   = dwPHYPageAddr - ( dwPhyBlkNo << nDevInfo->ShiftPpB );
+		
+		if ( dwPhyBlkNo >= ( nDevInfo->Feature.PBpV >> 1 ) )
+		{
+			dwPhyBlkNo   += ( nDevInfo->Feature.PBpV >> 1 );
+			dwPHYPageAddr = ( dwPhyBlkNo << nDevInfo->ShiftPpB ) + dwPhyPageNo;
+
+			*nPageAddr = dwPHYPageAddr;
+		}
+	}
+	
+}
+
 //*****************************************************************************
 //*
 //*
@@ -4800,7 +4910,7 @@ static __inline void NAND_IO_SetBasicCycleTime( void )
 *  OUTPUT:	void - Return Type
 *  REMARK  :	
 **************************************************************************/
-static __inline void NAND_IO_SetCommCycleTime(void)
+void NAND_IO_SetCommCycleTime(void)
 {
 	BITCSET( pNFC->NFC_CTRL, 0xFFF, CommCycleTime.RegValue );
 }
@@ -4832,7 +4942,7 @@ static __inline void NAND_IO_SetWriteCycleTime(void)
 *  OUTPUT:	void - Return Type
 *  REMARK  :	
 **************************************************************************/
-static __inline void NAND_IO_SetReadCycleTime(void)
+void NAND_IO_SetReadCycleTime(void)
 {
 	BITCSET( pNFC->NFC_CTRL, 0xFFF, ReadCycleTime.RegValue );
 }
@@ -5043,15 +5153,7 @@ static __inline void NAND_IO_WaitBusy( U16 nChipNo )
    	// 1 :                             high
    	// Delay : 200nS
 
-	#ifdef READ_SPEED_CHECK   	
-	NAND_IO_GPIO_Toggle(Hw13);
-	#endif
-	
-   	NAND_IO_Delay();
-
-	#ifdef READ_SPEED_CHECK
-	NAND_IO_GPIO_Toggle(Hw13);
-	#endif
+	NAND_IO_Delay();
 	
 	while (NAND_IO_CheckReadyAndBusy( nChipNo ));
 }
@@ -5323,6 +5425,24 @@ NAND_IO_ERROR	NAND_IO_WaitBusyCheckForWriteEnd( NAND_IO_DEVINFO *nDevInfo )
 
 /**************************************************************************
 *  FUNCTION NAME : 
+*  
+*      void NAND_IO_SetInterLeavePageAddr(U32 nPageAddr );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			nPageAddr	= 
+*  
+*  OUTPUT:	void - Return Type
+*  
+**************************************************************************/
+void NAND_IO_SetInterLeavePageAddr(U32 nPageAddr )
+{
+	gInterLeavePageAddr = nPageAddr;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
 *      static __inline void NAND_IO_SetInterleaveStatus( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr );
 *  
 *  DESCRIPTION : 
@@ -5333,7 +5453,7 @@ NAND_IO_ERROR	NAND_IO_WaitBusyCheckForWriteEnd( NAND_IO_DEVINFO *nDevInfo )
 *  OUTPUT:	void - Return Type
 *  REMARK  :	
 **************************************************************************/
-static __inline void NAND_IO_SetInterleaveStatus( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr )
+void NAND_IO_SetInterleaveStatus( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr )
 {
 
 	if ( nDevInfo->Feature.MediaType & S_IL )
@@ -5491,6 +5611,1061 @@ static __inline void NAND_IO_Delay( void )
 
 /**************************************************************************
 *  FUNCTION NAME : 
+*  
+*      NAND_IO_ERROR NAND_IO_IRQ_ReadPagePreProcess( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U16 nStartPPage, U32 *rEccBuffer, U16 nChipNo );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			nChipNo	= 
+*			nDevInfo	= 
+*			nPageAddr	= 
+*			nStartPPage	= 
+*			rEccBuffer	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+**************************************************************************/
+NAND_IO_ERROR NAND_IO_IRQ_ReadPagePreProcess( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U16 nStartPPage, U32 *rEccBuffer, U16 nChipNo )
+{
+	unsigned int		i;
+	unsigned int		RowAddr, ColumnAddr;
+	unsigned short int	nSpareTotalSize;
+	unsigned char		*pSpareB = 0;
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ) )
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+	
+	//=============================================
+	// PreProcess
+	// Set Setup and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP LOW
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_BusControl(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+
+	NAND_IO_CheckForExtendBlockAccess( nDevInfo, &nPageAddr );
+	
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+		NAND_IO_ClearInterleaveStatus( nDevInfo );
+	else
+		NAND_IO_EnableChipSelect( nChipNo );
+
+	NAND_IO_EnableWriteProtect();
+
+	//=============================================
+	// Read Data
+	//=============================================	
+	// ECC Read
+	if ( nDevInfo->Feature.MediaType & A_MLC_16BIT )
+		nSpareTotalSize = 20;
+	else
+		nSpareTotalSize = 24;
+	
+	/* Generate Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForRead( nPageAddr, nDevInfo->Feature.PageSize + nSpareTotalSize, &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		return res;
+
+	/* Write Row and Column Address	*/
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+	
+	/* Command READ2 [ 0x30 ] for Advance NandFlash */
+	if ( nDevInfo->Feature.MediaType & A_BIG )
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+
+
+	#ifdef NAND_GPIO_DEBUG
+	BITSET(pGPIO->GPFDAT, Hw21);
+	#endif	
+	
+	/* Change Cycle */
+	NAND_IO_SetReadCycleTime();
+
+	NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+	
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================	
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	// Set SpareBuffer Pointer =>> ECCBuffer
+	if ( ( nDevInfo->Feature.MediaType  & A_BIG ) || (( nDevInfo->Feature.MediaType  & A_SMALL ) && ( nDevInfo->Feature.MediaType  & A_PARALLEL )))
+	{
+		pSpareB		= (unsigned char*)&gNAND_IO_ShareEccBuffer[0];
+
+		//=========================================================================
+		// Empty Page ECCBuffer Pointer Increment
+		//=========================================================================
+		for ( i = 0; i < nStartPPage; ++i )
+			pSpareB += nDevInfo->EccDataSize;
+
+		*rEccBuffer = (unsigned int)pSpareB;
+	}
+
+	return SUCCESS;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      void NAND_IO_IRQ_ReadPagePostProcess( void );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*  
+*  OUTPUT:	void - Return Type
+*  
+**************************************************************************/
+void NAND_IO_IRQ_ReadPagePostProcess( void )
+{
+	/* Change Cycle */
+	NAND_IO_SetCommCycleTime();
+							
+	//=============================================
+	// Disable Chip Select
+	// PostProcess
+	//=============================================	
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();	
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      void 	NAND_IO_IRQ_Read512DataPreProcess( NAND_IO_DEVINFO *nDevInfo );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			nDevInfo	= 
+*  
+*  OUTPUT:	void - Return Type
+*  
+**************************************************************************/
+void 	NAND_IO_IRQ_Read512DataPreProcess( NAND_IO_DEVINFO *nDevInfo )
+{ 
+	//==========================================================
+	//
+	// ECC Decode Setup
+	//
+	//==========================================================
+	pECC->ECC_CLEAR	= 0x00000000;					/* Clear ECC Block		*/
+	pECC->ECC_MASK	= 0x00000000;				/* Address mask for ECC area */
+
+	if ( nDevInfo->EccType== SLC_ECC_TYPE )
+		pECC->ECC_CTRL	|= 	HwECC_CTRL_EN_SLCDE;
+	else if (nDevInfo->EccType == MLC_ECC_4BIT_TYPE )
+	{
+		pECC->ECC_CTRL	|= HwECC_CTRL_IEN_MECC4_EN;				
+		pECC->ECC_CTRL	|= 	HwECC_CTRL_EN_MCL4DE;
+	}
+	else if (nDevInfo->EccType == MLC_ECC_8BIT_TYPE )
+	{
+		pECC->ECC_CTRL	|= HwECC_CTRL_IEN_MECC8_EN;
+		pECC->ECC_CTRL	|= 	HwECC_CTRL_EN_MCL8DE;
+	}
+	else if (nDevInfo->EccType == MLC_ECC_12BIT_TYPE )
+	{
+		pECC->ECC_CTRL	|= HwECC_CTRL_IEN_MECC12_EN;
+		pECC->ECC_CTRL	|= 	HwECC_CTRL_EN_MCL12DE;
+	}
+	else if (nDevInfo->EccType == MLC_ECC_16BIT_TYPE )
+	{
+		pECC->ECC_CTRL	|= HwECC_CTRL_IEN_MECC16_EN;
+		pECC->ECC_CTRL	|= 	HwECC_CTRL_EN_MCL16DE;
+	}
+
+	pECC->ECC_CTRL		|= ( 512 << ECC_SHIFT_DATASIZE );
+	pECC->ECC_CLEAR	 = 0x00000000;			/* Clear ECC Block		*/
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      NAND_IO_ERROR 	NAND_IO_IRQ_Read512DataPostProcess( NAND_IO_DEVINFO *nDevInfo, U8* nPageBuffer, U8* nSpareBuffer );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			nDevInfo	= 
+*			nPageBuffer	= 
+*			nSpareBuffer	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+**************************************************************************/
+NAND_IO_ERROR 	NAND_IO_IRQ_Read512DataPostProcess( NAND_IO_DEVINFO *nDevInfo, U8* nPageBuffer, U8* nSpareBuffer )
+{ 
+	NAND_IO_ERROR	res = (NAND_IO_ERROR)SUCCESS;
+
+	/* Check and Correct ECC code */
+	if (( nDevInfo->EccType == SLC_ECC_TYPE ) && ( nDevInfo->Feature.MediaType & A_SMALL ))
+	{
+		//===================================
+		// SLC ECC Correction
+		//===================================				
+		nSpareBuffer += NAND_IO_SPARE_SIZE_SMALL;
+		res |= NAND_IO_CorrectionSLC( nPageBuffer, nSpareBuffer );
+	}
+	else
+	{
+		if ( nDevInfo->EccType == SLC_ECC_TYPE )
+			res |= NAND_IO_CorrectionSLC( nPageBuffer, nSpareBuffer );
+		else
+			res |= NAND_IO_CorrectionMLC( nDevInfo->EccType, nPageBuffer, nSpareBuffer, 512 );
+	}
+
+	return res;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      NAND_IO_ERROR NAND_IO_IRQ_WritePagePreProcess( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
+*      											   U16 nStartPPage, U8 *nSpareBuffer, U32 *rEccBuffer, U16 nChipNo, U8 nWriteMode );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			nChipNo	= 
+*			nDevInfo	= 
+*			nPageAddr	= 
+*			nSpareBuffer	= 
+*			nStartPPage	= 
+*			nWriteMode	= 
+*			rEccBuffer	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+**************************************************************************/
+NAND_IO_ERROR NAND_IO_IRQ_WritePagePreProcess( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
+											   U16 nStartPPage, U8 *nSpareBuffer, U32 *rEccBuffer, U16 nChipNo, U8 nWriteMode )
+{
+	unsigned int		j, i;
+	unsigned int		RowAddr, ColumnAddr;
+	unsigned long int	dwTempPHYPageAddr;
+	unsigned char 		*pSpareB, *pSpare;
+	NAND_IO_ERROR		res;
+	NAND_IO_ECC_INFO	*pECC_Info;
+
+	//=============================================
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+
+	//=============================================
+	// PreProcess
+	// Set Setup Time and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP HIGH
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_BusControl(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+
+	NAND_IO_CheckForExtendBlockAccess( nDevInfo, &nPageAddr );
+	
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) && 
+	   ( ( nWriteMode == MULTI_PLANE_START_PAGE ) || (nWriteMode == MULTI_PLANE_NORMAL_PAGE ) || (nWriteMode == MULTI_PLANE_STUFF_PAGE)) )
+	{
+		res = NAND_IO_WaitBusyForInterleave( nDevInfo, nPageAddr );
+		if ( res != SUCCESS )
+  		 	return (NAND_IO_ERROR)res;
+	}
+	else
+	{
+		NAND_IO_EnableChipSelect( nChipNo );
+		NAND_IO_DisableWriteProtect();
+	}
+
+	//=============================================
+	// Write Data
+	//=============================================
+	if ( nWriteMode == MULTI_PLANE_START_PAGE )
+	{
+		if ( ( nDevInfo->Feature.DeviceID.Code[0] == SAMSUNG_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == HYNIX_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == ST_NAND_MAKER_ID ) )
+		{
+			if ( ( nDevInfo->Feature.MediaType & A_MLC ) || ( nDevInfo->Feature.MediaType & A_SLC ) || ( nDevInfo->Feature.MediaType & A_MLC_12BIT ) )
+			{
+			    dwTempPHYPageAddr = ( ( nDevInfo->Feature.PBpV << nDevInfo->ShiftPpB ) >> 1 );
+	    
+		 	    if ( nPageAddr & dwTempPHYPageAddr )
+		 		    nPageAddr = dwTempPHYPageAddr;
+			    else
+				    nPageAddr = 0;
+		    }
+		}		
+	}
+
+	if ( (nWriteMode == MULTI_PLANE_NORMAL_PAGE ) || (nWriteMode == MULTI_PLANE_STUFF_PAGE) )
+	{
+		/* Generate Row and Column Address */
+		res = NAND_IO_GenerateRowColAddrForWrite( nPageAddr, ( nStartPPage << 9 ), &RowAddr, &ColumnAddr, nDevInfo );				
+	}
+	else
+	{
+		/* Generate Row and Column Address */
+		res = NAND_IO_GenerateRowColAddrForCBandCP( nPageAddr, ( nStartPPage << 9 ), &RowAddr, &ColumnAddr, nDevInfo );		
+	}		
+	if ( res != SUCCESS )
+	 	return (NAND_IO_ERROR)res;
+
+	if ( ( nWriteMode == MULTI_PLANE_MID_PAGE ) || ( nWriteMode == MULTI_PLANE_LAST_PAGE ))
+	{
+		if ( ( nDevInfo->Feature.DeviceID.Code[0] == SAMSUNG_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == HYNIX_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == ST_NAND_MAKER_ID ) )
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8181;
+		else if ( ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == INTEL_NAND_MAKER_ID ))
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8080;		
+	}
+	else
+	{
+		/* Command Page Program #1 [ 0x80 ] */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8080;		
+	}
+
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* Change Cycle */
+	NAND_IO_SetWriteCycleTime();
+
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	//=========================================================================
+	// Set SpareBuffer Pointer =>> ECCBuffer
+	//=========================================================================
+	if ( ( nDevInfo->Feature.MediaType  & A_BIG ) || (( nDevInfo->Feature.MediaType  & A_SMALL ) && ( nDevInfo->Feature.MediaType  & A_PARALLEL )))
+	{
+		memset( gNAND_IO_ShareEccBuffer, 0xFF, nDevInfo->EccWholeDataSize );		
+		pSpareB		= (unsigned char*)&gNAND_IO_ShareEccBuffer[0];
+	}
+	else
+	{
+		pSpareB		= (unsigned char*)nSpareBuffer;
+		pSpareB 	+= NAND_IO_SPARE_SIZE_SMALL;
+	}
+	
+	//=========================================================================
+	// Empty Page ECCBuffer Pointer Increment
+	//=========================================================================
+	for ( j = 0; j < nStartPPage; ++j )
+	{
+		if ( nDevInfo->EccType == MLC_ECC_4BIT_TYPE )
+			pECC_Info = &gMLC_ECC_4Bit;
+		else if ( nDevInfo->EccType == MLC_ECC_8BIT_TYPE )
+			pECC_Info = &gMLC_ECC_8Bit;
+		else if ( nDevInfo->EccType == MLC_ECC_12BIT_TYPE )
+			pECC_Info = &gMLC_ECC_12Bit;
+		else if ( nDevInfo->EccType == MLC_ECC_14BIT_TYPE )
+			pECC_Info = &gMLC_ECC_14Bit;
+		else if ( nDevInfo->EccType == MLC_ECC_16BIT_TYPE )
+			pECC_Info = &gMLC_ECC_16Bit;
+		else
+			return ERR_NAND_IO_WRONG_PARAMETER;
+
+		if ( nDevInfo->Feature.MediaType  & A_MLC_16BIT )
+		{
+			pSpare = (unsigned char*)pSpareB;
+			
+			for ( i = 0; i < nDevInfo->EccDataSize; ++i )
+				pSpare[i] = pECC_Info->All_FF_512_ECC_Code[i];
+		}
+		else
+		{
+			memcpy(	(void*)pSpareB, (void*)pECC_Info->All_FF_512_ECC_Code, nDevInfo->EccDataSize);
+		}
+
+		pSpareB += nDevInfo->EccDataSize;
+	}
+
+	*rEccBuffer = (unsigned int)pSpareB;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      void 	NAND_IO_IRQ_WritePageMidProcess( NAND_IO_DEVINFO *nDevInfo, U8 nWriteMode );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			nDevInfo	= 
+*			nWriteMode	= 
+*  
+*  OUTPUT:	void - Return Type
+*  
+**************************************************************************/
+void 	NAND_IO_IRQ_WritePageMidProcess( NAND_IO_DEVINFO *nDevInfo, U8 nWriteMode )
+{
+	/* Change Cycle */
+	NAND_IO_SetCommCycleTime();
+
+	if ( nWriteMode == MULTI_PLANE_START_PAGE )
+	{
+		/* Command Multi Plane Page Program #2 [ 0x11 ] */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1111;
+
+		if ( !( ( nDevInfo->Feature.MediaType & S_IL ) || ( nDevInfo->ExtInterleaveUsable == TRUE ) ) )
+			NAND_IO_WaitBusyForCacheProgram( nDevInfo );		
+	}
+	else if ( ( nWriteMode == MULTI_PLANE_MID_PAGE ) || ( nWriteMode == MULTI_PLANE_LAST_PAGE ) )
+	{
+		if ( ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID ) )	
+		{
+			if ( ( nWriteMode == MULTI_PLANE_LAST_PAGE ) || ( nDevInfo->ExtInterleaveUsable == TRUE ) )
+				pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+			else if ( nWriteMode == MULTI_PLANE_MID_PAGE )
+				pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1515;
+		}
+		else	
+		{
+			// SAMSUNG, HYNIX, MICRON, INTEL, ST Maker TwoPlane Write Function
+			if ( nDevInfo->Feature.MediaType & S_MCP )
+			{
+				if ( nWriteMode == MULTI_PLANE_LAST_PAGE )
+					pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+				else if ( nWriteMode == MULTI_PLANE_MID_PAGE )
+					pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1515;
+			}
+			else
+				pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+		}
+	}
+	else // normal page
+	{
+		/* Command Page Program #2 [ 0x10 ] */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+	}
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      void 	NAND_IO_IRQ_WritePagePostProcess( void );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*  
+*  OUTPUT:	void - Return Type
+*  
+**************************************************************************/
+void 	NAND_IO_IRQ_WritePagePostProcess( void )
+{
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      void 	NAND_IO_IRQ_Write512DataPreProcess( NAND_IO_DEVINFO *nDevInfo );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			nDevInfo	= 
+*  
+*  OUTPUT:	void - Return Type
+*  
+**************************************************************************/
+void 	NAND_IO_IRQ_Write512DataPreProcess( NAND_IO_DEVINFO *nDevInfo )
+{ 
+	//==========================================================
+	//
+	// ECC Encode Setup
+	//
+	//==========================================================
+	pIOBUSCFG_T->STORAGE = HwIOBUSCFG_STORAGE_NFC;
+	pECC->ECC_BASE	 = (unsigned int)&NAND_IO_HwLDATA_PA;
+
+	pECC->ECC_MASK	= 0x00000000;				/* Address mask for ECC area */
+
+	if ( nDevInfo->EccType == SLC_ECC_TYPE )
+		pECC->ECC_CTRL	|= 	HwECC_CTRL_EN_SLCEN;
+	else if (nDevInfo->EccType == MLC_ECC_4BIT_TYPE )
+		pECC->ECC_CTRL	|= 	HwECC_CTRL_EN_MCL4EN;
+	else if (nDevInfo->EccType == MLC_ECC_8BIT_TYPE )
+		pECC->ECC_CTRL	|= 	HwECC_CTRL_EN_MCL8EN;
+	else if (nDevInfo->EccType == MLC_ECC_12BIT_TYPE )
+		pECC->ECC_CTRL	|= 	HwECC_CTRL_EN_MCL12EN;
+	else if (nDevInfo->EccType == MLC_ECC_16BIT_TYPE )
+		pECC->ECC_CTRL	|= 	HwECC_CTRL_EN_MCL16EN;
+
+	pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );
+	pECC->ECC_CLEAR	= 0x00000000;	
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      NAND_IO_ERROR 	NAND_IO_IRQ_Write512DataPostProcess( NAND_IO_DEVINFO *nDevInfo, U8* nECCBuffer );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			nDevInfo	= 
+*			nECCBuffer	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+**************************************************************************/
+NAND_IO_ERROR 	NAND_IO_IRQ_Write512DataPostProcess( NAND_IO_DEVINFO *nDevInfo, U8* nECCBuffer )
+{ 
+	unsigned int		i;
+	#ifdef _LINUX_
+	unsigned char		nTempBuffer[30]__attribute__((aligned(8)));
+	#else
+	unsigned char		nTempBuffer[30];
+	#endif
+	unsigned char		*pSpare, *pEccB;
+	NAND_IO_ERROR		res = (NAND_IO_ERROR)SUCCESS;
+
+	//============================
+	// Get ECC Code
+	//============================
+	if ( pNFC->NFC_CTRL1 & Hw30 )
+		BITSET( pNFC->NFC_CTRL1, Hw31 );
+
+	/*	Load ECC code from ECC block */
+	if ( nDevInfo->Feature.MediaType  & A_MLC_16BIT )
+	{
+		pSpare = (unsigned char*)nECCBuffer;
+		pEccB  = (unsigned char*)nTempBuffer;
+		res = NAND_IO_EncodeECC( nDevInfo->EccType, pEccB );
+		for ( i = 0; i < nDevInfo->EccDataSize; ++i )
+			pSpare[i] = pEccB[i];
+	}
+	else
+	{
+		res = NAND_IO_EncodeECC( nDevInfo->EccType, nECCBuffer );
+	}
+
+	return res;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      static __inline void NAND_IO_IRQ_Mask( void );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*  
+*  OUTPUT:	void - Return Type
+*  
+**************************************************************************/
+static __inline void NAND_IO_IRQ_Mask( void )
+{
+	#ifdef __USE_NAND_ISR__
+	unsigned int	irq = NAND_IRQ_NFC;
+    if (irq < 32){
+		BITCLR(pPIC->IEN0, (1 << irq));
+        BITCLR(pPIC->INTMSK0,   (1 << irq));
+    } else {
+  		BITCLR(pPIC->IEN1, (1 << (irq - 32)));
+        BITCLR(pPIC->INTMSK1,   (1 << (irq - 32)));
+    }
+	#endif
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      static __inline void NAND_IO_IRQ_UnMask( void );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*  
+*  OUTPUT:	void - Return Type
+*  
+**************************************************************************/
+static __inline void NAND_IO_IRQ_UnMask( void )
+{
+	#ifdef __USE_NAND_ISR__
+	unsigned int	irq = NAND_IRQ_NFC;
+
+	pNFC->NFC_IREQ		= 0x77;	// HwNFC_IREQ_FLAG1;
+    if (irq < 32) {
+        BITSET(pPIC->INTMSK0,   (1 << irq));
+        BITSET(pPIC->CLR0,      (1 << irq));
+		BITSET(pPIC->IEN0, 		(1 << irq));
+    } else {
+        BITSET(pPIC->INTMSK1,   (1 << (irq - 32)));
+        BITSET(pPIC->CLR1,      (1 << (irq - 32)));
+		BITSET(pPIC->IEN1, 		(1 << (irq - 32)));
+    }
+	#endif
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      NAND_IO_ERROR NAND_IO_IRQ_ExtInterruptSet(unsigned int irq);
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			irq	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+**************************************************************************/
+NAND_IO_ERROR NAND_IO_IRQ_ExtInterruptSet(unsigned int irq)
+{
+	unsigned int	RegNum;
+	unsigned char	nSource;
+	NAND_IO_ERROR	res = (NAND_IO_ERROR)SUCCESS;
+
+	#if defined(TCC_NAND_RDY_B31)
+	nSource = 0x31;		// GPIO_B31
+	#else
+	nSource = 0x2E; 	// GPIO_B28
+	#endif
+
+	if (( irq < 15 ) && ( irq > 2 ))
+	{
+		RegNum = (( irq - 3 ) >> 2 );
+		switch(RegNum)
+		{
+			case 0:
+				BITCLR(pGPIO->EINTSEL0, 0x3F 	<< ( ( irq - 3 ) << 3 ));
+				BITSET(pGPIO->EINTSEL0, nSource << ( ( irq - 3 ) << 3 ));
+				break;
+
+			case 1:
+				BITCLR(pGPIO->EINTSEL1, 0x3F 	<< ( ( irq - 7 ) << 3 ));
+				BITSET(pGPIO->EINTSEL1, nSource << ( ( irq - 7 ) << 3 ));
+				break;
+
+			case 2:
+				BITCLR(pGPIO->EINTSEL2, 0x3F 	<< ( ( irq - 11 ) << 3 ));
+				BITSET(pGPIO->EINTSEL2, nSource << ( ( irq - 11 ) << 3 ));
+				break;
+		}
+
+		res = SUCCESS;
+	}
+	else
+	{
+		res = ERR_NAND_IO_WRONG_PARAMETER;		
+	}
+
+	return res;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      NAND_IO_ERROR NAND_IO_IRQ_ExtInterruptClear(unsigned int irq);
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			irq	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+**************************************************************************/
+NAND_IO_ERROR NAND_IO_IRQ_ExtInterruptClear(unsigned int irq)
+{
+	unsigned int	RegNum;
+	unsigned char	nSource;
+	NAND_IO_ERROR	res = (NAND_IO_ERROR)SUCCESS;
+
+	#if defined(TCC_NAND_RDY_B31)
+	nSource = 0x31;		// GPIO_B31
+	#else
+	nSource = 0x2E; 	// GPIO_B28
+	#endif
+
+	if (( irq < 15 ) && ( irq > 2 ))
+	{
+		RegNum = (( irq - 3 ) >> 2 );
+		switch(RegNum)
+		{
+			case 0:
+				BITCLR(pGPIO->EINTSEL0, 0x3F 	<< ( ( irq - 3 ) << 3 ));
+				break;
+
+			case 1:
+				BITCLR(pGPIO->EINTSEL1, 0x3F 	<< ( ( irq - 7 ) << 3 ));
+				break;
+
+			case 2:
+				BITCLR(pGPIO->EINTSEL2, 0x3F 	<< ( ( irq - 11 ) << 3 ));
+				break;
+		}
+		
+        BITSET(pPIC->CLR0, (1 << irq));
+		res = SUCCESS;
+	}
+	else
+	{
+		res = ERR_NAND_IO_WRONG_PARAMETER;		
+	}
+
+	return res;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      void NAND_IO_IRQ_ReadyBusySet( void );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*  
+*  OUTPUT:	void - Return Type
+*  
+**************************************************************************/
+void NAND_IO_IRQ_ReadyBusySet( void )
+{
+	pIOBUSCFG_T->STORAGE = HwIOBUSCFG_STORAGE_NFC;
+	pECC->ECC_BASE		 = (unsigned int)&NAND_IO_HwLDATA_PA;
+
+	#if defined(TCC_NAND_RDY_B28)
+	// Externel intr GPIOB_28 config
+	pGPIO->GPBFN3 &= ~0x00010000;		// GPIO_B28 --> Normal GPIO
+	BITCLR(pGPIO->GPBEN, Hw28);			// Input Mode
+    BITSET(pPIC->SEL0, (1 << NAND_IRQ_READY));			// Interrupt Select --> IRQ
+	#endif
+
+    BITCLR(pPIC->IEN0, (1 << NAND_IRQ_READY));			// Interrupt Disable	
+    BITSET(pPIC->CLR0, (1 << NAND_IRQ_READY));			// Interrupt Status Clear
+
+	NAND_IO_IRQ_ExtInterruptSet(NAND_IRQ_READY);
+
+    BITSET(pPIC->MODE0, (1 << NAND_IRQ_READY));			// Set: Level-triggered, Cler: Edge-triggered
+    BITCLR(pPIC->POL0,  (1 << NAND_IRQ_READY));			// Interrupt Set Active-High
+    BITSET(pPIC->CLR0,  (1 << NAND_IRQ_READY));			// Interrupt Status Clear
+    BITSET(pPIC->IEN0,  (1 << NAND_IRQ_READY));			// Interrupt Enable	
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      void NAND_IO_IRQ_ReadyBusyClear( void );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*  
+*  OUTPUT:	void - Return Type
+*  
+**************************************************************************/
+void NAND_IO_IRQ_ReadyBusyClear( void )
+{
+    BITSET(pPIC->CLR0, (1 << NAND_IRQ_READY));			// Interrupt Status Clear
+	NAND_IO_IRQ_ExtInterruptClear(NAND_IRQ_READY);
+    BITCLR(pPIC->IEN0, (1 << NAND_IRQ_READY));			// Interrupt Disable
+
+	#if defined(TCC_NAND_RDY_B31)
+	pGPIO->GPBFN3 &= ~0x10000000;		// ND_RDY: GPIO_B31			
+	BITCLR(pGPIO->GPBEN, Hw31);
+	#else	
+	pGPIO->GPBFN3 |= 0x00010000;		// GPIO_B28 --> EDI
+	#endif	
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      void NAND_IO_IRQ_SetupDMA( void *pDST, int nMode );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			nMode	= 
+*			pDST	= 
+*  
+*  OUTPUT:	void - Return Type
+*  
+**************************************************************************/
+void NAND_IO_IRQ_SetupDMA( void *pDST, int nMode )
+{
+	unsigned int	nSourceAddr, nDestAddr;
+	unsigned		uCHCTRL;
+	unsigned int	uTmp;	
+	unsigned int	uSrcInc, uSrcMask;
+	unsigned int	uDstInc, uDstMask;
+
+	if ( nMode == NAND_IO_DMA_WRITE )
+	{
+		uSrcInc 	= 4;
+		uSrcMask 	= 0;
+		uDstInc		= 0;
+		uDstMask 	= 0;
+	}
+	else
+	{
+		uSrcInc 	= 0;
+		uSrcMask 	= 0;
+		uDstInc		= 4;
+		uDstMask 	= 0;
+	}
+
+	if ( nMode == NAND_IO_DMA_WRITE )
+	{
+		BITCSET(pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_8 | HwNFC_CTRL_DEN_EN | HwNFC_CTRL_PSIZE_512 );
+		// Target Physical Address- for DMA H/W Control Set
+		nSourceAddr	= (unsigned int)pDST;
+		nDestAddr 	= (unsigned int)&NAND_IO_HwLDATA_PA;
+
+		//============================================================
+		// DMA Control Register Set
+		//============================================================
+		uCHCTRL =	
+	//				HwCHCTRL_SYNC_ON		|
+	//				HwCHCTRL_HRD_W			|
+					HwCHCTRL_BST_BURST		|
+					HwCHCTRL_TYPE_SINGL		|
+				   	HwCHCTRL_HRD_WR			|
+	//				HwCHCTRL_BST_BURST		|
+					HwCHCTRL_BSIZE_8		|
+					HwCHCTRL_WSIZE_32		|
+					HwCHCTRL_FLAG			|
+					HwCHCTRL_EN_ON			|
+					0;
+	}
+	else
+	{
+		// pSRC: NFC_LDATA
+		// pDST: Buffer Address
+		
+		BITCSET(pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_8 | HwNFC_CTRL_DEN_EN | HwNFC_CTRL_PSIZE_512 );
+		
+		nSourceAddr	= (unsigned int)&NAND_IO_HwLDATA_PA;
+		nDestAddr 	= (unsigned int)pDST;
+
+		//============================================================
+		// DMA Control Register Set
+		//============================================================
+		uCHCTRL =	
+	//				HwCHCTRL_SYNC_ON		|
+	//				HwCHCTRL_HRD_W			|
+					HwCHCTRL_BST_BURST		|
+					HwCHCTRL_TYPE_SINGL		|
+				   	HwCHCTRL_HRD_RD			|
+	//				HwCHCTRL_BST_BURST		|
+					HwCHCTRL_BSIZE_8		|
+					HwCHCTRL_WSIZE_32		|
+					HwCHCTRL_FLAG			|
+					HwCHCTRL_EN_ON			|
+					0;
+	}
+	
+	//============================================================
+	// Set Source Address & Source Parameter (mask + increment)
+	//============================================================
+	pNAND_DMA->ST_SADR 	= nSourceAddr;
+	#if defined(_WINCE_) || defined(_LINUX_)
+	pNAND_DMA->SPARAM[0] = (uSrcInc | (uSrcMask << 4));
+	#else
+	pNAND_DMA->SPARAM	 = (uSrcInc | (uSrcMask << 4));
+	#endif
+	//============================================================
+	// Set Dest Address & Dest Parameter (mask + increment)
+	//============================================================
+	pNAND_DMA->ST_DADR 	= nDestAddr;  
+	#if defined(_WINCE_) || defined(_LINUX_)
+	pNAND_DMA->DPARAM[0] = (uDstInc | (uDstMask << 4));
+	#else
+	pNAND_DMA->DPARAM	 = (uDstInc | (uDstMask << 4));
+	#endif
+	//============================================================
+	// Calculate byte size per 1 Hop transfer
+	//============================================================
+	uTmp	= (uCHCTRL & (Hw5+Hw4)) >> 4;			// calc log2(word size)
+	uTmp	= uTmp + ( (uCHCTRL & (Hw7+Hw6)) >> 6);	// calc log2(word * burst size)
+
+	//============================================================
+	// Set External DMA Request Register
+	//============================================================
+	pNAND_DMA->EXTREQ = Hw18;		// NFC
+
+	//============================================================
+	// Set Hcount
+	//============================================================
+	pNAND_DMA->HCOUNT	= 0x10;
+	
+	//============================================================
+	// Set & Enable DMA
+	//============================================================
+	pNAND_DMA->CHCTRL	= uCHCTRL;
+
+	//============================================================
+	// Set NFC DSize & IREQ Clear
+	//============================================================
+	pNFC->NFC_DSIZE		= 512;
+	pNFC->NFC_IREQ		= 0x77;	// HwNFC_IREQ_FLAG1;
+
+	//============================================================
+	// DMA Transfer Start
+	//============================================================
+	#ifdef NAND_GPIO_DEBUG
+	BITSET(pGPIO->GPFDAT, Hw21);
+	#endif	
+	if ( nMode == NAND_IO_DMA_WRITE )
+	{
+		if ( pNFC->NFC_CTRL1 & Hw31 )
+			BITCLR( pNFC->NFC_CTRL1, Hw31 );
+
+		pNFC->NFC_PSTART	= 0;
+}
+	else
+		pNFC->NFC_RSTART	= 0;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      void NAND_IO_IRQ_SetupDMAForSpare( int nDSize );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			nDSize	= 
+*  
+*  OUTPUT:	void - Return Type
+*  
+**************************************************************************/
+void NAND_IO_IRQ_SetupDMAForSpare( int nDSize )
+{
+	#if defined(USE_V_ADDRESS) && defined(_LINUX_)
+	unsigned int	uTmp;
+	unsigned int	*pDMA_PhyBuffer;
+	unsigned int	nSourceAddr, nDestAddr;
+	unsigned		uCHCTRL;
+
+	pDMA_PhyBuffer 	= (unsigned int*)gNAND_IO_ShareEccBuffer_w;			// Working Address
+
+	BITCSET(pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_8 | HwNFC_CTRL_DEN_EN | HwNFC_CTRL_PSIZE_512 );
+
+	#if defined(_WINCE_) || defined(_LINUX_)
+	nSourceAddr = (unsigned int)&NAND_IO_HwLDATA_PA;				// NFC_LDATA Physical Address: ex_TCC89,92XX: 0XF050b0020
+	#else
+	nSourceAddr = (unsigned int)&pNFC->NFC_LDATA;
+	#endif
+	nDestAddr 	= (unsigned int)pDMA_PhyBuffer;
+
+	//============================================================
+	// DMA Control Register Set
+	//============================================================
+	uCHCTRL =	
+//				HwCHCTRL_SYNC_ON		|
+//				HwCHCTRL_HRD_W			|
+				HwCHCTRL_BST_BURST		|
+				HwCHCTRL_TYPE_SINGL		|
+			   	HwCHCTRL_HRD_RD			|
+//				HwCHCTRL_BST_BURST		|
+				HwCHCTRL_BSIZE_8		|
+				HwCHCTRL_WSIZE_32		|
+				HwCHCTRL_FLAG			|
+				HwCHCTRL_EN_ON			|
+				0;
+
+	//============================================================
+	// Set Source Address & Source Parameter (mask + increment)
+	//============================================================
+	pNAND_DMA->ST_SADR 	= nSourceAddr;
+	#if defined(_WINCE_) || defined(_LINUX_)
+	pNAND_DMA->SPARAM[0] = 0;
+	#else
+	pNAND_DMA->SPARAM	 = 0;
+	#endif
+	//============================================================
+	// Set Dest Address & Dest Parameter (mask + increment)
+	//============================================================
+	pNAND_DMA->ST_DADR 	= nDestAddr;  
+	#if defined(_WINCE_) || defined(_LINUX_)
+	pNAND_DMA->DPARAM[0] = 0x4;
+	#else
+	pNAND_DMA->DPARAM	 = 0x4;
+	#endif
+	//============================================================
+	// Calculate byte size per 1 Hop transfer
+	//============================================================
+	uTmp	= (uCHCTRL & (Hw5+Hw4)) >> 4;			// calc log2(word size)
+	uTmp	= uTmp + ( (uCHCTRL & (Hw7+Hw6)) >> 6);	// calc log2(word * burst size)
+
+	//============================================================
+	// Set External DMA Request Register
+	//============================================================
+	pNAND_DMA->EXTREQ = Hw18;		// NFC
+
+	//============================================================
+	// Set Hcount
+	//============================================================
+	if (uTmp)
+		pNAND_DMA->HCOUNT	= (nDSize  + (1 << uTmp) - 1) >> uTmp;
+	else
+		pNAND_DMA->HCOUNT	= nDSize;
+
+	//============================================================
+	// Set & Enable DMA
+	//============================================================
+	pNAND_DMA->CHCTRL		= uCHCTRL;
+
+	//============================================================
+	// Set NFC DSize & IREQ Clear
+	//============================================================
+	pNFC->NFC_DSIZE		= nDSize ;
+	pNFC->NFC_IREQ		= 0x77;	// HwNFC_IREQ_FLAG1;
+
+	//============================================================
+	// DMA Transfer Start
+	//============================================================
+	#ifdef NAND_GPIO_DEBUG
+	BITSET(pGPIO->GPFDAT, Hw21);
+	#endif
+	pNFC->NFC_RSTART	= 0;
+#endif
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
 *      static __inline NAND_IO_ERROR NAND_IO_ReadStatus( NAND_IO_DEVINFO *nDevInfo );
 *  
 *  DESCRIPTION : 
@@ -5596,7 +6771,7 @@ static __inline NAND_IO_ERROR NAND_IO_ReadStatusForMultiPlane( NAND_IO_DEVINFO *
 		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7070;
 	else if ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID )
 		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7171;
-	else if ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID )
+	else if ( ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == INTEL_NAND_MAKER_ID ) )
 		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7070;
 	else
 		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7070;
@@ -5720,7 +6895,7 @@ static __inline NAND_IO_ERROR NAND_IO_ReadStatusForCacheProgram( NAND_IO_DEVINFO
  	{
 		uStatus		= nDevInfo->CmdMask & pNFC->NFC_SDATA;
 		
-		if ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID )
+		if ( ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == INTEL_NAND_MAKER_ID )  )
 			uCheckBit = nDevInfo->CmdMask & 0x2020;
 		else
 			uCheckBit = nDevInfo->CmdMask & 0x4040;
@@ -5807,7 +6982,7 @@ static __inline NAND_IO_ERROR NAND_IO_ReadStatusForInterleave( NAND_IO_DEVINFO *
 			pNFC->NFC_CMD = nDevInfo->CmdMask & 0xF2F2;					
 			else if ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID )
 				pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7171;
-			else if ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID )
+			else if ( ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == INTEL_NAND_MAKER_ID ) )
 			{
 				pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7878;	
 				NAND_IO_WriteBlockPageAddr( gInterLeaveDie0BlockAddr, nDevInfo );
@@ -5828,7 +7003,7 @@ static __inline NAND_IO_ERROR NAND_IO_ReadStatusForInterleave( NAND_IO_DEVINFO *
 				pNFC->NFC_CMD = nDevInfo->CmdMask & 0xF3F3;			
 			else if ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID )
 				pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7171;	
-			else if ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID )
+			else if ( ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == INTEL_NAND_MAKER_ID ) )
 			{
 				pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7878;
 				NAND_IO_WriteBlockPageAddr( gInterLeaveDie1BlockAddr, nDevInfo );
@@ -5845,8 +7020,9 @@ static __inline NAND_IO_ERROR NAND_IO_ReadStatusForInterleave( NAND_IO_DEVINFO *
  	timeout = 0xFFFFF;
  	while ( timeout )
  	{
-		if ( ( nDevInfo->Feature.DeviceID.Code[0] == SAMSUNG_NAND_MAKER_ID ) || 
-			 ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID )	 ||
+		if ( ( nDevInfo->Feature.DeviceID.Code[0] == SAMSUNG_NAND_MAKER_ID ) 	|| 
+			 ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID )	 	||
+			 ( nDevInfo->Feature.DeviceID.Code[0] == INTEL_NAND_MAKER_ID )		||
 			 ( nDevInfo->Feature.DeviceID.Code[0] == ST_NAND_MAKER_ID ) )
 		{
 			uStatus		= nDevInfo->CmdMask & pNFC->NFC_SDATA;
@@ -5987,7 +7163,7 @@ static __inline NAND_IO_ERROR NAND_IO_ReadStatusForInterleaveClear( NAND_IO_DEVI
 			pNFC->NFC_CMD = nDevInfo->CmdMask & 0xF2F2;		
 		else if ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID )
 			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7171;
-		else if ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID )
+		else if ( ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == INTEL_NAND_MAKER_ID ) )
 		{
 			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7878;
 			NAND_IO_WriteBlockPageAddr( gInterLeaveDie0BlockAddr, nDevInfo );
@@ -6038,7 +7214,7 @@ static __inline NAND_IO_ERROR NAND_IO_ReadStatusForInterleaveClear( NAND_IO_DEVI
 			pNFC->NFC_CMD = nDevInfo->CmdMask & 0xF3F3;		
 		else if ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID )
 			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7171;
-		else if ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID )
+		else if ( ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == INTEL_NAND_MAKER_ID ) )
 		{
 			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7878;
 			NAND_IO_WriteBlockPageAddr( gInterLeaveDie1BlockAddr, nDevInfo );
@@ -6372,7 +7548,7 @@ static __inline void NAND_IO_WriteRowColAddr( U32 nRowAddr, U32 nColumnAddr, NAN
 *  OUTPUT:	void - Return Type
 *  REMARK  :	
 **************************************************************************/
-static __inline void NAND_IO_WriteColAddr( U32 nColumnAddr, NAND_IO_DEVINFO *nDevInfo )
+void NAND_IO_WriteColAddr( U32 nColumnAddr, NAND_IO_DEVINFO *nDevInfo )
 {
 	unsigned int		i;
 	
@@ -6432,7 +7608,6 @@ static __inline void NAND_IO_WriteBlockPageAddr( U32 nBlockPageAddr, NAND_IO_DEV
 *  OUTPUT:	void - Return Type
 *  
 **************************************************************************/
-#if defined( NAND_IO_USE_DMA_ACCESS )
 static __inline void NAND_IO_SetupDMA( void *pSRC, unsigned uSrcInc, unsigned uSrcMask, 
 									   void *pDST, unsigned uDstInc, unsigned uDstMask, int nMode, int nDSize )
 {
@@ -6446,16 +7621,12 @@ static __inline void NAND_IO_SetupDMA( void *pSRC, unsigned uSrcInc, unsigned uS
 	tSYSTEM_PARAM	*pSYS_Work_PARAM	= (tSYSTEM_PARAM*)(SYSTEM_PARAM_BASEADDRESS);
 	#endif
 
-	#ifdef READ_SPEED_CHECK
-	NAND_IO_GPIO_Toggle(Hw15);
-	#endif
-
 	#if defined(_WINCE_)
 	pDMA_PhyBuffer 	= (unsigned int*)pSYS_Work_PARAM->DMA2.CH0_BUFFER;	// Working Address
 	pDMA_WorkBuffer = (unsigned int*)pSYS_PARAM->DMA2.CH0_BUFFER;		// Physical Address
 	#elif defined(_LINUX_)
 	#ifdef KERNEL_DRIVER
-	pDMA_PhyBuffer 	= dma_t.dma_addr;	
+	pDMA_PhyBuffer 	= (unsigned int*)dma_t.dma_addr;	
 	pDMA_WorkBuffer	= (unsigned int*)dma_t.v_addr;
 	#else
 	pDMA_PhyBuffer 	= (unsigned int*)DMA_ADDR;	
@@ -6466,13 +7637,6 @@ static __inline void NAND_IO_SetupDMA( void *pSRC, unsigned uSrcInc, unsigned uS
 	pDMA_WorkBuffer	= (unsigned int*)0x10003000;			
 	#endif
 	
-	// Read Test
-	//pDMA_PhyBuffer = 0x10003000;
-	//pDMA_WorkBuffer	= 0x10003000;
-	
-	//pDMA_PhyBuffer = pDST;
-	//pDMA_WorkBuffer	= pDST;
-
 	if ( nMode == NAND_IO_DMA_WRITE )
 	{
 		// pSRC: Buffer Address
@@ -6506,11 +7670,6 @@ static __inline void NAND_IO_SetupDMA( void *pSRC, unsigned uSrcInc, unsigned uS
 	}
 	else	// NAND_IO_DMA_READ
 	{	
-
-		#ifdef READ_SPEED_CHECK
-		NAND_IO_GPIO_Toggle(Hw5);
-		#endif /* READ_SPEED_CHECK */
-	
 		// pSRC: NFC_LDATA
 		// pDST: Buffer Address
 
@@ -6519,6 +7678,8 @@ static __inline void NAND_IO_SetupDMA( void *pSRC, unsigned uSrcInc, unsigned uS
 		nSourceAddr = (unsigned int)pSRC;				// NFC_LDATA Physical Address: ex_TCC89,92XX: 0XF050b0020
 		nDestAddr 	= (unsigned int)pDMA_PhyBuffer;
 
+//		ND_TRACE("\npDMA_WorkBuffer_Addr:0x%08X / 0x%08X", pDMA_PhyBuffer, pDMA_WorkBuffer );
+
 		//============================================================
 		// DMA Control Register Set
 		//============================================================
@@ -6592,32 +7753,191 @@ static __inline void NAND_IO_SetupDMA( void *pSRC, unsigned uSrcInc, unsigned uS
 		if ( pNFC->NFC_CTRL1 & Hw31 )
 			BITCLR( pNFC->NFC_CTRL1, Hw31 );
 
+		NAND_IO_IRQ_Mask();
+
 		pNFC->NFC_PSTART	= 0;
-		
 		while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+		
+		NAND_IO_IRQ_UnMask();
 
 		if ( pNFC->NFC_CTRL1 & Hw30 )
 			BITSET( pNFC->NFC_CTRL1, Hw31 );
 	}
 	else
 	{
-		pNFC->NFC_RSTART	= 0;
+		NAND_IO_IRQ_Mask();
 		
+		pNFC->NFC_RSTART	= 0;
 		while ( ISZERO(pNFC->NFC_IREQ, HwNFC_IREQ_FLAG0) );
+		
+		NAND_IO_IRQ_UnMask();
 
-		#ifdef READ_SPEED_CHECK
-		NAND_IO_GPIO_Toggle(Hw5);
-		#endif /* READ_SPEED_CHECK */
+		memcpy( pDST, pDMA_WorkBuffer, nDSize );
+	}
+}
 
-		#ifdef READ_SPEED_CHECK
-		NAND_IO_GPIO_Toggle(Hw4);
-		#endif
+static __inline void NAND_IO_SetupDMA_kernel( void *pSRC, unsigned uSrcInc, unsigned uSrcMask, 
+										   void *pDST, unsigned uDstInc, unsigned uDstMask, int nMode, int nDSize )
+{
+	unsigned int	*pDMA_PhyBuffer;
+	unsigned int	*pDMA_WorkBuffer;
+	unsigned int	nSourceAddr, nDestAddr;
+	unsigned		uCHCTRL;
+	unsigned int	uTmp;
 
-		memcpy( pDST, pDMA_WorkBuffer, nDSize );
+	#if defined(_WINCE_)
+	tSYSTEM_PARAM	*pSYS_Work_PARAM	= (tSYSTEM_PARAM*)(SYSTEM_PARAM_BASEADDRESS);
+	#endif
 
-		#ifdef READ_SPEED_CHECK
-		NAND_IO_GPIO_Toggle(Hw4);
-		#endif
+	#if defined(_WINCE_)
+	pDMA_PhyBuffer 	= (unsigned int*)pSYS_Work_PARAM->DMA2.CH0_BUFFER;	// Working Address
+	pDMA_WorkBuffer = (unsigned int*)pSYS_PARAM->DMA2.CH0_BUFFER;		// Physical Address
+	#elif defined(_LINUX_)
+	#ifdef KERNEL_DRIVER
+	pDMA_PhyBuffer 	= (unsigned int*)dma_t.dma_addr;	
+	pDMA_WorkBuffer	= (unsigned int*)dma_t.v_addr;
+	#else
+	pDMA_PhyBuffer 	= (unsigned int*)DMA_ADDR;	
+	pDMA_WorkBuffer	= (unsigned int*)DMA_ADDR;
+	#endif
+	#else		// NU
+	pDMA_PhyBuffer 	= (unsigned int*)0x10003000;
+	pDMA_WorkBuffer	= (unsigned int*)0x10003000;			
+	#endif
+	
+	if ( nMode == NAND_IO_DMA_WRITE )
+	{
+		// pSRC: Buffer Address
+		// pDST: NFC_LDATA
+
+		BITCSET(pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_8 | HwNFC_CTRL_DEN_EN | HwNFC_CTRL_PSIZE_512 );
+
+		//pSRC --> pDMA_WorkBuffer
+		memcpy( pDMA_WorkBuffer, pSRC, nDSize );
+
+		// Target Physical Address- for DMA H/W Control Set
+		nSourceAddr	= (unsigned int)pDMA_PhyBuffer;
+		nDestAddr 	= (unsigned int)pDST;
+
+		//============================================================
+		// DMA Control Register Set
+		//============================================================
+		uCHCTRL =	
+	//				HwCHCTRL_SYNC_ON		|
+	//				HwCHCTRL_HRD_W			|
+					HwCHCTRL_BST_BURST		|
+					HwCHCTRL_TYPE_SINGL		|
+				   	HwCHCTRL_HRD_WR			|
+	//				HwCHCTRL_BST_BURST		|
+					HwCHCTRL_BSIZE_8		|
+					HwCHCTRL_WSIZE_32		|
+					HwCHCTRL_FLAG			|
+					HwCHCTRL_EN_ON			|
+					0;
+
+	}
+	else	// NAND_IO_DMA_READ
+	{	
+		// pSRC: NFC_LDATA
+		// pDST: Buffer Address
+
+		BITCSET(pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_8 | HwNFC_CTRL_DEN_EN | HwNFC_CTRL_PSIZE_512 );
+
+		nSourceAddr = (unsigned int)pSRC;				// NFC_LDATA Physical Address: ex_TCC89,92XX: 0XF050b0020
+//		nDestAddr 	= (unsigned int)pDMA_PhyBuffer;
+		nDestAddr 	= (unsigned int)pDST;
+
+		//============================================================
+		// DMA Control Register Set
+		//============================================================
+		uCHCTRL =	
+	//				HwCHCTRL_SYNC_ON		|
+	//				HwCHCTRL_HRD_W			|
+					HwCHCTRL_BST_BURST		|
+					HwCHCTRL_TYPE_SINGL		|
+				   	HwCHCTRL_HRD_RD			|
+	//				HwCHCTRL_BST_BURST		|
+					HwCHCTRL_BSIZE_8		|
+					HwCHCTRL_WSIZE_32		|
+					HwCHCTRL_FLAG			|
+					HwCHCTRL_EN_ON			|
+					0;
+	}
+
+	//============================================================
+	// Set Source Address & Source Parameter (mask + increment)
+	//============================================================
+	pNAND_DMA->ST_SADR 	= nSourceAddr;
+	#if defined(_WINCE_) || defined(_LINUX_)
+	pNAND_DMA->SPARAM[0] = (uSrcInc | (uSrcMask << 4));
+	#else
+	pNAND_DMA->SPARAM	 = (uSrcInc | (uSrcMask << 4));
+	#endif
+
+	//============================================================
+	// Set Dest Address & Dest Parameter (mask + increment)
+	//============================================================
+	pNAND_DMA->ST_DADR 	= nDestAddr;  
+	#if defined(_WINCE_) || defined(_LINUX_)
+	pNAND_DMA->DPARAM[0] = (uDstInc | (uDstMask << 4));
+	#else
+	pNAND_DMA->DPARAM	 = (uDstInc | (uDstMask << 4));
+	#endif
+
+	//============================================================
+	// Calculate byte size per 1 Hop transfer
+	//============================================================
+	uTmp	= (uCHCTRL & (Hw5+Hw4)) >> 4;			// calc log2(word size)
+	uTmp	= uTmp + ( (uCHCTRL & (Hw7+Hw6)) >> 6);	// calc log2(word * burst size)
+
+	//============================================================
+	// Set External DMA Request Register
+	//============================================================
+	pNAND_DMA->EXTREQ = Hw18;		// NFC
+
+	//============================================================
+	// Set Hcount
+	//============================================================
+	if (uTmp)
+		pNAND_DMA->HCOUNT	= (nDSize + (1 << uTmp) - 1) >> uTmp;
+	else
+		pNAND_DMA->HCOUNT	= nDSize;
+
+	//============================================================
+	// Set & Enable DMA
+	//============================================================
+	pNAND_DMA->CHCTRL		= uCHCTRL;
+
+	//============================================================
+	// Set NFC DSize & IREQ Clear
+	//============================================================
+	pNFC->NFC_DSIZE		= nDSize;
+	pNFC->NFC_IREQ		= 0x77;	// HwNFC_IREQ_FLAG1;
+
+	//============================================================
+	// DMA Transfer Start
+	//============================================================
+	if ( nMode == NAND_IO_DMA_WRITE )
+	{
+		if ( pNFC->NFC_CTRL1 & Hw31 )
+			BITCLR( pNFC->NFC_CTRL1, Hw31 );
+
+		NAND_IO_IRQ_Mask();
+	
+		pNFC->NFC_PSTART	= 0;
+		while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+
+		NAND_IO_IRQ_UnMask();
+		
+		if ( pNFC->NFC_CTRL1 & Hw30 )
+			BITSET( pNFC->NFC_CTRL1, Hw31 );
+	}
+	else
+	{
+		NAND_IO_IRQ_Mask();
+		pNFC->NFC_RSTART	= 0;
+		while ( ISZERO(pNFC->NFC_IREQ, HwNFC_IREQ_FLAG0) );
+		NAND_IO_IRQ_UnMask();
 	}
 }
 
@@ -6783,7 +8103,6 @@ static __inline void NAND_IO_SetupDMADoubleBuf(  int nMode, int nDMACh )
 	pNFC->NFC_DSIZE		= 512;
 	pNFC->NFC_IREQ		= 0x77;	// HwNFC_IREQ_FLAG1;
 }
-#endif
 
 /**************************************************************************
 *  FUNCTION NAME : 
@@ -7058,6 +8377,145 @@ ErrorCorrectionSLC:
 	
 }
 
+
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      static __inline NAND_IO_ERROR NAND_IO_CorrectionMLC_IRQ( U16 nEccType, U8* nPageBuffer, U8* nSpareBuffer, U16 nDataSize );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			nDataSize	= 
+*			nEccType	= 
+*			nPageBuffer	= 
+*			nSpareBuffer	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_CorrectionMLC_IRQ( U16 nEccType, U8* nPageBuffer, U8* nSpareBuffer, U16 nDataSize )
+{
+	unsigned int		i;
+	unsigned int		uErrAddr;
+	unsigned int		uErrorStatus;
+	unsigned int		*pSpareDW;
+	
+	NAND_IO_ECC_INFO	*pECC_Info;
+	NAND_IO_ERROR		res;
+
+	if ( nEccType == MLC_ECC_4BIT_TYPE )
+		pECC_Info = &gMLC_ECC_4Bit;
+	else if ( nEccType == MLC_ECC_8BIT_TYPE )
+		pECC_Info = &gMLC_ECC_8Bit;
+	else if ( nEccType == MLC_ECC_12BIT_TYPE )
+		pECC_Info = &gMLC_ECC_12Bit;
+	else if ( nEccType == MLC_ECC_14BIT_TYPE )
+		pECC_Info = &gMLC_ECC_14Bit;
+	else if ( nEccType == MLC_ECC_16BIT_TYPE )
+		pECC_Info = &gMLC_ECC_16Bit;
+	else
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	pSpareDW	= (unsigned int *)nSpareBuffer;
+	
+	//IO_CKC_EnableBUS( IO_CKC_BUS_ECC );
+	
+	pECC->ECC_CODE0	= *pSpareDW; ++pSpareDW;
+	pECC->ECC_CODE1	= *pSpareDW; ++pSpareDW;
+	pECC->ECC_CODE2	= *pSpareDW; ++pSpareDW;
+	pECC->ECC_CODE3	= *pSpareDW; ++pSpareDW;
+	pECC->ECC_CODE4	= *pSpareDW; ++pSpareDW;
+	pECC->ECC_CODE5	= *pSpareDW; ++pSpareDW;
+	pECC->ECC_CODE6	= *pSpareDW; ++pSpareDW;
+
+	/* Sync Delay */
+
+	/* Wait MLC ECC Correction */
+	while ( !(pECC->ECC_IREQ & pECC_Info->DecodeFlag ) );
+
+	res = (NAND_IO_ERROR)SUCCESS;
+
+	/* Correction */
+	uErrorStatus = pECC->ERRNUM & 0x1F;
+
+	if ( uErrorStatus > pECC_Info->ErrorNum )
+	{
+		if ( memcmp( nSpareBuffer, gNAND_IO_TempBuffer, pECC_Info->EccDataSize ) == 0 )
+		{
+			//ND_TRACE("[Ecc Decode]: %d byte 0xFF \n", nDataSize );
+			return SUCCESS;
+		}
+		
+		#ifdef NAND_IO_ECC_ERROR_LOG
+		PRINTF("\n\nErrorNum[%02d],DataSize[%03d] - Correction Fail", uErrorStatus, nDataSize );
+		#if defined(USE_V_ADDRESS) && defined(_WINCE_)
+		RETAILMSG(1,(	TEXT("[NAND        ] [ECC Correction Fail]\n")));
+		#else
+		ND_TRACE("[NAND        ] [ECC Correction Fail]\n" );
+		#endif
+		#endif
+
+		if ( nDataSize == 512 )
+		{
+			#if defined(USE_V_ADDRESS)				
+			ND_TRACE("\n\nErrorNum[%02d],DataSize[%03d] - Correction Fail", uErrorStatus, nDataSize );
+			ND_TRACE("\n\nISR_Data:\n");
+			for ( i = 0; i < nDataSize; ++i )
+			{
+				ND_TRACE("%02X", nPageBuffer[i]);
+			}
+
+			ND_TRACE("\n\nISR_ECC:\n");
+			for ( i = 0; i < 28; ++i )
+			{
+				ND_TRACE("%02X", nSpareBuffer[i]);
+			}
+			#else
+			ND_TRACE("\n\nErrorNum[%d],DataSize[%d] - Correction Fail", uErrorStatus, nDataSize );
+			ND_TRACE("\n\nData:\n");
+			for ( i = 0; i < nDataSize; ++i )
+			{
+				ND_TRACE("%X", nPageBuffer[i]);
+			}
+
+			ND_TRACE("\n\nECC:\n");
+			for ( i = 0; i < 28; ++i )
+			{
+				ND_TRACE("%X", nSpareBuffer[i]);
+			}
+			#endif
+
+			ND_TRACE("\n\n");			
+		}
+
+		res = ERR_NAND_IO_FAILED_CORRECTION_MLC_ECC;
+		goto ErrorCorrectionMLC;
+	}
+	else if ( uErrorStatus == HwERR_NUM_NOERR )
+	{
+		res = (NAND_IO_ERROR)SUCCESS;
+	}
+	else
+	{
+		for ( i = 0; i < uErrorStatus; ++i )
+		{
+			uErrAddr = *(unsigned long int*)(&pECC->ECC_EADDR0+i);
+
+			if ( ( uErrAddr >> 3 ) < nDataSize )
+				nPageBuffer[uErrAddr>>3] ^= (1<<(uErrAddr &0x7));
+		}
+	}
+	
+ErrorCorrectionMLC:
+	/* Disable MLC ECC */
+	//IO_CKC_DisableBUS( IO_CKC_BUS_ECC );
+	
+	return res;
+}
+
 /**************************************************************************
 *  FUNCTION NAME : 
 *  
@@ -7122,8 +8580,8 @@ static __inline NAND_IO_ERROR NAND_IO_CorrectionMLC( U16 nEccType, U8* nPageBuff
 	}
 	else
 	{
-		pSpareDW	= (unsigned int *)nECCBuffer;
-	}
+			pSpareDW 	= ( unsigned int *)nECCBuffer;
+		}
 	
 	//IO_CKC_EnableBUS( IO_CKC_BUS_ECC );
 	
@@ -7148,15 +8606,39 @@ static __inline NAND_IO_ERROR NAND_IO_CorrectionMLC( U16 nEccType, U8* nPageBuff
 
 	if ( uErrorStatus > pECC_Info->ErrorNum )
 	{
-		#ifdef NAND_IO_ECC_ERROR_LOG
-		PRINTF("\n\nErrorNum[%02d],DataSize[%03d] - Correction Fail", uErrorStatus, nDataSize );
-		#if defined(USE_V_ADDRESS) && defined(_WINCE_)
-		RETAILMSG(1,(	TEXT("[NAND        ] [ECC Correction Fail]\n")));
-		#else
-		ND_TRACE("[NAND        ] [ECC Correction Fail]\n" );
-		#endif
-		#endif
-		
+		if ( nDataSize == 512 )
+		{
+			#if defined(USE_V_ADDRESS)
+			ND_TRACE("\n\nErrorNum[%02d],DataSize[%03d] - Correction Fail", uErrorStatus, nDataSize );
+			ND_TRACE("\n\nData:\n");
+			for ( i = 0; i < nDataSize; ++i )
+			{
+				ND_TRACE("%02X", nPageBuffer[i]);
+			}
+
+			ND_TRACE("\n\nECC:\n");
+			for ( i = 0; i < 28; ++i )
+			{
+				ND_TRACE("%02X", nSpareBuffer[i]);
+			}
+			#else
+			ND_TRACE("\n\nErrorNum[%d],DataSize[%d] - Correction Fail", uErrorStatus, nDataSize );
+			ND_TRACE("\n\nData:\n");
+			for ( i = 0; i < nDataSize; ++i )
+			{
+				ND_TRACE("%X", nPageBuffer[i]);
+			}
+
+			ND_TRACE("\n\nECC:\n");
+			for ( i = 0; i < 28; ++i )
+			{
+				ND_TRACE("%X", nSpareBuffer[i]);
+			}
+			#endif
+			
+			ND_TRACE("\n\n");			
+		}
+
 		res = ERR_NAND_IO_FAILED_CORRECTION_MLC_ECC;
 		goto ErrorCorrectionMLC;
 	}
@@ -7348,7 +8830,7 @@ NAND_IO_ERROR NAND_IO_EncDecodeBinary( unsigned int nEncDec, unsigned int nEccTy
 	unsigned int		nEccDataSize = 0;
 	unsigned char		*pPageB;
 	unsigned char		*pDataBuffer;
-	unsigned char		*pEccB, *pEccBuffer;
+	unsigned char		*pEccBuffer;
 	DWORD_BYTE			uDWordByte;
 	NAND_IO_ERROR		res;
 
@@ -7671,7 +9153,7 @@ static __inline NAND_IO_ERROR NAND_IO_ReadSpareData( NAND_IO_DEVINFO *nDevInfo,
 
 	if ( nPageEccOnOff == PAGE_ECC_ON )
 	{
-		memset( gNAND_IO_ShareEccBuffer, 0xFF, nDevInfo->EccWholeDataSize );
+		//memset( gNAND_IO_ShareEccBuffer, 0xFF, nDevInfo->EccWholeDataSize );
 		
 		//=========================================================================
 		// Check Align of PageBuffer Address
@@ -7707,7 +9189,8 @@ static __inline NAND_IO_ERROR NAND_IO_ReadSpareData( NAND_IO_DEVINFO *nDevInfo,
 		}while(--i);
 	}
 
-	return res;
+//	return res;
+	return (NAND_IO_ERROR)SUCCESS;
 }
 
 /**************************************************************************
@@ -7904,6 +9387,24 @@ static __inline NAND_IO_ERROR NAND_IO_ReadSpareDataMTD( NAND_IO_DEVINFO *nDevInf
 	return res;
 }
 
+#if defined(USE_V_ADDRESS) && defined(_WINCE_)
+NAND_IO_ERROR NAND_IO_SetNFC_IRQ_Handle( int nIrq, DWORD nItrID, HANDLE hEvent )
+{
+	if ( nIrq == IRQ_NFC )
+	{
+		gNFC_IRQ_Intr	= nItrID;
+		gNFC_IRQ_Handle = hEvent;
+		printf("[-IRQ_NFC:EventH:0x%x]\r\n", gNFC_IRQ_Handle);
+	}
+	else
+	{
+		gEXT_IRQ_Intr	= nItrID;
+		gEXT_IRQ_Handle	= hEvent;
+		printf("[-IRQ_EI11:EventH:0x%x]\r\n", gEXT_IRQ_Handle);
+	}
+}
+#endif
+
 /**************************************************************************
 *  FUNCTION NAME : 
 *      static __inline NAND_IO_ERROR NAND_IO_Read512DataDoubleBuf( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nReadPPSize,
@@ -7922,7 +9423,6 @@ static __inline NAND_IO_ERROR NAND_IO_ReadSpareDataMTD( NAND_IO_DEVINFO *nDevInf
 *  			= 
 *  REMARK  :	
 **************************************************************************/
-#if defined( NAND_IO_USE_DMA_ACCESS )
 static __inline NAND_IO_ERROR NAND_IO_Read512DataDoubleBuf( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nReadPPSize,
 												   			U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff, int nSpareOnOff )
 {
@@ -7939,8 +9439,8 @@ static __inline NAND_IO_ERROR NAND_IO_Read512DataDoubleBuf( NAND_IO_DEVINFO *nDe
 		return ERR_NAND_IO_WRONG_PARAMETER;
 
 	#ifdef READ_SPEED_CHECK
-	NAND_IO_GPIO_Toggle(Hw6);
-	#endif /* READ_SPEED_CHECK */
+	NAND_IO_GPIO_Toggle(Hw17);
+	#endif
 
 	//=========================================================================
 	// Initial Setting
@@ -7965,7 +9465,7 @@ static __inline NAND_IO_ERROR NAND_IO_Read512DataDoubleBuf( NAND_IO_DEVINFO *nDe
 		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
 
 	#ifdef READ_SPEED_CHECK
-	NAND_IO_GPIO_Toggle(Hw6);	//----------------------->> ECC Setup
+	NAND_IO_GPIO_Toggle(Hw17);	//----------------------->> ECC Setup
 	#endif /* READ_SPEED_CHECK */
 
 	//=========================================================================
@@ -8023,7 +9523,7 @@ static __inline NAND_IO_ERROR NAND_IO_Read512DataDoubleBuf( NAND_IO_DEVINFO *nDe
 		}
 
 		#ifdef READ_SPEED_CHECK
-		NAND_IO_GPIO_Toggle(Hw5);
+		NAND_IO_GPIO_Toggle(Hw21);
 		#endif
 
 		/* Read 512 Data Area */
@@ -8044,12 +9544,17 @@ static __inline NAND_IO_ERROR NAND_IO_Read512DataDoubleBuf( NAND_IO_DEVINFO *nDe
 		}while(--i);
 
 		#ifdef READ_SPEED_CHECK
-		NAND_IO_GPIO_Toggle(Hw5);
+		NAND_IO_GPIO_Toggle(Hw21);
 		#endif
 		//----------------------------------------------
 		//	DMA ACCESS
 		//----------------------------------------------
 		#elif defined( NAND_IO_USE_DMA_ACCESS )		
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw17);
+		#endif
+		
 		/* Setup ECC Block */
 		if ( nEccOnOff == ECC_ON )
 		{
@@ -8066,13 +9571,77 @@ static __inline NAND_IO_ERROR NAND_IO_Read512DataDoubleBuf( NAND_IO_DEVINFO *nDe
 		/* Start DMA on NFC BUS */
 		NAND_IO_SetupDMADoubleBuf( NAND_IO_DMA_READ, j );
 
-		#ifdef READ_SPEED_CHECK
-		NAND_IO_GPIO_Toggle(Hw6);
+		#if defined(USE_V_ADDRESS) && defined(_WINCE_) && defined(__USE_NAND_ISR__)
+
+		#ifdef NAND_GPIO_DEBUG
+		BITSET(pGPIO->GPFDAT, Hw16);
 		#endif
 
+	    BITSET(pPIC->CLR1, Hw9);			// Interrupt Status Clear
+		InterruptDone(gNFC_IRQ_Intr);
+		
 		pNFC->NFC_RSTART	= 0;
+
+        if ( pNFC->NFC_IREQ & HwNFC_IREQ_FLAG0 )		//Check Read-Done Flag
+	    {
+            BITSET( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG0 );		// Interrupt Clear
+
+		    #ifdef NAND_IO_UART_DEBUG
+		    ND_TRACE("[NAND]Rx-DMA already complite[%s:%d]\r\n", __FUNCTION__, __LINE__);
+		    #endif
+	    }
+	    else
+	    {
+		    DWORD nTimeOut = 1;		// Unit: Milliseconds
+
+		    #ifdef NAND_GPIO_DEBUG
+		    BITSET(pGPIO->GPFDAT, Hw17);
+		    #endif
+	    
+		    if( WaitForSingleObject( gNFC_IRQ_Handle, nTimeOut) == WAIT_OBJECT_0 )
+		    {
+			    #ifdef NAND_GPIO_DEBUG
+			    BITSET(pGPIO->GPFDAT, Hw21);
+			    BITCLR(pGPIO->GPFDAT, Hw21);
+			    #endif
+
+			    #ifdef NAND_IO_UART_DEBUG
+			    ND_TRACE("[NAND]Rx-DMA complite[%s:%d]\r\n", __FUNCTION__, __LINE__);
+			    #endif
+		    }
+		    else
+		    {
+			    #ifdef NAND_GPIO_DEBUG
+			    BITSET(pGPIO->GPFDAT, Hw22);
+			    BITCLR(pGPIO->GPFDAT, Hw22);
+			    #endif
+			    #ifdef NAND_IO_UART_DEBUG
+			    ND_TRACE("[NAND]Rx-DMA Wait Time Out[%s:%d]\r\n", __FUNCTION__, __LINE__);
+			    #endif
+		    }
+		    #ifdef NAND_GPIO_DEBUG
+		    BITCLR(pGPIO->GPFDAT, Hw17);
+		    #endif
+	    }
+
+		BITSET( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG0 );		// Interrupt Clear
+        BITSET(pPIC->CLR1, Hw9);			// Interrupt Status Clear
+	    InterruptDone(gNFC_IRQ_Intr);
+
+	    #ifdef NAND_GPIO_DEBUG
+	    BITCLR(pGPIO->GPFDAT, Hw16);
+	    #endif
+		#else
 		
-		if ( j != 0 )
+		NAND_IO_IRQ_Mask();
+		pNFC->NFC_RSTART	= 0;
+		#endif
+
+		if ( j == 0 )
+		{
+//			memcpy( gNAND_IO_ShareEccBuffer, gpDMA_WorkBuffer0, nDevInfo->EccWholeDataSize );
+		}
+		else
 		{
 			if ( j & 1 )
 				memcpy( pPrDataBuffer, gpDMA_WorkBuffer1, 512 );
@@ -8080,23 +9649,14 @@ static __inline NAND_IO_ERROR NAND_IO_Read512DataDoubleBuf( NAND_IO_DEVINFO *nDe
 				memcpy( pPrDataBuffer, gpDMA_WorkBuffer0, 512 );
 		}
 
-		#ifdef READ_SPEED_CHECK
-		NAND_IO_GPIO_Toggle(Hw6);
-		#endif
 
-		#ifdef READ_SPEED_CHECK
-		NAND_IO_GPIO_Toggle(Hw5);
-		#endif
+		#if defined(USE_V_ADDRESS) && defined(_WINCE_) && defined(__USE_NAND_ISR__)
+		// nop
+		#else
 		while ( ISZERO(pNFC->NFC_IREQ, HwNFC_IREQ_FLAG0) );
-
-		#ifdef READ_SPEED_CHECK
-		NAND_IO_GPIO_Toggle(Hw5);
+		NAND_IO_IRQ_UnMask();
 		#endif
 
-
-		#ifdef READ_SPEED_CHECK
-		NAND_IO_GPIO_Toggle(Hw4);
-		#endif		
 		if ( j == (unsigned int)( nReadPPSize - 1 ) )
 		{
 			if ( j & 1 )
@@ -8109,7 +9669,7 @@ static __inline NAND_IO_ERROR NAND_IO_Read512DataDoubleBuf( NAND_IO_DEVINFO *nDe
 			pPrDataBuffer = pDataBuffer;	// Buffer Pointer Backup
 
 			if ( j & 1 )
-				pDataBuffer =(unsigned char *)gpDMA_WorkBuffer0;			
+				pDataBuffer =(unsigned char *)gpDMA_WorkBuffer0;
 			else
 				pDataBuffer =(unsigned char *)gpDMA_WorkBuffer1;
 		}
@@ -8118,9 +9678,6 @@ static __inline NAND_IO_ERROR NAND_IO_Read512DataDoubleBuf( NAND_IO_DEVINFO *nDe
 			pPageDW += 128;
 		else
 			pPageB += 512;
-		#ifdef READ_SPEED_CHECK		
-		NAND_IO_GPIO_Toggle(Hw4);
-		#endif
 
 		#endif
 		//####################################################
@@ -8156,6 +9713,10 @@ static __inline NAND_IO_ERROR NAND_IO_Read512DataDoubleBuf( NAND_IO_DEVINFO *nDe
 			pSpareB +=	NAND_IO_SPARE_SIZE_SMALL;
 		}
 
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw22);
+		#endif
+		
 		/* Check and Correct ECC code */
 		if ( nEccOnOff == ECC_ON )
 		{
@@ -8179,8 +9740,8 @@ static __inline NAND_IO_ERROR NAND_IO_Read512DataDoubleBuf( NAND_IO_DEVINFO *nDe
 		}
 
 		#ifdef READ_SPEED_CHECK
-		NAND_IO_GPIO_Toggle(Hw6);
-		#endif		
+		NAND_IO_GPIO_Toggle(Hw22);
+		#endif
 	}
 
 	//=========================================================================
@@ -8192,7 +9753,6 @@ static __inline NAND_IO_ERROR NAND_IO_Read512DataDoubleBuf( NAND_IO_DEVINFO *nDe
 	return res;
 
 }
-#endif
 
 /**************************************************************************
 *  FUNCTION NAME : 
@@ -8226,10 +9786,6 @@ static __inline NAND_IO_ERROR NAND_IO_Read512Data( NAND_IO_DEVINFO *nDevInfo, U1
 	if ( ( nStartPPage + nReadPPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
 		return ERR_NAND_IO_WRONG_PARAMETER;
 
-	#ifdef READ_SPEED_CHECK
-	NAND_IO_GPIO_Toggle(Hw13);
-	#endif /* READ_SPEED_CHECK */
-
 	//=========================================================================
 	// Initial Setting
 	//=========================================================================
@@ -8252,10 +9808,6 @@ static __inline NAND_IO_ERROR NAND_IO_Read512Data( NAND_IO_DEVINFO *nDevInfo, U1
 	if ( nEccOnOff == ECC_ON )
 		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
 
-	#ifdef READ_SPEED_CHECK
-	NAND_IO_GPIO_Toggle(Hw13);	//----------------------->> ECC Setup
-	#endif /* READ_SPEED_CHECK */
-
 	//=========================================================================
 	// Get Buffer Pointer
 	//=========================================================================
@@ -8310,12 +9862,6 @@ static __inline NAND_IO_ERROR NAND_IO_Read512Data( NAND_IO_DEVINFO *nDevInfo, U1
 			pECC->ECC_CLEAR	 = 0x00000000;			/* Clear ECC Block		*/
 		}
 
-		#ifdef READ_SPEED_CHECK
-		BITCLR(pGPIO->GPBDAT, Hw15);
-
-		NAND_IO_GPIO_Toggle(Hw15);
-		#endif
-
 		/* Read 512 Data Area */
 		i = 128;
 		do {
@@ -8333,9 +9879,6 @@ static __inline NAND_IO_ERROR NAND_IO_Read512Data( NAND_IO_DEVINFO *nDevInfo, U1
 			}
 		}while(--i);
 
-		#ifdef READ_SPEED_CHECK
-		NAND_IO_GPIO_Toggle(Hw15);
-		#endif
 		//----------------------------------------------
 		//	DMA ACCESS
 		//----------------------------------------------
@@ -8352,17 +9895,8 @@ static __inline NAND_IO_ERROR NAND_IO_Read512Data( NAND_IO_DEVINFO *nDevInfo, U1
 			pECC->ECC_CLEAR	 = 0x00000000;			/* Clear ECC Block		*/
 		}
 		
-		#ifdef READ_SPEED_CHECK
-		NAND_IO_GPIO_Toggle(Hw13);
-		#endif /* READ_SPEED_CHECK */
-
-
-		#ifdef READ_SPEED_CHECK
-		BITCLR(pGPIO->GPBDAT, Hw15);
-		#endif
-
 		/* Start DMA on NFC BUS */
-		#if defined(_LINUX_) || defined(_WINCE_)
+		#if defined(_WINCE_) || defined(_LINUX_)
 		NAND_IO_SetupDMA( (void*)&NAND_IO_HwLDATA_PA, 0, 0,
 						  (void*)pDataBuffer, 4, 0,
 						  NAND_IO_DMA_READ, 512 );
@@ -8372,27 +9906,15 @@ static __inline NAND_IO_ERROR NAND_IO_Read512Data( NAND_IO_DEVINFO *nDevInfo, U1
 						  NAND_IO_DMA_READ, 512 );
 		#endif
 
-		#ifdef READ_SPEED_CHECK
-		NAND_IO_GPIO_Toggle(Hw15);
-		#endif
-
 		if ( bAlignAddr )
 			pPageDW += 128;
 		else
 			pPageB += 512;
 
-		#ifdef READ_SPEED_CHECK		
-		NAND_IO_GPIO_Toggle(Hw13);	//------------------------------------->> DMA Transfer
-		#endif
-
 		#endif
 		//####################################################
 		//####################################################
 
-		#ifdef READ_SPEED_CHECK
-		NAND_IO_GPIO_Toggle(Hw13);
-		#endif
-
 		if ( ( nDevInfo->Feature.MediaType  & A_BIG ) || (( nDevInfo->Feature.MediaType  & A_SMALL ) && ( nDevInfo->Feature.MediaType  & A_PARALLEL )))
 		{
 			// NOP	
@@ -8445,10 +9967,6 @@ static __inline NAND_IO_ERROR NAND_IO_Read512Data( NAND_IO_DEVINFO *nDevInfo, U1
 				pSpareB += nDevInfo->EccDataSize;
 			}
 		}
-
-		#ifdef READ_SPEED_CHECK
-		NAND_IO_GPIO_Toggle(Hw13);		//--------------------------------->> ECC Correction
-		#endif		
 	}
 
 	//=========================================================================
@@ -8824,7 +10342,7 @@ static __inline NAND_IO_ERROR NAND_IO_ReadUserSizeData( NAND_IO_DEVINFO *nDevInf
 *  
 *  REMARK:	  by nemo
 **************************************************************************/
-static __inline NAND_IO_ERROR NAND_IO_WriteSpareData( NAND_IO_DEVINFO *nDevInfo, U8 *nSpareBuffer, int nPageEccOnOff )
+NAND_IO_ERROR NAND_IO_WriteSpareData( NAND_IO_DEVINFO *nDevInfo, U8 *nSpareBuffer, int nPageEccOnOff )
 {
 	unsigned int		i;
 	unsigned int		nSpareTotalSize;
@@ -8849,7 +10367,7 @@ static __inline NAND_IO_ERROR NAND_IO_WriteSpareData( NAND_IO_DEVINFO *nDevInfo,
 	if ( nDevInfo->Feature.MediaType & A_MLC_16BIT )
 		nSpareTotalSize = 12;
 	else
-		nSpareTotalSize = 16;
+	nSpareTotalSize = 16;
 	
 	//=========================================================================
 	// Check Align of nSpareBuffer Address
@@ -8895,6 +10413,9 @@ static __inline NAND_IO_ERROR NAND_IO_WriteSpareData( NAND_IO_DEVINFO *nDevInfo,
 			BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
 			pNFC->NFC_DSIZE		= nSpareTotalSize;
 			pNFC->NFC_IREQ	 	= 0x77;	// pNFC->NFC_IREQ_FLAG1;
+
+			NAND_IO_IRQ_Mask();
+
 			pNFC->NFC_PSTART 	= 0;
 
 			i = ( nSpareTotalSize >> 2 );
@@ -8916,6 +10437,7 @@ static __inline NAND_IO_ERROR NAND_IO_WriteSpareData( NAND_IO_DEVINFO *nDevInfo,
 			}while(--i);
 
 			while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+			NAND_IO_IRQ_UnMask();
 		}
 		else
 		{
@@ -9318,7 +10840,6 @@ static __inline NAND_IO_ERROR NAND_IO_Write512DataDoubleBuf( NAND_IO_DEVINFO *nD
 	unsigned char		*pDataBuffer;
 	unsigned char		*pEccB, *pSpare;
 	#ifdef NAND_IO_USE_MCU_ACCESS
-	unsigned int		i;
 	DWORD_BYTE			uDWordByte;
 	#endif
 	NAND_IO_ECC_INFO	*pECC_Info;	
@@ -9398,9 +10919,9 @@ static __inline NAND_IO_ERROR NAND_IO_Write512DataDoubleBuf( NAND_IO_DEVINFO *nD
 		}
 		else
 		{
-			memcpy(	(void*)pSpareB, (void*)pECC_Info->All_FF_512_ECC_Code, nDevInfo->EccDataSize);
+		memcpy(	(void*)pSpareB, (void*)pECC_Info->All_FF_512_ECC_Code, nDevInfo->EccDataSize);
 		}
-		
+
 		pSpareB += nDevInfo->EccDataSize;
 	}
 
@@ -9437,6 +10958,9 @@ static __inline NAND_IO_ERROR NAND_IO_Write512DataDoubleBuf( NAND_IO_DEVINFO *nD
 			BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
 			pNFC->NFC_DSIZE		= 512;
 			pNFC->NFC_IREQ 		= 0x77;	// pNFC->NFC_IREQ_FLAG1;		
+
+			NAND_IO_IRQ_Mask();
+
 			pNFC->NFC_PSTART 	= 0;
 			
 			i = 128;
@@ -9458,6 +10982,7 @@ static __inline NAND_IO_ERROR NAND_IO_Write512DataDoubleBuf( NAND_IO_DEVINFO *nD
 			}while(--i);
 			
 			while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+			NAND_IO_IRQ_UnMask();
 		}
 		else
 		{
@@ -9515,6 +11040,7 @@ static __inline NAND_IO_ERROR NAND_IO_Write512DataDoubleBuf( NAND_IO_DEVINFO *nD
 		if ( pNFC->NFC_CTRL1 & Hw31 )
 			BITCLR( pNFC->NFC_CTRL1, Hw31 );
 
+		NAND_IO_IRQ_Mask();
 		pNFC->NFC_PSTART	= 0;
 
 		if ( j != (unsigned int)( nWritePPSize - 1 ) ) 
@@ -9526,6 +11052,7 @@ static __inline NAND_IO_ERROR NAND_IO_Write512DataDoubleBuf( NAND_IO_DEVINFO *nD
 		}
 
 		while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+		NAND_IO_IRQ_UnMask();
 
 		if ( pNFC->NFC_CTRL1 & Hw30 )
 			BITSET( pNFC->NFC_CTRL1, Hw31 );
@@ -9547,13 +11074,13 @@ static __inline NAND_IO_ERROR NAND_IO_Write512DataDoubleBuf( NAND_IO_DEVINFO *nD
 				if ( nDevInfo->Feature.MediaType  & A_MLC_16BIT )
 				{
 					pSpare = (unsigned char*)pSpareB;
-					pEccB  = (unsigned char*)nECCBuffer;
+					pEccB = (unsigned char*)nECCBuffer;
 					res = NAND_IO_EncodeECC( nDevInfo->EccType, pEccB );
 					for ( i = 0; i < nDevInfo->EccDataSize; ++i )
 						pSpare[i] = pEccB[i];
 				}
 				else
-					res = NAND_IO_EncodeECC( nDevInfo->EccType, pSpareB );
+				res = NAND_IO_EncodeECC( nDevInfo->EccType, pSpareB );
 			}
 			else
 			{
@@ -9620,7 +11147,7 @@ static __inline NAND_IO_ERROR NAND_IO_Write512DataDoubleBuf( NAND_IO_DEVINFO *nD
 				}
 				else
 				{
-					memcpy(	(void*)pSpareB, (void*)pECC_Info->All_FF_512_ECC_Code, nDevInfo->EccDataSize);
+				memcpy(	(void*)pSpareB, (void*)pECC_Info->All_FF_512_ECC_Code, nDevInfo->EccDataSize);
 				}
 				pSpareB += nDevInfo->EccDataSize;	
 			}
@@ -9654,6 +11181,8 @@ static __inline NAND_IO_ERROR NAND_IO_Write512DataDoubleBuf( NAND_IO_DEVINFO *nD
 				BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
 				pNFC->NFC_DSIZE	= 512;
 				pNFC->NFC_IREQ = 0x77;	// pNFC->NFC_IREQ_FLAG1;		
+
+				NAND_IO_IRQ_Mask();
 				pNFC->NFC_PSTART = 0;
 				
 				i = 128;
@@ -9665,6 +11194,8 @@ static __inline NAND_IO_ERROR NAND_IO_Write512DataDoubleBuf( NAND_IO_DEVINFO *nD
 				
 				while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
 				
+				NAND_IO_IRQ_UnMask();
+				
 				//----------------------------------------------
 				//	DMA ACCESS
 				//----------------------------------------------
@@ -9763,7 +11294,6 @@ static __inline NAND_IO_ERROR NAND_IO_Write512Data( NAND_IO_DEVINFO *nDevInfo, U
 	unsigned char		*pDataBuffer;
 	unsigned char		*pEccB, *pSpare;
 	#ifdef NAND_IO_USE_MCU_ACCESS
-	unsigned int		i;
 	DWORD_BYTE			uDWordByte;
 	#endif
 	NAND_IO_ECC_INFO	*pECC_Info;	
@@ -9841,7 +11371,7 @@ static __inline NAND_IO_ERROR NAND_IO_Write512Data( NAND_IO_DEVINFO *nDevInfo, U
 		}
 		else
 		{
-			memcpy(	(void*)pSpareB, (void*)pECC_Info->All_FF_512_ECC_Code, nDevInfo->EccDataSize);
+		memcpy(	(void*)pSpareB, (void*)pECC_Info->All_FF_512_ECC_Code, nDevInfo->EccDataSize);
 		}
 
 		pSpareB += nDevInfo->EccDataSize;
@@ -9880,6 +11410,8 @@ static __inline NAND_IO_ERROR NAND_IO_Write512Data( NAND_IO_DEVINFO *nDevInfo, U
 		    BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
 		    pNFC->NFC_DSIZE		= 512;
 		    pNFC->NFC_IREQ 		= 0x77;	// pNFC->NFC_IREQ_FLAG1;		
+
+			NAND_IO_IRQ_Mask();
 		    pNFC->NFC_PSTART 	= 0;
 		    
 		    i = 128;
@@ -9901,6 +11433,7 @@ static __inline NAND_IO_ERROR NAND_IO_Write512Data( NAND_IO_DEVINFO *nDevInfo, U
 		    }while(--i);
 		    
 		    while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+			NAND_IO_IRQ_UnMask();
 		}
 		else
 		{
@@ -9975,14 +11508,14 @@ static __inline NAND_IO_ERROR NAND_IO_Write512Data( NAND_IO_DEVINFO *nDevInfo, U
 			if ( nDevInfo->Feature.MediaType  & A_MLC_16BIT )
 			{
 				pSpare = (unsigned char*)pSpareB;
-				pEccB  = (unsigned char*)nECCBuffer;
+				pEccB = (unsigned char*)nECCBuffer;
 				res = NAND_IO_EncodeECC( nDevInfo->EccType, pEccB );
 				for ( i = 0; i < nDevInfo->EccDataSize; ++i )
 					pSpare[i] = pEccB[i];
 			}
 			else
 			{
-				res = NAND_IO_EncodeECC( nDevInfo->EccType, pSpareB );
+			res = NAND_IO_EncodeECC( nDevInfo->EccType, pSpareB );
 			}
 			if ( res != SUCCESS )
 				goto ErrorWrite512Data;
@@ -10039,7 +11572,7 @@ static __inline NAND_IO_ERROR NAND_IO_Write512Data( NAND_IO_DEVINFO *nDevInfo, U
 				}
 				else
 				{
-					memcpy(	(void*)pSpareB, (void*)pECC_Info->All_FF_512_ECC_Code, nDevInfo->EccDataSize);
+				memcpy(	(void*)pSpareB, (void*)pECC_Info->All_FF_512_ECC_Code, nDevInfo->EccDataSize);
 				}
 
 				pSpareB += nDevInfo->EccDataSize;	
@@ -10074,6 +11607,8 @@ static __inline NAND_IO_ERROR NAND_IO_Write512Data( NAND_IO_DEVINFO *nDevInfo, U
 				BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
 				pNFC->NFC_DSIZE	= 512;
 				pNFC->NFC_IREQ = 0x77;	// pNFC->NFC_IREQ_FLAG1;		
+
+				NAND_IO_IRQ_Mask();
 				pNFC->NFC_PSTART = 0;
 				
 				i = 128;
@@ -10084,6 +11619,7 @@ static __inline NAND_IO_ERROR NAND_IO_Write512Data( NAND_IO_DEVINFO *nDevInfo, U
 				}while(--i);
 				
 				while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+				NAND_IO_IRQ_UnMask();
 				
 				//----------------------------------------------
 				//	DMA ACCESS
@@ -10294,6 +11830,8 @@ static __inline NAND_IO_ERROR NAND_IO_Write512DataMTD( NAND_IO_DEVINFO *nDevInfo
 		BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
 		pNFC->NFC_DSIZE		= 512;
 		pNFC->NFC_IREQ 		= 0x77;	// pNFC->NFC_IREQ_FLAG1;		
+
+		NAND_IO_IRQ_Mask();
 		pNFC->NFC_PSTART 	= 0;
 		
 		i = 128;
@@ -10315,6 +11853,7 @@ static __inline NAND_IO_ERROR NAND_IO_Write512DataMTD( NAND_IO_DEVINFO *nDevInfo
 		}while(--i);
 		
 		while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+		NAND_IO_IRQ_UnMask();
 
 		//----------------------------------------------
 		//	DMA ACCESS
@@ -10436,6 +11975,8 @@ static __inline NAND_IO_ERROR NAND_IO_Write512DataMTD( NAND_IO_DEVINFO *nDevInfo
 				BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
 				pNFC->NFC_DSIZE	= 512;
 				pNFC->NFC_IREQ = 0x77;	// pNFC->NFC_IREQ_FLAG1;		
+
+				NAND_IO_IRQ_Mask();
 				pNFC->NFC_PSTART = 0;
 				
 				i = 128;
@@ -10446,6 +11987,7 @@ static __inline NAND_IO_ERROR NAND_IO_Write512DataMTD( NAND_IO_DEVINFO *nDevInfo
 				}while(--i);
 				
 				while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+				NAND_IO_IRQ_UnMask();
 				
 				//----------------------------------------------
 				//	DMA ACCESS
@@ -10657,7 +12199,7 @@ NAND_IO_ERROR NAND_IO_LBA_SetCallBackHandler( NAND_LBA_CALLBACK_HANDLER pCallBac
 	return (NAND_IO_ERROR)SUCCESS;
 }
 
-NAND_IO_ERROR NAND_IO_LBA_GetDeviceInfo( NAND_IO_DEVINFO *nDevInfo )
+NAND_IO_ERROR NAND_IO_LBA_GetDeviceInfo( U16 nChipNo, NAND_IO_DEVINFO *nDevInfo )
 {
 	unsigned short int		j,k,l;
 	unsigned char			bFindMedia;
@@ -10767,7 +12309,7 @@ NAND_IO_ERROR NAND_IO_LBA_GetDeviceInfo( NAND_IO_DEVINFO *nDevInfo )
 		return ERR_NAND_IO_FAILED_GET_DEVICE_INFO;
 }
 
-NAND_IO_ERROR NAND_IO_LBA_Init( NAND_IO_DEVINFO *nDevInfo )
+NAND_IO_ERROR NAND_IO_LBA_Init( U16 nChipNo, NAND_IO_DEVINFO *nDevInfo )
 {
 	unsigned short int		j,k,l;
 	unsigned char			bFindMedia;
@@ -10780,11 +12322,10 @@ NAND_IO_ERROR NAND_IO_LBA_Init( NAND_IO_DEVINFO *nDevInfo )
 	NAND_IO_ERROR			res;
 	
 	bFindMedia 				= FALSE;
-	sTempFeatureInfo		= (NAND_IO_FEATURE*)LBA_NAND_SupportMakerInfo.DevInfo[0];
-	sFindFeatureInfo		= (NAND_IO_FEATURE*)LBA_NAND_SupportMakerInfo.DevInfo[0];
 
+	nDevInfo->ChipNo = nChipNo;
 	NAND_IO_LBA_DeviceReboot( nDevInfo );
- 	NAND_IO_GetDeviceInfo( 0, nDevInfo );
+ 	NAND_IO_GetDeviceInfo( nChipNo, nDevInfo );
 
 	res = NAND_IO_LBA_ModeChange( nDevInfo, NAND_LBA_BCM );
 	if ( res != SUCCESS )
@@ -10808,7 +12349,18 @@ NAND_IO_ERROR NAND_IO_LBA_Init( NAND_IO_DEVINFO *nDevInfo )
 	}
 
 	NAND_IO_LBA_ModeChange( nDevInfo, NAND_LBA_MDP );
-	NAND_IO_LBA_SetTransferProtocol( nDevInfo, 0x04, 0x00 );
+	NAND_IO_LBA_SetTransferProtocol( nDevInfo, NAND_PROT1_512x1, 0x00 );
+	NAND_IO_LBA_GetTransferProtocol( nDevInfo, &nDevInfo->LBAInfo.TransProtocol1, &nDevInfo->LBAInfo.TransProtocol2 );
+
+	if ( nDevInfo->LBAInfo.TransProtocol1 & NAND_PROT1_SPARE_INCLUDE )
+		nDevInfo->LBAInfo.DataTransferCheck = ENABLE;
+	else
+		nDevInfo->LBAInfo.DataTransferCheck = DISABLE;
+
+	nDevInfo->LBAInfo.SectorCount = ( nDevInfo->LBAInfo.TransProtocol1 & NAND_PROT1_SECTOR_COUNT_MASK );
+
+	if ( nDevInfo->LBAInfo.SectorCount != 1 )
+		nDevInfo->LBAInfo.SectorCount = nDevInfo->LBAInfo.SectorCount << 1;
 	
 	nDevInfo->LBAInfo.Usable = DISABLE;
 	//=====================================================================
@@ -10865,7 +12417,10 @@ NAND_IO_ERROR NAND_IO_LBA_Init( NAND_IO_DEVINFO *nDevInfo )
 
 	if ( bFindMedia == TRUE )
 	{
-		// Get Protocol
+		// Get UniqueID
+		//NAND_IO_LBA_ReadUID( nDevInfo );
+        
+		NAND_IO_LBA_SetTransferProtocol( nDevInfo, NAND_PROT1_512x8, ( NAND_PROT2_WRITE_TYPE_B | NAND_PROT2_READ_TYPE_A ) );
 		NAND_IO_LBA_GetTransferProtocol( nDevInfo, &nDevInfo->LBAInfo.TransProtocol1, &nDevInfo->LBAInfo.TransProtocol2 );
 
 		// Data Format
@@ -10880,13 +12435,7 @@ NAND_IO_ERROR NAND_IO_LBA_Init( NAND_IO_DEVINFO *nDevInfo )
 		if ( nDevInfo->LBAInfo.SectorCount != 1 )
 			nDevInfo->LBAInfo.SectorCount = nDevInfo->LBAInfo.SectorCount << 1;
 		
-		// Set Power Save Mode
-		NAND_IO_LBA_PowerSaveMode( nDevInfo, DISABLE );
-
-		// Set High Speed Mode
-		NAND_IO_LBA_HighSpeedMode( nDevInfo, ENABLE );
-
-		NAND_IO_LBA_VFPGetTotalSectorSize( nDevInfo, (U32 *)&nDevInfo->LBAInfo.VFPSectorSize );
+		NAND_IO_LBA_VFPGetTotalSectorSize( nDevInfo, &nDevInfo->LBAInfo.VFPSectorSize );
 		if ( ( nDevInfo->LBAInfo.VFPSectorSize << 9 ) < gMAX_ROMSIZE )
 		{
 			// LBA Factory Setting values : 8 Mbyte
@@ -10905,6 +12454,9 @@ NAND_IO_ERROR NAND_IO_LBA_Init( NAND_IO_DEVINFO *nDevInfo )
 			return res;
 
 		nDevInfo->LBAInfo.Usable = ENABLE;		
+		
+		NAND_IO_LBA_SetAreaPartition( nDevInfo, sFindFeatureInfo );
+		NAND_IO_LBA_PowerSaveMode( nDevInfo, ENABLE );
 	}
 	//=====================================================================
 	// Not Found
@@ -10917,51 +12469,114 @@ NAND_IO_ERROR NAND_IO_LBA_Init( NAND_IO_DEVINFO *nDevInfo )
 	return (NAND_IO_ERROR)SUCCESS;
 }
 
+NAND_IO_ERROR NAND_IO_LBA_InitDrive( NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned int 		i;
+
+	gLBACSNums = 0;
+
+	for( i  = NAND_IO_DRV0_START_CS; i < NAND_IO_DRV0_END_CS + 1; ++i )
+	{
+		if ( NAND_IO_LBA_Init( i, &nDevInfo[i] ) == SUCCESS )
+		{
+			++gLBACSNums;
+			NAND_IO_LBA_PowerSaveMode( &nDevInfo[i], DISABLE );
+			NAND_IO_LBA_HighSpeedMode( &nDevInfo[i], ENABLE );
+		}
+        else
+		{
+			if ( i == 0 )
+				return ERR_LBA_NOT_EXIST_NANDFLASH;
+		}
+	}	
+	
+	if ( gLBACSNums > LBA_MAX_SUPPORT_MULTI_NANDFLASH )
+		return ERR_LBA_NOT_EXIST_MEDIA_NUM_INFO;
+	
+	return SUCCESS;
+}
+
 U32 NAND_IO_LBA_GetSerialNumber( NAND_IO_DEVINFO *nDevInfo, U8* nPageBuffer, U8* rSerialNumber, U16 nSize )
 {
-	unsigned int		j;
-	unsigned int		dwIDSize;
-	unsigned char		ucTempData[64];
+	unsigned int		i;
+	unsigned short int	wSizeOfSID;
+	unsigned char		ucPage[512];
 	unsigned char		*cPageBuffer;
 	unsigned char		*cSpareBuffer;
+	
 	NAND_IO_ERROR		res;
 
 	cPageBuffer		= &nPageBuffer[0];
 	cSpareBuffer	= &nPageBuffer[nDevInfo->Feature.PageSize];
-	nSize = 0;
 
-	NAND_IO_LBA_ModeChange( nDevInfo, NAND_LBA_BCM );
+	res = NAND_IO_LBA_ModeChange( &nDevInfo[0], NAND_LBA_BCM );	
+	if ( res != SUCCESS )
+	{
+		NAND_IO_LBA_DeviceReboot( nDevInfo );
+		res = NAND_IO_LBA_ModeChange( nDevInfo, NAND_LBA_BCM );
+		if ( res != SUCCESS )
+			return res;
+	}
 
-	res = NAND_IO_ReadGoldenPage( nDevInfo, 0, cPageBuffer, cSpareBuffer );
+	res = NAND_IO_ReadPage( nDevInfo, 0, 0, 4, cPageBuffer, cSpareBuffer, ECC_OFF );
 	if ( res != SUCCESS)
 		return ERR_NAND_IO_WRONG_PARAMETER;
 	
-	memcpy( ucTempData, &nPageBuffer[ ( 512 + 16 ) * ( nDevInfo->PPages - 1 ) ], 64 );
+	if (  nDevInfo[0].Feature.MediaType & A_PARALLEL )
+		memcpy( ucPage, &cPageBuffer[ ( 512 + 16 ) * ( nDevInfo[0].PPages - 2 ) ], 512 );
+	else
+		memcpy( ucPage, &cPageBuffer[ ( 512 + 16 ) * ( nDevInfo[0].PPages - 1 ) ], 512 );
 
-	dwIDSize = 32;
+	//=====================================================
+	// Check and Get Serial Number ID
+	//=====================================================
+	/* Get Signature to get sizes of serial number ID */
+	if (!memcmp( &ucPage[20], "ZERO", 4 ))
+		wSizeOfSID		= 16;
+	else if ((!memcmp( &ucPage[20], "FWDN", 4 )) || (!memcmp( &ucPage[20], "GANG", 4 )))
+		wSizeOfSID		= 32;
+	else
+		wSizeOfSID		= 0;
 	
-	for ( j = 0; j < dwIDSize; ++j )
-		rSerialNumber[j] = ucTempData[j];
+	for ( i = 0; i < ( wSizeOfSID >> 4 ); ++i )
+		memcpy( &rSerialNumber[i*16], &ucPage[i*32], 16 );
 
-	return dwIDSize;	
+	return wSizeOfSID;		
 }
 
 NAND_IO_ERROR NAND_IO_LBA_GetTotalSecAndCHS( NAND_IO_DEVINFO *nDevInfo, int nPartition, U32 *rTotalSec, U16 *rCylinder, U16 *rHead, U8 *rSector )
 {
-	unsigned long int		nTotalSectorSize;
+	unsigned short int		i;
 	unsigned short int		wCurrHead;
 	unsigned short int		wCurrCylinder;
+	unsigned long int		nTotalSectorSize;
+
+	nTotalSectorSize = 0;
 
 	if ( nPartition == NAND_LBA_DATA_AREA )
-		nTotalSectorSize = nDevInfo->LBAInfo.DTAreaSectorSize;
+	{
+		for ( i = 0; i < gLBACSNums; ++i )
+			nTotalSectorSize += nDevInfo[i].LBAInfo.DTAreaSectorSize;
+	}
 	else if ( nPartition == NAND_LBA_HIDDEN_AREA )
-		nTotalSectorSize = nDevInfo->LBAInfo.HDAreaSectorSize;
+	{
+		for ( i = 0; i < gLBACSNums; ++i )
+			nTotalSectorSize += nDevInfo[i].LBAInfo.HDAreaSectorSize;
+	}
+	else if ( nPartition == NAND_LBA_MULTI_HIDDEN_AREA_0 )
+	{
+		nTotalSectorSize = nDevInfo[0].LBAInfo.MHDAreaSectorSize[0];
+	}
 	else if ( nPartition == NAND_LBA_MDP )
-		nTotalSectorSize = nDevInfo->LBAInfo.MDPSectorSize;
+	{
+		for ( i = 0; i < gLBACSNums; ++i )
+			nTotalSectorSize += nDevInfo[i].LBAInfo.MDPSectorSize;
+	}
 	else if ( nPartition == NAND_LBA_VFP )
-		nTotalSectorSize = nDevInfo->LBAInfo.VFPSectorSize;
-	else
-		nTotalSectorSize = 0;
+	{
+		for ( i = 0; i < gLBACSNums; ++i )
+			nTotalSectorSize += nDevInfo[i].LBAInfo.VFPSectorSize;
+	}
 
 	if ( nTotalSectorSize == 0 )
 	{
@@ -11003,12 +12618,11 @@ NAND_IO_ERROR NAND_IO_LBA_GetTotalSecAndCHS( NAND_IO_DEVINFO *nDevInfo, int nPar
 
 NAND_IO_ERROR NAND_IO_LBA_ReadSectorBy4Byte( NAND_IO_DEVINFO *nDevInfo, U8 nPartition, U32 nSectorAddr, U16 nOffset, U16 nReadSize, U8 *nReadBuffer )
 {
-	unsigned short int		wCurrPPSize;
+	unsigned short int		wCSorder;
+	unsigned short int		wCurrPPSize, rConvertSize;
 	unsigned short int		wFlagFirstSector;
-	unsigned long int 		dwSectorAddr;
+	unsigned long int 		dwSectorAddr, rConvertAddr;
 	unsigned long int		dwTotalReadSecSize;
-	unsigned long int		nTotalSectorSize;
-	unsigned long int		dwSectorAddrOffSet;
 	unsigned char			cReadBuffer[512];
 	unsigned char			cSpareBuffer[16];
 	unsigned char			*pReadBuffer;
@@ -11016,53 +12630,28 @@ NAND_IO_ERROR NAND_IO_LBA_ReadSectorBy4Byte( NAND_IO_DEVINFO *nDevInfo, U8 nPart
 	NAND_IO_ERROR			res;
 
 	//######################################################
-	//# Check Parameter
+	//# Get Info of Parameter
 	//######################################################
-	if ( nDevInfo->LBAInfo.Usable != ENABLE )
-		return ERR_NAND_IO_WRONG_PARAMETER;
+	dwSectorAddr		= nSectorAddr;
+	dwTotalReadSecSize  = 1;
+
+	res = NAND_IO_LBA_ConvertMPPA( nDevInfo, nPartition, dwSectorAddr, dwTotalReadSecSize, &rConvertAddr, &rConvertSize, &wCSorder );
+	if ( res != SUCCESS )
+			return res;
 
 	cPartition = nPartition & 0x0F;
 
-	if ( nDevInfo->LBAInfo.CurrentMode != cPartition )
-		NAND_IO_LBA_ModeChange( nDevInfo, cPartition );
-	
-	if ( nPartition == NAND_LBA_DATA_AREA )
-	{
-		nTotalSectorSize 	= nDevInfo->LBAInfo.DTAreaSectorSize;
-		dwSectorAddrOffSet 	= 0;		
-	}
-	else if ( nPartition == NAND_LBA_HIDDEN_AREA )
-	{
-		nTotalSectorSize = nDevInfo->LBAInfo.HDAreaSectorSize;
-		dwSectorAddrOffSet 	= nDevInfo->LBAInfo.HDAreaAddrOffSet;
-	}
-	else if ( nPartition == NAND_LBA_MULTI_HIDDEN_AREA_0 )
-	{
-		nTotalSectorSize 	= nDevInfo->LBAInfo.MHDAreaSectorSize[0];
-		dwSectorAddrOffSet 	= nDevInfo->LBAInfo.MHDAreaAddrOffSet[0];
-	}	
-	else if ( nPartition == NAND_LBA_MDP )
-	{
-		nTotalSectorSize = nDevInfo->LBAInfo.MDPSectorSize;
-		dwSectorAddrOffSet 	= 0;
-	}
-	else if ( nPartition == NAND_LBA_VFP )
-	{
-		nTotalSectorSize = nDevInfo->LBAInfo.VFPSectorSize;
-		dwSectorAddrOffSet 	= 1;
-	}
-	else
-	{
-		nTotalSectorSize = 0;
-		dwSectorAddrOffSet 	= 0;
-		return ERR_NAND_IO_WRONG_PARAMETER;
-	}
+	if ( nDevInfo[wCSorder].LBAInfo.CurrentMode != cPartition )
+		NAND_IO_LBA_ModeChange( &nDevInfo[wCSorder], cPartition );
 	
-	if ( ( nSectorAddr + 1 ) > nTotalSectorSize )
-		return ERR_NAND_IO_WRONG_PARAMETER;
-
 	if (( !nReadSize ) || (( nOffset + nReadSize ) > 128 ))
 		return ERR_NAND_IO_WRONG_PARAMETER;
+	
+	//######################################################
+	//# Set High Speed Mode 
+	//######################################################
+	NAND_IO_LBA_PowerSaveMode( &nDevInfo[wCSorder], DISABLE );
+	NAND_IO_LBA_HighSpeedMode( &nDevInfo[wCSorder], ENABLE );
 
 	pReadBuffer			= nReadBuffer;
 
@@ -11075,148 +12664,116 @@ NAND_IO_ERROR NAND_IO_LBA_ReadSectorBy4Byte( NAND_IO_DEVINFO *nDevInfo, U8 nPart
 	NAND_IO_SetCommCycleTime();
 
 	/* Enable Chip Select */
-	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
-
-	//NAND_IO_DisableWriteProtect();
+	NAND_IO_EnableChipSelect( nDevInfo[wCSorder].ChipNo );
 
 	/* Set Data Bus as 16Bit */
-	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+	if ( nDevInfo[wCSorder].Feature.MediaType & A_PARALLEL )
 		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
 	else
 		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
 
-	//######################################################
-	//# Get Info of Parameter
-	//######################################################
-	dwSectorAddr		= nSectorAddr;
-	dwSectorAddr		+= dwSectorAddrOffSet;	
-	dwTotalReadSecSize  = 1;
-
-	if ( dwTotalReadSecSize < nDevInfo->LBAInfo.SectorCount )
-		wCurrPPSize = (U16)dwTotalReadSecSize;
+	if ( dwTotalReadSecSize < nDevInfo[wCSorder].LBAInfo.SectorCount )
+		wCurrPPSize = dwTotalReadSecSize;
 	else
-		wCurrPPSize = nDevInfo->LBAInfo.SectorCount ;
+		wCurrPPSize = nDevInfo[wCSorder].LBAInfo.SectorCount;
 	
 	//######################################################
 	//# Write Total Sector
 	//######################################################
-
-	while ( dwTotalReadSecSize )
-	{	
-		/* Command Page Program #1 [ 0x80 ] */
-		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+	pNFC->NFC_CMD = nDevInfo[wCSorder].CmdMask & 0x0000;
 
 		if ( wFlagFirstSector == TRUE )
 		{
 			/* Write Sector Size & Sector Address */
-			pNFC->NFC_SADDR= ( 1 & 0xFF );					// Write Sector Num : SC0
-			pNFC->NFC_SADDR= ( ( 1 >> 8 ) & 0xFF );			// Write Sector Num : SC1
-			pNFC->NFC_SADDR= ( dwSectorAddr & 0xFF );				// Write Sector Addr: AD0
-			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 8 ) & 0xFF );		// Write Sector Addr: AD1
-			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 16 ) & 0xFF );		// Write Sector Addr: AD2
+		pNFC->NFC_SADDR= ( (	wCurrPPSize		   ) & 0xFF );	// Write Sector Num : SC0
+		pNFC->NFC_SADDR= ( ( wCurrPPSize  >> 8  ) & 0xFF );	// Write Sector Num : SC1
+		pNFC->NFC_SADDR= ( ( rConvertAddr 	   ) & 0xFF );	// Write Sector Addr: AD0
+		pNFC->NFC_SADDR= ( ( rConvertAddr >> 8  ) & 0xFF );	// Write Sector Addr: AD1
+		pNFC->NFC_SADDR= ( ( rConvertAddr >> 16 ) & 0xFF );	// Write Sector Addr: AD2
+		pNFC->NFC_SADDR= ( ( rConvertAddr >> 24 ) & 0xFF );	// Write Sector Addr: AD3
 		}
 
 		/* Command Page Program #2 [ 0x10 ] */
-		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
-		
+		pNFC->NFC_CMD = nDevInfo[wCSorder].CmdMask & 0x3030;
 		/* Wait until it is ready */
-		NAND_IO_WaitBusy( nDevInfo->ChipNo );
+		NAND_IO_WaitBusy( nDevInfo[wCSorder].ChipNo );
 
 		NAND_IO_SetReadCycleTime();
 		/* Write Data to NAND FLASH */
-		res = NAND_IO_LBA_ReadData( nDevInfo, wCurrPPSize, cReadBuffer, cSpareBuffer );
+	res = NAND_IO_LBA_ReadData( &nDevInfo[wCSorder], wCurrPPSize, cReadBuffer, cSpareBuffer );
 		if ( res != SUCCESS )
 			return res;
 
 		NAND_IO_SetCommCycleTime();
 
-		/* Decrease Write Size */
-		dwTotalReadSecSize 	-= wCurrPPSize;
-
-		/* Increase Buffer Address */
-		nReadBuffer			+= ( nDevInfo->LBAInfo.SectorCount << 9 );
-		
-		/* Count Next Page Size */
-		if ( dwTotalReadSecSize < nDevInfo->LBAInfo.SectorCount )
-			wCurrPPSize = (U16)dwTotalReadSecSize;
-		else
-			wCurrPPSize = nDevInfo->LBAInfo.SectorCount;
-
-		if ( nDevInfo->LBAInfo.TransProtocol2 & NAND_PROT2_WRITE_TYPE_B )
-			wFlagFirstSector = FALSE;
-	}
-
 	memcpy( pReadBuffer, &cReadBuffer[nOffset << 2], nReadSize << 2 );
 
-	/* FORCE TO SET WP LOW */
-	//NAND_IO_EnableWriteProtect();
-	
 	/* Disable Chip Select */
 	NAND_IO_DisableChipSelect();
 
 	/* Post Process */
 	NAND_IO_PostProcess();
 	
+	//######################################################
+	//# Set Power Save Mode 
+	//######################################################
+	NAND_IO_LBA_PowerSaveMode( &nDevInfo[wCSorder], ENABLE );
+	
 	return (NAND_IO_ERROR)SUCCESS;
 }
 
 NAND_IO_ERROR NAND_IO_LBA_ReadSector( NAND_IO_DEVINFO *nDevInfo, U8 nPartition, U32 nSectorAddr, U16 nSecSize, U8 *nReadBuffer )
 {
-	unsigned short int		wCurrPPSize;
+	unsigned short int		wCSorder;
+	unsigned short int		wCurrPPSize, rConvertSize;
 	unsigned short int		wFlagFirstSector;
-	unsigned long int 		dwSectorAddr;
-	unsigned long int		dwSectorAddrOffSet;
+	unsigned long int 		dwSectorAddr, rConvertAddr;
 	unsigned long int		dwTotalReadSecSize;
-	unsigned long int		nTotalSectorSize;
 	unsigned char			cPartition;
 	unsigned char			cSpareBuffer[16];
 	NAND_IO_ERROR			res;
 
 	//######################################################
+	//# Get Info of Parameter
+	//######################################################
+	dwSectorAddr		= nSectorAddr;
+	dwTotalReadSecSize  = nSecSize;
+
+	while ( dwTotalReadSecSize )
+	{	
+		res = NAND_IO_LBA_ConvertMPPA( nDevInfo, nPartition, dwSectorAddr, dwTotalReadSecSize, &rConvertAddr, &rConvertSize, &wCSorder );
+		if ( res != SUCCESS )
+			return res;
+		
+		rConvertSize = dwTotalReadSecSize;	// nemo
+		
+		//######################################################
 	//# Check Parameter
 	//######################################################
-	if ( nDevInfo->LBAInfo.Usable != ENABLE )
+		if ( nDevInfo[wCSorder].LBAInfo.Usable != ENABLE )
 		return ERR_NAND_IO_WRONG_PARAMETER;
 
 	cPartition = nPartition & 0x0F;
 
-	if ( nDevInfo->LBAInfo.CurrentMode != cPartition )
-		NAND_IO_LBA_ModeChange( nDevInfo, cPartition );
-	
-	if ( nPartition == NAND_LBA_DATA_AREA )
-	{
-		nTotalSectorSize 	= nDevInfo->LBAInfo.DTAreaSectorSize;
-		dwSectorAddrOffSet 	= 0;		
-	}
-	else if ( nPartition == NAND_LBA_HIDDEN_AREA )
-	{
-		nTotalSectorSize = nDevInfo->LBAInfo.HDAreaSectorSize;
-		dwSectorAddrOffSet 	= nDevInfo->LBAInfo.HDAreaAddrOffSet;
-	}
-	else if ( nPartition == NAND_LBA_MULTI_HIDDEN_AREA_0 )
+		if ( nDevInfo[wCSorder].LBAInfo.CurrentMode != cPartition )
 	{
-		nTotalSectorSize 	= nDevInfo->LBAInfo.MHDAreaSectorSize[0];
-		dwSectorAddrOffSet 	= nDevInfo->LBAInfo.MHDAreaAddrOffSet[0];
-	}	
-	else if ( nPartition == NAND_LBA_MDP )
+			res = NAND_IO_LBA_ModeChange( &nDevInfo[wCSorder], cPartition );
+			if ( res != SUCCESS )
 	{
-		nTotalSectorSize = nDevInfo->LBAInfo.MDPSectorSize;
-		dwSectorAddrOffSet 	= 0;
+				NAND_IO_LBA_DeviceReboot( &nDevInfo[wCSorder]);
+				NAND_IO_LBA_ModeChange( nDevInfo, NAND_LBA_MDP );
+				NAND_IO_LBA_SetTransferProtocol( &nDevInfo[wCSorder], NAND_PROT1_512x8, ( NAND_PROT2_WRITE_TYPE_B | NAND_PROT2_READ_TYPE_A ) );				
+				res = NAND_IO_LBA_ModeChange( &nDevInfo[wCSorder], cPartition );
+				if ( res != SUCCESS )
+					return res;
 	}
-	else if ( nPartition == NAND_LBA_VFP )
-	{
-		nTotalSectorSize = nDevInfo->LBAInfo.VFPSectorSize;
-		dwSectorAddrOffSet 	= 1;
-	}
-	else
-	{
-		nTotalSectorSize = 0;
-		dwSectorAddrOffSet 	= 0;
-		return ERR_NAND_IO_WRONG_PARAMETER;
 	}
 	
-	if ( ( nSectorAddr + nSecSize ) > nTotalSectorSize )
-		return ERR_NAND_IO_WRONG_PARAMETER;
+		//######################################################
+		//# Set High Speed Mode 
+		//######################################################		
+		//NAND_IO_LBA_PowerSaveMode( &nDevInfo[wCSorder], DISABLE );
+		//NAND_IO_LBA_HighSpeedMode( &nDevInfo[wCSorder], ENABLE );
 
 	wFlagFirstSector = TRUE;
 	
@@ -11227,82 +12784,74 @@ NAND_IO_ERROR NAND_IO_LBA_ReadSector( NAND_IO_DEVINFO *nDevInfo, U8 nPartition,
 	NAND_IO_SetCommCycleTime();
 
 	/* Enable Chip Select */
-	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
-
-	//NAND_IO_DisableWriteProtect();
+		NAND_IO_EnableChipSelect( nDevInfo[wCSorder].ChipNo );
 
 	/* Set Data Bus as 16Bit */
-	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		if ( nDevInfo[wCSorder].Feature.MediaType & A_PARALLEL )
 		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
 	else
 		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
 
-	//######################################################
-	//# Get Info of Parameter
-	//######################################################
-	dwSectorAddr		= nSectorAddr;
-	dwSectorAddr		+= dwSectorAddrOffSet;
-	dwTotalReadSecSize  = nSecSize;
+		if ( rConvertSize < nDevInfo[wCSorder].LBAInfo.SectorCount )
+			wCurrPPSize = rConvertSize;
+		else
+			wCurrPPSize = nDevInfo[wCSorder].LBAInfo.SectorCount;
 
-	if ( dwTotalReadSecSize < nDevInfo->LBAInfo.SectorCount )
-		wCurrPPSize = (U16)dwTotalReadSecSize;
-	else
-		wCurrPPSize = nDevInfo->LBAInfo.SectorCount ;
+		/* Decrease Write Size */
+		dwSectorAddr		+= rConvertSize;
+		dwTotalReadSecSize  -= rConvertSize;
 	
 	//######################################################
 	//# Write Total Sector
 	//######################################################
-
-	while ( dwTotalReadSecSize )
+		while ( rConvertSize )
 	{	
 		/* Command Page Program #1 [ 0x80 ] */
-		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+			pNFC->NFC_CMD = nDevInfo[wCSorder].CmdMask & 0x0000;
 
 		if ( wFlagFirstSector == TRUE )
 		{
 			/* Write Sector Size & Sector Address */
-			pNFC->NFC_SADDR= ( nSecSize & 0xFF );					// Write Sector Num : SC0
-			pNFC->NFC_SADDR= ( ( nSecSize >> 8 ) & 0xFF );			// Write Sector Num : SC1
-			pNFC->NFC_SADDR= ( dwSectorAddr & 0xFF );				// Write Sector Addr: AD0
-			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 8 ) & 0xFF );		// Write Sector Addr: AD1
-			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 16 ) & 0xFF );		// Write Sector Addr: AD2
+				pNFC->NFC_SADDR= ( ( rConvertSize 	    ) & 0xFF );		// Write Sector Num : SC0
+				pNFC->NFC_SADDR= ( ( rConvertSize >> 8   ) & 0xFF );		// Write Sector Num : SC1
+				pNFC->NFC_SADDR= ( ( rConvertAddr 		) & 0xFF );		// Write Sector Addr: AD0
+				pNFC->NFC_SADDR= ( ( rConvertAddr >> 8 	) & 0xFF );		// Write Sector Addr: AD1
+				pNFC->NFC_SADDR= ( ( rConvertAddr >> 16 	) & 0xFF );		// Write Sector Addr: AD2
+				pNFC->NFC_SADDR= ( ( rConvertAddr >> 24 	) & 0xFF );		// Write Sector Addr: AD3
+
+				if ( nDevInfo[wCSorder].LBAInfo.TransProtocol2 & NAND_PROT2_READ_TYPE_B )				
+					wFlagFirstSector = FALSE;
 		}
 
 		/* Command Page Program #2 [ 0x10 ] */
-		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+			pNFC->NFC_CMD = nDevInfo[wCSorder].CmdMask & 0x3030;
 		
 		/* Wait until it is ready */
-		NAND_IO_WaitBusy( nDevInfo->ChipNo );
+			NAND_IO_LBA_WaitBusy( nDevInfo[wCSorder].ChipNo );
 
 		NAND_IO_SetReadCycleTime();
 		/* Write Data to NAND FLASH */
-		res = NAND_IO_LBA_ReadData( nDevInfo, wCurrPPSize, nReadBuffer, cSpareBuffer );
+			res = NAND_IO_LBA_ReadData( &nDevInfo[wCSorder], wCurrPPSize, nReadBuffer, cSpareBuffer );
 		if ( res != SUCCESS )
 			return res;
 
 		NAND_IO_SetCommCycleTime();
 
-		/* Decrease Write Size */
-		dwTotalReadSecSize 	-= wCurrPPSize;
+			rConvertAddr		+= wCurrPPSize;
+			rConvertSize		-= wCurrPPSize;
 
 		/* Increase Buffer Address */
-		nReadBuffer			+= ( nDevInfo->LBAInfo.SectorCount << 9 );
+			nReadBuffer			+= ( wCurrPPSize << 9 );
 		
 		/* Count Next Page Size */
-		if ( dwTotalReadSecSize < nDevInfo->LBAInfo.SectorCount )
-			wCurrPPSize = (U16)dwTotalReadSecSize;
+			if ( rConvertSize < nDevInfo[wCSorder].LBAInfo.SectorCount )
+				wCurrPPSize = rConvertSize;
 		else
-			wCurrPPSize = nDevInfo->LBAInfo.SectorCount;
-
-		if ( nDevInfo->LBAInfo.TransProtocol2 & NAND_PROT2_WRITE_TYPE_B )
-			wFlagFirstSector = FALSE;
+				wCurrPPSize = nDevInfo[wCSorder].LBAInfo.SectorCount;
 	}
 
-	pNFC->NFC_CMD = nDevInfo->CmdMask & 0xFBFB;
-	NAND_IO_WaitBusy( nDevInfo->ChipNo );
-
-	/* FORCE TO SET WP LOW */
-	//NAND_IO_EnableWriteProtect();
+		pNFC->NFC_CMD = nDevInfo[wCSorder].CmdMask & 0xFBFB;
+		NAND_IO_WaitBusy( nDevInfo[wCSorder].ChipNo );
 
 	/* Disable Chip Select */
 	NAND_IO_DisableChipSelect();
@@ -11310,11 +12859,19 @@ NAND_IO_ERROR NAND_IO_LBA_ReadSector( NAND_IO_DEVINFO *nDevInfo, U8 nPartition,
 	/* Post Process */
 	NAND_IO_PostProcess();
 
-	return (NAND_IO_ERROR)SUCCESS;
+		//######################################################
+		//# Set Power Save Mode 
+		//######################################################
+		//NAND_IO_LBA_PowerSaveMode( &nDevInfo[wCSorder], ENABLE );
+	}
+	
+	return SUCCESS;
 }
 
+	
 NAND_IO_ERROR NAND_IO_LBA_AREAClear( NAND_IO_DEVINFO *nDevInfo, U8 nPartition )
 {
+	unsigned short int 		i;
 	unsigned int			nSectorAddr;
 	unsigned short int		wCurrPPSize;
 	unsigned short int		wFlagFirstSector;
@@ -11332,47 +12889,51 @@ NAND_IO_ERROR NAND_IO_LBA_AREAClear( NAND_IO_DEVINFO *nDevInfo, U8 nPartition )
 	unsigned char			cPartition;
 	NAND_IO_ERROR			res;
 
+	for ( i = 0; i < gLBACSNums; ++i )
+	{
+		NAND_IO_LBA_Init( i, &nDevInfo[i] );
+		
 	//######################################################
 	//# Check Parameter
 	//######################################################
-	if ( nDevInfo->LBAInfo.Usable != ENABLE )
+		if ( nDevInfo[i].LBAInfo.Usable != ENABLE )
 		return ERR_NAND_IO_WRONG_PARAMETER;
 
 	cPartition = nPartition & 0x0F;
 
-	if ( nDevInfo->LBAInfo.CurrentMode != cPartition )
-		NAND_IO_LBA_ModeChange( nDevInfo, cPartition );
+		if ( nDevInfo[i].LBAInfo.CurrentMode != cPartition )
+			NAND_IO_LBA_ModeChange( &nDevInfo[i], cPartition );
+
+		//######################################################
+		//# Set High Speed Mode 
+		//######################################################
+		NAND_IO_LBA_PowerSaveMode( &nDevInfo[i], DISABLE );
+		NAND_IO_LBA_HighSpeedMode( &nDevInfo[i], ENABLE );
 
 	if ( nPartition == NAND_LBA_DATA_AREA )
 	{
-		nTotalSectorSize 	= nDevInfo->LBAInfo.DTAreaSectorSize;
-		dwSectorAddrOffSet 	= 0;
+			nTotalSectorSize 	= nDevInfo[i].LBAInfo.DTAreaSectorSize;
+			dwSectorAddrOffSet 	= nDevInfo[i].LBAInfo.DTAreaAddrOffSet;
 	}
 	else if ( nPartition == NAND_LBA_HIDDEN_AREA )
 	{
-		nTotalSectorSize 	= nDevInfo->LBAInfo.HDAreaSectorSize;
-		dwSectorAddrOffSet 	= nDevInfo->LBAInfo.HDAreaAddrOffSet;
+			nTotalSectorSize 	= nDevInfo[i].LBAInfo.HDAreaSectorSize;
+			dwSectorAddrOffSet 	= nDevInfo[i].LBAInfo.HDAreaAddrOffSet;
 	}
 	else if ( nPartition == NAND_LBA_MULTI_HIDDEN_AREA_0 )
 	{
-		nTotalSectorSize 	= nDevInfo->LBAInfo.MHDAreaSectorSize[0];
-		dwSectorAddrOffSet 	= nDevInfo->LBAInfo.MHDAreaAddrOffSet[0];
+			nTotalSectorSize 	= nDevInfo[i].LBAInfo.MHDAreaSectorSize[0];
+			dwSectorAddrOffSet 	= nDevInfo[i].LBAInfo.MHDAreaAddrOffSet[0];
 	}
 	else if ( nPartition == NAND_LBA_MDP )
 	{
-		nTotalSectorSize 	= nDevInfo->LBAInfo.MDPSectorSize;
+			nTotalSectorSize 	= nDevInfo[i].LBAInfo.MDPSectorSize;
 		dwSectorAddrOffSet 	= 0;
 	}
 	else if ( nPartition == NAND_LBA_VFP )
 	{
-		nTotalSectorSize 	= nDevInfo->LBAInfo.VFPSectorSize;
-		dwSectorAddrOffSet 	= 1;
-	}
-	else
-	{
-		nTotalSectorSize 	= 0;
-		dwSectorAddrOffSet 	= 0;
-		return ERR_NAND_IO_WRONG_PARAMETER;
+			nTotalSectorSize 	= nDevInfo[i].LBAInfo.VFPSectorSize;
+			dwSectorAddrOffSet 	= NAND_LBA_SYS_SECTION;
 	}
 
 	// Set Area Clear Sector Address, Size
@@ -11387,12 +12948,12 @@ NAND_IO_ERROR NAND_IO_LBA_AREAClear( NAND_IO_DEVINFO *nDevInfo, U8 nPartition )
 	NAND_IO_SetCommCycleTime();
 
 	/* Enable Chip Select */
-	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+		NAND_IO_EnableChipSelect( nDevInfo[i].ChipNo );
 
 	//NAND_IO_DisableWriteProtect();
 
 	/* Set Data Bus as 16Bit */
-	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+	if ( nDevInfo[i].Feature.MediaType & A_DATA_WITDH_16BIT )
 		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
 	else
 		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
@@ -11404,10 +12965,10 @@ NAND_IO_ERROR NAND_IO_LBA_AREAClear( NAND_IO_DEVINFO *nDevInfo, U8 nPartition )
 	dwSectorAddr 		+= dwSectorAddrOffSet;
 	dwTotalWriteSecSize = nTotalSectorSize;
 
-	if ( dwTotalWriteSecSize < nDevInfo->LBAInfo.SectorCount )
+	if ( dwTotalWriteSecSize < nDevInfo[i].LBAInfo.SectorCount )
 		wCurrPPSize = (U16)dwTotalWriteSecSize;
 	else
-		wCurrPPSize = nDevInfo->LBAInfo.SectorCount;
+		wCurrPPSize = nDevInfo[i].LBAInfo.SectorCount;
 	
 	//######################################################
 	//# Write Total Sector
@@ -11439,7 +13000,7 @@ NAND_IO_ERROR NAND_IO_LBA_AREAClear( NAND_IO_DEVINFO *nDevInfo, U8 nPartition )
 		}
 			
 		/* Command Page Program #1 [ 0x80 ] */
-		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8080;
+		pNFC->NFC_CMD = nDevInfo[i].CmdMask & 0x8080;
 
 		if ( wFlagFirstSector == TRUE )
 		{
@@ -11449,22 +13010,23 @@ NAND_IO_ERROR NAND_IO_LBA_AREAClear( NAND_IO_DEVINFO *nDevInfo, U8 nPartition )
 			pNFC->NFC_SADDR= ( dwSectorAddr & 0xFF );							// Write Sector Addr: AD0
 			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 8 ) & 0xFF );					// Write Sector Addr: AD1
 			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 16 ) & 0xFF );					// Write Sector Addr: AD2
+			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 24 ) & 0xFF );					// Write Sector Addr: AD2
 		}
 
 		NAND_IO_SetWriteCycleTime();
 		/* Write Data to NAND FLASH */
 		
-		res = NAND_IO_LBA_WriteDummyData( nDevInfo, wCurrPPSize );
+			res = NAND_IO_LBA_WriteDummyData( &nDevInfo[i], wCurrPPSize );
 		if ( res != SUCCESS )
 			return res;
 
 		NAND_IO_SetCommCycleTime();
 		
 		/* Command Page Program #2 [ 0x10 ] */
-		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+		pNFC->NFC_CMD = nDevInfo[i].CmdMask & 0x1010;
 
 		/* Wait until it is ready */
-		NAND_IO_WaitBusy( nDevInfo->ChipNo );
+		NAND_IO_WaitBusy( nDevInfo[i].ChipNo );
 
 		/* Decrease Write Size */
 		dwTotalWriteSecSize -= wCurrPPSize;
@@ -11475,12 +13037,12 @@ NAND_IO_ERROR NAND_IO_LBA_AREAClear( NAND_IO_DEVINFO *nDevInfo, U8 nPartition )
 		nWriteSectorSize	+= wCurrPPSize;
 		
 		/* Count Next Page Size */
-		if ( dwTotalWriteSecSize < nDevInfo->LBAInfo.SectorCount )
+		if ( dwTotalWriteSecSize < nDevInfo[i].LBAInfo.SectorCount )
 			wCurrPPSize = (U16)dwTotalWriteSecSize;
 		else
-			wCurrPPSize = nDevInfo->LBAInfo.SectorCount;
+			wCurrPPSize = nDevInfo[i].LBAInfo.SectorCount;
 
-		if ( nDevInfo->LBAInfo.TransProtocol2 & NAND_PROT2_WRITE_TYPE_B )
+		if ( nDevInfo[i].LBAInfo.TransProtocol2 & NAND_PROT2_WRITE_TYPE_B )
 			wFlagFirstSector = FALSE;
 
 		wProcessRate = (U16)(( ( nProCessWriteSectorSize + 1 ) * 100 ) / ( nTotalSectorSize + 1 ));
@@ -11503,11 +13065,8 @@ NAND_IO_ERROR NAND_IO_LBA_AREAClear( NAND_IO_DEVINFO *nDevInfo, U8 nPartition )
 		NAND_IO_LBA_CallBackLcdDisplay( 0, 0x05, 0 );
 	//--------------------------------------------------------------------------------------------------------
 	
-	pNFC->NFC_CMD = nDevInfo->CmdMask & 0xFBFB;
-	NAND_IO_WaitBusy( nDevInfo->ChipNo );
-
-	/* FORCE TO SET WP LOW */
-	//NAND_IO_EnableWriteProtect();
+	pNFC->NFC_CMD = nDevInfo[i].CmdMask & 0xFBFB;
+	NAND_IO_WaitBusy( nDevInfo[i].ChipNo );
 	
 	/* Disable Chip Select */
 	NAND_IO_DisableChipSelect();
@@ -11516,68 +13075,67 @@ NAND_IO_ERROR NAND_IO_LBA_AREAClear( NAND_IO_DEVINFO *nDevInfo, U8 nPartition )
 	NAND_IO_PostProcess();
 
 	/* Cache Flush */
-	NAND_IO_LBA_CacheFlush( nDevInfo );
+	NAND_IO_LBA_CacheFlush( &nDevInfo[i] );
+
+		//######################################################
+		//# Set Power Save Mode 
+		//######################################################
+	NAND_IO_LBA_PowerSaveMode( &nDevInfo[i], ENABLE );
+	}
 
 	return (NAND_IO_ERROR)SUCCESS;
 }
 
 NAND_IO_ERROR NAND_IO_LBA_WriteSector( NAND_IO_DEVINFO *nDevInfo, U8 nPartition, U32 nSectorAddr, U16 nSecSize, U8 *nWriteBuffer )
 {
+	unsigned short int		wCSorder;
 	unsigned short int		wCurrPPSize;
 	unsigned short int		wFlagFirstSector;
-	unsigned long int 		dwSectorAddr;
-	unsigned long int		dwSectorAddrOffSet;
-	unsigned long int		dwTotalWriteSecSize;
-	unsigned long int		nTotalSectorSize;
+	unsigned long int 		dwSectorAddr, rConvertAddr;
+	unsigned long int		dwTotalWriteSecSize, rConvertSize;
 	unsigned char			cPartition;
 	unsigned char			cSpareBuffer[16];
 	NAND_IO_ERROR			res;
 
 	//######################################################
+	//# Get Info of Parameter
+	//######################################################
+	dwSectorAddr		= nSectorAddr;
+	dwTotalWriteSecSize = nSecSize;
+		
+	while ( dwTotalWriteSecSize )
+	{
+		res = NAND_IO_LBA_ConvertMPPA( nDevInfo, nPartition, dwSectorAddr, dwTotalWriteSecSize, &rConvertAddr, &rConvertSize, &wCSorder );
+		if ( res != SUCCESS )
+			return res;
+
+		//######################################################
 	//# Check Parameter
 	//######################################################
-	if ( nDevInfo->LBAInfo.Usable != ENABLE )
+		if ( nDevInfo[wCSorder].LBAInfo.Usable != ENABLE )
 		return ERR_NAND_IO_WRONG_PARAMETER;
 
 	cPartition = nPartition & 0x0F;
 
-	if ( nDevInfo->LBAInfo.CurrentMode != cPartition )
-		NAND_IO_LBA_ModeChange( nDevInfo, cPartition );
-
-	if ( nPartition == NAND_LBA_DATA_AREA )
-	{
-		nTotalSectorSize 	= nDevInfo->LBAInfo.DTAreaSectorSize;
-		dwSectorAddrOffSet 	= 0;
-	}
-	else if ( nPartition == NAND_LBA_HIDDEN_AREA )
-	{
-		nTotalSectorSize 	= nDevInfo->LBAInfo.HDAreaSectorSize;
-		dwSectorAddrOffSet 	= nDevInfo->LBAInfo.HDAreaAddrOffSet;
-	}
-	else if ( nPartition == NAND_LBA_MULTI_HIDDEN_AREA_0 )
-	{
-		nTotalSectorSize 	= nDevInfo->LBAInfo.MHDAreaSectorSize[0];
-		dwSectorAddrOffSet 	= nDevInfo->LBAInfo.MHDAreaAddrOffSet[0];
-	}
-	else if ( nPartition == NAND_LBA_MDP )
+		if ( nDevInfo[wCSorder].LBAInfo.CurrentMode != cPartition )
 	{
-		nTotalSectorSize 	= nDevInfo->LBAInfo.MDPSectorSize;
-		dwSectorAddrOffSet 	= 0;
-	}
-	else if ( nPartition == NAND_LBA_VFP )
+			res = NAND_IO_LBA_ModeChange( &nDevInfo[wCSorder], cPartition );
+			if ( res != SUCCESS )
 	{
-		nTotalSectorSize 	= nDevInfo->LBAInfo.VFPSectorSize;
-		dwSectorAddrOffSet 	= 1;
+				NAND_IO_LBA_DeviceReboot( &nDevInfo[wCSorder]);
+				NAND_IO_LBA_ModeChange( nDevInfo, NAND_LBA_MDP );
+				NAND_IO_LBA_SetTransferProtocol( &nDevInfo[wCSorder], NAND_PROT1_512x8, ( NAND_PROT2_WRITE_TYPE_B | NAND_PROT2_READ_TYPE_A ) );
+				res = NAND_IO_LBA_ModeChange( &nDevInfo[wCSorder], cPartition );
+				if ( res != SUCCESS )
+					return res;
 	}
-	else
-	{
-		nTotalSectorSize 	= 0;
-		dwSectorAddrOffSet 	= 0;
-		return ERR_NAND_IO_WRONG_PARAMETER;
 	}
 
-	if ( ( nSectorAddr + nSecSize ) > nTotalSectorSize )
-		return ERR_NAND_IO_WRONG_PARAMETER;
+		//######################################################
+		//# Set High Speed Mode 
+		//######################################################
+		NAND_IO_LBA_PowerSaveMode( &nDevInfo[wCSorder], DISABLE );
+		NAND_IO_LBA_HighSpeedMode( &nDevInfo[wCSorder], ENABLE );
 
 	wFlagFirstSector = TRUE;
 	
@@ -11588,82 +13146,74 @@ NAND_IO_ERROR NAND_IO_LBA_WriteSector( NAND_IO_DEVINFO *nDevInfo, U8 nPartition,
 	NAND_IO_SetCommCycleTime();
 
 	/* Enable Chip Select */
-	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
-
-	//NAND_IO_DisableWriteProtect();
+		NAND_IO_EnableChipSelect( nDevInfo[wCSorder].ChipNo );
 
 	/* Set Data Bus as 16Bit */
-	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		if ( nDevInfo[wCSorder].Feature.MediaType & A_DATA_WITDH_16BIT )
 		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
 	else
 		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
 
-	//######################################################
-	//# Get Info of Parameter
-	//######################################################
-	dwSectorAddr		= nSectorAddr;
-	dwSectorAddr 		+= dwSectorAddrOffSet;
-	dwTotalWriteSecSize = nSecSize;
+		if ( rConvertSize < nDevInfo[wCSorder].LBAInfo.SectorCount )
+			wCurrPPSize = rConvertSize;
+		else
+			wCurrPPSize = nDevInfo[wCSorder].LBAInfo.SectorCount;
 
-	if ( dwTotalWriteSecSize < nDevInfo->LBAInfo.SectorCount )
-		wCurrPPSize = (U16)dwTotalWriteSecSize;
-	else
-		wCurrPPSize = nDevInfo->LBAInfo.SectorCount ;
+		/* Decrease Write Size */
+		dwSectorAddr		+= rConvertSize;
+		dwTotalWriteSecSize -= rConvertSize;
 	
 	//######################################################
 	//# Write Total Sector
 	//######################################################
-
-	while ( dwTotalWriteSecSize )
+		while ( rConvertSize )
 	{
 		/* Command Page Program #1 [ 0x80 ] */
-		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8080;
+			pNFC->NFC_CMD = nDevInfo[wCSorder].CmdMask & 0x8080;
 
 		if ( wFlagFirstSector == TRUE )
 		{
 			/* Write Sector Size & Sector Address */
-			pNFC->NFC_SADDR= ( nSecSize & 0xFF );					// Write Sector Num : SC0
-			pNFC->NFC_SADDR= ( ( nSecSize >> 8 ) & 0xFF );			// Write Sector Num : SC1
-			pNFC->NFC_SADDR= ( dwSectorAddr & 0xFF );				// Write Sector Addr: AD0
-			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 8 ) & 0xFF );		// Write Sector Addr: AD1
-			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 16 ) & 0xFF );		// Write Sector Addr: AD2
+			  pNFC->NFC_SADDR= ( rConvertSize & 0xFF );					// Write Sector Num : SC0
+			  pNFC->NFC_SADDR= ( ( rConvertSize >> 8 ) & 0xFF );			// Write Sector Num : SC1
+			  pNFC->NFC_SADDR= ( rConvertAddr & 0xFF );				// Write Sector Addr: AD0
+			  pNFC->NFC_SADDR= ( ( rConvertAddr >> 8 ) & 0xFF );		// Write Sector Addr: AD1
+			  pNFC->NFC_SADDR= ( ( rConvertAddr >> 16 ) & 0xFF );		// Write Sector Addr: AD2
+			  pNFC->NFC_SADDR= ( ( rConvertAddr >> 24 ) & 0xFF );		// Write Sector Addr: AD2
+  
+			  if ( nDevInfo[wCSorder].LBAInfo.TransProtocol2 & NAND_PROT2_WRITE_TYPE_B )
+				  wFlagFirstSector = FALSE;
 		}
 
 		NAND_IO_SetWriteCycleTime();
 		/* Write Data to NAND FLASH */
-		res = NAND_IO_LBA_WriteData( nDevInfo, wCurrPPSize, nWriteBuffer, cSpareBuffer );
+		  res = NAND_IO_LBA_WriteData( &nDevInfo[wCSorder], wCurrPPSize, nWriteBuffer, cSpareBuffer );
 		if ( res != SUCCESS )
 			return res;
 		
 		NAND_IO_SetCommCycleTime();
 		
 		/* Command Page Program #2 [ 0x10 ] */
-		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+		  pNFC->NFC_CMD = nDevInfo[wCSorder].CmdMask & 0x1010;
 
-		/* Decrease Write Size */
-		dwTotalWriteSecSize -= wCurrPPSize;
+		  rConvertAddr		+= wCurrPPSize;
+		  rConvertSize		-= wCurrPPSize;
 
 		/* Increase Buffer Address */
-		nWriteBuffer		+= ( nDevInfo->LBAInfo.SectorCount << 9 );
+		  nWriteBuffer		+= ( wCurrPPSize << 9 );
 		
 		/* Count Next Page Size */
-		if ( dwTotalWriteSecSize < nDevInfo->LBAInfo.SectorCount )
-			wCurrPPSize = (U16)dwTotalWriteSecSize;
+		    if ( rConvertSize < nDevInfo[wCSorder].LBAInfo.SectorCount )
+			    wCurrPPSize = rConvertSize;
 		else
-			wCurrPPSize = nDevInfo->LBAInfo.SectorCount;
-
-		if ( nDevInfo->LBAInfo.TransProtocol2 & NAND_PROT2_WRITE_TYPE_B )
-			wFlagFirstSector = FALSE;
+			    wCurrPPSize = nDevInfo[wCSorder].LBAInfo.SectorCount;
 
 		/* Wait until it is ready */
-		NAND_IO_WaitBusy( nDevInfo->ChipNo );
+		  NAND_IO_LBA_WaitBusy( nDevInfo[wCSorder].ChipNo );
 	}
 	
-	pNFC->NFC_CMD = nDevInfo->CmdMask & 0xFBFB;
-	NAND_IO_WaitBusy( nDevInfo->ChipNo );
-
-	/* FORCE TO SET WP LOW */
-	//NAND_IO_EnableWriteProtect();
+	  pNFC->NFC_CMD = nDevInfo[wCSorder].CmdMask & 0xFBFB;
+	  NAND_IO_WaitBusy( nDevInfo[wCSorder].ChipNo );
 	
 	/* Disable Chip Select */
 	NAND_IO_DisableChipSelect();
@@ -11671,9 +13221,11 @@ NAND_IO_ERROR NAND_IO_LBA_WriteSector( NAND_IO_DEVINFO *nDevInfo, U8 nPartition,
 	/* Post Process */
 	NAND_IO_PostProcess();
 
-	/* Cache Flush */
-//	NAND_IO_LBA_CacheFlush( nDevInfo );
-
+	  //######################################################
+	  //# Set Power Save Mode 
+	  //######################################################
+	  //NAND_IO_LBA_PowerSaveMode( &nDevInfo[wCSorder], ENABLE );
+	}
 	return (NAND_IO_ERROR)SUCCESS;
 }
 
@@ -11767,6 +13319,7 @@ NAND_IO_ERROR NAND_IO_LBA_ScanHeaderOfVFP( NAND_IO_DEVINFO *nDevInfo )
 			pNFC->NFC_SADDR= ( dwSectorAddr & 0xFF );				// Write Sector Addr: AD0
 			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 8 ) & 0xFF );		// Write Sector Addr: AD1
 			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 16 ) & 0xFF );		// Write Sector Addr: AD2
+			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 24 ) & 0xFF );		// Write Sector Addr: AD2
 		}
 
 		/* Command Page Program #2 [ 0x10 ] */
@@ -11777,7 +13330,7 @@ NAND_IO_ERROR NAND_IO_LBA_ScanHeaderOfVFP( NAND_IO_DEVINFO *nDevInfo )
 
 		NAND_IO_SetReadCycleTime();
 		/* Write Data to NAND FLASH */
-		res = NAND_IO_LBA_ReadData( nDevInfo, wCurrPPSize, cPageBuffer, cSpareBuffer );
+		res = NAND_IO_LBA_ReadData_VFP( nDevInfo, wCurrPPSize, cPageBuffer, cSpareBuffer );
 		if ( res != SUCCESS )
 			return res;
 
@@ -11875,23 +13428,6 @@ NAND_IO_ERROR NAND_IO_LBA_ScanHeaderOfVFP( NAND_IO_DEVINFO *nDevInfo )
 	if ( wFlagCheckSize == FALSE )
 		return ERR_NAND_IO_NOT_EXIST_LBA_HEADBLOCK;
 
-	//==================================
-	// Area Address Offset Setting
-	//==================================
-	// Data Area Address Offset = 0
-	// 0 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~MDP Size
-	// [ Data Area | Multi Hidden[n], Multi Hidden[n-1], Multi Hidden[0] | Hidden Area ]
-
-	nDevInfo->LBAInfo.DTAreaSectorSize = nDevInfo->LBAInfo.MDPSectorSize;
-	
-	nDevInfo->LBAInfo.DTAreaSectorSize -= nDevInfo->LBAInfo.HDAreaSectorSize;
-	nDevInfo->LBAInfo.HDAreaAddrOffSet = nDevInfo->LBAInfo.DTAreaSectorSize;
-
-	for ( i = 0; i < nDevInfo->LBAInfo.MHDAreaNums; ++i )
-	{
-		nDevInfo->LBAInfo.DTAreaSectorSize -= nDevInfo->LBAInfo.MHDAreaSectorSize[i];
-		nDevInfo->LBAInfo.MHDAreaAddrOffSet[i] = nDevInfo->LBAInfo.DTAreaSectorSize;
-	}
 
 	return (NAND_IO_ERROR)SUCCESS;
 }
@@ -11998,6 +13534,7 @@ NAND_IO_ERROR NAND_IO_LBA_MakeHeaderOfVFP( NAND_IO_DEVINFO *nDevInfo )
 			pNFC->NFC_SADDR= ( dwSectorAddr & 0xFF );				// Write Sector Addr: AD0
 			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 8 ) & 0xFF );		// Write Sector Addr: AD1
 			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 16 ) & 0xFF );		// Write Sector Addr: AD2
+			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 24 ) & 0xFF );		// Write Sector Addr: AD2
 		}
 
 		NAND_IO_SetWriteCycleTime();
@@ -12030,8 +13567,8 @@ NAND_IO_ERROR NAND_IO_LBA_MakeHeaderOfVFP( NAND_IO_DEVINFO *nDevInfo )
 		NAND_IO_WaitBusy( nDevInfo->ChipNo );
 	}
 	
-	nDevInfo->LBAInfo.HDAreaAddrOffSet = nDevInfo->LBAInfo.MDPSectorSize - nDevInfo->LBAInfo.HDAreaSectorSize;
-	nDevInfo->LBAInfo.DTAreaSectorSize = nDevInfo->LBAInfo.MDPSectorSize - nDevInfo->LBAInfo.HDAreaSectorSize;
+	//nDevInfo->LBAInfo.HDAreaAddrOffSet = nDevInfo->LBAInfo.MDPSectorSize - nDevInfo->LBAInfo.HDAreaSectorSize;
+	//nDevInfo->LBAInfo.DTAreaSectorSize = nDevInfo->LBAInfo.MDPSectorSize - nDevInfo->LBAInfo.HDAreaSectorSize;
 
 	/* FORCE TO SET WP LOW */
 	NAND_IO_EnableWriteProtect();
@@ -12360,6 +13897,42 @@ NAND_IO_ERROR NAND_IO_LBA_SetRebootCmdChange( NAND_IO_DEVINFO *nDevInfo, U8 nReb
 	return (NAND_IO_ERROR)SUCCESS;
 }
 
+NAND_IO_ERROR NAND_IO_LBA_SetAreaPartition( NAND_IO_DEVINFO *nDevInfo, NAND_IO_FEATURE *sDevFeatureInfo )
+{
+	unsigned int i;
+	unsigned int nBlockOffset;
+
+	//==================================
+	// Area Address Offset Setting
+	//==================================
+	// Data Area Address Offset = 0
+	// 0 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~MDP Size
+	// [ Multi Hidden[n], Multi Hidden[n-1], Multi Hidden[0] | Hidden Area | Data Area ]
+	nDevInfo->LBAInfo.DTAreaAddrOffSet = 0;
+	nDevInfo->LBAInfo.DTAreaSectorSize = nDevInfo->LBAInfo.MDPSectorSize;
+
+	for ( i = 0; i < nDevInfo->LBAInfo.MHDAreaNums; ++i )
+	{
+		nDevInfo->LBAInfo.DTAreaSectorSize -= nDevInfo->LBAInfo.MHDAreaSectorSize[i];
+		nDevInfo->LBAInfo.MHDAreaAddrOffSet[i] = 0;
+		nDevInfo->LBAInfo.DTAreaAddrOffSet += nDevInfo->LBAInfo.MHDAreaSectorSize[i];
+		if ( i > 0 )
+			nDevInfo->LBAInfo.MHDAreaAddrOffSet[i] = ( nDevInfo->LBAInfo.MHDAreaSectorSize[i-1] + nDevInfo->LBAInfo.MHDAreaAddrOffSet[i-1] );
+	}
+	nDevInfo->LBAInfo.HDAreaAddrOffSet = nDevInfo->LBAInfo.MDPSectorSize - nDevInfo->LBAInfo.DTAreaSectorSize;
+	nDevInfo->LBAInfo.DTAreaSectorSize -= nDevInfo->LBAInfo.HDAreaSectorSize;
+	nDevInfo->LBAInfo.DTAreaAddrOffSet += nDevInfo->LBAInfo.HDAreaSectorSize;
+
+	nBlockOffset = ( nDevInfo->LBAInfo.DTAreaAddrOffSet /  ( ( sDevFeatureInfo->PageSize * sDevFeatureInfo->PpB ) >> 9 ) );
+	if ( nDevInfo->LBAInfo.DTAreaAddrOffSet %  ( ( sDevFeatureInfo->PageSize * sDevFeatureInfo->PpB ) >> 9 ) )
+		++nBlockOffset;
+
+	nDevInfo->LBAInfo.DTAreaAddrOffSet += ( ( nBlockOffset * ( ( sDevFeatureInfo->PageSize * sDevFeatureInfo->PpB ) >> 9 ) ) - nDevInfo->LBAInfo.DTAreaAddrOffSet  );
+	nDevInfo->LBAInfo.DTAreaSectorSize -= ( ( nBlockOffset * ( ( sDevFeatureInfo->PageSize * sDevFeatureInfo->PpB ) >> 9 ) ) - nDevInfo->LBAInfo.DTAreaAddrOffSet  );
+
+	return SUCCESS;
+}
+
 NAND_IO_ERROR NAND_IO_LBA_GetPersistentFunction( NAND_IO_DEVINFO *nDevInfo, U8 *rBootMode, U8 *rRebootCmd )
 {
 	unsigned char	nParameter;
@@ -12489,6 +14062,32 @@ NAND_IO_ERROR NAND_IO_LBA_GetTransferProtocol( NAND_IO_DEVINFO *nDevInfo, U8 *rP
 	return (NAND_IO_ERROR)SUCCESS;
 }
 
+NAND_IO_ERROR NAND_IO_LBA_GetDeviceMDPSectorSize( NAND_IO_DEVINFO *nDevInfo, unsigned long int *rTotalSector )
+{
+	unsigned int 		i;
+	unsigned long int	nTotalSecSize;
+		
+	NAND_IO_ERROR	res;
+
+	nTotalSecSize = 0;
+	
+	for ( i = NAND_IO_DRV0_START_CS; i < NAND_IO_DRV0_END_CS + 1; ++i )
+	{
+		nDevInfo[i].LBAInfo.MDPSectorSize = 0;
+		
+		res = NAND_IO_LBA_GetDeviceInfo( i, &nDevInfo[i] );
+		if ( res == SUCCESS )
+		{
+			NAND_IO_LBA_MDPGetTotalSectorSize( nDevInfo, &nDevInfo[i].LBAInfo.MDPSectorSize );
+			nTotalSecSize += nDevInfo[i].LBAInfo.MDPSectorSize;
+		}
+	}
+
+	*rTotalSector = nTotalSecSize;
+
+	return SUCCESS;
+}
+
 NAND_IO_ERROR NAND_IO_LBA_GetBusyTime( NAND_IO_DEVINFO *nDevInfo, U8 *rBusyTime )
 {
 	unsigned char	dwBusyTime;
@@ -12755,6 +14354,79 @@ NAND_IO_ERROR NAND_IO_LBA_CacheFlush( NAND_IO_DEVINFO *nDevInfo )
 	return (NAND_IO_ERROR)SUCCESS;
 }
 
+NAND_IO_ERROR NAND_IO_LBA_GetDeviceMediaNums( U16 *rMediaOrder )
+{
+	*rMediaOrder = gLBACSNums;
+
+	return SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_ConvertMPPA( NAND_IO_DEVINFO *nDevInfo, U8 nPartition, U32 nSectorAddr, U32 nSecSize, U32 *nConvertAddr, U32 *nConvertSize, U16 *rMediaOrder )
+{
+	unsigned short int		i;
+	unsigned short int		wOrder;
+	unsigned long int       dwBound;
+	unsigned long int		dwSectorAddr;
+	unsigned long int		nTotalSectorSize[4];
+	unsigned long int		nPartitionOffSet[4];
+		
+	dwBound = 0;
+	dwSectorAddr = nSectorAddr;
+
+	for ( wOrder = 0; wOrder < gLBACSNums; ++wOrder )
+	{	
+		if ( nPartition == NAND_LBA_DATA_AREA )
+		{
+			nTotalSectorSize[wOrder] = nDevInfo[wOrder].LBAInfo.DTAreaSectorSize;
+			nPartitionOffSet[wOrder] = nDevInfo[wOrder].LBAInfo.DTAreaAddrOffSet;
+		}	
+		else if ( nPartition == NAND_LBA_HIDDEN_AREA )
+		{
+			nTotalSectorSize[wOrder] = nDevInfo[wOrder].LBAInfo.HDAreaSectorSize;
+			nPartitionOffSet[wOrder] = nDevInfo[wOrder].LBAInfo.HDAreaAddrOffSet;
+		}
+		else if ( nPartition == NAND_LBA_MULTI_HIDDEN_AREA_0 )
+		{
+			nTotalSectorSize[wOrder] = nDevInfo[wOrder].LBAInfo.MHDAreaSectorSize[0];
+			nPartitionOffSet[wOrder] = nDevInfo[wOrder].LBAInfo.MHDAreaAddrOffSet[0];
+		}
+		else if ( nPartition == NAND_LBA_MDP )
+		{
+			nTotalSectorSize[wOrder] = nDevInfo[wOrder].LBAInfo.MDPSectorSize;
+			nPartitionOffSet[wOrder] = 0;			
+		}
+		else if ( nPartition == NAND_LBA_VFP )
+		{
+			nTotalSectorSize[wOrder] = nDevInfo[wOrder].LBAInfo.VFPSectorSize;
+			nPartitionOffSet[wOrder] = NAND_LBA_SYS_SECTION;
+		}
+	
+		dwBound 	 += nDevInfo[wOrder].LBAInfo.MDPSectorSize;
+		dwSectorAddr += nPartitionOffSet[wOrder];
+		
+		if ( dwSectorAddr < dwBound )
+		{
+			*rMediaOrder = wOrder;
+			break;
+		}		
+	}
+
+	for ( i = 0; i < wOrder; ++i )
+		dwSectorAddr -= nDevInfo[i].LBAInfo.MDPSectorSize;
+	
+	if ( ( nDevInfo[wOrder].LBAInfo.MDPSectorSize - dwSectorAddr ) >= nSecSize )
+		*nConvertSize = nSecSize;
+	else
+		*nConvertSize = ( nDevInfo[wOrder].LBAInfo.MDPSectorSize - dwSectorAddr );
+
+	*nConvertAddr = dwSectorAddr;
+	
+	if ( ( dwSectorAddr + *nConvertSize ) > ( nTotalSectorSize[wOrder] + nPartitionOffSet[wOrder] ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	return SUCCESS;
+}	
+
 NAND_IO_ERROR NAND_IO_LBA_DeviceReboot( NAND_IO_DEVINFO *nDevInfo )
 {
 	/* Pre Process */
@@ -13066,15 +14738,15 @@ NAND_IO_ERROR NAND_IO_LBA_Read2Status( NAND_IO_DEVINFO *nDevInfo )
 	//	Read IO Status
 	//================================
 	uStatus	= nDevInfo->CmdMask & pNFC->NFC_SDATA;
-	uStatus = uStatus & 0x06;
+	uStatus = uStatus & 0x0F;
 	
-	if ( uStatus == NAND_LBA_PNP )
+	if ( ( uStatus & 0x06 ) == NAND_LBA_PNP )
 		nDevInfo->LBAInfo.CurrentMode = NAND_LBA_PNP;
-	else if ( uStatus == NAND_LBA_BCM )
+	else if ( ( uStatus & 0x06 ) == NAND_LBA_BCM )
 		nDevInfo->LBAInfo.CurrentMode = NAND_LBA_BCM;
-	else if ( uStatus == NAND_LBA_VFP )
+	else if ( ( uStatus & 0x06 ) == NAND_LBA_VFP )
 		nDevInfo->LBAInfo.CurrentMode = NAND_LBA_VFP;
-	else if ( uStatus == NAND_LBA_MDP )
+	else if ( ( uStatus & 0x06 ) == NAND_LBA_MDP )
 		nDevInfo->LBAInfo.CurrentMode = NAND_LBA_MDP;
 	else
 		res = ERR_NAND_IO_FAILED_LBA_PARTITION_CHANGE;
@@ -13104,14 +14776,15 @@ NAND_IO_ERROR NAND_IO_LBA_Read2Status( NAND_IO_DEVINFO *nDevInfo )
 	return res;
 }
 
-static __inline NAND_IO_ERROR NAND_IO_LBA_ReadData( NAND_IO_DEVINFO *nDevInfo, U16 nReadPPSize,
+static __inline NAND_IO_ERROR NAND_IO_LBA_ReadData_VFP( NAND_IO_DEVINFO *nDevInfo, U16 nReadPPSize,
 												    U8 *nPageBuffer, U8 *nSpareBuffer )
 {
 	unsigned int		i, j;
 	unsigned char		bAlignAddr;
 	unsigned char		*pPageB = 0, *pSpareB = 0;
 	unsigned int		*pPageDW = 0, *pSpareDW = 0;
-	unsigned char		*pDataBuffer;
+	unsigned char		*pDataBuffer, *pPrDataBuffer;
+	unsigned char		*pPhy_Buffer;
 	DWORD_BYTE			uDWordByte;
 	NAND_IO_ERROR		res;
 	
@@ -13159,6 +14832,25 @@ static __inline NAND_IO_ERROR NAND_IO_LBA_ReadData( NAND_IO_DEVINFO *nDevInfo, U
 		/* Set Data Buffer */
 		pDataBuffer = ( bAlignAddr ) ? (unsigned char*)pPageDW : (unsigned char*)pPageB;
 
+
+#if 1		/* 09.12.21 */
+		/* Read 512 Data Area */
+		i = 128;
+		do {
+			if ( bAlignAddr )
+			{
+				*pPageDW = pNFC->NFC_WDATA;++pPageDW;
+			}	
+			else
+			{
+				uDWordByte.DWORD = pNFC->NFC_WDATA;
+				*pPageB = uDWordByte.BYTE[0];++pPageB;
+				*pPageB = uDWordByte.BYTE[1];++pPageB;
+				*pPageB = uDWordByte.BYTE[2];++pPageB;
+				*pPageB = uDWordByte.BYTE[3];++pPageB;
+			}
+		}while(--i);
+#else
 		//####################################################
 		//#	Read 512 Page Data
 		//####################################################
@@ -13187,13 +14879,24 @@ static __inline NAND_IO_ERROR NAND_IO_LBA_ReadData( NAND_IO_DEVINFO *nDevInfo, U
 		//	DMA ACCESS
 		//----------------------------------------------
 		#elif defined( NAND_IO_USE_DMA_ACCESS )
-
-		/* Disable DMA Ahead */
-		//IO_DMA_SetCTRL( IO_DMA_CH2, 0 );
-		//IO_INT_HwICLR = IO_INT_HwDMA_CH2;
-
-		/* Start DMA on NFC BUS */
+		//
+		///* Disable DMA Ahead */
+		////IO_DMA_SetCTRL( IO_DMA_CH2, 0 );
+		////IO_INT_HwICLR = IO_INT_HwDMA_CH2;
+		//
+		///* Start DMA on NFC BUS */
+#if 1		/* 09.12.08 */
 		#if defined(_LINUX_) || defined(_WINCE_)
+
+		//if ( nEccOnOff == ECC_ON_NON_CACHE_BUF )
+		//{
+		//	pPhy_Buffer = virt_to_phys(pDataBuffer);
+		//
+		//	NAND_IO_SetupDMA_kernel( (void*)&NAND_IO_HwLDATA_PA, 0, 0,
+		//							  (void*)pPhy_Buffer, 4, 0,
+		//							  NAND_IO_DMA_READ, 512 );
+		//}
+		//else
 		NAND_IO_SetupDMA( (void*)&NAND_IO_HwLDATA_PA, 0, 0,
 						  (void*)pDataBuffer, 4, 0,
 						  NAND_IO_DMA_READ, 512 );
@@ -13203,38 +14906,226 @@ static __inline NAND_IO_ERROR NAND_IO_LBA_ReadData( NAND_IO_DEVINFO *nDevInfo, U
 						  NAND_IO_DMA_READ, 512 );
 		#endif
 
-		//if ( ISZERO(pDataBuffer,3) ) {
-		//	#if defined(_WINCE_)
-		//		memcpy( pDataBuffer, (void*)IO_NFC_BUFFER0_BASE, 512 );
-		//	#elif defined(_LINUX_)
-		//		#ifndef KERNEL_DRIVER
-		//	    memcpy(pDataBuffer, (void*)IO_NFC_BUFFER0_BASE, 512);
-		//	    #else
-		//	    memcpy(pDataBuffer, virtadr, 512);
-		//		#endif
-		//	#else
-		//	fmemcpy16( pDataBuffer, (void*)IO_NFC_BUFFER0_BASE, 512 );
-		//	#endif
-		//} else {
-		//	#if defined(_WINCE_)
-		//		memcpy( pDataBuffer, (void*)IO_NFC_BUFFER0_BASE, 512 );
-		//	#elif defined(_LINUX_)
-		//	    #ifndef KERNEL_DRIVER
-		//	    memcpy(pDataBuffer, (void*)IO_NFC_BUFFER0_BASE, 512);
-		//	    #else
-		//	    memcpy(pDataBuffer, virtadr, 512);
-		//	    #endif
-		//	#else
-		//	memcpy( pDataBuffer, (void*)IO_NFC_BUFFER0_BASE, 512 );
-		//	#endif
-		//}
+		if ( bAlignAddr )
+			pPageDW += 128;
+		else
+			pPageB += 512;
+#else
+
+
+		/* Disable DMA Ahead */
+		/* Start DMA on NFC BUS */
+		NAND_IO_SetupDMADoubleBuf( NAND_IO_DMA_READ, j );
+
+		pNFC->NFC_RSTART	= 0;
+		
+		if ( j != 0 )
+		{
+			if ( j & 1 )
+				memcpy( pPrDataBuffer, gpDMA_WorkBuffer1, 512 );
+			else
+				memcpy( pPrDataBuffer, gpDMA_WorkBuffer0, 512 );
+		}
+
+		while ( ISZERO(pNFC->NFC_IREQ, HwNFC_IREQ_FLAG0) );
+
+
+		if ( j == (unsigned int)( nReadPPSize - 1 ) )
+		{
+			if ( j & 1 )
+				memcpy( pDataBuffer, gpDMA_WorkBuffer0, 512 );
+			else
+				memcpy( pDataBuffer, gpDMA_WorkBuffer1, 512 );
+		}
+		else
+		{
+			pPrDataBuffer = pDataBuffer;	// Buffer Pointer Backup
 
+			if ( j & 1 )
+				pDataBuffer =(unsigned char *)gpDMA_WorkBuffer0;			
+			else
+				pDataBuffer =(unsigned char *)gpDMA_WorkBuffer1;
+		}
+		
 		if ( bAlignAddr )
 			pPageDW += 128;
 		else
 			pPageB += 512;
-			
+#endif		
 		#endif
+#endif		
+		//####################################################
+		//####################################################
+		if ( nDevInfo->LBAInfo.DataTransferCheck == ENABLE )
+		{
+			/* Read 16Bytes spare data */
+			i = 4;
+			do {
+				if ( bAlignAddr )
+				{
+					*pSpareDW = pNFC->NFC_WDATA;++pSpareDW;
+				}	
+				else
+				{
+					uDWordByte.DWORD = pNFC->NFC_WDATA;
+					*pSpareB = uDWordByte.BYTE[0];++pSpareB;
+					*pSpareB = uDWordByte.BYTE[1];++pSpareB;
+					*pSpareB = uDWordByte.BYTE[2];++pSpareB;
+					*pSpareB = uDWordByte.BYTE[3];++pSpareB;
+				}
+			}while(--i);
+
+			/* Adapt type of address */
+			if ( bAlignAddr )
+				pSpareDW	= (unsigned int*)nSpareBuffer;
+			else
+				pSpareB		= (unsigned char*)nSpareBuffer;				
+		}
+	}
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+	return res;
+}
+
+static __inline NAND_IO_ERROR NAND_IO_LBA_ReadData( NAND_IO_DEVINFO *nDevInfo, U16 nReadPPSize,
+												    U8 *nPageBuffer, U8 *nSpareBuffer )
+{
+	unsigned int		i, j;
+	unsigned char		bAlignAddr;
+	unsigned char		*pPageB = 0, *pSpareB = 0;
+	unsigned int		*pPageDW = 0, *pSpareDW = 0;
+	unsigned char		*pDataBuffer, *pPrDataBuffer;
+	unsigned char		*pPhy_Buffer;
+	DWORD_BYTE			uDWordByte;
+	NAND_IO_ERROR		res;
+	
+	if ( nReadPPSize > nDevInfo->LBAInfo.SectorCount )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+		
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	res = (NAND_IO_ERROR)SUCCESS;
+
+	//=========================================================================
+	// Check Align of PageBuffer Address
+	//=========================================================================
+	bAlignAddr = ( (unsigned int)nPageBuffer & 3 ) ? 0 : 1;
+	
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================	
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//=========================================================================
+	// Read Data as 512+16Bytes
+	//=========================================================================
+	/* Adapt type of address */
+	if ( bAlignAddr )
+	{
+		pPageDW		= (unsigned int*)nPageBuffer;
+		pSpareDW	= (unsigned int*)nSpareBuffer;
+	}	
+	else
+	{
+		pPageB		= (unsigned char*)nPageBuffer;
+		pSpareB		= (unsigned char*)nSpareBuffer;
+	}	
+
+	//----------------------------------------------
+	//	Read Data as 512Bytes repeatly
+	//----------------------------------------------		
+#ifdef __USE_NAND_ISR__
+	pDataBuffer = ( bAlignAddr ) ? (unsigned char*)pPageDW : (unsigned char*)pPageB;
+
+	pPhy_Buffer = virt_to_phys(pDataBuffer);
+	NAND_IO_SetupDMA_kernel( (void*)&NAND_IO_HwLDATA_PA, 0, 0,
+					  (void*)pPhy_Buffer, 4, 0,
+					  NAND_IO_DMA_READ, 512 * nReadPPSize );
+#else
+	for ( j = 0; j < nReadPPSize; ++j )
+	{
+		/* Set Data Buffer */
+		pDataBuffer = ( bAlignAddr ) ? (unsigned char*)pPageDW : (unsigned char*)pPageB;
+
+		//####################################################
+		//#	Read 512 Page Data
+		//####################################################
+		//----------------------------------------------
+		//	MCU ACCESS
+		//----------------------------------------------
+		#if defined( NAND_IO_USE_MCU_ACCESS )
+		
+		/* Read 512 Data Area */
+		i = 128;
+		do {
+			if ( bAlignAddr )
+			{
+				*pPageDW = pNFC->NFC_WDATA;++pPageDW;
+			}	
+			else
+			{
+				uDWordByte.DWORD = pNFC->NFC_WDATA;
+				*pPageB = uDWordByte.BYTE[0];++pPageB;
+				*pPageB = uDWordByte.BYTE[1];++pPageB;
+				*pPageB = uDWordByte.BYTE[2];++pPageB;
+				*pPageB = uDWordByte.BYTE[3];++pPageB;
+			}
+		}while(--i);
+		//----------------------------------------------
+		//	DMA ACCESS
+		//----------------------------------------------
+		#elif defined( NAND_IO_USE_DMA_ACCESS )
+		//
+		///* Disable DMA Ahead */
+		////IO_DMA_SetCTRL( IO_DMA_CH2, 0 );
+		////IO_INT_HwICLR = IO_INT_HwDMA_CH2;
+		//
+		///* Start DMA on NFC BUS */
+		/* Disable DMA Ahead */
+		/* Start DMA on NFC BUS */
+		NAND_IO_SetupDMADoubleBuf( NAND_IO_DMA_READ, j );
+
+		pNFC->NFC_RSTART	= 0;
+		
+		if ( j != 0 )
+		{
+			if ( j & 1 )
+				memcpy( pPrDataBuffer, gpDMA_WorkBuffer1, 512 );
+			else
+				memcpy( pPrDataBuffer, gpDMA_WorkBuffer0, 512 );
+		}
+
+		while ( ISZERO(pNFC->NFC_IREQ, HwNFC_IREQ_FLAG0) );
+
+
+		if ( j == (unsigned int)( nReadPPSize - 1 ) )
+		{
+			if ( j & 1 )
+				memcpy( pDataBuffer, gpDMA_WorkBuffer0, 512 );
+			else
+				memcpy( pDataBuffer, gpDMA_WorkBuffer1, 512 );
+		}
+		else
+		{
+			pPrDataBuffer = pDataBuffer;	// Buffer Pointer Backup
+
+			if ( j & 1 )
+				pDataBuffer =(unsigned char *)gpDMA_WorkBuffer0;			
+			else
+				pDataBuffer =(unsigned char *)gpDMA_WorkBuffer1;
+		}
+
+		if ( bAlignAddr )
+			pPageDW += 128;
+		else
+			pPageB += 512;
+#endif		
 		//####################################################
 		//####################################################
 		if ( nDevInfo->LBAInfo.DataTransferCheck == ENABLE )
@@ -13263,6 +15154,7 @@ static __inline NAND_IO_ERROR NAND_IO_LBA_ReadData( NAND_IO_DEVINFO *nDevInfo, U
 				pSpareB		= (unsigned char*)nSpareBuffer;				
 		}
 	}
+#endif
 
 	//=========================================================================
 	// Return
@@ -13270,6 +15162,32 @@ static __inline NAND_IO_ERROR NAND_IO_LBA_ReadData( NAND_IO_DEVINFO *nDevInfo, U
 	return res;
 }
 
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_LBA_WaitBusy( U16 nChipNo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nChipNo	= 
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_LBA_WaitBusy( U16 nChipNo )
+{
+	// Misc. Configuration Register(MCFG)
+   	// 0 : represent that READY pin is low
+   	// 1 :                             high
+   	// Delay : 200nS
+
+	while (NAND_IO_CheckReadyAndBusy( nChipNo ))
+	{
+		#ifndef FWDN_DOWNLOADER_INCLUDE
+		TCC7XX_USBDRV_WriteToQueue();
+		#endif
+	}
+}
+
 static __inline NAND_IO_ERROR NAND_IO_LBA_WriteData( NAND_IO_DEVINFO *nDevInfo, U16 nWritePPSize,
 													 U8 *nPageBuffer, U8 *nSpareBuffer )
 {
@@ -13335,18 +15253,16 @@ static __inline NAND_IO_ERROR NAND_IO_LBA_WriteData( NAND_IO_DEVINFO *nDevInfo,
 		#if defined( NAND_IO_USE_MCU_ACCESS )
 
 		/* Write 512 Data Area */	
-		BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
-		pNFC->NFC_DSIZE	= 512;
-		pNFC->NFC_IREQ = 0x77;	// pNFC->NFC_IREQ_FLAG1;
-		pNFC->NFC_PSTART = 0;
+		//BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
+		//pNFC->NFC_DSIZE	= 512;
+		//pNFC->NFC_IREQ = 0x77;	// pNFC->NFC_IREQ_FLAG1;
+		//pNFC->NFC_PSTART = 0;
 		
 		i = 128;
 		do {
-			while (!( pNFC->NFC_CTRL & HwNFC_CTRL_FS_RDY ));
-			
 			if ( bAlignAddr )
 			{
-				pNFC->NFC_LDATA = *pPageDW;++pPageDW;
+				pNFC->NFC_WDATA = *pPageDW;++pPageDW;
 			}	
 			else
 			{
@@ -13354,47 +15270,18 @@ static __inline NAND_IO_ERROR NAND_IO_LBA_WriteData( NAND_IO_DEVINFO *nDevInfo,
 				uDWordByte.BYTE[1] = *pPageB;++pPageB;
 				uDWordByte.BYTE[2] = *pPageB;++pPageB;
 				uDWordByte.BYTE[3] = *pPageB;++pPageB;
-				pNFC->NFC_LDATA	= uDWordByte.DWORD;					
+				pNFC->NFC_WDATA	= uDWordByte.DWORD;					
 			}
 		}while(--i);
 
-		while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+		//while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
 		
 		//----------------------------------------------
 		//	DMA ACCESS
 		//----------------------------------------------
 		#elif defined( NAND_IO_USE_DMA_ACCESS )
-		/* Disable DMA Ahead */
-		//IO_DMA_SetCTRL( IO_DMA_CH2, 0 );
-		//IO_INT_HwICLR = IO_INT_HwDMA_CH2;
-
-		/* Prepare data */
-		//if (ISZERO( pDataBuffer, 3 )) {
-		//	#if defined(_WINCE_)
-		//		memcpy( (void*)IO_NFC_BUFFER0_BASE, pDataBuffer, 512 );
-		//	#elif defined(_LINUX_)
-		//	    #ifndef KERNEL_DRIVER
-		//	    memcpy( (void*)IO_NFC_BUFFER0_BASE, pDataBuffer, 512 );
-		//	    #else
-		//	    memcpy( virtadr, pDataBuffer, 512 );
-		//	    #endif
-		//	#else
-		//	fmemcpy16( (void*)IO_NFC_BUFFER0_BASE, pDataBuffer, 512 );
-		//	#endif
-		//} else {
-		//	#if defined(_WINCE_)
-		//		memcpy( (void*)IO_NFC_BUFFER0_BASE, pDataBuffer, 512 );
-		//	#elif defined(_LINUX_)
-		//	    #ifndef KERNEL_DRIVER
-		//	    memcpy( (void*)IO_NFC_BUFFER0_BASE, pDataBuffer, 512 );
-		//	    #else
-		//	    memcpy( virtadr, pDataBuffer, 512 );
-		//	    #endif
-		//	#else
-		//	memcpy( (void*)IO_NFC_BUFFER0_BASE, pDataBuffer, 512 );
-		//	#endif
-		//}
 			
+#if 1		/* 09.12.08 */
 		#if defined(_LINUX_) || defined(_WINCE_)
 		NAND_IO_SetupDMA( (void*)pDataBuffer, 4, 0,
 						  (void*)&NAND_IO_HwLDATA_PA, 0, 0,
@@ -13410,6 +15297,39 @@ static __inline NAND_IO_ERROR NAND_IO_LBA_WriteData( NAND_IO_DEVINFO *nDevInfo,
 		else
 			pPageB += 512;
 
+
+#else
+
+
+		if ( j == 0 )
+			memcpy( gpDMA_WorkBuffer1, pDataBuffer, 512 );
+
+		NAND_IO_SetupDMADoubleBuf( NAND_IO_DMA_WRITE, j );
+
+		if ( pNFC->NFC_CTRL1 & Hw31 )
+			BITCLR( pNFC->NFC_CTRL1, Hw31 );
+
+		pNFC->NFC_PSTART	= 0;
+
+		if ( j != (unsigned int)( nWritePPSize - 1 ) ) 
+		{
+			if ( j & 1 )
+				memcpy( gpDMA_WorkBuffer1, (void *)(pDataBuffer + 512), 512 );
+			else
+				memcpy( gpDMA_WorkBuffer0, (void *)(pDataBuffer + 512), 512 );
+		}
+		
+		while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+
+		if ( pNFC->NFC_CTRL1 & Hw30 )
+			BITSET( pNFC->NFC_CTRL1, Hw31 );
+	
+		if ( bAlignAddr )
+			pPageDW += 128;
+		else
+			pPageB += 512;
+#endif
+
 		#endif
 		//####################################################
 		//####################################################
@@ -13513,6 +15433,8 @@ static __inline NAND_IO_ERROR NAND_IO_LBA_WriteDummyData( NAND_IO_DEVINFO *nDevI
 		BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
 		pNFC->NFC_DSIZE	= 512;
 		pNFC->NFC_IREQ = 0x77;	// pNFC->NFC_IREQ_FLAG1;
+
+		NAND_IO_IRQ_Mask();
 		pNFC->NFC_PSTART = 0;
 		
 		i = 128;
@@ -13522,6 +15444,7 @@ static __inline NAND_IO_ERROR NAND_IO_LBA_WriteDummyData( NAND_IO_DEVINFO *nDevI
 		}while(--i);
 
 		while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+		NAND_IO_IRQ_UnMask();
 		
 		//----------------------------------------------
 		//	DMA ACCESS
diff --git a/kernel/sched.c b/kernel/sched.c
index cda71ee..e4bb1dd 100644
--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -4388,10 +4388,8 @@ static inline void schedule_debug(struct task_struct *prev)
 	 * schedule() atomically, we ignore that path for now.
 	 * Otherwise, whine if we are scheduling when we should not be.
 	 */
-	#if 0 /*FIXME: Disable nand driver report*/
 	if (unlikely(in_atomic_preempt_off() && !prev->exit_state))
 		__schedule_bug(prev);
-	#endif
 
 	profile_hit(SCHED_PROFILING, __builtin_return_address(0));
 
-- 
1.6.3.3

