From ca875b673b32054a196452d6b36b8467912147fd Mon Sep 17 00:00:00 2001
From: YouSheng <david.ysh@gmail.com>
Date: Fri, 16 Oct 2009 15:40:05 +0800
Subject: [PATCH] Apply patch r1888

---
 Makefile                                           |   32 +-
 arch/arm/Kconfig                                   |   12 +
 arch/arm/Makefile                                  |    3 +
 arch/arm/configs/tcc8900_defconfig                 | 1422 +++++++
 arch/arm/configs/tcc8900_wifi_defconfig            | 1453 +++++++
 arch/arm/include/asm/mach/map.h                    |    1 +
 arch/arm/include/asm/mach/time.h                   |   23 +
 arch/arm/kernel/head.S                             |   68 +-
 arch/arm/kernel/irq.c                              |    3 +
 arch/arm/kernel/setup.c                            |   13 +
 arch/arm/kernel/time.c                             |  114 +
 arch/arm/mach-tcc8900/Kconfig                      |  107 +
 arch/arm/mach-tcc8900/Makefile                     |   52 +
 arch/arm/mach-tcc8900/Makefile.boot                |    3 +
 arch/arm/mach-tcc8900/board-tcc8900.c              |   88 +
 arch/arm/mach-tcc8900/devices.c                    |  713 ++++
 arch/arm/mach-tcc8900/gpio.c                       |   32 +
 arch/arm/mach-tcc8900/idle.c                       |   49 +
 arch/arm/mach-tcc8900/include/bsp.h                |   62 +
 .../mach-tcc8900/include/mach/TCC89x_Physical.h    | 1164 +++++
 .../mach-tcc8900/include/mach/TCC89x_Structures.h  | 3275 +++++++++++++++
 arch/arm/mach-tcc8900/include/mach/bsp_cfg.h       |   32 +
 arch/arm/mach-tcc8900/include/mach/common.h        |   36 +
 arch/arm/mach-tcc8900/include/mach/debug-macro.S   |   40 +
 arch/arm/mach-tcc8900/include/mach/dma.h           |   27 +
 arch/arm/mach-tcc8900/include/mach/entry-macro.S   |   66 +
 arch/arm/mach-tcc8900/include/mach/globals.h       |  443 ++
 arch/arm/mach-tcc8900/include/mach/gpio.h          |   27 +
 arch/arm/mach-tcc8900/include/mach/hardware.h      |   65 +
 arch/arm/mach-tcc8900/include/mach/io.h            |   73 +
 arch/arm/mach-tcc8900/include/mach/ioctl_ckcstr.h  |   86 +
 arch/arm/mach-tcc8900/include/mach/irqs.h          |  158 +
 arch/arm/mach-tcc8900/include/mach/memory.h        |  116 +
 arch/arm/mach-tcc8900/include/mach/ohci.h          |  241 ++
 arch/arm/mach-tcc8900/include/mach/reg_physical.h  |   38 +
 arch/arm/mach-tcc8900/include/mach/system.h        |   54 +
 arch/arm/mach-tcc8900/include/mach/system_type.h   |   32 +
 arch/arm/mach-tcc8900/include/mach/tca_ckc.h       |  178 +
 arch/arm/mach-tcc8900/include/mach/tcc_ckc_ctrl.h  |   60 +
 arch/arm/mach-tcc8900/include/mach/tcc_pca953x.h   |  210 +
 arch/arm/mach-tcc8900/include/mach/timex.h         |   31 +
 arch/arm/mach-tcc8900/include/mach/uncompress.h    |   45 +
 arch/arm/mach-tcc8900/include/mach/vmalloc.h       |   25 +
 arch/arm/mach-tcc8900/io.c                         |  100 +
 arch/arm/mach-tcc8900/irq.c                        |  548 +++
 arch/arm/mach-tcc8900/tca_ckc.c                    | 1174 ++++++
 arch/arm/mach-tcc8900/tcc                          |    1 +
 arch/arm/mach-tcc8900/tcc8900/arm_ioctlutil.S      |   23 +
 .../mach-tcc8900/tcc8900/tcc_ckcddr2_141to190.c    | 2253 ++++++++++
 .../mach-tcc8900/tcc8900/tcc_ckcddr2_141to190.h    |   23 +
 .../mach-tcc8900/tcc8900/tcc_ckcddr2_200to290.c    | 2287 ++++++++++
 .../mach-tcc8900/tcc8900/tcc_ckcddr2_200to290.h    |   24 +
 .../mach-tcc8900/tcc8900/tcc_ckcddr2_300to330.c    |  916 ++++
 .../mach-tcc8900/tcc8900/tcc_ckcddr2_300to330.h    |   19 +
 .../mach-tcc8900/tcc8900/tcc_ckcmddr_100to160.c    | 1403 +++++++
 .../mach-tcc8900/tcc8900/tcc_ckcmddr_100to160.h    |   27 +
 arch/arm/mach-tcc8900/tcc8900/tcc_ckcmddr_20to90.c | 1570 +++++++
 arch/arm/mach-tcc8900/tcc8900/tcc_ckcmddr_20to90.h |   29 +
 arch/arm/mach-tcc8900/tcc_ckc_ctrl.c               |  744 ++++
 arch/arm/mach-tcc8900/time.c                       |  135 +
 arch/arm/mm/Kconfig                                |    3 +-
 arch/arm/mm/init.c                                 |    3 +
 arch/arm/mm/mmu.c                                  |    6 +
 arch/arm/plat-tcc/Makefile                         |   10 +
 arch/arm/plat-tcc/include/plat/dpm.h               |  169 +
 arch/arm/plat-tcc/tcc_dpm.c                        |  896 ++++
 arch/arm/tools/mach-types                          |    4 +
 drivers/Kconfig                                    |    2 +
 drivers/Makefile                                   |    5 +-
 drivers/ata/Kconfig                                |    8 +
 drivers/ata/Makefile                               |    1 +
 drivers/ata/sata_snps.c                            | 1294 ++++++
 drivers/ata/sata_snps.h                            |  157 +
 drivers/base/power/Makefile                        |    1 +
 drivers/base/power/power-dpm.c                     |  464 ++
 drivers/char/Kconfig                               |   29 +
 drivers/char/Makefile                              |    8 +
 drivers/char/tca_backlight.c                       |  133 +
 drivers/char/tca_backlight.h                       |   74 +
 drivers/char/tcc_backlight.c                       |  362 ++
 drivers/char/tcc_ckc_ioctl.c                       |  295 ++
 drivers/char/tcc_intr.c                            |  578 +++
 drivers/char/tcc_ll.c                              |  256 ++
 drivers/char/tcc_proc.c                            |   92 +
 drivers/char/tcc_pwm.c                             |  118 +
 drivers/char/tcc_pwrkey.c                          |  454 ++
 drivers/dpm/Kconfig                                |   29 +
 drivers/dpm/Makefile                               |    7 +
 drivers/dpm/dpm-idle.c                             |  174 +
 drivers/dpm/dpm-ui.c                               | 1378 ++++++
 drivers/dpm/dpm.c                                  | 1141 +++++
 drivers/dpm/proc.c                                 |  613 +++
 drivers/i2c/busses/Kconfig                         |    9 +
 drivers/i2c/busses/Makefile                        |    5 +
 drivers/i2c/busses/i2c-tcc.c                       |  474 +++
 drivers/i2c/busses/tcc                             |    1 +
 drivers/i2c/busses/tcc8900/tca_i2c.c               |   82 +
 drivers/i2c/busses/tcc8900/tca_i2c.h               |   43 +
 drivers/i2c/chips/Kconfig                          |   12 +
 drivers/i2c/chips/Makefile                         |    2 +
 drivers/i2c/chips/tcc_pca953x.c                    |  257 ++
 drivers/i2c/chips/tcc_wm8731.c                     |   99 +
 drivers/i2c/i2c-core.c                             |    5 +
 drivers/i2c/i2c-dev.c                              |   16 +
 drivers/ide/Kconfig                                |   11 +
 drivers/ide/Makefile                               |    2 +
 drivers/ide/tcc89x_ide.c                           |  329 ++
 drivers/input/touchscreen/Kconfig                  |   31 +
 drivers/input/touchscreen/Makefile                 |    4 +
 drivers/input/touchscreen/tcc_ts.c                 |  695 +++
 drivers/media/video/Kconfig                        |    2 +
 drivers/media/video/Makefile                       |    2 +
 drivers/media/video/tcccam/Kconfig                 |   44 +
 drivers/media/video/tcccam/Makefile                |   13 +
 drivers/media/video/tcccam/cam.c                   |    1 +
 drivers/media/video/tcccam/cam.h                   |    1 +
 drivers/media/video/tcccam/cam_reg.h               |    1 +
 drivers/media/video/tcccam/camera_core.c           | 1032 +++++
 drivers/media/video/tcccam/camera_core.h           |  137 +
 drivers/media/video/tcccam/camera_hw_if.h          |   22 +
 drivers/media/video/tcccam/mt9d111_2mp.c           |  698 +++
 drivers/media/video/tcccam/mt9d111_2mp.h           |   63 +
 drivers/media/video/tcccam/mt9d112_2mp.c           |  987 +++++
 drivers/media/video/tcccam/mt9d112_2mp.h           |   64 +
 drivers/media/video/tcccam/mt9p111_5mp.c           | 1264 ++++++
 drivers/media/video/tcccam/mt9p111_5mp.h           |   64 +
 drivers/media/video/tcccam/mv9317_3mp.c            |  303 ++
 drivers/media/video/tcccam/mv9317_3mp.h            |   64 +
 drivers/media/video/tcccam/s5k4bafb_2mp.c          | 2793 ++++++++++++
 drivers/media/video/tcccam/s5k4bafb_2mp.h          |   63 +
 drivers/media/video/tcccam/sensor_if.c             |  831 ++++
 drivers/media/video/tcccam/sensor_if.h             |   61 +
 drivers/media/video/tcccam/tcc_cam.c               | 1397 ++++++
 drivers/media/video/tcccam/tcc_cam.h               |  367 ++
 drivers/media/video/tcccam/tcc_cam_i2c.c           |  478 +++
 drivers/media/video/tcccam/tcc_cam_i2c.h           |  104 +
 drivers/media/video/tcccam/tcc_cam_inc.h           |   17 +
 drivers/media/video/tcccam/tdd_cif.c               | 2881 +++++++++++++
 drivers/media/video/tcccam/tdd_cif.h               |    1 +
 drivers/mmc/core/sdio_cis.c                        |    4 +-
 drivers/mmc/host/Kconfig                           |   20 +
 drivers/mmc/host/Makefile                          |    1 +
 drivers/mmc/host/tcc_sdhc.c                        | 1294 ++++++
 drivers/mmc/host/tcc_sdhc.h                        |  224 +
 drivers/rtc/Kconfig                                |    9 +
 drivers/rtc/Makefile                               |    5 +
 drivers/rtc/rtc-tcc.c                              |  476 +++
 drivers/rtc/tcc                                    |    1 +
 drivers/rtc/tcc8900/tca_alarm.c                    |  303 ++
 drivers/rtc/tcc8900/tca_alarm.h                    |   71 +
 drivers/rtc/tcc8900/tca_rtc.c                      |  187 +
 drivers/rtc/tcc8900/tca_rtc.h                      |   76 +
 drivers/serial/Kconfig                             |   34 +
 drivers/serial/Makefile                            |    7 +
 drivers/serial/tcc                                 |    1 +
 drivers/serial/tcc8900/tca_serial.c                |  450 ++
 drivers/serial/tcc8900/tca_serial.h                |   52 +
 drivers/serial/tcc_serial.c                        | 1694 ++++++++
 drivers/serial/tcc_serial.h                        |   75 +
 drivers/spi/Kconfig                                |   14 +
 drivers/spi/Makefile                               |    9 +
 drivers/spi/spi.c                                  |    3 +
 drivers/spi/spidev.c                               |   20 +
 drivers/spi/tcc8900/tca_spi_hwset.c                |  328 ++
 drivers/spi/tcc8900/tca_spi_hwset.h                |  116 +
 drivers/spi/tcc_spi.c                              |  590 +++
 drivers/spi/tcc_tsif.c                             |  535 +++
 drivers/usb/Kconfig                                |    3 +
 drivers/usb/Makefile                               |    2 +
 drivers/usb/core/otg_whitelist.h                   |    1 +
 drivers/usb/core/quirks.c                          |    2 +-
 drivers/usb/dwc_otg/Kconfig                        |   49 +
 drivers/usb/dwc_otg/Makefile                       |   37 +
 drivers/usb/dwc_otg/dwc_otg_attr.c                 |  792 ++++
 drivers/usb/dwc_otg/dwc_otg_attr.h                 |   67 +
 drivers/usb/dwc_otg/dwc_otg_cil.c                  | 3384 +++++++++++++++
 drivers/usb/dwc_otg/dwc_otg_cil.h                  |  894 ++++
 drivers/usb/dwc_otg/dwc_otg_cil_intr.c             |  725 ++++
 drivers/usb/dwc_otg/dwc_otg_driver.c               | 1582 +++++++
 drivers/usb/dwc_otg/dwc_otg_driver.h               |   80 +
 drivers/usb/dwc_otg/dwc_otg_hcd.c                  | 2760 ++++++++++++
 drivers/usb/dwc_otg/dwc_otg_hcd.h                  |  650 +++
 drivers/usb/dwc_otg/dwc_otg_hcd_intr.c             | 1820 ++++++++
 drivers/usb/dwc_otg/dwc_otg_hcd_queue.c            |  660 +++
 drivers/usb/dwc_otg/dwc_otg_pcd.c                  | 1665 ++++++++
 drivers/usb/dwc_otg/dwc_otg_pcd.h                  |  214 +
 drivers/usb/dwc_otg/dwc_otg_pcd_intr.c             | 2713 ++++++++++++
 drivers/usb/dwc_otg/dwc_otg_plat.h                 |  291 ++
 drivers/usb/dwc_otg/dwc_otg_regs.h                 | 1884 +++++++++
 drivers/usb/dwc_otg/tcc_usb_def.h                  |   59 +
 drivers/usb/dwc_otg/tcc_usb_phy.c                  |  181 +
 drivers/usb/dwc_otg/tcc_usb_phy.h                  |   24 +
 drivers/usb/gadget/Kconfig                         |   18 +
 drivers/usb/gadget/Makefile                        |    1 +
 drivers/usb/gadget/file_storage.c                  |  331 ++-
 drivers/usb/gadget/gadget_chips.h                  |    9 +
 drivers/usb/host/Kconfig                           |    2 +-
 drivers/usb/host/ohci-hcd.c                        |    5 +
 drivers/usb/host/ohci-tcc.c                        |  488 +++
 drivers/video/Kconfig                              |   15 +
 drivers/video/Makefile                             |    1 +
 drivers/video/logo/logo_linux_clut224.ppm          | 4428 +++++++++++++-------
 drivers/video/tca_backlight.h                      |    1 +
 drivers/video/tca_lcdc.c                           |  781 ++++
 drivers/video/tca_tvout.c                          |  930 ++++
 drivers/video/tca_tvout.h                          |   84 +
 drivers/video/tccfb.c                              | 3013 +++++++++++++
 drivers/video/tccfb.h                              |   52 +
 include/linux/device.h                             |    4 +-
 include/linux/dpm-trace.h                          |   63 +
 include/linux/dpm.h                                |  410 ++
 include/linux/i2c-dev.h                            |    4 +
 include/linux/i2c-id.h                             |   10 +
 include/linux/i2c.h                                |    3 +
 include/linux/mmc/sdio_ids.h                       |    3 +
 include/linux/pm.h                                 |   33 +
 include/linux/sched.h                              |    3 +
 include/linux/serial_core.h                        |    4 +
 include/linux/spi/spi.h                            |   20 +
 include/linux/spi/tcc_tsif.h                       |   51 +
 include/linux/tcc_intr.h                           |   41 +
 include/linux/tcc_ioctl.h                          |   83 +
 include/linux/tcc_ll.h                             |   53 +
 include/linux/tcc_pwm.h                            |    1 +
 include/linux/tcc_pwm_ioctl.h                      |   10 +
 include/linux/tccfb_ioctl.h                        |  308 ++
 init/initramfs.c                                   |    1 +
 initrd_tcc_mkrd.sh                                 |   31 +
 sound/soc/Kconfig                                  |    1 +
 sound/soc/Makefile                                 |    2 +-
 sound/soc/codecs/Kconfig                           |    3 +
 sound/soc/codecs/Makefile                          |    2 +
 sound/soc/codecs/wm8581.c                          | 1296 ++++++
 sound/soc/codecs/wm8581.h                          |   43 +
 sound/soc/codecs/wm8731.c                          |  165 +-
 sound/soc/tcc/Kconfig                              |   36 +
 sound/soc/tcc/Makefile                             |   17 +
 sound/soc/tcc/tcc-i2s.c                            |  296 ++
 sound/soc/tcc/tcc-i2s.h                            |  133 +
 sound/soc/tcc/tcc-loopback.c                       |  177 +
 sound/soc/tcc/tcc-loopback.h                       |   74 +
 sound/soc/tcc/tcc-pcm.c                            |  918 ++++
 sound/soc/tcc/tcc-pcm.h                            |  119 +
 sound/soc/tcc/tcc8900/tca_tcchwcontrol.c           |  633 +++
 sound/soc/tcc/tcc8900/tca_tcchwcontrol.h           |   60 +
 sound/soc/tcc/tcc_board.c                          |  444 ++
 sound/soc/tcc/tcc_board_wm8581.c                   |  456 ++
 tcc_mkrd.sh                                        |   42 +
 248 files changed, 88295 insertions(+), 1699 deletions(-)
 create mode 100644 arch/arm/configs/tcc8900_defconfig
 create mode 100644 arch/arm/configs/tcc8900_wifi_defconfig
 create mode 100644 arch/arm/mach-tcc8900/Kconfig
 create mode 100644 arch/arm/mach-tcc8900/Makefile
 create mode 100644 arch/arm/mach-tcc8900/Makefile.boot
 create mode 100644 arch/arm/mach-tcc8900/board-tcc8900.c
 create mode 100644 arch/arm/mach-tcc8900/devices.c
 create mode 100644 arch/arm/mach-tcc8900/gpio.c
 create mode 100644 arch/arm/mach-tcc8900/idle.c
 create mode 100644 arch/arm/mach-tcc8900/include/bsp.h
 create mode 100644 arch/arm/mach-tcc8900/include/mach/TCC89x_Physical.h
 create mode 100644 arch/arm/mach-tcc8900/include/mach/TCC89x_Structures.h
 create mode 100644 arch/arm/mach-tcc8900/include/mach/bsp_cfg.h
 create mode 100644 arch/arm/mach-tcc8900/include/mach/common.h
 create mode 100644 arch/arm/mach-tcc8900/include/mach/debug-macro.S
 create mode 100644 arch/arm/mach-tcc8900/include/mach/dma.h
 create mode 100644 arch/arm/mach-tcc8900/include/mach/entry-macro.S
 create mode 100644 arch/arm/mach-tcc8900/include/mach/globals.h
 create mode 100644 arch/arm/mach-tcc8900/include/mach/gpio.h
 create mode 100644 arch/arm/mach-tcc8900/include/mach/hardware.h
 create mode 100644 arch/arm/mach-tcc8900/include/mach/io.h
 create mode 100644 arch/arm/mach-tcc8900/include/mach/ioctl_ckcstr.h
 create mode 100644 arch/arm/mach-tcc8900/include/mach/irqs.h
 create mode 100644 arch/arm/mach-tcc8900/include/mach/memory.h
 create mode 100644 arch/arm/mach-tcc8900/include/mach/ohci.h
 create mode 100644 arch/arm/mach-tcc8900/include/mach/reg_physical.h
 create mode 100644 arch/arm/mach-tcc8900/include/mach/system.h
 create mode 100644 arch/arm/mach-tcc8900/include/mach/system_type.h
 create mode 100644 arch/arm/mach-tcc8900/include/mach/tca_ckc.h
 create mode 100644 arch/arm/mach-tcc8900/include/mach/tcc_ckc_ctrl.h
 create mode 100644 arch/arm/mach-tcc8900/include/mach/tcc_pca953x.h
 create mode 100644 arch/arm/mach-tcc8900/include/mach/timex.h
 create mode 100644 arch/arm/mach-tcc8900/include/mach/uncompress.h
 create mode 100644 arch/arm/mach-tcc8900/include/mach/vmalloc.h
 create mode 100644 arch/arm/mach-tcc8900/io.c
 create mode 100644 arch/arm/mach-tcc8900/irq.c
 create mode 100644 arch/arm/mach-tcc8900/tca_ckc.c
 create mode 120000 arch/arm/mach-tcc8900/tcc
 create mode 100644 arch/arm/mach-tcc8900/tcc8900/arm_ioctlutil.S
 create mode 100644 arch/arm/mach-tcc8900/tcc8900/tcc_ckcddr2_141to190.c
 create mode 100644 arch/arm/mach-tcc8900/tcc8900/tcc_ckcddr2_141to190.h
 create mode 100644 arch/arm/mach-tcc8900/tcc8900/tcc_ckcddr2_200to290.c
 create mode 100644 arch/arm/mach-tcc8900/tcc8900/tcc_ckcddr2_200to290.h
 create mode 100644 arch/arm/mach-tcc8900/tcc8900/tcc_ckcddr2_300to330.c
 create mode 100644 arch/arm/mach-tcc8900/tcc8900/tcc_ckcddr2_300to330.h
 create mode 100644 arch/arm/mach-tcc8900/tcc8900/tcc_ckcmddr_100to160.c
 create mode 100644 arch/arm/mach-tcc8900/tcc8900/tcc_ckcmddr_100to160.h
 create mode 100644 arch/arm/mach-tcc8900/tcc8900/tcc_ckcmddr_20to90.c
 create mode 100644 arch/arm/mach-tcc8900/tcc8900/tcc_ckcmddr_20to90.h
 create mode 100644 arch/arm/mach-tcc8900/tcc_ckc_ctrl.c
 create mode 100644 arch/arm/mach-tcc8900/time.c
 create mode 100644 arch/arm/plat-tcc/Makefile
 create mode 100644 arch/arm/plat-tcc/include/plat/dpm.h
 create mode 100644 arch/arm/plat-tcc/tcc_dpm.c
 create mode 100644 drivers/ata/sata_snps.c
 create mode 100644 drivers/ata/sata_snps.h
 create mode 100644 drivers/base/power/power-dpm.c
 create mode 100644 drivers/char/tca_backlight.c
 create mode 100644 drivers/char/tca_backlight.h
 create mode 100644 drivers/char/tcc_backlight.c
 create mode 100644 drivers/char/tcc_ckc_ioctl.c
 create mode 100644 drivers/char/tcc_intr.c
 create mode 100644 drivers/char/tcc_ll.c
 create mode 100644 drivers/char/tcc_proc.c
 create mode 100644 drivers/char/tcc_pwm.c
 create mode 100644 drivers/char/tcc_pwrkey.c
 create mode 100644 drivers/dpm/Kconfig
 create mode 100644 drivers/dpm/Makefile
 create mode 100644 drivers/dpm/dpm-idle.c
 create mode 100644 drivers/dpm/dpm-ui.c
 create mode 100644 drivers/dpm/dpm.c
 create mode 100644 drivers/dpm/proc.c
 create mode 100644 drivers/i2c/busses/i2c-tcc.c
 create mode 120000 drivers/i2c/busses/tcc
 create mode 100644 drivers/i2c/busses/tcc8900/tca_i2c.c
 create mode 100644 drivers/i2c/busses/tcc8900/tca_i2c.h
 create mode 100644 drivers/i2c/chips/tcc_pca953x.c
 create mode 100644 drivers/i2c/chips/tcc_wm8731.c
 create mode 100644 drivers/ide/tcc89x_ide.c
 create mode 100644 drivers/input/touchscreen/tcc_ts.c
 create mode 100644 drivers/media/video/tcccam/Kconfig
 create mode 100644 drivers/media/video/tcccam/Makefile
 create mode 100644 drivers/media/video/tcccam/cam.c
 create mode 100644 drivers/media/video/tcccam/cam.h
 create mode 100644 drivers/media/video/tcccam/cam_reg.h
 create mode 100644 drivers/media/video/tcccam/camera_core.c
 create mode 100644 drivers/media/video/tcccam/camera_core.h
 create mode 100644 drivers/media/video/tcccam/camera_hw_if.h
 create mode 100644 drivers/media/video/tcccam/mt9d111_2mp.c
 create mode 100644 drivers/media/video/tcccam/mt9d111_2mp.h
 create mode 100644 drivers/media/video/tcccam/mt9d112_2mp.c
 create mode 100644 drivers/media/video/tcccam/mt9d112_2mp.h
 create mode 100644 drivers/media/video/tcccam/mt9p111_5mp.c
 create mode 100644 drivers/media/video/tcccam/mt9p111_5mp.h
 create mode 100644 drivers/media/video/tcccam/mv9317_3mp.c
 create mode 100644 drivers/media/video/tcccam/mv9317_3mp.h
 create mode 100644 drivers/media/video/tcccam/s5k4bafb_2mp.c
 create mode 100644 drivers/media/video/tcccam/s5k4bafb_2mp.h
 create mode 100644 drivers/media/video/tcccam/sensor_if.c
 create mode 100644 drivers/media/video/tcccam/sensor_if.h
 create mode 100644 drivers/media/video/tcccam/tcc_cam.c
 create mode 100644 drivers/media/video/tcccam/tcc_cam.h
 create mode 100644 drivers/media/video/tcccam/tcc_cam_i2c.c
 create mode 100644 drivers/media/video/tcccam/tcc_cam_i2c.h
 create mode 100644 drivers/media/video/tcccam/tcc_cam_inc.h
 create mode 100644 drivers/media/video/tcccam/tdd_cif.c
 create mode 100644 drivers/media/video/tcccam/tdd_cif.h
 create mode 100644 drivers/mmc/host/tcc_sdhc.c
 create mode 100644 drivers/mmc/host/tcc_sdhc.h
 create mode 100644 drivers/rtc/rtc-tcc.c
 create mode 120000 drivers/rtc/tcc
 create mode 100644 drivers/rtc/tcc8900/tca_alarm.c
 create mode 100644 drivers/rtc/tcc8900/tca_alarm.h
 create mode 100644 drivers/rtc/tcc8900/tca_rtc.c
 create mode 100644 drivers/rtc/tcc8900/tca_rtc.h
 create mode 120000 drivers/serial/tcc
 create mode 100644 drivers/serial/tcc8900/tca_serial.c
 create mode 100644 drivers/serial/tcc8900/tca_serial.h
 create mode 100644 drivers/serial/tcc_serial.c
 create mode 100644 drivers/serial/tcc_serial.h
 create mode 100644 drivers/spi/tcc8900/tca_spi_hwset.c
 create mode 100644 drivers/spi/tcc8900/tca_spi_hwset.h
 create mode 100644 drivers/spi/tcc_spi.c
 create mode 100644 drivers/spi/tcc_tsif.c
 create mode 100644 drivers/usb/dwc_otg/Kconfig
 create mode 100644 drivers/usb/dwc_otg/Makefile
 create mode 100644 drivers/usb/dwc_otg/dwc_otg_attr.c
 create mode 100644 drivers/usb/dwc_otg/dwc_otg_attr.h
 create mode 100644 drivers/usb/dwc_otg/dwc_otg_cil.c
 create mode 100644 drivers/usb/dwc_otg/dwc_otg_cil.h
 create mode 100644 drivers/usb/dwc_otg/dwc_otg_cil_intr.c
 create mode 100644 drivers/usb/dwc_otg/dwc_otg_driver.c
 create mode 100644 drivers/usb/dwc_otg/dwc_otg_driver.h
 create mode 100644 drivers/usb/dwc_otg/dwc_otg_hcd.c
 create mode 100644 drivers/usb/dwc_otg/dwc_otg_hcd.h
 create mode 100644 drivers/usb/dwc_otg/dwc_otg_hcd_intr.c
 create mode 100644 drivers/usb/dwc_otg/dwc_otg_hcd_queue.c
 create mode 100644 drivers/usb/dwc_otg/dwc_otg_pcd.c
 create mode 100644 drivers/usb/dwc_otg/dwc_otg_pcd.h
 create mode 100644 drivers/usb/dwc_otg/dwc_otg_pcd_intr.c
 create mode 100644 drivers/usb/dwc_otg/dwc_otg_plat.h
 create mode 100644 drivers/usb/dwc_otg/dwc_otg_regs.h
 create mode 100644 drivers/usb/dwc_otg/tcc_usb_def.h
 create mode 100644 drivers/usb/dwc_otg/tcc_usb_phy.c
 create mode 100644 drivers/usb/dwc_otg/tcc_usb_phy.h
 create mode 100644 drivers/usb/host/ohci-tcc.c
 create mode 120000 drivers/video/tca_backlight.h
 create mode 100644 drivers/video/tca_lcdc.c
 create mode 100644 drivers/video/tca_tvout.c
 create mode 100644 drivers/video/tca_tvout.h
 create mode 100644 drivers/video/tccfb.c
 create mode 100644 drivers/video/tccfb.h
 create mode 100644 include/linux/dpm-trace.h
 create mode 100644 include/linux/dpm.h
 create mode 100644 include/linux/spi/tcc_tsif.h
 create mode 100644 include/linux/tcc_intr.h
 create mode 100644 include/linux/tcc_ioctl.h
 create mode 100644 include/linux/tcc_ll.h
 create mode 120000 include/linux/tcc_pwm.h
 create mode 100644 include/linux/tcc_pwm_ioctl.h
 create mode 100644 include/linux/tccfb_ioctl.h
 create mode 100644 initrd_tcc_mkrd.sh
 create mode 100644 sound/soc/codecs/wm8581.c
 create mode 100644 sound/soc/codecs/wm8581.h
 create mode 100644 sound/soc/tcc/Kconfig
 create mode 100644 sound/soc/tcc/Makefile
 create mode 100644 sound/soc/tcc/tcc-i2s.c
 create mode 100644 sound/soc/tcc/tcc-i2s.h
 create mode 100644 sound/soc/tcc/tcc-loopback.c
 create mode 100644 sound/soc/tcc/tcc-loopback.h
 create mode 100644 sound/soc/tcc/tcc-pcm.c
 create mode 100644 sound/soc/tcc/tcc-pcm.h
 create mode 100644 sound/soc/tcc/tcc8900/tca_tcchwcontrol.c
 create mode 100644 sound/soc/tcc/tcc8900/tca_tcchwcontrol.h
 create mode 100644 sound/soc/tcc/tcc_board.c
 create mode 100644 sound/soc/tcc/tcc_board_wm8581.c
 create mode 100755 tcc_mkrd.sh

Index: linux-2.6.29/Makefile
===================================================================
--- linux-2.6.29.orig/Makefile	2010-04-07 12:29:33.000000000 -0400
+++ linux-2.6.29/Makefile	2010-04-07 13:00:58.000000000 -0400
@@ -190,8 +190,9 @@
 # Default value for CROSS_COMPILE is not to prefix executables
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
 export KBUILD_BUILDHOST := $(SUBARCH)
-ARCH		?= $(SUBARCH)
-CROSS_COMPILE	?=
+ARCH           ?= arm
+CROSS_COMPILE  ?= /opt/armv6/codesourcery/bin/arm-none-linux-gnueabi-
+#CROSS_COMPILE  ?= /opt/codesourcery/bin/arm-none-linux-gnueabi-
 
 # Architecture as present in compile.h
 UTS_MACHINE 	:= $(ARCH)
@@ -344,9 +345,9 @@
 
 KBUILD_CPPFLAGS := -D__KERNEL__
 
+#Debug KERNEL
 KBUILD_CFLAGS   := -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs \
-		   -fno-strict-aliasing -fno-common \
-		   -Werror-implicit-function-declaration
+		   -fno-strict-aliasing -fno-common
 KBUILD_AFLAGS   := -D__ASSEMBLY__
 
 # Read KERNELRELEASE from include/config/kernel.release (if it exists)
@@ -532,6 +533,21 @@
 KBUILD_CFLAGS += $(call cc-option,-Wframe-larger-than=${CONFIG_FRAME_WARN})
 endif
 
+ifeq ($(CONFIG_ARCH_TCC), y)
+#	KBUILD_CFLAGS += -D_TCC_ -D_LINUX_
+	KBUILD_CPPFLAGS += -D_TCC_ -D_LINUX_
+	ARCH_DIR := $(TCC_STRING)
+endif
+
+ifeq ($(CONFIG_TCC_R_AX), y)
+	KBUILD_CFLAGS += -DTCC_R_AX
+	KBUILD_CPPFLAGS += -DTCC_R_AX
+endif
+ifeq ($(CONFIG_TCC_R_XX), y)
+	KBUILD_CFLAGS += -DTCC_R_XX
+	KBUILD_CPPFLAGS += -DTCC_R_XX
+endif
+
 # Force gcc to behave correct even for buggy distributions
 # Arch Makefiles may override this setting
 KBUILD_CFLAGS += $(call cc-option, -fno-stack-protector)
@@ -699,6 +715,7 @@
 # Generate new vmlinux version
 quiet_cmd_vmlinux_version = GEN     .version
       cmd_vmlinux_version = set -e;                     \
+	if [ ! -d .svn ]; then\
 	if [ ! -r .version ]; then			\
 	  rm -f .version;				\
 	  echo 1 >.version;				\
@@ -706,6 +723,9 @@
 	  mv .version .old_version;			\
 	  expr 0$$(cat .old_version) + 1 >.version;	\
 	fi;						\
+	else\
+	  echo $(shell svnversion -n .) >.version;\
+	fi;\
 	$(MAKE) $(build)=init
 
 # Generate System.map
@@ -1208,6 +1228,7 @@
 	$(Q)$(MAKE) $(clean)=$(patsubst _clean_%,%,$@)
 
 clean: archclean $(clean-dirs)
+	@rm -f linux.rom
 	$(call cmd,rmdirs)
 	$(call cmd,rmfiles)
 	@find . $(RCS_FIND_IGNORE) \
@@ -1242,6 +1263,9 @@
 		-o -name '.*.rej' -o -size 0 \
 		-o -name '*%' -o -name '.*.cmd' -o -name 'core' \) \
 		-type f -print | xargs rm -f
+	@find $(srctree) $(RCS_FIND_IGNORE) \
+		\( -name 'tcc' \) \
+		-type l -print | xargs rm -f
 
 
 # Packaging of the kernel to various formats
Index: linux-2.6.29/arch/arm/Kconfig
===================================================================
--- linux-2.6.29.orig/arch/arm/Kconfig	2010-04-07 12:29:33.000000000 -0400
+++ linux-2.6.29/arch/arm/Kconfig	2010-04-07 13:00:43.000000000 -0400
@@ -590,6 +590,12 @@
 		Support for Nuvoton (Winbond logic dept.) ARM9 processor,You
 		can login www.mcuos.com or www.nuvoton.com to know more.
 
+config ARCH_TCC
+	bool "Telechips TCC8900"
+	help
+	  Support for the following Telechips TCC series SoCs:
+	  TCC8900.
+
 endchoice
 
 source "arch/arm/mach-clps711x/Kconfig"
@@ -676,6 +682,10 @@
 
 source "arch/arm/mach-w90x900/Kconfig"
 
+if ARCH_TCC
+source "arch/arm/mach-tcc8900/Kconfig"
+endif
+
 # Definitions to make life easier
 config ARCH_ACORN
 	bool
@@ -1220,6 +1230,8 @@
 
 source "kernel/power/Kconfig"
 
+source "drivers/dpm/Kconfig"
+
 config ARCH_SUSPEND_POSSIBLE
 	def_bool y
 
Index: linux-2.6.29/arch/arm/Makefile
===================================================================
--- linux-2.6.29.orig/arch/arm/Makefile	2010-04-07 12:29:32.000000000 -0400
+++ linux-2.6.29/arch/arm/Makefile	2010-04-07 12:29:36.000000000 -0400
@@ -95,6 +95,9 @@
 head-y		:= arch/arm/kernel/head$(MMUEXT).o arch/arm/kernel/init_task.o
 textofs-y	:= 0x00008000
 
+ machine-$(CONFIG_ARCH_TCC)		:= tcc8900
+    plat-$(CONFIG_ARCH_TCC) 	:= tcc
+ textofs-$(CONFIG_ARCH_TCC)	   	:= 0x00100000
  machine-$(CONFIG_ARCH_RPC)	   := rpc
  machine-$(CONFIG_ARCH_EBSA110)	   := ebsa110
  machine-$(CONFIG_FOOTBRIDGE)	   := footbridge
Index: linux-2.6.29/arch/arm/configs/tcc8900_defconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/configs/tcc8900_defconfig	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,1422 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.28
+# Fri Sep  4 12:18:28 2009
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+# CONFIG_GENERIC_GPIO is not set
+# CONFIG_GENERIC_TIME is not set
+# CONFIG_GENERIC_CLOCKEVENTS is not set
+CONFIG_MMU=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=17
+# CONFIG_CGROUPS is not set
+# CONFIG_GROUP_SCHED is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+CONFIG_RELAY=y
+CONFIG_NAMESPACES=y
+# CONFIG_UTS_NS is not set
+# CONFIG_IPC_NS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+# CONFIG_EMBEDDED is not set
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_KMOD=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_CLASSIC_RCU=y
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_MSM is not set
+CONFIG_ARCH_TCC=y
+
+#
+# Boot options
+#
+
+#
+# Power management
+#
+
+#
+# TCC Core Type
+#
+CONFIG_ARCH_TCC8900=y
+CONFIG_TCC_R_AX=y
+# CONFIG_TCC_R_XX is not set
+
+#
+# TCC Board Type
+#
+CONFIG_MACH_TCC8900=y
+CONFIG_DRAM_DDR2=y
+# CONFIG_DRAM_MDDR is not set
+# CONFIG_RAM_128MB is not set
+CONFIG_RAM_256MB=y
+# CONFIG_HD720p_LEVEL41 is not set
+# CONFIG_HD720p_LEVEL51 is not set
+# CONFIG_HD1080p_LEVEL41 is not set
+CONFIG_HD1080p_LEVEL51=y
+CONFIG_TCC_STRING="tcc8900"
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_V6=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v6=y
+CONFIG_CPU_ABRT_EV6=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_V6=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V6=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+# CONFIG_OUTER_CACHE is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT is not set
+CONFIG_HZ=100
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_UNEVICTABLE_LRU is not set
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="root=/dev/ram rw initrd=0x40700000,0x1000000 init=/linuxrc console=ttySAC0"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+CONFIG_BINFMT_AOUT=y
+CONFIG_BINFMT_MISC=y
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_APM_EMULATION is not set
+
+#
+# Dynamic Power Management
+#
+CONFIG_DPM=y
+CONFIG_DPM_PROCFS=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_PHONET is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+CONFIG_DEBUG_DEVRES=y
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=2
+CONFIG_BLK_DEV_RAM_SIZE=16384
+# CONFIG_BLK_DEV_XIP is not set
+CONFIG_CDROM_PKTCDVD=y
+CONFIG_CDROM_PKTCDVD_BUFFERS=8
+# CONFIG_CDROM_PKTCDVD_WCACHE is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MISC_DEVICES is not set
+CONFIG_HAVE_IDE=y
+CONFIG_IDE=y
+
+#
+# Please see Documentation/ide/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_IDE_GD=y
+CONFIG_IDE_GD_ATA=y
+# CONFIG_IDE_GD_ATAPI is not set
+CONFIG_BLK_DEV_IDECD=y
+CONFIG_BLK_DEV_IDECD_VERBOSE_ERRORS=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+CONFIG_IDE_TASK_IOCTL=y
+CONFIG_IDE_PROC_FS=y
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_BLK_DEV_PLATFORM=y
+# CONFIG_BLK_DEV_PATA_TCC89X is not set
+# CONFIG_BLK_DEV_IDEDMA is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=y
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_DH is not set
+CONFIG_ATA=y
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_SATA_PMP=y
+CONFIG_ATA_SFF=y
+# CONFIG_SATA_MV is not set
+CONFIG_SATA_TCC=y
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_ENC28J60 is not set
+# CONFIG_SMC911X is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_IWLWIFI_LEDS is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_FF_MEMLESS=y
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+CONFIG_TOUCHSCREEN_TCCTS=y
+# CONFIG_LCD01 is not set
+CONFIG_LCD11=y
+# CONFIG_LCD10 is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+# CONFIG_DEVKMEM is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_TCC=y
+CONFIG_SERIAL_TCC_CONSOLE=y
+CONFIG_SERIAL_TCC_DMA=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_TCC_CKC_IOCTL=y
+CONFIG_TCC_USER_INTR=y
+CONFIG_TCC_BL=y
+CONFIG_TCC_POWER_CTL=y
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_HELPER_AUTO is not set
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_SIMTEC is not set
+CONFIG_I2C_TCC=y
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_AT24 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+CONFIG_TCC_I2C_WM8731=y
+CONFIG_TCC_I2C_PCA953X=y
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_BITBANG is not set
+
+#
+# Telechips GPSB (General Purpose Serial Bus) Controller Drivers
+#
+# CONFIG_SPI_TCC_MASTER is not set
+CONFIG_TSIF_TCC_SLAVE=y
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_AT25 is not set
+CONFIG_SPI_SPIDEV=y
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_VIDEO_MEDIA is not set
+
+#
+# Multimedia drivers
+#
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+CONFIG_FB_TILEBLITTING=y
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D13XXX is not set
+CONFIG_FB_TCC8900=y
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+CONFIG_SND_ARM=y
+CONFIG_SND_SPI=y
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_CAIAQ is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_TCC_SOC=y
+CONFIG_SND_TCC_SOC_I2S=y
+CONFIG_SND_TCC_SOC_BOARD_WM8731=y
+# CONFIG_SND_TCC_SOC_BOARD_WM8581 is not set
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_WM8731=y
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+CONFIG_HID_DEBUG=y
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+CONFIG_HID_COMPAT=y
+CONFIG_HID_A4TECH=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_BRIGHT=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DELL=y
+CONFIG_HID_EZKEY=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_LOGITECH=y
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_PANTHERLORD=y
+# CONFIG_PANTHERLORD_FF is not set
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+# CONFIG_THRUSTMASTER_FF is not set
+# CONFIG_ZEROPLUS_FF is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+# CONFIG_USB_DEVICE_CLASS is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_SUSPEND=y
+CONFIG_USB_OTG=y
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# Telechips DWC OTG Controller Drivers
+#
+CONFIG_TCC_DWC_OTG=y
+CONFIG_TCC_DWC_OTG_DUAL_ROLE=y
+# CONFIG_TCC_DWC_OTG_DEVICE_ONLY is not set
+# CONFIG_TCC_DWC_OTG_HOST_ONLY is not set
+# CONFIG_TCC_DWC_OTG_DEBUG is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_GADGET_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
+#
+
+#
+# see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+CONFIG_USB_GADGET_TCC_OTG=y
+CONFIG_USB_TCC_OTG=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+CONFIG_USB_FILE_STORAGE=m
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_SPI is not set
+CONFIG_MMC_TCC_SDHC=y
+CONFIG_MMC_TCC_SDHC_CORE0=y
+# CONFIG_MMC_TCC_SDHC_CORE1 is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_RTC_DRV_TCC=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_UIO is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+# CONFIG_EXT4_FS is not set
+CONFIG_JBD=y
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_FILE_LOCKING=y
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_DNOTIFY is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+CONFIG_AUTOFS_FS=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=y
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+CONFIG_UDF_FS=y
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+# CONFIG_ROOT_NFS is not set
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+# CONFIG_SUNRPC_REGISTER_V4 is not set
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_UNUSED_SYMBOLS=y
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC=y
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=1
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+CONFIG_DEBUG_MUTEXES=y
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+
+#
+# Tracers
+#
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_BOOT_TRACER is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_ERRORS is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+CONFIG_CRC_ITU_T=y
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
Index: linux-2.6.29/arch/arm/configs/tcc8900_wifi_defconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/configs/tcc8900_wifi_defconfig	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,1453 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.28
+# Wed Aug  5 16:39:32 2009
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+# CONFIG_GENERIC_GPIO is not set
+# CONFIG_GENERIC_TIME is not set
+# CONFIG_GENERIC_CLOCKEVENTS is not set
+CONFIG_MMU=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=17
+# CONFIG_CGROUPS is not set
+# CONFIG_GROUP_SCHED is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+CONFIG_RELAY=y
+CONFIG_NAMESPACES=y
+# CONFIG_UTS_NS is not set
+# CONFIG_IPC_NS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+# CONFIG_EMBEDDED is not set
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_KMOD=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_CLASSIC_RCU=y
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_MSM is not set
+CONFIG_ARCH_TCC=y
+
+#
+# Boot options
+#
+
+#
+# Power management
+#
+
+#
+# TCC Core Type
+#
+CONFIG_ARCH_TCC8900=y
+CONFIG_TCC_R_AX=y
+# CONFIG_TCC_R_XX is not set
+
+#
+# TCC Board Type
+#
+CONFIG_MACH_TCC8900=y
+# CONFIG_RAM_128MB is not set
+CONFIG_RAM_256MB=y
+CONFIG_DRAM_DDR2=y
+# CONFIG_DRAM_MDDR is not set
+CONFIG_HD720p_LEVEL41=y
+# CONFIG_HD720p_LEVEL51 is not set
+# CONFIG_HD1080p_LEVEL41 is not set
+# CONFIG_HD1080p_LEVEL51 is not set
+CONFIG_TCC_STRING="tcc8900"
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_V6=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v6=y
+CONFIG_CPU_ABRT_EV6=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_V6=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V6=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+# CONFIG_OUTER_CACHE is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT is not set
+CONFIG_HZ=100
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_UNEVICTABLE_LRU is not set
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="root=/dev/ram rw initrd=0x40700000,0x1000000 init=/linuxrc console=ttySAC0"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+CONFIG_BINFMT_AOUT=y
+CONFIG_BINFMT_MISC=y
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_APM_EMULATION is not set
+
+#
+# Dynamic Power Management
+#
+CONFIG_DPM=y
+CONFIG_DPM_PROCFS=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_TCP_MD5SIG=y
+# CONFIG_IPV6 is not set
+CONFIG_NETWORK_SECMARK=y
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+
+#
+# Core Netfilter Configuration
+#
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+# CONFIG_NF_CONNTRACK is not set
+# CONFIG_NETFILTER_XTABLES is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_NF_DEFRAG_IPV4 is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+# CONFIG_NET_SCH_HTB is not set
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+
+#
+# Classification
+#
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_FW is not set
+# CONFIG_NET_CLS_U32 is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_FLOW is not set
+# CONFIG_NET_EMATCH is not set
+# CONFIG_NET_CLS_ACT is not set
+CONFIG_NET_SCH_FIFO=y
+
+#
+# Network testing
+#
+CONFIG_NET_PKTGEN=y
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_PHONET is not set
+CONFIG_WIRELESS=y
+CONFIG_CFG80211=y
+CONFIG_NL80211=y
+CONFIG_WIRELESS_OLD_REGULATORY=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+CONFIG_MAC80211=y
+
+#
+# Rate control algorithm selection
+#
+CONFIG_MAC80211_RC_PID=y
+# CONFIG_MAC80211_RC_MINSTREL is not set
+CONFIG_MAC80211_RC_DEFAULT_PID=y
+# CONFIG_MAC80211_RC_DEFAULT_MINSTREL is not set
+CONFIG_MAC80211_RC_DEFAULT="pid"
+# CONFIG_MAC80211_MESH is not set
+# CONFIG_MAC80211_LEDS is not set
+# CONFIG_MAC80211_DEBUG_MENU is not set
+CONFIG_IEEE80211=y
+CONFIG_IEEE80211_DEBUG=y
+CONFIG_IEEE80211_CRYPT_WEP=y
+CONFIG_IEEE80211_CRYPT_CCMP=y
+CONFIG_IEEE80211_CRYPT_TKIP=y
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+CONFIG_DEBUG_DEVRES=y
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=2
+CONFIG_BLK_DEV_RAM_SIZE=16384
+# CONFIG_BLK_DEV_XIP is not set
+CONFIG_CDROM_PKTCDVD=y
+CONFIG_CDROM_PKTCDVD_BUFFERS=8
+# CONFIG_CDROM_PKTCDVD_WCACHE is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MISC_DEVICES is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=y
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_ENC28J60 is not set
+# CONFIG_SMC911X is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+CONFIG_WLAN_80211=y
+# CONFIG_LIBERTAS is not set
+# CONFIG_LIBERTAS_THINFIRM is not set
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_USB_NET_RNDIS_WLAN is not set
+# CONFIG_RTL8187 is not set
+# CONFIG_MAC80211_HWSIM is not set
+# CONFIG_P54_COMMON is not set
+# CONFIG_IWLWIFI_LEDS is not set
+# CONFIG_HOSTAP is not set
+# CONFIG_B43 is not set
+# CONFIG_B43LEGACY is not set
+# CONFIG_ZD1211RW is not set
+# CONFIG_RT2X00 is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_FF_MEMLESS=y
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+CONFIG_TOUCHSCREEN_TCCTS=y
+# CONFIG_LCD01 is not set
+# CONFIG_LCD11 is not set
+CONFIG_LCD10=y
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+# CONFIG_DEVKMEM is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_TCC=y
+CONFIG_SERIAL_TCC_CONSOLE=y
+CONFIG_SERIAL_TCC_DMA=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_TCC_CKC_IOCTL=y
+CONFIG_TCC_USER_INTR=y
+CONFIG_TCC_BL=y
+CONFIG_TCC_POWER_CTL=y
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_HELPER_AUTO is not set
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_SIMTEC is not set
+CONFIG_I2C_TCC=y
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_AT24 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+CONFIG_TCC_I2C_WM8731=y
+CONFIG_TCC_I2C_PCA953X=y
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_TCC_MASTER is not set
+CONFIG_TSIF_TCC_SLAVE=y
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_AT25 is not set
+CONFIG_SPI_SPIDEV=y
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_VIDEO_MEDIA is not set
+
+#
+# Multimedia drivers
+#
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+CONFIG_FB_TILEBLITTING=y
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D13XXX is not set
+CONFIG_FB_TCC8900=y
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+# CONFIG_SOUND is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+CONFIG_HID_DEBUG=y
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+CONFIG_HID_COMPAT=y
+CONFIG_HID_A4TECH=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_BRIGHT=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DELL=y
+CONFIG_HID_EZKEY=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_LOGITECH=y
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_PANTHERLORD=y
+# CONFIG_PANTHERLORD_FF is not set
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+# CONFIG_THRUSTMASTER_FF is not set
+# CONFIG_ZEROPLUS_FF is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+# CONFIG_USB_DEVICE_CLASS is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_SUSPEND=y
+CONFIG_USB_OTG=y
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# Telechips DWC OTG Controller Drivers
+#
+CONFIG_TCC_DWC_OTG=y
+CONFIG_TCC_DWC_OTG_DUAL_ROLE=y
+# CONFIG_TCC_DWC_OTG_DEVICE_ONLY is not set
+# CONFIG_TCC_DWC_OTG_HOST_ONLY is not set
+# CONFIG_TCC_DWC_OTG_DEBUG is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_GADGET_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
+#
+
+#
+# see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+CONFIG_USB_GADGET_TCC_OTG=y
+CONFIG_USB_TCC_OTG=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+CONFIG_USB_FILE_STORAGE=m
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+CONFIG_MMC=y
+CONFIG_MMC_DEBUG=y
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_SPI is not set
+CONFIG_MMC_TCC_SDHC=y
+CONFIG_MMC_TCC_SDHC_CORE0=y
+# CONFIG_MMC_TCC_SDHC_CORE1 is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_RTC_DRV_TCC=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_UIO is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+# CONFIG_EXT4_FS is not set
+CONFIG_JBD=y
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_FILE_LOCKING=y
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_DNOTIFY is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+CONFIG_AUTOFS_FS=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=y
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+CONFIG_UDF_FS=y
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+# CONFIG_ROOT_NFS is not set
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+# CONFIG_SUNRPC_REGISTER_V4 is not set
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_UNUSED_SYMBOLS=y
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC=y
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=1
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+CONFIG_DEBUG_MUTEXES=y
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+
+#
+# Tracers
+#
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_BOOT_TRACER is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_ERRORS is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_MICHAEL_MIC=y
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+CONFIG_CRC_ITU_T=y
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
Index: linux-2.6.29/arch/arm/include/asm/mach/map.h
===================================================================
--- linux-2.6.29.orig/arch/arm/include/asm/mach/map.h	2010-04-07 12:29:32.000000000 -0400
+++ linux-2.6.29/arch/arm/include/asm/mach/map.h	2010-04-07 12:29:36.000000000 -0400
@@ -26,6 +26,7 @@
 #define MT_HIGH_VECTORS		8
 #define MT_MEMORY		9
 #define MT_ROM			10
+#define MT_MEMORY_TCC		11
 
 #ifdef CONFIG_MMU
 extern void iotable_init(struct map_desc *, int);
Index: linux-2.6.29/arch/arm/include/asm/mach/time.h
===================================================================
--- linux-2.6.29.orig/arch/arm/include/asm/mach/time.h	2010-04-07 12:29:32.000000000 -0400
+++ linux-2.6.29/arch/arm/include/asm/mach/time.h	2010-04-07 12:29:36.000000000 -0400
@@ -41,8 +41,31 @@
 #ifndef CONFIG_GENERIC_TIME
 	unsigned long		(*offset)(void);
 #endif
+#ifdef CONFIG_NO_IDLE_HZ
+	struct dyn_tick_timer	*dyn_tick;
+#endif
+};
+
+#ifdef CONFIG_NO_IDLE_HZ
+
+#define DYN_TICK_ENABLED	(1 << 1)
+
+struct dyn_tick_timer {
+	spinlock_t	lock;
+	unsigned int	state;			/* Current state */
+	int		(*enable)(void);	/* Enables dynamic tick */
+	int		(*disable)(void);	/* Disables dynamic tick */
+	void		(*reprogram)(unsigned long); /* Reprograms the timer */
+	int		(*handler)(int, void *);
 };
 
+void timer_dyn_reprogram(void);
+#else
+#define timer_dyn_reprogram()	do { } while (0)
+#endif
+
+
+
 extern struct sys_timer *system_timer;
 extern void timer_tick(void);
 
Index: linux-2.6.29/arch/arm/kernel/head.S
===================================================================
--- linux-2.6.29.orig/arch/arm/kernel/head.S	2010-04-07 12:29:32.000000000 -0400
+++ linux-2.6.29/arch/arm/kernel/head.S	2010-04-07 12:29:36.000000000 -0400
@@ -1,9 +1,13 @@
 /*
  *  linux/arch/arm/kernel/head.S
  *
- *  Copyright (C) 1994-2002 Russell King
- *  Copyright (c) 2003 ARM Limited
- *  All Rights Reserved
+ * Author:  <linux@telechips.com>
+ * Modified: 10th Jun, 2009 
+ *
+ * Copyright (C) 1994-2002 Russell King
+ * Copyright (c) 2003 ARM Limited
+ * Copyright (C) 2008-2009 Telechips
+ * All Rights Reserved
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -38,7 +42,7 @@
  * relax this restriction to KERNEL_RAM_VADDR >= PAGE_OFFSET + 0x4000.
  */
 #if (KERNEL_RAM_VADDR & 0xffff) != 0x8000
-#error KERNEL_RAM_VADDR must start at 0xXXXX8000
+@#error KERNEL_RAM_VADDR must start at 0xXXXX8000
 #endif
 
 	.globl	swapper_pg_dir
@@ -76,15 +80,71 @@
  */
 	.section ".text.head", "ax"
 ENTRY(stext)
+	b __startup__
+	
+	/*
+	 *************************************************************************
+	 * Telechips data
+	 *************************************************************************
+	 */ 
+	.word 0xffff0106	/* HardwareID */
+	FirmwareVersion:
+	.word 0x3A726556	/* Ver: */
+	.word 0x34333231	/* 1234 */
+	FirmwareCheckSum:
+	.word 0x00000000	/* Firmware CRC32 Value Until 128Kbyte */
+	DACVersion:
+	.word 0x00000000	/* Not Used Area - Reserved */
+	FirmwareCheckSumEnd:
+	.word 0x00000000	/* Firmware CRC32 Value From 128Kbye to End */
+	FirmwareSize:
+	.word 0x00000000	/* Firmware Total Size */
+	SerialNumber:
+	.word 0x00000000	/* SN[3:0]   */
+	.word 0x00000000	/* SN[7:4]   */
+	.word 0x00000000	/* SN[11:8]  */
+	.word 0x00000000	/* SN[15:12] */
+	.word 0x00000000	/* SN[19:16] */
+	.word 0x00000000	/* SN[23:20] */
+	.word 0x00000000	/* SN[27:24] */
+	.word 0x00000000	/* SN[31:28] */
+	.word 0x00000000	/* SN[35:32] */
+	.word 0x00000000	/* SN[39:36] */
+	.word 0x00000000	/* SN[43:40] */
+	.word 0x00000000	/* SN[47:44] */
+	.word 0x00000000	/* SN[51:48] */
+	.word 0x00000000	/* SN[55:52] */
+	.word 0x00000000	/* SN[59:56] */
+	.word 0x00000000	/* SN[63:60] */
+
+__startup__:
 	msr	cpsr_c, #PSR_F_BIT | PSR_I_BIT | SVC_MODE @ ensure svc mode
 						@ and irqs disabled
 	mrc	p15, 0, r9, c0, c0		@ get processor id
 	bl	__lookup_processor_type		@ r5=procinfo r9=cpuid
 	movs	r10, r5				@ invalid processor (r5=0)?
 	beq	__error_p			@ yes, error 'p'
+
+	mov r0, r9			@ print CPU_TYPE
+@	bl printhex8
+	mov r0, #','
+@	bl  printch
+
+#if defined(CONFIG_MACH_TCC8900)
+    ldr r1, =0xfa0 @ Machine type = TCC8900 , actually this value should comes from bootloader
+#elif defined(CONFIG_MACH_TCC9100)
+    ldr r1, =0xfa1 @ Machine type = TCC9100
+#elif defined(CONFIG_MACH_TCC9200)
+    ldr r1, =0xfa2 @ Machine type = TCC9200
+#endif
+
 	bl	__lookup_machine_type		@ r5=machinfo
 	movs	r8, r5				@ invalid machine (r5=0)?
 	beq	__error_a			@ yes, error 'a'
+
+	movs    r0, r5		@ print MACH_TYPE
+@	bl printhex8
+
 	bl	__vet_atags
 	bl	__create_page_tables
 
Index: linux-2.6.29/arch/arm/kernel/irq.c
===================================================================
--- linux-2.6.29.orig/arch/arm/kernel/irq.c	2010-04-07 12:29:32.000000000 -0400
+++ linux-2.6.29/arch/arm/kernel/irq.c	2010-04-07 12:29:36.000000000 -0400
@@ -109,10 +109,13 @@
  * come via this function.  Instead, they should provide their
  * own 'handler'
  */
+extern inline void arch_idle_off(void);
 asmlinkage void __exception asm_do_IRQ(unsigned int irq, struct pt_regs *regs)
 {
 	struct pt_regs *old_regs = set_irq_regs(regs);
 
+	arch_idle_off();
+
 	irq_enter();
 
 	/*
Index: linux-2.6.29/arch/arm/kernel/setup.c
===================================================================
--- linux-2.6.29.orig/arch/arm/kernel/setup.c	2010-04-07 12:29:32.000000000 -0400
+++ linux-2.6.29/arch/arm/kernel/setup.c	2010-04-07 12:29:36.000000000 -0400
@@ -684,6 +684,13 @@
 	struct tag *tags = (struct tag *)&init_tags;
 	struct machine_desc *mdesc;
 	char *from = default_command_line;
+	
+	/*
+	 * Telechips Board Memory Setting
+	 *  - refer to arch/arm/mach-tcc8900/include/mach/memory.h
+	 */
+	char *tcc_mem_size = TCC_MEM_SIZE;
+	strcat(default_command_line, tcc_mem_size);
 
 	setup_processor();
 	mdesc = setup_machine(machine_arch_type);
@@ -839,7 +846,13 @@
 	seq_puts(m, "\n");
 
 	seq_printf(m, "Hardware\t: %s\n", machine_name);
+#if defined(CONFIG_TCC_R_AX)
+	seq_printf(m, "Revision\t: %s\n", "AX");
+#elif defined(CONFIG_TCC_R_XX)
+	seq_printf(m, "Revision\t: %s\n", "XX");
+#else
 	seq_printf(m, "Revision\t: %04x\n", system_rev);
+#endif
 	seq_printf(m, "Serial\t\t: %08x%08x\n",
 		   system_serial_high, system_serial_low);
 
Index: linux-2.6.29/arch/arm/kernel/time.c
===================================================================
--- linux-2.6.29.orig/arch/arm/kernel/time.c	2010-04-07 12:29:32.000000000 -0400
+++ linux-2.6.29/arch/arm/kernel/time.c	2010-04-07 12:29:36.000000000 -0400
@@ -367,6 +367,108 @@
 	.resume		= timer_resume,
 };
 
+#ifdef CONFIG_NO_IDLE_HZ
+static int timer_dyn_tick_enable(void)
+{
+	struct dyn_tick_timer *dyn_tick = system_timer->dyn_tick;
+	unsigned long flags;
+	int ret = -ENODEV;
+
+	if (dyn_tick) {
+		spin_lock_irqsave(&dyn_tick->lock, flags);
+		ret = 0;
+		if (!(dyn_tick->state & DYN_TICK_ENABLED)) {
+			ret = dyn_tick->enable();
+
+			if (ret == 0)
+				dyn_tick->state |= DYN_TICK_ENABLED;
+		}
+		spin_unlock_irqrestore(&dyn_tick->lock, flags);
+	}
+
+	return ret;
+}
+
+static int timer_dyn_tick_disable(void)
+{
+	struct dyn_tick_timer *dyn_tick = system_timer->dyn_tick;
+	unsigned long flags;
+	int ret = -ENODEV;
+
+	if (dyn_tick) {
+		spin_lock_irqsave(&dyn_tick->lock, flags);
+		ret = 0;
+		if (dyn_tick->state & DYN_TICK_ENABLED) {
+			ret = dyn_tick->disable();
+
+			if (ret == 0)
+				dyn_tick->state &= ~DYN_TICK_ENABLED;
+		}
+		spin_unlock_irqrestore(&dyn_tick->lock, flags);
+	}
+
+	return ret;
+}
+
+/*
+ * Reprogram the system timer for at least the calculated time interval.
+ * This function should be called from the idle thread with IRQs disabled,
+ * immediately before sleeping.
+ */
+void timer_dyn_reprogram(void)
+{
+	struct dyn_tick_timer *dyn_tick = system_timer->dyn_tick;
+	unsigned long next, seq, flags;
+
+	if (!dyn_tick)
+		return;
+
+	spin_lock_irqsave(&dyn_tick->lock, flags);
+	if (dyn_tick->state & DYN_TICK_ENABLED) {
+		next = next_timer_interrupt();
+		do {
+			seq = read_seqbegin(&xtime_lock);
+			dyn_tick->reprogram(next - jiffies);
+		} while (read_seqretry(&xtime_lock, seq));
+	}
+	spin_unlock_irqrestore(&dyn_tick->lock, flags);
+}
+
+static ssize_t timer_show_dyn_tick(struct sys_device *dev, char *buf)
+{
+	return sprintf(buf, "%i\n",
+		       (system_timer->dyn_tick->state & DYN_TICK_ENABLED) >> 1);
+}
+
+static ssize_t timer_set_dyn_tick(struct sys_device *dev, const char *buf,
+				  size_t count)
+{
+	unsigned int enable = simple_strtoul(buf, NULL, 2);
+
+	if (enable)
+		timer_dyn_tick_enable();
+	else
+		timer_dyn_tick_disable();
+
+	return count;
+}
+static SYSDEV_ATTR(dyn_tick, 0644, timer_show_dyn_tick, timer_set_dyn_tick);
+
+/*
+ * dyntick=enable|disable
+ */
+static char dyntick_str[4] __initdata = "";
+
+static int __init dyntick_setup(char *str)
+{
+	if (str)
+		strlcpy(dyntick_str, str, sizeof(dyntick_str));
+	return 1;
+}
+
+__setup("dyntick=", dyntick_setup);
+#endif
+
 static int __init timer_init_sysfs(void)
 {
 	int ret = sysdev_class_register(&timer_sysclass);
@@ -374,6 +476,18 @@
 		system_timer->dev.cls = &timer_sysclass;
 		ret = sysdev_register(&system_timer->dev);
 	}
+#ifdef CONFIG_NO_IDLE_HZ
+	if (ret == 0 && system_timer->dyn_tick) {
+		ret = sysdev_create_file(&system_timer->dev, &attr_dyn_tick);
+
+		/*
+		 * Turn on dynamic tick after calibrate delay
+		 * for correct bogomips
+		 */
+		if (ret == 0 && dyntick_str[0] == 'e')
+			ret = timer_dyn_tick_enable();
+	}
+#endif
 
 	return ret;
 }
Index: linux-2.6.29/arch/arm/mach-tcc8900/Kconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/Kconfig	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,107 @@
+# arch/arm/mach-tcc8900/Kconfig
+# Copyright 2009 Telechips
+# License under GPLv2
+
+comment "TCC Core Type"
+	depends on ARCH_TCC
+
+config ARCH_TCC8900
+	bool "TCC Based System"
+	depends on ARCH_TCC
+
+choice
+    prompt "TCC Revision type"
+    depends on ARCH_TCC8900
+    default TCC_R_AX
+    help 
+        Select Revision type 
+config TCC_R_AX
+	bool "Revision AX"
+	depends on ARCH_TCC && ARCH_TCC8900
+config TCC_R_XX
+	bool "Revision XX"
+	depends on ARCH_TCC && ARCH_TCC8900
+endchoice
+
+
+comment "TCC Board Type"
+    depends on ARCH_TCC && ARCH_TCC8900
+
+config MACH_TCC8900 
+    bool "TCC8900"
+    depends on ARCH_TCC && ARCH_TCC8900
+    default y
+    help 
+      Support for the TCC8900 demo board, Say Y here if you
+      have such a device.
+
+choice
+    prompt "DRAM Type"
+    depends on ARCH_TCC8900
+    default DRAM_DDR2
+    help 
+        Select DRAM Type
+config DRAM_DDR2
+    bool "DRAM_DDR2"
+    help 
+        Select DRAM DDR2
+config DRAM_MDDR
+    bool "DRAM_MDDR"
+    help 
+        Select DRAM MDDR
+endchoice
+
+
+choice
+    prompt "RAM Size"
+    depends on ARCH_TCC8900
+    default RAM_256MB
+    help 
+        Select DRAM Spec 
+config RAM_128MB
+    bool "128MB"
+    help 
+        Select DRAM size 128MB
+config RAM_256MB
+    bool "256MB"
+    depends on DRAM_DDR2
+    help 
+        Select DRAM size 256MB
+endchoice
+
+
+choice
+    prompt "HD Spec"
+    depends on ARCH_TCC8900
+    default HD1080p_LEVEL51
+    help 
+        Select HD and LEVEL spec
+config HD720p_LEVEL41
+    bool "HD720p_LEVEL41"
+    help 
+        Select HD720p and LEVEL 4.1 
+config HD720p_LEVEL51
+    bool "HD720p_LEVEL51"
+    help 
+        Select HD720p and LEVEL 5.1 
+config HD1080p_LEVEL41
+    bool "HD1080p_LEVEL41"
+    help 
+        Select HD1080p and LEVEL 4.1 
+config HD1080p_LEVEL51
+    bool "HD1080p_LEVEL51"
+	depends on RAM_256MB
+    help 
+        Select HD1080p and LEVEL 5.1 
+endchoice
+
+
+config TCC_STRING
+	string "Default dir name"
+	depends on ARCH_TCC8900
+	default "tcc8900"
+	help
+	  "tcc8900"
+	  Default dir name for MACH_TCC8900
+	  Don't edit!!!
+
Index: linux-2.6.29/arch/arm/mach-tcc8900/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/Makefile	2010-04-07 13:00:45.000000000 -0400
@@ -0,0 +1,52 @@
+#
+# Makefile for the linux kernel.
+#
+# Common support
+obj-$(CONFIG_ARCH_TCC) += io.o irq.o devices.o time.o tca_ckc.o idle.o 
+# Specific board support
+obj-$(CONFIG_MACH_TCC8900) += board-tcc8900.o
+
+
+ifeq ($(CONFIG_ARCH_TCC),y)
+$(shell ln -fsn $(CONFIG_TCC_STRING) $(srctree)/arch/arm/mach-tcc8900/tcc) 
+endif
+
+ifeq ($(CONFIG_DRAM_DDR2), y)
+file_1	= tcc_ckcddr2_141to190.c
+file_2	= tcc_ckcddr2_200to290.c
+file_3	= tcc_ckcddr2_300to330.c
+tmp_file = tcc_ckcddr2.newfile
+endif
+ifeq ($(CONFIG_DRAM_MDDR), y)
+file_1	= tcc_ckcmddr_100to160.c
+file_2	= tcc_ckcmddr_20to90.c
+tmp_file = tcc_ckcmddr.newfile
+endif
+
+from_str	='0xB'
+to_str		='0xF'
+
+ifeq ($(CONFIG_DRAM_DDR2), y)
+$(shell sed 's/${from_str}/${to_str}/g' $(srctree)/arch/arm/mach-tcc8900/tcc/$(file_1) > $(srctree)/arch/arm/mach-tcc8900/tcc/${tmp_file})
+$(shell mv -f $(srctree)/arch/arm/mach-tcc8900/tcc/${tmp_file} $(srctree)/arch/arm/mach-tcc8900/tcc/$(file_1))
+$(shell sed 's/${from_str}/${to_str}/g' $(srctree)/arch/arm/mach-tcc8900/tcc/$(file_2) > $(srctree)/arch/arm/mach-tcc8900/tcc/${tmp_file})
+$(shell mv -f $(srctree)/arch/arm/mach-tcc8900/tcc/${tmp_file} $(srctree)/arch/arm/mach-tcc8900/tcc/$(file_2))
+$(shell sed 's/${from_str}/${to_str}/g' $(srctree)/arch/arm/mach-tcc8900/tcc/$(file_3) > $(srctree)/arch/arm/mach-tcc8900/tcc/${tmp_file})
+$(shell mv -f $(srctree)/arch/arm/mach-tcc8900/tcc/${tmp_file} $(srctree)/arch/arm/mach-tcc8900/tcc/$(file_3))
+endif
+ifeq ($(CONFIG_DRAM_MDDR), y)
+$(shell sed 's/${from_str}/${to_str}/g' $(srctree)/arch/arm/mach-tcc8900/tcc/$(file_1) > $(srctree)/arch/arm/mach-tcc8900/tcc/${tmp_file})
+$(shell mv -f $(srctree)/arch/arm/mach-tcc8900/tcc/${tmp_file} $(srctree)/arch/arm/mach-tcc8900/tcc/$(file_1))
+$(shell sed 's/${from_str}/${to_str}/g' $(srctree)/arch/arm/mach-tcc8900/tcc/$(file_2) > $(srctree)/arch/arm/mach-tcc8900/tcc/${tmp_file})
+$(shell mv -f $(srctree)/arch/arm/mach-tcc8900/tcc/${tmp_file} $(srctree)/arch/arm/mach-tcc8900/tcc/$(file_2))
+endif
+
+ifeq ($(CONFIG_DRAM_DDR2), y)
+obj-$(CONFIG_ARCH_TCC) += tcc_ckc_ctrl.o tcc/arm_ioctlutil.o tcc/tcc_ckcddr2_141to190.o tcc/tcc_ckcddr2_200to290.o tcc/tcc_ckcddr2_300to330.o
+endif
+ifeq ($(CONFIG_DRAM_MDDR), y)
+obj-$(CONFIG_ARCH_TCC) += tcc_ckc_ctrl.o tcc/arm_ioctlutil.o tcc/tcc_ckcmddr_100to160.o tcc/tcc_ckcmddr_20to90.o
+endif
+
+
+
Index: linux-2.6.29/arch/arm/mach-tcc8900/Makefile.boot
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/Makefile.boot	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,3 @@
+	zreladdr-y		:= 0x10008000
+params_phys-y		:= 0x10000100
+initrd_phys-y		:= 0x10800000
Index: linux-2.6.29/arch/arm/mach-tcc8900/board-tcc8900.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/board-tcc8900.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,88 @@
+/* lnux/arch/arm/mach-tcc8900/board-tcc8900.c
+ *
+ * Author:  <linux@telechips.com>
+ * Created: 10th Feb, 2009
+ * Description:
+ *
+ * Copyright (C) Telechips, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+
+#include <linux/spi/spi.h>
+#include <linux/i2c.h>
+
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/flash.h>
+
+#include <bsp.h>
+#include <mach/common.h>
+
+extern void __init tcc8900_irq_init(void);
+extern void __init tcc8900_map_common_io(void);
+
+
+static struct spi_board_info tcc8900_spi0_board_info[] = {
+	{
+		.modalias = "spidev",
+		.bus_num = 0,
+		.chip_select = 0,
+		.max_speed_hz = 40 * 1000 * 1000,
+	},
+};
+
+static struct spi_board_info tcc8900_spi1_board_info[] = {
+	{
+		.modalias = "spidev",
+		.bus_num = 1,
+		.chip_select = 0,
+		.max_speed_hz = 40 * 1000 * 1000,
+	},
+};
+
+static struct i2c_board_info __initdata tcc8900_i2c_board_info[] = {
+	{
+//		I2C_BOARD_INFO("tps65011", 0x48),
+//		.type	= "",
+//		.addr	= 0xff,
+//		.irq	= IRQ_EINT20,
+	}
+};
+
+
+static void __init tcc8900_map_io(void)
+{
+    tcc8900_map_common_io();
+}
+
+static void __init tcc8900_init_irq(void)
+{
+	tcc8900_irq_init();
+//	tcc8900_gpio_init();
+}
+
+static void __init tcc8900_init_machine(void)
+{
+	spi_register_board_info(tcc8900_spi0_board_info, ARRAY_SIZE(tcc8900_spi0_board_info));
+	spi_register_board_info(tcc8900_spi1_board_info, ARRAY_SIZE(tcc8900_spi1_board_info));
+	i2c_register_board_info(-1, tcc8900_i2c_board_info, ARRAY_SIZE(tcc8900_i2c_board_info));
+}
+
+MACHINE_START(TCC8900, "Telechips TCC8900 Demo Board")
+    /* Maintainer: Telechips Linux BSP Team <linux@telechips.com> */
+    .phys_io        = 0xf0000000,
+    .io_pg_offst    = ((0xf0000000) >> 18) & 0xfffc,
+    .boot_params    = PHYS_OFFSET + 0x00000100,
+    .map_io         = tcc8900_map_io,
+    .init_irq       = tcc8900_init_irq,
+    .init_machine   = tcc8900_init_machine,
+    .timer          = &tcc8900_timer,
+MACHINE_END
Index: linux-2.6.29/arch/arm/mach-tcc8900/devices.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/devices.c	2010-04-07 13:00:44.000000000 -0400
@@ -0,0 +1,713 @@
+/*
+ * linux/arch/arm/mach-tcc8900/devices.c
+ *
+ * Author:  <linux@telechips.com>
+ * Created: 10th Feb, 2009
+ * Description:
+ *
+ * Copyright (C) Telechips, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <asm/io.h>
+#include <asm/mach-types.h>
+#include <asm/mach/map.h>
+
+#include <bsp.h>
+#include <mach/ohci.h>
+
+#include <linux/dm9000.h>
+
+
+/*----------------------------------------------------------------------
+ * Device     : Touch Driver resource
+ * Description: tcc8900_touch_resources 
+ *----------------------------------------------------------------------*/
+#if defined(CONFIG_TOUCHSCREEN_TCCTS) || defined(CONFIG_TOUCHSCREEN_TCCTS_MODULE)
+static struct resource tcc8900_touch_resources[] = {
+	[0] = {
+		.start	= 0xF05F4000,		
+		.end	= 0xF05F4000 + 0x20,	
+		.flags	= IORESOURCE_MEM,
+	},
+    [1] = {
+        .start = INT_TSADC,
+        .end   = INT_TSADC,
+        .flags = IORESOURCE_IRQ,
+    },
+    [2] = {
+        .start = INT_EI2,
+        .end   = INT_EI2,
+        .flags = IORESOURCE_IRQ,
+    },
+};
+
+static struct platform_device tcc8900_touchscreen_device = {
+	.name			= "tcc-ts",
+	.id				= -1,
+	.resource		= tcc8900_touch_resources,
+	.num_resources	= ARRAY_SIZE(tcc8900_touch_resources),
+};
+
+static inline void tcc8900_init_touch_ts(void)
+{
+	platform_device_register(&tcc8900_touchscreen_device);
+}
+#endif /* CONFIG_TOUCHSCREEN_TCCTS */
+
+
+/*----------------------------------------------------------------------
+ * Device     : DM9000 resource
+ * Description: tcc8900_dm9000_resources
+ *----------------------------------------------------------------------*/
+#if defined(CONFIG_TCC_DM9000) || defined(CONFIG_TCC_DM9000_MODULE)
+static struct resource tcc8900_dm9000_resource[] = {
+	[0] = {
+		.start = (0xF05C0000),
+		.end   = (0xF05C0000)+ 0x3,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = (0xF05C0000)+ 0x4,
+		.end   = (0xF05C0000)+ 0x4 + 0x3f,
+		.flags = IORESOURCE_MEM,
+	},
+	[2] = {
+		.start = INT_EI4,
+		.end   = INT_EI4,
+		.flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,   
+	}
+
+};
+
+/* for the moment we limit ourselves to 16bit IO until some
+ * better IO routines can be written and tested
+*/
+static struct dm9000_plat_data bast_dm9000_platdata = {
+	.flags		= DM9000_PLATF_8BITONLY,
+};
+
+static struct platform_device tcc8900_dm9000_device = {
+	.name		= "dm9000",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(tcc8900_dm9000_resource),
+	.resource	= tcc8900_dm9000_resource,
+	.dev		= {
+		.platform_data = &bast_dm9000_platdata,
+	}
+};
+
+static inline void tcc8900_init_dm9000(void)
+{
+    platform_device_register(&tcc8900_dm9000_device);
+}
+#endif
+
+
+/*----------------------------------------------------------------------
+ * Device     : DM9000 resource
+ * Description: tcc8900_dm9ks_resources
+ *----------------------------------------------------------------------*/
+#if defined(CONFIG_DM9KS) || defined(CONFIG_DM9KS_MODULE)
+static struct platform_device tcc8900_dm9ks_device = {
+    .name   = "dm9ks",
+    .id     = -1,
+};
+
+static inline void tcc8900_init_dm9ks(void)
+{
+    platform_device_register(&tcc8900_dm9ks_device);
+}
+#endif
+
+
+/*----------------------------------------------------------------------
+ * Device     : RTC resource
+ * Description: tcc8900_rtc_resources
+ *----------------------------------------------------------------------*/
+#if defined(CONFIG_RTC_DRV_TCC) || defined(CONFIG_RTC_DRV_TCC_MODULE)
+static struct resource tcc8900_rtc_resource[] = {
+    [0] = {
+        .start = 0xF05F2000,
+        .end   = 0xF05F20FF,
+        .flags = IORESOURCE_MEM,
+    },
+    [1] = {
+        .start  = INT_RTC,
+        .end    = INT_RTC,
+        .flags  = IORESOURCE_IRQ,
+    }
+};
+
+static struct platform_device tcc8900_rtc_device = {
+    .name           = "tcc-rtc",
+    .id             = -1,
+    .resource       = tcc8900_rtc_resource,
+    .num_resources  = ARRAY_SIZE(tcc8900_rtc_resource),
+    .dev        = {    
+        .platform_data  = NULL,   
+    }   
+};
+
+static inline void tcc8900_init_rtc(void)
+{
+    platform_device_register(&tcc8900_rtc_device);
+}
+#endif  /* CONFIG_RTC_DRV_TCC */
+
+
+#if defined(CONFIG_I2C_TCC) || defined(CONFIG_I2C_TCC_MODULE)
+/*----------------------------------------------------------------------
+ * Device     : I2C resource
+ * Description: tcc8900_i2c_resources has master0 and master1
+ *----------------------------------------------------------------------*/
+static struct resource tcc8900_i2c_resources[] = {
+	[0] = {
+		.start	= 0xF0530000,			/* I2C master ch0 base address */
+		.end	= 0xF0530040,			/* I2C master ch1 base address */
+		.flags	= IORESOURCE_MEM,
+    },
+	[1] = {
+		.start	= 100,					/* I2C ch0 100Kbps */
+		.end	= 400,					/* I2C ch1 400Kbps */
+		.flags	= IORESOURCE_MEM,
+    },
+//	[1] = {
+//		.start  = INT_I2C,				/* I2C master ch[0,1] irq number */
+//		.end    = INT_I2C,				/* I2C ch1 irq number */
+//		.flags  = IORESOURCE_IRQ,
+//	},
+
+	/* SMU_I2C */
+	[2] = {
+		.start	= 0xF0405000,			/* SMU_I2C master ch0 SATA-PHY base address */
+		.end	= 0xF0405040,			/* SMU_I2C master ch1 HDMI-PHY base address */
+		.flags	= IORESOURCE_MEM,
+    },
+	[3] = {
+		.start	= 100,					/* SMU_I2C ch0 100Kbps */
+		.end	= 100,					/* SMU_I2C ch1 100Kbps */
+		.flags	= IORESOURCE_MEM,
+    },
+};
+
+static struct platform_device tcc8900_i2c_device = {
+    .name           = "tcc-i2c",
+    .id             = -1,
+    .resource       = tcc8900_i2c_resources,
+    .num_resources  = ARRAY_SIZE(tcc8900_i2c_resources),
+};
+
+static inline void tcc8900_init_i2c(void)
+{
+    platform_device_register(&tcc8900_i2c_device);
+}
+#endif
+
+
+/*----------------------------------------------------------------------
+ * Device     : LCD Frame Buffer resource
+ * Description: 
+ *----------------------------------------------------------------------*/
+static u64 tcc8900_device_lcd_dmamask = 0xffffffffUL;
+struct platform_device tcc8900_lcd_device = {
+	.name	  = "tccxxx-lcd",
+	.id		  = -1,
+	.dev      = {
+		.dma_mask		    = &tcc8900_device_lcd_dmamask,
+//		.coherent_dma_mask	= 0xffffffffUL
+	}
+};
+
+static inline void tcc8900_init_lcd(void)
+{
+	platform_device_register(&tcc8900_lcd_device);
+}
+
+
+/*----------------------------------------------------------------------
+ * Device     : Serial-ATA resource
+ * Description: 
+ *----------------------------------------------------------------------*/
+#if defined(CONFIG_SATA_TCC) || defined(CONFIG_SATA_TCC_MODULE)
+static struct resource sata_resources[] = {
+    [0] = {
+		.start = 0xF0560000,
+		.end   = 0xF0560800,
+		.flags = IORESOURCE_MEM,
+    },
+    [1] = {
+        .start = INT_SATA,
+        .end   = INT_SATA,
+        .flags = IORESOURCE_IRQ,
+    },
+};
+
+static struct platform_device tcc8900_sata_device = {
+    .name			= "tcc-sata",
+    .id				= 0,
+    .resource		= sata_resources,
+    .num_resources	= ARRAY_SIZE(sata_resources),
+};
+
+static inline void tcc8900_init_sata(void)
+{
+    platform_device_register(&tcc8900_sata_device);
+}
+#endif
+
+
+/*----------------------------------------------------------------------
+ * Device     : SPI(GPSB) Master resource
+ * Description: 
+ *----------------------------------------------------------------------*/
+#if defined(CONFIG_SPI_TCC_MASTER) || defined(CONFIG_SPI_TCC_MASTER_MODULE)
+static struct resource spi0_resources[] = {
+    [0] = {
+		.start = 0xF0536000,
+		.end   = 0xF0536038,
+		.flags = IORESOURCE_MEM,
+    },
+    [1] = {
+        .start = INT_GPSB0_DMA,
+        .end   = INT_GPSB0_DMA,
+        .flags = IORESOURCE_IRQ,
+    },
+};
+
+static struct platform_device tcc8900_spi0_device = {
+    .name			= "tcc-spi",
+    .id				= 0,
+    .resource		= spi0_resources,
+    .num_resources	= ARRAY_SIZE(spi0_resources),
+};
+
+static struct resource spi1_resources[] = {
+    [0] = {
+		.start = 0xF0536100,
+		.end   = 0xF0536138,
+		.flags = IORESOURCE_MEM,
+    },
+    [1] = {
+        .start = INT_GPSB1_DMA,
+        .end   = INT_GPSB1_DMA,
+        .flags = IORESOURCE_IRQ,
+    },
+};
+
+static struct platform_device tcc8900_spi1_device = {
+    .name			= "tcc-spi",
+    .id				= 1,
+    .resource		= spi1_resources,
+    .num_resources	= ARRAY_SIZE(spi1_resources),
+};
+
+static inline void tcc8900_init_spi(void)
+{
+	platform_device_register(&tcc8900_spi0_device);
+	platform_device_register(&tcc8900_spi1_device);
+}
+#endif
+
+
+/*----------------------------------------------------------------------
+ * Device     : SPI(TSIF) Slave resource
+ * Description:
+ *----------------------------------------------------------------------*/
+#if defined(CONFIG_TSIF_TCC_SLAVE) || defined(CONFIG_TSIF_TCC_SLAVE_MODULE)
+static struct platform_device tcc_tsif_device = {
+	.name	= "tcc-tsif",
+	.id		= -1,
+};
+
+static inline void tcc8900_init_tsif(void)
+{
+    platform_device_register(&tcc_tsif_device);
+}
+#endif
+
+
+/*----------------------------------------------------------------------
+ * Device	  : SD/MMC resource
+ * Description: tcc8900_mmc_core0_resource
+ *				tcc8900_mmc_core1_resource
+ *----------------------------------------------------------------------*/
+#if defined(CONFIG_MMC_TCC_SDHC_CORE0) || defined(CONFIG_MMC_TCC_SDHC_CORE0_MODULE)
+static u64 tcc8900_device_mmc0_dmamask = 0xffffffffUL;
+static struct resource tcc8900_mmc_core0_resource[] = {
+	[0] = {
+		.start	= 0xF05A0000,
+		.end	= 0xF05A00FF,
+		.flags	= IORESOURCE_MEM,
+	},	
+	[1] = {
+		.start	= INT_SD0,
+		.end	= INT_SD0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+struct platform_device tcc8900_mmc0_device = {
+	.name			= "tcc-sdhc0",
+	.id 			= 0,
+	.num_resources	= ARRAY_SIZE(tcc8900_mmc_core0_resource),
+	.resource		= tcc8900_mmc_core0_resource,
+	.dev			= {
+		.dma_mask			= &tcc8900_device_mmc0_dmamask,
+		.coherent_dma_mask	= 0xffffffffUL
+	}
+};
+#endif
+
+#if defined(CONFIG_MMC_TCC_SDHC_CORE1) || defined(CONFIG_MMC_TCC_SDHC_CORE1_MODULE)
+static u64 tcc8900_device_mmc1_dmamask = 0xffffffffUL;
+static struct resource tcc8900_mmc_core1_resource[] = {
+	[0] = {
+		.start	= 0xF05A0200,
+		.end	= 0xF05A02FF,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= INT_SD1,
+		.end	= INT_SD1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+struct platform_device tcc8900_mmc1_device = {
+	.name			= "tcc-sdhc1",
+	.id 			= 1,
+	.num_resources	= ARRAY_SIZE(tcc8900_mmc_core1_resource),
+	.resource		= tcc8900_mmc_core1_resource,
+	.dev			= {
+		.dma_mask			= &tcc8900_device_mmc1_dmamask,
+		.coherent_dma_mask	= 0xffffffffUL
+	}
+};
+#endif
+
+#if defined(CONFIG_MMC_TCC_SDHC) || defined(CONFIG_MMC_TCC_SDHC_MODULE)
+static inline void tcc8900_init_mmc(void)
+{
+#if defined(CONFIG_MMC_TCC_SDHC_CORE0)
+	platform_device_register(&tcc8900_mmc0_device);
+#endif
+#if defined(CONFIG_MMC_TCC_SDHC_CORE1)
+	platform_device_register(&tcc8900_mmc1_device);
+#endif
+}
+#endif
+
+
+/*----------------------------------------------------------------------
+ * Device     : UART resource
+ * Description: uart0_resources
+ *              uart1_resources
+ *              uart2_resources (not used)
+ *              uart3_resources (not used)
+ *              uart4_resources (not used)
+ *              uart5_resources (not used)
+ *----------------------------------------------------------------------*/
+static struct resource uart0_resources[] = {
+    /* PA -> VA */
+    [0] = {
+        .start  = 0xF0532000,
+        .end    = 0xF05320FF,
+        .flags  = IORESOURCE_MEM,
+    },
+    [1] = {
+        .start  = INT_UART0,
+        .end    = INT_UART0,
+        .flags  = IORESOURCE_IRQ,
+    },
+};
+
+static struct platform_device tcc8900_uart0_device = {
+    .name           = "tcc8900-uart",
+    .id             = 0,
+    .resource       = uart0_resources,
+    .num_resources  = ARRAY_SIZE(uart0_resources),
+};
+
+static struct resource uart1_resources[] = {
+    [0] = {
+        .start  = 0xF0532100,
+        .end    = 0xF05321FF,
+        .flags  = IORESOURCE_MEM,
+    },
+    [1] = {
+        .start  = INT_UART1,
+        .end    = INT_UART1,
+        .flags  = IORESOURCE_IRQ,
+    },
+};
+
+static struct platform_device tcc8900_uart1_device = {
+    .name           = "tcc8900-uart",
+    .id             = 1,
+    .resource       = uart1_resources,
+    .num_resources  = ARRAY_SIZE(uart1_resources),
+};
+
+#if 0
+static struct resource uart2_resources[] = {
+    [0] = {
+        .start  = 0xF0532200,
+        .end    = 0xF05322FF,
+        .flags  = IORESOURCE_MEM,
+    },
+    [1] = {
+        .start  = INT_UART2,
+        .end    = INT_UART2,
+        .flags  = IORESOURCE_IRQ,
+    },
+};
+
+static struct platform_device tcc8900_uart2_device = {
+    .name           = "tcc8900-uart",
+    .id             = 2,
+    .resource       = uart2_resources,
+    .num_resources  = ARRAY_SIZE(uart2_resources),
+};
+
+static struct resource uart3_resources[] = {
+    [0] = {
+        .start  = 0xF0532300,
+        .end    = 0xF05323FF,
+        .flags  = IORESOURCE_MEM,
+    },
+    [1] = {
+        .start  = INT_UART3,
+        .end    = INT_UART3,
+        .flags  = IORESOURCE_IRQ,
+    },
+};
+
+static struct platform_device tcc8900_uart3_device = {
+    .name           = "tcc8900-uart",
+    .id             = 3,
+    .resource       = uart3_resources,
+    .num_resources  = ARRAY_SIZE(uart3_resources),
+};
+
+static struct resource uart4_resources[] = {
+    [0] = {
+        .start  = 0xF0532400,
+        .end    = 0xF05324FF,
+        .flags  = IORESOURCE_MEM,
+    },
+    [1] = {
+        .start  = INT_UART4,
+        .end    = INT_UART4,
+        .flags  = IORESOURCE_IRQ,
+    },
+};
+
+static struct platform_device tcc8900_uart4_device = {
+    .name           = "tcc8900-uart",
+    .id             = 4,
+    .resource       = uart4_resources,
+    .num_resources  = ARRAY_SIZE(uart4_resources),
+};
+
+static struct resource uart5_resources[] = {
+    [0] = {
+        .start  = 0xF0532500,
+        .end    = 0xF05325FF,
+        .flags  = IORESOURCE_MEM,
+    },
+    [1] = {
+        .start  = INT_UART5,
+        .end    = INT_UART5,
+        .flags  = IORESOURCE_IRQ,
+    },
+};
+
+static struct platform_device tcc8900_uart5_device = {
+    .name           = "tcc8900-uart",
+    .id             = 5,
+    .resource       = uart5_resources,
+    .num_resources  = ARRAY_SIZE(uart5_resources),
+};
+#endif
+
+static inline void tcc8900_init_uart(void)
+{
+    platform_device_register(&tcc8900_uart0_device);
+    platform_device_register(&tcc8900_uart1_device);
+#if 0
+    platform_device_register(&tcc8900_uart2_device);
+    platform_device_register(&tcc8900_uart3_device);
+    platform_device_register(&tcc8900_uart4_device);
+    platform_device_register(&tcc8900_uart5_device);
+#endif
+}
+
+
+/*----------------------------------------------------------------------
+ * Device     : USB HOST1.1 OHCI resource
+ * Description: tcc8900_ohci_resources
+ *----------------------------------------------------------------------*/
+ #if defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE)
+ static u64 tcc8900_device_ohci_dmamask = 0xffffffffUL;
+ 
+ static struct resource tcc8900_ohci_resources[] = {
+	[0] = {
+		.start = 0xF0500000,
+		.end   = 0xF050005C,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = INT_U11H,
+		.end   = INT_U11H,
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+static struct platform_device ohci_device = {
+	.name			= "tcc-ohci",
+	.id				= -1,
+	.num_resources  = ARRAY_SIZE(tcc8900_ohci_resources),
+	.resource       = tcc8900_ohci_resources,
+	.dev			= {
+		.dma_mask 			= &tcc8900_device_ohci_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+};
+
+static int tcc8900_ohci_init(struct device *dev)
+{
+	return 0;
+}
+
+static struct tccohci_platform_data tcc8900_ohci_platform_data = {
+	.port_mode	= USBOHCI_PPM_PERPORT,
+	.init		= tcc8900_ohci_init,
+};
+
+void __init tcc_set_ohci_info(struct tccohci_platform_data *info)
+{
+	ohci_device.dev.platform_data = info;
+}
+
+static inline void tcc8900_init_usbhost(void)
+{
+	platform_device_register(&ohci_device);
+	tcc_set_ohci_info(&tcc8900_ohci_platform_data);
+}
+#endif /*CONFIG_USB_OHCI_HCD  || CONFIG_USB_OHCI_HCD_MODULE*/
+
+
+/*----------------------------------------------------------------------
+ * Device     : USB DWC OTG resource
+ * Description: dwc_otg_resources
+ *----------------------------------------------------------------------*/
+#if defined(CONFIG_TCC_DWC_OTG) || defined(CONFIG_TCC_DWC_OTG_MODULE)
+static u64 tcc8900_dwc_otg_dmamask = 0xffffffffUL;
+static struct resource dwc_otg_resources[] = {
+	[0] = {
+		.start	= 0xF0550000,
+		.end	= 0xF0550100,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = INT_UOTG,
+		.end   = INT_UOTG,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device tcc8900_dwc_otg_device = {
+	.name			= "dwc_otg",
+	.id				= 0,
+	.resource		= dwc_otg_resources,
+	.num_resources	= ARRAY_SIZE(dwc_otg_resources),
+	.dev			= {
+		.dma_mask 			= &tcc8900_dwc_otg_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+};
+
+static inline void tcc8900_init_dwc_otg(void)
+{
+	int ret;
+	ret = platform_device_register(&tcc8900_dwc_otg_device);
+}
+#endif
+
+
+/*
+ * This gets called after board-specific INIT_MACHINE, and initializes most
+ * on-chip peripherals accessible on this board (except for few like USB):
+ *
+ *  (a) Does any "standard config" pin muxing needed.  Board-specific
+ *  code will have muxed GPIO pins and done "nonstandard" setup;
+ *  that code could live in the boot loader.
+ *  (b) Populating board-specific platform_data with the data drivers
+ *  rely on to handle wiring variations.
+ *  (c) Creating platform devices as meaningful on this board and
+ *  with this kernel configuration.
+ *
+ * Claiming GPIOs, and setting their direction and initial values, is the
+ * responsibility of the device drivers.  So is responding to probe().
+ *
+ * Board-specific knowlege like creating devices or pin setup is to be
+ * kept out of drivers as much as possible.  In particular, pin setup
+ * may be handled by the boot loader, and drivers should expect it will
+ * normally have been done by the time they're probed.
+ */
+static int __init tcc8900_init_devices(void)
+{
+#if defined(CONFIG_I2C_TCC) || defined(CONFIG_I2C_TCC_MODULE)
+	tcc8900_init_i2c();
+#endif
+
+#if defined(CONFIG_TCC_DM9000) || defined(CONFIG_TCC_DM9000_MODULE)
+    tcc8900_init_dm9000();
+#endif
+#if defined(CONFIG_DM9KS) || defined(CONFIG_DM9KS_MODULE)
+    tcc8900_init_dm9ks();
+#endif
+
+#if defined(CONFIG_RTC_DRV_TCC) || defined(CONFIG_RTC_DRV_TCC_MODULE)
+    tcc8900_init_rtc();
+#endif
+
+    tcc8900_init_uart();
+    tcc8900_init_lcd();
+
+#if defined(CONFIG_SPI_TCC_MASTER) || defined(CONFIG_SPI_TCC_MASTER_MODULE)
+	tcc8900_init_spi();
+#endif
+#if defined(CONFIG_TSIF_TCC_SLAVE) || defined(CONFIG_TSIF_TCC_SLAVE_MODULE)
+	tcc8900_init_tsif();
+#endif
+
+#if defined(CONFIG_TOUCHSCREEN_TCCTS) || defined(CONFIG_TOUCHSCREEN_TCCTS_MODULE)
+    tcc8900_init_touch_ts();
+#endif
+
+#if defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE)
+	tcc8900_init_usbhost();
+#endif
+#if defined(CONFIG_TCC_DWC_OTG) || defined(CONFIG_TCC_DWC_OTG_MODULE)
+	tcc8900_init_dwc_otg();
+#endif
+
+#if defined(CONFIG_MMC_TCC_SDHC) || defined(CONFIG_MMC_TCC_SDHC_MODULE)
+	tcc8900_init_mmc();
+#endif
+
+#if defined(CONFIG_SATA_TCC) || defined(CONFIG_SATA_TCC_MODULE)
+    tcc8900_init_sata();
+#endif
+
+    return 0;
+}
+
+arch_initcall(tcc8900_init_devices);
Index: linux-2.6.29/arch/arm/mach-tcc8900/gpio.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/gpio.c	2010-04-07 13:00:45.000000000 -0400
@@ -0,0 +1,32 @@
+/*
+ *  linux/arch/arm/mach-tcc8900/gpio.c
+ *
+ * Support functions for TCC8900 GPIO
+ *
+ * Copyright (C) 2009 Telechips 
+ * Written by linux <linux@telechips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/sysdev.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+
+#include <mach/hardware.h>
+#include <asm/irq.h>
+#include <mach/irqs.h>
+#include <mach/gpio.h>
+#include <asm/mach/irq.h>
+
+
+int __init tcc8900_gpio_init(void)
+{
+    return 0;
+}
Index: linux-2.6.29/arch/arm/mach-tcc8900/idle.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/idle.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,49 @@
+/*
+ * linux/arch/arm/mach-tcc8900/idle.c 
+ *
+ * Author: <linux@telechips.com>
+ * Created: June 10, 2008
+ * Description: TCC89/91/92 idle function
+ *
+ * Copyright (C) 2008-2009 Telechips 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as 
+ * published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see the file COPYING, or write
+ * to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <asm/atomic.h>
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+#include <bsp.h>
+
+volatile static PCKC pCKC = (volatile PCKC)tcc_p2v(HwCLK_BASE);
+volatile static unsigned int bCLK0CTRL;
+volatile unsigned int idle_expired;
+
+inline void tcc_idle(void)
+{
+	idle_expired = 1;
+	local_irq_enable();
+	bCLK0CTRL = pCKC->CLK0CTRL;
+	pCKC->CLK0CTRL |= (Hw20|0xFF00);
+	while (idle_expired);
+	pCKC->CLK0CTRL = bCLK0CTRL;
+	local_irq_disable();
+}
+
+inline void arch_idle_off(void)
+{
+	idle_expired = 0;
+}
+
+/* end of file */
Index: linux-2.6.29/arch/arm/mach-tcc8900/include/bsp.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/include/bsp.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,62 @@
+/****************************************************************************
+*   FileName    : bsp.h
+*   Description : 
+****************************************************************************
+*
+*   TCC Version : 1.0
+*   Copyright (c) Telechips, Inc.
+*   ALL RIGHTS RESERVED
+*
+****************************************************************************/
+
+#ifndef __BSP_H__
+#define __BSP_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if defined(_LINUX_)
+#ifndef VOLATILE
+#define VOLATILE
+#endif
+#include <mach/reg_physical.h>
+#include <mach/bsp_cfg.h>
+#include <mach/globals.h>
+#include <mach/tca_ckc.h>
+#include <linux/tcc_pwm.h>
+#include <linux/tcc_ll.h>
+#else
+
+#ifndef VOLATILE
+#define VOLATILE	volatile
+#endif
+
+//system os header file 
+#include <system_type.h> 
+
+//argument structur and define file
+#include <args.h>
+
+//globals macro, defines file
+#include <globals.h>
+
+//bsp option config file
+#include <bsp_cfg.h>
+
+//Physical Base address file
+#include <reg_physical.h>
+
+//Kernel Ioctl
+#include <ioctl_code.h>
+#include <ioctl_ckcstr.h>
+#include <ioctl_gpiostr.h>
+#include <ioctl_pwrstr.h>
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __BSP_H__
Index: linux-2.6.29/arch/arm/mach-tcc8900/include/mach/TCC89x_Physical.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/include/mach/TCC89x_Physical.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,1164 @@
+/****************************************************************************
+ *   FileName    : TCC89x_Physical.h
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+
+  Revision History
+
+ ****************************************************************************
+
+ ****************************************************************************/
+
+/************************************************************************
+*	TCC89x Internal Register Definition File
+************************************************************************/
+#ifndef	__TCC89x_H__
+#define	__TCC89x_H__
+
+
+/************************************************************************
+*	Bit Field Definition
+************************************************************************/
+#define	Hw37									(1LL << 37)
+#define	Hw36									(1LL << 36)
+#define	Hw35									(1LL << 35)
+#define	Hw34									(1LL << 34)
+#define	Hw33									(1LL << 33)
+#define	Hw32									(1LL << 32)
+#define	Hw31									0x80000000
+#define	Hw30									0x40000000
+#define	Hw29									0x20000000
+#define	Hw28									0x10000000
+#define	Hw27									0x08000000
+#define	Hw26									0x04000000
+#define	Hw25									0x02000000
+#define	Hw24									0x01000000
+#define	Hw23									0x00800000
+#define	Hw22									0x00400000
+#define	Hw21									0x00200000
+#define	Hw20									0x00100000
+#define	Hw19									0x00080000
+#define	Hw18									0x00040000
+#define	Hw17									0x00020000
+#define	Hw16									0x00010000
+#define	Hw15									0x00008000
+#define	Hw14									0x00004000
+#define	Hw13									0x00002000
+#define	Hw12									0x00001000
+#define	Hw11									0x00000800
+#define	Hw10									0x00000400
+#define	Hw9										0x00000200
+#define	Hw8										0x00000100
+#define	Hw7										0x00000080
+#define	Hw6										0x00000040
+#define	Hw5										0x00000020
+#define	Hw4										0x00000010
+#define	Hw3										0x00000008
+#define	Hw2										0x00000004
+#define	Hw1										0x00000002
+#define	Hw0										0x00000001
+#define	HwZERO									0x00000000
+
+/*******************************************************************************
+*	 TCC8900_DataSheet_PART 2 SMU & PMU_V0.00 Dec.11 2008
+********************************************************************************/
+/************************************************************************
+*	1. Clock Controller Register Define			(Base Addr = 0xF0400000) // R/W
+************************************************************************/
+//---------------------------------------------------------------------------------------------
+//31  | 30  | 29  | 28  | 27  | 26  | 25  | 24  | 23  | 22  | 21  | 20  | 19  | 18  | 17  | 16 |
+//  												 		|CFGEN|MODE | NCKOE/DPRD           |
+//15  | 14  | 13  | 12  | 11  | 10  |  9  |  8  |  7  |   6 |   5 |   4 |   3 |   2 |   1 |  0 |
+//   NCKOE/DMIN  		|		NCKOE/DMAX      |		  NCKOE/DCDIV   |     |	    CKSEL      |
+//----------------------------------------------------------------------------------------------   
+#define HwCLK_BASE					*(volatile unsigned long *)0xF0400000
+#define HwCKC						((PCKC)&HwCLK_BASE)
+
+/************************************************************************
+*	2. Vectored Priority Interrupt Controller Register Map(Base Addr = 0xF0401000)
+************************************************************************/
+#define	HwPIC_BASE					*(volatile unsigned long *)0xF0401000
+#define	HwVIC_BASE					*(volatile unsigned long *)0xF0401200
+#define HwPIC						((PPIC)&HwPIC_BASE)
+#define HwVIC						((PVIC)&HwVIC_BASE)
+
+
+// Interrupt Enable 0
+#define	HwINT0_EHI0					Hw31										// R/W, External Host Interface0 Interrupt Enable
+#define	HwINT0_ECC					Hw30										// R/W, ECC Interrupt Enable 
+#define	HwINT0_DMA					Hw29										// R/W, DMA Controller Interrupt Enable
+#define	HwINT0_TSADC				Hw28										// R/W, TSADC Interrupt Enable
+#define	HwINT0_G2D					Hw27										// R/W, Graphic Engine 2D Hardware Interrupt Enable
+#define	HwINT0_3DMMU				Hw26										// R/W, 3D MMU Interrupt Enable
+#define	HwINT0_3DGP					Hw25										// R/W, 3D Geometary Interrupt Enable
+#define	HwINT0_3DPP					Hw24										// R/W, 3D Pixel Processor Interrupt Enable
+#define	HwINT0_VCDC					Hw23										// R/W, Video CODEC Interrupt Enable
+#define	HwINT0_JPGD					Hw22										// R/W, JPEG Decoder Interrupt Enable
+#define	HwINT0_JPGE					Hw21										// R/W, JPEG Encoder Interrupt Enable
+#define	HwINT0_VIPET				Hw20										// R/W, VIPET Controller Interrupt Enable
+#define	HwINT0_LCD1					Hw19										// R/W, LCD Controller1 Interrupt Enable
+#define	HwINT0_LCD0					Hw18										// R/W, LCD Controller0 Interrupt Enable
+#define	HwINT0_CAM					Hw17										// R/W, Camera Interrupt Enable
+#define	HwINT0_SC1					Hw16										// R/W, Mem-to-Mem Scaler1 Interrupt Enable
+#define	HwINT0_SC0					Hw15										// R/W, Mem-to-Mem Scaler0 Interrupt Enable
+#define	HwINT0_EI11					Hw14										// R/W, External Interrupt11 Enable
+#define	HwINT0_EI10					Hw13										// R/W, External Interrupt10 Enable
+#define	HwINT0_EI9					Hw12										// R/W, External Interrupt9 Enable
+#define	HwINT0_EI8					Hw11										// R/W, External Interrupt8 Enable
+#define	HwINT0_EI7					Hw10										// R/W, External Interrupt7 Enable
+#define	HwINT0_EI6					Hw9											// R/W, External Interrupt6 Enable
+#define	HwINT0_EI5					Hw8											// R/W, External Interrupt5 Enable
+#define	HwINT0_EI4					Hw7											// R/W, External Interrupt4 Enable
+#define	HwINT0_EI3					Hw6											// R/W, External Interrupt3 Enable
+#define	HwINT0_EI2					Hw5											// R/W, External Interrupt2 Enable
+#define	HwINT0_EI1					Hw4											// R/W, External Interrupt1 Enable
+#define	HwINT0_EI0					Hw3											// R/W, External Interrupt0 Enable
+#define	HwINT0_SMUI2C				Hw2											// R/W, SMU_I2C Interrupt Enable
+#define	HwINT0_TC1					Hw1											// R/W, Timer1 Interrupt Enable
+#define	HwINT0_TC0					Hw0											// R/W, Timer0 Interrupt Enable
+
+// Interrupt Enable 1
+#define	HwINT1_AEIRQ				Hw31										// R/W, Not maskable error ARM DMA interrupt enable
+#define	HwINT1_ASIRQ				Hw30										// R/W, Secure ARM DMA select interrupt enable
+#define	HwINT1_AIRQ					Hw29										// R/W, Non secure ARM DMA interrupt enable
+#define	HwINT1_APMU					Hw28										// R/W, ARM System Metrics interrupt enable
+#define	HwINT1_AUDIO				Hw27										// R/W, AUDIO interrupt enable
+#define	HwINT1_ADMA					Hw26										// R/W, AUDIO DMA interrupt enable
+#define	HwINT1_DAITX				Hw25										// R/W, DAI transmit interrupt enable
+#define	HwINT1_DAIRX				Hw24										// R/W, DAI receive interrupt enable
+#define	HwINT1_CDRX					Hw23										// R/W, CDIF receive interrupt enable
+#define	HwINT1_TSIF1				Hw22										// R/W, TS interface 1 interrupt enable
+#define	HwINT1_TSIF0				Hw21										// R/W, TS interface 0 interrupt enable
+#define	HwINT1_GPS2					Hw20										// R/W, GPS AGPS interrupt enable
+#define	HwINT1_GPS1					Hw19										// R/W, GPS TCXO expired interrupt enable
+#define	HwINT1_GPS0					Hw18										// R/W, GPS RTC expired interrupt enable
+#define	HwINT1_NotUsed				Hw17										// R/W, Reserved
+#define	HwINT1_UOTG					Hw16										// R/W, USB 2.0 OTG interrupt enable
+#define	HwINT1_UART					Hw15										// R/W, UART interrupt enable
+#define	HwINT1_SPDTX				Hw14										// R/W, SPDIF transmitter interrupt enable
+#define	HwINT1_SD1					Hw13										// R/W, SD/MMC 1 interrupt enable
+#define	HwINT1_SD0					Hw12										// R/W, SD/MMC 0 interrupt enable
+#define	HwINT1_RTC					Hw11										// R/W, RTC interrupt enable
+#define	HwINT1_RMT					Hw10										// R/W, Remote Control interrupt enable
+#define	HwINT1_NFC					Hw9											// R/W, Nand flash controller interrupt enable
+#define	HwINT1_MS					Hw8											// R/W, Memory Stick interrupt enable
+#define	HwINT1_MPEFEC				Hw7											// R/W, MPEFEC interrupt enable
+#define	HwINT1_I2C					Hw6											// R/W, I2C interrupt enable
+#define	HwINT1_HDD					Hw5											// R/W, HDD controller interrupt enable
+#define	HwINT1_GPSB					Hw4											// R/W, GPSB Interrupt Enable
+#define	HwINT1_NotUsed1				Hw3											// R/W, Reserved
+#define	HwINT1_HDMI					Hw2											// R/W, HDMI interrupt enable
+#define	HwINT1_NotUsed2				Hw1											// R/W, Reserved
+#define	HwINT1_EHI1					Hw0											// R/W, External Host Interface1 Interrupt Enable
+
+#define	HwALLMSK_FIQ				Hw1										// FIQ mask register
+#define	HwALLMSK_IRQ				Hw0										// IRQ mask register
+	
+/***********************************************************************
+*	3. Timer/Counter Register Map (Base Address = 0xF0403000) 
+************************************************************************/
+#define	HwTMR_BASE					*(volatile unsigned long *)0xF0403000	// Timer/Counter Base Register
+
+/***********************************************************************
+*	4. PMU(POWER MANAGEMENT UNIT) Register Map (Base Address = 0xF0404000) 
+************************************************************************/
+#define	HwPMU_BASE  				*(volatile unsigned long *)0xF0404000 	//R/W   PMU Control Register 
+
+/*******************************************************************************
+*	5. SMUI2C Controller Register Define   (Base Addr = 0xF0405000)
+********************************************************************************/
+#define HwSMU_I2CMASTER0_BASE     	*(volatile unsigned long *)0xF0405000
+#define HwSMU_I2CMASTER1_BASE     	*(volatile unsigned long *)0xF0405040
+#define HwSMU_I2CICLK_BASE     		*(volatile unsigned long *)0xF0405080	//I2C_SCL divider Regist
+#define HwI2CSTATUS_BASE            *(volatile unsigned long *)0xF05300C0
+
+/*******************************************************************************
+*	 TCC8900_DataSheet_PART 3 GPIO_V0.00 Dec.11 2008
+********************************************************************************/
+/************************************************************************
+*	1. GPIO Register Map (Base Address = 0xF0102000) 
+************************************************************************/
+#define	HwGPIO_BASE  				*(volatile unsigned long *)0xF0102000  	// 
+#define	HwGPIOA_BASE  				*(volatile unsigned long *)0xF0102000  	// 
+#define	HwGPIOB_BASE  				*(volatile unsigned long *)0xF0102040  	// 
+#define	HwGPIOC_BASE  				*(volatile unsigned long *)0xF0102080  	// 
+#define	HwGPIOD_BASE  				*(volatile unsigned long *)0xF01020C0  	// 
+#define	HwGPIOE_BASE  				*(volatile unsigned long *)0xF0102100  	// 
+#define	HwGPIOF_BASE  				*(volatile unsigned long *)0xF0102140  	// 
+#define	HwEINTSEL_BASE  			*(volatile unsigned long *)0xF0102180  	// 
+#define HwGPIO						((PGPIO)&HwGPIO_BASE)
+#define HwGPIOA						((PGPION)&HwGPIOA_BASE)
+#define HwGPIOB						((PGPION)&HwGPIOB_BASE)
+#define HwGPIOC						((PGPION)&HwGPIOC_BASE)
+#define HwGPIOD						((PGPION)&HwGPIOD_BASE)
+#define HwGPIOE						((PGPION)&HwGPIOE_BASE)
+#define HwGPIOF						((PGPION)&HwGPIOF_BASE)
+#define HwEINTSEL					((PGPIOINT)&HwEINTSEL_BASE)
+
+#define	HwPORTCFG_GPFN0(X)			((X)<<0)	// 0~3
+#define HwPORTCFG_GPFN0_MASK		(0xF)		// HwPORTCFG_GPFN0(15)
+#define	HwPORTCFG_GPFN1(X)			((X)<<4)	// 4~7
+#define HwPORTCFG_GPFN1_MASK		(0xF<<4)	// HwPORTCFG_GPFN1(15)
+#define	HwPORTCFG_GPFN2(X)			((X)<<8)	// 8~11
+#define HwPORTCFG_GPFN2_MASK		(0xF<<8)	// HwPORTCFG_GPFN2(15)
+#define	HwPORTCFG_GPFN3(X)			((X)<<12)	// 12~15
+#define HwPORTCFG_GPFN3_MASK		(0xF<<12)	// HwPORTCFG_GPFN3(15)
+#define	HwPORTCFG_GPFN4(X)			((X)<<16)	// 16~19
+#define HwPORTCFG_GPFN4_MASK		(0xF<<16)	// HwPORTCFG_GPFN4(15)
+#define	HwPORTCFG_GPFN5(X)			((X)<<20)	// 20~23
+#define HwPORTCFG_GPFN5_MASK		(0xF<<20)	// HwPORTCFG_GPFN5(15)
+#define	HwPORTCFG_GPFN6(X)			((X)<<24)	// 24~27
+#define HwPORTCFG_GPFN6_MASK		(0xF<<24)	// HwPORTCFG_GPFN6(15)
+#define	HwPORTCFG_GPFN7(X)			((X)<<28)	// 28~31
+#define HwPORTCFG_GPFN7_MASK		(0xF<<28)	// HwPORTCFG_GPFN7(15)
+
+/*******************************************************************************
+*	 TCC8900_DataSheet_PART 4 CORE & MEMORY BUS_V0.00 Dec.11 2008
+********************************************************************************/
+/************************************************************************
+*	3. DRAM CONTROLLER Register Map (Base Address = 0xF0301000) 
+************************************************************************/
+#define	HwDRAM_BASE  				*(volatile unsigned long *)0xF0301000  	//
+#define	HwDRAMM0_BASE  				*(volatile unsigned long *)0xF0301000  	//
+#define	HwDRAMM1_BASE  				*(volatile unsigned long *)0xF0302000  	//
+#define	HwDRAMMISC_BASE  			*(volatile unsigned long *)0xF0303000  	//
+#define	HwDRAMPHY_BASE  			*(volatile unsigned long *)0xF0304400  	//
+#define	HwDRAMMEMBUS_BASE  			*(volatile unsigned long *)0xF0305004  	//
+
+/************************************************************************
+*	4-1. MISC CORE BUS CONFIGURATION REGISTERS				(Base Addr = 0xF0101000)
+************************************************************************/
+#define	HwCORECFG_BASE				*(volatile unsigned long *)0xF0101000	
+       
+/************************************************************************
+*	4-2. Virtual MMU Table  Register Define	(Base Addr = 0xF7000000)
+************************************************************************/
+#define	HwVMT_BASE					*(volatile unsigned long *)0x20000000	// VMT Base Regiseter
+#define	HwREGION_BASE				*(volatile unsigned long *)0xF0600000	// R/W, Configuration Register for Region 0
+
+
+/*******************************************************************************
+*	 TCC8900_DataSheet_PART 5 IO BUS_V0.00 Dec.11 2008
+********************************************************************************/
+/*******************************************************************************
+*	 4. Memory Stick Host Controller Register Define   (Base Addr = 0xF0590000)
+********************************************************************************/
+#define HwSMSHC_BASE                *(volatile unsigned long *)0xF0590000
+#define HwPORTCFG_BASE              *(volatile unsigned long *)0xF05F1000
+
+/********************************************************************************
+*	 5. SD/SDIO/MMC/CE-ATA Host Controller Register Define   (Base Addr = 0xF05A0000)
+********************************************************************************/
+#define HwSDCORE0SLOT0_BASE         *(volatile unsigned long *)0xF05A0000	// Core 0 Slot 0
+#define HwSDCORE0SLOT1_BASE         *(volatile unsigned long *)0xF05A0100	// Core 0 Slot 1
+#define HwSDCORE1SLOT2_BASE         *(volatile unsigned long *)0xF05A0200	// Core 1 Slot 2
+#define HwSDCORE1SLOT3_BASE         *(volatile unsigned long *)0xF05A0300	// Core 1 Slot 3
+
+// Channel Control Register
+#define HwSDCHCTRL_BASE             *(volatile unsigned long *)0xF05A0800	// R/W 0x0000 SD/MMC port control register
+
+/*******************************************************************************
+*	 6. NAND Flash Controller(NFC) Register Define   (Base Addr = 0xF05B0000)
+********************************************************************************/
+#define HwNFC_BASE                  *(volatile unsigned long *)0xF05B0000
+#define HwNFC						((PNFC)&HwNFC_BASE)
+
+// NFC Control Register
+#define	HwNFC_CTRL_RDYIEN_EN		Hw31							// Nand Flash Ready Interrupt Enable
+#define	HwNFC_CTRL_RDYIEN_DIS		~Hw31							// Nand Flash Ready Interrupt Disable
+#define	HwNFC_CTRL_PROGIEN_EN		Hw30							// Nand Flash Program Interrupt Enable 
+#define	HwNFC_CTRL_PROGIEN_DIS		~Hw30							// Nand Flash Program Interrupt Disable
+#define	HwNFC_CTRL_READIEN_EN		Hw29							// Nand Flash Read Interrupt Enable
+#define	HwNFC_CTRL_READIEN_DIS		~Hw29							// Nand Flash Read Interrupt Disable
+#define	HwNFC_CTRL_DEN_EN			Hw28							// Nand Flash DMA Request Enable
+#define	HwNFC_CTRL_DEN_DIS			~Hw28							// Nand Flash DMA Request Disable
+#define	HwNFC_CTRL_FS_RDY			Hw27							// FIFO status is Ready to write and read in FIFO
+#define	HwNFC_CTRL_FS_BUSY			~Hw27							// FIFO status is Busy to write and read in FIFO
+#define	HwNFC_CTRL_BW_16			Hw26							// Bus width = 8bit
+#define	HwNFC_CTRL_BW_8				HwZERO							// Bus width = 16bit
+#define	HwNFC_CTRL_CS3SEL_1			Hw25							// Nand Flash nCS3 is High (Disabled)
+#define	HwNFC_CTRL_CS3SEL_0			HwZERO							// Nand Flash nCS3 is Low (Enabled)
+#define	HwNFC_CTRL_CS2SEL_1			Hw24							// Nand Flash nCS2 is High (Disabled)
+#define	HwNFC_CTRL_CS2SEL_0			HwZERO							// Nand Flash nCS2 is Low (Enabled)
+#define	HwNFC_CTRL_CS1SEL_1			Hw23							// Nand Flash nCS1 is High (Disabled)
+#define	HwNFC_CTRL_CS1SEL_0			HwZERO							// Nand Flash nCS1 is Low (Enabled)
+#define	HwNFC_CTRL_CS0SEL_1			Hw22							// Nand Flash nCS0 is High (Disabled)
+#define	HwNFC_CTRL_CS0SEL_0			HwZERO							// Nand Flash nCS0 is Low (Enabled)
+#define	HwNFC_CTRL_CFG_nCS3			HwNFC_CTRL_CS3SEL_1
+#define	HwNFC_CTRL_CFG_nCS2			HwNFC_CTRL_CS2SEL_1
+#define	HwNFC_CTRL_CFG_nCS1			HwNFC_CTRL_CS1SEL_1
+#define	HwNFC_CTRL_CFG_nCS0			HwNFC_CTRL_CS0SEL_1
+#define	HwNFC_CTRL_CSnSEL(X)		((X)*Hw22)						// Nand Flash nCS[3:0] Set
+#define	HwNFC_CTRL_CFG_NOACT		HwNFC_CTRL_CSnSEL(15)
+#define	HwNFC_CTRL_RDY_RDY			Hw21							// External Nand Flash Controller is Ready
+#define	HwNFC_CTRL_RDY_BUSY			~Hw21							// External Nand Flash Controller is Busy
+#define	HwNFC_CTRL_BSIZE(X)			((X)*Hw19)
+#define	HwNFC_CTRL_BSIZE_1			HwNFC_CTRL_BSIZE(0)				// 1Read/Write
+#define	HwNFC_CTRL_BSIZE_2			HwNFC_CTRL_BSIZE(1)				// 2Read/Write
+#define	HwNFC_CTRL_BSIZE_4			HwNFC_CTRL_BSIZE(2)				// 4Read/Write
+#define	HwNFC_CTRL_BSIZE_8			HwNFC_CTRL_BSIZE(3)				// 8Read/Write
+#define	HwNFC_CTRL_BSIZE_MASK		HwNFC_CTRL_BSIZE(3)
+#define	HwNFC_CTRL_PSIZE(X)			((X)*Hw16)
+#define	HwNFC_CTRL_PSIZE_256		HwNFC_CTRL_PSIZE(0)				// 1 Page = 256 Half-Word
+#define	HwNFC_CTRL_PSIZE_512		HwNFC_CTRL_PSIZE(1)				// 1 Page = 512 Byte
+#define	HwNFC_CTRL_PSIZE_1024		HwNFC_CTRL_PSIZE(2)				// 1 Page = 1024 Half-Word
+#define	HwNFC_CTRL_PSIZE_2048		HwNFC_CTRL_PSIZE(3)				// 1 Page = 2048 Byte
+#define	HwNFC_CTRL_PSIZE_4096		HwNFC_CTRL_PSIZE(4)				// 1 Page = 4096 Byte
+#define	HwNFC_CTRL_PSIZE_MASK		HwNFC_CTRL_PSIZE(7)
+#define	HwNFC_CTRL_MASK_EN			Hw15							// Address/Command Mask Enable
+#define	HwNFC_CTRL_CADDR			Hw12							// Number of Address Cycle
+#define	HwNFC_CTRL_bSTP(X)			((X)*Hw8)						// Number of Base cycle for Setup Time
+#define	HwNFC_CTRL_bSTP_MASK		HwNFC_CTRL_bSTP(15)
+#define	HwNFC_CTRL_bPW(X)			((X)*Hw4)						// Number of Base cycle for Pulse Width
+#define	HwNFC_CTRL_bPW_MASK			HwNFC_CTRL_bPW(15)
+#define	HwNFC_CTRL_bHLD(X)			((X)*Hw0)						// Number of Base cycle for Hold Time
+#define	HwNFC_CTRL_bHLD_MASK		HwNFC_CTRL_bHLD(15)
+
+#define	HwNFC_IREQ_FLAG2			Hw6						//
+#define	HwNFC_IREQ_FLAG1			Hw5						//
+#define	HwNFC_IREQ_FLAG0			Hw4						//
+#define	HwNFC_IREQ_IRQ2				Hw2						// Ready Interrupt
+#define	HwNFC_IREQ_IRQ1				Hw1						// Program Interrupt
+#define	HwNFC_IREQ_IRQ0				Hw0						// Reading Interrupt
+
+/*******************************************************************************
+*	 7. Static Memory Controller(SMC) Register Define   (Base Addr = 0xF05F0000)
+********************************************************************************/
+#define HwSMC_BASE                  *(volatile unsigned long *)0xF05F0000
+#define HwSMC_STATUS                *(volatile unsigned long *)0xF05F0000 // R/W Unknown Status Register
+#define HwSMC_CSNCFG0               *(volatile unsigned long *)0xF05F0020 // R 0x4b40_3183 External Chip Select0 Config Register
+#define HwSMC_CSNCFG1               *(volatile unsigned long *)0xF05F0024 // R/W 0x4b40_1104 External Chip Select1 Config Register
+#define HwSMC_CSNCFG2               *(volatile unsigned long *)0xF05F0028 // W 0x4b40_4082 External Chip Select2 Config Register
+#define HwSMC_CSNCFG3               *(volatile unsigned long *)0xF05F002C // R/W 0x4b40_20C5 External Chip Select3 Config. Register
+#define HwSMC_CSNOFFSET             *(volatile unsigned long *)0xF05F0030 // R/W 0x0 Wapping Address Mode OFFSET Register
+#define HwSMC_INDIRADDR             *(volatile unsigned long *)0xF05F0034 // R/W 0x0 Indirect Address
+
+/*******************************************************************************
+*	 8. External Device Interface (EDI) Register Define   (Base Addr = 0xF05F6000)
+********************************************************************************/
+#define HwEDI_BASE                  *(volatile unsigned long *)0xF05F6000
+#define HwEDI						((PEDI)&HwEDI_BASE)
+
+/*******************************************************************************
+*	 9. IDE Controller Register Define   (Base Addr = 0xF0520000)
+********************************************************************************/
+#define HwIDE_BASE                  *(volatile unsigned long *)0xF0520000
+
+/*******************************************************************************
+*	 10. SATA Interface Register Define   (Base Addr = 0xF0560000)
+********************************************************************************/
+#define HwSATA_BASE                 *(volatile unsigned long *)0xF0560000
+//SCR5-SCR15 0x38-0x60 32 See description 0x0 Reserved for SATA Dependencies: Reads to these locations return zeros; writes have no effect
+
+/*******************************************************************************
+*	 11-1. Audio DMA Controller Register Define   (Base Addr = 0xF0533000)
+********************************************************************************/
+#define HwADMA_BASE                 *(volatile unsigned long *)0xF0533000
+
+/*******************************************************************************
+*	 11-2. DAI Register Define   (Base Addr = 0xF0534000)
+********************************************************************************/
+#define HwADMA_DAIBASE              *(volatile unsigned long *)0xF0534000
+
+/*******************************************************************************
+*	 11-3. CDIF Register Define   (Base Addr = 0xF0534000)
+********************************************************************************/
+#define HwADMA_CDIFBASE             *(volatile unsigned long *)0xF0534080
+
+/*******************************************************************************
+*	 11-4. SPDIF Register Define   (Base Addr = 0xF0535000/0xF0535800)
+********************************************************************************/
+#define HwADMA_SPDIFTXBASE          *(volatile unsigned long *)0xF0535000
+
+/*******************************************************************************
+*	 12-1. DAI Register Define   (Base Addr = 0xF0537000
+********************************************************************************/
+#define HwDAI_BASE                  *(volatile unsigned long *)0xF0537000
+
+/*******************************************************************************
+*	 12-2. CDIF Register Define   (Base Addr = 0xF0537000
+********************************************************************************/
+#define HwCDIF_BASE                 *(volatile unsigned long *)0xF0537080
+
+/*******************************************************************************
+*	 13. SPDIF Register Define   (Base Addr = 0xF0538000)
+********************************************************************************/
+#define HwSPDIF_BASE                *(volatile unsigned long *)0xF0538000
+
+/*******************************************************************************
+*	 14-1. USB1.1 HOST Controller & Transceiver       (Base Addr = 0xF0500000)
+********************************************************************************/
+#define HwUSBHOST_BASE              *(volatile unsigned long *)0xF0500000
+
+/*******************************************************************************
+*	 14-2 USB1.1 HOST Configuration Register        (Base Addr = 0xF05F5000)
+********************************************************************************/
+#define HwUSBHOSTCFG_BASE           *(volatile unsigned long *)0xF05F5000
+
+/*******************************************************************************
+*	 15-1. USB2.0 OTG Controller Define   (Base Addr = 0xF0550000)
+********************************************************************************/
+#define HwUSB20OTG_BASE             *(volatile unsigned long *)0xF0550000
+
+/*******************************************************************************
+*	 15-2. USB OTG Configuration Register Define   (Base Addr = 0xF05F5000)
+********************************************************************************/
+#define HwUSBOTGCFG_BASE            *(volatile unsigned long *)0xF05F5000
+
+/*******************************************************************************
+*	 15-3. USB PHY Configuration Register Define   (Base Addr = 0xF05F5028)
+********************************************************************************/
+#define HwUSBPHYCFG_BASE            *(volatile unsigned long *)0xF05F5028
+
+/*******************************************************************************
+*	 16. External Host Interface Register Define   (Base Addr = 0xF0570000/0xF0580000)
+********************************************************************************/
+#define HwEHICS0_BASE               *(volatile unsigned long *)0xF0570000
+#define HwEHICS1_BASE               *(volatile unsigned long *)0xF0580000
+
+/*******************************************************************************
+*	 17. General Purpose Serial Bus (GPSB) Register Define   (Base Addr = 0xF0538000)
+********************************************************************************/
+#if 0
+#define HwGPSBCH0_BASE              *(volatile unsigned long *)0xF0057000
+#define HwGPSBCH1_BASE              *(volatile unsigned long *)0xF0057100
+#define HwGPSBCH2_BASE              *(volatile unsigned long *)0xF0057200
+#define HwGPSBCH3_BASE              *(volatile unsigned long *)0xF0057300
+#define HwGPSBCH4_BASE              *(volatile unsigned long *)0xF0057400
+#define HwGPSBCH5_BASE              *(volatile unsigned long *)0xF0057500
+#define HwGPSBPORTCFG_BASE          *(volatile unsigned long *)0xF0057800
+#define HwGPSBPIDTABLE_BASE         *(volatile unsigned long *)0xF0057F00
+
+#define	HwGPSB_PIDT(X)				*(volatile unsigned long *)(0xF0057F00+(X)*4)	// R/W, PID Table Register
+#define	HwGPSB_PIDT_CH2				Hw31											// Channel 2 enable
+#define	HwGPSB_PIDT_CH1				Hw30											// Channel 1 enable
+#define	HwGPSB_PIDT_CH0				Hw29											// Channel 0 enable
+#else
+#define HwGPSBCH0_BASE              *(volatile unsigned long *)0xF0536000
+#define HwGPSBCH1_BASE              *(volatile unsigned long *)0xF0536100
+#define HwGPSBCH2_BASE              *(volatile unsigned long *)0xF0536200
+#define HwGPSBCH3_BASE              *(volatile unsigned long *)0xF0536300
+#define HwGPSBCH4_BASE              *(volatile unsigned long *)0xF0536400
+#define HwGPSBCH5_BASE              *(volatile unsigned long *)0xF0536500
+#define HwGPSBPORTCFG_BASE          *(volatile unsigned long *)0xF0536800
+#define HwGPSBPIDTABLE_BASE         *(volatile unsigned long *)0xF0536F00
+
+#define	HwGPSB_PIDT(X)				*(volatile unsigned long *)(0xF0536F00+(X)*4)	// R/W, PID Table Register
+#define	HwGPSB_PIDT_CH2				Hw31											// Channel 2 enable
+#define	HwGPSB_PIDT_CH1				Hw30											// Channel 1 enable
+#define	HwGPSB_PIDT_CH0				Hw29											// Channel 0 enable
+#endif
+
+/*******************************************************************************
+*	 18. The Transport Stream Interface (TSIF) Register Define   (Base Addr = 0xF0538000)
+********************************************************************************/
+#define HwTSIF_BASE                 *(volatile unsigned long *)0xF053B000
+#define HwTSIFPORTSEL_BASE          *(volatile unsigned long *)0xF053B800
+
+/*******************************************************************************
+*	 19. GPS Interface Register Define   (Base Addr = )
+********************************************************************************/
+
+
+/*******************************************************************************
+*	 20. Remote Control Interface Register Define   (Base Addr = 0xF05F3000)
+********************************************************************************/
+#define HwREMOCON_BASE             *(volatile unsigned long *)0xF05F3000
+
+
+/*******************************************************************************
+*	 21. I2C Controller Register Define   (Base Addr = 0xF0530000)
+********************************************************************************/
+#define HwI2CMASTER0_BASE          *(volatile unsigned long *)0xF0530000
+#define HwI2CMASTER1_BASE          *(volatile unsigned long *)0xF0530040
+#define HwI2CSLAVE_BASE            *(volatile unsigned long *)0xF0530080
+#define HwI2CSTATUS_BASE           *(volatile unsigned long *)0xF05300C0
+
+#define HwI2CMASTER0			((PSMUI2CMASTER)&HwI2CMASTER0_BASE)
+#define HwI2CMASTER1			((PSMUI2CMASTER)&HwI2CMASTER1_BASE)
+
+/*******************************************************************************
+*	 22. UART Controller Register Define   (Base Addr = 0xF0538000)
+********************************************************************************/
+#define HwUARTCH0_BASE             *(volatile unsigned long *)0xF0532000
+#define HwUARTCH1_BASE             *(volatile unsigned long *)0xF0532100
+#define HwUARTCH2_BASE             *(volatile unsigned long *)0xF0532200
+#define HwUARTCH3_BASE             *(volatile unsigned long *)0xF0532300
+#define HwUARTCH4_BASE             *(volatile unsigned long *)0xF0532400
+#define HwUARTCH5_BASE             *(volatile unsigned long *)0xF0532500
+#define HwUARTPORTMUX_BASE         *(volatile unsigned long *)0xF0532600
+
+/*******************************************************************************
+*	 23. CAN Controller Register Define   (Base Addr = 0xF0531000)
+********************************************************************************/
+#define HwCAN_BASE                 *(volatile unsigned long *)0xF0531000
+
+/*******************************************************************************
+*	 24. DMA Controller Register Define   (Base Addr = 0xF0540000)
+********************************************************************************/
+#define HwGDMA0_BASE               *(volatile unsigned long *)0xF0540000
+#define HwGDMA1_BASE               *(volatile unsigned long *)0xF0540100
+#define HwGDMA2_BASE               *(volatile unsigned long *)0xF0540200
+#define HwGDMA3_BASE               *(volatile unsigned long *)0xF0540300
+
+/*******************************************************************************
+*	 25. Real Time Clock(RTC) Register Define   (Base Addr = 0xF05F2000)
+********************************************************************************/
+#define HwRTC_BASE                 *(volatile unsigned long *)0xF05F2000
+
+/*******************************************************************************
+*	 26. TouchScreen ADC (TSADC) Register Define   (Base Addr = 0xF05F4000)
+********************************************************************************/
+#define HwTSADC_BASE               *(volatile unsigned long *)0xF05F4000
+
+/*******************************************************************************
+*	 27. Error Correction Code Register Define   (Base Addr = 0xF0539000)
+********************************************************************************/
+#define HwECC_BASE                 *(volatile unsigned long *)0xF0539000
+
+// ECC Control
+#define	HwECC_CTRL_IEN_MECC16_EN	Hw20										// MLC ECC16 Decoding Interrupt Enable
+#define	HwECC_CTRL_IEN_MECC16_DIS	~Hw20										// MLC ECC16 Decoding Interrupt Disable
+#define	HwECC_CTRL_IEN_MECC14_EN	Hw19										// MLC ECC14 Decoding Interrupt Enable
+#define	HwECC_CTRL_IEN_MECC14_DIS	~Hw19										// MLC ECC14 Decoding Interrupt Disable
+#define	HwECC_CTRL_IEN_MECC12_EN	Hw18										// MLC ECC12 Decoding Interrupt Enable
+#define	HwECC_CTRL_IEN_MECC12_DIS	~Hw18										// MLC ECC12 Decoding Interrupt Disable
+#define	HwECC_CTRL_IEN_MECC8_EN		Hw17										// MLC ECC8 Decoding Interrupt Enable
+#define	HwECC_CTRL_IEN_MECC8_DIS	~Hw17										// MLC ECC8 Decoding Interrupt Disable
+#define	HwECC_CTRL_IEN_MECC4_EN		Hw16										// MLC ECC4 Decoding Interrupt Enable
+#define	HwECC_CTRL_IEN_MECC4_DIS	~Hw16										// MLC ECC4 Decoding Interrupt Disable
+
+// ECC Disable
+#define	HwECC_CTRL_EN_SLCEN			Hw2											// SLC ECC Encoding Enable
+#define	HwECC_CTRL_EN_SLCDE			(Hw2|Hw0)									// SLC ECC Decoding Enable
+#define	HwECC_CTRL_EN_MCL4EN		(Hw2|Hw1)									// MLC ECC4 Encoding Enable
+#define	HwECC_CTRL_EN_MCL4DE		(Hw2|Hw1|Hw0)								// MLC ECC4 Decoding Enable
+#define	HwECC_CTRL_EN_MCL8EN		(Hw3)										// MLC ECC8 Encoding Enable
+#define	HwECC_CTRL_EN_MCL8DE		(Hw3|Hw0)									// MLC ECC8 Decoding Enable
+#define	HwECC_CTRL_EN_MCL12EN		(Hw3|Hw1)									// MLC ECC12 Encoding Enable
+#define	HwECC_CTRL_EN_MCL12DE		(Hw3|Hw1|Hw0)								// MLC ECC12 Decoding Enable
+#define	HwECC_CTRL_EN_MCL14EN		(Hw3|Hw2)									// MLC ECC14 Encoding Enable
+#define	HwECC_CTRL_EN_MCL14DE		(Hw3|Hw2|Hw0)								// MLC ECC14 Decoding Enable
+#define	HwECC_CTRL_EN_MCL16EN		(Hw3|Hw2|Hw1)								// MLC ECC16 Encoding Enable
+#define	HwECC_CTRL_EN_MCL16DE		(Hw3|Hw2|Hw1|Hw0)							// MLC ECC16 Decoding Enable
+#define	HwECC_CTRL_EN_DIS			~(Hw3|Hw2|Hw1|Hw0)							// ECC Disable
+
+// ECC Error Number
+#define	HwERR_NUM_ERR1				Hw0											// Correctable Error(SLC), Error Occurred(MLC3), 1 Error Occurred(MLC4)
+#define	HwERR_NUM_ERR2				Hw1											// 2 Error Occurred(MLC4)
+#define	HwERR_NUM_ERR3				(Hw1|Hw0)									// 3 Error Occurred(MLC4)
+#define	HwERR_NUM_ERR4				Hw2											// 4 Error Occurred(MLC4)
+#define	HwERR_NUM_ERR5				(Hw2|Hw0)									// 5 Error Occurred(MLC4)
+#define	HwERR_NUM_ERR6				(Hw2|Hw1)									// 5 Error Occurred(MLC4)
+#define	HwERR_NUM_ERR7				(Hw2|Hw1|Hw0)								// 5 Error Occurred(MLC4)
+#define	HwERR_NUM_ERR8				Hw3											// 5 Error Occurred(MLC4)
+#define	HwERR_NUM_ERR9				(Hw3|Hw0)									// 5 Error Occurred(MLC4)
+#define	HwERR_NUM_ERR10				(Hw3|Hw1)									// 5 Error Occurred(MLC4)
+#define	HwERR_NUM_ERR11				(Hw3|Hw1|Hw0)								// 5 Error Occurred(MLC4)
+#define	HwERR_NUM_ERR12				(Hw3|Hw2)									// 5 Error Occurred(MLC4)
+#define	HwERR_NUM_ERR13				(Hw3|Hw2|Hw0)								// 5 Error Occurred(MLC4)
+#define	HwERR_NUM_ERR14				(Hw3|Hw2|Hw1)								// 5 Error Occurred(MLC4)
+#define	HwERR_NUM_ERR15				(Hw3|Hw2|Hw1|Hw0)							// 5 Error Occurred(MLC4)
+#define	HwERR_NUM_ERR16				Hw4											// 5 Error Occurred(MLC4)
+#define	HwERR_NUM_NOERR				HwZERO										// No Error
+#define	HwERR_NUM_CORIMP			(Hw1|Hw0)									// Correction Impossible(SLC, MLC4)
+
+// ECC Interrupt Control
+#define	HwECC_IREQ_SEF				Hw17										// SLC ECC Encoding Flag Register
+#define	HwECC_IREQ_SDF				Hw16										// SLC ECC Decoding Flag Register
+#define	HwECC_IREQ_M4EF				Hw19										// MLC ECC4 Encoding Flag Register
+#define	HwECC_IREQ_M4DF				Hw18										// MLC ECC4 Decoding Flag Register
+#define	HwECC_IREQ_M8EF				Hw21										// MLC ECC8 Encoding Flag Register
+#define	HwECC_IREQ_M8DF				Hw20										// MLC ECC8 Decoding Flag Register
+#define	HwECC_IREQ_M12EF			Hw23										// MLC ECC12 Encoding Flag Register
+#define	HwECC_IREQ_M12DF			Hw22										// MLC ECC12 Decoding Flag Register
+#define	HwECC_IREQ_M14EF			Hw25										// MLC ECC14 Encoding Flag Register
+#define	HwECC_IREQ_M14DF			Hw24										// MLC ECC14 Decoding Flag Register
+#define	HwECC_IREQ_M16EF			Hw27										// MLC ECC16 Encoding Flag Register
+#define	HwECC_IREQ_M16DF			Hw26										// MLC ECC16 Decoding Flag Register
+#define	HwECC_IREQ_M4DI				Hw2											// MLC ECC4 Decoding Interrupt Request Register
+#define	HwECC_IREQ_M8DI				Hw4											// MLC ECC8 Decoding Interrupt Request Register
+#define	HwECC_IREQ_M12DI			Hw6											// MLC ECC12 Decoding Interrupt Request Register
+#define	HwECC_IREQ_M14DI			Hw8											// MLC ECC14 Decoding Interrupt Request Register
+#define	HwECC_IREQ_M16DI			Hw10										// MLC ECC16 Decoding Interrupt Request Register
+#define	HwECC_IREQ_CLR				(Hw27|Hw26|Hw25|Hw24|Hw23|Hw22|Hw21|Hw20|Hw19|Hw18|Hw17|Hw16|Hw10|Hw8|Hw6|Hw4|Hw2)
+
+/*******************************************************************************
+*	 28. Multi-Protocol Encapsulation Forward Error Correction (MPEFEC)
+*    Register Define   (Base Addr = 0xF0510000)
+********************************************************************************/
+#define HwMPEFEC_BASE              *(volatile unsigned long *)0xF0510000
+
+/*******************************************************************************
+*	 29. IOBUS Configuration Register Define   (Base Addr = 0xF05F5000)
+********************************************************************************/
+#define HwIOBUSCFG_BASE            *(volatile unsigned long *)0xF05F5000
+#define HwIOBUSCFG					((PIOBUSCFG)&HwIOBUSCFG_BASE)
+
+// IOBUS AHB 0
+#define HwIOBUSCFG_USB				Hw1											// USB2.0 OTG
+#define HwIOBUSCFG_IDE				Hw2											// IDE Controller
+#define HwIOBUSCFG_DMA				Hw3											// DMA Controller
+#define HwIOBUSCFG_SD				Hw4											// SD/MMC Controller
+#define HwIOBUSCFG_MS				Hw6											// Memory Stick Controller
+#define HwIOBUSCFG_I2C				Hw7											// I2C Controller
+#define HwIOBUSCFG_NFC				Hw8											// NFC Controller
+#define HwIOBUSCFG_EHI0				Hw9											// External Host Interface 0
+#define HwIOBUSCFG_EHI1				Hw10										// External Host Interface 1
+#define HwIOBUSCFG_UART0			Hw11										// UART Controller 0
+#define HwIOBUSCFG_UART1			Hw12										// UART Controller 1
+#define HwIOBUSCFG_UART2			Hw13										// UART Controller 2
+#define HwIOBUSCFG_UART3			Hw14										// UART Controller 3
+#define HwIOBUSCFG_UART4			Hw15										// UART Controller 4
+#define HwIOBUSCFG_UART5			Hw16										// UART Controller 5
+#define HwIOBUSCFG_GPSB0			Hw17										// GPSB Controller 0
+#define HwIOBUSCFG_GPSB1			Hw18										// GPSB Controller 1
+#define HwIOBUSCFG_GPSB2			Hw19										// GPSB Controller 2
+#define HwIOBUSCFG_GPSB3			Hw20										// GPSB Controller 3
+#define HwIOBUSCFG_GPSB4			Hw21										// GPSB Controller 4
+#define HwIOBUSCFG_GPSB5			Hw22										// GPSB Controller 5
+#define HwIOBUSCFG_DAI				Hw23										// DAI/CDIF Interface
+#define HwIOBUSCFG_ECC				Hw24										// ECC Calculator
+#define HwIOBUSCFG_SPDIF			Hw25										// SPDIF Tx Controller
+#define HwIOBUSCFG_RTC				Hw26										// RTC
+#define HwIOBUSCFG_TSADC			Hw27										// TSADC Controller
+#define HwIOBUSCFG_GPS				Hw28										// GPS Interface
+#define HwIOBUSCFG_ADMA				Hw31										// Audio DMA Controller
+
+// IOBUS AHB 1
+#define HwIOBUSCFG_MPE				Hw0											// MPE_FEC
+#define HwIOBUSCFG_TSIF				Hw1											// TSIF
+#define HwIOBUSCFG_SRAM				Hw2											// SRAM Controller
+
+#define	HwIOBUSCFG_STORAGE_ECC		~(Hw17|Hw16)							// Storage Bus
+#define	HwIOBUSCFG_STORAGE_AHB_BUS1	Hw16							// I/O bus
+#define	HwIOBUSCFG_STORAGE_AHB_BUS2	Hw17							// General purpose SRAM or DTCM
+#define	HwIOBUSCFG_STORAGE_NFC		(Hw17|Hw16)						// Main processor data bus
+
+/************************************************************************
+*	Channel 0 Memory Controller Register Define	(Base Addr = 0xF1000000)
+************************************************************************/
+#define	HwEMC_BASE				   *(volatile unsigned long *)0xF1000000	// External Memory Controller Base Register
+
+/*******************************************************************************
+*	 TCC8900_DataSheet_PART 6 DDI_BUS_V0.00 Dec.11 2008
+********************************************************************************/
+/************************************************************************
+*	4. LCD INTERFACE Register Define				(Base Addr = 0xF0200000)
+************************************************************************/
+#define	HwLCDC0_BASE				*(volatile unsigned long *)0xF0200000	// LCDC0 Control Base Register
+#define HwLCDLUT0_BASE				*(volatile unsigned long *)0xF0200400	// LCD LUT 0 Base Register
+#define	HwLCDC1_BASE				*(volatile unsigned long *)0xF0204000	// LCDC1 Control Base Register
+#define HwLCDLUT1_BASE				*(volatile unsigned long *)0xF0204400	// LCD LUT 1 Base Register
+
+/************************************************************************
+*	5. LCD System Interface Register Define		(Base Addr = 0xF0200400)
+************************************************************************/
+#define	HwLCDSI_BASE				*(volatile unsigned long *)0xF020C400	// LCDSI Base Register
+
+/***********************************************************************
+*	6. Memory to Memory Scaler Register Define	(Base Addr = 0xF0210000/0xF0220000)
+************************************************************************/
+#define HwM2MSCALER0_BASE           *(volatile unsigned long *)0xF0210000
+#define HwM2MSCALER1_BASE           *(volatile unsigned long *)0xF0220000
+
+/************************************************************************
+*	7. NTSC/PAL ENCODER Composite Output Register Define (Base Addr = 0xF0240000)
+************************************************************************/
+#define	HwTVE_BASE					*(volatile unsigned long *)0xF0240000	// TV Encoder Base Register
+
+/************************************************************************
+*	8. HDMI Register Define				(Base Addr = 0xF0254000)
+************************************************************************/
+//Controller register base address 
+#define HwHDMICTRL_BASE				*(volatile unsigned long *)0xF0254000	//Controller register base address 
+	
+//HDMI register base address 
+#define HwHDMICORE_BASE  			*(volatile unsigned long *)0xF0255000  
+
+//AES register base address 
+#define HwHDMIAES_BASE  			*(volatile unsigned long *)0xF0256000  //AES register base address 
+
+//SPDIF Receiver register base address 
+#define HwHDMISPDIF_BASE  			*(volatile unsigned long *)0xF0257000  
+
+//I2S Receiver register base address 
+#define HwHDMII2S_BASE  			*(volatile unsigned long *)0xF0258000  
+				
+ //CEC register base address 					
+#define HwHDMICEC_BASE  			*(volatile unsigned long *)0xF0259000 
+
+/***********************************************************************
+*	 9-1. Camera Interface Register Define			(Base Addr = 0xF0230000)
+************************************************************************/
+#define	HwCIF_BASE					*(volatile unsigned long *)0xF0230000	// CIF Base Register
+#define HwCIF						((PCIF)&HwCIF_BASE)
+
+// Input Image Color/Pattern Configuration 1
+#define	HwICPCR1_ON					Hw31										// On/Off on CIF >> 0:Can't operate CIF , 1:Operating CIF
+#define	HwICPCR1_PWD				Hw30										// Power down mode in camera >> 0:Disable, 1:Power down mode , This power down mode is connected the PWDN of camera sensor
+#define	HwICPCR1_BPS				Hw23										// Bypass Scaler >> 0:Non, 1:Bypass
+#define	HwICPCR1_POL				Hw21										// PXCLK Polarity >> 0:Positive edge, 1:Negative edge
+#define	HwICPCR1_SKPF				(Hw20|Hw19|Hw18)							// Skip Frame >> 0~7 #Frames skips	[20:18]
+#define	HwICPCR1_M420_ZERO			HwZERO										// Format Convert (YUV422->YUV420) , Not-Convert
+#define	HwICPCR1_M420_ODD			Hw17										// converted in odd line skip
+#define	HwICPCR1_M420_EVEN			(Hw17|Hw16)									// converted in even line skip
+#define	HwICPCR1_BP					Hw15										// Bypass
+#define	HwICPCR1_BBS_LSB8			Hw14										// When bypass 16bits mode, LSB 8bits are stored in first
+#define	HwICPCR1_C656				Hw13										// Convert 656 format 0:Disable, 1:Enable
+#define	HwICPCR1_CP_RGB				Hw12										// RGB(555,565,bayer) color pattern
+#define	HwICPCR1_PF_444				HwZERO										// 4:4:4 format
+#define	HwICPCR1_PF_422				Hw10										// 4:2:2 format
+#define	HwICPCR1_PF_420				Hw11										// 4:2:0 format or RGB(555,565,bayer) mode
+#define	HwICPCR1_RGBM_BAYER			HwZERO										// Bayer RGB Mode
+#define	HwICPCR1_RGBM_RGB555		Hw8											// RGB555 Mode
+#define	HwICPCR1_RGBM_RGB565		Hw9											// RGB565 Mode
+#define	HwICPCR1_RGBBM_16			HwZERO										// 16bit mode
+#define	HwICPCR1_RGBBM_8DISYNC		Hw6											// 8bit disable sync
+#define	HwICPCR1_RGBBM_8			Hw7											// 8bit mode
+#define	HwICPCR1_CS_RGBMG			HwZERO										// 555RGB:RGB(MG), 565RGB:RGB, 444/422/420:R/Cb/U first, Bayer RGB:BG->GR, CCIR656:YCbYCr
+#define	HwICPCR1_CS_RGBLG			Hw4											// 555RGB:RGB(LG), 565RGB:RGB, 444/422/420:R/Cb/U first, Bayer RGB:GR->BG, CCIR656:YCrYCb
+#define	HwICPCR1_CS_BGRMG			Hw5											// 555RGB:BGR(MG), 565RGB:BGR, 444/422/420:B/Cr/V first, Bayer RGB:RG->GB, CCIR656:CbYCrY
+#define	HwICPCR1_CS_BGRLG			(Hw5|Hw4)									// 555RGB:BGR(LG), 565RGB:BGR, 444/422/420:B/Cr/V first, Bayer RGB:GB->RG, CCIR656:CrYCbY
+#define	HwICPCR1_BO_SW				Hw2											// Switch the MSB/LSB 8bit Bus
+#define	HwICPCR1_HSP_HIGH			Hw1											// Active high
+#define	HwICPCR1_VSP_HIGH			Hw0											// Active high
+
+// CCIR656 Format Configuration 1
+#define	Hw656FCR1_PSL_1ST			HwZERO										// The status word is located the first byte of EAV & SAV
+#define	Hw656FCR1_PSL_2ND			Hw25										// The status word is located the second byte of EAV & SAV
+#define	Hw656FCR1_PSL_3RD			Hw26										// The status word is located the third byte of EAV & SAV
+#define	Hw656FCR1_PSL_4TH			(Hw26|Hw25)									// The status word is located the forth byte of EAV & SAV
+																				//FPV [23:16] 0x00FF0000,	SPV [15:8] 0x0000FF00, TPV [7:0]	0x000000FF
+// CMOSIF DMA Configuratin 1
+#define	HwCDCR1_TM_INC				Hw3											// INC Transfer
+#define	HwCDCR1_LOCK_ON				Hw2											// Lock Transfer
+#define	HwCDCR1_BS_1				HwZERO										// The DMA transfers the image data as 1 word to memory
+#define	HwCDCR1_BS_2				Hw0											// The DMA transfers the image data as 2 word to memory
+#define	HwCDCR1_BS_4				Hw1											// The DMA transfers the image data as 4 word to memory
+#define	HwCDCR1_BS_8				(Hw1|Hw0)									// The DMA transfers the image data as 8 word to memory (default)
+
+// FIFO Status
+#define	HwFIFOSTATE_CLR				Hw21										// Clear FIFO states, 1:Clear, 0:Not Clear
+#define	HwFIFOSTATE_REO				Hw19										// Overlay FIFO Read ERROR,	1:The empty signal of input overlay FIFO and read enable signal are High, 0:The empty signal of overlay FIFO is low, or empty is High and read enable signal is Low.
+#define	HwFIFOSTATE_REV				Hw18										// V(B) Channel FiFO Read ERROR, 1:The empty signal of input V(B) channel FIFO and read enable signal are High, 0:The empty signal of V(B) channel FIFO is Low, or empty is High and read enable signal is Low.
+#define	HwFIFOSTATE_REU				Hw17										// U(R) Channel FiFO Read ERROR, 1:The empty signal of input U(R) channel FIFO and read enable signal are High, 0:The empty signal of U(R) channel FIFO is Low, or empty is High and read enable signal is Low.
+#define	HwFIFOSTATE_REY				Hw16										// Y(G) Channel FiFO Read ERROR, 1:The empty signal of input Y(G) channel FIFO and read enable signal are High, 0:The empty signal of Y(G) channel FIFO is Low, or empty is High and read enable signal is Low.
+#define	HwFIFOSTATE_WEO				Hw13										// Overlay FIFO Write ERROR, 1:The full signal of overlay FIFO and write enable signal are High, 0:The full signal of overlay FIFO is Low, or full is High and write enable signal is Low.
+#define	HwFIFOSTATE_WEV				Hw12										// V(B) Channel FiFO Write ERROR, 1:The full signal of V(B) channel FIFO and write enable signal are High, 0:The full signal of V(B) channel FIFO is Low, or full is High and write enable signal is Low.
+#define	HwFIFOSTATE_WEU				Hw11										// U(R) Channel FiFO Write ERROR, 1:The full signal of U(R) channel FIFO and write enable signal are High, 0:The full signal of U(R) channel FIFO is Low, or full is High and write enable signal is Low.
+#define	HwFIFOSTATE_WEY				Hw10										// Y(G) Channel FiFO Write ERROR, 1:The full signal of Y channel FIFO and write enable signal are High, 0:The full signal of Y channel FIFO is Low, or full is High and write enable signal is Low.
+#define	HwFIFOSTATE_EO				Hw8											// Overlay FIFO Empty Signal, 1:The state of overlay FIFO is empty, 0:The state of overlay FIFO is non-empty.
+#define	HwFIFOSTATE_EV				Hw7											// V(B) Channel FiFO Empty Signal, 1:The state of V(B) channel FIFO is empty, 0:The state of V(B) channel FIFO is non-empty.
+#define	HwFIFOSTATE_EU				Hw6											// U(R) Channel FiFO Empty Signal, 1:The state of U(R) channel FIFO is empty, 0:The state of U(R) channel FIFO is non-empty.
+#define	HwFIFOSTATE_EY				Hw5											// Y(G) Channel FiFO Empty Signal, 1:The state of Y channel FIFO is empty, 0:The state of Y channel FIFO is non-empty.
+#define	HwFIFOSTATE_FO				Hw3											// Overlay FiFO FULL Signal, 1:The state of overlay FIFO is full, 0:The state of overlay FIFO is non-full.
+#define	HwFIFOSTATE_FV				Hw2											// V(B) Channel FiFO FULL Signal, 1:The state of V(B) channel FIFO is full, 0:The state of V(B) channel FIFO is non-full.
+#define	HwFIFOSTATE_FU				Hw1											// U(R) Channel FiFO FULL Signal, 1:The state of U(R) channel FIFO is full, 0:The state of U(R) channel FIFO is non-full.
+#define	HwFIFOSTATE_FY				Hw0											// Y(G) Channel FiFO FULL Signal, 1:The state of Y(G) channel FIFO is full, 0:The state of Y(G) channel FIFO is non-full.
+
+// Interrupt & CIF Operating
+#define	HwCIRQ_IEN					Hw31										// Interrupt Enable	0:interrupt disable, 1:interrupt enable
+#define	HwCIRQ_URV					Hw30										// Update Register in VSYNC	0:Register is update without VSYNC , 1:When VSYNC is posedge, register is updated.
+#define	HwCIRQ_ITY					Hw29										// Interrupt Type	0:Pulse type, 1:Hold-up type when respond signal(ICR) is high
+#define	HwCIRQ_ICR					Hw28										// Interrupt Clear 0:.... , 1:Interrupt Clear (using ITY is Hold-up type)
+#define	HwCIRQ_MVN					Hw26										// Mask interrupt of VS negative edge,	0:Don't mask, 1:Mask
+#define	HwCIRQ_MVP					Hw25										// Mask interrupt of VS positive edge,	0:Don't mask, 1:Mask
+#define	HwCIRQ_MVIT					Hw24										// Mask interrupt of VCNT Interrupt,	0:Don't mask, 1:Mask
+#define	HwCIRQ_MSE					Hw23										// Mask interrupt of Scaler Error,	0:Don't mask, 1:Mask
+#define	HwCIRQ_MSF					Hw22										// Mask interrupt of Scaler finish,	0:Don't mask, 1:Mask
+#define	HwCIRQ_MENS					Hw21										// Mask interrupt of Encoding start,	0:Don't mask, 1:Mask
+#define	HwCIRQ_MRLV					Hw20										// Mask interrupt of Rolling V address,	0:Don't mask, 1:Mask
+#define	HwCIRQ_MRLU					Hw19										// Mask interrupt of Rolling U address,	0:Don't mask, 1:Mask
+#define	HwCIRQ_MRLY					Hw18										// Mask interrupt of Rolling Y address,	0:Don't mask, 1:Mask
+#define	HwCIRQ_MSCF					Hw17										// Mask interrupt of Capture frame,	0:Don't mask, 1:Mask
+#define	HwCIRQ_MSOF					Hw16										// Mask interrupt of Stored one frame,	0:Don't mask, 1:Mask
+#define	HwCIRQ_VSS					Hw12										// Status of vertical sync, Non-vertical sync blank area.
+#define	HwCIRQ_VN					Hw10										// VS negative, 0:-, 1:When VS is generated if negative edge
+#define	HwCIRQ_VP					Hw9											// VS positive, 0:-, 1:When VS is generated if positive edge
+#define	HwCIRQ_VIT					Hw8											// VCNT Interrupt, 0:-, 1:When VCNT is generated....
+#define	HwCIRQ_SE					Hw7											// Scaler Error, 0:-, 1:When Scale operation is not correct.
+#define	HwCIRQ_SF					Hw6											// Scaler Finish, 0:-, 1:When Scale operation is finished
+#define	HwCIRQ_ENS					Hw5											// Encoding start status, 0:-, 1:When Y address is bigger than encoding start address, this bit is high
+#define	HwCIRQ_ROLV					Hw4											// Rolling V address status, 0:-, 1:If V address is move to start address, this bit is high
+#define	HwCIRQ_ROLU					Hw3											// Rolling U address starus, 0:-, 1:If U address is move to start address, this bit is high 
+#define	HwCIRQ_ROLY					Hw2											// Rolling Y address starus, 0:-, 1:If Y address is move to start address, this bit is high 
+#define	HwCIRQ_SCF					Hw1											// Stored captured frame,	0:-, 1:If Captured frame is stored, this bit is high
+#define	HwCIRQ_SOF					Hw0											// Stored One frame, 0-, 1:If one frame if stored, this bit is high.
+
+// Overlay Control 1
+#define	HwOCTRL1_OCNT_MAX			(Hw29|Hw28|Hw27|Hw26|Hw25|Hw24)				//[28:24] Overlay Count FIFO (Hw27|Hw26|Hw25|Hw24|Hw23)
+#define	HwOCTRL1_OM_BLOCK			Hw16										// Overlay Method 0:Full image overlay, 1:Block image overlay	, Full image overlay mode, overlay image size is equal to the input image size.
+#define	HwOCTRL1_OE_EN				Hw12										// Overlay enable 0:Disable, 1:Enable
+#define	HwOCTRL1_XR1_100			Hw10										// XOR in AP1 is 3 (100%)	0:XOR operation, 1:100%	, When AP1 is 3 and CEN & AEN is 1, We select the 100% alpha value or XOR.
+#define	HwOCTRL1_XR0_100			Hw9											// XOR in AP0 is 3 (100%)	0:XOR operation, 1:100%	, When AP0 is 3 and CEN & AEN is 1, We select the 100% alpha value or XOR.
+#define	HwOCTRL1_AP1_25				HwZERO										// Alpha Value in alpha is 1		// 25%			
+#define	HwOCTRL1_AP1_50				Hw6											// Alpha Value in alpha is 1		// 50%
+#define	HwOCTRL1_AP1_75				Hw7											// Alpha Value in alpha is 1		// 75%				
+#define	HwOCTRL1_AP1_100			(Hw7|Hw6)									// Alpha Value in alpha is 1		// 100% or XOR operation (for XR value)
+#define	HwOCTRL1_AP0_25				HwZERO										// Alpha Value in alpha is 0		// 25%			
+#define	HwOCTRL1_AP0_50				Hw4											// Alpha Value in alpha is 0		// 50%
+#define	HwOCTRL1_AP0_75				Hw5											// Alpha Value in alpha is 0		// 75%				
+#define	HwOCTRL1_AP0_100			(Hw5|Hw4)									// Alpha Value in alpha is 0		// 100% or XOR operation
+																				// When 565RGB and AEN, alpha value is depend on AP0 value.
+#define	HwOCTRL1_AEN_EN				Hw2											// Alpha enable	0:Disable, 1:Enable
+#define	HwOCTRL1_CEN_EN				Hw0											// Chroma key enable	0:Disable, 1:Enable
+
+// Overlay Control 2 
+#define	HwOCTRL2_CONV				Hw3											// Color Converter Enable 0:Disable, 1:Enable 
+#define	HwOCTRL2_RGB_565			HwZERO										// RGB mode 565RGB 
+#define	HwOCTRL2_RGB_555			Hw1											// RGB mode 555RGB
+#define	HwOCTRL2_RGB_444			Hw2											// RGB mode 444RGB
+#define	HwOCTRL2_RGB_332			(Hw2|Hw1)									// RGB mode 332RGB
+#define	HwOCTRL2_MD					Hw0											// Color Mode	0:YUV Color, 1:RGB color
+
+// Overlay Control 3 -- KEY Value 
+#define	HwOCTRL3_KEYR_MAX			0x00FF0000									// Chroma-key value R(U), Chroea-key value in R(U) channel, Default value is 0x00
+#define	HwOCTRL3_KEYG_MAX			0x0000FF00									// Chroma-key value G(Y), Chroea-key value in G(Y) channel, Default value is 0x00
+#define	HwOCTRL3_KEYB_MAX			0x000000FF									// Chroma-key value B(V), Chroea-key value in B(V) channel, Default value is 0x00
+ 
+// Overlay Control 4 -- Mask KEY Value
+#define	HwOCTRL4_MKEYR_MAX			0x00FF0000									// Mask Chroma-key value R(U), Chroea-key value in R(U) channel, Default value is 0x00
+#define	HwOCTRL4_MKEYG_MAX			0x0000FF00									// Mask Chroma-key value G(Y), Chroea-key value in G(Y) channel, Default value is 0x00
+#define	HwOCTRL4_MKEYB_MAX			0x000000FF									// Mask Chroma-key value B(V), Chroea-key value in B(V) channel, Default value is 0x00
+
+// Camera Down Scaler
+#define	HwCDS_SFH_1					HwZERO										// Horizontal Scale Factor, 1/1 down scale
+#define	HwCDS_SFH_2					Hw4											// Horizontal Scale Factor, 1/2 down scale
+#define	HwCDS_SFH_4					Hw5											// Horizontal Scale Factor, 1/4 down scale
+#define	HwCDS_SFH_8					(Hw5|Hw4)									// Horizontal Scale Factor, 1/8 down scale
+#define	HwCDS_SFV_1					HwZERO										// Vertical Scale Factor, 1/1 down scale
+#define	HwCDS_SFV_2					Hw2											// Vertical Scale Factor, 1/2 down scale
+#define	HwCDS_SFV_4					Hw3											// Vertical Scale Factor, 1/4 down scale
+#define	HwCDS_SFV_8					(Hw3|Hw2)									// Vertical Scale Factor, 1/8 down scale
+#define	HwCDS_SEN_EN				Hw0											// Scale enable, 0:Disable, 1:enable
+
+// CMOSIF Capture mode1
+#define	HwCCM1_ENCNUM				0xF0000000									// Encode INT number (using CAP mode) [31:28], value area (0~15), Encode interrupt number
+#define	HwCCM1_ROLNUMV				0x0F000000									// Rolling number in V (using CAP mode) [27:24], value area (0~15), Rolling number
+#define	HwCCM1_ROLNUMU				0x00F00000									// Rolling number in U (using CAP mode) [23:20], value area (0~15), Rolling number
+#define	HwCCM1_ROLNUMY				0x000F0000									// Rolling number in Y (using CAP mode) [19:16], value area (0~15), Rolling number
+#define	HwCCM1_CB					Hw10										// Capture Busy,	0:-, 1:Capture busy
+#define	HwCCM1_EIT					Hw9											// Encodig INT count,	0:Always 1 pulse, 1:Counting encoding INT
+#define	HwCCM1_UES					Hw8											// Using Encoding Start Address,	0:disable, 1:Enable
+#define	HwCCM1_SKIPNUM				0x000000F0									// Skip frame number (using CAP mode) [7:4], value area (0~15), Skip frame number
+#define	HwCCM1_RLV					Hw3											// Rolling address V,	0:disable, 1:Enable
+#define	HwCCM1_RLU					Hw2											// Rolling address U,	0:disable, 1:Enable
+#define	HwCCM1_RLY					Hw1											// Rolling address Y,	0:disable, 1:Enable
+#define	HwCCM1_CAP					Hw0											// Image Capture,	0:Normal, 1:Image Capture
+
+// CMOSIF Capture mode2
+#define	HwCCM2_VCNT					0x000000F0									// Description (Using CAP mode) [7:4], Threshold line counter in interrupt 1:16 line, 2:32 line, 3: 48 line...
+#define	HwCCM2_VEN					Hw0											// VCNT folling enable (Using CAP mode) 0:Normal(?) Disalbe?, 1:Enable
+
+// CMOSIF R2Y confiquration
+#define	HwCR2Y_FMT					(Hw4|Hw3|Hw2|Hw1)							// FMT[4:1]	0000 -> Input format 16bit 565RGB(RGB sequence)   750A CIF SPEC. 1-22
+#define	HwCR2Y_EN					Hw0											// R2Y Enable,	0:disable, 1:Enable
+
+// CMOSIF Current Line Count
+#define	HwCCLC_LCNT					0x0000FFFF									// LCNT[15:0]	Current Line Count
+
+
+
+/***********************************************************************
+*	 9-2. Effect Register Define			(Base Addr = 0xF0230100)
+************************************************************************/
+#define	HwCEM_BASE					*(volatile unsigned long *)0xF0230100  //W/R  0x00000000  Effect mode register 
+#define HwCEM						((PEFFECT)&HwCEM_BASE)
+
+// CMOSIF Effect mode
+#define	HwCEM_UVS					Hw15										// UV Swap	0:u-v-u-v sequence, 1:v-u-v-u sequence
+#define	HwCEM_VB					Hw14										// V Bias (V channel value offset),	0:disable, 1:Enable 
+#define	HwCEM_UB					Hw13										// U Bias (U channel value offset),	0:disable, 1:Enable
+#define	HwCEM_YB					Hw12										// Y Bias (Y channel value offset),	0:disable, 1:Enable
+#define	HwCEM_YCS					Hw11										// YC Swap	0:u-y-v-y sequence, 1:y-u-y-v sequence
+#define	HwCEM_IVY					Hw10										// Invert Y,	0:disable, 1:Enable 
+#define	HwCEM_STC					Hw9											// Strong C,	0:disable, 1:Enable 
+#define	HwCEM_YCL					Hw8											// Y Clamp (Y value clipping),	0:disable, 1:Enable 
+#define	HwCEM_CS					Hw7											// C Select (Color filter),	0:disable, 1:Enable(Color filter)	
+#define	HwCEM_SKT					Hw6											// Sketch Enable,	0:disable, 1:Enable 
+#define	HwCEM_EMM					Hw5											// Emboss mode,	0:Positive emboss, 1:Negative emboss
+#define	HwCEM_EMB					Hw4											// Emboss,	0:disable, 1:Enable	
+#define	HwCEM_NEGA					Hw3											// Negative mode,	0:disable, 1:Enable 
+#define	HwCEM_GRAY					Hw2											// Gray mode,	0:disable, 1:Enable 
+#define	HwCEM_SEPI					Hw1											// Sepia mode,	0:disable, 1:Enable	
+#define	HwCEM_NOR					Hw0											// Normal mode,	0:Effect mode, 1:Normal mode 
+
+// CMOSIF Sepia UV Setting
+#define	HwHwCSUV_SEPIA_U			0x0000FF00									// SEPIA_U[15:8] U channel threshold value for sepia
+#define	HwHwCSUV_SEPIA_V			0x000000FF									// SEPIA_V[7:0] V channel threshold value for sepia
+
+// CMOSIF Color selection
+#define	HwCCS_USTART				0xFF000000									// USTART [31:24]	Color filter range start point of U channel
+#define	HwCCS_UEND					0x00FF0000									// UEND	[23:16]	Color filter range end point of U channel
+#define	HwCCS_VSTART				0x0000FF00									// VSTART [15:8]	Color filter range start point of V channel
+#define	HwCCS_VEND					0x000000FF									// VEND	[7:0]	 Color filter range end point of V channel
+
+// CMOSIF H-filter coefficent
+#define	HwCHFC_COEF0				0x00FF0000									// COEF0	[23:16] Horizontal filter coefficient0 for emboss or sketch 
+#define	HwCHFC_COEF1				0x0000FF00									// COEF1	[15:8] Horizontal filter coefficient1 for emboss or sketch 
+#define	HwCHFC_COEF2				0x000000FF									// COEF2	[7:0] Horizontal filter coefficient2 for emboss or sketch 
+
+// CMOSIF Sketch threshold
+#define	HwCST_THRESHOLD				0x000000FF									// Sketch [7:0] Sketch threshold
+
+// CMOSIF Clamp threshold
+#define	HwCCT_THRESHOLD				0x000000FF									// Clamp [7:0] Clamp threshold
+
+// CMOSIF BIAS
+#define	HwCBR_YBIAS					0x00FF0000									// Y_BIAS [23:16] Y value offset
+#define	HwCBR_UBIAS					0x0000FF00									// U_BIAS [15:8]	U value offset
+#define	HwCBR_VBIAS					0x000000FF									// V_BIAS [7:0]	V value offset
+
+// CMOSIF Image size
+#if defined (SENSOR_3M) || defined (SENSOR_5M)
+#define	HwCEIS_HSIZE				0x0FFF0000									// HSIZE [26:16]	Horizontal size of input image
+#else
+#define	HwCEIS_HSIZE				0x07FF0000									// HSIZE [26:16]	Horizontal size of input image
+#endif
+#define	HwCEIS_VSIZE				0x000007FF									// VSIZE [10:0]	Vertical size of input image
+
+#define HwCIC_H2H_WAIT                      0xFFFF0000       // H2H_WAIT [31:16]   Horizontal sync (hs)to hs wait cycle
+#define HwCIC_STB_CYCLE                      0x0000FF00      // STB_CYCLE [15:8]  CCIR strobe cycle,  Minimum Value of STB_CYCLE is 4.
+#define HwCIC_INP_WAIT                        (Hw6|Hw5|Hw4)      // INP_WAIT [6:4]     ???????????????
+#define HwCIC_INPR                                Hw3     // ???????????????
+#define HwCIC_FA                                   Hw2     // Flush all
+#define HwCIC_INE                                  Hw1     // Inpath Enalbe,   0:disable, 1:Enable 
+#define HwCIC_INP                                  Hw0     // Inpath Mode,   0:Camera mode, 1:Memory mode
+
+// Y 32    U, V  4bit  cif address   .
+//	HwCISA1_SRC_BASE Y 4      ,,     32 address  . 
+// CMOSIF INPATH Source address in Y channel
+#define	HwCISA1_SRC_BASE			0xF0000000									// SRC_BASE [31:28] Source base address (31 down to 28 bit assign in base address)
+#define	HwCISA1_SRC_BASE_Y			0x0FFFFFFF									// SRC_BASE_Y [27:0] Source base address in Y channel (27 down to 0 bit assign in bass address)
+
+// CMOSIF INPATH Source address in U channel
+#define	HwCISA2_SRC_TYPE_422SEQ0	HwZERO										// 0: (4:2:2 SEQ0)
+#define	HwCISA2_SRC_TYPE_422SEQ1	Hw28										// 1: (4:2:2 SEQ1)
+#define	HwCISA2_SRC_TYPE_422SEPA	Hw29										// 2: (4:2:2 Separate)
+#define	HwCISA2_SRC_TYPE_420SEPA	(Hw29|Hw28)									// 3: (4:2:0 Separate)
+#define	HwCISA2_SRC_BASE_U			0x0FFFFFFF									// SRC_BASE_U [27:0] Source base address in U channal (27 down to 0 bit assign in base address)
+
+// CMOSIF INPATH Source address in V channel
+#define	HwCISA3_SRC_BASE_V			0x0FFFFFFF									// SRC_BASE_V [27:0] Source base address in V channal (27 down to 0 bit assign in base address)
+
+
+// CMOSIF INPATH Source image offset
+//#define	HwCISO_SRC_OFFSET_H			0x0FFF0000									// SRC_OFFSET_H [27:16] source address offset in H
+//#define	HwCISO_SRC_OFFSET_V			0x00000FFF									// SRC_OFFSET_V [11:0]	source address offset in V
+#define	HwCISO_SRC_OFFSET_Y			0x0FFF0000									// SRC_OFFSET_Y [27:16] source address offset in Y channel
+#define	HwCISO_SRC_OFFSET_C			0x00000FFF									// SRC_OFFSET_C [11:0]	source address offset in C channel
+
+// CMOSIF INPATH Source image size
+#define	HwCISS_SRC_HSIZE			0x0FFF0000									// SRC_HSIZE [27:16] Horizontal size in source image
+#define	HwCISS_SRC_VSIZE			0x00000FFF									// SRC_VSIZE [11:0]	Vertical size in source image
+
+
+// CMOSIF INPATH Destination image size
+#define	HwCIDS_DST_HSIZE			0x0FFF0000									// DST_HSIZE [27:16] Horizontal size in destination image
+#define	HwCIDS_DST_VSIZE			0x00000FFF									// DST_VSIZE [11:0]	Vertical size in destination image
+
+// HSCALE = SRC_HSIZE*256/DST_HSIZE
+// VSCALE = SRC_VSIZE*256/DST_VSIZE
+// CMOSIF INPATH Target scale
+#define	HwCIS_HSCALE				0x3FFF0000									// HSCALE [29:16] Horizontal scale factor
+#define	HwCIS_VSCALE				0x00003FFF									// VSCALE [13:0]	Vertical scale factor
+
+
+
+/***********************************************************************
+*	 9-3. Scaler Register Define			(Base Addr = 0xF0230200)
+************************************************************************/
+#define	HwCSC_BASE					*(volatile unsigned long *)0xF0230200  //W/R  0x00000000  Scaler configuration 
+#define HwCSC						((PCIFSCALER)&HwCSC_BASE)
+
+// Scaler configuration
+#define	HwSCC_EN					Hw0											// Scaler Enable	0:disable, 1:Enable 
+
+// HSCALE = SRC_HSIZE*256/DST_HSIZE
+// VSCALE = SRC_VSIZE*256/DST_VSIZE
+// Scale factor
+#define	HwSCSF_HSCALE				0x3FFF0000									// HSCALE [29:16] Horizontal scale factor
+#define	HwSCSF_VSCALE				0x00003FFF									// VSCALE [13:0]	Vertical scale factor
+
+// Image offset
+#define	HwSCSO_OFFSET_H				0x0FFF0000									// H [27:16] Horizontal offset
+#define	HwSCSO_OFFSET_V				0x00000FFF									// V [11:0]	Vertical offset
+
+// Source image size
+#define	HwSCSS_HSIZE				0x0FFF0000									// H [27:16] Horizontal size in source image
+#define	HwSCSS_VSIZE				0x00000FFF									// V [11:0]	Vertical size in source image
+
+// Destination image size
+#define	HwSCDS_HSIZE				0x0FFF0000									// H [27:16] Horizontal size in destination image
+#define	HwSCDS_VSIZE				0x00000FFF									// V [11:0]	Vertical size in destination image
+
+/***********************************************************************
+*   10. Video and Image  Quality Enhancer Register Define	(Base Addr = 0xF0230200)
+************************************************************************/
+#define HwVIQE_BASE                 *(volatile unsigned long *)0xF0252000
+
+/***********************************************************************
+*   11. LVDS Register Define                	(Base Addr = 0xF0230200)
+************************************************************************/
+#define HwDDI_CONFIG_BASE           *(volatile unsigned long *)0xF0251000
+#define HwDDI_CONFIG				((PDDICONFIG)&HwDDI_CONFIG_BASE)
+
+// HDMI Control register
+#define	HwDDIC_HDMI_CTRL_EN			Hw15
+#define	HwDDIC_HDMI_CTRL_SEL_LCDC0	HwZERO
+#define	HwDDIC_HDMI_CTRL_SEL_LCDC1	Hw14
+#define	HwDDIC_HDMI_CTRL_RST_HDMI	Hw0
+#define	HwDDIC_HDMI_CTRL_RST_SPDIF	Hw1
+#define	HwDDIC_HDMI_CTRL_RST_TMDS	Hw2
+#define	HwDDIC_HDMI_CTRL_RST_NOTUSE	Hw3
+
+// Power Down
+#define	HwDDIC_PWDN_HDMI			Hw8											// HDMI Interface
+#define	HwDDIC_PWDN_DDIC			Hw7											// DDIBUS Cache
+#define	HwDDIC_PWDN_MSCL1			Hw6											// Memory Scaler 1
+#define	HwDDIC_PWDN_MSCL0			Hw5											// Memory Scaler 0
+#define	HwDDIC_PWDN_LCDSI			Hw4											// LCDSI Interface
+#define	HwDDIC_PWDN_LCDC1			Hw3											// LCD 1 Interface
+#define	HwDDIC_PWDN_LCDC0			Hw2											// LCD 0 Interface
+#define	HwDDIC_PWDN_VIQE			Hw1											// Video Image Quality Enhancer
+#define	HwDDIC_PWDN_CIF				Hw0											// Camera Interface
+
+// Soft Reset
+#define	HwDDIC_SWRESET_HDMI			Hw8											// HDMI Interface
+#define	HwDDIC_SWRESET_DDIC			Hw7											// DDIBUS Cache
+#define	HwDDIC_SWRESET_MSCL1		Hw6											// Memory Scaler 1
+#define	HwDDIC_SWRESET_MSCL0		Hw5											// Memory Scaler 0
+#define	HwDDIC_SWRESET_LCDSI		Hw4											// LCDSI Interface
+#define	HwDDIC_SWRESET_LCDC1		Hw3											// LCD 1 Interface
+#define	HwDDIC_SWRESET_LCDC0		Hw2											// LCD 0 Interface
+#define	HwDDIC_SWRESET_VIQE			Hw1											// Video Image Quality Enhancer
+#define	HwDDIC_SWRESET_CIF			Hw0											// Camera Interface
+
+#define HwDDI_CACHE_BASE            *(volatile unsigned long *)0xF0250000
+#define HwDDI_CACHE					((PDDICACHE)&HwDDI_CACHE_BASE)
+
+// DDI CACHE Control
+#define	HwDDIC_CTRL_BW				Hw31
+#define	HwDDIC_CTRL_CIF_DMA			Hw25
+#define	HwDDIC_CTRL_VIQE_DMA2_2		Hw24
+#define	HwDDIC_CTRL_VIQE_DMA2_1		Hw23
+#define	HwDDIC_CTRL_VIQE_DMA2_0		Hw22
+#define	HwDDIC_CTRL_VIQE_DMA1_2		Hw21
+#define	HwDDIC_CTRL_VIQE_DMA1_1		Hw20
+#define	HwDDIC_CTRL_VIQE_DMA1_0		Hw19
+#define	HwDDIC_CTRL_VIQE_DMA0_2		Hw18
+#define	HwDDIC_CTRL_VIQE_DMA0_1		Hw17
+#define	HwDDIC_CTRL_VIQE_DMA0_0		Hw16
+#define	HwDDIC_CTRL_MSCL1_DMA2		Hw15
+#define	HwDDIC_CTRL_MSCL1_DMA1		Hw14
+#define	HwDDIC_CTRL_MSCL1_DMA0		Hw13
+#define	HwDDIC_CTRL_MSCL0_DMA2		Hw12
+#define	HwDDIC_CTRL_MSCL0_DMA1		Hw11
+#define	HwDDIC_CTRL_MSCL0_DMA0		Hw10
+#define	HwDDIC_CTRL_LCD1_DMA2		Hw9
+#define	HwDDIC_CTRL_LCD1_DMA1		Hw8
+#define	HwDDIC_CTRL_LCD1_DMA0_2		Hw7
+#define	HwDDIC_CTRL_LCD1_DMA0_1		Hw6
+#define	HwDDIC_CTRL_LCD1_DMA0_0		Hw5
+#define	HwDDIC_CTRL_LCD0_DMA2		Hw4
+#define	HwDDIC_CTRL_LCD0_DMA1		Hw3
+#define	HwDDIC_CTRL_LCD0_DMA0_2		Hw2
+#define	HwDDIC_CTRL_LCD0_DMA0_1		Hw1
+#define	HwDDIC_CTRL_LCD0_DMA0_0		Hw0
+
+// DDI CACHE Configuration
+#define	HwDDIC_CFG_CIF_DMA			(25)
+#define	HwDDIC_CFG_VIQE_DMA2_2		(24)
+#define	HwDDIC_CFG_VIQE_DMA2_1		(23)
+#define	HwDDIC_CFG_VIQE_DMA2_0		(22)
+#define	HwDDIC_CFG_VIQE_DMA1_2		(21)
+#define	HwDDIC_CFG_VIQE_DMA1_1		(20)
+#define	HwDDIC_CFG_VIQE_DMA1_0		(19)
+#define	HwDDIC_CFG_VIQE_DMA0_2		(18)
+#define	HwDDIC_CFG_VIQE_DMA0_1		(17)
+#define	HwDDIC_CFG_VIQE_DMA0_0		(16)
+#define	HwDDIC_CFG_MSCL1_DMA2		(15)
+#define	HwDDIC_CFG_MSCL1_DMA1		(14)
+#define	HwDDIC_CFG_MSCL1_DMA0		(13)
+#define	HwDDIC_CFG_MSCL0_DMA2		(12)
+#define	HwDDIC_CFG_MSCL0_DMA1		(11)
+#define	HwDDIC_CFG_MSCL0_DMA0		(10)
+#define	HwDDIC_CFG_LCD1_DMA2		(9)
+#define	HwDDIC_CFG_LCD1_DMA1		(8)
+#define	HwDDIC_CFG_LCD1_DMA0_2		(7)
+#define	HwDDIC_CFG_LCD1_DMA0_1		(6)
+#define	HwDDIC_CFG_LCD1_DMA0_0		(5)
+#define	HwDDIC_CFG_LCD0_DMA2		(4)
+#define	HwDDIC_CFG_LCD0_DMA1		(3)
+#define	HwDDIC_CFG_LCD0_DMA0_2		(2)
+#define	HwDDIC_CFG_LCD0_DMA0_1		(1)
+#define	HwDDIC_CFG_LCD0_DMA0_0		(0)	
+
+#define HwDDIC_CFG_MASK			(0x1F)
+#define	HwDDIC_CFG26(X)			((X)<<16)
+#define	HwDDIC_CFG27(X)			((X)<<24)
+#define	HwDDIC_CFG28(X)			((X))
+#define	HwDDIC_CFG29(X)			((X)<<8)
+#define	HwDDIC_CFG30(X)			((X)<<16)
+#define	HwDDIC_CFG31(X)			((X)<<24)
+
+/*******************************************************************************
+*	 TCC8900_DataSheet_PART 7 VIDEO BUS_V0.00 Dec.11 2008
+********************************************************************************/
+/***********************************************************************
+*   4. VIDEO CODEC Register Define                	(Base Addr = 0x0xF0700000)
+************************************************************************/
+#define HwVIDEOCODEC_BASE           *(volatile unsigned long *)0xF0700000
+
+/***********************************************************************
+*   5. JPEG CODEC Register Define                	(Base Addr = 0x0xF0710000/0xF0720000)
+************************************************************************/
+#define HwJPEGDECODER_BASE          *(volatile unsigned long *)0xF0710000
+#define HwJPEGENCODER_BASE          *(volatile unsigned long *)0xF0720000
+#define HwVIDEOCACHE_BASE           *(volatile unsigned long *)0xF0701000
+
+/*******************************************************************************
+*	 TCC8900_DataSheet_PART 8 GRAPHIC BUS_V0.00 Dec.11 2008
+********************************************************************************/
+/***********************************************************************
+*	 4. Overlay Mixer Register Define	(Base Addr = 0xF0010000)
+************************************************************************/
+#define HwOVERLAYMIXER_BASE         *(volatile unsigned long *)0xF0010000
+
+/*******************************************************************************
+*	 5-1. 2D/3D GPU
+*
+*	 Pixel Processor Register Map Register Define   (Base Addr = 0xF0000000)
+********************************************************************************/
+#define HwPIXELPROCESSOR_BASE       *(volatile unsigned long *)0xF0000000
+
+/*******************************************************************************
+*	 5-2. Geometry Processor Register Map Register Define   (Base Addr = 0xF0000000)
+********************************************************************************/
+#define HwGEOMETRYPROCESSOR_BASE    *(volatile unsigned long *)0xF0002000
+
+/*******************************************************************************
+*	 5-3. MMU Configuration Register Define   (Base Addr = 0xF0003000)
+********************************************************************************/
+#define HwMMUCONFIG_BASE            *(volatile unsigned long *)0xF0003000
+
+/*******************************************************************************
+*	 5-4. GRPBUS Configuration Register Define   (Base Addr = 0xF0004000)
+********************************************************************************/
+#define HwGRPBUS_BASE               *(volatile unsigned long *)0xF0004000
+
+/*******************************************************************************
+*	 5-5. GRPBUS BWRAP Register Define   (Base Addr = 0xF0005000)
+********************************************************************************/
+#define HwGRPBUSBWRAP_BASE          *(volatile unsigned long *)0xF0005000
+
+#endif						
Index: linux-2.6.29/arch/arm/mach-tcc8900/include/mach/TCC89x_Structures.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/include/mach/TCC89x_Structures.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,3275 @@
+/****************************************************************************
+ *   FileName    : TCC89x_Structures.h
+ *   Description : 
+ ****************************************************************************
+*
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+*
+ ****************************************************************************/
+
+
+/************************************************************************
+*	TCC89x Internal Register Definition File
+************************************************************************/
+#ifndef	__TCC89xSTRUCTURES_H__
+#define	__TCC89xSTRUCTURES_H__
+
+
+/*******************************************************************************
+*	 TCC8900_DataSheet_PART 2 SMU & PMU_V0.00 Dec.11 2008
+********************************************************************************/
+/************************************************************************
+*	1. Clock Controller Register Define			(Base Addr = 0xF0400000) // R/W
+************************************************************************/
+//---------------------------------------------------------------------------------------------
+//31  | 30  | 29  | 28  | 27  | 26  | 25  | 24  | 23  | 22  | 21  | 20  | 19  | 18  | 17  | 16 |
+//  												 		|CFGEN|MODE | NCKOE/DPRD           |
+//15  | 14  | 13  | 12  | 11  | 10  |  9  |  8  |  7  |   6 |   5 |   4 |   3 |   2 |   1 |  0 |
+//   NCKOE/DMIN  		|		NCKOE/DMAX      |		  NCKOE/DCDIV   |     |	    CKSEL      |
+//----------------------------------------------------------------------------------------------   
+//CLK_BASE					*(volatile unsigned long *)0xF0400000
+
+typedef struct _CKC{
+	volatile unsigned int	CLK0CTRL;					//   0x00  R/W  0x2FFFF4  CPU & Bus Clock0 Control Register 
+	volatile unsigned int	CLK1CTRL;					//   0x04  R/W  0x2FFFF4  CPU & Bus Clock1 Control Register 
+	volatile unsigned int	CLK2CTRL;					//   0x08  R/W  0x2FFFF4  CPU & Bus Clock2 Control Register 
+	volatile unsigned int	CLK3CTRL;					//   0x0C  R/W  0x2FFFF4  CPU & Bus Clock3 Control Register 
+	volatile unsigned int	CLK4CTRL;					//   0x10  R/W  0x2FFFF4  CPU & Bus Clock4 Control Register 
+	volatile unsigned int	CLK5CTRL;					//   0x14  R/W  0x2FFFF4  CPU & Bus Clock5 Control Register 
+	volatile unsigned int	CLK6CTRL;					//   0x18  R/W  0x2FFFF4  CPU & Bus Clock6 Control Register 
+	volatile unsigned int	CLK7CTRL;					//   0x1C  R/W  0x2FFFF4  CPU & Bus Clock 7Control Register 
+	volatile unsigned int	PLL0CFG;					//   0x20  R/W  0x8010FA03  PLL0 Configuration Register 
+	volatile unsigned int	PLL1CFG;					//   0x24  R/W  0x80009603  PLL1 Configuration Register 
+	volatile unsigned int	PLL2CFG;					//   0x28  R/W  0x80007D03  PLL2 Configuration Register 
+	volatile unsigned int	PLL3CFG;					//   0x2C  R/W  0x80009603  PLL3 Configuration Register 
+	volatile unsigned int	CLKDIVC;					//   0x30  R/W  0x81818181  PLL Divider Configuration Register 
+	volatile unsigned int	CLKDIVC1;					//   0x34  R/W  0x00008181  External Clock Divider Configuration Register 
+	volatile unsigned int	CLKDIVC2;					//-  0x38     Reserved 
+	volatile unsigned int	CLKDIVC3;					//-  0x3C      Reserved 
+	volatile unsigned int	SWRESETPRD;					//   0x40  R/W  0x000000FF  Software Reset Period Register 
+	volatile unsigned int	SWRESET;					//   0x44  R/W  0x00000000  Software Reset Control Register 
+	volatile unsigned int	NOTDEFINE0[14];			//-  0x48-0x7C      Reserved 
+	volatile unsigned int	PCLK_TCX;					//   0x80  R/W  0x00014000  Timer Counter 0 Oscillator-Clock Control Register   
+	volatile unsigned int	PCLK_TCT;					//   0x84  R/W  0x00014000  Timer Counter 0 Clock Control Register   
+	volatile unsigned int	PCLK_TCZ;					//   0x88  R/W  0x00014000  Timer Counter 1 Clock Control Register   
+	volatile unsigned int	PCLK_LCD0;					//   0x8C  R/W  0x00014000  LCD0 Clock Control Register 
+	volatile unsigned int	PCLK_LCD1;					//   0x90  R/W  0x00014000  LCD1 Clock Control Register 
+	volatile unsigned int	PCLK_LCDSI;				//   0x94  R/W  0x00014000  LCDSI Clock Control Register 
+	volatile unsigned int	PCLK_CIFMC;				//   0x98  R/W  0x00014000  Control Register for CIF Internal Clock
+	volatile unsigned int	PCLK_CIFSC;				//   0x9C  R/W  0x00014000  Control Register for CIF Scaler Clock
+	volatile unsigned int	PCLK_OUT0;					//   0xA0  R/W  0x00014000  Control Register for External Clock Output 0
+	volatile unsigned int	PCLK_OUT1;					//   0xA4  R/W  0x00014000  Control Register for External Clock Output 1 
+	volatile unsigned int	PCLK_HDMI;					//   0xA8  R/W  0x00014000  Control Register for HDMI PHY Input Clock 
+	volatile unsigned int	PCLK_USB11H;				//   0xAC  R/W  0x00014000  Control Register for USB 1.1 Host 
+	volatile unsigned int	PCLK_SDMMC0;				//   0xB0  R/W  0x00014000  Control Register for SD/MMC Channel 0
+	volatile unsigned int	PCLK_MSTICK;				//   0xB4  R/W  0x00014000  Memory Stick Clock Control Register 
+	volatile unsigned int	PCLK_I2C;					//   0xB8  R/W  0x00014000  I2C Clock Control Register 
+	volatile unsigned int	PCLK_UART0;				//   0xBC  R/W  0x00014000  UART0 Clock Control Register 
+	volatile unsigned int	PCLK_UART1;				//   0xC0  R/W  0x00014000  UART1 Clock Control Register 
+	volatile unsigned int	PCLK_UART2;				//   0xC4  R/W  0x00014000  UART2 Clock Control Register 
+	volatile unsigned int	PCLK_UART3;				//   0xC8  R/W  0x00014000  UART3 Clock Control Register 
+	volatile unsigned int	PCLK_UART4;				//   0xCC  R/W  0x00014000  UART4 Clock Control Register 
+	volatile unsigned int	PCLK_UART5;				//   0xD0  R/W  0x00014000  UART5 Clock Control Register 
+	volatile unsigned int	PCLK_GPSB0;				//   0xD4  R/W  0x00014000  Control Register for GPSB Channel 0
+	volatile unsigned int	PCLK_GPSB1;				//   0xD8  R/W  0x00014000  Control Register for GPSB Channel 1
+	volatile unsigned int	PCLK_GPSB2;				//   0xDC  R/W  0x00014000  Control Register for GPSB Channel 2
+	volatile unsigned int	PCLK_GPSB3;				//   0xE0  R/W  0x00014000  Control Register for GPSB Channel 3
+	volatile unsigned int   PCLK_GPSB4; 				//	0x0E4 R/W  0x14000000  Control Register for GPSB Channel 4
+	volatile unsigned int	PCLK_GPSB5;				//   0xE8  R/W  0x00014000  Control Register for GPSB Channel 5 
+	volatile unsigned int	PCLK_ADC;					//   0xEC  R/W  0x00014000  Control Register for ADC (Touch Screen)
+	volatile unsigned int	PCLK_SPDIF;				//   0xF0  R/W  0x00140000  Control Register for SPDIF 
+	volatile unsigned int	PCLK_EHI0;					//   0xF4  R/W  0x00140000  Control Register for EHI Channel 0
+	volatile unsigned int   PCLK_EHI1;					//	0x0F8 R/W  0x14000000 Control Register for EHI Channel 1 
+	volatile unsigned int	PCLK_AUD;					//   0xFC  R/W  0x00014000  Control Register for Audio DMA
+	volatile unsigned int	PCLK_CAN ;					//   0x100  R/W  0x00014000  Control Register for CAN 
+	volatile unsigned int	NOTDEFINE1;				//   0x104  R/W  0x00140000  Reserved 
+	volatile unsigned int	PCLK_SDMMC1;				//   0x108  R/W  0x00014000  Control Register for SD/MMC Channel 1
+	volatile unsigned int	NOTDEFINE2;				//   0x10C  R/W  0x00014000  Reserved 
+	volatile unsigned int	PCLK_DAI ;					//   0x110  R/W  0x00014000  Control Register for DAI (DAI Only) 
+}CKC, *PCKC;
+
+/************************************************************************
+*	2. Vectored Priority Interrupt Controller Register Map(Base Addr = 0xF0401000)
+************************************************************************/
+//#define	HwPIC_BASE					*(volatile unsigned long *)0xF0401000
+typedef struct _PIC{
+	volatile unsigned int	IEN0;					//     0x000  R/W  0x00000000  Interrupt Enable0 Register 
+	volatile unsigned int	IEN1;					//     0x004  R/W  0x00000000  Interrupt Enable1 Register 
+	volatile unsigned int	CLR0;					//     0x008  R/W  0x00000000  Interrupt Clear0 Register 
+	volatile unsigned int	CLR1;					//     0x00C  R/W  0x00000000  Interrupt Clear1 Register 
+	volatile unsigned int	STS0;					//     0x010  R  Unknown  Interrupt Status0 Register 
+	volatile unsigned int	STS1;					//     0x014  R  Unknown  Interrupt Status1 Register 
+	volatile unsigned int	SEL0;					//     0x018  R/W  0x00000000  IRQ or FIR Selection0 Register 
+	volatile unsigned int	SEL1;					//     0x01C  R/W  0x00000000  IRQ or FIR Selection1 Register 
+	volatile unsigned int	SRC0;					//     0x020  R  Unknown  Source Interrupt Status0 Register 
+	volatile unsigned int	SRC1;					//     0x024  R  Unknown  Source Interrupt Status1 Register 
+	volatile unsigned int	MSTS0;					//     0x028  R  0x00000000  Masked Status0 Register 
+	volatile unsigned int	MSTS1;					//     0x02C  R  0x00000000  Masked Status1 Register 
+	volatile unsigned int	TIG0;					//     0x030  R/W  0x00000000  Test Interrupt Generation0 Register 
+	volatile unsigned int	TIG1;					//     0x034  R/W  0x00000000  Test Interrupt Generation1 Register 
+	volatile unsigned int	POL0;					//     0x038  R/W  0x00000000  Interrupt Polarity0 Register 
+	volatile unsigned int	POL1;					//     0x03C  R/W  0x00000000  Interrupt Polarity1 Register 
+	volatile unsigned int	IRQ0;					//     0x040  R  0x00000000  IRQ Raw Status0 Register 
+	volatile unsigned int	IRQ1;					//     0x044  R  0x00000000  IRQ Raw Status1 Register 
+	volatile unsigned int	FIQ0;					//     0x048  R  Unknown  FIQ Status0 Register 
+	volatile unsigned int	FIQ1;					//     0x04C  R  Unknown  FIQ Status1 Register 
+	volatile unsigned int	MIRQ0;					//     0x050  R  0x00000000  Masked IRQ Status0 Register 
+	volatile unsigned int	MIRQ1;					//     0x054  R  0x00000000  Masked IRQ Status1 Register 
+	volatile unsigned int	MFIQ0;					//     0x058  R  0x00000000  Masked FIQ Status0 Register 
+	volatile unsigned int	MFIQ1;					//     0x05C  R  0x00000000  Masked FIQ Status1 Register 
+	volatile unsigned int	MODE0;					//     0x060  R/W  0x00000000  Trigger Mode0 Register ? Level or Edge 
+	volatile unsigned int	MODE1;					//     0x064  R/W  0x00000000  Trigger Mode1 Register ? Level or Edge 
+	volatile unsigned int	SYNC0;					//     0x068  R/W  0xFFFFFFFF  Synchronization Enable0 Register 
+	volatile unsigned int	SYNC1;					//     0x06C  R/W  0xFFFFFFFF  Synchronization Enable1 Register 
+	volatile unsigned int	WKEN0;					//     0x070  R/W  0x00000000  Wakeup Event Enable0 Register 
+	volatile unsigned int	WKEN1;					//     0x074  R/W  0x00000000  Wakeup Event Enable1 Register 
+	volatile unsigned int	MODEA0;					//     0x078  R/W  0x00000000  Both Edge or Single Edge0 Register 
+	volatile unsigned int	MODEA1;					//     0x07C  R/W  0x00000000  Both Edge or Single Edge1 Register 
+	volatile unsigned int	NOTDEFINE0[32];		//-  0x80-0xFC      Reserved 
+	volatile unsigned int	INTMSK0;				//     0x100  R/W  0xFFFFFFFF  Interrupt Output Masking0 Register 
+	volatile unsigned int	INTMSK1;				//     0x104  R/W  0xFFFFFFFF  Interrupt Output Masking1 Register 
+	volatile unsigned int	ALLMSK;					//     0x108  R/W  0x00000003  All Mask Register 
+}PIC, *PPIC;
+
+//#define	HwVIC_BASE					*(volatile unsigned long *)0xF0401200
+typedef struct _VIC{
+	volatile unsigned int	VAIRQ;					//       0x200  R  0x800000XX  IRQ Vector Register 
+	volatile unsigned int	VAFIQ;					//       0x204  R  0x800000XX  FIQ Vector Register 
+	volatile unsigned int	VNIRQ;					//       0x208  R  0x800000XX  IRQ Vector Number Register 
+	volatile unsigned int	VNFIQ;					//       0x20C  R  0x800000XX  FIQ Vector Number Register 
+	volatile unsigned int	VCTRL;					//       0x210  R/W  0x00000000  Vector Control Register 
+	volatile unsigned int	NOTDEFINE0[3];			//  		0x214-0x218-0x21c      Reserved 
+	volatile unsigned int	PRIO0;					//       0x220  R/W  0x03020100  Priorities for Interrupt 0 ~ 3 
+	volatile unsigned int	PRIO1;					//       0x224  R/W  0x07060504  Priorities for Interrupt 4 ~ 7 
+	volatile unsigned int	PRIO2;					//       0x228  R/W  0x0B0A0908  Priorities for Interrupt 8 ~ 11 
+	volatile unsigned int	PRIO3;					//       0x22C  R/W  0x0F0E0D0C  Priorities for Interrupt 12 ~ 15 
+	volatile unsigned int	PRIO4;					//       0x230  R/W  0x13121110  Priorities for Interrupt 16 ~ 19 
+	volatile unsigned int	PRIO5;					//       0x234  R/W  0x17161514  Priorities for Interrupt 20 ~ 23 
+	volatile unsigned int	PRIO6;					//       0x238  R/W  0x1B1A1918  Priorities for Interrupt 24 ~ 27 
+	volatile unsigned int	PRIO7;					//       0x23C  R/W  0x1F1E1D1C  Priorities for Interrupt 28 ~ 31 
+	volatile unsigned int	PRIO8;					//       0x220  R/W  0x23222120  Priorities for Interrupt 32 ~ 35 
+	volatile unsigned int	PRIO9;					//       0x224  R/W  0x27262524  Priorities for Interrupt 36 ~ 39 
+	volatile unsigned int	PRIO10;					//       0x228  R/W  0x2B2A2928  Priorities for Interrupt 40 ~ 43 
+	volatile unsigned int	PRIO11;					//       0x22C  R/W  0x2F2E2D2C  Priorities for Interrupt 44 ~ 47 
+	volatile unsigned int	PRIO12;					//       0x230  R/W  0x33323130  Priorities for Interrupt 48 ~ 51 
+	volatile unsigned int	PRIO13;					//       0x234  R/W  0x37363534  Priorities for Interrupt 52 ~ 55 
+	volatile unsigned int	PRIO14;					//       0x238  R/W  0x3B3A3938  Priorities for Interrupt 56 ~ 59 
+	volatile unsigned int	PRIO15;					//       0x23C  R/W  0x3F3E3D3C  Priorities for Interrupt 60 ~ 63 
+
+}VIC, *PVIC;
+
+/***********************************************************************
+*	3. Timer/Counter Register Map (Base Address = 0xF0403000) 
+************************************************************************/
+//#define	HwTMR_BASE					*(volatile unsigned long *)0xF0403000	// Timer/Counter Base Register
+typedef struct _TIMER{
+	volatile unsigned int	TCFG0;					//         0x00  R/W  0x00  Timer/Counter 0 Configuration Register 
+	volatile unsigned int	TCNT0;					//         0x04  R/W  0x0000  Timer/Counter 0 Counter Register 
+	volatile unsigned int	TREF0;					//         0x08  R/W  0xFFFF  Timer/Counter 0 Reference Register 
+	volatile unsigned int	TMREF0;					//         0x0C  R/W  0x0000  Timer/Counter 0 Middle Reference Register 
+	volatile unsigned int	TCFG1;					//         0x10  R/W  0x00  Timer/Counter 1 Configuration Register 
+	volatile unsigned int	TCNT1;					//         0x14  R/W  0x0000  Timer/Counter 1 Counter Register 
+	volatile unsigned int	TREF1;					//         0x18  R/W  0xFFFF  Timer/Counter 1 Reference Register 
+	volatile unsigned int	TMREF1;					//         0x1C  R/W  0x0000  Timer/Counter 1 Middle Reference Register 
+	volatile unsigned int	TCFG2;					//         0x20  R/W  0x00  Timer/Counter 2 Configuration Register 
+	volatile unsigned int	TCNT2;					//         0x24  R/W  0x0000  Timer/Counter 2 Counter Register 
+	volatile unsigned int	TREF2;					//         0x28  R/W  0xFFFF  Timer/Counter 2 Reference Register 
+	volatile unsigned int	TMREF2;					//         0x2C  R/W  0x0000  Timer/Counter 2 Middle Reference Register 
+	volatile unsigned int	TCFG3;					//         0x30  R/W  0x00  Timer/Counter 3 Configuration Register 
+	volatile unsigned int	TCNT3;					//         0x34  R/W  0x0000  Timer/Counter 3 Counter Register 
+	volatile unsigned int	TREF3;					//         0x38  R/W  0xFFFF  Timer/Counter 3 Reference Register 
+	volatile unsigned int	TMREF3;					//         0x3C  R/W  0x0000  Timer/Counter 3 Middle Reference Register 
+	volatile unsigned int	TCFG4;					//         0x40  R/W  0x00  Timer/Counter 4 Configuration Register 
+	volatile unsigned int	TCNT4;					//         0x44  R/W  0x00000  Timer/Counter 4 Counter Register 
+	volatile unsigned int	TREF4;					//         0x48  R/W  0xFFFFF  Timer/Counter 4 Reference Register 
+	volatile unsigned int   NOTDEFINE0;
+	volatile unsigned int	TCFG5;					//         0x50  R/W  0x00  Timer/Counter 5 Configuration Register 
+	volatile unsigned int	TCNT5;					//         0x54  R/W  0x00000  Timer/Counter 5 Counter Register 
+	volatile unsigned int	TREF5;					//         0x58  R/W  0xFFFFF  Timer/Counter 5 Reference Register 
+	volatile unsigned int   NOTDEFINE1;
+	volatile unsigned int	TIREQ;					//         0x60  R/W  0x0000  Timer/Counter n Interrupt Request Register 
+	volatile unsigned int   NOTDEFINE2[3];
+	volatile unsigned int	TWDCFG;					//         0x70  R/W  0x0000  Reserved 
+	volatile unsigned int	TWDCLR;					//         0x74  W  -  Reserved 
+	volatile unsigned int   NOTDEFINE3[2];
+	volatile unsigned int	TC32EN;					//         0x80  R/W  0x00007FFF  32-bit Counter Enable / Pre-scale Value 
+	volatile unsigned int	TC32LDV;				//         0x84  R/W  0x00000000  32-bit Counter Load Value 
+	volatile unsigned int	TC32CMP0;				//         0x88  R/W  0x00000000  32-bit Counter Match Value 0 
+	volatile unsigned int	TC32CMP1;				//         0x8C  R/W  0x00000000  32-bit Counter Match Value 1 
+	volatile unsigned int	TC32PCNT;				//         0x90  R/W  -  32-bit Counter Current Value (pre-scale counter) 
+	volatile unsigned int	TC32MCNT;				//         0x94  R/W  -  32-bit Counter Current Value (main counter) 
+	volatile unsigned int	TC32IRQ;				//         0x98  R/W  0x0000----  32-bit Counter Interrupt Control 
+
+}TIMER, *PTIMER;
+
+typedef struct _TIMERN{
+	volatile unsigned int	TCFG;					// 0x000   R/W	Timer/Counter Configuration Register 
+	volatile unsigned int	TCNT;					// 0x004   R/W  Timer/Counter Counter Register 
+	volatile unsigned int	TREF;					// 0x008   R/W  Timer/Counter Reference Register 
+	volatile unsigned int	TMREF;					// 0x00C   R/W  Timer/Counter Middle Reference Register 
+} TIMERN, *PTIMERN;
+
+/***********************************************************************
+*	4. PMU(POWER MANAGEMENT UNIT) Register Map (Base Address = 0xF0404000) 
+************************************************************************/
+//#define	HwCONTROL  				*(volatile unsigned long *)0xF0404000 	//R/W   PMU Control Register 
+typedef struct _PMU{
+	volatile unsigned int	CONTROL;				// 	0x00 R/W   PMU Control Register 
+	volatile unsigned int	WKUPEN ;				//	0x04  R/W    Wakeup Enable Configuration Register 
+	volatile unsigned int	WKUPPOL ;				//	0x08 R/W   Wakeup Polarity Configuration Register 
+	volatile unsigned int	WATCHDOG;				//  0x0C  R/W    Watchdog Control Register 
+	volatile unsigned int	CONFIG0 ;				//	0x10 R/W   Boot Configuration Register 
+	volatile unsigned int	USERSTS ;				//	0x14 R/W   Status Register 
+	volatile unsigned int	PWROFF  ;				//	0x18  R/W    Power-Off Control Register 
+} PMU, *PPMU;
+
+
+
+/*******************************************************************************
+*	5. SMUI2C Controller Register Define   (Base Addr = 0xF0405000)
+********************************************************************************/
+//#define HwSMU_I2CMASTER0_BASE     *(volatile unsigned long*)0xF0405000
+//#define HwSMU_I2CMASTER1_BASE     *(volatile unsigned long*)0xF0405040
+//#define HwSMU_I2CICLK_BASE     	*(volatile unsigned long*)0xF0405080	//I2C_SCL divider Regist
+typedef struct _SMUI2CMASTER{
+    volatile unsigned int  PRES;                // 0x00 R/W 0xFFFF Clock Prescale register
+    volatile unsigned int  CTRL;                // 0x04 R/W 0x0000 Control Register
+    volatile unsigned int  TXR;                 // 0x08 W 0x0000 Transmit Register
+    volatile unsigned int  CMD;                 // 0x0C W 0x0000 Command Register
+    volatile unsigned int  RXR;                 // 0x10 R 0x0000 Receive Register
+    volatile unsigned int  SR;                  // 0x14 R 0x0000 Status register
+    volatile unsigned int  TIME;                // 0x18 R/W 0x0000 Timing Control Register    
+} SMUI2CMASTER, *PSMUI2CMASTER;
+
+typedef struct _SMUI2CICLK{
+    volatile unsigned int  ICLK;                // 0x00 R/W 0xFFFF Clock Prescale register
+} SMUI2CICLK, *PSMUI2CICLK;
+
+/*******************************************************************************
+*	 TCC8900_DataSheet_PART 3 GPIO_V0.00 Dec.11 2008
+********************************************************************************/
+/************************************************************************
+*	1. GPIO Register Map (Base Address = 0xF0102000) 
+************************************************************************/
+/*
+#define	HwGPIO_BASE  			*(volatile unsigned long *)0xF0102000  	// 
+#define	HwGPIOA_BASE  			*(volatile unsigned long *)0xF0102000  	// 
+#define	HwGPIOB_BASE  			*(volatile unsigned long *)0xF0102040  	// 
+#define	HwGPIOC_BASE  			*(volatile unsigned long *)0xF0102080  	// 
+#define	HwGPIOD_BASE  			*(volatile unsigned long *)0xF01020C0  	// 
+#define	HwGPIOE_BASE  			*(volatile unsigned long *)0xF0102100  	// 
+#define	HwGPIOF_BASE  			*(volatile unsigned long *)0xF0102140  	// 
+#define	HwEINTSEL_BASE  		*(volatile unsigned long *)0xF0102180  	// 
+*/
+typedef struct _GPIO{
+	volatile unsigned int	GPADAT;					//   0x000  R/W  0x00000000  GPA Data Register 
+	volatile unsigned int	GPAEN;					//   0x004  R/W  0x00000000  GPA Output Enable Register 
+	volatile unsigned int	GPASET;					//   0x008  W  -  OR function on GPA Output Data 
+	volatile unsigned int	GPACLR;					//   0x00C  W  -  BIC function on GPA Output Data 
+	volatile unsigned int	GPAXOR;					//   0x010  W  -  XOR function on GPA Output Data 
+	volatile unsigned int	GPACD0;					//   0x014  W  0x55555555  Driver strength Control 0 on GPA Output Data 
+	volatile unsigned int	GPACD1;					//   0x018  W  0x00000000  Driver strength Control 1 on GPA Output Data 
+	volatile unsigned int	GPAPD0;					//   0x01C  W  0x55555555  Pull-Up/Down function on GPA Output Data 
+	volatile unsigned int	GPAPD1;					//   0x020  W  0x00000000  Pull-Up/Down function on GPA Output Data 
+	volatile unsigned int	GPAFN0;					//   0x024  W  0x00000000  Port Configuration on GPA Output Data 
+	volatile unsigned int	GPAFN1;					//   0x028  W  0x00000000  Port Configuration on GPA Output Data 
+	volatile unsigned int	GPAFN2;					//   0x02C  W  0x00000000  Port Configuration on GPA Output Data 
+	volatile unsigned int	GPAFN3;					//   0x030  W  0x00000000  Port Configuration on GPA Output Data 
+	volatile unsigned int	NOTDEFINE0[3];			//	 0x034-0x03C     Reserved 
+	volatile unsigned int	GPBDAT;					//   0x040  R/W  0x00000000  GPB Data Register 
+	volatile unsigned int	GPBEN;					//   0x044  R/W  0x00000000  GPB Output Enable Register 
+	volatile unsigned int	GPBSET;					//   0x048  W  -  OR function on GPB Output Data 
+	volatile unsigned int	GPBCLR;					//   0x04C  W  -  BIC function on GPB Output Data 
+	volatile unsigned int	GPBXOR;					//   0x050  W  -  XOR function on GPB Output Data 
+	volatile unsigned int	GPBCD0;					//   0x054  W  0x55555555  Driver strength Control 0 on GPB Output Data 
+	volatile unsigned int	GPBCD1;					//   0x058  W  0x00000000  Driver strength Control 1 on GPB Output Data 
+	volatile unsigned int	GPBPD0;					//   0x05C  W  0x55555555  Pull-Up/Down function on GPB Output Data 
+	volatile unsigned int	GPBPD1;					//   0x060  W  0x00000000  Pull-Up/Down function on GPB Output Data 
+	volatile unsigned int	GPBFN0;					//   0x064  W  0x00000000  Port Configuration on GPB Output Data 
+	volatile unsigned int	GPBFN1;					//   0x068  W  0x00000000  Port Configuration on GPB Output Data 
+	volatile unsigned int	GPBFN2;					//   0x06C  W  0x00000000  Port Configuration on GPB Output Data 
+	volatile unsigned int	GPBFN3;					//   0x070  W  0x00000000  Port Configuration on GPB Output Data 
+	volatile unsigned int	NOTDEFINE1[3];			// 	 0x074-0x07C     Reserved 
+	volatile unsigned int	GPCDAT;					//   0x080  R/W  0x00000000  GPC Data Register 
+	volatile unsigned int	GPCEN;					//   0x084  R/W  0x00000000  GPC Output Enable Register 
+	volatile unsigned int	GPCSET;					//   0x088  W  -  OR function on GPC Output Data 
+	volatile unsigned int	GPCCLR;					//   0x08C  W  -  BIC function on GPC Output Data 
+	volatile unsigned int	GPCXOR;					//   0x090  W  -  XOR function on GPC Output Data 
+	volatile unsigned int	GPCCD0;					//   0x094  W  0x55555555  Driver strength Control 0 on GPC Output Data 
+	volatile unsigned int	GPCCD1;					//   0x098  W  0x00000000  Driver strength Control 1 on GPC Output Data 
+	volatile unsigned int	GPCPD0;					//   0x09C  W  0x55555555  Pull-Up/Down function on GPC Output Data 
+	volatile unsigned int	GPCPD1;					//   0x0A0  W  0x00000000  Pull-Up/Down function on GPC Output Data 
+	volatile unsigned int	GPCFN0;					//   0x0A4  W  0x00000000  Port Configuration on GPC Output Data 
+	volatile unsigned int	GPCFN1;					//   0x0A8  W  0x00000000  Port Configuration on GPC Output Data 
+	volatile unsigned int	GPCFN2;					//   0x0AC  W  0x00000000  Port Configuration on GPC Output Data 
+	volatile unsigned int	GPCFN3;					//   0x0B0  W  0x00000000  Port Configuration on GPC Output Data 
+	volatile unsigned int	NOTDEFINE2[3];			// 	 0x0B4-0x0BC Reserved 
+	volatile unsigned int	GPDDAT;					//   0x0C0  R/W  0x00000000  GPD Data Register 
+	volatile unsigned int	GPDEN;					//   0x0C4  R/W  0x00000000  GPD Output Enable Register 
+	volatile unsigned int	GPDSET;					//   0x0C8  W  -  OR function on GPD Output Data 
+	volatile unsigned int	GPDCLR;					//   0x0CC  W  -  BIC function on GPD Output Data 
+	volatile unsigned int	GPDXOR;					//   0x0D0  W  -  XOR function on GPD Output Data 
+	volatile unsigned int	GPDCD0;					//   0x0D4  W  0x55555555  Driver strength Control 0 on GPD Output Data 
+	volatile unsigned int	GPDCD1;					//   0x0D8  W  0x00000000  Driver strength Control 1 on GPD Output Data 
+	volatile unsigned int	GPDPD0;					//   0x0DC  W  0x55555555  Pull-Up/Down function on GPD Output Data 
+	volatile unsigned int	GPDPD1;					//   0x0E0  W  0x00000000  Pull-Up/Down function on GPD Output Data 
+	volatile unsigned int	GPDFN0;					//   0x0E4  W  0x00000000  Port Configuration on GPD Output Data 
+	volatile unsigned int	GPDFN1;					//   0x0E8  W  0x00000000  Port Configuration on GPD Output Data 
+	volatile unsigned int	GPDFN2;					//   0x0EC  W  0x00000000  Port Configuration on GPD Output Data 
+	volatile unsigned int	GPDFN3;					//   0x0F0  W  0x00000000  Port Configuration on GPD Output Data 
+	volatile unsigned int	NOTDEFINE3[3];			// 	 0x0F4-0x0FC     Reserved 
+	volatile unsigned int	GPEDAT;					//   0x100  R/W  0x00000000  GPE Data Register 
+	volatile unsigned int	GPEEN;					//   0x104  R/W  0x00000000  GPE Output Enable Register 
+	volatile unsigned int	GPESET;					//   0x108  W  -  OR function on GPE Output Data 
+	volatile unsigned int	GPECLR;					//   0x10C  W  -  BIC function on GPE Output Data 
+	volatile unsigned int	GPEXOR;					//   0x110  W  -  XOR function on GPE Output Data 
+	volatile unsigned int	GPECD0;					//   0x114  W  0x55555555  Driver strength Control 0 on GPE Output Data 
+	volatile unsigned int	GPECD1;					//   0x118  W  0x00000000  Driver strength Control 1 on GPE Output Data 
+	volatile unsigned int	GPEPD0;					//   0x11C  W  0x55555555  Pull-Up/Down function on GPE Output Data 
+	volatile unsigned int	GPEPD1;					//   0x120  W  0x00000000  Pull-Up/Down function on GPE Output Data 
+	volatile unsigned int	GPEFN0;					//   0x124  W  0x00000000  Port Configuration on GPE Output Data 
+	volatile unsigned int	GPEFN1;					//   0x128  W  0x00000000  Port Configuration on GPE Output Data 
+	volatile unsigned int	GPEFN2;					//   0x12C  W  0x00000000  Port Configuration on GPE Output Data 
+	volatile unsigned int	GPEFN3;					//   0x130  W  0x00000000  Port Configuration on GPE Output Data 
+	volatile unsigned int	NOTDEFINE4[3];			// 	 0x134-0x13C     Reserved 
+	volatile unsigned int	GPFDAT;					//   0x140  R/W  0x00000000  GPF Data Register 
+	volatile unsigned int	GPFEN;					//   0x144  R/W  0x00000000  GPF Output Enable Register 
+	volatile unsigned int	GPFSET;					//   0x148  W  -  OR function on GPF Output Data 
+	volatile unsigned int	GPFCLR;					//   0x14C  W  -  BIC function on GPF Output Data 
+	volatile unsigned int	GPFXOR;					//   0x150  W  -  XOR function on GPF Output Data 
+	volatile unsigned int	GPFCD0;					//   0x154  W  0x55555555  Driver strength Control 0 on GPF Output Data 
+	volatile unsigned int	GPFCD1;					//   0x158  W  0x00000000  Driver strength Control 1 on GPF Output Data 
+	volatile unsigned int	GPFPD0;					//   0x15C  W  0x55555555  Pull-Up/Down function on GPF Output Data 
+	volatile unsigned int	GPFPD1;					//   0x160  W  0x00000000  Pull-Up/Down function on GPF Output Data 
+	volatile unsigned int	GPFFN0;					//   0x164  W  0x00000000  Port Configuration on GPF Output Data 
+	volatile unsigned int	GPFFN1;					//   0x168  W  0x00000000  Port Configuration on GP Output Data 
+	volatile unsigned int	GPFFN2;					//   0x16C  W  0x00000000  Port Configuration on GPF Output Data 
+	volatile unsigned int	GPFFN3;					//   0x170  W  0x00000000  Port Configuration on GPF Output Data 
+	volatile unsigned int	NOTDEFINE5[4];			// 	 0x174-0x17C     Reserved 
+	volatile unsigned int	EINTSEL0;				//   0x184  R/W  0x00000000  External Interrupt Select Register 01
+	volatile unsigned int	EINTSEL1;				//   0x188  R/W  0x00000000  External Interrupt Select Register 1 
+	volatile unsigned int	EINTSEL2;				//   0x18C  R/W  0x00000000  External Interrupt Select Register 2 
+	volatile unsigned int	MON;					//   0x190  R/W  0x00000000  System Monitor Enable Register   
+	volatile unsigned int	ECID0;					//   0x194  R/W  0x00000000  CID output Register 
+	volatile unsigned int	ECID1;					//   0x198  R  -  CID serial input Register 
+	volatile unsigned int	ECID2;					//   0x19C  R  -  CID parallel input 0 Register 
+	volatile unsigned int	ECID3;					//   0x1A0  R  -  CID parallel input 1 Register     
+}GPIO, *PGPIO;
+
+typedef struct _GPION{
+	volatile unsigned int	GPDAT;					// 0x000  R/W	GPA Data Register 
+	volatile unsigned int	GPEN;					// 0x004  R/W	GPA Output Enable Register 
+	volatile unsigned int	GPSET;					// 0x008  W  	OR function on GPA Output Data 
+	volatile unsigned int	GPCLR;					// 0x00C  W  	BIC function on GPA Output Data 
+	volatile unsigned int	GPXOR;					// 0x010  W  	XOR function on GPA Output Data 
+	volatile unsigned int	GPCD0;					// 0x014  W  	Driver strength Control 0 on GPA Output Data 
+	volatile unsigned int	GPCD1;					// 0x018  W  	Driver strength Control 1 on GPA Output Data 
+	volatile unsigned int	GPPD0;					// 0x01C  W  	Pull-Up/Down function on GPA Output Data 
+	volatile unsigned int	GPPD1;					// 0x020  W  	Pull-Up/Down function on GPA Output Data 
+	volatile unsigned int	GPFN0;					// 0x024  W  	Port Configuration on GPA Output Data 
+	volatile unsigned int	GPFN1;					// 0x028  W  	Port Configuration on GPA Output Data 
+	volatile unsigned int	GPFN2;					// 0x02C  W  	Port Configuration on GPA Output Data 
+	volatile unsigned int	GPFN3;					// 0x030  W  	Port Configuration on GPA Output Data 
+} GPION, *PGPION;
+
+/*******************************************************************************
+*	 TCC8900_DataSheet_PART 4 CORE & MEMORY BUS_V0.00 Dec.11 2008
+********************************************************************************/
+/************************************************************************
+*	3. DRAM CONTROLLER Register Map (Base Address = 0xF0301000) 
+************************************************************************/
+/*
+#define	HwDRAM_BASE  			*(volatile unsigned long *)0xF0301000  	//
+#define	HwDRAMM0_BASE  		*(volatile unsigned long *)0xF0301000  	//
+#define	HwDRAMM1_BASE  		*(volatile unsigned long *)0xF0302000  	//
+#define	HwDRAMMISC_BASE  		*(volatile unsigned long *)0xF0303000  	//
+#define	HwDRAMPHY_BASE  		*(volatile unsigned long *)0xF0304000  	//
+#define	HwDRAMMEMBUS_BASE  	*(volatile unsigned long *)0xF0305004  	//
+*/
+typedef struct _DRAM{
+	volatile unsigned int	STAT;					//  0x000 RO  -  Status Register 
+	volatile unsigned int	CMD;					//  0x004 WO  -  Command Register 
+	volatile unsigned int	DCMD;					//   0x008  WO  -  Direct COmmnad Register 
+	volatile unsigned int	CFG;					//  0x00C R/W 0x00010020 Configuration Register 
+	volatile unsigned int	REF;					//   0x010  R/W  0x00000A60  Refresh Period Register 
+	volatile unsigned int	CAS;					//  0x014 R/W 0x00000006 CAS Latency Register 
+	volatile unsigned int	DQSS;					//  0x018 R/W 0x00000001 t_dqss Register 
+	volatile unsigned int	MRD;					//  0x01C R/W 0x00000002 t_mrd Register 
+	volatile unsigned int	RAS;					//  0x020 R/W 0x00000007 t_ras Register 
+	volatile unsigned int	RC;						//  0x024 R/W 0x0000000B t_rc Register 
+	volatile unsigned int	RCD;					//  0x028 R/W 0x0000001D t_rcd Register 
+	volatile unsigned int	RFC;					//  0x02C R/W 0x000000212 t_rfc Register 
+	volatile unsigned int	RP;						//  0x030 R/W 0x0000001D t_rp Register 
+	volatile unsigned int	RRD;					//  0x034 R/W 0x00000002 t_rrd Register 
+	volatile unsigned int	WR;						//  0x038 R/W 0x00000003 t_wr Register 
+	volatile unsigned int	WTR;					//  0x03C R/W 0x00000002 t_wtr Register 
+	volatile unsigned int	XP;						//  0x040 R/W 0x00000001 t_xp Register 
+	volatile unsigned int	XSR;					//  0x044 R/W 0x0000000A t_xsr Register 
+	volatile unsigned int	ESR;					//  0x048 R/W 0x00000014 t_esr Register 
+	volatile unsigned int	CFG2;					//  0x04C R/W  -  Memory_cfg2 Register 
+	volatile unsigned int	CFG3;					//  0x050 R/W 0x00000007 Memory_cfg3 Register 
+	volatile unsigned int	NOTDEFINE0[43];		//	 - 0x054- 0x0FC   Reserved 
+	volatile unsigned int	ID0;					//  0x100 R/W 0x00000000 AXI ID0 configuration Register 
+	volatile unsigned int	ID1;					//  0x104 R/W 0x00000000 AXI ID1 configuration Register 
+	volatile unsigned int	ID2;					//  0x108 R/W 0x00000000 AXI ID2 configuration Register 
+	volatile unsigned int	ID3;					//  0x10C R/W 0x00000000 AXI ID3 configuration Register 
+	volatile unsigned int	ID4;					//  0x110 R/W 0x00000000 AXI ID4 configuration Register 
+	volatile unsigned int	ID5;					//  0x114 R/W 0x00000000 AXI ID5 configuration Register 
+	volatile unsigned int	ID6;					//  0x118 R/W 0x00000000 AXI ID6 configuration Register 
+	volatile unsigned int	ID7;					//  0x11C R/W 0x00000000 AXI ID7 configuration Register 
+	volatile unsigned int	ID8;					//  0x120 R/W 0x00000000 AXI ID8 configuration Register 
+	volatile unsigned int	ID9;					//  0x124 R/W 0x00000000 AXI ID9 configuration Register 
+	volatile unsigned int	ID10;					//   0x128  R/W  0x00000000  AXI ID10 configuration Register 
+	volatile unsigned int	ID11;					//   0x12C  R/W  0x00000000  AXI ID11 configuration Register 
+	volatile unsigned int	ID12;					//   0x130  R/W  0x00000000  AXI ID12 configuration Register 
+	volatile unsigned int	ID13;					//   0x134  R/W  0x00000000  AXI ID13 configuration Register 
+	volatile unsigned int	ID14;					//   0x138  R/W  0x00000000  AXI ID14 configuration Register 
+	volatile unsigned int	ID15;					//   0x13C  R/W  0x00000000  AXI ID15 configuration Register 
+	volatile unsigned int	NOTDEFINE1[48];			//	 - 0x140- 0x1FC   Reserved 
+	volatile unsigned int	CH0;					//  0x200 R/W 0x0000FF00 CHIP ID0 configuration Register 
+	volatile unsigned int	CH1;					//  0x204 R/W 0x0000FF00 CHIP ID1 configuration Register 
+	volatile unsigned int	CH2;					//  0x208 R/W 0x0000FF00 CHIP ID2 configuration Register 
+	volatile unsigned int	CH3;					//  0x20C R/W 0x0000FF00 CHIP ID3 configuration Register 
+}DRAM, *PDRAM;
+
+typedef struct _DRAMMX{
+	volatile unsigned int	M0STAT;					//  0x000 RO  -  Status Register 
+	volatile unsigned int	M0CMD;					//  0x004 WO  -  Command Register 
+	volatile unsigned int	M0DCMD;					//   0x008  WO  -  Direct COmmnad Register 
+	volatile unsigned int	M0CFG;					//  0x00C R/W 0x00010020 Configuration Register 
+	volatile unsigned int	M0REF;					//   0x010  R/W  0x00000A60  Refresh Period Register 
+	volatile unsigned int	M0CAS;					//  0x014 R/W 0x00000006 CAS Latency Register 
+	volatile unsigned int	M0DQSS;					//  0x018 R/W 0x00000001 t_dqss Register 
+	volatile unsigned int	M0MRD;					//  0x01C R/W 0x00000002 t_mrd Register 
+	volatile unsigned int	M0RAS;					//  0x020 R/W 0x00000007 t_ras Register 
+	volatile unsigned int	M0RC;						//  0x024 R/W 0x0000000B t_rc Register 
+	volatile unsigned int	M0RCD;					//  0x028 R/W 0x0000001D t_rcd Register 
+	volatile unsigned int	M0RFC;					//  0x02C R/W 0x000000212 t_rfc Register 
+	volatile unsigned int	M0RP;						//  0x030 R/W 0x0000001D t_rp Register 
+	volatile unsigned int	M0RRD;					//  0x034 R/W 0x00000002 t_rrd Register 
+	volatile unsigned int	M0WR;						//  0x038 R/W 0x00000003 t_wr Register 
+	volatile unsigned int	M0WTR;					//  0x03C R/W 0x00000002 t_wtr Register 
+	volatile unsigned int	M0XP;						//  0x040 R/W 0x00000001 t_xp Register 
+	volatile unsigned int	M0XSR;					//  0x044 R/W 0x0000000A t_xsr Register 
+	volatile unsigned int	M0ESR;					//  0x048 R/W 0x00000014 t_esr Register 
+	volatile unsigned int	M0CFG2;					//  0x04C R/W  -  Memory_cfg2 Register 
+	volatile unsigned int	M0CFG3;					//  0x050 R/W 0x00000007 Memory_cfg3 Register 
+	volatile unsigned int	NOTDEFINE0[43];		//	 - 0x054- 0x0FC   Reserved 
+	volatile unsigned int	M0ID0;					//  0x100 R/W 0x00000000 AXI ID0 configuration Register 
+	volatile unsigned int	M0ID1;					//  0x104 R/W 0x00000000 AXI ID1 configuration Register 
+	volatile unsigned int	M0ID2;					//  0x108 R/W 0x00000000 AXI ID2 configuration Register 
+	volatile unsigned int	M0ID3;					//  0x10C R/W 0x00000000 AXI ID3 configuration Register 
+	volatile unsigned int	M0ID4;					//  0x110 R/W 0x00000000 AXI ID4 configuration Register 
+	volatile unsigned int	M0ID5;					//  0x114 R/W 0x00000000 AXI ID5 configuration Register 
+	volatile unsigned int	M0ID6;					//  0x118 R/W 0x00000000 AXI ID6 configuration Register 
+	volatile unsigned int	M0ID7;					//  0x11C R/W 0x00000000 AXI ID7 configuration Register 
+	volatile unsigned int	M0ID8;					//  0x120 R/W 0x00000000 AXI ID8 configuration Register 
+	volatile unsigned int	M0ID9;					//  0x124 R/W 0x00000000 AXI ID9 configuration Register 
+	volatile unsigned int	M0ID10;					//   0x128  R/W  0x00000000  AXI ID10 configuration Register 
+	volatile unsigned int	M0ID11;					//   0x12C  R/W  0x00000000  AXI ID11 configuration Register 
+	volatile unsigned int	M0ID12;					//   0x130  R/W  0x00000000  AXI ID12 configuration Register 
+	volatile unsigned int	M0ID13;					//   0x134  R/W  0x00000000  AXI ID13 configuration Register 
+	volatile unsigned int	M0ID14;					//   0x138  R/W  0x00000000  AXI ID14 configuration Register 
+	volatile unsigned int	M0ID15;					//   0x13C  R/W  0x00000000  AXI ID15 configuration Register 
+	volatile unsigned int	NOTDEFINE1[48];			//	 - 0x140- 0x1FC   Reserved 
+	volatile unsigned int	M0CH0;					//  0x200 R/W 0x0000FF00 CHIP ID0 configuration Register 
+	volatile unsigned int	M0CH1;					//  0x204 R/W 0x0000FF00 CHIP ID1 configuration Register 
+	volatile unsigned int	M0CH2;					//  0x208 R/W 0x0000FF00 CHIP ID2 configuration Register 
+	volatile unsigned int	M0CH3;					//  0x20C R/W 0x0000FF00 CHIP ID3 configuration Register 
+	volatile unsigned int	NOTDEFINE2[892];		//	 - 0x1210- 0x1FFC   Reserved 
+	//0xF0302000
+	volatile unsigned int	M1STAT;					//  0x000 RO  -  Status Register 
+	volatile unsigned int	M1CMD;					//  0x004 WO  -  Command Register 
+	volatile unsigned int	M1DCMD;					//   0x008  WO  -  Direct COmmnad Register 
+	volatile unsigned int	M1CFG;					//  0x00C R/W 0x00010020 Configuration Register 
+	volatile unsigned int	M1REF;					//   0x010  R/W  0x00000A60  Refresh Period Register 
+	volatile unsigned int	M1CAS;					//  0x014 R/W 0x00000006 CAS Latency Register 
+	volatile unsigned int	M1DQSS;					//  0x018 R/W 0x00000001 t_dqss Register 
+	volatile unsigned int	M1MRD;					//  0x01C R/W 0x00000002 t_mrd Register 
+	volatile unsigned int	M1RAS;					//  0x020 R/W 0x00000007 t_ras Register 
+	volatile unsigned int	M1RC;						//  0x024 R/W 0x0000000B t_rc Register 
+	volatile unsigned int	M1RCD;					//  0x028 R/W 0x0000001D t_rcd Register 
+	volatile unsigned int	M1RFC;					//  0x02C R/W 0x000000212 t_rfc Register 
+	volatile unsigned int	M1RP;						//  0x030 R/W 0x0000001D t_rp Register 
+	volatile unsigned int	M1RRD;					//  0x034 R/W 0x00000002 t_rrd Register 
+	volatile unsigned int	M1WR;						//  0x038 R/W 0x00000003 t_wr Register 
+	volatile unsigned int	M1WTR;					//  0x03C R/W 0x00000002 t_wtr Register 
+	volatile unsigned int	M1XP;						//  0x040 R/W 0x00000001 t_xp Register 
+	volatile unsigned int	M1XSR;					//  0x044 R/W 0x0000000A t_xsr Register 
+	volatile unsigned int	M1ESR;					//  0x048 R/W 0x00000014 t_esr Register 
+	volatile unsigned int	M1CFG2;					//  0x04C R/W  -  Memory_cfg2 Register 
+	volatile unsigned int	M1CFG3;					//  0x050 R/W 0x00000007 Memory_cfg3 Register 
+	volatile unsigned int	NOTDEFINE3[43];		//	 - 0x054- 0x0FC   Reserved 
+	volatile unsigned int	M1ID0;					//  0x100 R/W 0x00000000 AXI ID0 configuration Register 
+	volatile unsigned int	M1ID1;					//  0x104 R/W 0x00000000 AXI ID1 configuration Register 
+	volatile unsigned int	M1ID2;					//  0x108 R/W 0x00000000 AXI ID2 configuration Register 
+	volatile unsigned int	M1ID3;					//  0x10C R/W 0x00000000 AXI ID3 configuration Register 
+	volatile unsigned int	M1ID4;					//  0x110 R/W 0x00000000 AXI ID4 configuration Register 
+	volatile unsigned int	M1ID5;					//  0x114 R/W 0x00000000 AXI ID5 configuration Register 
+	volatile unsigned int	M1ID6;					//  0x118 R/W 0x00000000 AXI ID6 configuration Register 
+	volatile unsigned int	M1ID7;					//  0x11C R/W 0x00000000 AXI ID7 configuration Register 
+	volatile unsigned int	M1ID8;					//  0x120 R/W 0x00000000 AXI ID8 configuration Register 
+	volatile unsigned int	M1ID9;					//  0x124 R/W 0x00000000 AXI ID9 configuration Register 
+	volatile unsigned int	M1ID10;					//   0x128  R/W  0x00000000  AXI ID10 configuration Register 
+	volatile unsigned int	M1ID11;					//   0x12C  R/W  0x00000000  AXI ID11 configuration Register 
+	volatile unsigned int	M1ID12;					//   0x130  R/W  0x00000000  AXI ID12 configuration Register 
+	volatile unsigned int	M1ID13;					//   0x134  R/W  0x00000000  AXI ID13 configuration Register 
+	volatile unsigned int	M1ID14;					//   0x138  R/W  0x00000000  AXI ID14 configuration Register 
+	volatile unsigned int	M1ID15;					//   0x13C  R/W  0x00000000  AXI ID15 configuration Register 
+	volatile unsigned int	NOTDEFINE4[48];			//	 - 0x140- 0x1FC   Reserved 
+	volatile unsigned int	M1CH0;					//  0x200 R/W 0x0000FF00 CHIP ID0 configuration Register 
+	volatile unsigned int	M1CH1;					//  0x204 R/W 0x0000FF00 CHIP ID1 configuration Register 
+	volatile unsigned int	M1CH2;					//  0x208 R/W 0x0000FF00 CHIP ID2 configuration Register 
+	volatile unsigned int	M1CH3;					//  0x20C R/W 0x0000FF00 CHIP ID3 configuration Register 
+}DRAMMX, *PDRAMMX;
+
+typedef struct _DRAMPHY{
+	volatile unsigned int	REG0; 	//  0x400  R/W  0x00000000  PHY Mode Control Register 
+	volatile unsigned int	REG1; 	// 0x404 R/ RW 0x00000018  DLL Control & Status Register 
+	volatile unsigned int	REG2; 	// 0x408 R/W 0x00000000 DLL Phase Detector configuration Register 
+	volatile unsigned int	REG3; 	//  0x40C  R/W  0x00000000  Gate Control Register 
+	volatile unsigned int	REG4; 	// 0x410  R/W  0x00000000  Read Data Slice 0 Control Register 
+	volatile unsigned int	REG5; 	//  0x414  R/W  0x00000000  Read Data Slice 1 Control Register 
+	volatile unsigned int	REG6; 	//  0x418  RO  0x00000000  Read Data Slice 2 Control Register 
+	volatile unsigned int	REG7; 	//  0x41C  R/W  0x00000000  Read Data Slice 3 Control Register 
+	volatile unsigned int	REG8; 	//  0x420  R/W  0x00000000  CLK Delay Register 
+	volatile unsigned int	REG9; 	//  0x424  R/W  0x00000000  DLL Force Lock Value Register 
+	volatile unsigned int	REG10; 	// 0x428 R/W 0x00000000 ZQ Calibration Control Register 
+	volatile unsigned int	REG11; 	//  0x42C  RO  0x00000000  ZQ Calibration Status Register 
+	volatile unsigned int	REG12; 	// 0x430 R/W 0x00000000 Read Delay Register 
+}DRAMPHY, *PDRAMPHY;
+
+typedef struct _DRAMMISC{
+	volatile unsigned int	M0CFG0; 		//0x00 R/W 0x80400000 SDR/DDR SDRAM Controller Configuration Register 0 
+	volatile unsigned int	M0CFG1; 		//0x04 R/RW 0x00000018 SDR/DDR SDRAM Controller Configuration Register 1 
+	volatile unsigned int	NOTDEFINE0[2];	//	 0x08-0x0C   Reserved 
+	volatile unsigned int	M1CFG0; 		//0x10 R/W 0x80000000 DDR2 SDRAM Controller Configuration Register 0 
+	volatile unsigned int	M1CFG1; 		//0x14 R/W 0x00000000 DDR2 SDRAM Controller Configuration Register 1 
+	volatile unsigned int	NOTDEFINE1[2];	//	- 0x18- 0x1C   Reserved 
+	volatile unsigned int	COMMON; 		//0x20 R/W 0x00010103  Common Control Register 
+	volatile unsigned int	PHYCTRL; 		//0x24  R/W  0x00000000  SDRAM PHY Control Register 
+	volatile unsigned int	PHYTSTS; 		//0x28  RO  0x00000000  SDRAM PHY Status Register 
+	volatile unsigned int	IOCFG;  		//0x2C  R/W  0x00000000  SDRAM IO Control Register 
+}DRAMMISC, *PDRAMMISC;
+
+typedef struct _DRAMMEMBUS{
+	volatile unsigned int	CKDOWN;				//0x04 RW 0x00000000 Clock Enable control over memory bus com-ponents
+}DRAMMEMBUS, *PDRAMMEMBUS;
+
+/************************************************************************
+*	4-1. MISC CORE BUS CONFIGURATION REGISTERS				(Base Addr = 0xF0101000)
+************************************************************************/
+//#define	HwCORECFG_BASE				*(volatile unsigned long *)0xF0101000	************************************************************************/
+typedef struct _MISCCOREBUS{
+	volatile unsigned int	CORECFG;				//R/W  0x90000000 Core Bus Configuration Register 
+}MISCCOREBUS, *PMISCCOREBUS;
+
+/************************************************************************
+*	4-2. Virtual MMU Table  Register Define	(Base Addr = 0xF7000000)
+************************************************************************/
+//#define	HwVMT_BASE				*(volatile unsigned long *)0x20000000	// VMT Base Regiseter
+//#define	HwREGION_BASE			*(volatile unsigned long *)0xF7000000	// R/W, Configuration Register for Region 0
+
+typedef struct _VMTREGION{
+	volatile unsigned int	REGION0;				// 0x00 R/W - Configuration Register for Region 0 
+	volatile unsigned int	REGION1;				// 0x04 R/W - Configuration Register for Region 1 
+	volatile unsigned int	REGION2;				// 0x08 R/W - Configuration Register for Region 2 
+	volatile unsigned int	REGION3;				// 0x0C R/W - Configuration Register for Region 3 
+	volatile unsigned int	REGION4;				// 0x10 R/W - Configuration Register for Region 4 
+	volatile unsigned int	REGION5;				// 0x14 R/W - Configuration Register for Region 5 
+	volatile unsigned int	REGION6;				// 0x18 R/W - Configuration Register for Region 6 
+	volatile unsigned int	REGION7;				// 0x1C R/W - Configuration Register for Region 7 
+}VMTREGION, *PVMTREGION;
+
+
+/*******************************************************************************
+*	 TCC8900_DataSheet_PART 5 IO BUS_V0.00 Dec.11 2008
+********************************************************************************/
+/*******************************************************************************
+*	 4. Memory Stick Host Controller Register Define   (Base Addr = 0xF0590000)
+********************************************************************************/
+//#define HwSMSHC_BASE                            *(volatile unsigned long*)0xF0590000
+//#define HwSMSHCPORTCFG_BASE                     *(volatile unsigned long*)0xF05F1000
+typedef struct _SMSHC{
+	volatile unsigned int	MS_CONTROL_PROGRAMCOUNTREG;         //  0x00    // R/W 0x0070_1000
+	volatile unsigned int	MS_SYSTEMREG;                       //  0x04    // R/W 0x0800_XXXX
+	volatile unsigned int	MS_FLAGREG;                         //  0x08    // R 0x4000_XXXX
+	volatile unsigned int	MS_MEMORY_CONTROLREG;               //  0x0C    // R/W 0x0001_7000
+	volatile unsigned int	MS_GENERALREG01;                    //  0x10    // R/W 0x8000_9000
+	volatile unsigned int	MS_GENERALREG23;                    //  0x14    // R/W 0xA000_B000
+	volatile unsigned int	MS_GENERALREG45;                    //  0x18    // R/W 0xC000_D000
+	volatile unsigned int	MS_TIMERREG;                        //  0x1C    // R 0xE000XXXX
+	volatile unsigned int	MS_INSTRUCTIONREG;                  //  0x20    // R/W 0xXXXX_XXXX
+	volatile unsigned int	MS_GENERALDATAFIFO;                 //  0x24    // R/W 0x0000_0000
+	volatile unsigned int	MS_PAGEBUFFER;                      //  0x28    // R/W 0xXXXX_XXXX
+	volatile unsigned int	MS_VERSIONREG;                      //  0x2C    // R 0xXXXX_XXXX
+	volatile unsigned int	MS_MSHC_COMMANDREG;                 //  0x30    // R/W 0x0000_XXXX
+	volatile unsigned int	MS_MSHC_DATAREG;                    //  0x34    // R/W 0x0000_0000
+	volatile unsigned int	MS_MSHC_STATUSREG;                  //  0x38    // R 0x1000_XXXX
+	volatile unsigned int	MS_MSHC_SYSTEMREG;                  //  0x3C    // R/W 0x20A5_XXXX
+	volatile unsigned int	MS_MSHC_USERCUSTOMREG;              //  0x40    // R 0x0220_XXXX
+	volatile unsigned int	MS_MSHC_FIFOCTRLREG;                //  0x44    // R/W 0x0001_XXXX
+	volatile unsigned int	NOTDEFINE0;                         //
+	volatile unsigned int	MS_MSHC_DMACTRLREG;                 //  0x4C    // R/W 0x0000_XXXX
+}SMSHC, *PSMSHC;
+
+typedef struct _SMSHCPORTCFG{
+    volatile unsigned int	MS_PORTCFG;                         //   0xF05F1000    // R/W 0x00000000
+    volatile unsigned int	MS_PORTDLY;                         //   0xF05F1004    // R/W 0x00000000
+}SMSHCPORTCFG, *PSMSHCPORTCFG;
+
+/*******************************************************************************
+*	 5. SD/SDIO/MMC/CE-ATA Host Controller Register Define   (Base Addr = 0xF0590000)
+********************************************************************************/
+/*
+#define HwSDCORE0SLOT0_BASE                     *(volatile unsigned long*)0xF05A0000 // Core 0 Slot 0
+#define HwSDCORE0SLOT1_BASE                     *(volatile unsigned long*)0xF05A0100 // Core 0 Slot 1
+#define HwSDCORE1SLOT2_BASE                     *(volatile unsigned long*)0xF05A0200 // Core 1 Slot 2
+#define HwSDCORE1SLOT3_BASE                     *(volatile unsigned long*)0xF05A0300 // Core 1 Slot 3
+#define HwSDCHCTRL_BASE                         *(volatile unsigned long*)0xF05A0800 // Channel Control Register
+*/
+typedef struct _SDHOST{
+	volatile unsigned short 	SDMA;                       // 0x000 R/W 0x0000 SDMA System Address
+	volatile unsigned short     NOTDEFINE0;                 // 0x002
+	volatile unsigned short 	BSIZE;                      // 0x004 R/W 0x0000 Block Size
+	volatile unsigned short 	BCNT;                       // 0x006 R/W 0x0000 Block Count
+	volatile unsigned short 	ARG;                        // 0x008 R/W 0x0000 Argument
+	volatile unsigned short     NOTDEFINE1;                 // 0x00A
+	volatile unsigned short 	TMODE;                      // 0x00C R/W 0x0000 Transfer Mode
+	volatile unsigned short 	CMD;                        // 0x00E R/W 0x0000 Command
+	volatile unsigned short 	RESP0;                      // 0x010 R 0x0000 Response0
+	volatile unsigned short 	RESP1;                      // 0x012 R 0x0000 Response1
+	volatile unsigned short 	RESP2;                      // 0x014 R 0x0000 Response2
+	volatile unsigned short 	RESP3;                      // 0x016 R 0x0000 Response3
+	volatile unsigned short 	RESP4;                      // 0x018 R 0x0000 Response4
+	volatile unsigned short 	RESP5;                      // 0x01A R 0x0000 Response5
+	volatile unsigned short 	RESP6;                      // 0x01C R 0x0000 Response6
+	volatile unsigned short 	RESP7;                      // 0x01E R 0x0000 Response7
+	volatile unsigned short 	DATAL;                      // 0x020 R/W - Buffer Data Port(Low)
+	volatile unsigned short 	DATAH;                      // 0x022 R/W - Buffer Data Port(High)
+	volatile unsigned short 	STATEL;                     // 0x024 R 0x0000 Present State(Low)
+	volatile unsigned short 	STATEH;                     // 0x026 R 0x0000 Present State(High)
+	volatile unsigned short 	CONTL;                      // 0x028 R/W 0x0000 Power Control / Host Control
+	volatile unsigned short 	CONTH;                      // 0x02A R/W 0x0000 Wakeup Control / Block Gap Control
+	volatile unsigned short 	CLK;                        // 0x02C R/W 0x0000 Clock Control
+	volatile unsigned short 	TIME;                       // 0x02E R/W 0x0000 Software Reset / Timeout Control
+	volatile unsigned short 	STSL;                       // 0x030 R 0x0000 Normal Interrupt Status(Low)
+	volatile unsigned short 	STSH;                       // 0x032 R 0x0000 Normal Interrupt Status(High)
+	volatile unsigned short 	STSENL;                     // 0x034 R/W 0x0000 Normal Interrupt Status Enable(Low)
+	volatile unsigned short 	STSENH;                     // 0x036 R/W 0x0000 Normal Interrupt Status Enable(High)
+	volatile unsigned short 	INTENL;                     // 0x038 R/W 0x0000 Normal Interrupt Signal Enable(Low)
+	volatile unsigned short 	INTENH;                     // 0x03A R/W 0x0000 Normal Interrupt Signal Enable(High)
+	volatile unsigned short 	CMD12ERR;                   // 0x03C R 0x0000 Auto CMD12 Error Status
+	volatile unsigned short     NOTDEFINE2;                 // 0x03E
+	volatile unsigned short 	CAPL;                       // 0x040 R 0x30B0 Capabilities(Low)
+	volatile unsigned short 	CAPH;                       // 0x042 R 0x69EF Capabilities(High)
+	volatile unsigned short     NOTDEFINE3[2];              // 0x044, 0x046
+	volatile unsigned short 	CURL;                       // 0x048 R 0x0001 Maximum Current Capabilities(Low)
+	volatile unsigned short 	CURH;                       // 0x04A R 0x0000 Maximum Current Capabilities(High)
+	volatile unsigned short     NOTDEFINE4[2];              // 0x04C, 0x04E
+	volatile unsigned short 	FORCEL;                     // 0x050 W 0x0000 Force event for AutoCmd12 Error
+	volatile unsigned short 	FORCEH;                     // 0x052 W 0x0000 Force event for Error Interrupt Status
+	volatile unsigned short 	AUDIO_DMAERR;               // 0x054 R/W 0x0000 AUDIO DMA Error Status
+	volatile unsigned short     NOTDEFINE5;                 // 0x056
+	volatile unsigned short 	ADDR0;                      // 0x058 R/W 0x0000 AUDIO DMA Address[15:0]
+	volatile unsigned short 	ADDR1;                      // 0x05A R/W 0x0000 AUDIO DMA Address[31:16]
+	volatile unsigned short 	ADDR2;                      // 0x05C R/W 0x0000 AUDIO DMA Address[47:32]
+	volatile unsigned short 	ADDR3;                      // 0x05E R/W 0x0000 AUDIO DMA Address[63:48]
+	volatile unsigned short     NOTDEFINE6[78];             // 0x060~0x0FA
+	volatile unsigned short 	SLOT;                       // 0x0FC R 0x0000 Slot Interrupt Status
+	volatile unsigned short 	VERSION;                    // 0x0FE R 0x0002 Host Controller Version    
+}SDHOST, *PSDHOST;
+
+typedef struct _SDCHCTRL{
+	volatile unsigned int	SDPORTCTRL;                          //  0x00 R/W 0x0000 SD/MMC port control register
+	volatile unsigned int	SDPORTDLY0;                          //  0x04 R/W 0x0000 SD/MMC output delay control register
+	volatile unsigned int	SDPORTDLY1;                          //  0x08 R/W 0x0000 SD/MMC output delay control register
+	volatile unsigned int	SDPORTDLY2;                          //  0x0C R/W 0x0000 SD/MMC output delay control register
+	volatile unsigned int	SDPORTDLY3;                          //  0x10 R/W 0x0000 SD/MMC output delay control register    
+}SDCHCTRL, *PSDCHCTRL;
+
+
+/*******************************************************************************
+*	 6. NAND Flash Controller(NFC) Register Define   (Base Addr = 0xF05B0000)
+********************************************************************************/
+//#define HwNFC_BASE                              *(volatile unsigned long*)0xF05B0000
+
+typedef struct _NFC{
+	volatile unsigned int	NFC_CMD;				// 0x000  W  	NAND Flash Command Register
+	volatile unsigned int	NFC_LADDR;				// 0x004  W  	NAND Flash Linear Address Register
+	volatile unsigned int	NFC_BADDR;				// 0x008  W  	NAND Flash Block Address Register
+	volatile unsigned int	NFC_SADDR;				// 0x00C  W  	NAND Flash Signal Address Register
+	volatile unsigned int	NFC_WDATA;				// 0x01x  R/W	NAND Flash Word Data Register
+	volatile unsigned int	NOTDEFINE0[3];				// 0x01x  R/W	NAND Flash Word Data Register
+	volatile unsigned int	NFC_LDATA;			// 0x02x/3x R/W	NAND Flash Linear Data Register
+	volatile unsigned int	NOTDEFINE1[7];				// 0x01x  R/W	NAND Flash Word Data Register
+	volatile unsigned int	NFC_SDATA;				// 0x040  R/W	NAND Flash Single Data Register
+	volatile unsigned int	NOTDEFINE2[3];			// 0x044     	Not Used
+	volatile unsigned int	NFC_CTRL;				// 0x050  R/W	NAND Flash Control Register
+	volatile unsigned int	NFC_PSTART; 			// 0x054  W  	NAND Flash Program Start Register
+	volatile unsigned int	NFC_RSTART; 			// 0x058  W  	NAND Flash Read Start Register
+	volatile unsigned int	NFC_DSIZE;				// 0x05C  R/W	NAND Flash Data Size Register
+	volatile unsigned int	NFC_IREQ;				// 0x060  R/W	NAND Flash Interrupt Request Register
+	volatile unsigned int	NFC_RST;				// 0x064  W  	NAND Flash Controller Reset Register
+	volatile unsigned int	NFC_CTRL1;				// 0x068  R/W	NAND Flash Control Register 1
+	volatile unsigned int	NOTDEFINE3;				// 0x06C     	Not Used
+	volatile unsigned int	NFC_MDATA[4];			// 0x07x  R/W	NAND Flash Multiple Data Register	
+}NFC, *PNFC;
+
+/*******************************************************************************
+*	 7. Static Memory Controller(SMC) Register Define   (Base Addr = 0xF05F0000)
+********************************************************************************/
+//#define HwSMC_BASE                            *(volatile unsigned long*)0xF05F0000
+typedef struct _SMC{
+	volatile unsigned int	STATUS;                        //  0x00 R/W Unknown Status Register
+	volatile unsigned int   NOTDEFINE0[7];
+	volatile unsigned int	CSNCFG0;                       //  0x20 R 0x4b40_3183 External Chip Select0 Config Register
+	volatile unsigned int	CSNCFG1;                       //  0x24 R/W 0x4b40_1104 External Chip Select1 Config Register
+	volatile unsigned int	CSNCFG2;                       //  0x28 W 0x4b40_4082 External Chip Select2 Config Register
+	volatile unsigned int	CSNCFG3;                       //  0x2C R/W 0x4b40_20C5 External Chip Select3 Config. Register
+	volatile unsigned int	CSNOFFSET;                     //  0x30 R/W 0x0 Wapping Address Mode OFFSET Register
+	volatile unsigned int	INDIRADDR;                     //  0x34 R/W 0x0 Indirect Address    
+}SMC, *PSMC;
+
+/*******************************************************************************
+*	 8. External Device Interface (EDI) Register Define   (Base Addr = 0xF05F6000)
+********************************************************************************/
+//#define HwEDI_BASE                            *(volatile unsigned long*)0xF05F6000
+
+typedef struct _EDI{
+	volatile unsigned int	EDI_CTRL;                       //  0x00 R/W 0x00000000 EDI Control Register.
+	volatile unsigned int	EDI_CSNCFG0;                    //  0x04 R/W 0x00543210 EDI CSN Configuration Register 0.
+	volatile unsigned int	EDI_CSNCFG1;                    //  0x08 R/W 0x00BA9876 EDI CSN Configuration Register 1.
+	volatile unsigned int	NOTDEFINE0[2];                  //  Reserved 0x0C R/W - -
+	volatile unsigned int	EDI_RDYCFG;                     //  0x14 R/W 0x76543210 EDI Ready Configuration Register
+	volatile unsigned int	NOTDEFINE1[2];                  //  Reserved 0x18 R/W 0x00000000 EDI Time-Out Configuration Register 0
+	volatile unsigned int	EDI_REQOFF;                     //  0x20 R/W 0x00000000 EDI Request OFF Flag register    
+}EDI, *PEDI;
+
+/*******************************************************************************
+*	 9. IDE Controller Register Define   (Base Addr = 0xF0520000)
+********************************************************************************/
+//#define HwIDE_BASE                            *(volatile unsigned long*)0xF05F6000
+
+typedef struct _IDE{
+	volatile unsigned int	CS00;                           //  0x00 R/W - PIO CS0n Access Register
+	volatile unsigned int	CS01;                           //  0x04
+	volatile unsigned int	CS02;                           //  0x08
+	volatile unsigned int	CS03;                           //  0x0C
+	volatile unsigned int	CS04;                           //  0x10
+	volatile unsigned int	CS05;                           //  0x14
+	volatile unsigned int	CS06;                           //  0x18
+	volatile unsigned int	CS07;                           //  0x1C
+	volatile unsigned int	CS10;                           //  0x20 R/W - PIO CS1n Access Register
+	volatile unsigned int	CS11;                           //  0x24
+	volatile unsigned int	CS12;                           //  0x28
+	volatile unsigned int	CS13;                           //  0x2C
+	volatile unsigned int	CS14;                           //  0x30
+	volatile unsigned int	CS15;                           //  0x34
+	volatile unsigned int	CS16;                           //  0x38
+	volatile unsigned int	CS17;                           //  0x3C
+	volatile unsigned int	PIOCTRL;                        //  0x40 R/W 0x00600000 PIO Mode Control Register
+	volatile unsigned int	UDMACTRL;                       //  0x44 R/W 0x00000000 UDMA Mode Control Register
+	volatile unsigned int	IDMACTRL;                       //  0x48 R/W 0x00000000 IDMA Control Register
+	volatile unsigned int	IDMASA;                         //  0x4C R/W 0x00000000 IDMA Source Address Register
+	volatile unsigned int	IDMASP;                         //  0x50 R/W 0x00000000 IDMA Source Parameter Register
+	volatile unsigned int	IDMACSA;                        //  0x54 R 0x00000000 IDMA Current Source Address Register
+	volatile unsigned int	IDMADA;                         //  0x58 R/W 0x00000000 IDMA Destination Address Register
+	volatile unsigned int	IDMADP;                         //  0x5C R/W 0x00000000 IDMA Destination Parameter Register
+	volatile unsigned int	IDMACDA;                        //  0x60 R 0x00000000 IDMA Current Destination Address Register
+	volatile unsigned int	IDEINT;                         //  0x64 R/W 0x0000_0000 IDE Interrupt Register
+	volatile unsigned int	UDMATCNT;                       //  0x68 R/W 0x00FF_FFFF UDMA Transfer Counter Register
+	volatile unsigned int	UDMAIN;                         //  0x6C R - UDMA-IN Access Register
+	volatile unsigned int	UDMAOUT;                        //  0x70 W - UDMA-OUT Access register
+	volatile unsigned int	UDMACRC;                        //  0x74 R 0x0000_4ABA UDMA CRC Register
+	volatile unsigned int	UDMACTCNT;                      //  0x78 R 0x00FF_FFFF UDMA Current Transfer Counter Register    
+}IDE, *PIDE;
+
+
+/*******************************************************************************
+*	 10. SATA Interface Register Define   (Base Addr = 0xF0560000)
+********************************************************************************/
+//#define HwSATA_BASE                             *(volatile unsigned long*)0xF0560000
+
+typedef struct _SATA{
+	volatile unsigned int	CDR0;                           //  0x00 16 RO/WO - Data register in PIO mode Dependencies: Read-only for PIO read/receive operation, write-only for PIO write/transmit operation
+	volatile unsigned int	CDR1;                           //  0x04 8/8/8 RO/WO/WO 0xFF/0x00/0x00 Error register Feature Register(currnet value) Feature Expanded Register(previouis value)
+	volatile unsigned int	CDR2;                           //  0x08 8/8 R/W 0xFF Sector count register (current value) Sector count expanded register (previous value)
+	volatile unsigned int	CDR3;                           //  0x0C 8/8 R/W 0xFF Sector number register (current value) Sector number expanded register (previous value)
+	volatile unsigned int	CDR4;                           //  0x10 8/8 R/W 0xFF Cylinder low register (current value) Cylinder low expanded register (previous value)
+	volatile unsigned int	CDR5;                           //  0x14 8/8 R/W 0xFF Cylinder high register (current value) Cylinder high expanded register (previous value)
+	volatile unsigned int	CDR6;                           //  0x18 8 R/W 0xEF Device/ Head register 
+	volatile unsigned int	CDR7;                           //  0x1C 8/8 RO/WO 0x7F/0x00 Status register Dependencies: Value is 0x7F on power-up, then 0x80 when device presence is detected via PHY READY condition. Command register 
+	volatile unsigned int	CLR0;                           //  0x20 8/8 RO/WO 0x7F/0x00 Alternative status register Dependencies: Value is 0x7F on power-up, then 0x80 when device presence is detected via PHY READY condition. Device control register
+	volatile unsigned int	SCR0;                           //  0x24 32 RO 0x0 SStatus Register
+	volatile unsigned int	SCR1;                           //  0x28 32 R/W 0x0 SError Register
+	volatile unsigned int	SCR2;                           //  0x2C 32 R/W 0x0 SControl Register
+	volatile unsigned int	SCR3;                           //  0x30 32 R/W 0x0 SActive Register
+	volatile unsigned int	SCR4;                           //  0x34 32 R/W 0x0 Snotification Register
+	volatile unsigned int	SCR5;                           //  0x38
+	volatile unsigned int	SCR6;                           //  0x3C
+	volatile unsigned int	SCR7;                           //  0x40
+	volatile unsigned int	SCR8;                           //  0x44
+	volatile unsigned int	SCR9;                           //  0x48
+	volatile unsigned int	SCR10;                          //  0x4C
+	volatile unsigned int	SCR11;                          //  0x50
+	volatile unsigned int	SCR12;                          //  0x54
+	volatile unsigned int	SCR13;                          //  0x58
+	volatile unsigned int	SCR14;                          //  0x5C
+	volatile unsigned int	SCR15;                          //  0x60  See description 0x0 Reserved for SATA Dependencies: Reads to these locations return zeros; writes have no effect
+	volatile unsigned int	FPTAGR;                         //  0x64 32 RO 0x0 First Party DMA tag Register
+	volatile unsigned int	FPBOR;                          //  0x68 32 RO 0x0 First Party DMA buffer offset Register
+	volatile unsigned int	FPTCR;                          //  0x6C 32 RO 0x0 First Party DMA transfer count Register
+	volatile unsigned int	DMACR;                          //  0x70 32 R/W 0x0 DMA Control Register
+	volatile unsigned int	DBTSR;                          //  0x74 32 R/W 0x0014 _0010 DMA Burst Transaction Size register
+	volatile unsigned int	INTPR;                          //  0x78 32 R/W 0x0 Interrupt Pending Register
+	volatile unsigned int	INTMR;                          //  0x7C 32 RO 0x0 Interrupt Mask Register
+	volatile unsigned int	ERRMR;                          //  0x80 32 RO 0x0 Error Mask Register
+	volatile unsigned int	LLCR;                           //  0x84 32 R/W 0x0000 _0007 Link Layer Control Register    
+	volatile unsigned int	NOTDEFINE0[222]; 				//0x88 ~ 0x3FC
+	volatile unsigned int	DMADR[256];                     //  0x400-0x7FC FIFO Location in DMA mode
+}SATA, *PSATA;
+
+
+/*******************************************************************************
+*	 11-1. Audio DMA Controller Register Define   (Base Addr = 0xF0533000)
+********************************************************************************/
+//#define HwADMA_BASE                         *(volatile unsigned long*)0xF0533000
+
+typedef struct _ADMA{
+	volatile unsigned int	RxDaDar;                           //  0x00 R/W 0x00000000 DAI Rx (Right) Data Destination Address
+	volatile unsigned int	RxDaParam;                         //  0x04 R/W 0x00000000 DAI Rx Parameters
+	volatile unsigned int	RxDaTCnt;                          //  0x08 R/W 0x00000000 DAI Rx Transmission Counter Register
+	volatile unsigned int	RxDaCdar;                          //  0x0C R 0x00000000 DAI Rx (Right) Data Current Destination Address
+	volatile unsigned int	RxCdDar;                           //  0x10 R/W 0x00000000 CDIF(SPDIF) Rx (Right) Data Destination Address
+	volatile unsigned int	RxCdParam;                         //  0x14 R/W 0x00000000 CDIF(SPDIF) Rx Parameters
+	volatile unsigned int	RxCdTCnt;                          //  0x18 R/W 0x00000000 CDIF(SPDIF) Rx Transmission Counter Register
+	volatile unsigned int	RxCdCdar;                          //  0x1C R 0x00000000 CDIF(SPDIF) Rx (Right) Data Current Destination Address
+	volatile unsigned int   NOTDEFINE0[2];
+	volatile unsigned int	RxDaDarL;                          //  0x28 R/W 0x00000000 DAI Rx Left Data Destination Address
+	volatile unsigned int	RxDaCdarL;                         //  0x2C R 0x00000000 DAI Rx Left Data Current Destination Address
+	volatile unsigned int	RxCdDarL;                          //  0x30 R/W 0x00000000 CDIF(SPDIF) Rx Left Data Destination Address
+	volatile unsigned int	RxCdCdarL;                         //  0x34 R 0x00000000 CDIF(SPDIF) Rx Left Data Current Destination Address
+	volatile unsigned int	TransCtrl;                         //  0x38 R/W 0x0000AA00 DMA Transfer Control Register
+	volatile unsigned int	RptCtrl;                           //  0x3C R/W 0x00000000 DMA Repeat Control Register
+	volatile unsigned int	TxDaSar;                           //  0x40 R/W 0x00000000 DAI Tx (Right) Data Source Address
+	volatile unsigned int	TxDaParam;                         //  0x44 R/W 0x00000000 DAI Tx Parameters
+	volatile unsigned int	TxDaTCnt;                          //  0x48 R/W 0x00000000 DAI Tx Transmission Counter Register
+	volatile unsigned int	TxDaCsar;                          //  0x4C R 0x00000000 DAI Tx (Right) Data Current Source Address
+	volatile unsigned int	TxSpSar;                           //  0x50 R/W 0x00000000 SPDIF Tx (Right) Data Source Address
+	volatile unsigned int	TxSpParam;                         //  0x54 R/W 0x00000000 SPDIF Tx Parameters
+	volatile unsigned int	TxSpTCnt;                          //  0x58 R/W 0x00000000 SPDIF Tx Transmission Counter Register
+	volatile unsigned int	TxSpCsar;                          //  0x5C R 0x00000000 SPDIF Tx (Right) Data Current Source Address
+	volatile unsigned int   NOTDEFINE1[2];
+	volatile unsigned int	TxDaSarL;                          //  0x68 R/W 0x00000000 DAI Tx Left Data Source Address
+	volatile unsigned int	TxDaCsarL;                         //  0x6C R 0x00000000 DAI Tx Left Data Current Source Address
+	volatile unsigned int	TxSpSarL;                          //  0x70 R/W 0x00000000 SPDIF Tx Left Data Source Address
+	volatile unsigned int	TxSpCsarL;                         //  0x74 R 0x00000000 SPDIF Tx Left Data Current Source address
+	volatile unsigned int	ChCtrl;                            //  0x78 R/W 0x00008000 DMA Channel Control Register
+	volatile unsigned int	IntStatus;                         //  0x7C R/W 0x00000000 DMA Interrupt Status Register
+	volatile unsigned int	GIntReq;                           //  0x80 R/W 0x00000000 General Interrupt Request
+	volatile unsigned int	GIntStatus;                        //  0x84 R 0x00000000 General Interrupt Status
+	volatile unsigned int   NOTDEFINE2[6];	
+	volatile unsigned int	RxDaDar1;                          //  0x100 R/W 0x00000000 DAI1 Rx (Right) Data Destination Address
+	volatile unsigned int	RxDaDar2;                          //  0x104 R/W 0x00000000 DAI2 Rx (Right) Data Destination Address
+	volatile unsigned int	RxDaDar3;                          //  0x108 R/W 0x00000000 DAI3 Rx (Right) Data Destination Address
+	volatile unsigned int	RxDaCar1;                          //  0x10C R 0x00000000 DAI1 Rx (Right) Data Current Destination Address
+	volatile unsigned int	RxDaCar2;                          //  0x110 R 0x00000000 DAI2 Rx (Right) Data Current Destination Address
+	volatile unsigned int	RxDaCar3;                          //  0x114 R 0x00000000 DAI3 Rx (Right) Data Current Destination Address
+	volatile unsigned int	RxDaDarL1;                         //  0x118 R/W 0x00000000 DAI1 Rx Left Data Destination Address
+	volatile unsigned int	RxDaDarL2;                         //  0x11C R/W 0x00000000 DAI2 Rx Left Data Destination Address
+	volatile unsigned int	RxDaDarL3;                         //  0x120 R/W 0x00000000 DAI3 Rx Left Data Destination Address
+	volatile unsigned int	RxDaCarL1;                         //  0x124 R 0x00000000 DAI1 Rx Left Data Current Destination Address
+	volatile unsigned int	RxDaCarL2;                         //  0x128 R 0x00000000 DAI2 Rx Left Data Current Destination Address
+	volatile unsigned int	RxDaCarL3;                         //  0x12C R 0x00000000 DAI3 Rx Left Data Current Destination Address
+	volatile unsigned int	TxDaSar1;                          //  0x130 R/W 0x00000000 DAI1 Tx (Right) Data Source Address
+	volatile unsigned int	TxDaSar2;                          //  0x134 R/W 0x00000000 DAI2 Tx (Right) Data Source Address
+	volatile unsigned int	TxDaSar3;                          //  0x138 R/W 0x00000000 DAI3 Tx (Right) Data Source Address
+	volatile unsigned int	TxDaCsar1;                         //  0x13C R 0x00000000 DAI1 Tx (Right) Data Current Source Address
+	volatile unsigned int	TxDaCsar2;                         //  0x140 R 0x00000000 DAI2 Tx (Right) Data Current Source Address
+	volatile unsigned int	TxDaCsar3;                         //  0x144 R 0x00000000 DAI3 Tx (Right) Data Current Source Address
+	volatile unsigned int	TxDaDarL1;                         //  0x148 R/W 0x00000000 DAI1 Tx Left Data Source Address
+	volatile unsigned int	TxDaDarL2;                         //  0x14C R/W 0x00000000 DAI2 Tx Left Data Source Address
+	volatile unsigned int	TxDaDarL3;                         //  0x150 R/W 0x00000000 DAI3 Tx Left Data Source Address
+	volatile unsigned int	TxDaCarL1;                         //  0x154 R 0x00000000 DAI1 Tx Left Data Current Source Address
+	volatile unsigned int	TxDaCarL2;                         //  0x158 R 0x00000000 DAI2 Tx Left Data Current Source Address
+	volatile unsigned int	TxDaCarL3;                         //  0x15C R 0x00000000 DAI3 Tx Left Data Current Source Address
+}ADMA, *PADMA;
+
+
+/*******************************************************************************
+*	 11-2. DAI Register Define   (Base Addr = 0xF0534000)
+********************************************************************************/
+//#define HwADMA_DAIBASE                         *(volatile unsigned long*)0xF0534000
+
+typedef struct _ADMADAI{
+	volatile unsigned int	DADIR0;                         //  0x00 R - Digital Audio Input Register 0
+	volatile unsigned int	DADIR1;                         //  0x04 R - Digital Audio Input Register 1
+	volatile unsigned int	DADIR2;                         //  0x08 R - Digital Audio Input Register 2
+	volatile unsigned int	DADIR3;                         //  0x0C R - Digital Audio Input Register 3
+	volatile unsigned int	DADIR4;                         //  0x10 R - Digital Audio Input Register 4
+	volatile unsigned int	DADIR5;                         //  0x14 R - Digital Audio Input Register 5
+	volatile unsigned int	DADIR6;                         //  0x18 R - Digital Audio Input Register 6
+	volatile unsigned int	DADIR7;                         //  0x1C R - Digital Audio Input Register 7
+	volatile unsigned int	DADOR0;                         //  0x20 R/W - Digital Audio Output Register 0
+	volatile unsigned int	DADOR1;                         //  0x24 R/W - Digital Audio Output Register 1
+	volatile unsigned int	DADOR2;                         //  0x28 R/W - Digital Audio Output Register 2
+	volatile unsigned int	DADOR3;                         //  0x2C R/W - Digital Audio Output Register 3
+	volatile unsigned int	DADOR4;                         //  0x30 R/W - Digital Audio Output Register 4
+	volatile unsigned int	DADOR5;                         //  0x34 R/W - Digital Audio Output Register 5
+	volatile unsigned int	DADOR6;                         //  0x38 R/W - Digital Audio Output Register 6
+	volatile unsigned int	DADOR7;                         //  0x3C R/W - Digital Audio Output Register 7
+	volatile unsigned int	DAMR;                           //  0x40 R/W 0x00000000 Digital Audio Mode Register
+	volatile unsigned int	DAVC;                           //  0x44 R/W 0x0000 Digital Audio Volume Control Register
+	volatile unsigned int	MCCR0;                          //  0x48 R/W 0x00000000 Multi Channel Control Register 0
+	volatile unsigned int	MCCR1;                          //  0x4C R/W 0x00000000 Multi Channel Control Register 1    
+}ADMADAI, *PADMADAI; 
+
+
+
+/*******************************************************************************
+*	 11-3. CDIF Register Define   (Base Addr = 0xF0534000)
+********************************************************************************/
+//#define HwADMA_CDIFBASE                         *(volatile unsigned long*)0xF0534080
+
+typedef struct _ADMACDIF{
+	volatile unsigned int	CDDI_0;                         //  0x80 R CD Digital Audio Input Register 0
+	volatile unsigned int	CDDI_1;                         //  0x84 R CD Digital Audio Input Register 1
+	volatile unsigned int	CDDI_2;                         //  0x88 R CD Digital Audio Input Register 2
+	volatile unsigned int	CDDI_3;                         //  0x8C R CD Digital Audio Input Register 3
+	volatile unsigned int	CDDI_4;                         //  0x90 R CD Digital Audio Input Register 4
+	volatile unsigned int	CDDI_5;                         //  0x94 R CD Digital Audio Input Register 5
+	volatile unsigned int	CDDI_6;                         //  0x98 R CD Digital Audio Input Register 6
+	volatile unsigned int	CDDI_7;                         //  0x9C R CD Digital Audio Input Register 7
+	volatile unsigned int	CICR;                           //  0xA0 R/W 0x0000 CD Interface Control Register    
+}ADMACDIF, *PADMACDIF;
+
+
+/*******************************************************************************
+*	 11-4. ADMA_SPDIF Register Define   (Base Addr = 0xF0535000/0xF0535800)
+********************************************************************************/
+//#define HwADMA_SPDIFTXBASE                     *(volatile unsigned long*)0xF0535000
+//#define HwADMA_SPDIFRXBASE                     *(volatile unsigned long*)0xF0535800
+
+typedef struct _ADMASPDIFTX{
+	volatile unsigned int	TxVersion;                         //  0x00 R 0x00003111 Version Register
+	volatile unsigned int	TxConfig;                          //  0x04 R/W 0x00000000 Configuration Register
+	volatile unsigned int	TxChStat;                          //  0x08 R/W 0x00000000 Channel Status Control Register
+	volatile unsigned int	TxIntMask;                         //  0x0C R/W 0x00000000 Interrupt Mask Register
+	volatile unsigned int	TxIntStat;                         //  0x10 R/W 0x00000000 Interrupt Status Register
+	volatile unsigned int	NOTDEFINE0[27];
+	volatile unsigned int	UserData[24];                          //  0x80~0xDC W - User Data Buffer
+	volatile unsigned int	NOTDEFINE1[8];
+	volatile unsigned int	ChStatus[24];                          //  0x100~0x15C W - Channel Status Buffer
+	volatile unsigned int	NOTDEFINE2[40];
+	volatile unsigned int	TxBuffer[128];                          //  0x200~0x23C W - Transmit Data Buffer
+	volatile unsigned int	DMACFG;                            //  0x400 R/W 0x00000007 Additional Configuration for DMA
+	//volatile unsigned int	NOTDEFINE4[159];
+	//volatile unsigned int	CSBUDB[24];                        //  0x680~0x6DC W - Merged Window for CSB/UDB   
+}ADMASPDIFTX, *PADMASPDIFTX;
+
+typedef union _RXCAP{
+    volatile unsigned int	RxCapCtln[16];                //  0x840~0x87C(even) W 0x00000000 Channel Status Capture Control Register
+    volatile unsigned int	RxCapn[16];                   //  0x840~0x87C(odd) W 0x00000000 Captured Channel Status / user bit
+}RXCAP;
+    
+typedef struct _ADMASPDIFRX{
+	volatile unsigned int	RxVersion;                        //  0x800 R 0x00080111 Version Register
+	volatile unsigned int	RxConfig;                         //  0x804 R/W 0x00000000 Configuration Register
+	volatile unsigned int	RxStatus;                         //  0x808 R 0x00000000 Signal Status Buffer
+	volatile unsigned int	RxIntMask;                        //  0x80C R/W 0x00000000 Interrupt Mask Register
+	volatile unsigned int	RxIntStat;                        //  0x810 R/W 0x00000000 Interrupt Status register
+	volatile unsigned int   NOTDEFINE0[11];
+	RXCAP   RxCap;
+	//volatile unsigned int	RxCapCtln[16];                //  0x840~0x87C(even) W 0x00000000 Channel Status Capture Control Register
+    //volatile unsigned int	RxCapn[16];                   //  0x840~0x87C(odd) W 0x00000000 Captured Channel Status / user bit
+	volatile unsigned int	RxBuffer[8];                      //  0xA00~0xA1C W - Receive Data Buffer    
+}ADMASPDIFRX, *PADMASPDIFRX;
+
+
+/*******************************************************************************
+*	 12-1. DAI Register Define   (Base Addr = 0xF0537000
+********************************************************************************/
+//#define HwDAI_BASE                          *(volatile unsigned long*)0xF0537000
+typedef struct _DAI{
+	volatile unsigned int	DADI_L0;                         //  0x00 R - Digital Audio Left Input Register 0
+	volatile unsigned int	DADI_R0;                         //  0x04 R - Digital Audio Right Input Register 0
+	volatile unsigned int	DADI_L1;                         //  0x08 R - Digital Audio Left Input Register 1
+	volatile unsigned int	DADI_R1;                         //  0x0C R - Digital Audio Right Input Register 1
+	volatile unsigned int	DADI_L2;                         //  0x10 R - Digital Audio Left Input Register 2
+	volatile unsigned int	DADI_R2;                         //  0x14 R - Digital Audio Right Input Register 2
+	volatile unsigned int	DADI_L3;                         //  0x18 R - Digital Audio Left Input Register 3
+	volatile unsigned int	DADI_R3;                         //  0x1C R - Digital Audio Right Input Register 3
+	volatile unsigned int	DADO_L0;                         //  0x20 R/W - Digital Audio Left Output Register 0
+	volatile unsigned int	DADO_R0;                         //  0x24 R/W - Digital Audio Right Output Register 0
+	volatile unsigned int	DADO_L1;                         //  0x28 R/W - Digital Audio Left Output Register 1
+	volatile unsigned int	DADO_R1;                         //  0x2C R/W - Digital Audio Right Output Register 1
+	volatile unsigned int	DADO_L2;                         //  0x30 R/W - Digital Audio Left Output Register 2
+	volatile unsigned int	DADO_R2;                         //  0x34 R/W - Digital Audio Right Output Register 2
+	volatile unsigned int	DADO_L3;                         //  0x38 R/W - Digital Audio Left Output Register 3
+	volatile unsigned int	DADO_R3;                         //  0x3C R/W - Digital Audio Right Output Register 3
+	volatile unsigned int	DAMR;                            //  0x40 R/W 0x00000000 Digital Audio Mode Register
+	volatile unsigned int	DAVC;                            //  0x44 R/W 0x0000 Digital Audio Volume Control Register
+}DAI, *PDAI;
+
+/*******************************************************************************
+*	 12-2. CDIF Register Define   (Base Addr = 0xF0537000
+********************************************************************************/
+//#define HwCDIF_BASE                             *(volatile unsigned long*)0xF0537080
+typedef struct _CDIF{
+	volatile unsigned int	CDDI_0;                         // 0x80 R CD Digital Audio Input Register 0
+	volatile unsigned int	CDDI_1;                         // 0x84 R CD Digital Audio Input Register 1
+	volatile unsigned int	CDDI_2;                         // 0x88 R CD Digital Audio Input Register 2
+	volatile unsigned int	CDDI_3;                         // 0x8C R CD Digital Audio Input Register 3
+	volatile unsigned int	CICR;                           // 0x90 R/W 0x0000 CD Interface Control Register    
+}CDIF, *PCDIF;
+
+
+/*******************************************************************************
+*	 13. SPDIF Register Define   (Base Addr = 0xF0538000)
+********************************************************************************/
+//#define HwSPDIF_BASE                             *(volatile unsigned long*)0xF0538000
+typedef struct _SPDIF{
+	volatile unsigned int	TxVersion;                          // 0x00 R Version Register
+	volatile unsigned int	TxConfig;                           // 0x04 R/W Configuration Register
+	volatile unsigned int	TxChStat;                           // 0x08 R/W Channel Status Control Register
+	volatile unsigned int	TxIntMask;                          // 0x0C R/W Interrupt Mask Register
+	volatile unsigned int	TxIntStat;                          // 0x10 R/W Interrupt Status Register
+	volatile unsigned int	UserData[24];                       // 0x80~0xDC W - User Data Buffer
+	volatile unsigned int	ChStatus[24];                       // 0x100~0x15C W - Channel Status Buffer
+	volatile unsigned int	TxBuffer[128];                      // 0x200~0x3FC W - Transmit Data Buffer
+	volatile unsigned int	DMACFG;                             // 0x400 R/W - Additional Configuration for DMA    
+}SPDIF, *PSPDIF;
+
+
+/*******************************************************************************
+*	 14-1. USB1.1 HOST Controller & Transceiver       (Base Addr = 0xF0500000)
+********************************************************************************/
+//#define HwUSBHOST_BASE *(volatile unsigned long*)0xF0500000
+typedef struct _USBHOST11{
+	volatile unsigned int	HcRevision;                         // 0x00 R 0x00000010
+	volatile unsigned int	HcControl;                          // 0x04 R/W 0x00000000
+	volatile unsigned int	HcCommandStatus;                    // 0x08 R 0x00000000
+	volatile unsigned int	HcInterruptStatus;                  // 0x0C R 0x00000000
+	volatile unsigned int	HcInterruptEnable;                  // 0x10 R/W 0x00000000
+	volatile unsigned int	HcInterruptDisable;                 // 0x14 W 0x00000000
+	volatile unsigned int	HcHCCA;                             // 0x18 R/W 0x00000000
+	volatile unsigned int	HcPeriodCurrentED;                  // 0x1C R 0x00000000
+	volatile unsigned int	HcControlHeadED;                    // 0x20 R/W 0x00000000
+	volatile unsigned int	HcControlCurrentED;                 // 0x24 R/W 0x00000000
+	volatile unsigned int	HcBulkHeadED;                       // 0x28 R/W 0x00000000
+	volatile unsigned int	HcBulkCurrentED;                    // 0x2C R/W 0x00000000
+	volatile unsigned int	HcDoneHead;                         // 0x30 R 0x00000000
+	volatile unsigned int	HcRmInterval;                       // 0x34 R/W 0x00002EDF
+	volatile unsigned int	HcFmRemaining;                      // 0x38 R/W 0x00000000
+	volatile unsigned int	HcFmNumber;                         // 0x3C R/W 0x00000000
+	volatile unsigned int	HcPeriodStart;                      // 0x40 R/W 0x00000000
+	volatile unsigned int	HcLSThreshold;                      // 0x44 R/W 0x00000628
+	volatile unsigned int	HcRhDescriptorA;                    // 0x48 R/W 0x02001202
+	volatile unsigned int	HcRhDescriptorB;                    // 0x4C R/W 0x00000000
+	volatile unsigned int	HcRhStatus;                         // 0x50 R/W 0x00000000
+	volatile unsigned int	HcRhPortStatus1;                    // 0x54 R/W 0x00000100
+	volatile unsigned int	HcRhPortStatus2;                    // 0x58 R/W 0x00000100
+}USBHOST11, *PUSBHOST11;
+
+
+/*******************************************************************************
+*	 14-2. USB1.1 HOST Configuration Register        (Base Addr = 0xF05F5000)
+********************************************************************************/
+//#define HwUSBHOSTCFG_BASE                       *(volatile unsigned long*)0xF05F5000
+typedef struct _USBHOST11CFG{
+    volatile unsigned int   NOTDEFINE0;
+    volatile unsigned int   USB11H;                             // 0x4 R/W 0x00000010 USB1.1 Host Configuration register
+}USBHOST11CFG, *PUSBHOST11CFG;
+
+
+/*******************************************************************************
+*	 15-1. USB2.0 OTG Controller Define   (Base Addr = 0xF0550000)
+********************************************************************************/
+//#define HwUSB20OTG_BASE                         *(volatile unsigned long*)0xF0550000
+typedef struct _USB20OTG{
+	// Core Global CSR Map
+	volatile unsigned int	GOTGCTL;				// 0x000  R/W	OTG Control and Status Register
+	volatile unsigned int	GOTGINT;				// 0x004     	OTG Interrupt Register
+	volatile unsigned int	GAHBCFG;				// 0x008     	Core AHB Configuration Register 
+	volatile unsigned int	GUSBCFG;				// 0x00C     	Core USB Configuration register
+	volatile unsigned int	GRSTCTL;				// 0x010     	Core Reset Register 
+	volatile unsigned int	GINTSTS;				// 0x014     	Core Interrupt Register 
+	volatile unsigned int	GINTMSK;				// 0x018     	Core Interrupt Mask Register 
+	volatile unsigned int	GRXSTSR;				// 0x01C     	Receive Status Debug Read register(Read Only)
+	volatile unsigned int	GRXSTSP;				// 0x020     	Receive Status Read /Pop register(Read Only)
+	volatile unsigned int	GRXFSIZ;				// 0x024     	Receive FIFO Size Register 
+	volatile unsigned int	GNPTXFSIZ;				// 0x028     	Non-periodic Transmit FIFO Size register
+	volatile unsigned int	GNPTXSTS;				// 0x02C     	Non-periodic Transmit FIFO/Queue Status register (Read Only)
+	volatile unsigned int	NOTDEFINE0[3];			// 0x030~    	Reserved
+	volatile unsigned int	GUID;					// 0x03C     	User ID Register 
+	volatile unsigned int	NOTDEFINE1; 			// 0x040     	Reserved
+	volatile unsigned int	GHWCFG1;				// 0x044     	User HW Config1 Register(Read Only) 
+	volatile unsigned int	GHWCFG2;				// 0x048     	User HW Config2 Register(Read Only) 
+	volatile unsigned int	GHWCFG3;				// 0x04C     	User HW Config3 Register(Read Only) 
+	volatile unsigned int	GHWCFG4;				// 0x050     	User HW Config4 Register(Read Only) 
+	volatile unsigned int	NOTDEFINE2[43];			// 0x054~    	Reserved
+	volatile unsigned int	HPTXFSIZ;				// 0x100     	Host Periodic Transmit FIFO Size Register
+	volatile unsigned int	DIEPTXFn[15];			// 0x104~    	Device IN Endpoint Transmit FIFO Size register
+	volatile unsigned int	NOTDEFINE3[176];		// 0x140~    	Reserved
+	// Host Mode CSR Map
+	volatile unsigned int	HCFG;					// 0x400     	Host Configuration Register 
+	volatile unsigned int	HFIR;					// 0x404     	Host Frame Interval Register 
+	volatile unsigned int	HFNUM;					// 0x408     	Host Frame Number/Frame Time Remaining register
+	volatile unsigned int	NOTDEFINE4; 			// 0x40C     	Reserved
+	volatile unsigned int	HPTXSTS;				// 0x410     	Host Periodic Transmit FIFO/Queue Status Register
+	volatile unsigned int	HAINT;					// 0x414     	Host All Channels Interrupt Register
+	volatile unsigned int	HAINTMSK;				// 0x418     	Host All Channels Interrupt Mask register
+	volatile unsigned int	NOTDEFINE5[9];			// 0x41C~    	Not Used
+	volatile unsigned int	HPRT;					// 0x440     	Host Port Control and Status register
+	volatile unsigned int	NOTDEFINE6[47]; 		// 0x444~    	Reserved
+	volatile unsigned int	HCCHARn;				// 0x500     	Host Channel 0 Characteristics Register
+	volatile unsigned int	HCSPLTn;				// 0x504     	Host Channel 0 Split Control Register 
+	volatile unsigned int	HCINTn; 				// 0x508     	Host Channel 0 Interrupt Register 
+	volatile unsigned int	HCINTMSKn;				// 0x50C     	Host Channel 0 Interrupt Mask Register
+	volatile unsigned int	HCTSIZn;				// 0x510     	Host Channel 0 Transfer Size Register 
+	volatile unsigned int	HCDMAn; 				// 0x514     	Host Channel 0 DMA Address Register 
+	volatile unsigned int	NOTDEFINE7[2];			// 0x518~    	Reserved
+	volatile unsigned int	HCH1[8];				// 0x520~    	Host Channel 1 Registers
+	volatile unsigned int	HCH2[8];				// 0x540~    	Host Channel 2 Registers
+	volatile unsigned int	HCH3[8];				// 0x560~    	Host Channel 3 Registers
+	volatile unsigned int	HCH4[8];				// 0x580~    	Host Channel 4 Registers
+	volatile unsigned int	HCH5[8];				// 0x5A0~    	Host Channel 5 Registers
+	volatile unsigned int	HCH6[8];				// 0x5C0~    	Host Channel 6 Registers
+	volatile unsigned int	HCH7[8];				// 0x5E0~    	Host Channel 7 Registers
+	volatile unsigned int	HCH8[8];				// 0x600~    	Host Channel 8 Registers
+	volatile unsigned int	HCH9[8];				// 0x620~    	Host Channel 9 Registers
+	volatile unsigned int	HCH10[8];				// 0x640~    	Host Channel 10 Registers
+	volatile unsigned int	HCH11[8];				// 0x660~    	Host Channel 11 Registers
+	volatile unsigned int	HCH12[8];				// 0x680~    	Host Channel 12 Registers
+	volatile unsigned int	HCH13[8];				// 0x6A0~    	Host Channel 13 Registers
+	volatile unsigned int	HCH14[8];				// 0x6C0~    	Host Channel 14 Registers
+	volatile unsigned int	HCH15[8];				// 0x6E0~    	Host Channel 15 Registers
+	volatile unsigned int	NOTDEFINE8[64]; 		// 0x700~    	Reserved
+	// Device Mode CSR Map
+	volatile unsigned int	DCFG;					// 0x800     	Device Configuration Register 
+	volatile unsigned int	DCTL;					// 0x804     	Device Control Register
+	volatile unsigned int	DSTS;					// 0x808     	Device Status Register (Read Only)
+	volatile unsigned int	NOTDEFINE9; 			// 0x80C     	Reserved 
+	volatile unsigned int	DIEPMSK;				// 0x810     	Device IN Endpoint Common Interrupt Mask Register
+	volatile unsigned int	DOEPMSK;				// 0x814     	Device OUT Endpoint Common Interrupt Mask register
+	volatile unsigned int	DAINT;					// 0x818     	Device All Endpoints Interrupt Register 
+	volatile unsigned int	DAINTMSK;				// 0x81C     	Device All Endpoints Interrupt Mask Register
+	volatile unsigned int	NOTDEFINE10[2];			// 0x820~    	Reserved
+	volatile unsigned int	DVBUSDIS;				// 0x828    	Device VBUS Discharge Time Register
+	volatile unsigned int	DVBUSPULSE; 			// 0x82C     	Device VBUS Pulsing Time register
+	volatile unsigned int	DTHRCTL;				// 0x830     	Device Threshold Control register
+	volatile unsigned int	DIEPEMPMSK; 			// 0x834     	Device IN Endpoint FIFO Empty Interrupt Mask register
+	volatile unsigned int	NOTDEFINE11[50];		// 0x838~    	Reserved
+
+	volatile unsigned int	DIEPCTL0;				// 0x900     	Device Control IN Endpoint 0 Control Register
+	volatile unsigned int	NOTDEFINE12;			// 0x904     	Reserved 
+	volatile unsigned int	DIEPINT0;				// 0x908     	Device IN Endpoint 0 Interrupt Register 
+	volatile unsigned int	NOTDEFINE13;			// 0x90C     	Reserved
+	volatile unsigned int	DIEPTSIZ0;				// 0x910     	Device IN Endpoint 0 Transfer Size register
+	volatile unsigned int	DIEPDMA0;				// 0x914     	Device IN Endpoint 0 DMA Address Register
+	volatile unsigned int	DTXFSTS0;				// 0x918     	Device IN Endpoint Transmit FIFO Status Register
+	volatile unsigned int	NOTDEFINE14;			// 0x91C     	Reserved 
+
+	volatile unsigned int	DEVINENDPT[15][8];		// 0x920~    	Device IN Endpoint 1~15 Registers
+	volatile unsigned int	DOEPCTL0;				// 0xB00     	Device Control OUT Endpoint 0 Control register 
+	volatile unsigned int	NOTDEFINE15;			// 0xB04     	Reserved 
+	volatile unsigned int	DOEPINT0;				// 0xB08     	Device OUT Endpoint 0 Interrupt Register
+	volatile unsigned int	NOTDEFINE16;			// 0xB0C     	Reserved 
+	volatile unsigned int	DOEPTSIZ0;				// 0xB10     	Device OUT Endpoint 0 Transfer Size Register
+	volatile unsigned int	DOEPDMA0;				// 0xB14     	Device OUT Endpoint 0 DMA Address register
+	volatile unsigned int	NOTDEFINE17[2]; 		// 0xB18~    	Reserved
+	volatile unsigned int	DEVOUTENDPT[15][8];		// 0xB20~    	Device OUT Endpoint 1~15 Registers
+	volatile unsigned int	NOTDEFINE18[64];		// 0xD00~    	Reserved
+	// Power and Clock Gating CSR Map
+	volatile unsigned int	PCGCR;					// 0xE00     	Power and Clock Gating Control Register  
+	volatile unsigned int	NOTDEFINE19[127];		// 0xE04~    	Reserved
+	// Data FIFO(DFIFO) Access Register Map
+	volatile unsigned int	DFIFOENDPT[16][1024];	// 0x1000~   	Device IN Endpoint 0~16/Host Out Channel 0~16: DFIFO Write/Read Access
+	//volatile unsigned int	DFIFOENDPT0[1024];		// 0x1000~   	Device IN Endpoint 0/Host Out Channel 0: DFIFO Write/Read Access
+	//volatile unsigned int	DFIFOENDPT1[1024];		// 0x2000~   	Device IN Endpoint 1/Host Out Channel 1: DFIFO Write/Read Access
+	//volatile unsigned int	DFIFOENDPT2[1024];		// 0x3000~   	Device IN Endpoint 2/Host Out Channel 2: DFIFO Write/Read Access
+	//volatile unsigned int	DFIFOENDPT3[1024];		// 0x4000~   	Device IN Endpoint 3/Host Out Channel 3: DFIFO Write/Read Access
+	//volatile unsigned int	DFIFOENDPT4[1024];		// 0x5000~   	Device IN Endpoint 4/Host Out Channel 4: DFIFO Write/Read Access
+	//volatile unsigned int	DFIFOENDPT5[1024];		// 0x6000~   	Device IN Endpoint 5/Host Out Channel 5: DFIFO Write/Read Access
+	//volatile unsigned int	DFIFOENDPT6[1024];		// 0x7000~   	Device IN Endpoint 6/Host Out Channel 6: DFIFO Write/Read Access
+	//volatile unsigned int	DFIFOENDPT7[1024];		// 0x8000~   	Device IN Endpoint 7/Host Out Channel 7: DFIFO Write/Read Access
+	//volatile unsigned int	DFIFOENDPT8[1024];		// 0x9000~   	Device IN Endpoint 8/Host Out Channel 8: DFIFO Write/Read Access
+	//volatile unsigned int	DFIFOENDPT9[1024];		// 0xA000~   	Device IN Endpoint 9/Host Out Channel 9: DFIFO Write/Read Access
+	//volatile unsigned int	DFIFOENDPT10[1024];		// 0xB000~   	Device IN Endpoint 10/Host Out Channel 10: DFIFO Write/Read Access
+	//volatile unsigned int	DFIFOENDPT11[1024];		// 0xC000~   	Device IN Endpoint 11/Host Out Channel 11: DFIFO Write/Read Access
+	//volatile unsigned int	DFIFOENDPT12[1024];		// 0xD000~   	Device IN Endpoint 12/Host Out Channel 12: DFIFO Write/Read Access
+	//volatile unsigned int	DFIFOENDPT13[1024];		// 0xE000~   	Device IN Endpoint 13/Host Out Channel 13: DFIFO Write/Read Access
+	//volatile unsigned int	DFIFOENDPT14[1024];		// 0xF000~   	Device IN Endpoint 14/Host Out Channel 14: DFIFO Write/Read Access
+	//volatile unsigned int	DFIFOENDPT15[1024];		// 0x10000~   	Device IN Endpoint 15/Host Out Channel 15: DFIFO Write/Read Access
+}USB20OTG, *PUSB20OTG;
+
+typedef struct _USBOTG{
+	// Core Global CSR Map
+	volatile unsigned int	GOTGCTL;				// 0x000  R/W	OTG Control and Status Register
+	volatile unsigned int	GOTGINT;				// 0x004     	OTG Interrupt Register
+	volatile unsigned int	GAHBCFG;				// 0x008     	Core AHB Configuration Register 
+	volatile unsigned int	GUSBCFG;				// 0x00C     	Core USB Configuration register
+	volatile unsigned int	GRSTCTL;				// 0x010     	Core Reset Register 
+	volatile unsigned int	GINTSTS;				// 0x014     	Core Interrupt Register 
+	volatile unsigned int	GINTMSK;				// 0x018     	Core Interrupt Mask Register 
+	volatile unsigned int	GRXSTSR;				// 0x01C     	Receive Status Debug Read register(Read Only)
+	volatile unsigned int	GRXSTSP;				// 0x020     	Receive Status Read /Pop register(Read Only)
+	volatile unsigned int	GRXFSIZ;				// 0x024     	Receive FIFO Size Register 
+	volatile unsigned int	GNPTXFSIZ;				// 0x028     	Non-periodic Transmit FIFO Size register
+	volatile unsigned int	GNPTXSTS;				// 0x02C     	Non-periodic Transmit FIFO/Queue Status register (Read Only)
+	volatile unsigned int	NOTDEFINE0[3];			// 0x030~    	Reserved
+	volatile unsigned int	GUID;					// 0x03C     	User ID Register 
+	volatile unsigned int	NOTDEFINE1; 			// 0x040     	Reserved
+	volatile unsigned int	GHWCFG1;				// 0x044     	User HW Config1 Register(Read Only) 
+	volatile unsigned int	GHWCFG2;				// 0x048     	User HW Config2 Register(Read Only) 
+	volatile unsigned int	GHWCFG3;				// 0x04C     	User HW Config3 Register(Read Only) 
+	volatile unsigned int	GHWCFG4;				// 0x050     	User HW Config4 Register(Read Only) 
+	volatile unsigned int	NOTDEFINE2[43];			// 0x054~    	Reserved
+	volatile unsigned int	HPTXFSIZ;				// 0x100     	Host Periodic Transmit FIFO Size Register
+	volatile unsigned int	DIEPTXFn[15];			// 0x104~    	Device IN Endpoint Transmit FIFO Size register
+	volatile unsigned int	NOTDEFINE3[176];		// 0x140~    	Reserved
+	// Host Mode CSR Map
+	volatile unsigned int	HCFG;					// 0x400     	Host Configuration Register 
+	volatile unsigned int	HFIR;					// 0x404     	Host Frame Interval Register 
+	volatile unsigned int	HFNUM;					// 0x408     	Host Frame Number/Frame Time Remaining register
+	volatile unsigned int	NOTDEFINE4; 			// 0x40C     	Reserved
+	volatile unsigned int	HPTXSTS;				// 0x410     	Host Periodic Transmit FIFO/Queue Status Register
+	volatile unsigned int	HAINT;					// 0x414     	Host All Channels Interrupt Register
+	volatile unsigned int	HAINTMSK;				// 0x418     	Host All Channels Interrupt Mask register
+	volatile unsigned int	NOTDEFINE5[9];			// 0x41C~    	Not Used
+	volatile unsigned int	HPRT;					// 0x440     	Host Port Control and Status register
+	volatile unsigned int	NOTDEFINE6[47]; 		// 0x444~    	Reserved
+	volatile unsigned int	HCCHARn;				// 0x500     	Host Channel 0 Characteristics Register
+	volatile unsigned int	HCSPLTn;				// 0x504     	Host Channel 0 Split Control Register 
+	volatile unsigned int	HCINTn; 				// 0x508     	Host Channel 0 Interrupt Register 
+	volatile unsigned int	HCINTMSKn;				// 0x50C     	Host Channel 0 Interrupt Mask Register
+	volatile unsigned int	HCTSIZn;				// 0x510     	Host Channel 0 Transfer Size Register 
+	volatile unsigned int	HCDMAn; 				// 0x514     	Host Channel 0 DMA Address Register 
+	volatile unsigned int	NOTDEFINE7[2];			// 0x518~    	Reserved
+	volatile unsigned int	HCH1[8];				// 0x520~    	Host Channel 1 Registers
+	volatile unsigned int	HCH2[8];				// 0x540~    	Host Channel 2 Registers
+	volatile unsigned int	HCH3[8];				// 0x560~    	Host Channel 3 Registers
+	volatile unsigned int	HCH4[8];				// 0x580~    	Host Channel 4 Registers
+	volatile unsigned int	HCH5[8];				// 0x5A0~    	Host Channel 5 Registers
+	volatile unsigned int	HCH6[8];				// 0x5C0~    	Host Channel 6 Registers
+	volatile unsigned int	HCH7[8];				// 0x5E0~    	Host Channel 7 Registers
+	volatile unsigned int	HCH8[8];				// 0x600~    	Host Channel 8 Registers
+	volatile unsigned int	HCH9[8];				// 0x620~    	Host Channel 9 Registers
+	volatile unsigned int	HCH10[8];				// 0x640~    	Host Channel 10 Registers
+	volatile unsigned int	HCH11[8];				// 0x660~    	Host Channel 11 Registers
+	volatile unsigned int	HCH12[8];				// 0x680~    	Host Channel 12 Registers
+	volatile unsigned int	HCH13[8];				// 0x6A0~    	Host Channel 13 Registers
+	volatile unsigned int	HCH14[8];				// 0x6C0~    	Host Channel 14 Registers
+	volatile unsigned int	HCH15[8];				// 0x6E0~    	Host Channel 15 Registers
+	volatile unsigned int	NOTDEFINE8[64]; 		// 0x700~    	Reserved
+	// Device Mode CSR Map
+	volatile unsigned int	DCFG;					// 0x800     	Device Configuration Register 
+	volatile unsigned int	DCTL;					// 0x804     	Device Control Register
+	volatile unsigned int	DSTS;					// 0x808     	Device Status Register (Read Only)
+	volatile unsigned int	NOTDEFINE9; 			// 0x80C     	Reserved 
+	volatile unsigned int	DIEPMSK;				// 0x810     	Device IN Endpoint Common Interrupt Mask Register
+	volatile unsigned int	DOEPMSK;				// 0x814     	Device OUT Endpoint Common Interrupt Mask register
+	volatile unsigned int	DAINT;					// 0x818     	Device All Endpoints Interrupt Register 
+	volatile unsigned int	DAINTMSK;				// 0x81C     	Device All Endpoints Interrupt Mask Register
+	volatile unsigned int	NOTDEFINE10[2];			// 0x820~    	Reserved
+	volatile unsigned int	DVBUSDIS;				// 0x828    	Device VBUS Discharge Time Register
+	volatile unsigned int	DVBUSPULSE; 			// 0x82C     	Device VBUS Pulsing Time register
+	volatile unsigned int	DTHRCTL;				// 0x830     	Device Threshold Control register
+	volatile unsigned int	DIEPEMPMSK; 			// 0x834     	Device IN Endpoint FIFO Empty Interrupt Mask register
+	volatile unsigned int	NOTDEFINE11[50];		// 0x838~    	Reserved
+
+	//volatile unsigned int	DIEPCTL0;				// 0x900     	Device Control IN Endpoint 0 Control Register
+	//volatile unsigned int	NOTDEFINE12;			// 0x904     	Reserved 
+	//volatile unsigned int	DIEPINT0;				// 0x908     	Device IN Endpoint 0 Interrupt Register 
+	//volatile unsigned int	NOTDEFINE13;			// 0x90C     	Reserved
+	//volatile unsigned int	DIEPTSIZ0;				// 0x910     	Device IN Endpoint 0 Transfer Size register
+	//volatile unsigned int	DIEPDMA0;				// 0x914     	Device IN Endpoint 0 DMA Address Register
+	//volatile unsigned int	DTXFSTS0;				// 0x918     	Device IN Endpoint Transmit FIFO Status Register
+	//volatile unsigned int	NOTDEFINE14;			// 0x91C     	Reserved 
+
+	volatile unsigned int	DEVINENDPT[16][8];		// 0x900~    	Device IN Endpoint 1~15 Registers
+	
+	//volatile unsigned int	DOEPCTL0;				// 0xB00     	Device Control OUT Endpoint 0 Control register 
+	//volatile unsigned int	NOTDEFINE15;			// 0xB04     	Reserved 
+	//volatile unsigned int	DOEPINT0;				// 0xB08     	Device OUT Endpoint 0 Interrupt Register
+	//volatile unsigned int	NOTDEFINE16;			// 0xB0C     	Reserved 
+	//volatile unsigned int	DOEPTSIZ0;				// 0xB10     	Device OUT Endpoint 0 Transfer Size Register
+	//volatile unsigned int	DOEPDMA0;				// 0xB14     	Device OUT Endpoint 0 DMA Address register
+	//volatile unsigned int	NOTDEFINE17[2]; 		// 0xB18~    	Reserved
+
+	volatile unsigned int	DEVOUTENDPT[16][8];		// 0xB00~    	Device OUT Endpoint 1~15 Registers
+	volatile unsigned int	NOTDEFINE18[64];		// 0xD00~    	Reserved
+
+	// Power and Clock Gating CSR Map
+	volatile unsigned int	PCGCR;					// 0xE00     	Power and Clock Gating Control Register  
+	volatile unsigned int	NOTDEFINE19[127];		// 0xE04~    	Reserved
+	// Data FIFO(DFIFO) Access Register Map
+	volatile unsigned int	DFIFOENDPT[16][1024];	// 0x1000~   	Device IN Endpoint 0~16/Host Out Channel 0~16: DFIFO Write/Read Access
+	//volatile unsigned int	DFIFOENDPT0[1024];		// 0x1000~   	Device IN Endpoint 0/Host Out Channel 0: DFIFO Write/Read Access
+	//volatile unsigned int	DFIFOENDPT1[1024];		// 0x2000~   	Device IN Endpoint 1/Host Out Channel 1: DFIFO Write/Read Access
+	//volatile unsigned int	DFIFOENDPT2[1024];		// 0x3000~   	Device IN Endpoint 2/Host Out Channel 2: DFIFO Write/Read Access
+	//volatile unsigned int	DFIFOENDPT3[1024];		// 0x4000~   	Device IN Endpoint 3/Host Out Channel 3: DFIFO Write/Read Access
+	//volatile unsigned int	DFIFOENDPT4[1024];		// 0x5000~   	Device IN Endpoint 4/Host Out Channel 4: DFIFO Write/Read Access
+	//volatile unsigned int	DFIFOENDPT5[1024];		// 0x6000~   	Device IN Endpoint 5/Host Out Channel 5: DFIFO Write/Read Access
+	//volatile unsigned int	DFIFOENDPT6[1024];		// 0x7000~   	Device IN Endpoint 6/Host Out Channel 6: DFIFO Write/Read Access
+	//volatile unsigned int	DFIFOENDPT7[1024];		// 0x8000~   	Device IN Endpoint 7/Host Out Channel 7: DFIFO Write/Read Access
+	//volatile unsigned int	DFIFOENDPT8[1024];		// 0x9000~   	Device IN Endpoint 8/Host Out Channel 8: DFIFO Write/Read Access
+	//volatile unsigned int	DFIFOENDPT9[1024];		// 0xA000~   	Device IN Endpoint 9/Host Out Channel 9: DFIFO Write/Read Access
+	//volatile unsigned int	DFIFOENDPT10[1024];		// 0xB000~   	Device IN Endpoint 10/Host Out Channel 10: DFIFO Write/Read Access
+	//volatile unsigned int	DFIFOENDPT11[1024];		// 0xC000~   	Device IN Endpoint 11/Host Out Channel 11: DFIFO Write/Read Access
+	//volatile unsigned int	DFIFOENDPT12[1024];		// 0xD000~   	Device IN Endpoint 12/Host Out Channel 12: DFIFO Write/Read Access
+	//volatile unsigned int	DFIFOENDPT13[1024];		// 0xE000~   	Device IN Endpoint 13/Host Out Channel 13: DFIFO Write/Read Access
+	//volatile unsigned int	DFIFOENDPT14[1024];		// 0xF000~   	Device IN Endpoint 14/Host Out Channel 14: DFIFO Write/Read Access
+	//volatile unsigned int	DFIFOENDPT15[1024];		// 0x10000~   	Device IN Endpoint 15/Host Out Channel 15: DFIFO Write/Read Access
+}USBOTG, *PUSBOTG;
+/*******************************************************************************
+*	15-2. USB OTG Configuration Register Define   (Base Addr = 0xF05F5000)
+********************************************************************************/
+//#define HwUSBOTGCFG_BASE                        *(volatile unsigned long*)0xF05F5000
+typedef struct _USBOTGCFG{
+	volatile unsigned int	OTGCR;					// 0x000  R/W	USBOTG Configuration Register
+	volatile unsigned int	OTGID;					// 0x004  R/W	USBOTG ID Register
+	volatile unsigned int	NOTUSED[8];     // 0x08, 0x0C, 0x10, 0x14, 0x18, 0x1C, 0x20, 0x24		
+	volatile unsigned int	UPCR0;					// 0x028  R/W	USB PHY Configuration Register0
+	volatile unsigned int	UPCR1;					// 0x02C  R/W	USB PHY Configuration Register1
+	volatile unsigned int	UPCR2;					// 0x030  R/W	USB PHY Configuration Register2
+	volatile unsigned int	UPCR3;					// 0x034  R/W	USB PHY Configuration Register3			
+}USBOTGCFG, *PUSBOTGCFG;
+
+/*******************************************************************************
+*	 15-3. USB PHY Configuration Register Define   (Base Addr = 0xF05F5028)
+********************************************************************************/
+//#define HwUSBPHYCFG_BASE                        *(volatile unsigned long*)0xF05F5028
+typedef struct _USBPHYCFG
+{
+	volatile unsigned int	UPCR0;					// 0x028  R/W	USB PHY Configuration Register0
+	volatile unsigned int	UPCR1;					// 0x02C  R/W	USB PHY Configuration Register1
+	volatile unsigned int	UPCR2;					// 0x030  R/W	USB PHY Configuration Register2
+	volatile unsigned int	UPCR3;					// 0x034  R/W	USB PHY Configuration Register3
+}USBPHYCFG, *PUSBPHYCFG;
+
+
+/*******************************************************************************
+*	 16. External Host Interface Register Define   (Base Addr = 0xF0570000/0xF0580000)
+********************************************************************************/
+//#define HwEHICS0_BASE                           *(volatile unsigned long*)0xF0570000
+//#define HwEHICS1_BASE                           *(volatile unsigned long*)0xF0580000
+
+typedef struct _EHI{
+    volatile unsigned int   EHST;               //0x00 R/W R/W 0x00000080 Status register
+    volatile unsigned int   EHIINT;             //0x04 R/W R/W 0x00000000 Internal interrupt control register
+    volatile unsigned int   EHEINT;             //0x08 R/W R/W 0x00000000 External interrupt control register
+    volatile unsigned int   EHA;                //0x0C R R/W 0x00000000 Address register
+    volatile unsigned int   EHAM;               //0x10 R/W R 0x00000000 Address masking register
+    volatile unsigned int   EHD;                //0x14 R/W R/W 0x00000000 Data register
+    volatile unsigned int   EHSEM;              //0x18 R/W R/W 0x00000000 Semaphore register
+    volatile unsigned int   EHCFG;              //0x1C R/W R/W 0x00000000 Configuration registers
+    volatile unsigned int   EHIND;              //0x20 R W 0x00000000 Index register
+    volatile unsigned int   EHRWCS;             //0x24 R R/W 0x00000000 Read/Write Control/Status register    
+}EHI, *PEHI;
+
+/*******************************************************************************
+*	 17. General Purpose Serial Bus (GPSB) Register Define   (Base Addr = 0xF0057000)
+********************************************************************************/
+/*
+#define HwGPSBCH0_BASE                          *(volatile unsigned long*)0xF0057000
+#define HwGPSBCH1_BASE                          *(volatile unsigned long*)0xF0057100
+#define HwGPSBCH2_BASE                          *(volatile unsigned long*)0xF0057200
+#define HwGPSBCH3_BASE                          *(volatile unsigned long*)0xF0057300
+#define HwGPSBCH4_BASE                          *(volatile unsigned long*)0xF0057400
+#define HwGPSBCH5_BASE                          *(volatile unsigned long*)0xF0057500
+#define HwGPSBPORTCFG_BASE                      *(volatile unsigned long*)0xF0057800
+#define HwGPSBPIDTABLE_BASE                     *(volatile unsigned long*)0xF0057F00
+*/
+
+typedef struct _GPSB{
+    volatile unsigned int   PORT;               // 0x000 R/W 0x0000 Data port
+    volatile unsigned int   STAT;               // 0x004 R/W 0x0000 Status register
+    volatile unsigned int   INTEN;              // 0x008 R/W 0x0000 Interrupt enable
+    volatile unsigned int   MODE;               // 0x00C R/W 0x0004 Mode register
+    volatile unsigned int   CTRL;               // 0x010 R/W 0x0000 Control register
+    volatile unsigned int   EVTCTRL;            // 0x014 R/W 0x0000 Counter & Ext. Event Control
+    volatile unsigned int   CCV;                // 0x018 R 0x0000 Counter Current Value
+    volatile unsigned int   NOTDEFINE0;
+    volatile unsigned int   TXBASE;             // 0x020 R/W 0x0000 TX base address register
+    volatile unsigned int   RXBASE;             // 0x024 R/W 0x0000 RX base address register
+    volatile unsigned int   PACKET;             // 0x028 R/W 0x0000 Packet register
+    volatile unsigned int   DMACTR;             // 0x02C R/W 0x0000 DMA control register
+    volatile unsigned int   DMASTR;             // 0x030 R/W 0x0000 DMA status register
+    volatile unsigned int   DMAICR;             // 0x034 R/W 0x0000 DMA interrupt control register
+}GPSB, *PGPSB;
+
+
+typedef struct _GPSBPORTCFG{
+    volatile unsigned int   PCFG0;              // 0x800 R/W 0x03020100 Port Configuration Register 0
+    volatile unsigned int   PCFG1;              // 0x804 R/W 0x00000504 Port Configuration Port Config Register 1
+    volatile unsigned int   CIRQST;             // 0x808 R 0x0000 Channel IRQ Status Register   
+}GPSBPORTCFG, *PGPSBPORTCFG;
+
+
+typedef struct _GPSBPIDTABLE{
+    volatile unsigned int   PIDT[0x80/4]; // 0xF00 R/W   PID Table 
+}GPSBPIDTABLE, *PGPSBPIDTABLE;
+
+
+/*******************************************************************************
+*	 18. The Transport Stream Interface (TSIF) Register Define   (Base Addr = 0xF0538000)
+********************************************************************************/
+//#define HwTSIF_BASE                             *(volatile unsigned long*)0xF053B000
+//#define HwTSIFPORTSEL_BASE                      *(volatile unsigned long*)0xF053B800
+
+typedef struct _TSIF{
+    volatile unsigned int  TSDI; //0x00 R 0x0000 TSIF Input Data Register
+    volatile unsigned int  TSCR; //0x04 R/W 0x0000 TSIF Control Register
+    volatile unsigned int  TSPID; //0x08 R/W 0x0000 TSIF PID Register
+    volatile unsigned int  TSCTRL; //0x10 R/W 0x0000 TSIF Interrupt Control Register
+    volatile unsigned int  TSSTS; //0x10(14) R 0x0000 TSIF Interrupt Status Register(Test)
+}TSIF, *PTSIF;
+
+typedef struct _TSIFPORTSEL{
+    volatile unsigned int  TSCHS; //0x800 R/W 0x0000 TSIF Channel(Port) Select Register    
+}TSIFPORTSEL, *PTSIFPORTSEL;
+
+/*******************************************************************************
+*	 19. GPS Interface Register Define   (Base Addr = )
+********************************************************************************/
+
+
+/*******************************************************************************
+*	 20. Remote Control Interface Register Define   (Base Addr = 0xF05F3000)
+********************************************************************************/
+//#define HwREMOCON_BASE                          *(volatile unsigned long*)0xF05F3000
+
+typedef struct _REMOTECON{
+    volatile unsigned int  TXADDR;              // 0x00 R/W 0x0000 IR Data Transfer Address
+    volatile unsigned int  CMD;                 // 0x04 R/W 0x0000 Command Register
+    volatile unsigned int  CTRL;                // 0x08 R/W 0x0000 Control Register
+    volatile unsigned int  STA;                 // 0x0C W 0x0000 Status register
+    volatile unsigned int  NOTDEFINE0[13];
+    volatile unsigned int  CLKDIV;              // 0x40 R 0x0000 Clock Divide Register   
+}REMOTECON, *PREMOTECON;
+
+
+/*******************************************************************************
+*	 21. I2C Controller Register Define   (Base Addr = 0xF0530000)
+********************************************************************************/
+/*
+#define HwI2CMASTER0_BASE                          *(volatile unsigned long*)0xF0530000
+#define HwI2CMASTER1_BASE                          *(volatile unsigned long*)0xF0530040
+#define HwI2CSLAVE_BASE                            *(volatile unsigned long*)0xF0530080
+#define HwI2CSTATUS_BASE                           *(volatile unsigned long*)0xF05300C0
+*/
+
+typedef struct _I2CMASTER{
+    volatile unsigned int  PRES;                // 0x00 R/W 0xFFFF Clock Prescale register
+    volatile unsigned int  CTRL;                // 0x04 R/W 0x0000 Control Register
+    volatile unsigned int  TXR;                 // 0x08 W 0x0000 Transmit Register
+    volatile unsigned int  CMD;                 // 0x0C W 0x0000 Command Register
+    volatile unsigned int  RXR;                 // 0x10 R 0x0000 Receive Register
+    volatile unsigned int  SR;                  // 0x14 R 0x0000 Status register
+    volatile unsigned int  TIME;                // 0x18 R/W 0x0000 Timing Control Register    
+}I2CMASTER, *PI2CMASTER;
+
+typedef struct _I2C{
+	volatile unsigned int  PRES0;                // 0x00 R/W 0xFFFF Clock Prescale register
+	volatile unsigned int  CTRL0;                // 0x04 R/W 0x0000 Control Register
+	volatile unsigned int  TXR0;                 // 0x08 W 0x0000 Transmit Register
+	volatile unsigned int  CMD0;                 // 0x0C W 0x0000 Command Register
+	volatile unsigned int  RXR0;                 // 0x10 R 0x0000 Receive Register
+	volatile unsigned int  SR0;                  // 0x14 R 0x0000 Status register
+	volatile unsigned int  TIME0;                // 0x18 R/W 0x0000 Timing Control Register    
+	volatile unsigned int  NOTUSING[9];			 // 1c, 20, 24,28,2c,30,34,38,3c,
+	volatile unsigned int  PRES1;                // 0x40 R/W 0xFFFF Clock Prescale register
+	volatile unsigned int  CTRL1;                // 0x44 R/W 0x0000 Control Register
+	volatile unsigned int  TXR1;                 // 0x48 W 0x0000 Transmit Register
+	volatile unsigned int  CMD1;                 // 0x4C W 0x0000 Command Register
+	volatile unsigned int  RXR1;                 // 0x50 R 0x0000 Receive Register
+	volatile unsigned int  SR1;                  // 0x54 R 0x0000 Status register
+	volatile unsigned int  TIME1;                // 0x58 R/W 0x0000 Timing Control Register    
+	volatile unsigned int  NOTUSING1[26];	
+	volatile unsigned int  IRQSTR;              // 0xC0 R 0x00000000 IRQ Status Register    
+}I2C, *PI2C;
+
+typedef struct _SMUI2C{
+	volatile unsigned int  PRES0;                // 0x00 R/W 0xFFFF Clock Prescale register
+	volatile unsigned int  CTRL0;                // 0x04 R/W 0x0000 Control Register
+	volatile unsigned int  TXR0;                 // 0x08 W 0x0000 Transmit Register
+	volatile unsigned int  CMD0;                 // 0x0C W 0x0000 Command Register
+	volatile unsigned int  RXR0;                 // 0x10 R 0x0000 Receive Register
+	volatile unsigned int  SR0;                  // 0x14 R 0x0000 Status register
+	volatile unsigned int  TIME0;                // 0x18 R/W 0x0000 Timing Control Register    
+	volatile unsigned int  NOTUSING[9];			 // 1c, 20, 24,28,2c,30,34,38,3c,
+	volatile unsigned int  PRES1;                // 0x40 R/W 0xFFFF Clock Prescale register
+	volatile unsigned int  CTRL1;                // 0x44 R/W 0x0000 Control Register
+	volatile unsigned int  TXR1;                 // 0x48 W 0x0000 Transmit Register
+	volatile unsigned int  CMD1;                 // 0x4C W 0x0000 Command Register
+	volatile unsigned int  RXR1;                 // 0x50 R 0x0000 Receive Register
+	volatile unsigned int  SR1;                  // 0x54 R 0x0000 Status register
+	volatile unsigned int  TIME1;                // 0x58 R/W 0x0000 Timing Control Register    
+	volatile unsigned int  NOTUSING1[10];	
+	volatile unsigned int  IRQSTR;              // 0x80 R 0x00000000 IRQ Status Register    
+}SMUI2C, *PSMUI2C;
+
+typedef struct _I2CSLAVE{
+    volatile unsigned int  PORT;                // 0x80 R/W - Data Access port (TX/RX FIFO)
+    volatile unsigned int  CTL;                 // 0x84 R/W 0x00000000 Control register
+    volatile unsigned int  ADDR;                // 0x88 W 0x00000000 Address register
+    volatile unsigned int  INT;                 // 0x8C W 0x00000000 Interrupt Enable Register
+    volatile unsigned int  STAT;                // 0x90 R 0x00000000 Status Register
+    volatile unsigned int  NOTDEFINE0[2];
+    volatile unsigned int  MBF;                 // 0x9C R/W 0x00000000 Buffer Valid Flag
+    volatile unsigned int  MB0;                 // 0xA0 R/W 0x00000000 Data Buffer 0 (Byte 3 ~ 0)
+    volatile unsigned int  MB1;                 // 0xA4 R/W 0x00000000 Data Buffer 1 (Byte 7 ~ 4)    
+}I2CSLAVE, *PI2CSLAVE;
+
+typedef struct _I2CSTATUS{
+    volatile unsigned int  IRQSTR;              // 0xC0 R 0x00000000 IRQ Status Register    
+}I2CSTATUS, *PI2CSTATUS;
+
+
+/*******************************************************************************
+*	 22. UART Controller Register Define   (Base Addr = 0xF0538000)
+********************************************************************************/
+/*
+#define HwUARTCH0_BASE                              *(volatile unsigned long*)0xF0532000
+#define HwUARTCH1_BASE                              *(volatile unsigned long*)0xF0532100
+#define HwUARTCH2_BASE                              *(volatile unsigned long*)0xF0532200
+#define HwUARTCH3_BASE                              *(volatile unsigned long*)0xF0532300
+#define HwUARTCH4_BASE                              *(volatile unsigned long*)0xF0532400
+#define HwUARTCH5_BASE                              *(volatile unsigned long*)0xF0532500
+#define HwUARTPORTMUX_BASE                          *(volatile unsigned long*)0xF0532600
+*/
+typedef union _UARTREG1{
+    volatile unsigned int  RBR;                 // 0x00 R Unknown Receiver Buffer Register(DLAB = 0)
+    volatile unsigned int  THR;                 // 0x00 W 0x00 Transmitter Holding Register (DLAB=0)
+    volatile unsigned int  DLL;                 // 0x00 R/W 0x00 Divisor Latch (LSB) (DLAB=1)
+}UARTREG1;
+
+typedef union _UARTREG2{
+    volatile unsigned int  IER;                 // 0x04 R/W 0x00 Interrupt Enable Register (DLAB=0)
+    volatile unsigned int  DLM;                 // 0x04 R/W 0x00 Divisor Latch (MSB) (DLAB=1)
+}UARTREG2;
+
+typedef union _UARTREG3{
+    volatile unsigned int  IIR;                 // 0x08 R Unknown Interrupt Ident. Register (DLAB=0)
+    volatile unsigned int  FCR;                 // 0x08 W 0xC0 FIFO Control Register (DLAB=1)
+}UARTREG3;
+
+typedef struct _UART{
+/*
+    volatile unsigned int  RBR;                 // 0x00 R Unknown Receiver Buffer Register(DLAB = 0)
+    volatile unsigned int  THR;                 // 0x00 W 0x00 Transmitter Holding Register (DLAB=0)
+    volatile unsigned int  DLL;                 // 0x00 R/W 0x00 Divisor Latch (LSB) (DLAB=1)
+    volatile unsigned int  IER;                 // 0x04 R/W 0x00 Interrupt Enable Register (DLAB=0)
+    volatile unsigned int  DLM;                 // 0x04 R/W 0x00 Divisor Latch (MSB) (DLAB=1)
+    volatile unsigned int  IIR;                 // 0x08 R Unknown Interrupt Ident. Register (DLAB=0)
+    volatile unsigned int  FCR;                 // 0x08 W 0xC0 FIFO Control Register (DLAB=1)
+*/
+    UARTREG1    REG1;
+    UARTREG2    REG2;
+    UARTREG3    REG3;
+    volatile unsigned int  LCR;                     // 0x0C R/W 0x03 Line Control Register
+    volatile unsigned int  MCR;                     // 0x10 R/W 0x00 MODEM Control Register
+    volatile unsigned int  LSR;                     // 0x14 R Unknown Line Status Register
+    volatile unsigned int  MSR;                     // 0x18 R Unknown MODEM Status Register
+    volatile unsigned int  SCR;                     // 0x1C R/W 0x00 Scratch Register
+    volatile unsigned int  AFT;                     // 0x20 R/W 0x00 AFC Trigger Level Register
+    volatile unsigned int  UCR;                     // 0x24 R/W 0x00 UART Control register
+    volatile unsigned int  NOTDEFINE0[6];
+    volatile unsigned int  SRBR;                    // 0x40 R Unknown Rx Buffer Register
+    volatile unsigned int  STHR;                    // 0x44 W 0x00 Transmitter Holding Register
+    volatile unsigned int  SDLL;                    // 0x48 R/W 0x00 Divisor Latch (LSB)
+    volatile unsigned int  SDLM;                    // 0x4C R/W 0x00 Divisor Latch (MSB)
+    volatile unsigned int  SIER;                    // 0x50 R/W 0x00 Interrupt Enable register
+    volatile unsigned int  NOTDEFINE1[3];
+    volatile unsigned int  SCCR;                    // 0x60 R/W 0x00 Smart Card Control Register
+    volatile unsigned int  STC;                     // 0x64 R/W 0x00 Smart Card TX Count register
+    volatile unsigned int  NOTDEFINE2[6];
+    volatile unsigned int  IRCFG;                   // 0x80 R/W 0x00 IRDA Configuration Register
+}UART, *PUART;
+
+
+typedef struct _UARTPORTMUX{
+    volatile unsigned int  CHSEL;                   // 0x00 R/W 0x3210 Channel Selection Register
+    volatile unsigned int  CHST;                    // 0x00 R 0x0000 Channel Status Register    
+}UARTPORTMUX, *PUARTPORTMUX;
+
+
+/*******************************************************************************
+*	 23. CAN Controller Register Define   (Base Addr = 0xF0531000)
+********************************************************************************/
+//#define HwCAN_BASE                                  0xF0531000
+
+typedef struct _CANCTRL{
+    volatile unsigned int  CANCTRLREG;              //  CAN Control Register 0x00 0x0001
+    volatile unsigned int  CANSTATUS;               //   Status Register 0x04 0x0000
+    volatile unsigned int  CANERRORCNT;             // Error Counter 0x08 0x0000 Read only 
+    volatile unsigned int  CANBITTIMING;            //    Bit Timing Register 0x0C 0x2301 Write enabled by CCE
+    volatile unsigned int  CANINTREG;               //   Interrupt Register 0x10 0x0000 Read only
+    volatile unsigned int  CANTESTREG;              //  Test Register 0x14 0x00 & 0br0000000 1) Write enabled by Test
+    volatile unsigned int  CANBRPEXTREG;            //     Extenstion Register 0x18 0x0000 Write enabled by CCE
+    volatile unsigned int  NOTDEFINE0;              //  __reserved 0x1C 3)
+    volatile unsigned int  CANIF1CMDREQ;            // Command Request 0x20 0x0001
+    volatile unsigned int  CANIF1CMDMSK;            // Command Mask 0x24 0x0000
+    volatile unsigned int  CANIF1MSK1;              // IF1 Mask1 0x28 0xFFFF
+    volatile unsigned int  CANIF1MSK2;              // IF1 Mask2 0x2C 0xFFFF
+    volatile unsigned int  CANIF1ARBIT1;            // IF1 Arbitration 1 0x30 0x0000
+    volatile unsigned int  CANIF1ARBIT2;            // IF1 Arbitration 2 0x34 0x0000
+    volatile unsigned int  CANIF1MSGCTL;            // IF1 Message Control 0x38 0x0000
+    volatile unsigned int  CANIF1DTA1;              // IF1 Data A 1 0x3C 0x0000
+    volatile unsigned int  CANIF1DTA2;              // IF1 Data A 2 0x40 0x0000
+    volatile unsigned int  CANIF1DTB1;              // IF1 Data B 1 0x44 0x0000
+    volatile unsigned int  CANIF1DTB2;              // IF1 Data B 2 0x48 0x0000
+    volatile unsigned int  NOTDEFINE1[13];          // __reserved 0x50-0x7C 3)
+    volatile unsigned int  CANIF2CMDREQ;            // Command Request 0x80 0x0001
+    volatile unsigned int  CANIF2CMDMSK;            // Command Mask 0x84 0x0000
+    volatile unsigned int  CANIF2MSK1;              // IF1 Mask1 0x88 0xFFFF
+    volatile unsigned int  CANIF2MSK2;              // IF1 Mask2 0x8C 0xFFFF
+    volatile unsigned int  CANIF2ARBIT1;            // IF1 Arbitration 1 0x90 0x0000
+    volatile unsigned int  CANIF2ARBIT2;            // IF1 Arbitration 2 0x94 0x0000
+    volatile unsigned int  CANIF2MSGCTL;            // IF1 Message Control 0x98 0x0000
+    volatile unsigned int  CANIF2DTA1;              // IF1 Data A 1 0x9C 0x0000
+    volatile unsigned int  CANIF2DTA2;              // IF1 Data A 2 0xA0 0x0000
+    volatile unsigned int  CANIF2DTB1;              // IF1 Data B 1 0xA4 0x0000
+    volatile unsigned int  CANIF2DTB2;              // IF1 Data B 2 0xA8 0x0000
+    volatile unsigned int  NOTDEFINE2[20];          // __reserved 0xAC-0xFC 3)
+    volatile unsigned int  CANTRSREQ1;              // Transmission Requrest 1 0x100 0x0000 Read only
+    volatile unsigned int  CANTRSREQ2;              // Transmission Request 2 0x104 0x0000 Read only
+    volatile unsigned int  NOTDEFINE3[5];           // __reserved 0x108-0x11C 3)
+    volatile unsigned int  CANNEWDT1;               // New Data 1 0x120 0x0000 Read only
+    volatile unsigned int  CANNEWDT2;               // New Data 2 0x124 0x0000 Read only
+    volatile unsigned int  NOTDEFINE4[5];           // __reserved 0x128-0x13C 3)
+    volatile unsigned int  CANINTPEND1;             // Interrupt Pending 1 0x140 0x0000 Read only
+    volatile unsigned int  CANINTPEND2;             // Interrupt Pending 2 0x144 0x0000 Read only
+    volatile unsigned int  NOTDEFINE5[5];           // __reserved 0x148-0x15C 3)
+    volatile unsigned int  CANMSGVALID1;            // Message Valid 1 0x160 0x0000 Read only
+    volatile unsigned int  CANMSGVALID3;            // Message Valid 2 0x164 0x0000 Read only
+    volatile unsigned int  NOTDEFINE6[5];           // __reserved 0x168-0x17C        
+    
+}CANCTRL, *PCANCTRL;
+
+
+
+
+/*******************************************************************************
+*	 24. DMA Controller Register Define   (Base Addr = 0xF0540000)
+********************************************************************************/
+/*
+#define HwGDMA0_BASE               *(volatile unsigned long *)0xF0540000
+#define HwGDMA1_BASE               *(volatile unsigned long *)0xF0540100
+#define HwGDMA2_BASE               *(volatile unsigned long *)0xF0540200
+#define HwGDMA3_BASE               *(volatile unsigned long *)0xF0540300
+*/
+typedef struct _GDMACTRL{
+    volatile unsigned int  ST_SADR0;                // 0x00 R/W 0x00000000 Start Address of Source Block
+    volatile unsigned int  SPARAM0;                 // 0x04 R/W 0x00000000 Parameter of Source Block
+    volatile unsigned int  NOTDEFINE0;           	 //  0x08      
+    volatile unsigned int  C_SADR0;                 // 0x0C R 0x00000000 Current Address of Source Block
+    volatile unsigned int  ST_DADR0;                // 0x10 R/W 0x00000000 Start Address of Destination Block
+    volatile unsigned int  DPARAM0;              	// 0x14 R/W 0x00000000 Parameter of Destination Block
+    volatile unsigned int  NOTDEFINE1;           	//  0x18      
+    volatile unsigned int  C_DADR0;                 // 0x1C R 0x00000000 Current Address of Destination Block
+    volatile unsigned int  HCOUNT0;                 // 0x20 R/W 0x00000000 Initial and Current Hop count
+    volatile unsigned int  CHCTRL0;                 // 0x24 R/W 0x00000000 Channel Control Register
+    volatile unsigned int  RPTCTRL0;                // 0x28 R/W 0x00000000 Repeat Control Register
+    volatile unsigned int  EXTREQ0;                 // 0x2C R/W 0x00000000 External DMA Request Register
+    volatile unsigned int  ST_SADR1;                // 0x30 R/W 0x00000000 Start Address of Source Block
+    volatile unsigned int  SPARAM1;                 // 0x34 R/W 0x00000000 Parameter of Source Block
+    volatile unsigned int  NOTDEFINE2;           	//  0x38      
+    volatile unsigned int  C_SADR1;                 // 0x3C R 0x00000000 Current Address of Source Block
+    volatile unsigned int  ST_DADR1;                // 0x40 R/W 0x00000000 Start Address of Destination Block
+    volatile unsigned int  DPARAM1;              	// 0x44 R/W 0x00000000 Parameter of Destination Block
+    volatile unsigned int  NOTDEFINE3;           	//  0x48      
+    volatile unsigned int  C_DADR1;                 // 0x4C R 0x00000000 Current Address of Destination Block
+    volatile unsigned int  HCOUNT1;                 // 0x50 R/W 0x00000000 Initial and Current Hop count
+    volatile unsigned int  CHCTRL1;                 // 0x54 R/W 0x00000000 Channel Control Register
+    volatile unsigned int  RPTCTRL1;                // 0x58 R/W 0x00000000 Repeat Control Register
+    volatile unsigned int  EXTREQ1;                 // 0x5C R/W 0x00000000 External DMA Request Register
+    volatile unsigned int  ST_SADR2;                // 0x60 R/W 0x00000000 Start Address of Source Block
+    volatile unsigned int  SPARAM2;                 // 0x64/ R/W 0x00000000 Parameter of Source Block
+    volatile unsigned int  NOTDEFINE4;           	//  0x68      
+    volatile unsigned int  C_SADR2;                 // 0x6C R 0x00000000 Current Address of Source Block
+    volatile unsigned int  ST_DADR2;                // 0x70 R/W 0x00000000 Start Address of Destination Block
+    volatile unsigned int  DPARAM2;              	// 0x74/ R/W 0x00000000 Parameter of Destination Block
+    volatile unsigned int  NOTDEFINE5;           	//  0x78      
+    volatile unsigned int  C_DADR2;                 // 0x7C R 0x00000000 Current Address of Destination Block
+    volatile unsigned int  HCOUNT2;                 // 0x80 R/W 0x00000000 Initial and Current Hop count
+    volatile unsigned int  CHCTRL2;                 // 0x84 R/W 0x00000000 Channel Control Register
+    volatile unsigned int  RPTCTRL2;                // 0x88 R/W 0x00000000 Repeat Control Register
+    volatile unsigned int  EXTREQ2;                 // 0x8C R/W 0x00000000 External DMA Request Register
+    volatile unsigned int  CHCONFIG;                // 0x90 R/W 0x00000000 Channel Configuration Register    
+}GDMACTRL, *PGDMACTRL;
+
+
+typedef struct _GDMANCTRL{
+	volatile unsigned int	ST_SADR;				// 0x000  R/W	Start Address of Source Block
+	volatile unsigned int	SPARAM[2]; 				// 0x004~ R/W	Parameter of Source Block
+	volatile unsigned int	C_SADR; 				// 0x00C  R  	Current Address of Source Block
+	volatile unsigned int	ST_DADR;				// 0x010  R/W	Start Address of Destination Block
+	volatile unsigned int	DPARAM[2];				// 0x014~ R/W	Parameter of Destination Block
+	volatile unsigned int	C_DADR; 				// 0x01C  R  	Current Address of Destination Block
+	volatile unsigned int	HCOUNT; 				// 0x020  R/W	Initial and Current Hop count
+	volatile unsigned int	CHCTRL; 				// 0x024  R/W	Channel Control Register
+	volatile unsigned int	RPTCTRL;				// 0x028  R/W	Repeat Control Register
+	volatile unsigned int	EXTREQ; 				// 0x02C  R/W	External DMA Request Register
+} GDMANCTRL, *PGDMANCTRL;
+
+/*******************************************************************************
+*	 25. Real Time Clock(RTC) Register Define   (Base Addr = 0xF05F2000)
+********************************************************************************/
+//#define HwRTC_BASE                                *(volatile unsigned long*)0xF05F2000
+
+typedef struct _RTC{
+    volatile unsigned int  RTCCON;                  // 0x00 R/W 0x00 RTC Control Register
+    volatile unsigned int  INTCON;                  // 0x04 R/W - RTC Interrupt Control Register
+    volatile unsigned int  RTCALM;                  // 0x08 R/W - RTC Alarm Control Register
+    volatile unsigned int  ALMSEC;                  // 0x0C R/W - Alarm Second Data Register
+    
+    volatile unsigned int  ALMMIN;                  // 0x10 R/W - Alarm Minute Data Register
+    volatile unsigned int  ALMHOUR;                 // 0x14 R/W - Alarm Hour Data Register
+    volatile unsigned int  ALMDATE;                 // 0x18 R/W - Alarm Date Data Register
+    volatile unsigned int  ALMDAY;                  // 0x1C R/W - Alarm Day of Week Data Register
+    
+    volatile unsigned int  ALMMON;                  // 0x20 R/W - Alarm Month Data Register
+    volatile unsigned int  ALMYEAR;                 // 0x24 R/W - Alarm Year Data Register
+    volatile unsigned int  BCDSEC;                  // 0x28 R/W - BCD Second Register
+    volatile unsigned int  BCDMIN;                  // 0x2C R/W - BCD Minute Register
+    
+    volatile unsigned int  BCDHOUR;                 // 0x30 R/W - BCD Hour Register
+    volatile unsigned int  BCDDATE;                 // 0x34 R/W - BCD Date Register
+    volatile unsigned int  BCDDAY;                  // 0x38 R/W - BCD Day of Week Register
+    volatile unsigned int  BCDMON;                  // 0x3C R/W - BCD Month Register
+    
+    volatile unsigned int  BCDYEAR;                 // 0x40 R/W - BCD Year Register
+    volatile unsigned int  RTCIM;                   // 0x44 R/W - RTC Interrupt Mode Register
+    volatile unsigned int  RTCPEND;                 // 0x48 R/W - RTC Interrupt Pending Register
+    volatile unsigned int  RTCSTR;                 // 0x48 R/W - RTC Interrupt Pending Register
+}RTC, *PRTC;
+
+
+/*******************************************************************************
+*	 26. TouchScreen ADC (TSADC) Register Define   (Base Addr = 0xF05F4000)
+********************************************************************************/
+//#define HwTSADC_BASE                                *(volatile unsigned long*)0xF05F4000
+typedef struct _TSADC{
+    volatile unsigned int  ADCCON;                  // 0x00 R/W 0x00003FC4 ADC Control Register
+    volatile unsigned int  ADCTSC;                  // 0x04 R/W 0x00000058 ADC Touch Screen Control Register
+    volatile unsigned int  ADCDLY;                  // 0x08 R/W 0x000000FF ADC Start or Interval Delay Register
+    volatile unsigned int  ADCDAT0;                 // 0x0C R - ADC Conversion Data Register
+    volatile unsigned int  ADCDAT1;                 // 0x10 R - ADC Conversion Data Register
+    volatile unsigned int  ADCUPDN;                 // 0x14 R/W 0x00000000 Stylus Up or Down Interrupt Register
+    volatile unsigned int  ADCCLRINT;               // 0x18 W - Clear ADC Interrrupt
+    volatile unsigned int  NOTDEFINE0;              // 0x1C - - Reserved
+    volatile unsigned int  ADCCLRUPDN;              // 0x20 W - Clear Pen UP/DOWN Interrupt    
+}TSADC, *PTSADC;
+
+
+/*******************************************************************************
+*	 27. Error Correction Code Register Define   (Base Addr = 0xF0539000)
+********************************************************************************/
+//#define HwECC_BASE                                  *(volatile unsigned long*)0xF0539000
+//#define HwECCERRADDR_BASE                           *(volatile unsigned long*)0xF0539050
+
+//=================================================================================
+// ECC Code Register
+//=================================================================================
+typedef struct _ECC{
+	volatile unsigned int	ECC_CTRL;				// 0x000  R/W	ECC Control Register
+	volatile unsigned int	ECC_BASE;				// 0x004  R/W	Base Address for ECC Calculation
+	volatile unsigned int	ECC_MASK;				// 0x008  R/W	Address mask for ECC area.
+	volatile unsigned int	ECC_CLEAR;				// 0x00C  R/W	ECC Clear		
+	volatile unsigned int	ECC_CODE0;				// 0x010  R/W	1st  ECC Code Register
+	volatile unsigned int	ECC_CODE1;				// 0x014  R/W	2nd  ECC Code Register
+	volatile unsigned int	ECC_CODE2;				// 0x018  R/W	3rd  ECC Code Register
+	volatile unsigned int	ECC_CODE3;				// 0x01C  R/W	4th  ECC Code Register
+	volatile unsigned int	ECC_CODE4;				// 0x020  R/W	5th  ECC Code Register
+	volatile unsigned int	ECC_CODE5;				// 0x024  R/W	6th  ECC Code Register
+	volatile unsigned int	ECC_CODE6;				// 0x028  R/W	7th  ECC Code Register
+	volatile unsigned int	ECC_CODE7;				// 0x02C  R/W	8th  ECC Code Register
+	volatile unsigned int	ECC_CODE8;				// 0x030  R/W	9th  ECC Code Register
+	volatile unsigned int	ECC_CODE9;				// 0x034  R/W	10th  ECC Code Register
+	volatile unsigned int	ECC_CODE10; 			// 0x038  R/W	11th  ECC Code Register
+	volatile unsigned int	ECC_CODE11; 			// 0x03C  R/W	12th  ECC Code Register
+	volatile unsigned int	ECC_CODE12; 			// 0x040  R/W	13th  ECC Code Register
+	volatile unsigned int	ECC_CODE13; 			// 0x044  R/W	14th  ECC Code Register
+	volatile unsigned int	ECC_CODE14; 			// 0x048  R/W	15th  ECC Code Register
+	volatile unsigned int	ECC_CODE15; 			// 0x04C  R/W	16th  ECC Code register
+	volatile unsigned int	ECC_EADDR0; 			// 0x050  R  	ECC Error Address Register0
+	volatile unsigned int	ECC_EADDR1; 			// 0x054  R  	ECC Error Address Register1
+	volatile unsigned int	ECC_EADDR2; 			// 0x058  R  	ECC Error Address Register2
+	volatile unsigned int	ECC_EADDR3; 			// 0x05C  R  	ECC Error Address Register3
+	volatile unsigned int	ECC_EADDR4; 			// 0x060  R  	ECC Error Address Register4
+	volatile unsigned int	ECC_EADDR5; 			// 0x064  R  	ECC Error Address Register5
+	volatile unsigned int	ECC_EADDR6; 			// 0x068  R  	ECC Error Address Register6
+	volatile unsigned int	ECC_EADDR7; 			// 0x06C  R  	ECC Error Address Register7
+	volatile unsigned int	ECC_EADDR8; 			// 0x070  R  	ECC Error Address Register8
+	volatile unsigned int	ECC_EADDR9; 			// 0x074  R  	ECC Error Address Register9
+	volatile unsigned int	ECC_EADDR10;			// 0x078  R  	ECC Error Address Register10
+	volatile unsigned int	ECC_EADDR11;			// 0x07C  R  	ECC Error Address Register11
+	volatile unsigned int	ECC_EADDR12;			// 0x080  R  	ECC Error Address Register12
+	volatile unsigned int	ECC_EADDR13;			// 0x084  R  	ECC Error Address Register13
+	volatile unsigned int	ECC_EADDR14;			// 0x088  R  	ECC Error Address Register14
+	volatile unsigned int	ECC_EADDR15;			// 0x08C  R  	ECC Error Address Register15
+	volatile unsigned int	ERRNUM;					// 0x090  R  	ECC Error Number
+	volatile unsigned int	ECC_IREQ;				// 0x094  R/W	ECC Interrupt Control Register	
+}ECC, *PECC;
+
+typedef struct _SLCECC{
+    volatile unsigned int  ECC_CTRL;                // 0x00 R/W 0x00000000 ECC Control Register
+    volatile unsigned int  ECC_BASE;                //  0x04 R/W 0x00000000 Base Address for ECC Calculation
+    volatile unsigned int  ECC_MASK;                //  0x08 R/W 0x00000000 Address mask for ECC area.
+    volatile unsigned int  ECC_CLEAR;               //  0x0C R/W ECC Clear    
+    volatile unsigned int  SECC_0;                  //  0x10 R/W 0x00000000 1st SLC ECC Code Register
+    volatile unsigned int  SECC_1;                  //  0x14 R/W 0x00000000 2nd SLC ECC Code Register
+    volatile unsigned int  SECC_2;                  //  0x18 R/W 0x00000000 3rd SLC ECC Code Register
+    volatile unsigned int  SECC_3;                  //  0x1C R/W 0x00000000 4th SLC ECC Code Register
+    volatile unsigned int  SECC_4;                  //  0x20 R/W 0x00000000 5th SLC ECC Code Register
+    volatile unsigned int  SECC_5;                  //  0x24 R/W 0x00000000 6th SLC ECC Code Register
+    volatile unsigned int  SECC_6;                  //  0x28 R/W 0x00000000 7th SLC ECC Code Register
+    volatile unsigned int  SECC_7;                  //  0x2C R/W 0x00000000 8th SLC ECC Code Register
+    volatile unsigned int  SECC_8;                  //  0x30 R/W 0x00000000 9th SLC ECC Code Register
+    volatile unsigned int  SECC_9;                  //  0x34 R/W 0x00000000 10th SLC ECC Code Register
+    volatile unsigned int  SECC_10;                 //  0x38 R/W 0x00000000 11th SLC ECC Code Register
+    volatile unsigned int  SECC_11;                 //  0x3C R/W 0x00000000 12th SLC ECC Code Register
+    volatile unsigned int  SECC_12;                 //  0x40 R/W 0x00000000 13th SLC ECC Code Register
+    volatile unsigned int  SECC_13;                 //  0x44 R/W 0x00000000 14th SLC ECC Code Register
+    volatile unsigned int  SECC_14;                 //  0x48 R/W 0x00000000 15th SLC ECC Code Register
+    volatile unsigned int  SECC_15;                 //  0x4C R/W 0x00000000 16th SLC ECC Code register
+    
+}SLCECC, *PSLCECC;
+
+typedef struct _MLCECC4{
+    volatile unsigned int  ECC_CTRL;                //  0x00 R/W 0x00000000 ECC Control Register
+    volatile unsigned int  ECC_BASE;                //  0x04 R/W 0x00000000 Base Address for ECC Calculation
+    volatile unsigned int  ECC_MASK;                //  0x08 R/W 0x00000000 Address mask for ECC area.
+    volatile unsigned int  ECC_CLEAR;               //  0x0C R/W ECC Clear
+    volatile unsigned int  MECC4_0;                 //  0x10 R/W 0x00000000 1st MLC ECC4 Code Register
+    volatile unsigned int  MECC4_1;                 //  0x14 R/W 0x00000000 2nd MLC ECC4 Code register
+    
+}MLCECC4, *PMLCECC4;
+
+typedef struct _MLCECC8{
+    volatile unsigned int  ECC_CTRL;                //  0x00 R/W 0x00000000 ECC Control Register
+    volatile unsigned int  ECC_BASE;                //  0x04 R/W 0x00000000 Base Address for ECC Calculation
+    volatile unsigned int  ECC_MASK;                //  0x08 R/W 0x00000000 Address mask for ECC area.
+    volatile unsigned int  ECC_CLEAR;               //  0x0C R/W ECC Clear
+    volatile unsigned int  MECC8_0;                 //  0x10 R/W 0x00000000 1st MLC ECC8 Code Register
+    volatile unsigned int  MECC8_1;                 //  0x14 R/W 0x00000000 2nd MLC ECC8 Code Register
+    volatile unsigned int  MECC8_2;                 //  0x18 R/W 0x00000000 3rd MLC ECC8 Code Register
+    volatile unsigned int  MECC8_3;                 //  0x1C R/W 0x00000000 4th MLC ECC8 Code Register   
+}MLCECC8, *PMLCECC8;
+
+
+typedef struct _MLCECC12{
+    volatile unsigned int  ECC_CTRL;                //  0x00 R/W 0x00000000 ECC Control Register
+    volatile unsigned int  ECC_BASE;                //  0x04 R/W 0x00000000 Base Address for ECC Calculation
+    volatile unsigned int  ECC_MASK;                //  0x08 R/W 0x00000000 Address mask for ECC area.
+    volatile unsigned int  ECC_CLEAR;               //  0x0C R/W ECC Clear    
+    volatile unsigned int  MECC12_0;                //  0x10 R/W 0x00000000 1st MLC ECC12 Code Register
+    volatile unsigned int  MECC12_1;                //  0x14 R/W 0x00000000 2nd MLC ECC12 Code Register
+    volatile unsigned int  MECC12_2;                //  0x18 R/W 0x00000000 3rd MLC ECC12 Code Register
+    volatile unsigned int  MECC12_3;                //  0x1C R/W 0x00000000 4th MLC ECC12 Code Register
+    volatile unsigned int  MECC12_4;                //  0x20 R/W 0x00000000 5th MLC ECC12 Code Register
+}MLCECC12, *PMLCECC12;
+
+
+typedef struct _MLCECC14{
+    volatile unsigned int  ECC_CTRL;                //  0x00 R/W 0x00000000 ECC Control Register
+    volatile unsigned int  ECC_BASE;                //  0x04 R/W 0x00000000 Base Address for ECC Calculation
+    volatile unsigned int  ECC_MASK;                //  0x08 R/W 0x00000000 Address mask for ECC area.
+    volatile unsigned int  ECC_CLEAR;               //  0x0C R/W ECC Clear    
+    volatile unsigned int  MECC14_0;                //  0x10 R/W 0x00000000 1st MLC ECC14 Code Register
+    volatile unsigned int  MECC14_1;                //  0x14 R/W 0x00000000 2nd MLC ECC14 Code Register
+    volatile unsigned int  MECC14_2;                //  0x18 R/W 0x00000000 3rd MLC ECC14 Code Register
+    volatile unsigned int  MECC14_3;                //  0x1C R/W 0x00000000 4th MLC ECC14 Code Register
+    volatile unsigned int  MECC14_4;                //  0x20 R/W 0x00000000 5th MLC ECC14 Code Register
+    volatile unsigned int  MECC14_5;                //  0x24 R/W 0x00000000 6th MLC ECC14 Code Register
+}MLCECC14, *PMLCECC14;
+
+
+typedef struct _MLCECC16{
+    volatile unsigned int  ECC_CTRL;                //  0x00 R/W 0x00000000 ECC Control Register
+    volatile unsigned int  ECC_BASE;                //  0x04 R/W 0x00000000 Base Address for ECC Calculation
+    volatile unsigned int  ECC_MASK;                //  0x08 R/W 0x00000000 Address mask for ECC area.
+    volatile unsigned int  ECC_CLEAR;               //  0x0C R/W ECC Clear    
+    volatile unsigned int  MECC16_0;                //  0x10 R/W 0x00000000 1st MLC ECC16 Code Register
+    volatile unsigned int  MECC16_1;                //  0x14 R/W 0x00000000 2nd MLC ECC16 Code Register
+    volatile unsigned int  MECC16_2;                //  0x18 R/W 0x00000000 3rd MLC ECC16 Code Register
+    volatile unsigned int  MECC16_3;                //  0x1C R/W 0x00000000 4th MLC ECC16 Code Register
+    volatile unsigned int  MECC16_4;                //  0x20 R/W 0x00000000 5th MLC ECC16 Code Register
+    volatile unsigned int  MECC16_5;                //  0x24 R/W 0x00000000 6th MLC ECC16 Code Register
+    volatile unsigned int  MECC16_6;                //  0x28 R/W 0x00000000 7th MLC ECC16 Code Register
+}MLCECC16, *PMLCECC16;
+
+//=================================================================================
+// ECC Error Address Register
+//=================================================================================
+typedef struct _SLCECCERRADDR{
+    volatile unsigned int  SECC_EADDR0;             //  0x50 R 0x00000000 SLC ECC Error Address Register0
+    volatile unsigned int  SECC_EADDR1;             //  0x54 R 0x00000000 SLC ECC Error Address Register1
+    volatile unsigned int  SECC_EADDR2;             //  0x58 R 0x00000000 SLC ECC Error Address Register2
+    volatile unsigned int  SECC_EADDR3;             //  0x5C R 0x00000000 SLC ECC Error Address Register3
+    volatile unsigned int  SECC_EADDR4;             //  0x60 R 0x00000000 SLC ECC Error Address Register4
+    volatile unsigned int  SECC_EADDR5;             //  0x64 R 0x00000000 SLC ECC Error Address Register5
+    volatile unsigned int  SECC_EADDR6;             //  0x68 R 0x00000000 SLC ECC Error Address Register6
+    volatile unsigned int  SECC_EADDR7;             //  0x6C R 0x00000000 SLC ECC Error Address Register7
+    volatile unsigned int  SECC_EADDR8;             //  0x70 R 0x00000000 SLC ECC Error Address Register8
+    volatile unsigned int  SECC_EADDR9;             //  0x74 R 0x00000000 SLC ECC Error Address Register9
+    volatile unsigned int  SECC_EADDR10;            //  0x78 R 0x00000000 SLC ECC Error Address Register10
+    volatile unsigned int  SECC_EADDR11;            //  0x7C R 0x00000000 SLC ECC Error Address Register11
+    volatile unsigned int  SECC_EADDR12;            //  0x80 R 0x00000000 SLC ECC Error Address Register12
+    volatile unsigned int  SECC_EADDR13;            //  0x84 R 0x00000000 SLC ECC Error Address Register13
+    volatile unsigned int  SECC_EADDR14;            //  0x88 R 0x00000000 SLC ECC Error Address Register14
+    volatile unsigned int  SECC_EADDR15;            //  0x8C R 0x00000000 SLC ECC Error Address Register15
+    volatile unsigned int  ERRNUM;                  //  0x90 R 0x00000000 ECC Error Number
+    volatile unsigned int  ECC_IREQ;                //  0x94 R/W 0x00000000 ECC Interrupt Control Register
+}SLCECCERRADDR, *PSLCECCERRADDR;
+
+
+typedef struct _MLCECC4ERRADDR{
+    volatile unsigned int  MECC4_EADDR0;            //  0x50 R 0x00000000 MLC ECC Error Address Register0
+    volatile unsigned int  MECC4_EADDR1;            //  0x54 R 0x00000000 MLC ECC Error Address Register1
+    volatile unsigned int  MECC4_EADDR2;            //  0x58 R 0x00000000 MLC ECC Error Address Register2
+    volatile unsigned int  MECC4_EADDR3;            //  0x5C R 0x00000000 MLC ECC Error Address Register3
+    volatile unsigned int  NOTDEFINE0[12];
+    volatile unsigned int  ERRNUM;                  //  0x90 R 0x00000000 ECC Error Number
+    volatile unsigned int  ECC_IREQ;                //  0x94 R/W 0x00000000 ECC Interrupt Control Register    
+}MLCECC4ERRADDR, *PMLCECC4ERRADDR;
+
+
+typedef struct _MLCECC8ERRADDR{
+    volatile unsigned int  MECC8_EADDR0;            //  0x50 R 0x00000000 MLC ECC8 Error Address Register0
+    volatile unsigned int  MECC8_EADDR1;            //  0x54 R 0x00000000 MLC ECC8 Error Address Register1
+    volatile unsigned int  MECC8_EADDR2;            //  0x58 R 0x00000000 MLC ECC8 Error Address Register2
+    volatile unsigned int  MECC8_EADDR3;            //  0x5C R 0x00000000 MLC ECC8 Error Address Register3
+    volatile unsigned int  MECC8_EADDR4;            //  0x60 R 0x00000000 MLC ECC8 Error Address Register4
+    volatile unsigned int  MECC8_EADDR5;            //  0x64 R 0x00000000 MLC ECC8 Error Address Register5
+    volatile unsigned int  MECC8_EADDR6;            //  0x68 R 0x00000000 MLC ECC8 Error Address Register6
+    volatile unsigned int  MECC8_EADDR7;            //  0x6C R 0x00000000 MLC ECC8 Error Address Register7
+    volatile unsigned int  NOTDEFINE0[8];
+    volatile unsigned int  ERRNUM;                  //  0x90 R 0x00000000 ECC Error Number
+    volatile unsigned int  ECC_IREQ;                //  0x94 R/W 0x00000000 ECC Interrupt Control Register    
+}MLCECC8ERRADDR, *PMLCECC8ERRADDR;
+
+
+typedef struct _MLCECC12ERRADDR{
+    volatile unsigned int  MECC12_EADDR0;           //  0x50 R 0x00000000 MLC ECC12 Error Address Register0
+    volatile unsigned int  MECC12_EADDR1;           //  0x54 R 0x00000000 MLC ECC12 Error Address Register1
+    volatile unsigned int  MECC12_EADDR2;           //  0x58 R 0x00000000 MLC ECC12 Error Address Register2
+    volatile unsigned int  MECC12_EADDR3;           //  0x5C R 0x00000000 MLC ECC12 Error Address Register3
+    volatile unsigned int  MECC12_EADDR4;           //  0x60 R 0x00000000 MLC ECC12 Error Address Register4
+    volatile unsigned int  MECC12_EADDR5;           //  0x64 R 0x00000000 MLC ECC12 Error Address Register5
+    volatile unsigned int  MECC12_EADDR6;           //  0x68 R 0x00000000 MLC ECC12 Error Address Register6
+    volatile unsigned int  MECC12_EADDR7;           //  0x6C R 0x00000000 MLC ECC12 Error Address Register7
+    volatile unsigned int  MECC12_EADDR8;           //  0x70 R 0x00000000 MLC ECC12 Error Address Register8
+    volatile unsigned int  MECC12_EADDR9;           //  0x74 R 0x00000000 MLC ECC12 Error Address Register9
+    volatile unsigned int  MECC12_EADDR10;          //  0x78 R 0x00000000 MLC ECC12 Error Address Register10
+    volatile unsigned int  MECC12_EADDR11;          //  0x7C R 0x00000000 MLC ECC12 Error Address Register11
+    volatile unsigned int  NOTDEFINE0[4];
+    volatile unsigned int  ERRNUM;                  //  0x90 R 0x00000000 ECC Error Number
+    volatile unsigned int  ECC_IREQ;                //  0x94 R/W 0x00000000 ECC Interrupt Control Register    
+}MLCECC12ERRADDR, *PMLCECC12ERRADDR;
+
+typedef struct _MLCECC14ERRADDR{
+    volatile unsigned int  MECC14_EADDR0;           //  0x50 R 0x00000000 MLC ECC14 Error Address Register0
+    volatile unsigned int  MECC14_EADDR1;           //  0x54 R 0x00000000 MLC ECC14 Error Address Register1
+    volatile unsigned int  MECC14_EADDR2;           //  0x58 R 0x00000000 MLC ECC14 Error Address Register2
+    volatile unsigned int  MECC14_EADDR3;           //  0x5C R 0x00000000 MLC ECC14 Error Address Register3
+    volatile unsigned int  MECC14_EADDR4;           //  0x60 R 0x00000000 MLC ECC14 Error Address Register4
+    volatile unsigned int  MECC14_EADDR5;           //  0x64 R 0x00000000 MLC ECC14 Error Address Register5
+    volatile unsigned int  MECC14_EADDR6;           //  0x68 R 0x00000000 MLC ECC14 Error Address Register6
+    volatile unsigned int  MECC14_EADDR7;           //  0x6C R 0x00000000 MLC ECC14 Error Address Register7
+    volatile unsigned int  MECC14_EADDR8;           //  0x70 R 0x00000000 MLC ECC14 Error Address Register8
+    volatile unsigned int  MECC14_EADDR9;           //  0x74 R 0x00000000 MLC ECC14 Error Address Register9
+    volatile unsigned int  MECC14_EADDR10;          //  0x78 R 0x00000000 MLC ECC14 Error Address Register10
+    volatile unsigned int  MECC14_EADDR11;          //  0x7C R 0x00000000 MLC ECC14 Error Address Register11
+    volatile unsigned int  MECC14_EADDR12;          //  0x80 R 0x00000000 MLC ECC14 Error Address Register12
+    volatile unsigned int  MECC14_EADDR13;          //  0x84 R 0x00000000 MLC ECC14 Error Address Register13
+    volatile unsigned int  NOTDEFINE0[2];
+    volatile unsigned int  ERRNUM;                  //  0x90 R 0x00000000 ECC Error Number
+    volatile unsigned int  ECC_IREQ;                //  0x94 R/W 0x00000000 ECC Interrupt Control Register    
+}MLCECC14ERRADDR, *PMLCECC14ERRADDR;
+
+typedef struct _MLCECC16ERRADDR{
+    volatile unsigned int  MECC16_EADDR0;           //  0x50 R 0x00000000 MLC ECC16 Error Address Register0
+    volatile unsigned int  MECC16_EADDR1;           //  0x54 R 0x00000000 MLC ECC16 Error Address Register1
+    volatile unsigned int  MECC16_EADDR2;           //  0x58 R 0x00000000 MLC ECC16 Error Address Register2
+    volatile unsigned int  MECC16_EADDR3;           //  0x5C R 0x00000000 MLC ECC16 Error Address Register3
+    volatile unsigned int  MECC16_EADDR4;           //  0x60 R 0x00000000 MLC ECC16 Error Address Register4
+    volatile unsigned int  MECC16_EADDR5;           //  0x64 R 0x00000000 MLC ECC16 Error Address Register5
+    volatile unsigned int  MECC16_EADDR6;           //  0x68 R 0x00000000 MLC ECC16 Error Address Register6
+    volatile unsigned int  MECC16_EADDR7;           //  0x6C R 0x00000000 MLC ECC16 Error Address Register7
+    volatile unsigned int  MECC16_EADDR8;           //  0x70 R 0x00000000 MLC ECC16 Error Address Register8
+    volatile unsigned int  MECC16_EADDR9;           //  0x74 R 0x00000000 MLC ECC16 Error Address Register9
+    volatile unsigned int  MECC16_EADDR10;          //  0x78 R 0x00000000 MLC ECC16 Error Address Register10
+    volatile unsigned int  MECC16_EADDR11;          //  0x7C R 0x00000000 MLC ECC16 Error Address Register11
+    volatile unsigned int  MECC16_EADDR12;          //  0x80 R 0x00000000 MLC ECC16 Error Address Register12
+    volatile unsigned int  MECC16_EADDR13;          //  0x84 R 0x00000000 MLC ECC16 Error Address Register13
+    volatile unsigned int  MECC16_EADDR14;          //  0x88 R 0x00000000 MLC ECC16 Error Address Register14
+    volatile unsigned int  MECC16_EADDR15;          //  0x8C R 0x00000000 MLC ECC16 Error Address Register15
+    volatile unsigned int  ERRNUM;                  //  0x90 R 0x00000000 ECC Error Number
+    volatile unsigned int  ECC_IREQ;                //  0x94 R/W 0x00000000 ECC Interrupt Control Register    
+}MLCECC16ERRADDR, *PMLCECC16ERRADDR;
+
+
+/*******************************************************************************
+*	 28. Multi-Protocol Encapsulation Forward Error Correction (MPEFEC)
+*    Register Define   (Base Addr = 0xF0510000)
+********************************************************************************/
+//#define HwMPEFEC_BASE                               *(volatile unsigned long*)0xF0510000
+
+typedef struct _MPEFEC{
+    volatile unsigned int  MERR;                    // 0x00 R/W 0x00000000 MPE_FEC Enable/ RESET [1] -> MPE_FEC Enable [0] -> MPE_FEC RESET
+    volatile unsigned int  MSR;                     // 0x04 W 0x00000000 MPE_FEC Start (Auto clear)
+    volatile unsigned int  MFRNR;                   // 0x08 R/W 0x03FF03FF [25:16] active row number -1 : MPE Frame   row MEPFEC    [9:0] MPE Frame  row -1 
+    volatile unsigned int  MDSAR;                   // 0x0C R/W 0x00000000 Datagram    memory start address Memory Data Source Address
+    volatile unsigned int  EFR;                     // 0x10 R/W 0x00000000 Erasure flag   memory start address 
+    volatile unsigned int  MCR;                     // 0x14 R/W 0x00014000 MPE_FEC Control [25] -> 0   [24] -> erasure_on(erasure 1b1) [22:16] -> eras_thres(erasureeras_thres  erasure  ) [15:8] -> stuffing_len [6:0] -> puncturing_len 
+    volatile unsigned int  MSTR;                    // 0x18 R 0x00000000 MPE_FEC Status [1] -> mpe_done [0] -> mpe_over 
+    volatile unsigned int  MIER;                    // 0x1C R 0x00000000 MPE_FEC IRQ Enable [1] -> mpe_done IRQ Enable [0] -> mpe_over IRQ Enable
+    volatile unsigned int  MICR;                    // 0x20 W 0x00000000 MPE_FEC IRQ_clear [1] -> mpe_done IRQ clear [0] -> mpe_over IRQ clear
+    volatile unsigned int  MARR;                    // 0x24 R/W 0x03FF0000 MPE Frame   row  MPEFEC     [9:0] start row number [25:16] end row number
+    volatile unsigned int  ECNT;                    // 0x28 R/W 0x00000000 MPEFECs  Error  
+    volatile unsigned int  NOTDEFINE0[3];           // 0x34-0x3C R/W Reserved    
+}MPEFEC, *PMPEFEC;
+
+
+/*******************************************************************************
+*	 29. IOBUS Configuration Register Define   (Base Addr = 0xF05F5000)
+********************************************************************************/
+//#define HwIOBUSCFG_BASE                             *(volatile unsigned long*)0xF05F5000
+
+typedef struct _IOBUSCFG{
+    volatile unsigned int  USBOTG;                  // 0x00 Refer to USB OTG Configuration Register (OTGCR) in 15.2 register Description for USB 2.0 OTG Controller USB OTG Configuration register (OTGCR)USB OTG Configuration Register (OTGCR)USB OTG Configuration register (OTGCR)USB OTG Configuration Register (OTGCR)USB OTG Configuration Register (OTGCR).
+    volatile unsigned int  USB11H;                  // 0x04 Refer to USB 1.1 Host Configuration Register (USB11H) in 14.2 register Description for USB 1.1 Host Controller & Transceiver
+    volatile unsigned int  IOBAPB;                  // 0x08 IOBUS APB wait counter register
+    volatile unsigned int  STORAGE;                 // 0x0C Storage Device Configuration Register
+    volatile unsigned int  HCLKEN0;                 // 0x10 IOBUS AHB clock enable Register 0
+    volatile unsigned int  HCLKEN1;                 // 0x14 IOBUS AHB clock enable Register 1
+    volatile unsigned int  HCLKMEN;                 // 0x18 DMA AHB clock mask enable Register
+    volatile unsigned int  NOTDEFINE0;              // 0x1C Reserved
+    volatile unsigned int  HRSTEN0;                 // 0x20 IOBUS AHB Hreset Control register 0
+    volatile unsigned int  HRSTEN1;                 // 0x24 IOBUS AHB Hreset Control register 1
+    volatile unsigned int  USBOTG0;                 // 0x28 Refer to USB PHY Configuration Register0 (UPCR0) in 15.2 register Description for USB 2.0 OTG Controller
+    volatile unsigned int  USBOTG1;                 // 0x2C Refer to USB PHY Configuration Register1 (UPCR1) in 15.2 register Description for USB 2.0 OTG Controller
+    volatile unsigned int  USBOTG2;                 // 0x30 Refer to USB PHY Configuration Register2 (UPCR2) in 15.2 register Description for USB 2.0 OTG Controller
+    volatile unsigned int  USBOTG3;                 // 0x34 Refer to USB PHY Configuration Register3 (UPCR3) in 15.2 register Description for USB 2.0 OTG Controller
+    volatile unsigned int  IO_A2X;                  // 0x38 IOBUS AHB2AXI Control Register    
+}IOBUSCFG, *PIOBUSCFG;
+
+
+
+/************************************************************************
+*	Channel 0 Memory Controller Register Define	(Base Addr = 0xF1000000)
+************************************************************************/
+//#define	HwEMC_BASE					*(volatile unsigned long *)0xF1000000	// External Memory Controller Base Register
+typedef struct _EMC{
+	volatile unsigned int	SDCFG;				//           0x00  R/W  0x6A484C00  SDRAM Configuration Register 
+	volatile unsigned int	SDFSM;				//           0x04  R  0x00000000  SDRAM FSM Status Register 
+	volatile unsigned int	MCFG;				//           0x08  R/W  0x01000042  Miscellaneous Configuration Register 
+	volatile unsigned int	TST;				//           0x0C  W  0x00000000  Should not write to this ? its for TEST 
+	volatile unsigned int	CSCFG0;				//           0x10  R/W  0x468AC809 External Chip Select 0 Config. Register   (CSN_CS0) 
+	volatile unsigned int	NOTDEFINE0[2];		//           0x14  R/W  0x508AD01A  Reserved -  0x18  R/W  0x608AD03A  Reserved 
+	volatile unsigned int	CSCFG3;				//           0x1C  R/W  0x728AD01A External Chip Select 3 Config. Register (CSN_NOR) 
+	volatile unsigned int	CLKCFG;				//           0x20  R/W  0x00000A05 Memory Controller  Version  &  Periodic Clock  Enable Count Register 
+	volatile unsigned int	SDCMD;				//           0x24  R/W  -  SDRAM Command Write Register 
+	volatile unsigned int	SDCFG1;				//           0x28  R/W  0xFFFFFFFF  Extra SDRAM Configuration Register 
+}EMC, *PEMC;
+
+
+/*******************************************************************************
+*	 TCC8900_DataSheet_PART 6 DDI_BUS_V0.00 Dec.11 2008
+********************************************************************************/
+/************************************************************************
+*	4. LCD INTERFACE Register Define				(Base Addr = 0xF0200000)
+************************************************************************/
+//#define	HwLCDC0_BASE							*(volatile unsigned long *)0xF0200000	// LCDC0 Control Base Register
+//#define	HwLCDC1_BASE							*(volatile unsigned long *)0xF0204000	// LCDC1 Control Base Register
+
+typedef struct _LCDC{
+	volatile unsigned int	LCTRL;				//   0x00  R/W  0x00000000  LCD Control Register 
+	volatile unsigned int	LBC;				//   0x04  R/W  0x00000000  LCD Background Color Register 
+	volatile unsigned int	LCLKDIV;			//   0x08  R/W  0x00000000  LCD Clock Divider Register 
+	volatile unsigned int	LHTIME1;			//   0x0C  R/W  0x00000000  LCD Horizontal Timing Register 1 
+	volatile unsigned int	LHTIME2;			//   0x10  R/W  0x00000000  LCD Horizontal Timing Register 2 
+	volatile unsigned int	LVTIME1;			//   0x14  R/W  0x00000000  LCD Vertical Timing Register 1 
+	volatile unsigned int	LVTIME2;			//   0x18  R/W  0x00000000  LCD Vertical Timing Register 2 
+	volatile unsigned int	LVTIME3;			//   0x1C  R/W  0x00000000  LCD Vertical Timing Register 3 
+	volatile unsigned int	LVTIME4;			//   0x20  R/W  0x00000000  LCD Vertical Timing Register 4 
+	volatile unsigned int	LLUTR;				//   0x24  R/W  0x00000000  LCD Lookup Register for Red 
+	volatile unsigned int	LLUTG;				//   0x28  R/W  0x00000000  LCD Lookup Register for Green 
+	volatile unsigned int	LLUTB;				//   0x2C  R/W  0x00000000  LCD Lookup Register for Blue 
+	volatile unsigned int	LDP7L;				//   0x30  R/W  0x4d2b3401  LCD Modulo 7 Dithering Pattern (low) 
+	volatile unsigned int	LDP7H;				//   0x34  R/W  0x0000003f  LCD Modulo 7 Dithering Pattern (high) 
+	volatile unsigned int	LDP5;				//   0x38  R/W  0x1d0b0610  LCD Modulo 5 Dithering Pattern Register 
+	volatile unsigned int	LDP4;				//   0x3C  R/W  0x00000768  LCD Modulo 4 Dithering Pattern Register 
+	volatile unsigned int	LDP3;				//   0x40  R/W  0x00000034  LCD 3-bit Dithering Pattern Register 
+	volatile unsigned int	LCP1;				//   0x44  R/W  0x000000ff  LCD Clipping Register1 
+	volatile unsigned int	LCP2;				//   0x48  R/W  0x000000ff  LCD Clipping Register2 
+	volatile unsigned int	LDS;				//   0x4C  R/W  0x00000000  LCD Display Size Register 
+	volatile unsigned int	LSTATUS;			//   0x50  R/CLR  0x00000000  LCD Status Register 
+	volatile unsigned int	LIM;				//   0x54  R/W  0x0000001f  LCD Interrupt Register. 
+	volatile unsigned int	LGR0;				//   0x58  R/W  0x00000000  LCD Gamma Correction Register 0 for Red Color 
+	volatile unsigned int	LGR1;				//   0x5C  R/W  0x00000000  LCD Gamma Correction Register 1 for Red Color 
+	volatile unsigned int	LGG0;				//   0x60  R/W  0x00000000  LCD Gamma Correction Register 0 for Green Color 
+	volatile unsigned int	LGG1;				//   0x64  R/W  0x00000000  LCD Gamma Correction Register 1 for Green Color 
+	volatile unsigned int	LGB0;				//   0x68  R/W  0x00000000  LCD Gamma Correction Register 0 for Blue Color 
+	volatile unsigned int	LGB1;				//   0x6C  R/W  0x00000000  LCD Gamma Correction Register 1 for Blue Color 
+	volatile unsigned int	LENH;				//   0x70  R/W  0x00000020  LCD Color Enhancement Register 
+	volatile unsigned int	NOTDEFINE0;		    // 	 0x74
+	volatile unsigned int	LI0C;				//   0x78  R/W  0x00000000  LCD Image 0 Control Register 
+	volatile unsigned int	LI0P;				//   0x7C  R/W  0x00000000  LCD Image 0 Position Register 
+	volatile unsigned int	LI0S;				//   0x80  R/W  0x00000000  LCD Image 0 Size Register 
+	volatile unsigned int	LI0BA0;				//   0x84  R/W  0x00000000  LCD Image 0 Base Address 0 Register. 
+	volatile unsigned int	LI0CA;				//   0x88  R/W  0x00000000  LCD Image 0 Current Address Register. 
+	volatile unsigned int	LI0BA1;				//   0x8C  R/W  0x00000000  LCD Image 0 Base Address 1 Register 
+	volatile unsigned int	LI0BA2;				//   0x90  R/W  0x00000000  LCD Image 0 Base Address 2 Register 
+	volatile unsigned int	LI0O;				//   0x94  R/W  0x00000000  LCD Image 0 Offset Register 
+	volatile unsigned int	LI0SR;				//   0x98  R/W  0x00000000  LCD Image 0 Scale ratio 
+	volatile unsigned int	LI0A;				//   0x9C  R/W  0x00000000  LCD Image 0 Alpha Configuration Register 
+	volatile unsigned int	LI0KR;				//   0xA0  R/W  0x00000000  LCD Image 0 Keying Register for RED or LUMA(Y) 
+	volatile unsigned int	LI0KG;				//   0xA4  R/W  0x00000000  LCD Image 0 Keying Register for BLUE or CHROMA(Cb) 
+	volatile unsigned int	LI0KB;				//   0xA8  R/W  0x00000000  LCD Image 0 Keying Register for GREEN or CHROMA(Cr) 
+	volatile unsigned int	LI0EN;				//   0xAC  R/W  0x00000000  LCD Image 0 Enhancement Register 
+	volatile unsigned int	LI1C;				//   0xB0  R/W  0x00000000  LCD Image 1 Control Register 
+	volatile unsigned int	LI1P;				//   0xB4  R/W  0x00000000  LCD Image 1 Position Register 
+	volatile unsigned int	LI1S;				//   0xB8  R/W  0x00000000  LCD Image 1 Size Register 
+	volatile unsigned int	LI1BA0;				//   0xBC  R/W  0x00000000  LCD Image 1 Base Address 0 Register. 
+	volatile unsigned int	LI1CA;				//   0xC0  R/W  0x00000000  LCD Image 1 Current Address Register. 
+	volatile unsigned int	LI1BA1;				//   0xC4  R/W  0x00000000  Not Used 
+	volatile unsigned int	LI1BA2;				//   0xC8  R/W  0x00000000  Not Used 
+	volatile unsigned int	LI1O;				//   0xCC  R/W  0x00000000  LCD Image 1 Offset Register 
+	volatile unsigned int	LI1SR;				//   0xD0  R/W  0x00000000  LCD Image 1 Scale ratio- 
+	volatile unsigned int	LI1A;				//   0xD4  R/W  0x00000000  LCD Image 1 Alpha Configuration Register 
+	volatile unsigned int	LI1KR;				//   0xD8  R/W  0x00000000  LCD Image 1 Keying Register for RED or LUMA(Y) 
+	volatile unsigned int	LI1KG;				//   0xDC  R/W  0x00000000  LCD Image 1 Keying Register for BLUE or CHROMA(Cb) 
+	volatile unsigned int	LI1KB;				//   0xE0  R/W  0x00000000  LCD Image 1 Keying Register for GREEN or CHROMA(Cr) 
+	volatile unsigned int	LI1EN;				//   0xE4  R/W  0x00000000  LCD Image 1 Enhancement Register 
+	volatile unsigned int	LI2C;				//   0xE8  R/W  0x00000000  LCD Image 2 Control Register 
+	volatile unsigned int	LI2P;				//   0xEC  R/W  0x00000000  LCD Image 2 Position Register 
+	volatile unsigned int	LI2S;				//   0xF0  R/W  0x00000000  LCD Image 2 Size Register 
+	volatile unsigned int	LI2BA0;				//   0xF4  R/W  0x00000000  LCD Image 2 Base Address 0 Register. 
+	volatile unsigned int	LI2CA;				//   0xF8  R/W  0x00000000  LCD Image 2 Current Address Register. 
+	volatile unsigned int	LI2BA1;				//   0xFC  R/W  0x00000000  Not Used 
+	volatile unsigned int	LI2BA2;				//   0x100  R/W  0x00000000  Not Used 
+	volatile unsigned int	LI2O;				//   0x104  R/W  0x00000000  LCD Image 2 Offset Register 
+	volatile unsigned int	LI2SR;				//   0x108  R/W  0x00000000  LCD Image 2 Scale ratio 
+	volatile unsigned int	LI2A;				//   0x10C  R/W  0x00000000  LCD Image 2 Alpha Register 
+	volatile unsigned int	LI2KR;				//   0x110  R/W  0x00000000  LCD Image 2 Keying Register for RED or LUMA(Y) 
+	volatile unsigned int	LI2KG;				//   0x114  R/W  0x00000000  LCD Image 2 Keying Register for BLUE or CHROMA(Cb) 
+	volatile unsigned int	LI2KB;				//   0x118  R/W  0x00000000  LCD Image 2 Keying Register for GREEN or CHROMA(Cr) 
+	volatile unsigned int	LI2EN;				//   0x11C  R/W  0x00000000  LCD Image 2 Enhancement Register 
+	volatile unsigned int	LUTIDX;				//   0x120      Lookup Table index Register 
+
+}LCDC, *PLCDC;
+
+
+//#define HwLCDLUT0_BASE							*(volatile unsigned long *)0xF0200400	// LCD LUT 0 Base Register
+//#define HwLCDLUT1_BASE							*(volatile unsigned long *)0xF0204400	// LCD LUT 1 Base Register
+
+typedef struct _LUT_TYPE{
+	volatile unsigned char	BCr;	// [7:0]
+	volatile unsigned char	GCb;	// [15:8]
+	volatile unsigned char	RY;		// [23:16]
+	volatile unsigned char	dummy;	// [31:24]]
+}LUT_TYPE, *PLUT_TYPE;
+
+typedef struct _LCDLUT{
+	volatile LUT_TYPE	LUTDAT[256];			// 0x400 ~ 0x7FF
+}LCDLUT, *PLCDLUT;
+
+
+/************************************************************************
+*	5. LCD System Interface Register Define		(Base Addr = 0xF020C400)
+************************************************************************/
+//#define	HwLCDSI_BASE							*(volatile unsigned long *)0xF020C400	// LCDSI Base Register
+
+typedef struct _LCDSI0{
+	volatile unsigned int		CTRL0;				// 0x400 R/W 0x00000000 Control register for LCDSI
+}LCDSI0, *PLCDSI0;
+
+typedef struct _LCDSI1{
+	volatile unsigned int		CTRL1;				// 0x800 R/W 0xA0229011 Control register for nCS0 when RS=0(for core access)
+	volatile unsigned int		CTRL2;				// 0x804 R/W 0xA0429021 Control register for nCS0 when RS=1(for core access)
+	volatile unsigned int		CTRL3;				// 0x808 R/W 0xA0129009 Control register for nCS1 when RS=0(for core access)
+	volatile unsigned int		CTRL4;				// 0x80C R/W 0xA0229011 Control register for nCS1 when RS=1(for core access)
+	volatile unsigned int		CS0RS0;				// 0x810 R/W -if this register is read or written, reading or writing operations are generated on nCS0 while RS = 0.
+	volatile unsigned int		NOTDEFINE0;			// 0x814
+	volatile unsigned int		CS0RS1;				// 0x818 R/W -if this register is read or written, reading or writing operations are generated on nCS0 while RS = 1.
+	volatile unsigned int		NOTDEFINE1;			// 0x81C
+	volatile unsigned int		CS1RS0;				// 0x820 R/W -if this register is read or written, reading or writing operations are generated on nCS1 while RS = 0.
+	volatile unsigned int		NOTDEFINE2;			// 0x824
+	volatile unsigned int		CS1RS1;				// 0x828 R/W -if this register is read or written, reading or writing operations are generated on nCS1 while RS = 1.
+	volatile unsigned int		NOTDEFINE3;			// 0x82C
+	volatile unsigned int		CTRL5;				// 0x830 R/W 0xA0229011 Control register for nCS0 when RS=0(for lcd access)
+	volatile unsigned int		CTRL6;				// 0x834 R/W 0xA0429021 Control register for nCS0 when RS=1(for lcd access)
+	volatile unsigned int		CTRL7;				// 0x838 R/W 0xA0129009 Control register for nCS1 when RS=0(for lcd access)
+	volatile unsigned int		CTRL8;				// 0x83C R/W 0xA0229011 Control register for nCS1 when RS=1(for lcd access)
+}LCDSI1, *PLCDSI1;
+
+
+/***********************************************************************
+*	6. Memory to Memory Scaler Register Define	(Base Addr = 0xF0210000/0xF0220000)
+************************************************************************/
+//#define HwM2MSCALER1_BASE                       *(volatile unsigned long *)0xF0251000
+//#define HwM2MSCALER1_BASE                       *(volatile unsigned long *)0xF0252000
+typedef struct _M2MSCALER{
+	volatile unsigned int	SRCBASEY;				// 0x000 R/W 0x00000000 Scaler source base address for Y
+	volatile unsigned int	SRCBASEU;				// 0x004 R/W 0x00000000 Scaler source base address for U (Cb)
+	volatile unsigned int	SRCBASEV;				// 0x008 R/W 0x00000000 Scaler source base address for V (Cr)
+	volatile unsigned int	SRCSIZE;				// 0x00c R/W 0x00000000 Source image size register
+	volatile unsigned int	SRCOFF; 				// 0x010 R/W 0x00000000 Source image line offset register
+	volatile unsigned int	SRCCFG;	    			// 0x014 R/W 0x00000000 Source image configuration register
+	volatile unsigned int	NOTDEFINE0[2];
+	volatile unsigned int	DSTBASEY;				// 0x020 R/W 0x00000000 Scaler destination base address for Y
+	volatile unsigned int	DSTBASEU;				// 0x024 R/W 0x00000000 Scaler destination base address for U (Cb)
+	volatile unsigned int	DSTBASEV;				// 0x028 R/W 0x00000000 Scaler destination base address for V (Cr)
+	volatile unsigned int	DSTSIZE;				// 0x02c R/W 0x00000000 Destination image size register
+	volatile unsigned int	DSTOFF;		    		// 0x030 R/W 0x00000000 Destination image line offset register
+	volatile unsigned int	DSTCFG;			    	// 0x034 R/W 0x00000000 Destination image configuration register
+	volatile unsigned int	NOTDEFINE1[2];
+	volatile unsigned int	MSCINF;		    		// 0x040 R/W 0x00000000 Scaling information register
+	volatile unsigned int	MSCCTR;		    		// 0x044 R/W 0x00000000 Scaler control register
+	volatile unsigned int	MSCSTR;		    		// 0x048 R/W 0x00000000 Scaler status register
+	volatile unsigned int	HSTROBE;				// 0x04C R/W 0x000A0002 Horizontal Strobe Timing Control Register
+	volatile unsigned int	DSTRMCNT;				// 0x050 R/W 0x00000000 Destination Rolling Status Register
+	volatile unsigned int	CRCNT;					// 0x054 R   0x00000000 Destination Rolling Status Register
+	volatile unsigned int	CLIP0;					// 0x058 R/W 0x00000000 RGB-to-YCbCr Clipping Configuration Register 0
+	volatile unsigned int	CLIP1;					// 0x05C R/W 0x000000FF RGB-to-YCbCr Clipping Configuration Register 1
+	volatile unsigned int	VSTROBE;				// 0x060 R/W 0x0000000A Vertical Strobe Timing Control Register
+}M2MSCALER, *PM2MSCALER;
+
+
+/************************************************************************
+*	7. NTSC/PAL ENCODER Composite Output Register Define (Base Addr = 0xF9000000)
+************************************************************************/
+//#define	HwTVE_BASE								*(volatile unsigned long *)0xF9000000	// TV Encoder Base Register
+typedef struct _NTSCPAL{
+	volatile unsigned int 	STATA;					//0x00
+	volatile unsigned int	ECMDA;					//0x04
+	volatile unsigned int	ECMDB;					//0x08
+	volatile unsigned int	GLK;					//0x0C
+	volatile unsigned int	SCH;					//0x10
+	volatile unsigned int	HUE;					//0x14
+	volatile unsigned int	SAT;					//0x18
+	volatile unsigned int	CONT;					//0x1C
+	volatile unsigned int	BRIGHT;					//0x20
+	volatile unsigned int	FSC_ADJM;				//0x24
+	volatile unsigned int	FSC_ADJL;				//0x28
+	volatile unsigned int	ECMDC;					//0x2C
+	volatile unsigned int	NOTDEFINE0[4];			//0x30, 34, 38, 3C
+	volatile unsigned int	DACSEL;					//0x40
+	volatile unsigned int	NOTDEFINE1[3];			//0x44, 48, 4C
+	volatile unsigned int	DACPD;					//0x50
+	volatile unsigned int	NOTDEFINE2[11];			//0x54, 58, 5C, 60, 64, 68, 6C, 70, 74, 78, 7C
+	volatile unsigned int	ICNTL;					//0x80
+	volatile unsigned int	HVOFFST;				//0x84
+	volatile unsigned int	HOFFST;					//0x88
+	volatile unsigned int	VOFFST;					//0x8C
+	volatile unsigned int	HSVSO;					//0x90
+	volatile unsigned int	HSOE;					//0x94
+	volatile unsigned int	HSOB;					//0x98
+	volatile unsigned int	VSOB;					//0x9C
+	volatile unsigned int	VSOE;					//0xA0
+}NTSCPAL, *PNTSCPAL;
+
+typedef struct _NTSCPALOP{
+	volatile unsigned int	VENCON;					//0xF9080000
+	volatile unsigned int	VENCIF;					//0xF9080004
+}NTSCPALOP, *PNTSCPALOP;
+
+/************************************************************************
+*	8. HDMI Register Define				(Base Addr = 0xF0254000)
+************************************************************************/
+//#define HwHDMICTRL_BASE							*(volatile unsigned long *)0xF0254000	//Controller register base address 
+typedef struct _HDMICTRL{
+	volatile unsigned int	INTC_CON;				//  0x0000  R/W  Interrupt Control Register  0x00 
+	volatile unsigned int	INTC_FLAG;				//  0x0004  R/W  Interrupt Flag Register  0x00 
+	volatile unsigned int	AESKEY_VALID;			//  0x0008  R  aeskey_valid Register  0x00 
+	volatile unsigned int	HPD;					//  0x000C  R  HPD signal  0x00 
+}HDMICTRL, *PHDMICTRL;
+
+//#define HwHDMICORE_BASE  							*(volatile unsigned long *)0xF0255000  
+typedef struct _HDMICORE{
+	volatile unsigned int	HDMI_CON_0;			//  0x0000  R/W  HDMI system control register 0  0x00 
+	volatile unsigned int	HDMI_CON_1;			//  0x0004  R/W  HDMI system control register 1  0x00 
+	volatile unsigned int	HDMI_CON_2;			//  0x0008  R/W  HDMI system control register 2  0x00 
+	volatile unsigned int	NOTDEFINE_;			//	0x000C
+	volatile unsigned int	STATUS;					//  0x0010  R/W  HDMI system status register  0x00 
+	volatile unsigned int	PHY_STATUS;			//  0x0014  R  PHY status register  0x00 
+	volatile unsigned int	NOTDEFINE0[2];			//	0x18, 0x1C
+	volatile unsigned int	STATUS_EN;				//  0x0020  R/W  HDMI system status enable register  0x00 
+	volatile unsigned int	NOTDEFINE1[3];			//	0x24, 0x28, 0x2C
+	volatile unsigned int	HPD;					//  0x0030  R/W  HPD control register  0x00 
+	volatile unsigned int	NOTDEFINE2[3];			//	0x34, 0x38, 0x3C
+	volatile unsigned int	MODE_SEL;				//  0x0040  R/W  HDMI/DVI mode selection  0x00 
+	volatile unsigned int	ENC_EN;					//  0x0044  R/W  HDCP encryption enable register  0x00 
+	volatile unsigned int	NOTDEFINE3[2];			//	0x48, 0x4C
+//Video Related Registers 
+	volatile unsigned int	BLUE_SCREEN_0;			//  0x0050  R/W  Pixel values for blue screen  0x00 
+	volatile unsigned int	BLUE_SCREEN_1;			//  0x0054  R/W  Pixel values for blue screen 0x00   
+	volatile unsigned int	BLUE_SCREEN_2;			//  0x0058  R/W  Pixel values for blue screen 0x00   
+	volatile unsigned int	NOTDEFINE4;			//	0x5C
+	volatile unsigned int	HDMI_YMAX;				//  0x0060  R/W  Maximum Y (or "R,G,B)" pixel value 0x00   
+	volatile unsigned int	HDMI_YMIN;				//  0x0064  R/W  Minimum Y (or "R,G,B)" pixel value 0x00   
+	volatile unsigned int	HDMI_CMAX;				//  0x0068  R/W  Maximum Cb/Cr pixel value  0x00 
+	volatile unsigned int	HDMI_CMIN;				//  0x006C  R/W  Minimum Cb/Cr pixel value  0x00 
+	volatile unsigned int	NOTDEFINE5[12];		//	0x70~0x9C
+	volatile unsigned int	H_BLANK[2];				//  0x00A0 ,0x00A4 R/W  Horizontal blanking setting  0x00 
+	volatile unsigned int	NOTDEFINE6[2];		//	0xA8 0xAC
+	volatile unsigned int	V_BLANK[3];				//  0x00B0,0x00B4, 0x00B8 R/W  Vertical blanking setting  0x00 
+	volatile unsigned int	NOTDEFINE7[2];		//	0xB8 0xBC
+	volatile unsigned int	H_V_LINE[3];			//  0x00C0,0x00C4, 0x00C8 R/W  Horizontal line & vertical line setting  0x00 
+	volatile unsigned int	NOTDEFINE8[6];		//	0xCC, 0xD0, 0xD4, 0xD8, 0xDC, 0xE0
+	volatile unsigned int	VSYNC_POL;				//  0x00E4  R/W  Vertical sync polarity control register  0x00 
+	volatile unsigned int	INT_PRO_MODE ;			// 0x00E8  R/W  Interlace/Progressive control register  0x00 
+	volatile unsigned int	NOTDEFINE9[9];		//	0xEC, 0xF0, 0xF4, 0xF8, 0xFC, 0x100, 0x104, 0x108, 0x10C
+	volatile unsigned int	V_BLANK_F[3];			//  0x0110,0x0114, 0x0118 R/W  Vertical blanking setting for bottom field  0x00 
+	volatile unsigned int	NOTDEFINE10;			//	0x011C
+	volatile unsigned int	H_SYNC_GEN[3] ;		// 0x0120,0x0124 ,0x0128 R/W  Horizontal sync generation setting  0x00 
+	volatile unsigned int	NOTDEFINE11;			//	0x012C
+	volatile unsigned int	V_SYNC_GEN1[3];		//  0x0130,0x0134,0x0138  R/W  Vertical sync generation for top field or frame  0x01 
+	volatile unsigned int	NOTDEFINE12;			//	0x013C
+	volatile unsigned int	V_SYNC_GEN2[3];		//  0x0140,0x0144,0x0148  R/W Vertical sync generation for bottom field   - vertical position 0x01 
+	volatile unsigned int	NOTDEFINE13;			//	0x014C
+	volatile unsigned int	V_SYNC_GEN3[3];		//  0x0150,0x0154,0x0158  R/W Vertical sync generation for bottom field   - horizontal position 0x01 
+	volatile unsigned int	NOTDEFINE14;			//	0x015C
+//Audio Related Registers 
+	volatile unsigned int	ASP_CON;				//  0x0160  R/W  ASP packet control register  0x00 
+	volatile unsigned int	ASP_SP_FLAT;			//  0x0164  R/W  ASP packet sp_flat bit control  0x00 
+	volatile unsigned int	NOTDEFINE15[2];		//	0x0168,0x016C
+	volatile unsigned int	ASP_CHCFG[4];			//  0x0170,0x0174,0x0178,0x017C  R/W  ASP audio channel configuration  0x04 
+	volatile unsigned int	ACR_CON;				//  0x0180  R/W  ACR packet control register  0x00 
+	volatile unsigned int	ACR_MCTS[3];			//  0x0184,0x0188,0x018C  R/W  Measured CTS value  0x01 
+	volatile unsigned int	ACR_CTS[3];				//  0x0190,0x0194,0x0198  R/W  CTS value for fixed CTS transmission mode.  0xe8 
+	volatile unsigned int	NOTDEFINE16;		//	0x019C
+	volatile unsigned int	ACR_N[3];				//  0x01A0,0x01A4,0x01A8  R/W  N value for ACR packet  0xe8 
+	volatile unsigned int	NOTDEFINE17;		//	0x01AC
+	volatile unsigned int	ACR_LSB2;				//  0x01B0  R/W  Alternate LSB for fixed CTS transmission mode  0x00 
+	volatile unsigned int	ACR_TXCNT;				//  0x01B4  R/W  Number of ACR packet transmission per frame  0x1f 
+	volatile unsigned int	ACR_TXINTERVAL;		//  0x01B8  R/W  Interval for ACR packet transmission  0x63 
+	volatile unsigned int	ACR_CTS_OFFSET;		//  0x01BC  R/W  CTS offset for measured CTS mode  0x00 
+//Packet Related Registers 
+	volatile unsigned int	GCP_CON ;				// 0x01C0  R/W  ACR packet control register  0x00 
+	volatile unsigned int	NOTDEFINE18[3];	//	0x01C4,0x01C8,0x01CC,
+	volatile unsigned int	GCP_BYTE[3];			//  0x01D0,0x01D4,0x01D8  R/W  GCP packet body  0x00 
+	volatile unsigned int	NOTDEFINE19;		//	0x01DC,
+	volatile unsigned int	ACP_CON;				//  0x01E0  R/W  ACP packet control register  0x00 
+	volatile unsigned int	NOTDEFINE20[3];		//	0x01E4,0x01E8,0x01EC,
+	volatile unsigned int	ACP_TYPE;				//  0x01F0  R/W  ACP packet header  0x00 
+	volatile unsigned int	NOTDEFINE21[3];		//	0x01F4,0x01F8,0x01FC,
+	volatile unsigned int	ACP_DATA[17];			// 0x0200~0x0240  R/W ACP packet body 0x00 
+	volatile unsigned int	NOTDEFINE22[3];		//	0x0244,0x0248,0x024C,
+	volatile unsigned int	ISRC_CON;				//  0x0250  R/W  ACR packet control register  0x00 
+	volatile unsigned int	NOTDEFINE23[4];		//	0x0254,0x0258,0x025C,0x0260
+	volatile unsigned int	ISRC1_HEADER1;			//  0x0264  R/W  ISCR1 packet header  0x00 
+	volatile unsigned int	NOTDEFINE24[2];		//	0x0268,0x026C,
+	volatile unsigned int	ISRC1_DATA[16];		//	0x0270~0x02AC R/W ISRC1 packet body 0x00 
+	volatile unsigned int	ISRC2_DATA[16];		//	0x02B0~0x02EC R/W ISRC2 packet body 0x00 
+	volatile unsigned int	NOTDEFINE25[4];		//	0x02F0,0x02F4,0x02F8,0x2FC
+
+	volatile unsigned int	AVI_CON;				//  0x0300  R/W  AVI packet control register  0x00 
+	volatile unsigned int	NOTDEFINE26[3];		//	0x0304,0x0308,0x030c
+	volatile unsigned int	AVI_CHECK_SUM;			//  0x0310  R/W  AVI packet checksum  0x00 
+	volatile unsigned int	NOTDEFINE27[3];		//	0x0314,0x0318,0x031c
+	volatile unsigned int	AVI_BYTE[13];			//	0x0320~0x0350 R/W AVI packet body 0x00 
+	volatile unsigned int	NOTDEFINE28[3];		//	0x0354,0x0358,0x035c
+	volatile unsigned int	AUI_CON;				//  0x0360  R/W  AUI packet control register  0x00 
+	volatile unsigned int	NOTDEFINE29[3];		//	0x0364,0x0368,0x036c
+	volatile unsigned int	AUI_CHECK_SUM;			//  0x0370  R/W  AUI packet checksum  0x00 
+	volatile unsigned int	NOTDEFINE30[3];		//	0x0374,0x0378,0x037c
+	volatile unsigned int	AUI_BYTE[5];			// 0x0380~0x0390  R/W AUI packet body 0x00 
+	volatile unsigned int	NOTDEFINE31[3];		//	0x0394,0x0398,0x039c
+
+	volatile unsigned int	MPG_CON;				//  0x03A0  R/W  ACR packet control register  0x00 
+	volatile unsigned int	NOTDEFINE32[3];		//	0x03A4,0x03A8,0x03Ac
+	volatile unsigned int	MPG_CHECK_SUM;			//  0x03B0  R/W  MPG packet checksum  0x00 
+	volatile unsigned int	NOTDEFINE33[3];		//	0x03B4,0x03B8,0x03Bc
+
+	volatile unsigned int	MPG_BYTE[5];			// 0x03C0~0x03D0  R/W MPG packet body 0x00 
+	volatile unsigned int	NOTDEFINE34[11];		//	0x03D4,0x03D8,0x03Dc
+													//	0x03E0,
+													//  0x03F
+	volatile unsigned int	SPD_CON;				//  0x0400  R/W  SPD packet control register  0x00 
+	volatile unsigned int	NOTDEFINE35[3];		//	0x0344,0x0348,0x034c
+	volatile unsigned int	SPD_HEADER0;			//  0x0410~  R/W  SPD packet header  0x00 
+	volatile unsigned int	SPD_HEADER1;			//  0x0414  R/W  SPD packet header  0x00 
+	volatile unsigned int	SPD_HEADER2;			//  0x0418  R/W  SPD packet header  0x00 
+	volatile unsigned int	NOTDEFINE36;		//	0x041C
+	volatile unsigned int	SPD_DATA[28];			//	 0x0420~0x048C R/W SPD packet body 0x00 
+
+//HDCP Related Registes 
+	volatile unsigned int	GAMUT_CON;				//  0x0500  R/W  GAMUT packet control register  0x00 
+	volatile unsigned int	GAMUT_HEADER0;			//  0x0504  R/W  GAMUT packet header  0x00 
+	volatile unsigned int	GAMUT_HEADER1;			//  0x0508  R/W  GAMUT packet header  0x00 
+	volatile unsigned int	GAMUT_HEADER2;			//  0x050C  R/W  GAMUT packet header  0x00 
+	volatile unsigned int	GAMUT_DATA[28];		// 0x0510~0x057C R/W  GAMUT packet body  0x00 
+	volatile unsigned int	NOTDEFINE37[16];		//	0x0580~
+													// 	0x0590,~
+													//	0x05A0~
+													//	0x05B0~
+	volatile unsigned int	DC_CONTROL;			//  0x05C0  R/W  Deep Color Control Register  0x00 
+	volatile unsigned int	VIDEO_PATTERN_GEN;		//  0x05C4  R/W  Video Pattern Generation Register  0x00 
+	volatile unsigned int	HPD_GEN ;				// 0x05C8  R/W  HPD Duration value register  0x01 
+	volatile unsigned int	NOTDEFINE38[113];		//	0x05CC
+													// 	0x05D0,
+													//	0x05E0
+													//	0x05F0
+
+	volatile unsigned int	HDCP_SHA1[20];			//	0x0600~0x064C R/W  SHA-1 value from repeater  0x00 
+	volatile unsigned int	HDCP_KSV_LIST[5];		// 0x0650~0x0660 R/W  KSV list from repeater  0x00 
+
+	volatile unsigned int	HDCP_KSV_LIST_CON;		//  0x0664  R/W  KSV list control  0x00 
+	volatile unsigned int	NOTDEFINE39[2];		//	0x0668,0x066C
+	volatile unsigned int	HDCP_SHA_RESULT;		//  0x0670  R/W  SHA-1 checking result register  0x00 
+	volatile unsigned int	NOTDEFINE40[3];		//	0x0674,0x0678,0x067c
+	volatile unsigned int	HDCP_CTRL1;			//  0x0680  R/W  HDCP control register1  0x00 
+	volatile unsigned int	HDCP_CTRL2;			//  0x0684  R/W  HDCP control register2  0x00 
+	volatile unsigned int	NOTDEFINE41[2];		//	0x0688,0x068c
+	volatile unsigned int	HDCP_CHECK_RESULT;		//  0x0690  R/W  Ri and Pj value checking result  0x00 
+	volatile unsigned int	NOTDEFINE42[3];		//	0x0394,0x0398,0x039c
+	volatile unsigned int	HDCP_BKSV[5];			// 0x06A0~0x06B0 R/W  KSV of Rx  0x00
+	volatile unsigned int	NOTDEFINE43[3];		//	0x06B4,0x06B8,0x06Bc
+ 
+	volatile unsigned int	HDCP_AKSV[5];			//0x06C0~ 0x06D0 R/W  KSV of Tx  0x00 
+	volatile unsigned int	NOTDEFINE44[3];		//	0x06D4,0x06D8,0x06Dc
+	volatile unsigned int	HDCP_An[8];				// 0x06E0~ 0x06FC R/W  An value  0x00 
+	volatile unsigned int	HDCP_BCAPS;			//  0x0700  R/W  BCAPS from Rx  0x00 
+	volatile unsigned int	NOTDEFINE45[3];		//	0x0704,0x0708,0x070c
+	volatile unsigned int	HDCP_BSTATUS_0;		//  0x0710  R/W  BSTATUS from Rx  0x00 
+	volatile unsigned int	HDCP_BSTATUS_1;		//  0x0714  R/W  BSTATUS from Rx  0x00 
+	volatile unsigned int	NOTDEFINE46[10];		//	0x0718,0x071c
+													//	0x0720,
+													//	0x0730
+	volatile unsigned int	HDCP_Ri_0;				//  0x0740  R/W  Ri value of Tx  0x00 
+	volatile unsigned int	HDCP_Ri_1;				//  0x0744  R/W  Ri value of Tx  0x00 
+	volatile unsigned int	NOTDEFINE47[13];		//	0x0748
+													//	0x0750,
+													//	0x0760,
+													//	0x0770
+	volatile unsigned int	HDCP_I2C_INT;			//  0x0780  R/W  I2C interrupt flag  0x00 
+	volatile unsigned int	NOTDEFINE48[3];		//	0x0784,0x0788,0x078c
+	
+	volatile unsigned int	HDCP_AN_INT;			//  0x0790  R/W  An value ready interrupt flag  0x00 
+	volatile unsigned int	NOTDEFINE49[3];		//	0x0794,0x0798,0x079c
+	
+	volatile unsigned int	HDCP_WATCGDOG_INT;		//  0x07A0  R/W  Wachdog interrupt flag  0x00 
+	volatile unsigned int	NOTDEFINE50[3];		//	0x07A4,0x07A8,0x07Ac
+	
+	volatile unsigned int	HDCP_Ri_INT;			//  0x07B0  R/W  Ri value update interrupt flag  0x00 
+	volatile unsigned int	NOTDEFINE51[7];		//	0x07B4,0x07B8,0x07Bc
+													//	0x07C0,
+	volatile unsigned int	HDCP_Ri_Compare_0;		//  0x07D0  R/W  HDCP Ri Interrupt Frame number index register 0  0x80 
+	volatile unsigned int	HDCP_Ri_Compare_1;		//  0x07D4  R/W  HDCP Ri Interrupt Frame number index register 1  0x7f 
+	volatile unsigned int	NOTDEFINE52[2];		//	0x07D8,0x07Dc
+	
+	volatile unsigned int	HDCP_Frame_Count;		// 0x07E0  R  Current value of the frame count index in the hardware 0x00 
+}HDMICORE, *PHDMICORE;
+
+//AES register base address 
+//fHDMIAES_BASE  							*(volatile unsigned long *)0xF0256000  //AES register base address 
+typedef struct _HDMIAES{
+	volatile unsigned int	AES_START;				//   0x0000  R/W  AES_START  0x00 
+	volatile unsigned int	NOTDEFINE0[7];			//	0x0004,0x0008,0x000c
+													//	0x0010,
+	volatile unsigned int	AES_DATA_SIZE_L;		//   0x0020  R/W  AES_DATA_SIZE_L  0x20 
+	volatile unsigned int	AES_DATA_SIZE_H;		//   0x0024  R/W  AES_DATA_SIZE_H  0x01 
+	volatile unsigned int	NOTDEFINE1[6];			//	0x0028,0x002c
+													//	0x0030
+	volatile unsigned int	AES_DATA;				//   0x0040  W  AES_DATA  - 
+}HDMIAES, *PHDMIAES;
+
+//SPDIF Receiver register base address 
+//#define HwHDMISPDIF_BASE  							*(volatile unsigned long *)0xF0257000  
+typedef struct _HDMISPDIF{
+	volatile unsigned int	SPDIFIN_CLK_CTRL;				//  0x0000  R/W  SPDIFIN Clock Control Register  0x02 
+	volatile unsigned int	SPDIFIN_OP_CTRL;				//  0x0004  R/W  SPDIFIN Operation Control Register 1  0x00 
+	volatile unsigned int	SPDIFIN_IRQ_MASK;				//  0x0008  R/W  SPDIFIN Interrupt Request Mask Register  0x00 
+	volatile unsigned int	SPDIFIN_IRQ_STATUS;			//  0x000C  R/W  SPDIFIN Interrupt Request Status Register  0x00 
+	volatile unsigned int	SPDIFIN_CONFIG_1;				//  0x0010  R/W  SPDIFIN Configuration Register 1  0x02 
+	volatile unsigned int	SPDIFIN_CONFIG_2;				//  0x0014  R/W  SPDIFIN Configuration Register 2  0x00 
+	volatile unsigned int	NOTDEFINE0[2];					//	0x0018 0x001C -  Reserved  - 
+	volatile unsigned int	SPDIFIN_USER_VALUE_1;			//  0x0020  R  SPDIFIN User Value Register 1  0x00 
+	volatile unsigned int	SPDIFIN_USER_VALUE_2;			//  0x0024  R  SPDIFIN User Value Register 2  0x00 
+	volatile unsigned int	SPDIFIN_USER_VALUE_3;			//  0x0028  R  SPDIFIN User Value Register 3  0x00 
+	volatile unsigned int	SPDIFIN_USER_VALUE_4;			//  0x002C  R  SPDIFIN User Value Register 4  0x00 
+	volatile unsigned int	SPDIFIN_CH_STATUS_0_1;		//  0x0030  R  SPDIFIN Channel Status Register 0-1  0x00 
+	volatile unsigned int	SPDIFIN_CH_STATUS_0_2;		//  0x0034  R  SPDIFIN Channel Status Register 0-2  0x00 
+	volatile unsigned int	SPDIFIN_CH_STATUS_0_3;		//  0x0038  R  SPDIFIN Channel Status Register 0-3  0x00 
+	volatile unsigned int	SPDIFIN_CH_STATUS_0_4;		//  0x003C  R  SPDIFIN Channel Status Register 0-4  0x00 
+	volatile unsigned int	SPDIFIN_CH_STATUS_1;			//  0x0040  R  SPDIFIN Channel Status Register 1  0x00 
+	volatile unsigned int	NOTDEFINE1;					//  0x0044 -  Reserved  - 
+	volatile unsigned int	SPDIFIN_FRAME_PERIOD_1;		//  0x0048  R  SPDIFIN Frame Period Register 1  0x00 
+	volatile unsigned int	SPDIFIN_FRAME_PERIOD_2;		//  0x004C  R  SPDIFIN Frame Period Register 2  0x00 
+	volatile unsigned int	SPDIFIN_Pc_INFO_1;				//  0x0050  R  SPDIFIN Pc Info Register 1  0x00 
+	volatile unsigned int	SPDIFIN_Pc_INFO_2;				//  0x0054  R  SPDIFIN Pc Info Register 2  0x00 
+	volatile unsigned int	SPDIFIN_Pd_INFO_1;				//  0x0058  R  SPDIFIN Pd Info Register 1  0x00 
+	volatile unsigned int	SPDIFIN_Pd_INFO_2;				//  0x005C  R  SPDIFIN Pd Info Register 2  0x00 
+	volatile unsigned int	SPDIFIN_DATA_BUF_0_1;			//  0x0060  R  SPDIFIN Data Buffer Register 0_1  0x00 
+	volatile unsigned int	SPDIFIN_DATA_BUF_0_2;			//  0x0064  R  SPDIFIN Data Buffer Register 0_2  0x00 
+	volatile unsigned int	SPDIFIN_DATA_BUF_0_3;			//  0x0068  R  SPDIFIN Data Buffer Register 0_3  0x00 
+	volatile unsigned int	SPDIFIN_USER_BUF_0;			//  0x006C  R  SPDIFIN User Buffer Register 0  0x00 
+	volatile unsigned int	SPDIFIN_DATA_BUF_1_1;			//  0x0070  R  SPDIFIN Data Buffer Register 1_1  0x00 
+	volatile unsigned int	SPDIFIN_DATA_BUF_1_2;			//  0x0074  R  SPDIFIN Data Buffer Register 1_2  0x00 
+	volatile unsigned int	SPDIFIN_DATA_BUF_1_3;			//  0x0078  R  SPDIFIN Data Buffer Register 1_3  0x00 
+	volatile unsigned int	SPDIFIN_USER_BUF_1;			//  0x007C  R  SPDIFIN User Buffer Register 1  0x00 
+}HDMISPDIF, *PHDMISPDIF;
+
+//I2S Receiver register base address 
+//#define HwHDMII2S_BASE  							*(volatile unsigned long *)0xF0258000  
+typedef struct _HDMII2S{
+	volatile unsigned int	I2S_CLK_CON;					//  0x0000  R/W  I2S Clock Enable Register  0x00 
+	volatile unsigned int	I2S_CON_1;						//  0x0004  R/W  I2S Control Register 1  0x00 
+	volatile unsigned int	I2S_CON_2;						//  0x0008  R/W  I2S Control Register 2  0x00 
+	volatile unsigned int	I2S_PIN_SEL_0;					//  0x000C  R/W  I2S Input Pin Selection Register 0  0x77 
+	volatile unsigned int	I2S_PIN_SEL_1;					//  0x0010  R/W  I2S Input Pin Selection Register 1  0x77 
+	volatile unsigned int	I2S_PIN_SEL_2;					//  0x0014  R/W  I2S Input Pin Selection Register 2  0x77 
+	volatile unsigned int	I2S_PIN_SEL_3;					//  0x0018  R/W  I2S Input Pin Selection Register 3  0x07 
+	volatile unsigned int	I2S_DSD_CON;					//  0x001C  R/W  I2S DSD Control Register  0x02 
+	volatile unsigned int	I2S_MUX_CON;					//  0x0020  R/W  I2S In/Mux Control Register  0x60 
+	volatile unsigned int	I2S_CH_ST_CON;					//  0x0024  R/W  I2S Channel Status Control Register  0x00 
+	volatile unsigned int	I2S_CH_ST_0;					//  0x0028  R/W  I2S Channel Status Block 0  0x00 
+	volatile unsigned int	I2S_CH_ST_1;					//  0x002C  R/W  I2S Channel Status Block 1  0x00 
+	volatile unsigned int	I2S_CH_ST_2;					//  0x0030  R/W  I2S Channel Status Block 2  0x00 
+	volatile unsigned int	I2S_CH_ST_3;					//  0x0034  R/W  I2S Channel Status Block 3  0x00 
+	volatile unsigned int	I2S_CH_ST_4;					//  0x0038  R/W  I2S Channel Status Block 4  0x00 
+	volatile unsigned int	I2S_CH_ST_SH_0;				//  0x003C  R  I2S Channel Status Block Shadow Register 0  0x00 
+	volatile unsigned int	I2S_CH_ST_SH_1;				//  0x0040  R  I2S Channel Status Block Shadow Register 1  0x00 
+	volatile unsigned int	I2S_CH_ST_SH_2;				//  0x0044  R  I2S Channel Status Block Shadow Register 2  0x00 
+	volatile unsigned int	I2S_CH_ST_SH_3;				// 	0x0048  R  I2S Channel Status Block Shadow Register 3  0x00 
+	volatile unsigned int	I2S_CH_ST_SH_4;				//  0x004C  R  I2S Channel Status Block Shadow Register 4  0x00 
+	volatile unsigned int	I2S_VD_DATA;					//  0x0050  R/W  I2S Audio Sample Validity Register  0x00 
+	volatile unsigned int	I2S_MUX_CH;					//  0x0054  R/W  I2S Channel Enable Register  0x03 
+	volatile unsigned int	I2S_MUX_CUV;					//  0x0058  R/W  I2S CUV Enable Register  0x03 
+	volatile unsigned int	I2S_IRQ_MASK;					//  0x005C  R/W  I2S Interrupt Request Mask Register  0x03 
+	volatile unsigned int	I2S_IRQ_STATUS;				//  0x0060  R/W  I2S Interrupt Request Status Register  0x00 
+	volatile unsigned int	I2S_CH0_L_0;					//  0x0064  R  I2S PCM Output Data Register  0x00 
+	volatile unsigned int	I2S_CH0_L_1;					//  0x0068  R  I2S PCM Output Data Register  0x00 
+	volatile unsigned int	I2S_CH0_L_2;					//  0x006C  R  I2S PCM Output Data Register  0x00 
+	volatile unsigned int	I2S_CH0_L_3;					//  0x0070  R  I2S PCM Output Data Register  0x00 
+	volatile unsigned int	I2S_CH0_R_0;					//  0x0074  R  I2S PCM Output Data Register  0x00 
+	volatile unsigned int	I2S_CH0_R_1;					//  0x0078  R  I2S PCM Output Data Register  0x00 
+	volatile unsigned int	I2S_CH0_R_2;					//  0x007C  R  I2S PCM Output Data Register  0x00 
+	volatile unsigned int	I2S_CH0_R_3;					//  0x0080  R  I2S PCM Output Data Register  0x00 
+	volatile unsigned int	I2S_CH1_L_0;					//  0x0084  R  I2S PCM Output Data Register  0x00 
+	volatile unsigned int	I2S_CH1_L_1;					//  0x0088  R  I2S PCM Output Data Register  0x00 
+	volatile unsigned int	I2S_CH1_L_2;					//  0x008C  R  I2S PCM Output Data Register  0x00 
+	volatile unsigned int	I2S_CH1_L_3;					//  0x0090  R  I2S PCM Output Data Register  0x00 
+	volatile unsigned int	I2S_CH1_R_0;					//  0x0094  R  I2S PCM Output Data Register  0x00 
+	volatile unsigned int	I2S_CH1_R_1;					//  0x0098  R  I2S PCM Output Data Register  0x00 
+	volatile unsigned int	I2S_CH1_R_2;					//  0x009C  R  I2S PCM Output Data Register  0x00 
+	volatile unsigned int	I2S_CH1_R_3;					//  0x00A0  R  I2S PCM Output Data Register  0x00 
+	volatile unsigned int	I2S_CH2_L_0;					//  0x00A4  R  I2S PCM Output Data Register  0x00 
+	volatile unsigned int	I2S_CH2_L_1;					//  0x00A8  R  I2S PCM Output Data Register  0x00 
+	volatile unsigned int	I2S_CH2_L_2;					//  0x00AC  R  I2S PCM Output Data Register  0x00 
+	volatile unsigned int	I2S_CH2_L_3;					//  0x00B0  R  I2S PCM Output Data Register  0x00 
+	volatile unsigned int	I2S_CH2_R_0;					//  0x00B4  R  I2S PCM Output Data Register  0x00 
+	volatile unsigned int	I2S_CH2_R_1;					//  0x00B8  R  I2S PCM Output Data Register  0x00 
+	volatile unsigned int	I2S_CH2_R_2;					//  0x00BC  R  I2S PCM Output Data Register  0x00 
+	volatile unsigned int	I2S_Ch2_R_3;					//  0x00C0  R  I2S PCM Output Data Register  0x00 
+	volatile unsigned int	I2S_CH3_L_0;					//  0x00C4  R  I2S PCM Output Data Register  0x00 
+	volatile unsigned int	I2S_CH3_L_1;					//  0x00C8  R  I2S PCM Output Data Register  0x00 
+	volatile unsigned int	I2S_CH3_L_2;					//  0x00CC  R  I2S PCM Output Data Register  0x00 
+	volatile unsigned int	I2S_CH3_R_0;					//  0x00D0  R  I2S PCM Output Data Register  0x00 
+	volatile unsigned int	I2S_CH3_R_1;					//  0x00D4  R  I2S PCM Output Data Register  0x00 
+	volatile unsigned int	I2S_CH3_R_2;					//  0x00D8  R  I2S PCM Output Data Register  0x00 
+	volatile unsigned int	I2S_CUV_L_R;					//  0x00DC  R  I2S CUV Output Data Register  0x00 
+}HDMII2S, *PHDMII2S;
+
+ //CEC register base address 					
+//#define HwHDMICEC_BASE  							*(volatile unsigned long *)0xF0259000 
+typedef struct _HDMICEC{
+	volatile unsigned int	CEC_TX_STATUS_0;					//  0x0000  R  CEC Tx status register 0.  0x00 
+	volatile unsigned int	CEC_TX_STATUS_1;					//  0x0004  R  CEC Tx status register 1. Number of blocks transferred. 0x00 
+	volatile unsigned int	CEC_RX_STATUS_0;					//  0x0008  R  CEC Rx status register 0.  0x00 
+	volatile unsigned int	CEC_RX_STATUS_1;					//  0x000C  R  CEC Rx status register 1. Number of blocks received. 0x00 
+	volatile unsigned int	CEC_INTR_MASK;						//  0x0010  R/W  CEC interrupt mask register  0x00 
+	volatile unsigned int	CEC_INTR_CLEAR;					//  0x0014  R/W  CEC interrupt clear register  0x00 
+	volatile unsigned int	NOTDEFINE0[2];						//	0x0018 0x001C -  Reserved  - 
+	volatile unsigned int	CEC_LOGIC_ADDR;					//  0x0020  R/W  HDMI Tx logical address register  0x0F 
+	volatile unsigned int	NOTDEFINE1[3];					//	0x0024 0x0028, 0x002C -  Reserved  - 
+	volatile unsigned int	CEC_DIVISOR_0;						//  0x0030  R/W  Clock divisor for 0.05ms period count ([7:0] of 32-bit) 0x00 
+	volatile unsigned int	CEC_DIVISOR_1;						//  0x0034  R/W  Clock divisor for 0.05ms period count ([15:8] of 32-bit) 0x00 
+	volatile unsigned int	CEC_DIVISOR_2;						//  0x0038  R/W  Clock divisor for 0.05ms period count ([23:16] of 32-bit) 0x00 
+	volatile unsigned int	CEC_DIVISOR_3;						//  0x003C  R/W  Clock divisor for 0.05ms period count ([31:24] of 32-bit) 0x00 
+//CEC Tx related Registers 
+	volatile unsigned int	CEC_TX_CTRL;						//  0x0040  R/W  CEC Tx control register  0x10 
+	volatile unsigned int	CEC_TX_BYTE_NUM;					//  0x0044  R/W  Number of blocks in a message to be transferred  0x00 
+	volatile unsigned int	NOTDEFINE2[6];						//	0x0048 0x004C -  Reserved  - 
+																//  0x0050
+	volatile unsigned int	CEC_TX_STATUS_2;					//  0x0060  R  CEC Tx status register 2  0x00 
+	volatile unsigned int	CEC_TX_STATUS_3;					//  0x0064  R  CEC Tx status register 3  0x00 
+	volatile unsigned int	NOTDEFINE3[6];						//	0x0068 0x006C -  Reserved  - 
+																//  0x0070
+	volatile unsigned int	NOTDEFINE4[3];					//	0x0074 0x0078, 0x007C -  Reserved  - 
+	volatile unsigned int	CEC_TX_BUFFER[16];					// 0x0080 ~ 0x00BC R/W  Byte #0 ~ #15 of CEC message to be transferred. (#0 is transferred 1st ) 0x00 
+//CEC Rx related Registers 
+	volatile unsigned int	CEC_RX_CTRL;						//  0x00C0  R/W  CEC Rx control register  0x00 
+	volatile unsigned int	NOTDEFINE5[7];						//	0x00C4 0x00C8, 0x00CC -  Reserved  - 
+																//  0x00D0
+	volatile unsigned int	CEC_RX_STATUS_2;					//  0x00E0  R  CEC Rx status register 2  0x00 
+	volatile unsigned int	CEC_RX_STATUS_3;					//  0x00E4  R  CEC Rx status register 3eived 1st )  0x00 
+	volatile unsigned int	NOTDEFINE6[2];						//	0x00E8, 0x00EC -  Reserved  - 
+	volatile unsigned int	CEC_RX_BUFFER[16];					// 0x0100 ~ 0x013C R  Byte #0 ~ #15 of CEC message received (#0 is received 1st ) 0x00 
+}HDMICEC, *PHDMICEC;
+
+/***********************************************************************
+*	 9-1. Camera Interface Register Define			(Base Addr = 0xF0230000)
+************************************************************************/
+//#define	HwCIF_BASE								*(volatile unsigned long *)0xF0230000	// CIF Base Register
+typedef struct _CIF{
+	volatile unsigned int	ICPCR1;					// 0x00 W/R 0x00000000 Input Image Color/Pattern Configuration Register 1
+	volatile unsigned int	CCIR656FCR1;			// 0x04 W/R 0x06ff0000 CCIR656 Format Configuration Register 1
+	volatile unsigned int	CCIR656FCR2;			// 0x08 W/R 0x010b CCIR656 Format Configuration Register 2
+	volatile unsigned int	IIS;					// 0x0C W/R 0x00000000 Input Image Size
+	volatile unsigned int	IIW1;					// 0x10 W/R 0x00000000 Input Image Windowing 1
+	volatile unsigned int	IIW2;					// 0x14 W/R 0x00000000 Input Image Windowing 2
+	volatile unsigned int	CDCR1;					// 0x18 W/R 0x0003 DMA Configuration Register 1
+	volatile unsigned int	CDCR2;					// 0x1C W/R 0x00000000 DMA Configuration Register 2
+	volatile unsigned int	CDCR3;					// 0x20 W/R 0x00000000 DMA Configuration Register 3
+	volatile unsigned int	CDCR4;					// 0x24 W/R 0x00000000 DMA Configuration Register 4
+	volatile unsigned int	CDCR5;					// 0x28 W/R 0x00000000 DMA Configuration Register 5
+	volatile unsigned int	CDCR6;					// 0x2C W/R 0x00000000 DMA Configuration Register 6
+	volatile unsigned int	CDCR7;					// 0x30 W/R 0x00000000 DMA Configuration Register 7
+	volatile unsigned int	CDCR8;					// 0x34 W/R 0x00000000 DMA Configuration Register 7
+	volatile unsigned int	FIFOSTATE;				// 0x38 R 0x00000000 FIFO Status Register
+	volatile unsigned int	CIRQ;					// 0x3C W/R 0x00000000 Interrupt & Status register
+	volatile unsigned int	OCTRL1;					// 0x40 W/R 0x37000000 Overlay Control 1
+	volatile unsigned int	OCTRL2;					// 0x44 W/R 0x00000000 Overlay Control 2
+	volatile unsigned int	OCTRL3;					// 0x48 W/R 0x00000000 Overlay Control 3
+	volatile unsigned int	OCTRL4;					// 0x4C W/R 0x00000000 Overlay Control 4
+	volatile unsigned int	OIS;					// 0x50 W/R 0x00000000 Overlay Image Size
+	volatile unsigned int	OIW1;					// 0x54 W/R 0x00000000 Overlay Image Windowing 1
+	volatile unsigned int	OIW2;					// 0x58 W/R 0x00000000 Overlay Image Windowing 2
+	volatile unsigned int	COBA;					// 0x5C W/R 0x00000000 Overlay Base Address
+	volatile unsigned int	COBO;					// 0x60 W/R 0x00000000 Overlay Base Address Offset 
+	volatile unsigned int	CDS;					// 0x64 W/R 0x00000000 Camera Down Scaler
+	volatile unsigned int	CCM1;					// 0x68 W/R 0x00000000 Capture Mode Configuration 1
+	volatile unsigned int	CCM2;					// 0x6C W/R 0x00000000 Capture Mode Configuration 2
+	volatile unsigned int	CESA;					// 0x70 W/R 0x00000000 Point Encoding Start Address
+	volatile unsigned int	CR2Y;					// 0x74  W/R 0x00000000 RGB2YUV Format converter Configuration
+	volatile unsigned int	CCYA;					// 0x78 R - Current Y Address
+	volatile unsigned int	CCUA;					// 0x7C R - Current U Address
+	volatile unsigned int	CCVA;					// 0x80 R - Current V Address
+	volatile unsigned int	CCLC;					// 0x84 R Current Line count
+}CIF, *PCIF;
+
+/***********************************************************************
+*	 9-2. Effect Register Define			(Base Addr = 0xF0230100)
+************************************************************************/
+//#define	HwCEM_BASE    								*(volatile unsigned long *)0xF0230100  //W/R  0x00000000  Effect mode register 
+
+typedef struct _EFFECT{
+	volatile unsigned int	CEM;					// 0x00 W/R 0x00000000 Effect mode register
+	volatile unsigned int	CSUV;				// 0x04 W/R 0x00000000 Sepia UV setting
+	volatile unsigned int	CCS;					// 0x08 W/R 0x00000000 Color selection register
+	volatile unsigned int	CHFC;				// 0x0C W/R 0x00000000 H-filter coefficent0
+	volatile unsigned int	CST;				// 0x10 W/R 0x00000000 Sketch threshold register
+	volatile unsigned int	CCT;				// 0x14 W/R 0x00000000 Clamp threshold register
+	volatile unsigned int	CBR;					// 0x18 W/R 0x00000000 BIAS register
+	volatile unsigned int	CEIS;					// 0x1C W/R 0x00000000 Image size register
+	volatile unsigned int	NOTDEFINE0[8];			// 0x20, 24, 28, 2C, 30, 34, 38, 3C,
+	volatile unsigned int	INPATH_CTRL;			// 0x40 W/R 0x00000000 Inpath configuration
+	volatile unsigned int	CISA1;				// 0x44 W/R 0x00000000 Source address in Y channel
+	volatile unsigned int	CISA2;				// 0x48 W/R 0x00000000 Source address in U channel
+	volatile unsigned int	CISA3;				// 0x4C W/R 0x00000000 Source address in V channel
+	volatile unsigned int	CISS;				// 0x50 W/R 0x00000000 Source image size
+	volatile unsigned int	CISO;				// 0x54 W/R 0x00000000 Source image offset
+	volatile unsigned int	CIDS;				// 0x58 W/R 0x00000000 Destination image size
+	volatile unsigned int	CIS;				// 0x5C W/R 0x00000000 Target scale	
+}EFFECT, *PEFFECT;
+
+/***********************************************************************
+*	 9-3. Scaler Register Define			(Base Addr = 0xF0230200)
+************************************************************************/
+//#define	HwCSC_BASE    								*(volatile unsigned long *)0xF0230200  //W/R  0x00000000  Scaler configuration 
+typedef struct _CIFSCALER{
+	volatile unsigned int	CSC;				//  0x00  W/R  0x00000000  Scaler configuration 
+	volatile unsigned int	CSSF;				//  0x04  W/R  0x00000000  Scale factor 
+	volatile unsigned int	CSSO;				//  0x08  W/R  0x00000000  Image offset 
+	volatile unsigned int	CSSS;				//  0x0C  W/R  0x00000000  Source image size 
+	volatile unsigned int	CSDS;				//  0x10  W/R  0x00000000  Destination image size 
+}CIFSCALER, *PCIFSCALER;
+
+
+
+/***********************************************************************
+*	10. Video and Image  Quality Enhancer Register Define	(Base Addr = 0xF0230200)
+************************************************************************/
+//#define HwVIQE_BASE                     *(volatile unsigned long *)0xF0252000
+typedef struct _VIQE{
+	volatile unsigned int	CTRL;               // 0x000 R/W 0x00000000 VIQE General Control Register
+	volatile unsigned int	SIZE;               // 0x004 R/W 0x00000000 VIQE SIZE Register
+	volatile unsigned int	TIMEGEN;            // 0x008 R/W 0x00000000 VIQE Time Generator Register
+	volatile unsigned int	LUMADLY;            // 0x00C R/W 0x00000000 VIQE Luma Delay Register
+	volatile unsigned int	IMGCONF;            // 0x010 R/W 0x00000000 VIQE Image Configuration Register
+	volatile unsigned int	IMGFMT;             // 0x014 R/W 0x00000000 VIQE Image Format Register
+	volatile unsigned int	MISCC;              // 0x018 R/W 0x00000000 VIQE Misc, Control Register
+	volatile unsigned int	FRMC;               // 0x01C R/W 0x00000000 VIQE Frame Control Register
+	volatile unsigned int	INT;                // 0x020 R/W 0x00000000 VIQE Interrupt Register
+	volatile unsigned int	INTMASK;            // 0x024 R/W 0x00000000 VIQE Interrupt Mask register
+	volatile unsigned int   NOTDEFINE0[5];
+	volatile unsigned int	VERSION;            // 0x03c R 0x4d2b3401 VIQE Version register
+    volatile unsigned int   NOTDEFINE1[16];
+	volatile unsigned int	DI_CTRL;            // 0x080 R/W 0x00000000 De-interlacer Control Register
+	volatile unsigned int	DI_ENGINE0;         // 0x084 R/W 0x00000000 De-interlacer Engine 0 Register
+	volatile unsigned int	DI_ENGINE1;         // 0x088 R/W 0x00000000 De-interlacer Engine 1 Register
+	volatile unsigned int	PD_THRES0;          // 0x08C R/W 0x00000000 De-interlacer Pulldown Threshold 0 Register
+	volatile unsigned int	PD_THRES1;          // 0x090 R/W 0x00000000 De-interlacer Pulldown Threshold 1 Register
+	volatile unsigned int	PD_JUDDER;          // 0x094 R/W 0x00000000 De-interlacer Pulldown Judder Register
+	volatile unsigned int	DI_MISCC;           // 0x098 R/W 0x00000000 De-interlacer Misc. Control register
+	volatile unsigned int   NOTDEFINE2;
+	volatile unsigned int	DI_STATUS;          // 0x0A0 R De-interlacer Status Register
+	volatile unsigned int	PD_STATUS;          // 0x0A4 R De-interlacer Pulldown Status Register
+	volatile unsigned int	DI_REGION0;         // 0x0A8 R/W 0x00000000 De-interlacer Region 0 Register
+	volatile unsigned int	DI_REGION1;         // 0x0AC R/W 0x00000000 De-interlacer Region 1 register
+	volatile unsigned int   NOTDEFINE3[3];
+	volatile unsigned int	DI_INT;             // 0x0BC R/W 0x00000000 De-interlacer Interrupt Register
+    volatile unsigned int   NOTDEFINE4[16];
+    
+	volatile unsigned int	DN_C_H_Y0;          // 0x100 R/W 0xbfffffa4 Temporal De-noiser horizontal coefficient #0 in luminance
+	volatile unsigned int	DN_C_H_Y1;          // 0x104 R/W 0x15556aaa Temporal De-noiser horizontal coefficient #1 in luminance
+	volatile unsigned int	DN_C_V_Y0;          // 0x108 R/W 0xaaaaaaa4 Temporal De-noiser vertical coefficient #0 in luminance
+	volatile unsigned int	DN_C_V_Y1;          // 0x10C R/W 0x15556aaa Temporal De-noiser vertical coefficient #1 in luminance
+	volatile unsigned int	DN_C_T_Y0;          // 0x110 R/W 0xaaaaaaa4 Temporal De-noiser temporal coefficient #0 in luminance
+	volatile unsigned int	DN_C_T_Y1;          // 0x114 R/W 0x15556aaa Temporal De-noiser temporal coefficient #1 in luminance
+	volatile unsigned int	DN_C_H_C0;          // 0x118 R/W 0xbfffffa4 Temporal De-noiser horizontal coefficient #0 in chrominance 
+	volatile unsigned int	DN_C_H_C1;          // 0x11C R/W 0x15556aaa Temporal De-noiser horizontal coefficient #1 in chrominance
+	volatile unsigned int	DN_C_V_C0;          // 0x120 R/W 0xaaaaaaa4 Temporal De-noiser vertical coefficient #0 in chrominance
+	volatile unsigned int	DN_C_V_C1;          // 0x124 R/W 0x15556aaa Temporal De-noiser vertical coefficient #1 in chrominance
+	volatile unsigned int	DN_C_T_C0;          // 0x128 R/W 0xaaaaaaa4 Temporal De-noiser temporal coefficient #0 in chrominance
+	volatile unsigned int	DN_C_T_C1;          // 0x12C R/W 0x15556aaa Temporal De-noiser temporal coefficient #1 in chrominance
+	volatile unsigned int	DN_STATE0_TEM;      // 0x130 R/W 0x00000000 Temporal De-noiser count states and int. mask
+	volatile unsigned int	DN_STATE1_TEM;      // 0x134 R - Temporal De-noiser count states
+	volatile unsigned int	DN_DIV_IMG_TEM;     // 0x138 R/W 0x00000168 Temporal De-noiser image divide
+	volatile unsigned int   NOTDEFINE5;
+	volatile unsigned int	DN_C_SPA_Y0;        // 0x140 R/W 0x12320e0a Spatial De-noiser coefficient #0 in luminance
+	volatile unsigned int	DN_C_SPA_Y1;        // 0x144 R/W 0x373c051d Spatial De-noiser coefficient #1 in luminance
+	volatile unsigned int	DN_C_SPA_Y2;        // 0x148 R/W 0x4a0640ff Spatial De-noiser coefficient #2 in luminance
+	volatile unsigned int	DN_C_SPA_Y3;        // 0x14C R/W 0x003100fb Spatial De-noiser coefficient #3 in luminance
+	volatile unsigned int	DN_C_SPA_C0;        // 0x150 R/W 0x12190805 Spatial De-noiser coefficient #0 in chrominance
+	volatile unsigned int	DN_C_SPA_C1;        // 0x154 R/W 0x373c0507 Spatial De-noiser coefficient #1 in chrominance
+	volatile unsigned int	DN_C_SPA_C2;        // 0x158 R/W 0x4a0640ff Spatial De-noiser coefficient #2 in chrominance
+	volatile unsigned int	DN_C_SPA_C3;        // 0x15C R/W 0x003100fb Spatial De-noiser coefficient #3 in chrominance
+	volatile unsigned int	DN_FIFOSTATE;       // 0x160 R/W 0x00000000 De-noiser FIFO states
+	volatile unsigned int	DN_STATE0_SPA;      // 0x164 R/W 0x00000000 Spatial De-noiser count states and int.mask
+	volatile unsigned int	DN_STATE1_SPA;      // 0x168 R - Spatial De-noiser count states
+	volatile unsigned int	DN_CTRL;            // 0x16C R/W 0x00000000 De-noiser FIFO and coefficient ctrl
+	volatile unsigned int	DN_DIV_IMG_SPA;     // 0x170 R/W 0x00000168 Spatial De-noiser image divide
+	volatile unsigned int   NOTDEFINE6[3];
+
+	volatile unsigned int	RD_IMG0_BASE0;      // 0x180 R/W 0x00000000 RDMA image #0 base address in Y channel
+	volatile unsigned int	RD_IMG0_BASE1;      // 0x184 R/W 0x00000000 RDMA image #0 base address in U channel
+	volatile unsigned int	RD_IMG0_BASE2;      // 0x188 R/W 0x00000000 RDMA image #0 base address in V channel
+	volatile unsigned int	RD_IMG0_OFS;        // 0x18C R/W 0x00000000 RDMA image #0 address offset
+	volatile unsigned int	RD_IMG1_BASE0;      // 0x190 R/W 0x00000000 RDMA image #1 base address in Y channel
+	volatile unsigned int	RD_IMG1_BASE1;      // 0x194 R/W 0x00000000 RDMA image #1 base address in U channel
+	volatile unsigned int	RD_IMG1_BASE2;      // 0x198 R/W 0x00000000 RDMA image #1 base address in V channel
+	volatile unsigned int	RD_IMG1_OFS;        // 0x19C R/W 0x00000000 RDMA image #1 address offset
+	volatile unsigned int	RD_IMG2_BASE0_0;    // 0x1A0 R/W 0x00000000 RDMA decomp. data #0 base address in Y channel
+	volatile unsigned int	RD_IMG2_BASE1_0;    // 0x1A4 R/W 0x00000000 RDMA decomp. data #0 base address in U channel
+	volatile unsigned int	RD_IMG2_BASE2_0;    // 0x1A8 R/W 0x00000000 RDMA decomp. data #0 base address in V channel
+	volatile unsigned int	RD_IMG2_BASE0_1;    // 0x1AC R/W 0x00000000 RDMA decomp. data #1 base address in Y channel
+	volatile unsigned int	RD_IMG2_BASE1_1;    // 0x1B0 R/W 0x00000000 RDMA decomp. data #1 base address in U channel
+	volatile unsigned int	RD_IMG2_BASE2_1;    // 0x1B4 R/W 0x00000000 RDMA decomp. data #1 base address in V channel
+	volatile unsigned int	RD_CUR_ADDR0;       // 0x1B8 R - RDMA image #0 current address
+	volatile unsigned int	RD_CUR_ADDR1;       // 0x1BC R - RDMA image #1 current address
+	volatile unsigned int	RD_CUR_ADDR2;       // 0x1C0 R - RDMA decomp. data current address
+	volatile unsigned int	RD_FIFOSTATE;       // 0x1C4 R/W 0x00000000 RDMA FIFO States
+	volatile unsigned int	RD_LINE_STATE0;     // 0x1C8 R - RDMA count states #0
+	volatile unsigned int	RD_LINE_STATE1;     // 0x1CC R/W 0x00000000 RDMA count states #1
+	volatile unsigned int	RD_CTRL;            // 0x1D0 R/W 0x00000000 RDMA control register
+	volatile unsigned int	RD_COMP_PL0;        // 0x1D4 R/W 0x00000000 RDMA decomp. data number in Y channel
+	volatile unsigned int	RD_COMP_PL1;        // 0x1D8 R/W 0x00000000 RDMA decomp. data number in C channel
+	volatile unsigned int   NOTDEFINE7[9];
+
+	volatile unsigned int	CD_BASE0_0;         // 0x200 R/W 0x00000000 Comp. DMA #0 base address in Y channel
+	volatile unsigned int	CD_BASE1_0;         // 0x204 R/W 0x00000000 Comp. DMA #0 base address in U channel
+	volatile unsigned int	CD_BASE2_0;         // 0x208 R/W 0x00000000 Comp. DMA #0 base address in V channel
+	volatile unsigned int	CD_BASE0_1;         // 0x20C R/W 0x00000000 Comp. DMA #1 base address in Y channel
+	volatile unsigned int	CD_BASE1_1;         // 0x210 R/W 0x00000000 Comp. DMA #1 base address in U channel
+	volatile unsigned int	CD_BASE2_1;         // 0x214 R/W 0x00000000 Comp. DMA #1 base address in V channel
+	volatile unsigned int	CD_CUR_ADDR;        // 0x218 R - Comp. DMA current address
+	volatile unsigned int	CD_STATE;           // 0x21C R/W 0x00000000 Comp. DMA states
+	volatile unsigned int	CD_CTRL;            // 0x220 R/W 0x00000000 Comp. DMA control register
+	volatile unsigned int   NOTDEFINE8[3];
+	volatile unsigned int	CD_HUFF_CNT0;       // 0x230 R - Comp. DMA compressed data count in Y channel
+	volatile unsigned int	CD_HUFF_CNT1;       // 0x234 R - Comp. DMA compressed data count in U channel
+	volatile unsigned int	CD_HUFF_CNT2;       // 0x238 R Comp. DMA compressed data count in V channel
+    volatile unsigned int   NOTDEFINE9[17];
+
+	volatile unsigned int	OD_BASE0;           // 0x280 R/W 0x00000000 ODMA base address in Y channel
+	volatile unsigned int	OD_BASE1;           // 0x284 R/W 0x00000000 ODMA base address in U channel
+	volatile unsigned int	OD_BASE2;           // 0x288 R/W 0x00000000 ODMA base address in V channel
+	volatile unsigned int	OD_SIZE;            // 0x28C R/W 0x00000000 ODMA image size
+	volatile unsigned int	OD_OFS;             // 0x290 R/W 0x00000000 ODMA address offset
+	volatile unsigned int	OD_CFG;             // 0x294 R/W 0x00000000 ODMA image type
+	volatile unsigned int   NOTDEFINE10[3];
+	volatile unsigned int	OD_CTRL;            // 0x2A4 R/W 0x00000000 ODMA control register
+	volatile unsigned int	OD_STATE;           // 0x2A8 R/W 0x00000000 ODMA States
+	volatile unsigned int   NOTDEFINE11[85];
+
+	volatile unsigned int	GM_CTRL;            // 0x400 R/W 0x00000000 Gamut-mapper Control Register
+	volatile unsigned int	GM_STATUS;          // 0x404 R/W 0x00000000 Gamut-mapper Status Register
+	volatile unsigned int	GM_REGION0;         // 0x408 R/W 0x00000000 Gamut-mapper Region 0 Register
+	volatile unsigned int	GM_REGION1;         // 0x40C R/W 0x00000000 Gamut-mapper Region 1 register
+	volatile unsigned int   NOTDEFINE12[3];
+	volatile unsigned int	GM_INT;             // 0x41C R/W 0x00000000 Gamut-mapper Interrupt Register
+    volatile unsigned int   NOTDEFINE13[120];
+
+	volatile unsigned int	HI_CTRL;            // 0x600 R/W 0x00000000 Histogram Control Register
+	volatile unsigned int	HI_STATUS;          // 0x604 R/W 0x00000000 Histogram Status Register
+	volatile unsigned int	HI_CONFIG;          // 0x608 R/W 0x00000000 Histogram Configuration Register
+	volatile unsigned int	HI_REGION0;         // 0x60C R/W 0x00000000 Histogram Region 0 Register
+	volatile unsigned int	HI_REGION1;         // 0x610 R/W 0x00000000 Histogram Region 1 register
+	volatile unsigned int   NOTDEFINE14[2];
+	volatile unsigned int	HI_INT;             // 0x61C R/W 0x00000000 Histogram Interrupt Register
+	volatile unsigned int	HI_SEGS[4];         // 0x620 ~ 0x62C R/W 0x00000000 Histogram Segments Register
+	volatile unsigned int	HI_CDFS[4];         // 0x630 ~ 0x63C R 0x00000000 Histogram CDF Register
+	volatile unsigned int	HI_CNTS[8];         // 0x640 ~ 0x65C R 0x00000000 Histogram CNT Register
+	volatile unsigned int	HI_SCALE[4];        // 0x660 ~ 0x66C R/W 0x00000000 Histogram Scale Register
+	volatile unsigned int	HI_LUTS[64];        // 0x700 ~ 0x7FC R/W 0x00000000 Histogram LUT Table register
+}VIQE, *PVIQE;
+
+
+
+/***********************************************************************
+*   11. DDI_CONFIG/DDI_CACHE Register Define   	(Base Addr = 0xF0251000)
+************************************************************************/
+//#define HwDDI_CONFIG_BASE               *(volatile unsigned long *)0xF0251000
+//#define HwDDI_CACHE_BASE                *(volatile unsigned long *)0xF0250000
+
+typedef struct _DDICONFIG{
+	volatile unsigned int	NTSCPAL_SEL;        // 0x000 R/W 0x00000001 NTSCPAL_Encoder select
+	volatile unsigned int	LVDS_CTRL;          // 0x004 R/W 0x04444443 LVDS Control register
+	volatile unsigned int	LVDS_TXO_SEL0;      // 0x008 R/W 0x03020100 LVDS TXOUT select #0
+	volatile unsigned int	LVDS_TXO_SEL1;      // 0x00C R/W 0x09080504 LVDS TXOUT select #1
+	volatile unsigned int	LVDS_TXO_SEL2;      // 0x010 R/W 0x0D0C0B0A LVDS TXOUT select #2
+	volatile unsigned int	LVDS_TXO_SEL3;      // 0x014 R/W 0x13121110 LVDS TXOUT select #3
+	volatile unsigned int	LVDS_TXO_SEL4;      // 0x018 R/W 0x1A191514 LVDS TXOUT select #4
+	volatile unsigned int	LVDS_TXO_SEL5;      // 0x01C R/W 0x0E070618 LVDS TXOUT select #5
+	volatile unsigned int	LVDS_TXO_SEL6;      // 0x020 R/W 0x1B17160F LVDS TXOUT select #6
+	volatile unsigned int	LVDS_TXO_SEL7;      // 0x024 R/W 0x1F1E1F1E LVDS TXOUT select #7
+	volatile unsigned int	LVDS_TXO_SEL8;      // 0x028 R/W 0x001E1F1E LVDS TXOUT select #8
+	volatile unsigned int	HDMI_CTRL;          // 0x02C R/W 0x00000002 HDMI Control register
+	volatile unsigned int	PWDN;               // 0x030 R/W 0x00000000 Power Down
+	volatile unsigned int	SWRESET;            // 0x034 R/W 0x00000000 Soft Reset
+	volatile unsigned int	ON_THE_FLY;         // 0x038 R/W 0x00000000 On-The-Fly mode
+	volatile unsigned int   NOTDEFINE0;
+	volatile unsigned int	HDMI_AES;           // 0x040 R/W 0x00000000 HDMI AES
+	volatile unsigned int	HDMI_AES_DATA0;     // 0x044 RW 0x00000000 HDMI AES DATA #0
+	volatile unsigned int	HDMI_AES_DATA1;     // 0x048 R/W 0x00000000 HDMI AES DATA #1
+	volatile unsigned int	HDMI_AES_HW0;       // 0x050 R/W 0x00000000 HDMI AES HW #0
+	volatile unsigned int	HDMI_AES_HW1;       // 0x054 R/W 0x00000000 HDMI AES HW #1
+	volatile unsigned int	HDMI_AES_HW2;       // 0x058 R/W 0x00000000 HDMI AES HW #2
+}DDICONFIG, *PDDICONFIG;
+
+
+// Where is DDI_CONGIF in DataSheet ??
+
+typedef struct _DDICACHE{
+	volatile unsigned int	DDIC_CTRL;          //  0x000 R/W 0x00000000 DDI_CACHE Control
+	volatile unsigned int	DDIC_CFG0;          //  0x004 R/W 0x00000000 DDI_CACHE Configuration #0
+	volatile unsigned int	DDIC_CFG1;          //  0x008 R/W 0x00000000 DDI_CACHE Configuration #1    
+}DDICACHE, *PDDICACHE;
+
+
+/*******************************************************************************
+*	 TCC8900_DataSheet_PART 7 VIDEO BUS_V0.00 Dec.11 2008
+********************************************************************************/
+/***********************************************************************
+*   4. VIDEO CODEC Register Define                	(Base Addr = 0x0xF0700000)
+************************************************************************/
+//#define HwVIDEOCODEC_BASE                           *(volatile unsigned long*)0xF0700000
+
+/*******************************************************************************
+*	 TCC8900_DataSheet_PART 7 VIDEO BUS_V0.00 Dec.11 2008
+********************************************************************************/
+/*******************************************************************************
+*	 5-1. JPEG Encoder Register Define   (Base Addr = 0xF0720000)
+********************************************************************************/
+//#define HwJPEGDECODER_BASE                          *(volatile unsigned long*)0xF0710000
+//#define HwJPEGENCODER_BASE                          *(volatile unsigned long*)0xF0720000
+//#define HwVIDEOCACHE_BASE                           *(volatile unsigned long*)0xF0701000
+typedef struct _JPEGENCODER{
+    volatile unsigned int  NOTDEFINE0;              // 0x000
+    volatile unsigned int  JP_MOD;                  //  0x004 R/W ALL 0x00000000 JPEG codec mode register
+    volatile unsigned int  JP_INT_MASK;             //  0x008 R/W ALL 0x0000001f Interrupt mask register
+    volatile unsigned int  JP_INT_LEVEL;            //  0x00c R/W SLV 0x000000ff FIFO interrupt level register
+    volatile unsigned int  JP_TRG_MOD;              //  0x010 R/W ALL 0x00000000 Polling or Interrupt mode selection register
+    volatile unsigned int  NOTDEFINE1[3];
+    volatile unsigned int  R_YBUF_ADDR;             //  0x020 R/W JP 0x00000000 Raw data buffer Y address register
+    volatile unsigned int  R_UBUF_ADDR;             //  0x024 R/W JP 0x00000000 Raw data buffer U address register
+    volatile unsigned int  R_VBUF_ADDR;             //  0x028 R/W JP 0x00000000 Raw data V address register
+    volatile unsigned int  R_BUF_INFO;              //  0x02c R/W JP 0x00000000 Raw data buffer information register
+    volatile unsigned int  JP_SIZE;                 //  0x030 R/W JP 0x00000000 Image size information register
+    volatile unsigned int  JP_CHROMA;               //  0x034 R/W JP 0x00000000 Image format information register
+    volatile unsigned int  JP_CBUF_ADDR;            //  0x38 R/W JP 0x00000000 Coded data buffer address register
+    volatile unsigned int  JP_CBUF_SIZE;            //  0x03c R/W JP 0x00000fff Coded data buffer size register
+    volatile unsigned int  NOTDEFINE2[12];
+    volatile unsigned int  JP_START;                //  0x070 W ALL 0x00000000 Codec start command register
+    volatile unsigned int  NOTDEFINE3[3];
+    volatile unsigned int  JP_SBUF_WCNT;            //  0x080 R/W MST 0x00000000 Source buffer write count register
+    volatile unsigned int  JP_SBUF_RCNT;            //  0x084 R MST 0x00000000 Source buffer read count register
+    volatile unsigned int  JP_DBUF_WCNT;            //  0x088 R MST 0x00000000 Destination buffer write count register
+    volatile unsigned int  JP_DBUF_RCNT;            //  0x08c R/W MST 0x00000000 Destination buffer read count register
+    volatile unsigned int  JP_IFIFO_ST;             //  0x090 R SLV 0x00000000 Input FIFO status register
+    volatile unsigned int  JP_OFIFO_ST;             //  0x094 R SLV 0x00000000 Output FIFO status register
+    volatile unsigned int  NOTDEFINE4[2];
+    volatile unsigned int  JP_INT_FLAG;             //  0x0a0 R ALL 0x00000000 Interrupt flag register
+    volatile unsigned int  JP_INT_ACK;              //  0x0a4 R ALL 0x00000000 Interrupt ack register
+    volatile unsigned int  NOTDEFINE5[10];
+    volatile unsigned int  JP_IFIFO_WD;             //  0x0c0 W SLV 0x00000000 Input FIFO write data register
+    volatile unsigned int  NOTDEFINE6[7];
+    volatile unsigned int  JP_OFIFO_RD;             //  0x0e0 R SLV 0x00000000 Output FIFO read data register
+    volatile unsigned int  NOTDEFINE7[7];
+    volatile unsigned int  JPC_QTAB0[64];           //  0x100 - W JPC 0x00000000 Encoder Q table 0 (64 entries)
+    volatile unsigned int  JPC_QTAB1[64];           //  0x200 - W JPC 0x00000000 Encoder Q table 1 (64 entries)
+}JPEGENCODER, *PJPEGENCODER;
+
+/*******************************************************************************
+*	 5-2. JPEG Decoder Register Define   (Base Addr = 0xF0710000)
+********************************************************************************/
+typedef struct _JPEGDECODER{
+    volatile unsigned int  NOTDEFINE0;              // 0x000
+    volatile unsigned int  JP_MOD;                  // 0x004 R/W ALL 0x00000000 JPEG codec mode register
+    volatile unsigned int  JP_INT_MASK;             // 0x008 R/W ALL 0x0000001f Interrupt mask register
+    volatile unsigned int  JP_INT_LEVEL;            // 0x00c R/W SLV 0x000000ff FIFO interrupt level register
+    volatile unsigned int  JP_TRG_MOD;              // 0x010 R/W ALL 0x00000000 Polling or Interrupt mode selection register
+    volatile unsigned int  R_YBUF_ADDR;             // 0x020 R/W JP 0x00000000 Raw data buffer Y address register
+    volatile unsigned int  R_UBUF_ADDR;             // 0x024 R/W JP 0x00000000 Raw data buffer U address register
+    volatile unsigned int  R_VBUF_ADDR;             // 0x028 R/W JP 0x00000000 Raw data V address register
+    volatile unsigned int  R_BUF_INFO;              // 0x02c R/W JP 0x00000000 Raw data buffer information register
+    volatile unsigned int  JP_SIZE;                 // 0x030 R/W JP 0x00000000 Image size information register
+    volatile unsigned int  JP_CHROMA;               // 0x034 R/W JP 0x00000000 Image format information register
+    volatile unsigned int  JP_CBUF_ADDR;            // 0x38 R/W JP 0x00000000 Coded data buffer address register
+    volatile unsigned int  JP_CBUF_SIZE;            // 0x03c R/W JP 0x00000fff Coded data buffer size register
+    volatile unsigned int  NOTDEFINE1[4];
+    volatile unsigned int  JPD_TBL_ID;              // 0x050 R/W JPD 0x00000000 Decoder table index register
+    volatile unsigned int  JPD_RST_INTV;            // 0x054 R/W JPD 0x00000000 Decoder reset interval register
+    volatile unsigned int  JPD_OUT_SCL;             // 0x058 R/W JPD 0x00000000 Decoder output scaling register
+    volatile unsigned int  NOTDEFINE2[5];
+    volatile unsigned int  JP_START;                // 0x070 W ALL 0x00000000 Codec start command register
+    volatile unsigned int  NOTDEFINE3[3];
+    volatile unsigned int  JP_SBUF_WCNT;            // 0x080 R/W MST 0x00000000 Source buffer write count register
+    volatile unsigned int  JP_SBUF_RCNT;            // 0x084 R MST 0x00000000 Source buffer read count register
+    volatile unsigned int  JP_DBUF_WCNT;            // 0x088 R MST 0x00000000 Destination buffer write count register
+    volatile unsigned int  JP_DBUF_RCNT;            // 0x08c R/W MST 0x00000000 Destination buffer read count register
+    volatile unsigned int  JP_IFIFO_ST;             // 0x090 R SLV 0x00000000 Input FIFO status register
+    volatile unsigned int  JP_OFIFO_ST;             // 0x094 R SLV 0x00000000 Output FIFO status register
+    volatile unsigned int  NOTDEFINE4[2];
+    volatile unsigned int  JP_INT_FLAG;             // 0x0a0 R ALL 0x00000000 Interrupt flag register
+    volatile unsigned int  JP_INT_ACK;              // 0x0a4 R ALL 0x00000000 Interrupt ack register
+    volatile unsigned int  NOTDEFINE5[6];
+    volatile unsigned int  JP_IFIFO_WD;             // 0x0c0 W SLV 0x00000000 Input FIFO write data register
+    volatile unsigned int  NOTDEFINE6[7];
+    volatile unsigned int  JP_OFIFO_RD;             // 0x0e0 R SLV 0x00000000 Output FIFO read data register
+    volatile unsigned int  NOTDEFINE7[135];
+    volatile unsigned int  JPD_IQTAB0[64];          // 0x300 - W JPD 0x00000000 Decoder IQ table 0 (64 entries)
+    volatile unsigned int  JPD_IQTAB1[64];          // 0x400 - W JPD 0x00000000 Decoder IQ table 1 (64 entires)
+    volatile unsigned int  JPD_IQTAB2[64];          // 0x500 - W JPD 0x00000000 Decoder IQ table 2 (64 entires)
+    volatile unsigned int  JPD_HT_DC0_C[16];        // 0x600 - W JPD 0x00000000 Decoder huffman table (dc0 code, 16 entreis)
+    volatile unsigned int  JPD_HT_AC0_C[16];        // 0x640 - W JPD 0x00000000 Decoder huffman table (ac0 code, 16 entreis)
+    volatile unsigned int  JPD_HT_DC1_C[16];        // 0x680 - W JPD 0x00000000 Decoder huffman table (dc1 code, 16 entreis)
+    volatile unsigned int  JPD_HT_AC1_C[16];        // 0x6c0 - W JPD 0x00000000 Decoder huffman table (ac1 code, 16 entreis)
+    volatile unsigned int  JPD_HT_DC0_A[16];        // 0x700 - W JPD 0x00000000 Decoder huffman table (dc0 addr, 16 entreis)
+    volatile unsigned int  JPD_HT_AC0_A[16];        // 0x740 - W JPD 0x00000000 Decoder huffman table (ac0 addr, 16 entreis)
+    volatile unsigned int  JPD_HT_DC1_A[16];        // 0x780 - W JPD 0x00000000 Decoder huffman table (dc1 addr, 16 entreis)
+    volatile unsigned int  JPD_HT_AC1_A[16];        // 0x7c0 - W JPD 0x00000000 Decoder huffman table (ac1 addr, 16 entreis)
+    volatile unsigned int  JPD_HT_DC0_V[12];        // 0x800 - W JPD 0x00000000 Decoder huffman table (dc0 var, 12 entreis)
+    volatile unsigned int  JPD_HT_AC0_V[162];       // 0x840 - W JPD 0x00000000 Decoder huffman table (ac0 var, 162 entreis)
+    volatile unsigned int  NOTDEFINE8[78];
+    volatile unsigned int  JPD_HT_DC1_V[12];        // 0xc00 - W JPD 0x00000000 Decoder huffman table (dc1 var, 12 entreis)
+    volatile unsigned int  NOTDEFINE9[4];
+    volatile unsigned int  JPD_HT_AC1_V[162];       // 0xc40 - W JPD 0x00000000 Decoder huffman table (ac1 var, 162 entreis)
+}JPEGDECODER, *PJPEGDECODER;
+
+
+/*******************************************************************************
+*	 TCC8900_DataSheet_PART 8 GRAPHIC BUS_V0.00 Dec.11 2008
+********************************************************************************/
+/***********************************************************************
+*	 4. Overlay Mixer Register Define	(Base Addr = 0xF6000000)
+************************************************************************/
+//#define HwOVERLAYMIXER_BASE                     *(volatile unsigned long *)0xF6000000
+typedef struct _OVERLAYMIXER{
+	volatile unsigned int	FCH0_SADDR0;        // 0x00 R/W 0x00000000 Front-End Channel 0 Source Address 0
+	volatile unsigned int	FCH0_SADDR1;        // 0x04 R/W 0x00000000 Front-End Channel 0 Source Address 1
+	volatile unsigned int	FCH0_SADDR2;        // 0x08 R/W 0x00000000 Front-End Channel 0 Source Address 2
+	volatile unsigned int	FCH0_SFSIZE;        // 0x0C R/W 0x00000000 Front-End Channel 0 Source Frame Pixel Size
+	volatile unsigned int	FCH0_SOFF;          // 0x10 R/W 0x00000000 Front-End Channel 0 Source Pixel Offset
+	volatile unsigned int	FCH0_SISIZE;        // 0x14 R/W 0x00000000 Front-End Channel 0 Source Image Pixel Size
+	volatile unsigned int	FCH0_WOFF;          // 0x18 R/W 0x00000000 Front-End Channel 0 Window Pixel Offset
+	volatile unsigned int	FCH0_SCTRL;         // 0x1C R/W 0x00000000 Front-End Channel 0 Control
+	volatile unsigned int	FCH1_SADDR0;        // 0x20 R/W 0x00000000 Front-End Channel 1 Source Address 0
+	volatile unsigned int	FCH1_SADDR1;        // 0x24 R/W 0x00000000 Front-End Channel 1 Source Address 1
+	volatile unsigned int	FCH1_SADDR2;        // 0x28 R/W 0x00000000 Front-End Channel 1 Source Address 2
+	volatile unsigned int	FCH1_SFSIZE;        // 0x2C R/W 0x00000000 Front-End Channel 1 Source Frame Pixel Size
+	volatile unsigned int	FCH1_SOFF;          // 0x30 R/W 0x00000000 Front-End Channel 1 Source Pixel Offset
+	volatile unsigned int	FCH1_SISIZE;        // 0x34 R/W 0x00000000 Front-End Channel 1 Source Image Pixel Size
+	volatile unsigned int	FCH1_WOFF;          // 0x38 R/W 0x00000000 Front-End Channel 1 Window Pixel Offset
+	volatile unsigned int	FCH1_SCTRL;         // 0x3C R/W 0x00000000 Front-End Channel 1 Control
+	volatile unsigned int	FCH2_SADDR0;        // 0x40 R/W 0x00000000 Front-End Channel 1 Source Address 0
+	volatile unsigned int	FCH2_SADDR1;        // 0x44 R/W 0x00000000 Front-End Channel 1 Source Address 1
+	volatile unsigned int	FCH2_SADDR2;        // 0x48 R/W 0x00000000 Front-End Channel 1 Source Address 2
+	volatile unsigned int	FCH2_SFSIZE;        // 0x4C R/W 0x00000000 Front-End Channel 1 Source Frame Pixel Size
+	volatile unsigned int	FCH2_SOFF;          // 0x50 R/W 0x00000000 Front-End Channel 1 Source Pixel Offset
+	volatile unsigned int	FCH2_SISIZE;        // 0x54 R/W 0x00000000 Front-End Channel 1 Source Image Pixel Size
+	volatile unsigned int	FCH2_WOFF;          // 0x58 R/W 0x00000000 Front-End Channel 1 Window Pixel Offset
+	volatile unsigned int	FCH2_SCTRL;         // 0x5C R/W 0x00000000 Front-End Channel 1 Control
+	volatile unsigned int	S0_CHROMA;          // 0x60 R/W 0x00000000 Source 0 Chroma-Key Parameter
+	volatile unsigned int	S0_PAR;             // 0x64 R/W 0x00000000 Source 0 Arithmetic Parameter
+	volatile unsigned int	S1_CHROMA;          // 0x68 R/W 0x00000000 Source 1 Chroma-Key Parameter
+	volatile unsigned int	S1_PAR;             // 0x6C R/W 0x00000000 Source 1 Arithmetic Parameter
+	volatile unsigned int	S2_CHROMA;          // 0x70 R/W 0x00000000 Source 2 Chroma-Key Parameter
+	volatile unsigned int	S2_PAR;             // 0x74 R/W 0x00000000 Source 2 Arithmetic Parameter
+	volatile unsigned int	S_CTRL;             // 0x78 R/W 0x00000000 Source Control Register
+	volatile unsigned int	NOTDEFINE0;         // 0x7C - - Reserved
+	volatile unsigned int	OP0_PAT;            // 0x80 R/W 0x00000000 Source Operator 0 Pattern
+	volatile unsigned int	OP1_PAT;            // 0x84 R/W 0x00000000 Source Operator 1 Pattern
+	volatile unsigned int	OP_CTRL;            // 0x88 R/W 0x00000000 Source Operation Control Register
+	volatile unsigned int	NOTDEFINE1;         // 0x8C - - Reserved
+	volatile unsigned int	BCH_DADDR0;         // 0x90 R/W 0x00000000 Back-End Channel Destination Address 0
+	volatile unsigned int	BCH_DADDR1;         // 0x94 R/W 0x00000000 Back -End Channel Destination Address 1
+	volatile unsigned int	BCH_DADDR2;         // 0x98 R/W 0x00000000 Back -End Channel Destination Address 2
+	volatile unsigned int	BCH_DFSIZE;         // 0x9C R/W 0x00000000 Back -End Channel Destination Frame Pixel Size
+	volatile unsigned int	BCH_DOFF;           // 0xA0 R/W 0x00000000 Back -End Channel Destination Pixel Offset
+	volatile unsigned int	BCH_DCTRL;          // 0xA4 R/W 0x00000000 Back -End Channel Control
+
+	volatile unsigned int	NOTDEFINE2[2];      // 0xA8 - 0xAF - - Reserved
+	volatile unsigned int	BCH_DDMAT0;         // 0xB0 R/W 0x00000000 Back-End Channel Destination Dither Matrix 0
+	volatile unsigned int	BCH_DDMAT1;         // 0xB4 R/W 0x00000000 Back-End Channel Destination Dither Matrix 1
+	volatile unsigned int	BCH_DDMAT2;         // 0xB8 R/W 0x00000000 Back-End Channel Destination Dither Matrix 2
+	volatile unsigned int	BCH_DDMAT3;         // 0xBC R/W 0x00000000 Back-End Channel Destination Dither Matrix 3
+	volatile unsigned int	OM_CTRL;            // 0xC0 R/W 0x00000000 Overlay Mixer Control
+	volatile unsigned int	OM_IREQ;            // 0xC4 R/W 0x00000000 Overlay Mixer Interrupt Request
+	volatile unsigned int	NOTDEFINE3[206];    // 0xC8 - 0x3FF - - Reserved
+	
+	volatile unsigned int	FCH0_LUT[256];      // 0x400 ? 0x7FF R/W - Front-End Channel 0 Lookup Table
+	volatile unsigned int	FCH1_LUT[256];      // 0x800 ? 0xBFF R/W - Front-End Channel 1 Lookup Table
+	volatile unsigned int	FCH2_LUT[256];      // 0xC00 ? 0xFFF R/W - Front-End Channel 2 Lookup Table
+}OVERLAYMIXER, *POVERLAYMIXER;
+
+
+/*******************************************************************************
+*	 5-1. 2D/3D GPU
+*
+*	 Pixel Processor Register Map Register Define   (Base Addr = 0xF0000000)
+********************************************************************************/
+// #define HwPIXELPROCESSOR_BASE                   *(volatile unsigned long *)0xF0000000
+typedef struct _GPUPIXELPROCESSOR{
+	volatile unsigned int	REND_LIST_ADDR;              // 0x0000 R/W 0x00000000 Renderer List Address
+	volatile unsigned int	REND_RSW_BASE;               // 0x0004 R/W 0x00000000 Renderer State Word Base Address
+	volatile unsigned int	REND_VERTEX_BASE;            // 0x0008 R/W 0x00000000 Renderer Vertex Base Address
+	volatile unsigned int	FEATURE_ENABLE;              // 0x000C R/W 0x00000002 Feature Enable
+	volatile unsigned int	Z_CLEAR_VALUE;               // 0x0010 R/W 0x00000009 Z Clear Value
+	volatile unsigned int	STENCIL_CLEAR_VALUE;         // 0x0014 R/W 0x00000000 Stencil Clear value
+	volatile unsigned int	ABGR_CLEAR_VALUE_0;          // 0x0018 R/W 0x00000000 ABGR Clear Value 0
+	volatile unsigned int	ABGR_CLEAR_VALUE_1;          // 0x001C R/W 0x00000000 ABGR Clear Value 1
+	volatile unsigned int	ABGR_CLEAR_VALUE_2;          // 0x0020 R/W 0x00000000 ABGR Clear Value 2
+	volatile unsigned int	ABGR_CLEAR_VALUE_3;          // 0x0024 R/W 0x00000000 ABGR Clear Value 3
+	volatile unsigned int	BOUNDING_BOX_LEFT_RIGHT;     // 0x0028 R/W 0x00000000 Bounding Box left Right
+	volatile unsigned int	BOUNDING_BOX_BOTTOM;         // 0x002C R/W 0x00000000 Bounding Box Bottom
+	volatile unsigned int	FS_STACK_ADDR;               // 0x0030 R/W 0x00000000 FS Stack Address
+	volatile unsigned int	FS_STACK_SIZE_AND_INIT_VAL;  // 0x0034 R/W 0x00000000 FS Stack Size and Initial Value
+	volatile unsigned int	ORIGIN_OFFSET_X;             // 0x0040 R/W 0x00000000 Origin Offset X
+	volatile unsigned int	ORIGIN_OFFSET_Y;             // 0x0044 R/W 0x00000000 Origin Offset Y
+	volatile unsigned int	SUBPIXEL_SPECIFIER;          // 0x0048 R/W 0x00000075 Subpixel Specifier
+	volatile unsigned int	TIEBREAK_MODE;               // 0x004C R/W 0x00000000 Tiebreak mode Register
+	volatile unsigned int	NOTDEFINE0[44];
+	volatile unsigned int	WB0_SOURCE_SELECT;           // 0x0100 R/W 0x00000000 WB0 Source Select
+	volatile unsigned int	WB0_TARGET_ADDR;             // 0x0104 R/W 0x00000000 WB0 Target Addres
+	volatile unsigned int	WB0_TARGET_PIXEL_FORMAT;     // 0x0108 R/W 0x00000000 WB0 Target Pixel Format
+	volatile unsigned int	WB0_TARGET_AA_FORMAT;        // 0x010C R/W 0x00000000 WB0 Target AA Format
+	volatile unsigned int	WB0_TARGET_LAYOUT;           // 0x0110 R/W 0x00000000 WB0 Target Layout
+	volatile unsigned int	WB0_TARGET_SCANLINE_LENGTH;  // 0x0114 R/W 0x00000000 WB0 Target Scanline length
+	volatile unsigned int	WB0_TARGET_FLAGS;            // 0x0118 R/W 0x00000000 WB0 Target Flags
+	volatile unsigned int	WB0_MRT_ENABLE;              // 0x011C R/W 0x00000000 WB0 MRT Enagle
+	volatile unsigned int	WB0_MRT_OFFSET;              // 0x0120 R/W 0x00000000 WB0 MRT Offset
+	volatile unsigned int	WB0_GLOBAL_TEST_ENABLE;      // 0x0124 R/W 0x00000000 WB0 Global Test Enable
+	volatile unsigned int	WB0_GLOBAL_TEST_REF_VALUE;   // 0x0128 R/W 0x00000000 WB0 Global Test Reference
+	volatile unsigned int	WB0_GLOBAL_TEST_CMP_FUNC;    // 0x012C R/W 0x00000000 WB0 Global Test Compare Function
+	volatile unsigned int	NOTDEFINE1[52];
+	volatile unsigned int	WB1_SOURCE_SELECT;           // 0x0200 R/W 0x00000000 WB1 Source Select
+	volatile unsigned int	WB1_TARGET_ADDR;             // 0x0204 R/W 0x00000000 WB1 Target Addres
+	volatile unsigned int	WB1_TARGET_PIXEL_FORMAT;     // 0x0208 R/W 0x00000000 WB1 Target Pixel Format
+	volatile unsigned int	WB1_TARGET_AA_FORMAT;        // 0x020C R/W 0x00000000 WB1 Target AA Format
+	volatile unsigned int	WB1_TARGET_LAYOUT;           // 0x0210 R/W 0x00000000 WB1 Target Layout
+	volatile unsigned int	WB1_TARGET_SCANLINE_LENGTH;  // 0x0214 R/W 0x00000000 WB1 Target Scanline length
+	volatile unsigned int	WB1_TARGET_FLAGS;            // 0x0218 R/W 0x00000000 WB1 Target Flags
+	volatile unsigned int	WB1_MRT_ENABLE;              // 0x021C R/W 0x00000000 WB1 MRT Enagle
+	volatile unsigned int	WB1_MRT_OFFSET;              // 0x0220 R/W 0x00000000 WB1 MRT Offset
+	volatile unsigned int	WB1_GLOBAL_TEST_ENABLE;      // 0x0224 R/W 0x00000000 WB1 Global Test Enable
+	volatile unsigned int	WB1_GLOBAL_TEST_REF_VALUE;   // 0x0228 R/W 0x00000000 WB1 Global Test Reference
+	volatile unsigned int	WB1_GLOBAL_TEST_CMP_FUNC;    // 0x022C R/W 0x00000000 WB1 Global Test Compare Function
+	volatile unsigned int	NOTDEFINE2[52];
+	volatile unsigned int	WB2_SOURCE_SELECT;           // 0x0300 R/W 0x00000000 WB2 Source Select
+	volatile unsigned int	WB2_TARGET_ADDR;             // 0x0304 R/W 0x00000000 WB2 Target Addres
+	volatile unsigned int	WB2_TARGET_PIXEL_FORMAT;     // 0x0308 R/W 0x00000000 WB2 Target Pixel Format
+	volatile unsigned int	WB2_TARGET_AA_FORMAT;        // 0x030C R/W 0x00000000 WB2 Target AA Format
+	volatile unsigned int	WB2_TARGET_LAYOUT;           // 0x0310 R/W 0x00000000 WB2 Target Layout
+	volatile unsigned int	WB2_TARGET_SCANLINE_LENGTH;  // 0x0314 R/W 0x00000000 WB2 Target Scanline length
+	volatile unsigned int	WB2_TARGET_FLAGS;            // 0x0318 R/W 0x00000000 WB2 Target Flags
+	volatile unsigned int	WB2_MRT_ENABLE;              // 0x031C R/W 0x00000000 WB2 MRT Enagle
+	volatile unsigned int	WB2_MRT_OFFSET;              // 0x0320 R/W 0x00000000 WB2 MRT Offset
+	volatile unsigned int	WB2_GLOBAL_TEST_ENABLE;      // 0x0324 R/W 0x00000000 WB2 Global Test Enable
+	volatile unsigned int	WB2_GLOBAL_TEST_REF_VALUE;   // 0x0328 R/W 0x00000000 WB2 Global Test Reference
+	volatile unsigned int	WB2_GLOBAL_TEST_CMP_FUNC;    // 0x032C R/W 0x00000000 WB2 Global Test Compare Function
+	volatile unsigned int	NOTDEFINE3[820];
+	volatile unsigned int	VERSION;                     // 0x1000 R 0xC8070005 Version
+	volatile unsigned int	CURRENT_REND_LIST_ADDR;      // 0x1004 R/W 0x00000000 Current Renderer List Address
+	volatile unsigned int	STATUS;                      // 0x1008 R/W 0x00000000 Status
+	volatile unsigned int	CTRL_MGMT;                   // 0x100C W N/A Control Management
+	volatile unsigned int	INT_RAWSTAT;                 // 0x1020 R/W 0x00000000 Interrupt Rawstat
+	volatile unsigned int	INT_CLEAR;                   // 0x1024 W N/A Interrupt Clear
+	volatile unsigned int	INT_MASK;                    // 0x1028 RW 0x00001FF Interrupt Mask
+	volatile unsigned int	INT_STATUS;                  // 0x102c R 0x00000000 Interrupt Status
+	volatile unsigned int	WRITE_BOUNDARY_ENABLE;       // 0x1040 R/W 0x00000000 Write Boundary Enable
+	volatile unsigned int	WRITE_BOUNDARY_LOW;          // 0x1044 R/W 0x00000000 Write Boundary Low
+	volatile unsigned int	WRITE_BOUNDARY_HIGH;         // 0x1048 R/W 0x00000000 Write Boundary High
+	volatile unsigned int	WRITE_BOUNDARY_ADDRESS;      // 0x104C R 0x00000000 Write Boundary Address
+	volatile unsigned int	BUS_ERROR_STATUS;            // 0x1050 R 0x00000000 Bus Error Status
+	volatile unsigned int	WATCHDOG_DISABLE;            // 0x1060 R/W 0x00000000 Watchdog Disable
+	volatile unsigned int	WATCHDOG_TIMEOUT;            // 0x1064 R/W 0x000F4240 Watchdog Timeout
+	volatile unsigned int	PERF_CNT_0_ENABLE;           // 0x1080 R/W 0x00000000 Performance Counter 0 Enable
+	volatile unsigned int	PERF_CNT_0_SRC;              // 0x1084 R/W 0x00000000 Performance Counter 0 SRC
+	volatile unsigned int	PERF_CNT_0_LIMIT;            // 0x1088 R/W 0x00000000 Performance Counter 0 Limit
+	volatile unsigned int	PERF_CNT_0_VALUE;            // 0x108C R/W 0x00000000 Performance Counter 0 Value
+	volatile unsigned int	PERF_CNT_1_ENABLE;           // 0x10A0 R/W 0x00000000 Performance Counter 1 Enable
+	volatile unsigned int	PERF_CNT_1_SRC;              // 0x10A4 R/W 0x00000000 Performance Counter 1 SRC
+	volatile unsigned int	PERF_CNT_1_LIMIT;            // 0x10A8 R/W 0x00000000 Performance Counter 1 Limit
+	volatile unsigned int	PERF_CNT_1_VALUE;            // 0x10AC R/W 0x00000000 Performance Counter 1 Value
+}GPUPIXELPROCESSOR,*PGPUPIXELPROCESSOR;
+
+/*******************************************************************************
+*	 5-2. Geometry Processor Register Map Register Define   (Base Addr = 0xF0000000)
+********************************************************************************/
+//#define HwGEOMETRYPROCESSOR_BASE                   *(volatile unsigned long *)0xF0002000
+typedef struct _GPUGEOMETRYPROCESSOR{
+	volatile unsigned int	CONTR_REG_VSCL_START_ADDR;      // 0x2000 R/W 0x00000000 Control Register VSCL Start Address
+	volatile unsigned int	CONTR_REG_VSCL_END_ADDR;        // 0x2004 R/W 0x00000000 Control Register VSCL End Address
+	volatile unsigned int	CONTR_REG_PLBCL_START_ADDR;     // 0x2008 R/W 0x00000000 Control Register PLBCL Start Address
+	volatile unsigned int	CONTR_REG_PLBCL_END_ADDR;       // 0x200C R/W 0x00000000 Control Register PLBCL End Address
+	volatile unsigned int	CONTR_REG_PLB_ALLOC_START_ADDR; // 0x2010 R/W 0x00000000 Control Register PLB Allocate Start Address
+	volatile unsigned int	CONTR_REG_PLB_ALLOC_END_ADDR;   // 0x2014 R/W 0x00000000 Control Register PLB Allocate End Address
+	volatile unsigned int	CONTR_REG_CMD;                  // 0x2020 W N/A Control Register Command
+	volatile unsigned int	CONTR_REG_INT_RAWSTAT;          // 0x2024 R/W 0x00000000 Control Register Interrupt Rawstat
+	volatile unsigned int	CONTR_REG_INT_CLEAR;            // 0x2028 W N/A Control Register Interrupt Clear
+	volatile unsigned int	CONTR_REG_INT_MASK;             // 0x202C R/W 0x00000000 Control Register Interrupt Mask
+	volatile unsigned int	CONTR_REG_INT_STAT;             // 0x2030 R 0x00000000 Control Register Interrupt Status
+	volatile unsigned int	CONTR_REG_WRITE_BOUND_LOW;      // 0x2034 R/W 0x00000000 Control Register Write Boundary Low
+	volatile unsigned int	CONTR_REG_WRITE_BOUND_HIGH;     // 0x2038 R/W 0xFFFFFF00 Control Register Write Boundary High
+	volatile unsigned int	CONTR_REG_PERF_CNT_0_ENABLE;    // 0x203C R/W 0x00000000 Control Register Performance Counter 0 Enable
+	volatile unsigned int	CONTR_REG_PERF_CNT_1_ENABLE;    // 0x2040 R/W 0x00000000 Control Register Performance Counter 1 Enable
+	volatile unsigned int	CONTR_REG_PERF_CNT_0_SRC;       // 0x2044 R/W 0x00000000 Control Register Performance Counter 0 Source
+	volatile unsigned int	CONTR_REG_PERF_CNT_1_SRC;       // 0x2048 R/W 0x00000000 Control Register Performance Counter 1 Source
+	volatile unsigned int	CONTR_REG_PERF_CNT_0_VAL;       // 0x204C R 0x00000000 Control Register Performance Counter 0 Value
+	volatile unsigned int	CONTR_REG_PERF_CNT_1_VAL;       // 0x2050 R 0x00000000 Control Register Performance Counter 1 Value
+	volatile unsigned int	CONTR_REG_PERF_CNT_0_LIMIT;     // 0x2054 R/W 0x00000000 Control Register Performance Counter 0 Limit
+	volatile unsigned int	CONTR_REG_PERF_CNT_1_LIMIT;     // 0x2058 R/W 0x00000000 Control Register Performance Counter 1 Limit
+	volatile unsigned int	CONTR_REG_STATUS;               // 0x2068 R 0x00000000 Control Register Status
+	volatile unsigned int	CONTR_REG_VERSION;              // 0x206C R 0x0A070005 Control Register VERSION
+	volatile unsigned int	CONTR_REG_VSCL_INITIAL_ADDR;    // 0x2080 R 0x00000000 Control Register VSCL Initial Address
+	volatile unsigned int	CONTR_REG_PLBCL_INITIAL_ADDR;   // 0x2084 R 0x00000000 Control Register PLBCL Initial Address
+	volatile unsigned int	CONTR_REG_WRITE_BOUNDARY_ERROR_ADDR;// 0x2088 R 0x00000000 Control Register Write Error Address
+	volatile unsigned int	CONTR_REG_AXI_BUS_ERROR_STAT;   // 0x2094 R 0x00000000 Control AXI Bus Error Status
+	volatile unsigned int	CONTR_REG_WATCHDOG_DISABLE;     // 0x20A0 R/W 0x00000000 Control Register Watchdog Disable
+	volatile unsigned int	CONTR_REG_WATCHDOG_TIMEOUT;     // 0x20A4 R/W 0x000F4240 Control Register Watchdog Timeout
+}GPUGEOMETRYPROCESSOR, *PGPUGEOMETRYPROCESSOR;
+
+
+// MaliGP2 PLB Configuration Register Map
+//#define HwPLBCFG_BASE                                       *(volatile unsigned long*)0xFFFFFFFF
+typedef struct _GPUPLBCFG{	
+	volatile unsigned char	PLB_CONF_REG_VERTEX_ARRAY_ADDR; // 0x0100 W 0x00000000 PLB Configuration Register Vertex Array Address
+	volatile unsigned char	PLB_CONF_REG_INDEX_ARRAY_ADDR;  // 0x0101 W 0x00000000 PLB Configuration Register Index Array Address
+	volatile unsigned char	PLB_CONF_REG_POINT_SIZE_ADDR;   // 0x0102 W 0x00000000 PLB Configuration Register Point Size Address
+	volatile unsigned char	PLB_CONF_REG_HEAP_START_ADDR;   // 0x0103 W 0x00000000 PLB Configuration Register Heap Start Address
+	volatile unsigned char	PLB_CONF_REG_HEAP_END_ADDR;     // 0x0104 W 0x00000000 PLB Configuration Register Heap End Address
+	volatile unsigned char	PLB_CONF_REG_VIEWPORT_TO;      // 0x0105 W 0x00000000 PLB Configuration Register Viewport Top
+	volatile unsigned char	PLB_CONF_REG_VIEWPORT_BOTTOM;   // 0x0106 W 0x00000000 PLB Configuration Register Viewport Bottom
+	volatile unsigned char	PLB_CONF_REG_VIEWPORT_LEFT;     // 0x0107 W 0x00000000 PLB Configuration Register Viewport Left
+	volatile unsigned char	PLB_CONF_REG_VIEWPORT_RIGHT;    // 0x0108 W 0x00000000 PLB Configuration Register Viewport Right
+	volatile unsigned char	PLB_CONF_REG_SCREENSIZE;        // 0x0109 W 0x00000000 PLB Configuration Register Screen Size
+	volatile unsigned char	PLB_CONF_REG_OFFSET_VERTEX_ARRAY;// 0x010A W 0x00000000 PLB Configuration Register Offset Vertex Array
+	volatile unsigned char	PLB_CONF_REG_PARAMS;            // 0x010B W 0x00000000 PLB Configuration Register Parameters
+	volatile unsigned char	PLB_CONF_REG_TILE_SIZE;         // 0x010C W 0x00000000 PLB Configuration Register Tile Size
+	volatile unsigned char	PLB_CONF_REG_POchar_SIZE;        // 0x010D W 0x00000000 PLB Configuration Register Pochar Size
+	volatile unsigned char	PLB_CONF_REG_Z_NEAR;            // 0x010E W 0x00000000 PLB Configuration Register Z Near
+	volatile unsigned char	PLB_CONF_REG_Z_FAR;             // 0x010F W 0x3F800000 PLB Configuration Register Z Far
+}GPUPLBCFG, *PGPUPLBCFG;
+
+
+// MaliGP2 Vertex Shader Register Map
+//#define HwGPUVERTEXSHADER_BASE                              *(volatile unsigned long*)0xFFFFFFFF
+typedef union _VSCFGREG1{
+	//volatile unsigned char	VS_CONF_REG_INP_ADDR[32];           // 0x0000-0x001E W 0x00000000 VS Configuration Register Input Address
+	//volatile unsigned char	VS_CONF_REG_INP_SPEC[32];           // 0x0001-0x001F W 0x0000003F VS Configuration Register Input Specifier
+    volatile unsigned char	ADDR[32];           // 0x0000-0x001E W 0x00000000 VS Configuration Register Input Address
+	volatile unsigned char	SPEC[32];           // 0x0001-0x001F W 0x0000003F VS Configuration Register Input Specifier
+}VSCFGREG;	
+/*
+typedef union _VSCFGREG2{
+    volatile unsigned char	ADDR[32];          // 0x0020-0x003E W 0x00000000 VS Configuration Register Output Address
+    volatile unsigned char	SPEC[32];          // 0x0021-0x003F W 0x0000003F VS Configuration Register Output Specifier
+}VSCFGREG2;
+*/
+typedef struct _GPUVERTEXSHADER{
+    VSCFGREG  VS_CONF_REG_INP;	
+    VSCFGREG  VS_CONF_REG_OUTP;
+	volatile unsigned char	VS_CONF_REG_PROG_PARAM;         // 0x0040 W 0x00000000 VS Configuration Register Program Parameter Create
+	volatile unsigned char	VS_CONF_REG_PREFETCH;           // 0x0041 W 0x00000000 VS Configuration Register Prefetch
+	volatile unsigned char	VS_CONF_REG_OPMOD;              // 0x0042 W 0x0F000000 VS Configuration Register OPMOD
+	volatile unsigned char	VS_CONF_REG_VERTICES_ALT_STRIDE;    // 0x0043 W 0x00000000 VS Configuration Register Vertices Alternative Stride
+	volatile unsigned char	VS_CONF_REG_INPUT_ALT_STRIDE_0; // 0x0044 W 0x00000000 VS Configuration Register Input Alternative Stride 0
+	volatile unsigned char	VS_CONF_REG_INPUT_ALT_STRIDE_1; // 0x0045 W 0x00000000 VS Configuration Register Input Alternative Stride 1
+	volatile unsigned char	VS_CONF_REG_INPUT_ALT_STRIDE_2; // 0x0046 W 0x00000000 VS Configuration Register Input Alternative Stride 2
+	volatile unsigned char	VS_CONF_REG_INPUT_ALT_STRIDE_3; // 0x0047 W 0x00000000 VS Configuration Register Input Alternative Stride 3
+	volatile unsigned char	VS_CONF_REG_OUTPUT_ALT_STRIDE_0;    // 0x0048 W 0x00000000 VS Configuration Register Output Alternative Stride 0
+	volatile unsigned char	VS_CONF_REG_OUTPUT_ALT_STRIDE_1;    // 0x0049 W 0x00000000 VS Configuration Register Output Alternative Stride 1
+	volatile unsigned char	VS_CONF_REG_OUTPUT_ALT_STRIDE_2;    // 0x004A W 0x00000000 VS Configuration Register Output Alternative Stride 2
+	volatile unsigned char	VS_CONF_REG_OUTPUT_ALT_STRIDE_3;    // 0x004B W 0x00000000 VS Configuration Register Output Alternative Stride 3
+}GPUVERTEXSHADER, *PGPUVERTEXSHADER;
+
+
+/*******************************************************************************
+*	 5-3. MMU Configuration Register Define   (Base Addr = 0xF0003000)
+********************************************************************************/
+//#define HwMMUCONFIG_BASE                      *(volatile unsigned long *)0xF0003000
+typedef struct _GPUMMUCONFIG{
+	volatile unsigned int	MMU_DTE_ADDR;                       // 0x3000 R/W 0x00000000 MMU Current Page Table Address
+	volatile unsigned int	MMU_STATUS;                         // 0x3004 R 0x00000018 MMU Status
+	volatile unsigned int	MMU_COMMAND;                        // 0x3008 W N/A MMU Command
+	volatile unsigned int	MMU_PAGE_FAULT_ADDR;                // 0x300C R 0x00000000 MMU Logical Address of Last Page Fault
+	volatile unsigned int	MMU_ZAP_ONE_LINE;                   // 0x3010 W N/A MMU Zap Cache Line
+	volatile unsigned int	MMU_INT_RAWSTA;                    // 0x3014 R/W 0x00000000 MMU Raw Interrupt Status
+	volatile unsigned int	MMU_INT_CLEAR;                      // 0x3018 W N/A MMU Interrupt Clear
+	volatile unsigned int	MMU_INT_MASK;                       // 0x301C R/W 0x00000000 MMU Interrupt Mask
+	volatile unsigned int	MMU_INT_STATUS;                     // 0x3020 R 0x00000000 MMU Interrup Status
+}GPUMMUCONFIG, *PGPUMMUCONFIG;
+
+/*******************************************************************************
+*	 5-4. GRPBUS Configuration Register Define   (Base Addr = 0xF0004000)
+********************************************************************************/
+//#define HwGRPBUS_BASE                         *(volatile unsigned long *)0xF0004000
+typedef struct _GPUGRPBUSCONFIG{
+	volatile unsigned int	GRPBUS_PWRDOWN;                     // 0x0000 R/W 0x00000000 Graphics bus power down
+	volatile unsigned int	GRPBUS_SWRESET;                     // 0x0004 R/W 0x00000000 Graphics bus software reset
+	volatile unsigned int	GRPBUS_MALI_IDLE;                   // 0x0008 R/W 0x00000002 Mali idle configration
+}GPUGRPBUSCONFIG, *PGPUGRPBUSCONFIG;
+
+/*******************************************************************************
+*	 5-5. GRPBUS BWRAP Register Define   (Base Addr = 0xF0005000)
+********************************************************************************/
+//#define HwGRPBUSBWRAP_BASE                      *(volatile unsigned long *)0xF0005000
+typedef struct _GPUGRPBUSBWRAP{
+	volatile unsigned int	GRPBUS_BWRAPCTRL;                   // 0x0000 R/W 0x00000000 Graphics bus bwrap control
+}GPUGRPBUSBWRAP, *PGPUGRPBUSBWRAP;
+
+
+
+
+#endif
Index: linux-2.6.29/arch/arm/mach-tcc8900/include/mach/bsp_cfg.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/include/mach/bsp_cfg.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,32 @@
+/****************************************************************************
+*   FileName    : bsp_cfg.h
+*   Description : 
+****************************************************************************
+*
+*   TCC Version : 1.0
+*   Copyright (c) Telechips, Inc.
+*   ALL RIGHTS RESERVED
+*
+****************************************************************************/
+
+#ifndef __BSP_CFG_H__
+#define __BSP_CFG_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+//loglevel option 
+#define TC_LOG_OPTION (TC_ERROR | TC_LOG ) 
+#define TC_LOG_LEVEL(a) ((TC_LOG_OPTION)&(a))
+
+#if defined(_LINUX_)
+#   define tc_debug pr_debug
+#endif
+
+//
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __BSP_CFG_H__
Index: linux-2.6.29/arch/arm/mach-tcc8900/include/mach/common.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/include/mach/common.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,36 @@
+/*
+ * linux/include/asm-arm/arch-tcc8900/common.h
+ *
+ * Author: <linux@telechips.com>
+ * Created: June 10, 2008
+ * Description: Header for code common to all Telechips TCC8900/TCC83x machines.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __ARCH_ARM_MACH_TCC8900_COMMON_H
+#define __ARCH_ARM_MACH_TCC8900_COMMON_H
+
+struct sys_timer;
+
+extern struct sys_timer tcc8900_timer;
+
+#endif /* __ARCH_ARM_MACH_TCC8900_COMMON_H */
Index: linux-2.6.29/arch/arm/mach-tcc8900/include/mach/debug-macro.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/include/mach/debug-macro.S	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,40 @@
+/* 
+ * linux/include/asm-arm/arch-tcc8900/debug-macro.S
+ *
+ * Based on:    linux/arch/arm/kernel/debug.S by Ben Dooks
+ * Author: <linux@telechips.com>
+ * Created: February 10, 2009
+ * Description: Debugging macro include header
+ *
+ * Copyright (C) 1994-1999 Russell King
+ * Copyright (C) 2009 Telechips 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+		.macro	addruart,rx
+		mrc	p15, 0, \rx, c1, c0
+		tst	\rx, #1					@ MMU enabled?
+		moveq	 \rx, #0xf0000000	@ physical base address
+		movne	 \rx, #0xf0000000	@ virtual base
+		orr	\rx, \rx, #0x00530000   @ debug port UART0
+		orr	\rx, \rx, #0x2000		@ debug port UART0 0xf00532000
+		.endm
+
+		.macro	senduart,rd,rx
+		strb	\rd, [\rx]
+		.endm
+
+		.macro	busyuart,rd,rx
+		.endm
+
+		.macro	waituart,rd,rx
+1001:
+		ldr \rd, [\rx, #0x14]
+		tst \rd, #0x20
+		
+		beq 1001b
+		.endm
Index: linux-2.6.29/arch/arm/mach-tcc8900/include/mach/dma.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/include/mach/dma.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,27 @@
+/*
+ * arch/arm/mach-tcc8900/include/mach/dma.h
+ *
+ * Written by <linux@telechips.com>
+ * Modified: March 10, 2009
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
Index: linux-2.6.29/arch/arm/mach-tcc8900/include/mach/entry-macro.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/include/mach/entry-macro.S	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,66 @@
+/*
+ * include/asm-arm/arch-tcc8900/entry-macro.S
+ *
+ * Author : <linux@telechips.com>
+ * Created: Feb 10, 2009
+ * Description: Low-level IRQ helper macros for OMAP-based platforms
+ *
+ * Copyright (C) 2009 Telechips
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+
+    .macro  disable_fiq
+    .endm 
+
+    .macro  get_irqnr_preamble, base, tmp
+    .endm
+
+    .macro  arch_ret_to_user, tmp1, tmp2
+    .endm
+
+    /* tcc8900 dependent code */
+    .macro  get_irqnr_and_base, irqnr, irqstat, base, tmp 
+        ldr \base, =0xF0401000     @ load base address of IRQ registers 
+
+        /* A intr */
+        ldr \irqstat, [\base, #0x50]    /* MIRQ0 */
+        cmp \irqstat, #0
+        bne 1001f /* jump to check A-intr */
+
+        /* B intr */
+        ldr \irqstat, [\base, #0x54]    /* MIRQ1 */
+        cmp \irqstat, #0
+        beq 1002f /* jump to exit macro. cannot find the intr number. (something wrong) */
+
+        /* get B-intr num */
+        mov \irqnr, #0                      @@ start here B
+1102:	ands \tmp, \irqstat, #1
+		moveq \irqstat, \irqstat, LSR #1
+		addeq \irqnr, \irqnr, #1
+		beq	1102b
+		add \irqnr, \irqnr, #32
+		b	1002f
+
+
+        /* get A-intr num */
+1001:	mov \irqnr, #0                      @@ start here A
+1101:	ands \tmp, \irqstat, #1
+		moveq \irqstat, \irqstat, LSR #1
+		addeq \irqnr, \irqnr, #1
+		beq	1101b
+		@@ work out which irq (if any) we got
+
+        @@ ADD Register #2
+	
+
+1002: /* exit */
+        @@ exit here, Z flag unset if IRQ
+    .endm
+
+    .macro irq_prio_table
+    .endm
Index: linux-2.6.29/arch/arm/mach-tcc8900/include/mach/globals.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/include/mach/globals.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,443 @@
+/****************************************************************************
+*   FileName    : globals.h
+*   Description : 
+****************************************************************************
+*
+*   TCC Version : 1.0
+*   Copyright (c) Telechips, Inc.
+*   ALL RIGHTS RESERVED
+*
+****************************************************************************/
+
+//using only global defines, macros.. etc - If you want using this file contact to RYU
+
+#ifndef __GLOBALS_H__
+#define __GLOBALS_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+//Log Level
+#define TC_ERROR 	0x00000001
+#define TC_LOG		0x00000002
+#define TC_TRACE	0x00000004
+#define	TC_DEBUG	0x00000008
+
+	//system info
+#define IOCTL_PLATFORM_TYPE                 (L"PLATFORM_TYPE")
+#define IOCTL_PLATFORM_OEM                  (L"PLATFORM_OEM")
+
+//------------------------------------------------------------------------------
+//  Define:  IOCTL_PROCESSOR_VENDOR/NAME/CORE
+//
+//  Defines the processor information
+//
+
+#define IOCTL_PROCESSOR_VENDOR              (L"Telechips")
+#define IOCTL_PROCESSOR_NAME                (L"TCC89X")
+#define IOCTL_PROCESSOR_CORE                (L"ARM11")
+
+//------------------------------------------------------------------------------
+//
+//  Define:  IOCTL_PROCESSOR_INSTRUCTION_SET
+//
+//  Defines the processor instruction set information
+//
+#define IOCTL_PROCESSOR_INSTRUCTION_SET     (0)
+#define IOCTL_PROCESSOR_CLOCK_SPEED	    266*1000
+
+//macro defines
+/************************************************************************************************
+*										 MACRO												   *
+************************************************************************************************/
+#ifndef BITSET
+#define BITSET(X, MASK) 			( (X) |= (unsigned int)(MASK) )
+#endif
+#ifndef BITSCLR
+#define BITSCLR(X, SMASK, CMASK)	( (X) = ((((unsigned int)(X)) | ((unsigned int)(SMASK))) & ~((unsigned int)(CMASK))) )
+#endif
+#ifndef BITCSET
+#define BITCSET(X, CMASK, SMASK)	( (X) = ((((unsigned int)(X)) & ~((unsigned int)(CMASK))) | ((unsigned int)(SMASK))) )
+#endif
+#ifndef BITCLR
+#define BITCLR(X, MASK) 			( (X) &= ~((unsigned int)(MASK)) )
+#endif
+#ifndef BITXOR
+#define BITXOR(X, MASK) 			( (X) ^= (unsigned int)(MASK) )
+#endif
+#ifndef ISZERO
+#define ISZERO(X, MASK) 			(  ! (((unsigned int)(X)) & ((unsigned int)(MASK))) )
+#endif
+
+#ifndef ENABLE
+#define ENABLE 1
+#endif
+#ifndef DISABLE
+#define DISABLE 0
+#endif
+
+#ifndef ON
+#define ON		1
+#endif
+#ifndef OFF
+#define OFF 	0
+#endif
+
+#ifndef FALSE
+#define FALSE	0
+#endif
+#ifndef TRUE
+#define TRUE	1
+#endif
+
+#define HwVMT_SZ(X) 							(((X)-1)*Hw12)
+	#define SIZE_4GB								32
+	#define SIZE_2GB								31
+	#define SIZE_1GB								30
+	#define SIZE_512MB								29
+	#define SIZE_256MB								28
+	#define SIZE_128MB								27
+	#define SIZE_64MB								26
+	#define SIZE_32MB								25
+	#define SIZE_16MB								24
+	#define SIZE_8MB								23
+	#define SIZE_4MB								22
+	#define SIZE_2MB								21
+	#define SIZE_1MB								20
+	#define HwVMT_REGION_AP_ALL 				(Hw11+Hw10)
+	#define HwVMT_DOMAIN(X) 					((X)*Hw5)
+	#define HwVMT_REGION_EN 					Hw9 							// Region Enable Register
+	#define HwVMT_CACHE_ON						Hw3 							// Cacheable Register
+	#define HwVMT_CACHE_OFF 					HwZERO
+	#define HwVMT_BUFF_ON							Hw2 							// Bufferable Register
+	#define HwVMT_BUFF_OFF							HwZERO
+
+	#define HwVMT_REGION0_EN						Hw9 							// Region Enable Register
+	#define HwVMT_REGION0_CA						Hw3 							// Cacheable Register
+	#define HwVMT_REGION0_BU						Hw2 							// Bufferable Register
+
+/************************************************************************************************
+*										 ENUM												   *
+************************************************************************************************/
+/***************************************CLOCK****************************************************/
+	enum
+	{
+		IDLE_PRIORITY = 0, // Don't Return IDLE_PRIORITY
+		LOW_PRIORITY,
+		MID_PRIORITY,
+		HIGH_PRIORITY,
+		MAX_PRIORITY,
+	
+		CLOCK_PRIORITY_NUM,
+	//}stCKC_PRIORITY;
+	};
+
+//CKC Enum
+	enum{ /* CLKCTRL Clock Source */
+		DIRECTPLL0=0,
+		DIRECTPLL1,
+		DIRECTPLL2,
+		DIRECTPLL3,
+		DIRECTXIN,
+		DIVIDPLL0,
+		DIVIDPLL1,
+		DIRECTXTIN,
+	};
+	
+	enum{ /* Peri. Clock Source */
+		PCDIRECTPLL0=0,
+		PCDIRECTPLL1,
+		PCDIRECTPLL2,
+		PCDIRECTPLL3,
+		PCDIRECTXIN,
+		PCDIVIDPLL0,
+		PCDIVIDPLL1,
+		PCDIVIDPLL2,
+		PCDIVIDPLL3,
+		PCDIRECTXTIN,
+		PCEXITERNAL, // 10
+		PCDIVIDXIN_HDMITMDS,
+		PCDIVIDXTIN_HDMIPCLK,
+		PCHDMI, 	// 27Mhz
+		PCSATA, 	// 25Mhz
+		PCUSBPHY,	// 48Mhz
+	};
+	
+	enum{ /* Peri. Clock Source */
+		PDCO = 0,
+		PDIVIDER,
+	};
+	
+	enum {/* Peri. Name */
+		PERI_TCX = 0, 
+		PERI_TCT, 
+		PERI_TCZ, 
+		PERI_LCD0,	
+		PERI_LCD1,	
+		PERI_LCDSI, 
+		PERI_CIFMC,  
+		PERI_CIFSC, 
+		PERI_OUT0, 
+		PERI_OUT1, 
+		PERI_HDMI, 
+		PERI_USB11H, 
+		PERI_SDMMC0, 
+		PERI_MSTICK,  
+		PERI_I2C, 
+		PERI_UART0,  
+		PERI_UART1,  
+		PERI_UART2,  
+		PERI_UART3,  
+		PERI_UART4,  
+		PERI_UART5,  
+		PERI_GPSB0, 
+		PERI_GPSB1, 
+		PERI_GPSB2, 
+		PERI_GPSB3, 
+		PERI_GPSB4, 
+		PERI_GPSB5, 
+		PERI_ADC,  
+		PERI_SPDIF,  
+		PERI_EHI0, 
+		PERI_EHI1, 
+		PERI_AUD,  
+		PERI_CAN,  
+		PERI_Reserved0, 
+		PERI_SDMMC1, 
+		PERI_Reserved1, 
+		PERI_DAI,  
+	};
+	
+	enum{/*for PWROFF Register*/
+		PMU_VIDEODAC = 0,
+		PMU_HDMIPHY,
+		PMU_LVDSPHY,
+		PMU_USBNANOPHY,
+		PMU_SATAPHY,
+		PMU_MEMORYBUS,
+		PMU_VIDEOBUS,
+		PMU_DDIBUS,
+		PMU_GRAPHICBUS,
+		PMU_IOBUS,
+	};
+	
+	enum{/* for SWRESET */
+		RESET_CPU = 0,
+		RESET_DDIBUS,
+		RESET_MEMBUS,
+		RESET_GRAPBUS,
+		RESET_IOBUS,
+		RESET_VIDEOBUS,
+		RESET_VIDEOCORE,
+		RESET_SMU,
+	};
+
+	enum {/* clock divider (div+1) */
+		CLKDIV0 = 0,
+		CLKDIV2 ,
+		CLKDIV3 ,
+		CLKDIV4 ,
+		CLKDIVNONCHANGE,
+	};
+	
+	enum {
+		CLKCTRL0 = 0,	//FCORE_CPU
+		CLKCTRL1,		//FBUS_DDI
+		CLKCTRL2,		//FMEM_BUS
+		CLKCTRL3,		//FBUS_GRP
+		CLKCTRL4,		//FBUS_IOB
+		CLKCTRL5,		//FBUS_VBUS
+		CLKCTRL6,		//FBUS_VCODEC
+		CLKCTRL7,		//FBUS_SMU
+	};
+	
+	enum {
+		NORMAL_MD = 0,
+		DYNAMIC_MD,
+	};
+	
+	enum {
+		RB_USB11H	= 0,
+		RB_USB20OTG, 
+		RB_IDECONTROLLER, 
+		RB_DMACONTROLLER , 
+		RB_SDMMCCONTROLLER ,
+		RB_SATAHCONTROLLER , 
+		RB_MEMORYSTICKCONTROLLER , 
+		RB_I2CCONTROLLER ,
+		RB_NFCCONTROLLER ,
+		RB_EXTHCONTROLLER0 ,  
+		RB_EXTHCONTROLLER1 , //10
+		RB_UARTCONTROLLER0 ,
+		RB_UARTCONTROLLER1 ,
+		RB_UARTCONTROLLER2 ,
+		RB_UARTCONTROLLER3 ,
+		RB_UARTCONTROLLER4 ,
+		RB_UARTCONTROLLER5 ,
+		RB_GPSBCONTROLLER0 ,
+		RB_GPSBCONTROLLER1 ,
+		RB_GPSBCONTROLLER2 ,
+		RB_GPSBCONTROLLER3 , //20
+		RB_GPSBCONTROLLER4 ,
+		RB_GPSBCONTROLLER5 ,
+		RB_DAICDIFCONTROLLER ,
+		RB_ECCCONTROLLER ,
+		RB_SPDIFTXCONTROLLER,
+		RB_RTCCONTROLLER ,
+		RB_TSADCCONTROLLER,
+		RB_GPSCONTROLLER ,
+		RB_RESERVEDCONTROLLER, 
+		RB_CANCONTROLLER,
+		RB_ADMACONTROLLER,	// 31
+	
+		RB_MPE_FECCONTROLLER, 
+		RB_TSIFCONTROLLER,
+		RB_SRAMCONTROLLER,
+		
+		RB_ALLPERIPERALS,
+	
+	};
+	
+	enum{ /* Fmbus Step */
+		FMBUS_141Mhz=0,
+		FMBUS_145Mhz,
+		FMBUS_150Mhz,
+		FMBUS_160Mhz,
+		FMBUS_170Mhz,
+		FMBUS_180Mhz,
+		FMBUS_190Mhz,
+		FMBUS_200Mhz,
+		FMBUS_210Mhz,
+		FMBUS_220Mhz,
+		FMBUS_230Mhz,
+		FMBUS_240Mhz,
+		FMBUS_250Mhz,
+		FMBUS_260Mhz,
+		FMBUS_270Mhz,
+		FMBUS_280Mhz,
+		FMBUS_290Mhz,
+		FMBUS_300Mhz,
+		FMBUS_312Mhz,
+		FMBUS_320Mhz,
+		FMBUS_330Mhz,
+	
+		FMBUS_STEPMAX,
+	};
+	
+	enum{ /* ddi Power Down Field  */
+		DDIPWDN_CIF = 0,
+		DDIPWDN_VIQE,
+		DDIPWDN_LCDC0,
+		DDIPWDN_LCDC1,
+		DDIPWDN_LCDSI,
+		DDIPWDN_MSCL0,
+		DDIPWDN_MSCL1,
+		DDIPWDN_DDIC,
+		DDIPWDN_HDMI,
+		DDIPWDN_STEPMAX,
+		};
+
+		enum{ /* ETC Power Down Field  */
+		ETC_USBPHYOFF = 0,
+		ETC_USBPHYON,
+		ETC_3DGPUOFF, 
+		ETC_3DGPUON, 
+		ETC_OVERLAYMIXEROFF, 
+		ETC_OVERLAYMIXERON ,
+		
+		ETC_STEPMAX,
+
+		};
+
+#define	ETCMASK_USBPHYOFF  		0x00000001
+#define   ETCMASK_USBPHYON    		0x00000002
+#define	ETCMASK_3DGPUOFF  		0x00000004
+#define   ETCMASK_3DGPUON    		0x00000008
+#define	ETCMASK_OVERLAYMIXEROFF  0x00000010
+#define   ETCMASK_OVERLAYMIXERON    0x00000020
+	
+/***************************************Interrup****************************************************/
+enum {
+	IRQ_TC0	=0,	// 0 	0x0  Timer 0 interrupt enable 
+	IRQ_TC1,		// 1 	0x0  Timer 1 interrupt enable 
+	IRQ_SMUI2C,  // 2   0x0	SMU_I2C interrupt enable 
+	IRQ_EI0,		// 3 	0x0  External interrupt 0 enable 
+	IRQ_EI1,		// 4 	0x0  External interrupt 1 enable 
+	IRQ_EI2,		// 5 	0x0  External interrupt 2 enable 
+	IRQ_EI3,		// 6 	0x0  External interrupt 3 enable 
+	IRQ_EI4,		// 7 	0x0  External interrupt 4 enable 
+	IRQ_EI5,		// 8 	0x0  External interrupt 5 enable 
+	IRQ_EI6,		// 9 	0x0  External interrupt 6 enable 
+	IRQ_EI7,  	// 10  0x0  External interrupt 7 enable 
+	IRQ_EI8,  	// 11  0x0  External interrupt 8 enable 
+	IRQ_EI9,  	// 12  0x0  External interrupt 9 enable 
+	IRQ_EI10,  	// 13  0x0  External interrupt 10 enable 
+	IRQ_EI11,  	// 14  0x0  External interrupt 11 enable 
+	IRQ_SC0,  	// 15  0x0  Mem-to-Mem scaler 0 interrupt enable 
+	IRQ_SC1,  	// 16  0x0  Mem-to-Mem scaler 0 interrupt enable 
+	IRQ_CAM,  	// 17  0x0  Camera interrupt enable 
+	IRQ_LCD0,  	// 18  0x0  LCD controller 0 interrupt enable 
+	IRQ_LCD1,  	// 19  0x0  LCD controller 1 interrupt enable 
+	IRQ_VIPET, 	// 20  0x0 VIPET controller interrupt enable Note: the interrupt request signal is active low. 21	JPGE  RW  0x0  JPEG Encoder interrupt enable 
+	IRQ_JPGE,  	// 21  0x0  JPEG Decoder interrupt enable 
+	IRQ_JPGD,  	// 22  0x0  JPEG Decoder interrupt enable 
+	IRQ_VCDC,  	// 23  0x0  Video CODEC interrupt enable 
+	IRQ_3DPP,  	// 24  0x0  3D Pixel Processor interrupt enable 
+	IRQ_3DGP,  	// 25  0x0  3D Geometry Processor interrupt enable 
+	IRQ_3DMMU,  	// 26  0x0	3D MMU interrupt enable 
+	IRQ_G2D,  	// 27  0x0  Graphic Engine 2D Hardware Interrupt Enable 
+	IRQ_TSADC,  	// 28  0x0	TSADC interrupt enable 
+	IRQ_DMA,  	// 29  0x0  DMA controller interrupt enable 
+	IRQ_ECC,  	// 30  0x0  ECC interrupt enable 
+	IRQ_EHI0,  	// 31  0x0  External interrupt 0 enable 
+	IRQ_EHI1,  	// 32  0x0  External interrupt 1 enable 
+	IRQ_CAN,  	// 33  0x0  CAN interrupt enable 
+	IRQ_HDMI, 	// 34  0x0  HDMI interrupt enable 
+	IRQ_SATA,  	// 35  0x0  SATA Host interrupt enable 
+	IRQ_GPSB,  	// 36  0x0  GPSB Interrupt Enable 
+	IRQ_HDD,  	// 37  0x0  HDD controller interrupt enable 
+	IRQ_I2C,  	// 38  0x0  I2C interrupt enable 
+	IRQ_MPEFEC, 	// 39  0x0	MPEFEC interrupt enable 
+	IRQ_MS,		// 40	0x0  Memory Stick interrupt enable 
+	IRQ_NFC, 	// 41  0x0  Nand flash controller interrupt enable 
+	IRQ_RMT,  	// 42  0x0  Remote Control interrupt enable 
+	IRQ_RTC,  	// 43  0x0  RTC interrupt enable 
+	IRQ_SD0,  	// 44  0x0  SD/MMC 0 interrupt enable 
+	IRQ_SD1,  	// 45  0x0  SD/MMC 1 interrupt enable 
+	IRQ_SPDTX,  	// 46  0x0	SPDIF transmitter interrupt enable 
+	IRQ_UART,  	// 47  0x0  UART interrupt enable 
+	IRQ_UOTG,  	// 48  0x0  USB 2.0 OTG interrupt enable 
+	IRQ_U11H,  	// 49  0x0  USB 1.1 host interrupt enable 
+	IRQ_GPS0,  	// 50  0x0  GPS RTC expired interrupt enable 
+	IRQ_GPS1,  	// 51  0x0  GPS TCXO expired interrupt enable 
+	IRQ_GPS2,  	// 52  0x0  GPS AGPS interrupt enable 
+	IRQ_TSIF0,  	// 53  0x0	TS interface 0 interrupt enable 
+	IRQ_TSIF1,  	// 54  0x0	TS interface 1 interrupt enable 
+	IRQ_CDRX,  	// 55  0x0  CDIF receive interrupt enable 
+	IRQ_DAIRX,  	// 56  0x0	DAI receive interrupt enable 
+	IRQ_DAITX,  	// 57  0x0	DAI transmit interrupt enable 
+	IRQ_ADMA,  	// 58  0x0  AUDIO DMA interrupt enable 
+	IRQ_AUDIO,  	// 59  0x0	AUDIO interrupt enable 
+	IRQ_APMU, 	// 60 0x0 ARM System Metrics interrupt enable Note: the interrupt request signal is active low. 
+	IRQ_AIRQ, 	// 61 0x0 Non secure ARM DMA interrupt enable Note: the interrupt request signal is active low. 
+	IRQ_ASIRQ, 	// 62 0x0 Secure ARM DMA select interrupt enable Note: the interrupt request signal is active low. 
+	IRQ_AEIRQ, 	// 63 0x0 Not maskable error ARM DMA interrupt enable Note: the interrupt request signal is active low. 
+};
+
+typedef struct _rtctime { 
+  unsigned int wYear; 
+  unsigned int wMonth; 
+  unsigned int wDayOfWeek; 
+  unsigned int wDay; 
+  unsigned int wHour; 
+  unsigned int wMinute; 
+  unsigned int wSecond; 
+  unsigned int wMilliseconds; 
+} rtctime;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __GLOBALS_H__
Index: linux-2.6.29/arch/arm/mach-tcc8900/include/mach/gpio.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/include/mach/gpio.h	2010-04-07 13:00:43.000000000 -0400
@@ -0,0 +1,27 @@
+/*
+ * arch/arm/mach-tcc8900/include/mach/gpio.h
+ *
+ * Written by <linux@telechips.com>
+ * Modified: March 10, 2009
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
Index: linux-2.6.29/arch/arm/mach-tcc8900/include/mach/hardware.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/include/mach/hardware.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,65 @@
+/*
+ * linux/include/asm-arm/arch-tcc8900/hardware.h
+ *
+ * Rewritten by:    <linux@telechips.com>
+ * Modifiedd: June 10, 2008
+ * Description: Hardware definitions for TCC8900 processors and boards
+ * Author: RidgeRun, Inc. Greg Lonnon <glonnon@ridgerun.com>
+ * Reorganized for Linux-2.6 by Tony Lindgren <tony@atomide.com>
+ *                          and Dirk Behme <dirk.behme@de.bosch.com>
+ *
+ * Copyright (C) 2001 RidgeRun, Inc.
+ * Copyright (C) 2008-2009 Telechips 
+ *
+ * NOTE: Please put device driver specific defines into a separate header
+ *	 file for each driver.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __ASM_ARCH_TCC8900_HARDWARE_H
+#define __ASM_ARCH_TCC8900_HARDWARE_H
+
+#include <asm/sizes.h>
+#ifndef __ASSEMBLER__
+#include <asm/types.h>
+#endif
+#include <mach/io.h>
+
+/*
+ * ----------------------------------------------------------------------------
+ * Clocks
+ * ----------------------------------------------------------------------------
+ */
+#define CLKGEN_REG_BASE		(0xfffece00)
+#define ARM_CKCTL		(CLKGEN_REG_BASE + 0x0)
+#define ARM_IDLECT1		(CLKGEN_REG_BASE + 0x4)
+#define ARM_IDLECT2		(CLKGEN_REG_BASE + 0x8)
+#define ARM_EWUPCT		(CLKGEN_REG_BASE + 0xC)
+#define ARM_RSTCT1		(CLKGEN_REG_BASE + 0x10)
+#define ARM_RSTCT2		(CLKGEN_REG_BASE + 0x14)
+#define ARM_SYSST		(CLKGEN_REG_BASE + 0x18)
+#define ARM_IDLECT3		(CLKGEN_REG_BASE + 0x24)
+
+/* DPLL control registers */
+#define DPLL_CTL		(0xfffecf00)
+
+#endif	/* __ASM_ARCH_TCC8900_HARDWARE_H */
Index: linux-2.6.29/arch/arm/mach-tcc8900/include/mach/io.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/include/mach/io.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,73 @@
+/*
+ * linux/include/asm-arm/arch-tcc89x/io.h
+ *
+ * Based on:    linux/include/asm-arm/arch-sa1100/io.h
+ * Author : <linux@telechips.com>
+ * Description: IO definitions for TCC8900 processors and boards
+ *
+ * Copyright (C) 1997-1999 Russell King
+ * Copyright (C) 2008-2009 Telechips 
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifndef __ASM_ARM_ARCH_IO_H__
+#define __ASM_ARM_ARCH_IO_H__
+
+#include <mach/hardware.h>
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+/*
+ * We don't actually have real ISA nor PCI buses, but there is so many
+ * drivers out there that might just work if we fake them...
+ */
+#define __io(a)             ((void __iomem *)(PCIO_BASE + (a)))
+#define __mem_pci(a)        (a)
+
+/*
+ * ----------------------------------------------------------------------------
+ * I/O mapping
+ * ----------------------------------------------------------------------------
+ */
+#define PCIO_BASE	0
+
+#define IO_PHYS		0xF0000000
+#define IO_OFFSET	0x00000000	/* Virtual IO = 0xf0000000 */
+#define IO_SIZE		0x100000
+#define IO_VIRT		(IO_PHYS - IO_OFFSET)
+#define IO_ADDRESS(pa)	((pa) - IO_OFFSET)
+#define io_p2v(pa)	((pa) - IO_OFFSET)
+#define io_v2p(va)	((va) + IO_OFFSET)
+
+/* Physical value to Virtual Address */
+#define tcc_p2v(pa)	((unsigned int)(&pa) - IO_OFFSET)
+
+#define tcc_readb(a)		(*(volatile unsigned char  *)IO_ADDRESS(a))
+#define tcc_readw(a)		(*(volatile unsigned short *)IO_ADDRESS(a))
+#define tcc_readl(a)		(*(volatile unsigned int   *)IO_ADDRESS(a))
+
+#define tcc_writeb(v,a)		(*(volatile unsigned char  *)IO_ADDRESS(a) = (v))
+#define tcc_writew(v,a)		(*(volatile unsigned short *)IO_ADDRESS(a) = (v))
+#define tcc_writel(v,a)		(*(volatile unsigned int   *)IO_ADDRESS(a) = (v))
+
+#endif	/*__ASM_ARM_ARCH_IO_H__*/
Index: linux-2.6.29/arch/arm/mach-tcc8900/include/mach/ioctl_ckcstr.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/include/mach/ioctl_ckcstr.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,86 @@
+/****************************************************************************
+ *   FileName    : ioctl_ckcstr.h
+ *   Description : 
+ ****************************************************************************
+*
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+*
+ ****************************************************************************/
+
+
+/************************************************************************************************
+*                                    Revision History                                           *
+*                                                                                               *
+* Version : 1.0    : 2009, 2, 04                                                                *
+************************************************************************************************/
+
+#ifndef __IOCTL_STR_H__
+#define __IOCTL_STR_H__
+
+
+//#include "bsp.h"
+
+
+// For CKC Controller
+typedef struct _stckcioctl{
+	unsigned int ioctlcode;
+	//Reset or bus Enable name
+	unsigned int prbname; 
+	//Peri Clock
+	unsigned int pckcname; 
+	unsigned int pckcenable; 
+	unsigned int pckcsource; 
+	unsigned int pckcfreq;
+	//PLL Cllock
+	unsigned int pllchannel;
+	unsigned int pllvalue;
+	unsigned int P;
+	unsigned int M;
+	unsigned int S;
+	//CPU Cllock
+	unsigned int cpuvalue; 
+	//BUS Cllock
+	unsigned int busvalue;
+	//mode 
+	unsigned int mode; // Enable, Disable, ahalf, athird
+
+	unsigned int priority;
+
+	unsigned int cpudivider;
+	unsigned int pmuoffname;
+	
+	unsigned int bspmax;	
+	//Fbus Clock
+	unsigned int fbusname;
+	unsigned int fbusenable; 
+	unsigned int fbussource; 
+	unsigned int fbusfreq;
+
+	//DDI PWDN
+	unsigned int ddipdname;
+
+	//ETC Block
+	unsigned int etcblock;
+	
+	
+}stckcioctl;
+
+
+typedef struct _stckcinfo{
+	unsigned int currentbusfreq;
+	unsigned int currentsysfreq;
+	unsigned int currentcpufreq;
+	int pckcfreq; //return etc frequency
+	unsigned int validpll[30];
+	int retVal;
+	unsigned int currentpriority;
+
+	unsigned int state;
+
+	int fbusfreq;
+	
+}stckcinfo;
+
+#endif /* __IOCTL_STR_H__ */
Index: linux-2.6.29/arch/arm/mach-tcc8900/include/mach/irqs.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/include/mach/irqs.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,158 @@
+/* linux/include/asm-arm/arch-tcc8900/irqs.h
+ *
+ * Author: <linux@telechips.com>
+ * Created: Mach 10, 2009
+ * Copyright (C) 2009- Telechips
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef __ASM_ARCH_TCC_IRQS_H
+#define __ASM_ARCH_TCC_IRQS_H
+
+/*
+ * IRQ numbers for interrupt handler
+ */
+
+#define INT_TC0    	0
+#define INT_TC1    	1
+#define INT_SMUI2C	2
+#define INT_EI0		3
+#define INT_EI1		4
+#define INT_EI2		5
+#define INT_EI3		6
+#define INT_EI4		7
+#define INT_EI5		8
+#define INT_EI6		9	
+#define INT_EI7		10
+#define INT_EI8		11
+#define INT_EI9		12
+#define INT_EI10	13
+#define INT_EI11	14
+#define INT_SC0		15
+#define INT_SC1		16
+#define INT_CAM		17
+#define INT_LCD0	18
+#define INT_LCD1	19
+#define INT_VIPET	20
+#define INT_JPGE	21
+#define INT_JPGD	22
+#define INT_VCDC	23
+#define INT_3DPP	24
+#define INT_3DGP	25
+#define INT_3DMMU	26
+#define INT_G2D		27
+#define INT_TSADC	28
+#define INT_DMA		29
+#define INT_ECC		30
+#define INT_EHI0	31
+#define INT_EHI1	32
+#define INT_CAN		33
+#define INT_HDMI	34
+#define INT_SATA	35
+#define INT_GPSB	36
+#define INT_HDD		37
+#define INT_I2C		38
+#define INT_MPEFEC	39
+#define INT_MS		40
+#define INT_NFC		41
+#define INT_RMT		42
+#define INT_RTC		43
+#define INT_SD0		44
+#define INT_SD1		45
+#define INT_SPDTX	46
+#define INT_UART	47
+#define INT_UOTG	48
+#define INT_U11H	49
+#define INT_GPS0	50
+#define INT_GPS1	51
+#define INT_GPS2	52
+#define INT_TSIF0	53
+#define INT_TSIF1	54
+#define INT_CDRX	55
+#define INT_DAIRX	56
+#define INT_DAITX	57
+#define INT_ADMA	58
+#define INT_AUDIO	59
+#define INT_APMU	60
+#define INT_AIRQ	61
+#define INT_ASIRQ	62
+#define INT_AEIRQ	63
+
+/*
+ * IRQ_UT numbers for UART[0:5]
+ */
+#define INT_UT_BASE         64
+#define INT_UART0           (0 + INT_UT_BASE)
+#define INT_UART1           (1 + INT_UT_BASE) 
+#define INT_UART2           (2 + INT_UT_BASE) 
+#define INT_UART3           (3 + INT_UT_BASE) 
+#define INT_UART4           (4 + INT_UT_BASE) 
+#define INT_UART5           (5 + INT_UT_BASE) 
+
+/*
+ * GPSB-IRQ numbers for GPSB0 & GPSB0
+ */
+#define INT_GPSB0_BASE      70          
+#define INT_GPSB0_DMA       (0 + INT_GPSB0_BASE)          
+#define INT_GPSB1_DMA       (1 + INT_GPSB0_BASE)
+#define INT_GPSB2_DMA       (2 + INT_GPSB0_BASE)
+
+#define INT_GPSB0_CORE      (3 + INT_GPSB0_BASE)
+#define INT_GPSB1_CORE      (4 + INT_GPSB0_BASE) 
+#define INT_GPSB2_CORE      (5 + INT_GPSB0_BASE) 
+#define INT_GPSB3_CORE      (6 + INT_GPSB0_BASE) 
+#define INT_GPSB4_CORE      (7 + INT_GPSB0_BASE) 
+#define INT_GPSB5_CORE      (8 + INT_GPSB0_BASE) 
+
+/*
+ * DMA-IRQ numbers
+ */
+#define INT_DMA0_BASE       79 
+#define INT_DMA0_CH0        (0 + INT_DMA0_BASE) 
+#define INT_DMA0_CH1        (1 + INT_DMA0_BASE) 
+#define INT_DMA0_CH2        (2 + INT_DMA0_BASE) 
+#define INT_DMA1_CH0        (3 + INT_DMA0_BASE) 
+#define INT_DMA1_CH1        (4 + INT_DMA0_BASE) 
+#define INT_DMA1_CH2        (5 + INT_DMA0_BASE) 
+#define INT_DMA2_CH0        (6 + INT_DMA0_BASE) 
+#define INT_DMA2_CH1        (7 + INT_DMA0_BASE) 
+#define INT_DMA2_CH2        (8 + INT_DMA0_BASE)
+#define INT_DMA3_CH0        (9 + INT_DMA0_BASE) 
+#define INT_DMA3_CH1        (10 + INT_DMA0_BASE) 
+#define INT_DMA3_CH2        (11 + INT_DMA0_BASE) 
+
+/*
+ * TC0-IRQ numbers for Timer/Counter 0~5
+ */
+#define INT_TC0_BASE		91
+#define INT_TC0_TI0			(0 + INT_TC0_BASE)
+#define INT_TC0_TI1			(1 + INT_TC0_BASE)
+#define INT_TC0_TI2			(2 + INT_TC0_BASE)
+#define INT_TC0_TI3			(3 + INT_TC0_BASE)
+#define INT_TC0_TI4			(4 + INT_TC0_BASE)
+#define INT_TC0_TI5			(5 + INT_TC0_BASE)
+
+/*
+ * NR_IRQ:
+ */
+#define NR_IRQS ((INT_AEIRQ + 1)\
+                 + (INT_UART5 - INT_UT_BASE + 1)\
+                 + (INT_GPSB5_CORE - INT_GPSB0_BASE + 1)\
+                 + (INT_DMA3_CH2 - INT_DMA0_BASE + 1)\
+                 + (INT_TC0_TI5 - INT_TC0_BASE + 1))
+
+#endif  /* ASM_ARCH_TCC_IRQS_H */
+
Index: linux-2.6.29/arch/arm/mach-tcc8900/include/mach/memory.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/include/mach/memory.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,116 @@
+/*
+ * linux/include/asm-arm/arch-tcc8900/memory.h
+ *
+ * Based on:    linux/include/asm-arm/arch-intergrator/memory.h
+ * Author:  Greg Lonnon <glonnon@ridgerun.com>
+ * Rewritten by: <linux@telechips.com>
+ * Modified: Feb 10, 2009
+ * Description: Memory map for TCC8900 
+ *
+ * Copyright (C) 1999 ARM Limited
+ * Copyright (C) 2000 RidgeRun, Inc.
+ * Copyright (C) 2008-2009 Telechips 
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+/*
+ * Physical DRAM offset.
+ */
+#define PHYS_OFFSET		UL(0x40200000)
+
+/*
+ * Free Mem Size
+ * mem=[size]
+ *      size = Total RAM size - Total Reserved RAM size
+ *      Total RAM size = CONFIG_RAM_XXXMB
+ *      Totla Reserved RAM size = FB reserved size + Video Codec reserved size
+ */
+#define CAL_VPU_OFFSET(ram_size, vpu_size) ( (0x40000000+ram_size) - (vpu_size*1024*1024) )
+#if defined(CONFIG_RAM_128MB)
+	#define TCC_RAM_TOTAL_SIZE 0x08000000
+
+	#if defined(CONFIG_HD720p_LEVEL41)
+		#define TCC_MEM_SIZE " mem=86M"
+		#define TCC_VPU_SIZE 24
+	#elif defined(CONFIG_HD720p_LEVEL51)
+		#define TCC_MEM_SIZE " mem=60M"
+		#define TCC_VPU_SIZE 50
+	#elif defined(CONFIG_HD1080p_LEVEL41)
+		#define TCC_MEM_SIZE " mem=66M"
+		#define TCC_VPU_SIZE 44
+	#elif defined(CONFIG_HD1080p_LEVEL51)
+		#error "[not support HD1080p_LEVEL51] Check menuconfig->System Type->A/V Spec"
+	#else
+		#error "[undefine A/V spec] Check menuconfig->System Type->A/V Spec"
+	#endif
+
+
+#elif defined(CONFIG_RAM_256MB)
+	#define TCC_RAM_TOTAL_SIZE 0x10000000
+
+	#if defined(CONFIG_HD720p_LEVEL41)
+		#define TCC_MEM_SIZE " mem=214M"
+		#define TCC_VPU_SIZE 24
+	#elif defined(CONFIG_HD720p_LEVEL51)
+		#define TCC_MEM_SIZE " mem=188M"
+		#define TCC_VPU_SIZE 50
+	#elif defined(CONFIG_HD1080p_LEVEL41)
+		#define TCC_MEM_SIZE " mem=194M"
+		#define TCC_VPU_SIZE 44
+	#elif defined(CONFIG_HD1080p_LEVEL51)
+		#define TCC_MEM_SIZE " mem=138M"
+		#define TCC_VPU_SIZE 100
+	#else
+		#error "[undefine A/V spec] Check menuconfig->System Type->A/V Spec"
+	#endif
+
+#else
+	#error "[undefine MEM size] Check menuconfig->System Type->RAM Spec"
+#endif
+
+#define TCC_VPU_OFFSET CAL_VPU_OFFSET(TCC_RAM_TOTAL_SIZE, TCC_VPU_SIZE) 
+
+/*
+ * Frame buffer memory define
+ */
+#define TCC_FB0_SIZE	(8*1024*1024)	// 8MB
+#define TCC_FB1_SIZE	(4*1024*1024)	// 4MB
+#define TCC_FB2_SIZE	(4*1024*1024)	// 4MB
+#define TCC_FB_OFFSET	(TCC_VPU_OFFSET - (TCC_FB0_SIZE+TCC_FB1_SIZE+TCC_FB2_SIZE))
+
+/*
+ * Size of DMA-consistent memory region.  Must be multiple of 2M,
+ * between 2MB and 14MB inclusive.
+ */
+#ifndef CONSISTENT_DMA_SIZE
+#define CONSISTENT_DMA_SIZE (SZ_2M)
+#endif
+
+
+#define __virt_to_bus(x)	__virt_to_phys(x)
+#define __bus_to_virt(x)	__phys_to_virt(x)
+
+#endif
+
Index: linux-2.6.29/arch/arm/mach-tcc8900/include/mach/ohci.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/include/mach/ohci.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,241 @@
+/*
+ * linux/include/asm-arm/arch-tcc79x/ohci.h 
+ *
+ * Author:  <linux@telechips.com>
+ * Created: June 10, 2008
+ * Description: ohci definition for TCC79x
+ *
+ * Copyright (C) 2008-2009 Telechips 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see the file COPYING, or write
+ * to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef ASMARM_ARCH_OHCI_H
+#define ASMARM_ARCH_OHCI_H
+
+
+// fields and bits for uhcrev:      HCI Spec Revision
+#define USBOHCI_UHCREV_OHCISPEC1_0_A        0x10
+
+// fields and bits for uhchcon:     Control register
+#define USBOHCI_UHCCON_CBSR_MASK            ( 0x3u << 0 )
+
+#define USBOHCI_UHCCON_CBSR_PLE             ( 2u   << 2 )
+#define USBOHCI_UHCCON_CBSR_IE              ( 3u   << 2 )
+#define USBOHCI_UHCCON_CBSR_CLE             ( 4u   << 2 )
+#define USBOHCI_UHCCON_CBSR_BLE             ( 5u   << 2 )
+
+#define USBOHCI_UHCCON_HCFS_MASK            ( 0x3u << 6 )
+
+#define USBOHCI_UHCCON_CBSR_IR              ( 8u   << 2 )
+#define USBOHCI_UHCCON_CBSR_RWC             ( 9u   << 2 )
+#define USBOHCI_UHCCON_CBSR_RWE             ( 10u  << 2 )
+
+// for the HCFS field
+#define USBOHCI_UHCCON_HCFS_USBRESET        ( 0u << 6 )
+#define USBOHCI_UHCCON_HCFS_USBRESUME       ( 1u << 6 )
+#define USBOHCI_UHCCON_HCFS_USBOPERATIONAL  ( 2u << 6 )
+#define USBOHCI_UHCCON_HCFS_USBSUSPEND      ( 3u << 6 )
+
+
+// fields and bits for uhccoms:     Command Status
+#define USBOHCI_UHCCOMS_HCR                 ( 1u   << 0)
+#define USBOHCI_UHCCOMS_CLF                 ( 1u   << 1 )
+#define USBOHCI_UHCCOMS_BLF                 ( 1u   << 2 )
+#define USBOHCI_UHCCOMS_OCR                 ( 1u   << 3 )
+
+#define USBOHCI_UHCCOMS_SOC_MASK            ( 0x3u << 16 )
+
+
+
+// fields and bits for uhcints:     Interrupt Status
+// fields and bits for uhcinte:     Interrupt Enable Control register
+// fields and bits for uhcintd:     Interrupt Disable Control register
+#define USBOHCI_UHCINT_SO                   ( 1u   << 0 )
+#define USBOHCI_UHCINT_WDH                  ( 1u   << 1 )
+#define USBOHCI_UHCINT_SF                   ( 1u   << 2 )
+#define USBOHCI_UHCINT_RD                   ( 1u   << 3 )
+#define USBOHCI_UHCINT_UE                   ( 1u   << 4 )
+#define USBOHCI_UHCINT_FNO                  ( 1u   << 5 )
+#define USBOHCI_UHCINT_RHSC                 ( 1u   << 6 )
+#define USBOHCI_UHCINT_OC                   ( 1u   << 30 )
+#define USBOHCI_UHCINT_MIE                  ( 1u   << 31 )
+
+// fields and bits for uhchcca:     Host controller Communication Area
+#define USBOHCI_UHCHCCA_MASK                ( 0xfffffffu << 8 )
+
+// fields and bits for uhcpced:     Period Current Endpoint Descriptor
+#define USBOHCI_UHCPCED_MASK                ( 0xffffffffu << 4 )
+
+// fields and bits for uhcched:     Control Head Endpoint Descriptor register
+#define USBOHCI_UHCCHED_MASK                ( 0xffffffffu << 4 )
+
+// fields and bits for uhccced:     Control Current Endpoint Descriptor register
+#define USBOHCI_UHCCCED_MASK                ( 0xffffffffu << 4 )
+
+// fields and bits for uhcbhed:     Bulk Head Endpoint Descriptor register
+#define USBOHCI_UHCBHED_MASK                ( 0xffffffffu << 4 )
+
+// fields and bits for uhcbced:     Bulk Current Endpoint Descriptor register
+#define USBOHCI_UHCBCED_MASK                ( 0xffffffffu << 4 )
+
+// fields and bits for uhcdhead:    Done head register
+#define USBOHCI_UHCDHED_MASK                ( 0xffffffffu << 4 )    // should be "DHTD" because its a transfer descriptor
+
+// fields and bits for uhcfmi:      Frame Interval register
+#define USBOHCI_UHCFMI_FI_MASK              ( 0x3fffu << 0 )
+#define USBOHCI_UHCFMI_FSMPS_MASK           ( 0x7fffu << 16 )
+#define USBOHCI_UHCFMI_FIT                  ( 1u   << 31 )
+
+// fields and bits for uhcfmr:      Frame Remaining register
+#define USBOHCI_UHCFMR_FR_MASK              ( 0x3fffu << 0 )
+#define USBOHCI_UHCFMI_FRT                  ( 1u   << 31 )
+
+// fields and bits for uhcfmn:      Frame Number register
+#define USBOHCI_UHCFMN_FN_MASK              ( 0xffffu << 0 )
+
+// fields and bits for uhcpers:     Periodic Start register
+#define USBOHCI_UHCPERS_PS_MASK             ( 0x3fffu << 0 )
+
+// fields and bits for uhclst:      Low Speed Threshold register
+#define USBOHCI_UHCPLST_LST_MASK            ( 0xfffu << 0 )
+
+// fields and bits for uhcrhda:     Root Hub Descriptor A register
+#define USBOHCI_UHCRHDA_NDP_MASK            ( 0xffu << 0 )
+
+#define USBOHCI_UHCRHDA_PSM                 ( 1u   << 8 )
+#define USBOHCI_UHCRHDA_NPS                 ( 1u   << 9 )
+#define USBOHCI_UHCRHDA_DT                  ( 1u   << 10 )
+#define USBOHCI_UHCRHDA_OCPM                ( 1u   << 11 )
+#define USBOHCI_UHCRHDA_NOCP                ( 1u   << 12 )
+
+#define USBOHCI_UHCRHDA_POTPGT_MASK         ( 0xffu << 24 )
+
+// fields and bits for uhcrhdb:     Root Hub Descriptor B register
+#define USBOHCI_UHCRHDB_DR_MASK             ( 0xffffu << 0 )
+#define USBOHCI_UHCRHDB_PPCM_MASK           ( 0xffffu << 16 )
+
+// fields and bits for uhcrhs:      Root Hub Status register
+#define USBOHCI_UHCRHS_LPS                  ( 1u   << 0 )       // meaning on read
+#define USBOHCI_UHCRHS_CGP                  ( 1u   << 0 )       // meaining on write
+#define USBOHCI_UHCRHS_OCI                  ( 1u   << 1 )
+#define USBOHCI_UHCRHS_DRWE                 ( 1u   << 15 )      // meaning on read
+#define USBOHCI_UHCRHS_SRWE                 ( 1u   << 15 )      // meaning on write
+#define USBOHCI_UHCRHS_LPSC                 ( 1u   << 16 )      // meaning on read
+#define USBOHCI_UHCRHS_SGP                  ( 1u   << 16 )      // meaning on write
+#define USBOHCI_UHCRHS_OCIC                 ( 1u   << 17 )
+#define USBOHCI_UHCRHS_CRWE                 ( 1u   << 31 )
+
+// fields and bits for uhcrhps1:    Root Hub Port 1 Status register
+// fields and bits for uhcrhps2:    Root Hub Port 2 Status register
+#define USBOHCI_UHCRHPS_CCS                 ( 1u   << 0 )
+#define USBOHCI_UHCRHPS_PES                 ( 1u   << 1 )
+#define USBOHCI_UHCRHPS_PSS                 ( 1u   << 2 )
+#define USBOHCI_UHCRHPS_POCI                ( 1u   << 3 )
+#define USBOHCI_UHCRHPS_PRS                 ( 1u   << 4 )
+#define USBOHCI_UHCRHPS_PPS                 ( 1u   << 8 )
+#define USBOHCI_UHCRHPS_LSDA                ( 1u   << 9 )       // meaning on read
+#define USBOHCI_UHCRHPS_CPP                 ( 1u   << 9 )       // meaning on write
+#define USBOHCI_UHCRHPS_CSC                 ( 1u   << 16 )
+#define USBOHCI_UHCRHPS_PESC                ( 1u   << 17 )
+#define USBOHCI_UHCRHPS_PSSC                ( 1u   << 18 )
+#define USBOHCI_UHCRHPS_POCIC               ( 1u   << 19 )
+#define USBOHCI_UHCRHPS_PRSC                ( 1u   << 20 )
+
+// fields and bits for uhcstat:     USB Host Status
+#define USBOHCI_UHCSTAT_RWUE                ( 1u   << 7 )
+#define USBOHCI_UHCSTAT_HBA                 ( 1u   << 8 )
+#define USBOHCI_UHCSTAT_HTA                 ( 1u   << 10 )
+#define USBOHCI_UHCSTAT_UPS1                ( 1u   << 11 )
+#define USBOHCI_UHCSTAT_UPS2                ( 1u   << 12 )
+#define USBOHCI_UHCSTAT_UPRI                ( 1u   << 13 )
+#define USBOHCI_UHCSTAT_SBTAI               ( 1u   << 14 )
+#define USBOHCI_UHCSTAT_SBMAI               ( 1u   << 15 )
+
+// fields and bits for uhchr:       USB Host Reset
+// UHCHR host reset register bit positions
+#define USBOHCI_UHCHR_SSEP1                 ( 1u << 10) // Sleep Standby Enable: enable/disable port1 SE receivers & power  supply
+#define USBOHCI_UHCHR_SSEP0                 ( 1u <<  9) // Sleep Standby Enable: enable/disable port1 SE receivers & power  supply
+#define USBOHCI_UHCHR_PCPL                  ( 1u <<  7) // Power CONTROL Polarity: Control polarity of Power Enable signals output to the MAX1693EUB USB Power Switch
+#define USBOHCI_UHCHR_PSPL                  ( 1u <<  6) // Power SENSE Polarity: Control polarity of Over-current Indicator signals input from the MAX1693EUB USB Power Switch
+#define USBOHCI_UHCHR_SSE                   ( 1u <<  5) // Sleep Standby Enable: enable/disable both ports SE receivers & power  supply
+#define USBOHCI_UHCHR_UIT                   ( 1u <<  4) // USB Interrupt Test: Enable Interrupt Test Mode and UHCHIT register
+#define USBOHCI_UHCHR_SSDC                  ( 1u <<  3) // Simulation Scale Down Clock: When 1, internal 1 mSec timer changes to 1 uSec to speed up simulations
+#define USBOHCI_UHCHR_CGR                   ( 1u <<  2) // Clock Generation Reset: When 0, resets the OHCI Clock Generation block (DPLL). Used only in simulation
+#define USBOHCI_UHCHR_FHR                   ( 1u <<  1) // Force Host controller Reset: When 1, resets OHCI core. Must be held high for 10 uSeconds, then cleared
+#define USBOHCI_UHCHR_FSBIR                 ( 1u <<  0) // Force System Bus Interface Reset: When 1, resets the logic that interfaces to the system bus, DMA, etc. Auto clears after three system bus clocks.
+
+// fields and bits for uhchie:      USB Host Interrupt Enable
+#define USBOHCI_UHCIE_RWIE                 ( 1u   << 7 )
+#define USBOHCI_UHCIE_HBAIE                ( 1u   << 8 )
+#define USBOHCI_UHCIE_TAIE                 ( 1u   << 10 )
+#define USBOHCI_UHCIE_UPS1IE               ( 1u   << 11 )
+#define USBOHCI_UHCIE_UPS2IE               ( 1u   << 12 )
+#define USBOHCI_UHCIE_UPRIE                ( 1u   << 13 )
+
+
+// fields and bits for uhchit:      USB Host Interrupt Test
+#define USBOHCI_UHCIT_RWIT                 ( 1u   << 7 )
+#define USBOHCI_UHCIT_BAT                  ( 1u   << 8 )
+#define USBOHCI_UHCIT_IRQT                 ( 1u   << 9 )
+#define USBOHCI_UHCIT_TAT                  ( 1u   << 10 )
+#define USBOHCI_UHCIT_UPS1T                ( 1u   << 11 )
+#define USBOHCI_UHCIT_UPS2T                ( 1u   << 12 )
+#define USBOHCI_UHCIT_UPRT                 ( 1u   << 13 )
+#define USBOHCI_UHCIT_STAT                 ( 1u   << 14 )
+#define USBOHCI_UHCIT_SMAT                 ( 1u   << 15 )
+
+
+
+// root hub descriptor A information
+#define USBOHCI_UHCRHDA_PSM_PERPORT        1
+
+
+#define INT_CTRL_BASE                           0xF3001000
+#define IEN_REG_OFFSET                          0x0
+#define CLR_REG_OFFSET                          0x4
+#define SEL_REG_OFFSET                          0xC
+#define POL_REG_OFFSET                          0x1C
+
+#define CLK_CTRL_BASE                           0xF3000000
+#define BCLK_CTRL_OFFSET                        0x18
+#define SWRESET_CTRL_OFFSET                     0x1C
+
+#define HwBCLK                                  *(volatile unsigned long *)(CLK_CTRL_BASE+BCLK_CTRL_OFFSET)
+
+#define IO_CKC_BUS_UBH                          0x00000001
+#define IO_CKC_BUS_UBD                          0x00000002
+
+
+
+struct device;
+
+struct tccohci_platform_data {
+	int (*init)(struct device *);
+	void (*exit)(struct device *);
+
+	int port_mode;
+#define USBOHCI_PPM_NPS     1
+#define USBOHCI_PPM_GLOBAL  2
+#define USBOHCI_PPM_PERPORT 3
+#define USBOHCI_PPM_MIXED   4
+
+	int power_budget;
+};
+
+extern void tcc_set_ohci_info(struct tccohci_platform_data *info);
+
+#endif
Index: linux-2.6.29/arch/arm/mach-tcc8900/include/mach/reg_physical.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/include/mach/reg_physical.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,38 @@
+/****************************************************************************
+*   FileName    : reg_physical.h
+*   Description : 
+****************************************************************************
+*
+*   TCC Version : 1.0
+*   Copyright (c) Telechips, Inc.
+*   ALL RIGHTS RESERVED
+*
+****************************************************************************/
+
+#ifndef __REG_PHYSICAL_H__
+#define __REG_PHYSICAL_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+#if defined(TCC89X)
+	#include "TCC89x_Physical.h"
+	#include "TCC89x_Structures.h"
+#elif defined(TCC91X)
+	#include "TCC91x_Physical.h"
+	#include "TCC91x_Structures.h"
+#elif defined(TCC92X)
+	#include "TCC92x_Physical.h"
+	#include "TCC92x_Structures.h"
+#endif
+*/
+#include "TCC89x_Physical.h"
+#include "TCC89x_Structures.h"
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __REG_PHYSICAL_H__
Index: linux-2.6.29/arch/arm/mach-tcc8900/include/mach/system.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/include/mach/system.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,54 @@
+/*
+ * linux/arch/arm/mach-tcc8900/include/mach 
+ *
+ * Author: <linux@telechips.com>
+ * Created: June 10, 2008
+ * Description: LINUX SYSTEM FUNCTIONS for TCC83x
+ *
+ * Copyright (C) 2008-2009 Telechips 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as 
+ * published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see the file COPYING, or write
+ * to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+#include <linux/clk.h>
+
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+
+#include <bsp.h>
+
+extern inline void tcc_idle(void);
+
+static inline void arch_idle(void)
+{
+	tcc_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+	volatile PPMU pPMU = (volatile PPMU)(tcc_p2v(HwPMU_BASE));	//0xF0404000
+	volatile PIOBUSCFG pIOBUSCFG = (volatile PIOBUSCFG)(tcc_p2v(HwIOBUSCFG_BASE)); //0xF05F5000
+
+	pIOBUSCFG->HCLKEN0 = -1;
+	pIOBUSCFG->HCLKEN1 = -1;
+	
+	while (1) {
+		pPMU->WATCHDOG = (Hw31 + 0x1);
+	}
+}
+
+#endif
Index: linux-2.6.29/arch/arm/mach-tcc8900/include/mach/system_type.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/include/mach/system_type.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,32 @@
+/****************************************************************************
+*   FileName    : system.h
+*   Description : 
+****************************************************************************
+*
+*   TCC Version : 1.0
+*   Copyright (c) Telechips, Inc.
+*   ALL RIGHTS RESERVED
+*
+****************************************************************************/	
+
+#ifndef __SYSTEM_H__
+#define __SYSTEM_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+	//wince
+#include <windows.h>
+#include <nkintr.h>
+#include <halether.h>
+#include <oal.h>
+
+	//linux
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __SYSTEM_H__
\ No newline at end of file
Index: linux-2.6.29/arch/arm/mach-tcc8900/include/mach/tca_ckc.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/include/mach/tca_ckc.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,178 @@
+/****************************************************************************
+ *   FileName    : tca_ckc.h
+ *   Description : 
+ ****************************************************************************
+*
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+*
+ ****************************************************************************/
+
+
+/************************************************************************************************
+*                                    Revision History                                           *
+*                                                                                               *
+* Version : 1.0    : 2009, 2, 04                                                                *
+************************************************************************************************/
+
+#ifndef __TCA_CKC_H__
+#define __TCA_CKC_H__
+
+//#include "bsp.h"
+
+#if defined(_LINUX_)
+#ifndef VOLATILE
+#define VOLATILE
+#endif
+#else
+#ifndef VOLATILE
+#define VOLATILE	volatile
+#endif
+#endif
+
+/************************************************************************************************
+*										 MACRO												   *
+************************************************************************************************/
+
+/************************************************************************************************
+*									  DEFINE											*
+************************************************************************************************/
+/************************************************************************************************
+*										 ENUM													*
+************************************************************************************************/
+/****************************************************************************************
+* FUNCTION :void tca_ckc_init(void)
+* DESCRIPTION :
+* ***************************************************************************************/
+extern VOLATILE void tca_ckc_init(void);
+
+/****************************************************************************************
+* FUNCTION :unsigned int tca_ckc_getpll(unsigned int ch)
+* DESCRIPTION :
+* ***************************************************************************************/
+extern VOLATILE unsigned int tca_ckc_getpll(unsigned int ch);
+
+/****************************************************************************************
+* FUNCTION :unsigned int tca_ckc_getcpu(void)
+* DESCRIPTION : 
+* ***************************************************************************************/
+extern VOLATILE unsigned int tca_ckc_getcpu(void);
+
+/****************************************************************************************
+* FUNCTION :unsigned int tca_ckc_getbus(void)
+* DESCRIPTION : 
+* ***************************************************************************************/
+extern VOLATILE unsigned int tca_ckc_getbus(void);
+
+/****************************************************************************************
+* FUNCTION :void tca_ckc_setfbusctrl(unsigned int clkname,unsigned int isenable,unsigned int freq, unsigned int sor)
+* DESCRIPTION :
+* ***************************************************************************************/
+extern VOLATILE void tca_ckc_setfbusctrl(unsigned int clkname,unsigned int isenable,unsigned int md,unsigned int freq, unsigned int sor);
+
+/****************************************************************************************
+* FUNCTION :void tca_ckc_getfbusctrl(unsigned int clkname)
+* DESCRIPTION :
+* ***************************************************************************************/
+extern VOLATILE int tca_ckc_getfbusctrl(unsigned int clkname);
+
+/****************************************************************************************
+* FUNCTION :int tca_ckc_setpll(unsigned int pll, unsigned int ch)
+* DESCRIPTION :
+* ***************************************************************************************/
+extern VOLATILE int tca_ckc_setpll(unsigned int pll, unsigned int ch);
+
+/****************************************************************************************
+* FUNCTION :void tca_ckc_validpll(unsigned int * pvalidpll)
+* DESCRIPTION :
+* ***************************************************************************************/
+extern VOLATILE void tca_ckc_validpll(unsigned int * pvalidpll);
+
+/****************************************************************************************
+* FUNCTION :void tca_ckc_setpmupwroff( unsigned int periname , unsigned int isenable)
+* DESCRIPTION : 
+* ***************************************************************************************/
+extern VOLATILE void tca_ckc_setpmupwroff( unsigned int periname , unsigned int isenable);
+
+/****************************************************************************************
+* FUNCTION :void tca_ckc_getpmupwroff( unsigned int pmuoffname)
+* DESCRIPTION : 
+* ***************************************************************************************/
+extern VOLATILE int tca_ckc_getpmupwroff( unsigned int pmuoffname);
+
+/****************************************************************************************
+* FUNCTION :void tca_ckc_setperi(unsigned int periname,unsigned int isenable, unsigned int freq, unsigned int sor)
+* DESCRIPTION : 
+* ***************************************************************************************/
+extern VOLATILE void tca_ckc_setperi(unsigned int periname,unsigned int isenable, unsigned int freq, unsigned int sor);
+
+/****************************************************************************************
+* FUNCTION : int tca_ckc_getperi(unsigned int periname)
+* DESCRIPTION :
+* ***************************************************************************************/
+extern VOLATILE int tca_ckc_getperi(unsigned int periname);
+
+/****************************************************************************************
+* FUNCTION :void tca_ckc_setcpu(unsigned int n)
+* DESCRIPTION :  n is n/16 
+* example : CPU == PLL : n=16 - CPU == PLL/2 : n=8
+* ***************************************************************************************/
+extern VOLATILE void tca_ckc_setcpu(unsigned int n);
+
+/****************************************************************************************
+* FUNCTION :void tca_ckc_setswresetprd(unsigned int prd)
+* DESCRIPTION : 
+* ***************************************************************************************/
+extern VOLATILE void tca_ckc_setswresetprd(unsigned int prd);
+
+/****************************************************************************************
+* FUNCTION :void tca_ckc_setswreset(unsigned int lfbusname, unsigned int mode)
+* DESCRIPTION : 
+* ***************************************************************************************/
+extern VOLATILE void  tca_ckc_setswreset(unsigned int lfbusname, unsigned int mode);
+
+/****************************************************************************************
+* FUNCTION :void tca_ckc_set_iobus_swreset(unsigned int sel)
+* DESCRIPTION : 
+* ***************************************************************************************/
+
+extern VOLATILE unsigned int tca_ckc_set_iobus_swreset(unsigned int sel, unsigned int mode);
+
+/****************************************************************************************
+* FUNCTION : int tca_ckc_setiobus(unsigned int sel, unsigned int mode)
+* DESCRIPTION : 
+* ***************************************************************************************/
+extern VOLATILE int tca_ckc_setiobus(unsigned int sel, unsigned int mode);
+/****************************************************************************************
+* FUNCTION :  int tca_ckc_getiobus(unsigned int sel)
+* DESCRIPTION : 
+* ***************************************************************************************/
+extern VOLATILE int tca_ckc_getiobus(unsigned int sel);
+
+/****************************************************************************************
+* FUNCTION :  int tca_ckc_setsmui2c(unsigned int freq)
+* DESCRIPTION : 
+* ***************************************************************************************/
+extern VOLATILE void tca_ckc_setsmui2c(unsigned int freq);
+/****************************************************************************************
+* FUNCTION :  int tca_ckc_getsmui2c(void)
+* DESCRIPTION : unit : 100Hz
+* ***************************************************************************************/
+extern VOLATILE int tca_ckc_getsmui2c(void);
+
+/****************************************************************************************
+* FUNCTION : void tca_ckc_setddipwdn(unsigned int lpwdn , unsigned int lmode)
+* DESCRIPTION : Power Down Register of DDI_CONFIG 
+* ***************************************************************************************/
+extern void tca_ckc_setddipwdn(unsigned int lpwdn , unsigned int lmode);
+/****************************************************************************************
+* FUNCTION : int tca_ckc_getddipwdn(unsigned int lpwdn)
+* DESCRIPTION : Power Down Register of DDI_CONFIG 
+* ***************************************************************************************/
+extern int tca_ckc_getddipwdn(unsigned int lpwdn);
+
+#endif  /* __TCA_CKC_H__ */
+
+
+
Index: linux-2.6.29/arch/arm/mach-tcc8900/include/mach/tcc_ckc_ctrl.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/include/mach/tcc_ckc_ctrl.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,60 @@
+/* linux/arch/arm/mach-tcc8900/include/mach/tcc_ckc_ctrl.h
+
+ * Author: <linux@telechips.com>
+ * Created: June 10, 2008
+ * Description: Header for code common to all Telechips TCC8900/TCC83x machines.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _TCC_CKC_CTRL_H
+#define _TCC_CKC_CTRL_H
+
+#include <linux/tcc_ioctl.h>
+
+extern int arm_changestack(void);
+extern void arm_restorestack(unsigned int rst);
+
+extern void ckc_set_peri(struct ckc_ioctl st);
+extern int ckc_get_peri(struct ckc_ioctl st);
+extern int ckc_set_peribus(struct ckc_ioctl st);
+extern int ckc_get_peribus(struct ckc_ioctl st);
+extern void ckc_set_periswreset(struct ckc_ioctl st);
+extern void ckc_set_fbusswreset(struct ckc_ioctl st);
+extern void ckc_set_cpu(struct ckc_ioctl st);
+extern void ckc_set_smui2c(struct ckc_ioctl st);
+extern unsigned int ckc_get_cpu(struct ckc_ioctl st);
+extern unsigned int ckc_get_bus(struct ckc_ioctl st);
+extern void ckc_get_validpllinfo(struct ckc_ioctl st);
+extern void ckc_set_fbus(struct ckc_ioctl st);
+extern int ckc_get_fbus(struct ckc_ioctl st);
+extern void ckc_set_pmupower(struct ckc_ioctl st);
+extern void ckc_get_pmupower(struct ckc_ioctl st);
+extern void ckc_get_clockinfo(struct ckc_ioctl st);
+extern void ckc_set_changefbus(struct ckc_ioctl st);
+extern void ckc_set_changemem(struct ckc_ioctl st);
+extern void ckc_set_changecpu(struct ckc_ioctl st);
+extern void ckc_set_ddipwdn(struct ckc_ioctl st);
+extern void ckc_get_ddipwdn(struct ckc_ioctl st);
+extern void ckc_set_etcblock(struct ckc_ioctl st);
+
+#endif /* _TCC_CKC_CTRL_H*/
+
Index: linux-2.6.29/arch/arm/mach-tcc8900/include/mach/tcc_pca953x.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/include/mach/tcc_pca953x.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,210 @@
+/*
+ * linux/arch/arm/mach-tcc8900/include/mach/tcc_pca953x.h
+ *
+ * Author:  <linux@telechips.com>
+ * Created: 21th March, 2009 
+ * Description: Tcc250 Driver 
+ *
+ * Copyright (c) Telechips, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * ===============================================================================================
+ *  USAGE
+ * =======
+ *
+ * Use "tcc_pca953x_setup()" function for management port status.
+ *
+ * 1. read operation
+ *
+ *   int tcc_pca953x_setup(int slave, int name, int direction, int value, int mode);
+ *
+ *   parameters
+ *   ----------
+ *     int slave     - PCA953x I2C slave address
+ *     int name      - fixed 0
+ *     int direction - direction of port [OUTPUT/INPUT]
+ *     int value     - fixed 0
+ *     int mode      - fixed GET_VALUE
+ *
+ *   return value
+ *   ------------
+ *     int rd_buf    - 16bit read data returned, -1 is fail
+ *
+ *   example
+ *   -------
+ *     // read PCA9539_U2_SLAVE_ADDR port0 and port1
+ *     int rd_buf = tcc_pca953x_setup(PCA9539_U2_SLAVE_ADDR, 0, OUTPUT, 0, GET_VALUE);
+ *
+ * 2. write operation
+ *
+ *   int tcc_pca953x_setup(int slave, int name, int direction, int value, int mode);
+ *
+ *   parameters
+ *   ----------
+ *     int slave     - PCA953x I2C slave address
+ *     int name      - control port name, see "Expanded GPIO port map"
+ *     int direction - direction of port [OUTPUT/INPUT]
+ *     int value     - output mode only. set port value [HIGH/LOW]
+ *     int mode      - [SET_DIRECTION/SET_VALUE] or [SET_DIRECTION|SET_VALUE]
+ *
+ *   return value
+ *   ------------
+ *     int rd_buf    - 1 is success, -1 is fail
+ *
+ *   example
+ *   -------
+ *     + set port direction
+ *       // PCA9539_U2_SLAVE_ADDR, ETH_RST, Output mode
+ *       tcc_pca953x_setup(PCA9539_U2_SLAVE_ADDR, ETH_RST, OUTPUT, 0, SET_DIRECTION);
+ *
+ *     + set port value (output mode only)
+ *       // PCA9539_U2_SLAVE_ADDR, ETH_RST, Output High
+ *       tcc_pca953x_setup(PCA9539_U2_SLAVE_ADDR, ETH_RST, OUTPUT, HIGH, SET_VALUE);
+ *
+ *     + set both (direction & value)
+ *       // PCA9539_U2_SLAVE_ADDR, ETH_RST, Output mode, Output Low
+ *       tcc_pca953x_setup(PCA9539_U2_SLAVE_ADDR, ETH_RST, OUTPUT, LOW, SET_DIRECTION|SET_VALUE);
+ *
+ * 3. direct read/write
+ *   + read
+ *     tcc_pca953x_read(PCA9539_U2_SLAVE_ADDR, PCA9539_OUTPUT_0, &buf[0]);
+ *     tcc_pca953x_read(PCA9539_U2_SLAVE_ADDR, PCA9539_OUTPUT_1, &buf[1]);
+ *     printk("PCA9539_U2_SLAVE_ADDR port0(%x), port1(%x)", buf[0], buf[1]);
+ *   
+ *   + write each port
+ *     buf[0] = PCA9539_OUTPUT_0;
+ *     buf[1] = 0x12;
+ *     tcc_pca953x_write(PCA9539_U2_SLAVE_ADDR, &buf[0], 2);
+ *     buf[0] = PCA9539_OUTPUT_1;
+ *     buf[1] = 0x34;
+ *     tcc_pca953x_write(PCA9539_U2_SLAVE_ADDR, &buf[0], 2);
+ *   
+ *   + write all port
+ *     buf[0] = PCA9539_OUTPUT_0;
+ *     buf[1] = 0x12;
+ *     buf[2] = 0x34;
+ *     tcc_pca953x_write(PCA9539_U3_SLAVE_ADDR, &buf[0], 3);
+ *
+ * ===============================================================================================
+ */
+#ifndef __PCA953X_H__
+#define __PCA953X_H__
+
+#include <bsp.h>
+
+
+/*
+ * EXPORT_SYMBOL
+ */
+extern int tcc_pca953x_setup(int slave, int name, int direction, int value, int mode);
+extern int tcc_pca953x_read(int slave, unsigned char cmd, unsigned char *rd_buf);
+extern int tcc_pca953x_write(int slave, const unsigned char *wr_buf, int count);
+
+/*
+ * PCA953x I2C slave address
+ */
+#define PCA9539_U2_SLAVE_ADDR	0x77
+#define PCA9539_U3_SLAVE_ADDR	0x74
+#define PCA9538_U4_SLAVE_ADDR	0x70
+
+/*
+ * Port setup mode
+ */
+#define GET_VALUE		0x0001
+#define SET_DIRECTION	0x0010
+#define SET_VALUE		0x0100
+
+/*
+ * Port direction & value
+ */
+#define INPUT	1
+#define OUTPUT	0
+#define HIGH	1
+#define LOW		0
+
+/*
+ * Expanded GPIO port map
+ */
+/* PCA9539 U2 */
+//PORT0
+#define ETH_RST      Hw0   // DNP : Ethernet Controller Reset
+#define DXB0_RST     Hw1   // DMB, DAB Reset
+#define CAM_RST      Hw2   // DNP : Camera Module Reset
+#define CAS_RST      Hw3   // DNP : CAS Reset
+#define AUTH_RST     Hw4   // iPod Auth Reset
+#define FM_RST       Hw5   // FM Transceiver Reset
+#define RTC_RST      Hw6   // DNP : RTC Reset
+#define SATA_ON      Hw6   // SATA_ON
+#define BT_WAKE      Hw7   // DNP : Bluetooth Wakeup
+#define HDMI_ON      Hw7   // HDMI_ON
+//PORT1
+#define DXB0_IRQ     Hw8   // INPUT
+#define BT_HWAKE     Hw9   // INPUT : Bluetooth Host Wakeup
+#define FM_IRQ       Hw10  // INPUT : FM Receiver IRQ
+#define CP_READY     Hw11  // INPUT : iPod CP Ready
+#define DXB_GP0      Hw12  // DXBGP0
+#define CAM_FL_EN    Hw13  // DNP : Camera Flash Light En/Disable
+#define LCD_BL_EN    Hw13  // DNP : LCD Backlight En/Disable
+#define MUTE_CTL     Hw14  // Audio Mute Control
+#define CAS_GP       Hw15  // CASGP
+#define TV_SLEEP     Hw15  // DNP : TV Sleep Signal
+#define HDD_RST      Hw15  // DNP : HDD Reset
+
+/* PCA9539 U3 */
+//PORT0
+#define ATAPI_ON     Hw0   // IDE Disk Interface
+#define LCD_ON       Hw1   // LCD Power
+#define LVDSIVT_ON   Hw2   // LVDS Inverter
+#define CAM_ON       Hw3   // Camera Module Power
+#define CODEC_ON     Hw4   // External Audio CODEC
+#define FMTC_ON      Hw5   // FM Transceiver
+#define SD0_ON       Hw6   // SD Card Slot 0
+#define SD1_ON       Hw7   // SD Card Slot 1
+//PORT1
+#define BT_ON        Hw8   // Bluetooth
+#define CAS_ON       Hw9   // CAS
+#define CAN_ON       Hw10  // CAN Interface Controller
+#define ETH_ON       Hw11  // Ethernet Controller
+#define DXB_ON       Hw12  // DMB, DAB Power
+#define iPOD_ON      Hw13  // iPOD Connection Power
+#define PWR_GP4      Hw14  // GPIO4 Power
+#define LVDS_LP_CTRL Hw15  // LVDS LCD Controller
+
+/* PCA9538 U4 */
+//PORT0
+#define DVBUS_ON     Hw0   // USB Device VBUS
+#define HVBUS_ON     Hw1   // USB Host VBUS
+#define HDMI_LVDS_ON Hw2   // HDMI_LVDS Interface Power
+#define PWR_GP0      Hw3   // GPIO0 Power
+#define PWR_GP2      Hw4   // GPIO2 Power
+#define PWR_GP3      Hw5   // GPIO3 Power
+#define VCORE_CTL    Hw6   // Core Voltage Power
+#define PWR_GP1      Hw7   // GPIO1 Power
+
+/*
+ * PCA953x command
+ */
+enum pca9539_cmd
+{
+	PCA9539_INPUT_0		= 0,
+	PCA9539_INPUT_1		= 1,
+	PCA9539_OUTPUT_0	= 2,
+	PCA9539_OUTPUT_1	= 3,
+	PCA9539_INVERT_0	= 4,
+	PCA9539_INVERT_1	= 5,
+	PCA9539_DIRECTION_0	= 6,
+	PCA9539_DIRECTION_1	= 7,
+};
+
+enum pca9538_cmd
+{
+	PCA9538_INPUT_0		= 0,
+	PCA9538_OUTPUT_0	= 1,
+	PCA9538_INVERT_0	= 2,
+	PCA9538_DIRECTION_0	= 3,
+};
+
+#endif	/*__PCA953X_H__*/
Index: linux-2.6.29/arch/arm/mach-tcc8900/include/mach/timex.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/include/mach/timex.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,31 @@
+/*
+ * linux/include/asm-arm/arch-tcc8900/timex.h
+ *
+ * Author:  Greg Lonnon <glonnon@ridgerun.com>
+ * Modified: <linux@telechips.com>
+ *
+ * Copyright (C) 2000 RidgeRun, Inc.
+ * Copyright (C) 2008-2009 Telechips 
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#define CLOCK_TICK_RATE		(HZ * 100000UL)
Index: linux-2.6.29/arch/arm/mach-tcc8900/include/mach/uncompress.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/include/mach/uncompress.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,45 @@
+/*
+ * linux/include/asm-arm/arch-tcc83x/uncompress.h
+ *
+ * Author: <source@mvista.com>
+ * Modified: <linux@telechips.com>
+ * Modified: June 10, 2008
+ * Description: Serial port stubs for kernel decompress status messages
+ *
+ * 2004 (c) MontaVista Software, Inc.
+ * Copyright (C) 2008-2009 Telechips 
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#include <linux/types.h>
+#include <linux/serial_reg.h>
+
+unsigned int system_rev;
+
+#define ID_MASK			0x7fff
+
+static void putc(int c)
+{
+	volatile u8 * uart = 0;
+	int shift = 2;
+
+	/*
+	 * Now, xmit each character
+	 */
+	while (!(uart[UART_LSR << shift] & UART_LSR_THRE))
+		barrier();
+	uart[UART_TX << shift] = c;
+}
+
+static inline void flush(void)
+{
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
Index: linux-2.6.29/arch/arm/mach-tcc8900/include/mach/vmalloc.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/include/mach/vmalloc.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,25 @@
+/*
+ * linux/include/asm-arm/arch-tcc8900/vmalloc.h
+ *
+ * Author: <linux@telechips.com>
+ * Created: Feb 10, 2009
+ *
+ * Copyright (C) 2000 Russell King.
+ * Copyright (C) 2008-2009 Telechips 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#define VMALLOC_END	  (PAGE_OFFSET + 0x20000000)
+
Index: linux-2.6.29/arch/arm/mach-tcc8900/io.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/io.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,100 @@
+/*
+ * linux/arch/arm/mach-tcc8900/io.c
+ *
+ * Author:  <linux@telechips.com>
+ * Created: 10th February, 2008
+ * Description: tcc8900 mapping code
+ *
+ * Copyright (C) Telechips, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <asm/tlb.h>
+#include <asm/mach/map.h>
+#include <asm/io.h>
+
+#include <bsp.h>
+
+/*
+ * The machine specific code may provide the extra mapping besides the
+ * default mapping provided here.
+ */
+static struct map_desc tcc8900_io_desc[] __initdata = {
+    {
+        .virtual    = 0xF0000000,
+        .pfn        = __phys_to_pfn(0xF0000000),   
+        .length     = 0x100000,                   
+        .type       = MT_DEVICE
+    },
+    {
+        .virtual    = 0xF0100000,
+        .pfn        = __phys_to_pfn(0xF0100000),
+        .length     = 0x100000,               
+        .type       = MT_DEVICE
+    },
+    {
+        .virtual    = 0xF0200000,
+        .pfn        = __phys_to_pfn(0xF0200000),
+        .length     = 0x100000,                
+        .type       = MT_DEVICE
+    },
+    {
+        .virtual    = 0xF0300000,
+        .pfn        = __phys_to_pfn(0xF0300000),
+        .length     = 0x100000,                
+        .type       = MT_DEVICE
+    },
+    {
+        .virtual    = 0xF0400000,
+        .pfn        = __phys_to_pfn(0xF0400000),
+        .length     = 0x100000,                
+        .type       = MT_DEVICE
+    },
+    {
+        .virtual    = 0xF0500000,
+        .pfn        = __phys_to_pfn(0xF0500000),
+        .length     = 0x100000,                
+        .type       = MT_DEVICE
+    },
+    {
+        .virtual    = 0xF0600000,
+        .pfn        = __phys_to_pfn(0xF0600000),
+        .length     = 0x100000,                
+        .type       = MT_DEVICE
+    },
+    {
+        .virtual    = 0xF0700000,
+        .pfn        = __phys_to_pfn(0xF0700000),
+        .length     = 0x100000,                
+        .type       = MT_DEVICE
+    },
+    {
+        .virtual    = 0xEFF00000,
+        .pfn        = __phys_to_pfn(0x10000000),
+        .length     = 0x100000,                
+        .type       = MT_MEMORY_TCC
+    },
+};
+
+
+/*
+ *  Maps common IO regions for tcc8900.
+ */
+void __init tcc8900_map_common_io(void)
+{
+    iotable_init(tcc8900_io_desc, ARRAY_SIZE(tcc8900_io_desc));
+
+    /* Normally devicemaps_init() would flush caches and tlb after
+     * mdesc->map_io(), but we must also do it here because of the CPU
+     * revision check below.
+     */
+    local_flush_tlb_all();
+    flush_cache_all();
+}
Index: linux-2.6.29/arch/arm/mach-tcc8900/irq.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/irq.c	2010-04-07 13:00:43.000000000 -0400
@@ -0,0 +1,548 @@
+/*
+ * linux/arch/arm/mach-tcc8900/irq.c
+ *
+ * Author:  <linux@telechips.com>
+ * Created: 10th February, 2009
+ * Description: Interrupt handler for Telechips TCC8900 chipset
+ *
+ * Copyright (C) Telechips, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+
+#include <linux/agpgart.h>
+#include <linux/types.h>
+
+#include <asm/irq.h>
+#include <asm/mach/irq.h>
+#include <asm/io.h>
+
+#include <bsp.h>
+
+
+// Global 
+static volatile PPIC pPIC;
+static volatile PVIC pVIC;
+static volatile PGPSBPORTCFG pPGPSBPORTCFG;
+static volatile PUARTPORTMUX pUARTPORTMUX;
+static volatile PGDMACTRL pPGDMACTRL0, pPGDMACTRL1, pPGDMACTRL2, pPGDMACTRL3;
+static volatile PTIMER pTIMER;
+
+
+/******************************************
+ * Disable IRQ
+ *
+ * If mask_ack exist, this is not called.
+ *****************************************/
+static void tcc8900_mask_irq(unsigned int irq)
+{
+    if (irq < 32) {
+        BITCLR(pPIC->INTMSK0,   (1 << irq));
+    } else {
+        BITCLR(pPIC->INTMSK1,   (1 << (irq - 32)));
+    }
+}
+
+static void tcc8900_mask_irq_uart(unsigned int irq)
+{
+    if (irq != INT_UART) {
+        BITCLR(pPIC->INTMSK1, Hw15);
+    }
+}
+
+static void tcc8900_mask_irq_gpsb(unsigned int irq)
+{
+    if (irq != INT_GPSB) {
+        BITCLR(pPIC->INTMSK1, Hw4);
+    }
+}
+
+static void tcc8900_mask_irq_dma(unsigned int irq)
+{
+    if (irq != INT_DMA) {
+        BITCLR(pPIC->INTMSK0, Hw29);
+    }
+}
+
+static void tcc8900_mask_irq_tc0(unsigned int irq)
+{
+    if (irq != INT_TC0) {
+        BITCLR(pPIC->INTMSK0, Hw0);
+    }
+}
+
+/******************************************
+ * Enable IRQ
+ *****************************************/
+static void tcc8900_irq_enable(unsigned int irq)
+{
+    if (irq < 32) {
+        BITSET(pPIC->CLR0,      (1 << irq));
+        BITSET(pPIC->IEN0,      (1 << irq));
+        BITSET(pPIC->INTMSK0,   (1 << irq));
+    } else {
+        BITSET(pPIC->CLR1,      (1 << (irq - 32)));
+        BITSET(pPIC->IEN1,      (1 << (irq - 32)));
+        BITSET(pPIC->INTMSK1,   (1 << (irq - 32)));
+    }
+}
+
+static void tcc8900_unmask_irq(unsigned int irq)
+{
+    if (irq < 32) {
+        BITSET(pPIC->INTMSK0,   (1 << irq));
+        BITSET(pPIC->CLR0,      (1 << irq));
+    } else {
+        BITSET(pPIC->INTMSK1,   (1 << (irq - 32)));
+        BITSET(pPIC->CLR1,      (1 << (irq - 32)));
+    }
+}
+static void tcc8900_unmask_irq_uart(unsigned int irq)
+{
+    if (irq != INT_UART) {
+        BITSET(pPIC->INTMSK1, Hw15);
+    }
+}
+static void tcc8900_unmask_irq_gpsb(unsigned int irq)
+{
+    if (irq != INT_GPSB) {
+        BITSET(pPIC->INTMSK1, Hw4);
+    }
+}
+static void tcc8900_unmask_irq_dma(unsigned int irq)
+{
+    if (irq != INT_DMA) {
+        BITSET(pPIC->INTMSK0, Hw29);
+    }
+}
+
+static void tcc8900_unmask_irq_tc0(unsigned int irq)
+{
+    if (irq != INT_TC0) {
+        BITSET(pPIC->INTMSK0, Hw0);
+    }
+}
+
+/******************************************
+ * Ack IRQ (Disable IRQ)
+ *****************************************/
+
+static void tcc8900_irq_disable(unsigned int irq)
+{
+    if (irq < 32){
+        BITCLR(pPIC->IEN0,      (1 << irq));
+        BITCLR(pPIC->INTMSK0,   (1 << irq));
+    } else {
+        BITCLR(pPIC->IEN1,      (1 << (irq - 32)));
+        BITCLR(pPIC->INTMSK1,   (1 << (irq - 32)));
+    }
+}
+
+
+static void tcc8900_mask_ack_irq(unsigned int irq)
+{
+    if (irq < 32){
+        BITCLR(pPIC->INTMSK0,   (1 << irq));
+    } else {
+        BITCLR(pPIC->INTMSK1,   (1 << (irq - 32)));
+    }
+}
+
+static void tcc8900_mask_ack_irq_uart(unsigned int irq)
+{
+    if (irq != INT_UART) {
+        BITCLR(pPIC->INTMSK1, Hw15);
+    }
+}
+
+static void tcc8900_mask_ack_irq_gpsb(unsigned int irq)
+{
+    if (irq != INT_GPSB) {
+        BITCLR(pPIC->INTMSK1, Hw4);
+    }
+}
+
+static void tcc8900_mask_ack_irq_dma(unsigned int irq)
+{
+    if (irq != INT_DMA) {
+        BITCLR(pPIC->INTMSK0, Hw29);
+    }
+}
+
+static void tcc8900_mask_ack_irq_tc0(unsigned int irq)
+{
+    if (irq != INT_TC0) {
+        BITCLR(pPIC->INTMSK0, Hw0);
+    }
+}
+
+/******************************************
+ * wake IRQ
+ *****************************************/
+static int tcc8900_wake_irq(unsigned int irq, unsigned int enable)
+{
+    return 0;
+}
+
+static int tcc8900_wake_irq_uart(unsigned int irq, unsigned int enable)
+{
+    return 0;
+}
+
+static int tcc8900_wake_irq_gpsb(unsigned int irq, unsigned int enable)
+{
+    return 0;
+}
+
+static int tcc8900_wake_irq_dma(unsigned int irq, unsigned int enable)
+{
+    return 0;
+}
+
+static int tcc8900_wake_irq_tc0(unsigned int irq, unsigned int enable)
+{
+    return 0;
+}
+
+static void tcc8900_irq_dummy(unsigned int irq)
+{
+}
+
+static void tcc8900_irq_uart_handler(unsigned irq, struct irq_desc *desc)
+{
+    if (pUARTPORTMUX->CHST & Hw0) {
+        irq = INT_UART0;
+    } else if (pUARTPORTMUX->CHST & Hw1) {
+        irq = INT_UART1;
+    } else if (pUARTPORTMUX->CHST & Hw2) {
+        irq = INT_UART2;
+    } else if (pUARTPORTMUX->CHST & Hw3) {
+        irq = INT_UART3;
+    } else if (pUARTPORTMUX->CHST & Hw4) {
+        irq = INT_UART4;
+    } else if (pUARTPORTMUX->CHST & Hw5) {
+        irq = INT_UART5;
+    } else {
+	    //BITSET(pPIC->INTMSK1 , Hw15); // using INTMSK
+        BITSET(pPIC->CLR1, Hw15);
+        goto out;
+    }
+
+    desc = irq_desc + irq;
+    desc_handle_irq(irq, desc);
+out:
+    return;
+}
+
+static void tcc8900_irq_gpsb_handler(unsigned irq, struct irq_desc *desc)
+{
+    if (pPGPSBPORTCFG->CIRQST & Hw3) {
+        irq = INT_GPSB1_DMA;
+    } else if (pPGPSBPORTCFG->CIRQST & Hw1) {
+        irq = INT_GPSB0_DMA;
+    } else if (pPGPSBPORTCFG->CIRQST & Hw5) {
+        irq = INT_GPSB2_DMA;
+    } else if (pPGPSBPORTCFG->CIRQST & Hw3) {
+        irq = INT_GPSB0_CORE;
+    } else if (pPGPSBPORTCFG->CIRQST & Hw0) {
+        irq = INT_GPSB1_CORE;
+    } else if (pPGPSBPORTCFG->CIRQST & Hw2) {
+        irq = INT_GPSB2_CORE;
+	} else if (pPGPSBPORTCFG->CIRQST & Hw6) {
+        irq = INT_GPSB3_CORE;
+	} else if (pPGPSBPORTCFG->CIRQST & Hw8) {
+        irq = INT_GPSB4_CORE;
+	} else if (pPGPSBPORTCFG->CIRQST & Hw10) {
+        irq = INT_GPSB5_CORE;
+    } else {
+	    //BITSET(pPIC->INTMSK1 , Hw4);	// using INTMSK
+        BITSET(pPIC->CLR1, Hw4);
+        goto out;
+    }
+
+    desc = irq_desc + irq;
+    desc_handle_irq(irq, desc);
+out:
+    return;
+}
+
+static void tcc8900_irq_dma_handler(unsigned irq, struct irq_desc *desc)
+{
+	if (pPGDMACTRL0->CHCONFIG & (Hw18|Hw17|Hw16)) {
+		if (pPGDMACTRL0->CHCONFIG & Hw16) {
+			irq = INT_DMA0_CH0;
+		} else if (pPGDMACTRL0->CHCONFIG & Hw17) {
+			irq = INT_DMA0_CH1;
+		} else if (pPGDMACTRL0->CHCONFIG & Hw18) {
+			irq = INT_DMA0_CH2;
+		} else {
+			goto out1;
+		}
+	} else if (pPGDMACTRL1->CHCONFIG & (Hw18|Hw17|Hw16)) {
+		if (pPGDMACTRL1->CHCONFIG & Hw16) {
+			irq = INT_DMA1_CH0;
+		} else if (pPGDMACTRL1->CHCONFIG & Hw17) {
+			irq = INT_DMA1_CH1;
+		} else if (pPGDMACTRL1->CHCONFIG & Hw18) {
+			irq = INT_DMA1_CH2;
+		} else {
+			goto out1;
+		}
+
+	} else if (pPGDMACTRL2->CHCONFIG & (Hw18|Hw17|Hw16)) {
+		if (pPGDMACTRL2->CHCONFIG & Hw16) {
+			irq = INT_DMA2_CH0;
+		} else if (pPGDMACTRL2->CHCONFIG & Hw17) {
+			irq = INT_DMA2_CH1;
+		} else if (pPGDMACTRL2->CHCONFIG & Hw18) {
+			irq = INT_DMA2_CH2;
+		} else {
+			goto out1;
+		}
+
+	} else if (pPGDMACTRL3->CHCONFIG & (Hw18|Hw17|Hw16)) {
+		if (pPGDMACTRL3->CHCONFIG & Hw16) {
+			irq = INT_DMA3_CH0;
+		} else if (pPGDMACTRL3->CHCONFIG & Hw17) {
+			irq = INT_DMA3_CH1;
+		} else if (pPGDMACTRL3->CHCONFIG & Hw18) {
+			irq = INT_DMA3_CH2;
+		} else {
+			goto out1;
+		}
+
+	} else {
+out1:
+		BITSET(pPIC->CLR0, Hw29);
+		goto out2;
+	}
+	
+    desc = irq_desc + irq;
+    desc_handle_irq(irq, desc);
+out2:
+    return;
+}
+
+static void tcc8900_irq_tc0_handler(unsigned irq, struct irq_desc *desc)
+{
+	if (pTIMER->TIREQ & Hw0) {
+		irq = INT_TC0_TI0;
+	} else if (pTIMER->TIREQ & Hw1) {
+		irq = INT_TC0_TI1;
+	} else if (pTIMER->TIREQ & Hw2) {
+		irq = INT_TC0_TI2;
+	} else if (pTIMER->TIREQ & Hw3) {
+		irq = INT_TC0_TI3;
+	} else if (pTIMER->TIREQ & Hw4) {
+		irq = INT_TC0_TI4;
+	} else if (pTIMER->TIREQ & Hw5) {
+		irq = INT_TC0_TI5;
+	} else {
+		//BITSET(pPIC->INTMSK1 , Hw0);	// using INTMSK
+		BITSET(pPIC->CLR0, Hw0);
+		goto out;
+	}
+
+	desc = irq_desc + irq;
+	desc_handle_irq(irq, desc);
+out:
+	return;
+}
+
+
+static struct irq_chip tcc8900_irq_chip = {
+    .name       = "IRQ",
+    .enable     = tcc8900_irq_enable,
+    .disable    = tcc8900_irq_disable,
+    .ack        = tcc8900_mask_ack_irq,
+    .mask_ack   = tcc8900_mask_ack_irq,
+    .mask       = tcc8900_mask_irq,
+    .unmask     = tcc8900_unmask_irq,
+    .set_wake   = tcc8900_wake_irq,
+};
+
+static struct irq_chip tcc8900_irq_uart_chip = {
+    .name       = "IRQ_UART",
+    .enable     = tcc8900_irq_dummy,
+    .disable    = tcc8900_irq_dummy,
+    .ack        = tcc8900_mask_ack_irq_uart,
+    .mask_ack   = tcc8900_mask_ack_irq_uart,
+    .mask       = tcc8900_mask_irq_uart,
+    .unmask     = tcc8900_unmask_irq_uart,
+    .set_wake   = tcc8900_wake_irq_uart,
+};
+
+static struct irq_chip tcc8900_irq_gpsb_chip = {
+    .name       = "IRQ_GPSB",
+    .enable     = tcc8900_irq_dummy,
+    .disable    = tcc8900_irq_dummy,
+    .ack        = tcc8900_mask_ack_irq_gpsb,
+    .mask_ack   = tcc8900_mask_ack_irq_gpsb,
+    .mask       = tcc8900_mask_irq_gpsb,
+    .unmask     = tcc8900_unmask_irq_gpsb,
+    .set_wake   = tcc8900_wake_irq_gpsb,
+};
+
+static struct irq_chip tcc8900_irq_dma_chip = {
+    .name       = "IRQ_DMA",
+    .enable     = tcc8900_irq_dummy,
+    .disable    = tcc8900_irq_dummy,
+    .ack        = tcc8900_mask_ack_irq_dma,
+    .mask_ack   = tcc8900_mask_ack_irq_dma,
+    .mask       = tcc8900_mask_irq_dma,
+    .unmask     = tcc8900_unmask_irq_dma,
+    .set_wake   = tcc8900_wake_irq_dma,
+};
+
+static struct irq_chip tcc8900_irq_tc0_chip = {
+    .name       = "IRQ_TC0",
+    .enable     = tcc8900_irq_dummy,
+    .disable    = tcc8900_irq_dummy,
+    .ack        = tcc8900_mask_ack_irq_tc0,
+    .mask_ack   = tcc8900_mask_ack_irq_tc0,
+    .mask       = tcc8900_mask_irq_tc0,
+    .unmask     = tcc8900_unmask_irq_tc0,
+    .set_wake   = tcc8900_wake_irq_tc0,
+};
+
+void __init tcc8900_irq_init(void)
+{
+	int irqno;
+
+	printk("%s\n", __func__);
+
+	//reset interrupt 
+	pPIC = (volatile PPIC)tcc_p2v(HwPIC_BASE);
+	pVIC = (volatile PVIC)tcc_p2v(HwVIC_BASE);
+	pPGPSBPORTCFG = (volatile PGPSBPORTCFG)tcc_p2v(HwGPSBPORTCFG_BASE);
+	pUARTPORTMUX = (volatile PUARTPORTMUX)tcc_p2v(HwUARTPORTMUX_BASE);
+	pPGDMACTRL0 = (volatile PGDMACTRL)tcc_p2v(HwGDMA0_BASE);
+	pPGDMACTRL1 = (volatile PGDMACTRL)tcc_p2v(HwGDMA1_BASE);
+	pPGDMACTRL2 = (volatile PGDMACTRL)tcc_p2v(HwGDMA2_BASE);
+	pPGDMACTRL3 = (volatile PGDMACTRL)tcc_p2v(HwGDMA3_BASE);
+	pTIMER = (volatile PTIMER)tcc_p2v(HwTMR_BASE);
+
+
+	/* ADD IOREMAP */
+
+	//clear IEN Field
+	BITCLR(pPIC->IEN0 , 0xFFFFFFFF); // All Interrupt Disable
+	BITCLR(pPIC->IEN1 , 0xFFFFFFFF); // All Interrupt Disable
+
+	//clear SEL Field
+	BITSET(pPIC->SEL0 , 0xFFFFFFFF); //using IRQ
+	BITSET(pPIC->SEL1 , 0xFFFFFFFF); //using IRQ
+
+	//clear TIG Field
+	BITCLR(pPIC->TIG0 , 0xFFFFFFFF); //Test Interrupt Disable
+	BITCLR(pPIC->TIG1 , 0xFFFFFFFF); //Test Interrupt Disable
+
+	//clear POL Field
+	BITCLR(pPIC->POL0 , 0xFFFFFFFF); //Default ACTIVE Low
+	BITCLR(pPIC->POL1 , 0xFFFFFFFF); //Default ACTIVE Low
+
+	//clear MODE Field
+	BITSET(pPIC->MODE0 , 0xFFFFFFFF); //Trigger Mode - Level Trigger Mode
+	BITSET(pPIC->MODE1 , 0xFFFFFFFF); //Trigger Mode - Level Trigger Mode
+
+	//clear SYNC Field
+	BITSET(pPIC->SYNC0 , 0xFFFFFFFF); //SYNC Enable
+	BITSET(pPIC->SYNC1 , 0xFFFFFFFF); //SYNC Enable
+
+	//clear WKEN Field
+	BITCLR(pPIC->WKEN0 , 0xFFFFFFFF); //Wakeup all disable
+	BITCLR(pPIC->WKEN1 , 0xFFFFFFFF); //Wakeup all disable
+
+	//celar MODEA Field
+	BITCLR(pPIC->MODEA0 , 0xFFFFFFFF); //both edge - all disable
+	BITCLR(pPIC->MODEA1 , 0xFFFFFFFF); //both edge - all disable
+
+	//clear INTMSK Field
+	BITCLR(pPIC->INTMSK0 , 0xFFFFFFFF); //not using INTMSK
+	BITCLR(pPIC->INTMSK1 , 0xFFFFFFFF); //not using INTMSK
+
+	//clear ALLMSK Field
+	BITCSET(pPIC->ALLMSK , 0xFFFFFFFF, 0x1); //using only IRQ
+
+	/* Install the interrupt handlers */
+	for(irqno = INT_TC0; irqno <= INT_AEIRQ; irqno++)
+	{
+		if (irqno == INT_UART) {
+			set_irq_chip(INT_UART, &tcc8900_irq_uart_chip);
+			set_irq_chained_handler(INT_UART, tcc8900_irq_uart_handler);
+		} else if (irqno == INT_GPSB) {
+			set_irq_chip(INT_GPSB, &tcc8900_irq_gpsb_chip);
+			set_irq_chained_handler(INT_GPSB, tcc8900_irq_gpsb_handler);
+		} else if (irqno == INT_DMA) {
+			set_irq_chip(INT_DMA, &tcc8900_irq_dma_chip);
+			set_irq_chained_handler(INT_DMA, tcc8900_irq_dma_handler);
+		} else if (irqno == INT_TC0) {
+			set_irq_chip(INT_TC0, &tcc8900_irq_tc0_chip);
+			set_irq_chained_handler(INT_TC0, tcc8900_irq_tc0_handler);
+		} else {
+			set_irq_chip(irqno, &tcc8900_irq_chip);
+			set_irq_handler(irqno, handle_level_irq);
+			set_irq_flags(irqno, IRQF_VALID);
+		}
+	}
+
+	/* Install the interrupt UART Group handlers */
+	for (irqno = INT_UART0; irqno <= INT_UART5; irqno++) {
+		set_irq_chip(irqno, &tcc8900_irq_uart_chip);
+		set_irq_handler(irqno, handle_level_irq);
+		set_irq_flags(irqno, IRQF_VALID);
+	}
+
+	/* Install the interrupt GPSB Group handlers */
+	for (irqno = INT_GPSB0_DMA; irqno <= INT_GPSB5_CORE; irqno++) {
+		set_irq_chip(irqno, &tcc8900_irq_gpsb_chip);
+		set_irq_handler(irqno, handle_level_irq);
+		set_irq_flags(irqno, IRQF_VALID);
+	}
+
+	/* Install the interrupt DMA Group handlers */
+	for (irqno = INT_DMA0_CH0; irqno <= INT_DMA3_CH2; irqno++) {
+		set_irq_chip(irqno, &tcc8900_irq_dma_chip);
+		set_irq_handler(irqno, handle_level_irq);
+		set_irq_flags(irqno, IRQF_VALID);
+	}
+
+	/* Install the interrupt TC0 Group handlers */
+	for (irqno = INT_TC0_TI0; irqno <= INT_TC0_TI5; irqno++) {
+		set_irq_chip(irqno, &tcc8900_irq_tc0_chip);
+		set_irq_handler(irqno, handle_level_irq);
+		set_irq_flags(irqno, IRQF_VALID);
+	}
+
+
+    /* IEN SET */
+	BITSET(pPIC->IEN1,      Hw15);	/* UART */
+	BITSET(pPIC->INTMSK1,   Hw15);
+	BITSET(pPIC->IEN1,      Hw4);	/* GPSB */
+	BITSET(pPIC->INTMSK1,   Hw4);
+	BITSET(pPIC->IEN0,      Hw29);	/* DMA */
+	BITSET(pPIC->INTMSK0,   Hw29);
+	BITSET(pPIC->IEN0,		Hw0);	/* TC0 */
+	BITSET(pPIC->INTMSK0,	Hw0);
+}
+
+/* end of file */
Index: linux-2.6.29/arch/arm/mach-tcc8900/tca_ckc.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/tca_ckc.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,1174 @@
+/****************************************************************************
+ *	 FileName	 : tca_ckc.c
+ *	 Description : 
+ ****************************************************************************
+*
+ *	 TCC Version 1.0
+ *	 Copyright (c) Telechips, Inc.
+ *	 ALL RIGHTS RESERVED
+*
+ ****************************************************************************/
+
+
+#if defined(_LINUX_)
+#   include <bsp.h>
+#   include <asm/io.h> 
+#	include <linux/mm.h>	// for PAGE_ALIGN
+#	include <linux/kernel.h>
+#	include <linux/module.h>
+#	ifndef VOLATILE
+#	define VOLATILE
+#	endif
+#else
+#	include <bsp.h>
+#   include "oal_memory.h"
+#   include "tca_ckc.h"
+#	ifndef VOLATILE
+#	define VOLATILE volatile
+#	endif
+#endif
+
+typedef struct {
+	unsigned			uFpll;
+	unsigned char		P, M, S, dummy;
+} sfPLL;
+
+#define PLLFREQ(P, M, S)		(( 120000 * (M) )  / (P) ) >> (S) // 100Hz Unit..
+#define FPLL_t(P, M, S) 	PLLFREQ(P,M,S), P, M, S
+// PLL table for XIN=12MHz
+ // P,	 M,  S
+sfPLL	pIO_CKC_PLL[]	=
+{
+		 {FPLL_t(3,  78, 1)}		// 156MHz 
+		,{FPLL_t(3, 120, 1)}		// 240 MHz
+		,{FPLL_t(3, 135, 1)}		// 270.0 MHz
+		,{FPLL_t(2,  52, 0)}		// 312 MHz
+		,{FPLL_t(3,  95, 0)}		// 380 MHz
+		,{FPLL_t(1, 39,   0)}			// 468 MHz
+		,{FPLL_t(1,  40, 0)}		// 480 MHz
+		,{FPLL_t(1, 44,   0)}			// 528 MHz
+		,{FPLL_t(2, 104,   0)}			// 624 MHz
+		,{FPLL_t(2, 116,   0)}			// 696 MHz		
+
+
+};
+
+sfPLL	pIO_CKC_PLL0[]	=
+{
+		 {FPLL_t(2, 176, 3)}		// 132 MHz 
+		, {FPLL_t(2, 192, 3)}		// 144 MHz 
+		, {FPLL_t(3, 146, 2)}		// 146 MHz 
+		, {FPLL_t(1, 30, 1)}		// 180 MHz 
+		, {FPLL_t(3, 95, 1)}		// 190 MHz 
+		, {FPLL_t(1, 32, 1)}		// 192 MHz 
+		, {FPLL_t(3, 202, 2)}		// 202 MHz 
+		, {FPLL_t(2, 144, 2)}		// 216 MHz 
+		, {FPLL_t(2, 148, 2)}		// 222 MHz 
+		, {FPLL_t(3, 230, 2)}		// 230 MHz 
+		,{FPLL_t(2, 216, 2)}		// 324 MHz
+		,{FPLL_t(2, 144, 1)}		// 432 MHz
+		,{FPLL_t(2, 162, 1)}		// 486 MHz
+		,{FPLL_t(2, 180, 1)}		// 540 MHz
+		,{FPLL_t(2, 200, 1)}		// 600 MHz
+};
+
+#define NUM_PLL 				(sizeof(pIO_CKC_PLL)/sizeof(sfPLL))
+#define NUM_PLL0 				(sizeof(pIO_CKC_PLL0)/sizeof(sfPLL))
+
+#define tca_wait()				{ volatile int i; for (i=0; i<0x2000; i++); }
+
+#if defined(_LINUX_)
+    #define iomap_p2v(x)            (x)
+#else
+//	#define iomap_p2v(x)			(x & ~0x40000000) //0xF0400000 -> 0xB04 
+	#define iomap_p2v(x)			(OALPAtoVA(x,FALSE)) //0xF0400000 -> 0xB04 
+#endif
+
+/****************************************************************************************
+* Global Variable
+* ***************************************************************************************/
+PCKC	pCKC ;
+PPMU	pPMU ; 
+PIOBUSCFG pIOBUSCFG;
+
+/****************************************************************************************
+* FUNCTION :void tca_ckc_init(void)
+* DESCRIPTION :
+* ***************************************************************************************/
+VOLATILE void tca_ckc_init(void)
+{
+	pCKC = (PCKC)(iomap_p2v((unsigned int)&HwCLK_BASE)); //0xF0400000
+	pPMU = (PPMU)(iomap_p2v((unsigned int)&HwPMU_BASE)); //0xF0404000
+	pIOBUSCFG = (PIOBUSCFG)(iomap_p2v((unsigned int)&HwIOBUSCFG_BASE)); //0xF05F5000
+	
+}
+/****************************************************************************************
+* FUNCTION :unsigned int tca_ckc_getpll(unsigned int ch)
+* DESCRIPTION :
+* ***************************************************************************************/
+VOLATILE unsigned int tca_ckc_getpll(unsigned int ch)
+{
+	volatile unsigned	tPLL;
+	volatile unsigned	tPLLCFG;
+	unsigned	iP=0, iM=0, iS=0;
+
+	switch(ch)
+	{
+		case DIRECTPLL0:
+			tPLLCFG = pCKC->PLL0CFG;
+			break;
+		case DIRECTPLL1:
+			tPLLCFG = pCKC->PLL1CFG;
+			break;
+		case DIRECTPLL2:
+			tPLLCFG = pCKC->PLL2CFG;
+			break;
+		case DIRECTPLL3:
+			tPLLCFG = pCKC->PLL3CFG;
+			break;
+	}
+
+	//Fpll Clock
+	iS	= (tPLLCFG & 0x7000000) >> 24;
+	iM	= (tPLLCFG & 0xFFF00) >> 8;
+	iP	= (tPLLCFG & 0x0003F) >> 0;
+
+	tPLL= (((120000 * iM )/ iP) >> (iS));
+	
+	return tPLL;
+
+}
+
+/****************************************************************************************
+* FUNCTION :unsigned int tca_ckc_getcpu(void)
+* DESCRIPTION : 
+* ***************************************************************************************/
+VOLATILE unsigned int tca_ckc_getcpu(void)
+{
+	unsigned int lcpu = 0;
+	unsigned int lconfig = 0;
+	unsigned int lcnt = 0;
+	unsigned int li = 0;
+	unsigned int lclksource = 0;
+	
+	lconfig = ((pCKC->CLK0CTRL & (Hw20-Hw4))>>4);
+
+	for(li = 0; li < 16; li++)
+	{
+		if((lconfig & Hw0) == 1)
+			lcnt++;
+		lconfig = (lconfig >> 1);
+	}
+
+	switch(pCKC->CLK0CTRL & (Hw3-Hw0)) // Check CPU Source
+	{
+		case PCDIRECTPLL0 :
+			lclksource =  tca_ckc_getpll(0);
+			break;
+		case PCDIRECTPLL1 :
+			lclksource =  tca_ckc_getpll(1);
+			break;
+		case PCDIRECTPLL2 :
+			lclksource =  tca_ckc_getpll(2);
+			break;
+		case PCDIRECTPLL3 :
+			lclksource =  tca_ckc_getpll(3);
+			break;
+		case PCDIRECTXIN :
+			lclksource =  120000;
+			break;
+		case PCHDMI :
+			lclksource =  270000;
+			break;
+		case PCSATA :
+			lclksource =  250000;		
+			break;
+		case PCUSBPHY:
+			lclksource =  480000;		
+			break;
+		default : 
+			lclksource =  tca_ckc_getpll(1);
+			break;
+	}
+	
+	if(pCKC->CLK0CTRL & Hw20) // Dynamic Mode
+	{
+		lcnt = pCKC->CLK0CTRL & (Hw8-Hw4);
+		lcnt = lcnt>>4;
+		lcpu = (lclksource / lcnt);
+	}
+	else
+		lcpu = (lclksource * lcnt)/16;
+
+	return lcpu;
+}
+
+/****************************************************************************************
+* FUNCTION :unsigned int tca_ckc_getbus(void)
+* DESCRIPTION : 
+* ***************************************************************************************/
+VOLATILE unsigned int tca_ckc_getbus(void)
+{
+	unsigned int lbus = 0;
+	unsigned int lconfig = 0;
+	unsigned int lclksource = 0;
+	
+	lconfig = ((pCKC->CLK2CTRL & (Hw8-Hw4))>>4);
+
+	switch(pCKC->CLK2CTRL & (Hw3-Hw0)) // Check CPU Source
+	{
+		case PCDIRECTPLL0 :
+			lclksource =  tca_ckc_getpll(0);
+			break;
+		case PCDIRECTPLL1 :
+			lclksource =  tca_ckc_getpll(1);
+			break;
+		case PCDIRECTPLL2 :
+			lclksource =  tca_ckc_getpll(2);
+			break;
+		case PCDIRECTPLL3 :
+			lclksource =  tca_ckc_getpll(3);
+			break;
+		case PCDIRECTXIN :
+			lclksource =  120000;
+			break;
+		case PCHDMI :
+			lclksource =  270000;
+			break;
+		case PCSATA :
+			lclksource =  250000;		
+			break;
+		case PCUSBPHY:
+			lclksource =  480000;		
+			break;
+		default : 
+			lclksource =  tca_ckc_getpll(1);
+			break;
+	}
+
+	lbus = lclksource /(lconfig+1);
+
+	return lbus;
+}
+
+/****************************************************************************************
+* FUNCTION :static unsigned int tca_ckc_setclkctrlx(unsigned int isenable,unsigned int md,unsigned int config,unsigned int sel)
+* DESCRIPTION : not ctrl 0 and ctrl 2 (CPU, BUS CTRL)
+* ***************************************************************************************/
+VOLATILE static unsigned int tca_ckc_gclkctrlx(unsigned int isenable,unsigned int md,unsigned int config,unsigned int sel)
+{
+	unsigned int retVal = 0;
+
+	retVal = ((isenable?1:0)<<21)|(md<<20)|(config<<4)|(sel<<0);
+	
+	return retVal;
+}
+
+/****************************************************************************************
+* FUNCTION :static unsigned int tca_ckc_clkctrly(unsigned int isenable,unsigned int md,unsigned int config,unsigned int sel)
+* DESCRIPTION : ctrl 0 and ctrl 2 (CPU and BUS CTRL)
+*				config is divider (md = 0)
+* ***************************************************************************************/
+VOLATILE static unsigned int tca_ckc_gclkctrly(unsigned int isenable,unsigned int md,unsigned int config,unsigned int sel, unsigned int ch)
+{
+	unsigned int retVal = 0;
+//	md = 0; // Normal Mode
+
+	if(ch == CLKCTRL0)
+	{
+		switch(config)
+		{
+			case CLKDIV0:
+					config = 0xFFFF; // 1111111111111111b 16/16
+				break;
+			case CLKDIV2:
+					config = 0xAAAA; // 1010101010101010b 8/16
+				break;
+			case CLKDIV3:
+					config = 0x9249; // 1001001001001001b 6/16
+				break;
+			case CLKDIV4:
+					config = 0x8888; // 1000100010001000b 4/16
+				break;
+			case CLKDIVNONCHANGE:
+					config = 0xFFFF; // 1111111111111111b
+				break;
+			default:
+					config = 0xFFFF; // 1111111111111111b
+				break;
+		}
+	}
+
+	if(config == CLKDIVNONCHANGE)
+	{
+		if(ch == 0) // Fcpu
+			retVal = (pCKC->CLK0CTRL & (Hw20-Hw4));
+		else		// Fmem_bus 
+			retVal = (pCKC->CLK2CTRL & (Hw20-Hw4));
+			
+		retVal |= ((isenable?1:0)<<21)|(md<<20)|(sel<<0);
+
+	}
+	else
+		retVal = ((isenable?1:0)<<21)|(md<<20)|(config<<4)|(sel<<0);
+	
+	return retVal;
+}
+
+/****************************************************************************************
+* FUNCTION :void tca_ckc_setfbusctrl(unsigned int clkname,unsigned int isenable,unsigned int freq, unsigned int sor)
+* DESCRIPTION :
+* ***************************************************************************************/
+VOLATILE void tca_ckc_setfbusctrl(unsigned int clkname,unsigned int isenable,unsigned int md,unsigned int freq, unsigned int sor)
+{
+	volatile unsigned	*pCLKCTRL;
+	unsigned int clkdiv = 0;
+	unsigned int clksource = 0;
+	unsigned int lconfig = 0;
+	
+	pCLKCTRL =(volatile unsigned	*)((&pCKC->CLK0CTRL)+clkname); 
+
+	switch(sor)
+	{
+		case DIRECTPLL0 :
+			clksource =  tca_ckc_getpll(0);
+			break;
+		case DIRECTPLL1 :
+			clksource =  tca_ckc_getpll(1);
+			break;
+		case DIRECTPLL2 :
+			clksource =  tca_ckc_getpll(2);
+			break;
+		case DIRECTPLL3 :
+			clksource =  tca_ckc_getpll(3);
+			break;
+		case DIRECTXIN:
+			clksource =  120000;
+			break;
+		default : 
+			clksource =  tca_ckc_getpll(1);
+			break;
+	}
+
+	if (freq != 0)
+	{
+		clkdiv	= (clksource + (freq>>1)) / freq ;	// should be even number of division factor
+		clkdiv -= 1;
+	}
+	else
+		clkdiv	= 1;
+
+	if(clkdiv == CLKDIV0) // The config value should not be "ZERO" = 1/(config+1)
+		clkdiv = 1;
+
+
+	if(md == DYNAMIC_MD && !(clkname == CLKCTRL0 || clkname == CLKCTRL2))
+	{
+		/*
+			CONFIG[3:0] 	: Curretn Divisor(Read-only)
+			CONFIG[7:4] 	: Max. Divisor
+			CONFIG[11:8]	: Min. Divisor
+			CONFIG[15:12]	: Update Cycle Period
+		*/
+			lconfig = (clkdiv<<8); //Min. Divisor
+			clkdiv = 10; //Max. Divisor
+			lconfig |= ((clkdiv<<4)| 0xF000);	// Min. Divisor = Max. Divisor/2, Update Cycle Period = F
+			
+			clkdiv = lconfig;
+	}
+
+	if(clkname == CLKCTRL0 || clkname == CLKCTRL2)
+	{
+		*pCLKCTRL = tca_ckc_gclkctrly(isenable,md,clkdiv,sor,clkname);
+	}
+	else
+	{
+		if(isenable == 0)
+			*pCLKCTRL &= ~Hw21;
+		else
+			*pCLKCTRL = tca_ckc_gclkctrlx(isenable,md,clkdiv,sor);
+	}
+	
+}
+
+/****************************************************************************************
+* FUNCTION :void tca_ckc_getfbusctrl(unsigned int clkname)
+* DESCRIPTION :
+* ***************************************************************************************/
+VOLATILE int tca_ckc_getfbusctrl(unsigned int clkname)
+{
+	volatile unsigned	*pCLKCTRL;
+	unsigned int lcheck = 0;
+	unsigned int lmd = 0;
+	unsigned int lconfig = 0;
+	unsigned int lsel = 0;
+	unsigned int clksource = 0; 
+
+	pCLKCTRL =(volatile unsigned	*)((&pCKC->CLK0CTRL)+clkname); 
+
+	lcheck = ((*pCLKCTRL >> 21) & Hw0);
+	lmd = ((*pCLKCTRL >> 20) & Hw0);
+	lconfig = ((*pCLKCTRL >> 4) & 0xF);
+	lsel = ((*pCLKCTRL) & 0x7);
+	
+	if(!lcheck || (clkname == CLKCTRL0 || clkname == CLKCTRL2))
+		return -1;
+
+	if(lmd == 0)
+	{
+		switch(lsel)
+		{
+			case DIRECTPLL0 :
+				clksource =  tca_ckc_getpll(0);
+				break;
+			case DIRECTPLL1 :
+				clksource =  tca_ckc_getpll(1);
+				break;
+			case DIRECTPLL2 :
+				clksource =  tca_ckc_getpll(2);
+				break;
+			case DIRECTPLL3 :
+				clksource =  tca_ckc_getpll(3);
+				break;
+			case DIRECTXIN:
+				clksource =  120000;
+				break;
+			default : 
+				clksource =  tca_ckc_getpll(1);
+				break;
+		}
+
+	}
+	else
+		return -1;
+			
+	return (clksource / (lconfig+1));
+}
+
+/****************************************************************************************
+* FUNCTION :static unsigned int tca_ckc_setpllxcfg(unsigned int isEnable, int P, int M, int S)
+* DESCRIPTION :
+* ***************************************************************************************/
+VOLATILE static unsigned int tca_ckc_gpllxcfg(unsigned int isenable, unsigned int p, unsigned int m, unsigned int s)
+{
+	unsigned int retVal = Hw31;//Disable
+	
+	if(isenable > 0)
+	{
+		retVal = (s<<24)|(m<<8)|(p<<0);
+		retVal |= Hw31;	//Enable
+	}
+
+	return retVal;
+}
+
+/****************************************************************************************
+* FUNCTION :static void tca_ckc_pll(unsigned int p, unsigned int m, unsigned int s,unsigned int ch)
+* DESCRIPTION :
+* ***************************************************************************************/
+VOLATILE static void tca_ckc_pll(unsigned int p, unsigned int m, unsigned int s,unsigned int ch)
+{
+	volatile unsigned	*pPLLCFG;
+
+	pPLLCFG =(volatile unsigned *)((&pCKC->PLL0CFG)+ch);	
+
+	if(ch == 0) // PLL0 is System Clock Source
+	{
+		// Change System Clock Souce --> XIN (12Mhz)
+	//	pCKC->CLK0CTRL = tca_ckc_gclkctrly(ENABLE,NORMAL_MD,CLKDIVNONCHANGE,DIRECTXIN,0);
+		pCKC->CLK0CTRL = tca_ckc_gclkctrly(ENABLE,NORMAL_MD,CLKDIVNONCHANGE,DIRECTPLL2,0);
+		tca_wait(); 
+	}
+	
+	//Disable PLL
+	*pPLLCFG &= ~Hw31;
+	//Set PMS
+	*pPLLCFG = tca_ckc_gpllxcfg(ENABLE,p,m,s);
+	//Enable PLL
+	*pPLLCFG |= Hw31;
+	tca_wait(); 
+	//Restore System Clock Source
+	if(ch == 0)
+	{
+		//pCKC->CLK2CTRL = tca_ckc_gclkctrly(ENABLE,NORMAL_MD,CLKDIVNONCHANGE,DIRECTPLL0,2);
+		pCKC->CLK0CTRL = tca_ckc_gclkctrly(ENABLE,NORMAL_MD,CLKDIVNONCHANGE,DIRECTPLL0,0);
+	}
+	
+}
+
+
+/****************************************************************************************
+* FUNCTION :void tca_ckc_validpll(unsigned int * pvalidpll)
+* DESCRIPTION :
+* ***************************************************************************************/
+VOLATILE void tca_ckc_validpll(unsigned int * pvalidpll)
+{
+	unsigned int uCnt;
+	sfPLL		*pPLL;
+
+	pPLL	= &pIO_CKC_PLL[0];
+	for (uCnt = 0; uCnt < NUM_PLL; uCnt ++, pPLL ++)
+	{
+		*pvalidpll = pPLL->uFpll ;		
+		pvalidpll++;
+	}
+};
+
+/****************************************************************************************
+* FUNCTION :int tca_ckc_setpll(unsigned int pll, unsigned int ch)
+* DESCRIPTION :
+* ***************************************************************************************/
+VOLATILE int tca_ckc_setpll(unsigned int pll, unsigned int ch)
+{
+	unsigned	uCnt;
+	int 		retVal = -1;
+	unsigned int num_pll;
+	
+	sfPLL		*pPLL;
+
+	if(pll != 0 )
+	{
+		if(ch == 0)
+		{
+			pPLL	= &pIO_CKC_PLL0[0];
+			num_pll = NUM_PLL0;
+		}
+		else
+		{
+			pPLL	= &pIO_CKC_PLL[0];
+			num_pll = NUM_PLL;
+		}
+		
+		for (uCnt = 0; uCnt < num_pll; uCnt ++, pPLL ++)
+			if (pPLL->uFpll == pll)
+				break;
+		
+		if (uCnt < num_pll)
+		{
+			tca_ckc_pll(pPLL->P,pPLL->M ,pPLL->S,ch);
+			retVal = 0;
+			return 1;
+		}
+	}
+
+	return -1;
+}
+
+/****************************************************************************************
+* FUNCTION :void tca_ckc_setcpu(unsigned int n)
+* DESCRIPTION :  n is n/16 
+* example : CPU == PLL : n=16 - CPU == PLL/2 : n=8
+* ***************************************************************************************/
+VOLATILE void tca_ckc_setcpu(unsigned int n)
+{
+	 unsigned int lckc0ctrl;	
+	 unsigned int lindex[] = {0x0,0x8000,0x8008,0x8808,0x8888,0xA888,0xA8A8,0xAAA8,0xAAAA,
+							0xECCC,0xEECC,0xEEEC,0xEEEE,0xFEEE,0xFFEE,0xFFFE,0xFFFF};
+
+
+	lckc0ctrl = pCKC->CLK0CTRL;
+	lckc0ctrl &= ~(Hw20-Hw4);
+	lckc0ctrl |= (lindex[n] << 4);
+
+	pCKC->CLK0CTRL = lckc0ctrl;
+}
+
+/****************************************************************************************
+* FUNCTION :void tca_ckc_setpmupwroff( unsigned int periname , unsigned int isenable)
+* DESCRIPTION : PMU Block :  Power Off Register
+* PMU_VIDEODAC
+* PMU_HDMIPHY	  
+* PMU_LVDSPHY	  
+* PMU_USBNANOPHY   
+* PMU_SATAPHY 
+* PMU_MEMORYBUS	
+* PMU_VIDEOBUS
+* PMU_DDIBUS
+* PMU_GRAPHICBUS
+* PMU_IOBUS
+* ***************************************************************************************/
+VOLATILE void tca_ckc_setpmupwroff( unsigned int periname , unsigned int isenable)
+{
+	unsigned int retVal = 0;
+
+	switch(periname)
+	{
+		case PMU_VIDEODAC:
+				retVal = (Hw0);	
+			break;
+		case PMU_HDMIPHY:
+				retVal = (Hw1);	
+			break;
+		case PMU_LVDSPHY:
+				retVal = (Hw2);	
+			break;
+		case PMU_USBNANOPHY:
+				retVal = (Hw3);	
+			break;
+		case PMU_SATAPHY:
+				retVal = (Hw4);	
+			break;
+		case PMU_MEMORYBUS:
+				retVal = (Hw5);	
+			break;
+		case PMU_VIDEOBUS:
+				retVal = (Hw6);	
+			break;
+		case PMU_DDIBUS:
+				retVal = (Hw7);	
+			break;
+		case PMU_GRAPHICBUS:
+				retVal = (Hw8);	
+			break;
+		case PMU_IOBUS:
+				retVal = (Hw9);	
+			break;
+		default:
+			break;
+	}
+
+	if(isenable)
+		pPMU->PWROFF &= ~(retVal);
+	else
+		pPMU->PWROFF |= (retVal);
+	
+}
+/****************************************************************************************
+* FUNCTION :void tca_ckc_getpmupwroff( unsigned int pmuoffname)
+* DESCRIPTION : 
+* ***************************************************************************************/
+VOLATILE int tca_ckc_getpmupwroff( unsigned int pmuoffname)
+{
+	unsigned int retVal = 0;
+	
+	switch(pmuoffname)
+	{
+		case PMU_VIDEODAC:
+				retVal =  (pPMU->PWROFF >> 0)  & Hw0;	
+			break;
+		case PMU_HDMIPHY:
+				retVal =  (pPMU->PWROFF >> 1)  & Hw0;	
+			break;
+		case PMU_LVDSPHY:
+				retVal =  (pPMU->PWROFF >> 2)  & Hw0;	
+			break;
+		case PMU_USBNANOPHY:
+				retVal =  (pPMU->PWROFF >> 3)  & Hw0;	
+			break;
+		case PMU_SATAPHY:
+				retVal =  (pPMU->PWROFF >> 4)  & Hw0;	
+			break;
+		case PMU_MEMORYBUS:
+				retVal =  (pPMU->PWROFF >> 5)  & Hw0;	
+			break;
+		case PMU_VIDEOBUS:
+				retVal =  (pPMU->PWROFF >> 6)  & Hw0;	
+			break;
+		case PMU_DDIBUS:
+				retVal =  (pPMU->PWROFF >> 7)  & Hw0;	
+			break;
+		case PMU_GRAPHICBUS:
+				retVal =  (pPMU->PWROFF >> 8)  & Hw0;	
+			break;
+		case PMU_IOBUS:
+				retVal =  (pPMU->PWROFF >> 9)  & Hw0;	
+			break;
+		default:
+			break;
+	}
+
+	return retVal;
+}
+
+/****************************************************************************************
+* FUNCTION :static unsigned int tca_ckc_setpckxxx(unsigned int isenable, unsigned int sel, unsigned int div)
+* DESCRIPTION : 
+* ***************************************************************************************/
+VOLATILE static unsigned int tca_ckc_gpckxxx(unsigned int isenable, unsigned int sel, unsigned int div)
+{
+	unsigned int retVal = Hw28; //Enable
+
+	if(isenable > 0)
+	{
+		retVal = ((isenable?1:0)<<28)|(sel<<24)|(div<<0);
+	}
+
+	return retVal;
+}
+
+/****************************************************************************************
+* FUNCTION :static unsigned int tca_ckc_setpckyyy(unsigned int isenable, unsigned int sel, unsigned int div)
+* DESCRIPTION : md (1: divider Mode, 0:DCO Mode)
+* ***************************************************************************************/
+VOLATILE static unsigned int tca_ckc_gpckyyy(unsigned int isenable, unsigned int md, unsigned int sel, unsigned int div)
+{
+	unsigned int retVal = Hw28;//Enable
+
+	if(isenable > 0)
+	{
+		retVal = (md<<31)|((isenable?1:0)<<28)|(sel<<24)|(div<<0);
+	}
+
+	return retVal;
+}
+
+/****************************************************************************************
+* FUNCTION :void tca_ckc_setperi(unsigned int periname,unsigned int isenable, unsigned int freq, unsigned int sor)
+* DESCRIPTION : 
+* ***************************************************************************************/
+VOLATILE void tca_ckc_setperi(unsigned int periname,unsigned int isenable, unsigned int freq, unsigned int sor)
+{
+	unsigned uPll;
+	unsigned int clkdiv = 0;
+	unsigned int lclksource = 0;
+	unsigned int clkmode = 1;
+	
+	volatile unsigned	*pPERI;
+	pPERI =(volatile unsigned	*)((&pCKC->PCLK_TCX)+periname); 
+
+	switch(sor)
+	{
+		case PCDIRECTPLL0 :
+			lclksource =  tca_ckc_getpll(0);
+			break;
+		case PCDIRECTPLL1 :
+			lclksource =  tca_ckc_getpll(1);
+			break;
+		case PCDIRECTPLL2 :
+			lclksource =  tca_ckc_getpll(2);
+			break;
+		case PCDIRECTPLL3 :
+			lclksource =  tca_ckc_getpll(3);
+			break;
+		case PCDIRECTXIN :
+			lclksource =  120000;
+			break;
+		case PCHDMI :
+			lclksource =  270000;
+			break;
+		case PCSATA :
+			lclksource =  250000;		
+			break;
+		case PCUSBPHY:
+			lclksource =  480000;		
+			break;
+		default : 
+			lclksource =  tca_ckc_getpll(1);
+			break;
+	}
+	
+	if (freq != 0)
+	{
+		clkdiv	= (lclksource + (freq>>1)) / freq ; // should be even number of division factor
+		clkdiv -= 1;
+	}
+	else
+		clkdiv	= 0;
+	
+	if(periname == PERI_ADC || periname == PERI_SPDIF ||periname == PERI_AUD || periname == PERI_DAI)
+	{
+		if(periname == PERI_DAI)
+		{
+			clkmode = 0;	// DCO Mode
+			clkdiv = (freq *32768);
+			uPll = lclksource;
+			clkdiv = clkdiv/uPll;
+			clkdiv <<= 1;			
+			clkdiv = clkdiv + 1;
+		}
+		
+		*pPERI = tca_ckc_gpckyyy(isenable,clkmode,sor,clkdiv);
+	}
+	else
+	{
+		*pPERI = tca_ckc_gpckxxx(isenable,sor,clkdiv);
+
+	}
+}
+
+/****************************************************************************************
+* FUNCTION : static int tca_ckc_gperi(unsigned int lclksrc, unsigned int ldiv,unsigned int lmd)
+* DESCRIPTION :
+* ***************************************************************************************/
+VOLATILE static int tca_ckc_gperi(unsigned int lclksrc, unsigned int ldiv,unsigned int lmd)
+{
+	if(lmd == 1)
+	{
+		if(lclksrc == PCDIRECTXIN)
+			return 120000/(ldiv+1);
+		else if(lclksrc == PCDIRECTPLL0){
+			return (tca_ckc_getpll(0)/(ldiv+1));
+		}
+		else if(lclksrc == PCDIRECTPLL1){
+			return (tca_ckc_getpll(1)/(ldiv+1));
+		}
+		else if(lclksrc == PCDIRECTPLL2){
+			return (tca_ckc_getpll(2)/(ldiv+1));
+		}
+		else if(lclksrc == PCDIRECTPLL3){
+			return (tca_ckc_getpll(3)/(ldiv+1));
+		}
+		else if(lclksrc == PCHDMI){
+			return (270000/(ldiv+1));
+		}
+		else if(lclksrc == PCSATA){
+			return (250000/(ldiv+1));
+		}
+		else if(lclksrc == PCUSBPHY){
+			return (480000/(ldiv+1));
+		}
+		else
+			return -1; // Not Support Others
+
+	}
+	else
+		return -1; // TO DO
+}
+
+/****************************************************************************************
+* FUNCTION : int tca_ckc_getperi(unsigned int periname)
+* DESCRIPTION :
+* ***************************************************************************************/
+VOLATILE int tca_ckc_getperi(unsigned int periname)
+{
+	unsigned int lreg = 0;
+	unsigned int lmd = 1; // DIVIDER mode
+	unsigned int lclksrc = 0;
+	unsigned int ldiv = 0;
+	
+	lreg =*(volatile unsigned	*)((&pCKC->PCLK_TCX)+periname); 
+	lclksrc = (lreg&0xF000000)>>24;
+	
+	if(periname == PERI_ADC || periname == PERI_SPDIF ||periname == PERI_AUD || periname == PERI_DAI)
+	{
+		lmd = (lreg&0x80000000);
+		ldiv = (lreg & 0xFFFF);
+		return tca_ckc_gperi(lclksrc, ldiv,lmd);
+	}
+	else
+	{
+		ldiv = (lreg & 0xFFF);
+		return tca_ckc_gperi(lclksrc, ldiv,1);
+	}
+}
+
+/****************************************************************************************
+* FUNCTION :void tca_ckc_setswresetprd(unsigned int prd)
+* DESCRIPTION : 
+* ***************************************************************************************/
+VOLATILE void tca_ckc_setswresetprd(unsigned int prd)
+{
+	pCKC->SWRESETPRD = prd<<0;
+}
+
+/****************************************************************************************
+* FUNCTION :void tca_ckc_set_iobus_swreset(unsigned int sel, unsigned int mode)
+* DESCRIPTION : 
+* ***************************************************************************************/
+VOLATILE unsigned int tca_ckc_set_iobus_swreset(unsigned int sel, unsigned int mode)
+{
+	unsigned int lindex[] = {Hw0,Hw1,Hw2,Hw3,Hw4,Hw5,Hw6,Hw7,Hw8,Hw9,Hw10,Hw11,Hw12,Hw13,Hw14,Hw15
+							,Hw16,Hw17,Hw18,Hw19,Hw20,Hw21,Hw22,Hw23,Hw24,Hw25,Hw26,Hw27,Hw28,Hw29,Hw30,Hw31};
+
+	unsigned int lrb_min;
+	unsigned int lrb_max;
+	unsigned int lrb_seperate;
+
+	lrb_min = RB_USB11H;
+	lrb_max = RB_ALLPERIPERALS;
+	lrb_seperate = RB_ADMACONTROLLER;
+
+	if(sel <  lrb_min || sel >= lrb_max)
+	{
+		return 0;
+	}
+
+	if(sel >  lrb_seperate)
+	{
+		sel -=	(lrb_seperate+1);
+		
+		if(mode)
+			pIOBUSCFG->HRSTEN1 |= lindex[sel];
+		else
+			pIOBUSCFG->HRSTEN1 &= ~lindex[sel];
+	}
+	else
+	{
+		if(mode)
+			pIOBUSCFG->HRSTEN0 |= lindex[sel];
+		else
+			pIOBUSCFG->HRSTEN0 &= ~lindex[sel];
+	}
+
+	return 1;
+}
+
+/****************************************************************************************
+* FUNCTION :void tca_ckc_setswreset(unsigned int lfbusname, unsigned int mode)
+* DESCRIPTION : 
+* ***************************************************************************************/
+
+VOLATILE void  tca_ckc_setswreset(unsigned int lfbusname, unsigned int mode)
+{
+	unsigned int hIndex[] = {Hw0,Hw1,Hw2,Hw3,Hw4,Hw5,Hw6,Hw7};
+
+	if(mode)
+		pCKC->SWRESET |= hIndex[lfbusname];
+	else
+		pCKC->SWRESET &= ~(hIndex[lfbusname]);
+}
+/****************************************************************************************
+* FUNCTION :  int tca_ckc_setiobus(unsigned int sel, unsigned int mode)
+* DESCRIPTION : 
+* ***************************************************************************************/
+VOLATILE int tca_ckc_setiobus(unsigned int sel, unsigned int mode)
+{
+	unsigned int lindex[] = {Hw0,Hw1,Hw2,Hw3,Hw4,Hw5,Hw6,Hw7,Hw8,Hw9,Hw10,Hw11,Hw12,Hw13,Hw14,Hw15
+							,Hw16,Hw17,Hw18,Hw19,Hw20,Hw21,Hw22,Hw23,Hw24,Hw25,Hw26,Hw27,Hw28,Hw29,Hw30,Hw31};
+
+	unsigned int lrb_min;
+	unsigned int lrb_max;
+	unsigned int lrb_seperate;
+
+	lrb_min = RB_USB11H;
+	lrb_max = RB_ALLPERIPERALS;
+	lrb_seperate = RB_ADMACONTROLLER;
+
+	if(sel <  lrb_min || sel >=  lrb_max)
+	{
+		return -1;
+	}
+
+	if(sel >  lrb_seperate)
+	{
+		sel -=	(lrb_seperate+1);
+		
+		if(mode)
+			pIOBUSCFG->HCLKEN1 |= lindex[sel];
+		else
+			pIOBUSCFG->HCLKEN1 &= ~lindex[sel];
+	}
+	else
+	{
+		if(mode)
+			pIOBUSCFG->HCLKEN0 |= lindex[sel];
+		else
+			pIOBUSCFG->HCLKEN0 &= ~lindex[sel];
+	}
+
+	return 1;
+}
+
+/****************************************************************************************
+* FUNCTION :  int tca_ckc_getiobus(unsigned int sel)
+* DESCRIPTION : 
+* ***************************************************************************************/
+VOLATILE int tca_ckc_getiobus(unsigned int sel)
+{
+	unsigned int lindex[] = {Hw0,Hw1,Hw2,Hw3,Hw4,Hw5,Hw6,Hw7,Hw8,Hw9,Hw10,Hw11,Hw12,Hw13,Hw14,Hw15
+							,Hw16,Hw17,Hw18,Hw19,Hw20,Hw21,Hw22,Hw23,Hw24,Hw25,Hw26,Hw27,Hw28,Hw29,Hw30,Hw31};
+	unsigned int lrb_min;
+	unsigned int lrb_max;
+	unsigned int lrb_seperate;
+	int lretVal = 0;
+	
+	lrb_min = RB_USB11H;
+	lrb_max = RB_ALLPERIPERALS;
+	lrb_seperate = RB_ADMACONTROLLER;
+
+	
+	if(sel <  lrb_min || sel >=  lrb_max)
+	{
+		return -1;
+	}
+		
+	if(sel >  lrb_seperate)
+	{
+		sel -=	(lrb_seperate+1);
+
+		lretVal = (pIOBUSCFG->HCLKEN1  & lindex[sel]) ;
+
+	}
+	else
+	{
+		lretVal = (pIOBUSCFG->HCLKEN0  & lindex[sel]) ;
+	}
+
+	if(lretVal != 0)
+		lretVal = 1; // Enable
+		
+	return lretVal;
+}
+
+/****************************************************************************************
+* FUNCTION :  int tca_ckc_setsmui2c(unsigned int freq)
+* DESCRIPTION : unit : 100Hz
+* ***************************************************************************************/
+VOLATILE void tca_ckc_setsmui2c(unsigned int freq)
+{
+	PSMUI2CICLK lSMUICLK;
+	unsigned int lclkctrl7=0;
+	unsigned int lsel=0;
+	unsigned int lclksource=0;
+	unsigned int lclkdiv=0;
+	
+	lSMUICLK = (PSMUI2CICLK)(iomap_p2v((unsigned int)&HwSMU_I2CICLK_BASE)); //0xF0400000
+	lclkctrl7 = (unsigned int)pCKC->CLK7CTRL;
+
+	lsel = (lclkctrl7 & 7);
+	
+	if(((lclkctrl7 >>20) & Hw0) == 0 ) // Normal Mode
+	{
+		switch(lsel)
+		{
+			case DIRECTPLL0:
+				lclksource = tca_ckc_getpll(0);
+				break;
+			case DIRECTPLL1:
+				lclksource = tca_ckc_getpll(1);
+				break;
+			case DIRECTPLL2:
+				lclksource = tca_ckc_getpll(2);
+				break;
+			case DIRECTPLL3:
+				lclksource = tca_ckc_getpll(3);
+				break;
+			default :
+				lclksource = tca_ckc_getpll(1);
+				break;
+
+		}
+	}
+	
+	if (freq != 0)
+	{
+		lclkdiv	= (lclksource + (freq>>1)) / freq ; // should be even number of division factor
+		lSMUICLK->ICLK = (Hw31|lclkdiv);
+	}
+	else
+	{
+		lclkdiv	= 0;
+		lSMUICLK->ICLK = 0;
+	}
+
+
+}
+/****************************************************************************************
+* FUNCTION :  int tca_ckc_getsmui2c(void)
+* DESCRIPTION : unit : 100Hz
+* ***************************************************************************************/
+VOLATILE int tca_ckc_getsmui2c(void)
+{
+	PSMUI2CICLK lSMUICLK;
+	unsigned int lclkctrl7;
+	unsigned int lsel;
+	unsigned int lclksource;
+	unsigned int lclkdiv;
+
+	lSMUICLK = (PSMUI2CICLK)(iomap_p2v((unsigned int)&HwSMU_I2CICLK_BASE)); //0xF0400000
+	lclkctrl7 = (unsigned int)pCKC->CLK7CTRL;
+
+	lsel = (lclkctrl7 & 7);
+
+	if(((lclkctrl7 >>20) & Hw0) == 0 ) // Normal Mode
+	{
+		switch(lsel)
+		{
+			case DIRECTPLL0:
+				lclksource = tca_ckc_getpll(0);
+				break;
+			case DIRECTPLL1:
+				lclksource = tca_ckc_getpll(1);
+				break;
+			case DIRECTPLL2:
+				lclksource = tca_ckc_getpll(2);
+				break;
+			case DIRECTPLL3:
+				lclksource = tca_ckc_getpll(3);
+				break;
+			default :
+				lclksource = tca_ckc_getpll(1);
+				break;
+
+		}
+		lclkdiv = (lclkctrl7 & 0xFFFF);
+		
+		if (lclkdiv != 0)
+		{
+			return (lclksource / lclkdiv) ; 
+		}
+		else
+			return -1;
+	}
+	else
+		return -1;
+
+}
+
+/****************************************************************************************
+* FUNCTION : void tca_ckc_setddipwdn(unsigned int lpwdn , unsigned int lmode)
+* DESCRIPTION : Power Down Register of DDI_CONFIG 
+* ***************************************************************************************/
+void tca_ckc_setddipwdn(unsigned int lpwdn , unsigned int lmode)
+{
+	PDDICONFIG lDDIPWDN;
+	unsigned int lindex[] = {Hw0,Hw1,Hw2,Hw3,Hw4,Hw5,Hw6,Hw7,Hw8};
+
+	lDDIPWDN = (PDDICONFIG)(iomap_p2v((unsigned int)&HwDDI_CONFIG_BASE)); //0xF0400000
+
+	if(lmode)  // Normal
+		lDDIPWDN->PWDN &= ~lindex[lpwdn];
+	else // Power Down
+		lDDIPWDN->PWDN |= lindex[lpwdn];
+
+}
+/****************************************************************************************
+* FUNCTION : int tca_ckc_getddipwdn(unsigned int lpwdn)
+* DESCRIPTION : Power Down Register of DDI_CONFIG 
+* ***************************************************************************************/
+int tca_ckc_getddipwdn(unsigned int lpwdn)
+{
+	PDDICONFIG lDDIPWDN;
+	unsigned int lindex[] = {Hw0,Hw1,Hw2,Hw3,Hw4,Hw5,Hw6,Hw7,Hw8};
+
+	lDDIPWDN = (PDDICONFIG)(iomap_p2v((unsigned int)&HwDDI_CONFIG_BASE)); //0xF0400000
+
+	return (lDDIPWDN->PWDN &  lindex[lpwdn]);
+}
+
+
+/****************************************************************************************
+* EXPORT_SYMBOL clock functions for Linux
+* ***************************************************************************************/
+#if defined(_LINUX_)
+EXPORT_SYMBOL(tca_ckc_init);
+EXPORT_SYMBOL(tca_ckc_getpll);
+EXPORT_SYMBOL(tca_ckc_getcpu);
+EXPORT_SYMBOL(tca_ckc_getbus);
+//EXPORT_SYMBOL(tca_ckc_gclkctrlx);
+//EXPORT_SYMBOL(tca_ckc_gclkctrly);
+EXPORT_SYMBOL(tca_ckc_setfbusctrl);
+EXPORT_SYMBOL(tca_ckc_getfbusctrl);
+//EXPORT_SYMBOL(tca_ckc_gpllxcfg);
+//EXPORT_SYMBOL(tca_ckc_pll);
+EXPORT_SYMBOL(tca_ckc_validpll);
+EXPORT_SYMBOL(tca_ckc_setpll);
+EXPORT_SYMBOL(tca_ckc_setpmupwroff);
+EXPORT_SYMBOL(tca_ckc_getpmupwroff);
+//EXPORT_SYMBOL(tca_ckc_gpckxxx);
+//EXPORT_SYMBOL(tca_ckc_gpckyyy);
+EXPORT_SYMBOL(tca_ckc_setperi);
+//EXPORT_SYMBOL(tca_ckc_gperi);
+EXPORT_SYMBOL(tca_ckc_getperi);
+EXPORT_SYMBOL(tca_ckc_setswresetprd);
+EXPORT_SYMBOL(tca_ckc_set_iobus_swreset);
+EXPORT_SYMBOL(tca_ckc_setswreset);
+EXPORT_SYMBOL(tca_ckc_setiobus);
+EXPORT_SYMBOL(tca_ckc_getiobus);
+EXPORT_SYMBOL(tca_ckc_setsmui2c);
+EXPORT_SYMBOL(tca_ckc_getsmui2c);
+EXPORT_SYMBOL(tca_ckc_setddipwdn);
+EXPORT_SYMBOL(tca_ckc_getddipwdn);
+#endif
+
+/* end of file */
Index: linux-2.6.29/arch/arm/mach-tcc8900/tcc8900/arm_ioctlutil.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/tcc8900/arm_ioctlutil.S	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,23 @@
+/***************************************************************************************
+*	FileName    : arm_ioctlutil.s 
+****************************************************************************************
+*
+*	TCC Board Support Package
+*	Copyright (c) Telechips, Inc.
+*	ALL RIGHTS RESERVED
+*
+****************************************************************************************/
+    .global arm_changestack
+arm_changestack:
+	mov		r0, r13
+//	ldr		r13, =0xF0A03FA0  			//	0x10000000 ~ 0x10003FFF SRAM(16KB)    
+	ldr		r13, =0xEFF03FFC    //	0x10000000 ~ 0x10003FFF SRAM(16KB)    
+    mov		pc, lr    
+    
+    .global arm_restorestack
+arm_restorestack:
+    mov		r13, r0    
+    mov		pc, lr
+
+
+/************* end of file *************************************************************/
Index: linux-2.6.29/arch/arm/mach-tcc8900/tcc8900/tcc_ckcddr2_141to190.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/tcc8900/tcc_ckcddr2_141to190.c	2010-04-07 12:59:47.000000000 -0400
@@ -0,0 +1,2253 @@
+#include "tcc_ckcddr2_141to190.h"
+
+#if !defined(DRAM_MDDR)
+
+#define DRAM_ODTOFF
+
+void init_clockchange125Mhz(void)
+{
+	unsigned int lpll1	=500;
+	unsigned int lmem_source =1; // 0 : PLL0 , 1 : PLL1 
+	unsigned int lmem_div	=4; // Fmbus 130Mhz
+	
+	volatile unsigned int i = 0;	
+	unsigned int ldiv = 0;
+	unsigned int lcycle = 0;
+
+//Enter Mode		
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xF0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xF0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xF030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+		
+	*(volatile unsigned long *)0xF0400030 = 0x01010101;
+	*(volatile unsigned long *)0xF0400034 = 0x01010101;
+	
+	*(volatile unsigned long *)0xF0400008 = 0x00200014; 		// XI - memebus
+	
+	//PLL1
+	*(volatile unsigned long *)0xF0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xF0400024= 0x00007D03;		// pms - pllout_480M
+	*(volatile unsigned long *)0xF0400024= 0x80007D03;		//	pll pwr on
+
+	*(volatile unsigned long *)0xF0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+//Init DDR2 
+	*(volatile unsigned long *) 0xF0302004=0x00000003;			// PL341_PAUSE
+	*(volatile unsigned long *) 0xF0302004=0x00000004;			// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+// memory arb.
+	*(volatile unsigned long *)0xF030200C |= 0x00140000; 
+// memory arb. end
+	
+	*(volatile unsigned long *)0xF030200C = 0x00150012; 		// config0 cas 10bit, ras 13bit
+	*(volatile unsigned long *)0xF0302010 = 0x00000445; 	// refresh 
+	
+#if defined(DRAM_BANK3)
+			*(volatile unsigned long *) 0xF030204c=0x00000571; // config2 - SOC
+#else
+			*(volatile unsigned long *) 0xF030204c=0x00000541; // config2 - SOC
+#endif		
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302014 = 0x0000000C; 	// cas_latency - 5
+#else
+		*(volatile unsigned long *)0xF0302014 = 0x0000000A; 	// cas_latency - 5
+#endif		
+	
+			
+	*(volatile unsigned long *)0xF030201c = 0x00000003; 		// tMRD
+
+	// 1 Tick = 2.5ns
+	*(volatile unsigned long *)0xF0302020 = 0x0000000D; // tRAS - 45ns
+	*(volatile unsigned long *)0xF0302024 = 0x00000011; // tRC	- 60ns
+	*(volatile unsigned long *)0xF0302028 = 0x00000205; // tRCD - 15ns
+	*(volatile unsigned long *)0xF030202c = 0x00001B1E; // tRFC - 105ns
+	*(volatile unsigned long *)0xF0302030 = 0x00000205; // tRP	- 15ns
+	*(volatile unsigned long *)0xF0302034 = 0x00000005; // tRRD
+	*(volatile unsigned long *)0xF0302038 = 0x00000006; // tWR
+	*(volatile unsigned long *)0xF030203c = 0x00000003; // tWTR
+	*(volatile unsigned long *)0xF0302040 = 0x00000003; // tXP
+	*(volatile unsigned long *)0xF0302044 = 0x00000022; // tXSR
+	*(volatile unsigned long *)0xF0302048 = 0x000000FA; // tESR
+	*(volatile unsigned long *)0xF0302054 = 0x00001619; // tFAW
+	
+	*(volatile unsigned long *)0xF0302200 = 0x000040f0; 		//256MB  config_chip0
+ //	*(volatile unsigned long *)0xF0302200 = 0x000040f8; 		//128MB config_chip0  //soc1-3
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000001; 		// PL341_SLEEP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 3);	// Wait until SLEEP
+
+	*(volatile unsigned long *)0xF030302C |= 0x00004000; 		// SSTL SDRAM IO Control Register 
+	
+	*(volatile unsigned long *)0xF0303020 = 0x00010103; 		// emccfg_config0
+	*(volatile unsigned long *)0xF0303024 = 0x00000000; 		// SDRAM PHY Control Register 
+	*(volatile unsigned long *)0xF0304400 = 0x00000000; 		// DDR2PHY_PHYMODE
+	*(volatile unsigned long *)0xF0304404 = 0x00000001; 		// DLLCTRL
+	
+	*(volatile unsigned long *)0xF0304408 = 0x00003E3E; 	// DLLPDCFG
+		
+	*(volatile unsigned long *)0xF0304404 = 0x00000003; 		// DLLCTRL
+	while (((*(volatile unsigned long *)0xF0304404) & (0x00000018)) != (0x00000018)); // Wait DLL Lock
+
+	*(volatile unsigned long *)0xF0304424 = 0x00000035; 		// DLLFORCELOCK
+	*(volatile unsigned long *)0xF030440C = 0x00000006; 		// GATECTRL
+	#if defined(DRAM_CAS6)
+		*(volatile unsigned long *) 0xF0304430=0x00000006; // RDDELAY - SOC
+	#else
+		*(volatile unsigned long *) 0xF0304430=0x00000005; // RDDELAY - SOC
+	#endif
+
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+	
+	while (!((*(volatile unsigned long *)0xF030442c) & (1)));	// Wait until Calibration completion without error
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+	
+	//*(volatile unsigned long *) 0xF0304404 &= ~(0x00000003); // DLLCTRL - DLL OFF, Not Useing DLL 
+	
+	*(volatile unsigned long *)0xF0302004 = 0x00000002; 		// PL34X_WAKEUP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 0);	// Wait until CONFIGURE
+
+	*(volatile unsigned long *)0xF0302008 = 0x000c0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000a0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000b0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090000; 		// Direct COmmnad Register	  
+	
+#if defined(DRAM_CAS6)
+	//	*(volatile unsigned long *)0xF0302008 = 0x00080962; 	// Direct COmmnad Register 
+		*(volatile unsigned long *)0xF0302008 = 0x00080362; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080952; 	// Direct COmmnad Register 
+#endif
+		
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+
+	i = 100;
+	while(i)
+	{
+		*(volatile unsigned long *) 0xF0302008=0x00040000; // dir_cmd
+		i--;
+	}
+
+#if defined(DRAM_CAS6)
+	//	*(volatile unsigned long *)0xF0302008 = 0x00080862; 	// Direct COmmnad Register 
+		*(volatile unsigned long *)0xF0302008 = 0x00080262; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080852; 	// Direct COmmnad Register 
+#endif
+
+	#if defined(DRAM_ODTOFF)
+
+#else
+	*(volatile unsigned long *)0xF0302008 = 0x00090380; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090004; 		// Direct COmmnad Register //soc1-3
+#endif
+
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000000; 		// PL341_GO
+
+}
+
+void init_clockchange130Mhz(void)
+{
+	unsigned int lpll1	=260;
+	unsigned int lmem_source =1; // 0 : PLL0 , 1 : PLL1 
+	unsigned int lmem_div	=2; // Fmbus 130Mhz
+	
+	volatile unsigned int i = 0;	
+	unsigned int ldiv = 0;
+	unsigned int lcycle = 0;
+
+//Enter Mode		
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xF0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xF0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xF030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+		
+	*(volatile unsigned long *)0xF0400030 = 0x01010101;
+	*(volatile unsigned long *)0xF0400034 = 0x01010101;
+	
+	*(volatile unsigned long *)0xF0400008 = 0x00200014; 		// XI - memebus
+	
+	//PLL1
+	*(volatile unsigned long *)0xF0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xF0400024= 0x01008203;		// pms - pllout_276M
+	*(volatile unsigned long *)0xF0400024= 0x81008203;		//	pll pwr on
+
+	*(volatile unsigned long *)0xF0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+//Init DDR2 
+	*(volatile unsigned long *) 0xF0302004=0x00000003;			// PL341_PAUSE
+	*(volatile unsigned long *) 0xF0302004=0x00000004;			// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+// memory arb.
+	*(volatile unsigned long *)0xF030200C |= 0x00140000; 
+// memory arb. end
+	
+	*(volatile unsigned long *)0xF030200C = 0x00150012; 		// config0 cas 10bit, ras 13bit
+	*(volatile unsigned long *)0xF0302010 = 0x00000445; 	// refresh 
+	
+#if defined(DRAM_BANK3)
+			*(volatile unsigned long *) 0xF030204c=0x00000571; // config2 - SOC
+#else
+			*(volatile unsigned long *) 0xF030204c=0x00000541; // config2 - SOC
+#endif		
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302014 = 0x0000000C; 	// cas_latency - 5
+#else
+		*(volatile unsigned long *)0xF0302014 = 0x0000000A; 	// cas_latency - 5
+#endif		
+	
+			
+	*(volatile unsigned long *)0xF030201c = 0x00000003; 		// tMRD
+
+	// 1 Tick = 2.5ns
+	*(volatile unsigned long *)0xF0302020 = 0x0000000D; // tRAS - 45ns
+	*(volatile unsigned long *)0xF0302024 = 0x00000011; // tRC	- 60ns
+	*(volatile unsigned long *)0xF0302028 = 0x00000205; // tRCD - 15ns
+	*(volatile unsigned long *)0xF030202c = 0x00001B1E; // tRFC - 105ns
+	*(volatile unsigned long *)0xF0302030 = 0x00000205; // tRP	- 15ns
+	*(volatile unsigned long *)0xF0302034 = 0x00000005; // tRRD
+	*(volatile unsigned long *)0xF0302038 = 0x00000006; // tWR
+	*(volatile unsigned long *)0xF030203c = 0x00000003; // tWTR
+	*(volatile unsigned long *)0xF0302040 = 0x00000003; // tXP
+	*(volatile unsigned long *)0xF0302044 = 0x00000022; // tXSR
+	*(volatile unsigned long *)0xF0302048 = 0x000000FA; // tESR
+	*(volatile unsigned long *)0xF0302054 = 0x00001619; // tFAW
+	
+	*(volatile unsigned long *)0xF0302200 = 0x000040f0; 		//256MB  config_chip0
+ //	*(volatile unsigned long *)0xF0302200 = 0x000040f8; 		//128MB config_chip0  //soc1-3
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000001; 		// PL341_SLEEP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 3);	// Wait until SLEEP
+
+	*(volatile unsigned long *)0xF030302C |= 0x00004000; 		// SSTL SDRAM IO Control Register 
+	
+	*(volatile unsigned long *)0xF0303020 = 0x00010103; 		// emccfg_config0
+	*(volatile unsigned long *)0xF0303024 = 0x00000000; 		// SDRAM PHY Control Register 
+	*(volatile unsigned long *)0xF0304400 = 0x00000000; 		// DDR2PHY_PHYMODE
+	*(volatile unsigned long *)0xF0304404 = 0x00000001; 		// DLLCTRL
+	
+	*(volatile unsigned long *)0xF0304408 = 0x00003E3E; 	// DLLPDCFG
+		
+	*(volatile unsigned long *)0xF0304404 = 0x00000003; 		// DLLCTRL
+	while (((*(volatile unsigned long *)0xF0304404) & (0x00000018)) != (0x00000018)); // Wait DLL Lock
+
+	*(volatile unsigned long *)0xF0304424 = 0x00000035; 		// DLLFORCELOCK
+	*(volatile unsigned long *)0xF030440C = 0x00000006; 		// GATECTRL
+	#if defined(DRAM_CAS6)
+		*(volatile unsigned long *) 0xF0304430=0x00000006; // RDDELAY - SOC
+	#else
+		*(volatile unsigned long *) 0xF0304430=0x00000005; // RDDELAY - SOC
+	#endif
+
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+	
+	while (!((*(volatile unsigned long *)0xF030442c) & (1)));	// Wait until Calibration completion without error
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+	
+	//*(volatile unsigned long *) 0xF0304404 &= ~(0x00000003); // DLLCTRL - DLL OFF, Not Useing DLL 
+	*(volatile unsigned long *)0xF0302004 = 0x00000002; 		// PL34X_WAKEUP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 0);	// Wait until CONFIGURE
+
+	*(volatile unsigned long *)0xF0302008 = 0x000c0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000a0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000b0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090000; 		// Direct COmmnad Register	  
+	
+#if defined(DRAM_CAS6)
+	//	*(volatile unsigned long *)0xF0302008 = 0x00080962; 	// Direct COmmnad Register 
+		*(volatile unsigned long *)0xF0302008 = 0x00080362; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080952; 	// Direct COmmnad Register 
+#endif
+		
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+
+	i = 100;
+	while(i)
+	{
+		*(volatile unsigned long *) 0xF0302008=0x00040000; // dir_cmd
+		i--;
+	}
+
+#if defined(DRAM_CAS6)
+	//	*(volatile unsigned long *)0xF0302008 = 0x00080862; 	// Direct COmmnad Register 
+		*(volatile unsigned long *)0xF0302008 = 0x00080262; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080852; 	// Direct COmmnad Register 
+#endif
+
+#if defined(DRAM_ODTOFF)
+
+#else
+	*(volatile unsigned long *)0xF0302008 = 0x00090380; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090004; 		// Direct COmmnad Register //soc1-3
+#endif
+
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000000; 		// PL341_GO
+}
+
+void init_clockchange135Mhz(void)
+{
+	unsigned int lpll1	=540;
+	unsigned int lmem_source =1; // 0 : PLL0 , 1 : PLL1 
+	unsigned int lmem_div	=4; // Fmbus 130Mhz
+	
+	volatile unsigned int i = 0;	
+	unsigned int ldiv = 0;
+	unsigned int lcycle = 0;
+
+//Enter Mode		
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xF0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xF0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xF030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+		
+	*(volatile unsigned long *)0xF0400030 = 0x01010101;
+	*(volatile unsigned long *)0xF0400034 = 0x01010101;
+	
+	*(volatile unsigned long *)0xF0400008 = 0x00200014; 		// XI - memebus
+	
+	//PLL1
+	*(volatile unsigned long *)0xF0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xF0400024= 0x00002D01;		// pms - pllout_540M
+	*(volatile unsigned long *)0xF0400024= 0x80002D01;		//	pll pwr on
+
+	*(volatile unsigned long *)0xF0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+//Init DDR2 
+	*(volatile unsigned long *) 0xF0302004=0x00000003;			// PL341_PAUSE
+	*(volatile unsigned long *) 0xF0302004=0x00000004;			// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+// memory arb.
+	*(volatile unsigned long *)0xF030200C |= 0x00140000; 
+// memory arb. end
+	
+	*(volatile unsigned long *)0xF030200C = 0x00150012; 		// config0 cas 10bit, ras 13bit
+	*(volatile unsigned long *)0xF0302010 = 0x00000445; 	// refresh 
+	
+#if defined(DRAM_BANK3)
+			*(volatile unsigned long *) 0xF030204c=0x00000571; // config2 - SOC
+#else
+			*(volatile unsigned long *) 0xF030204c=0x00000541; // config2 - SOC
+#endif		
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302014 = 0x0000000C; 	// cas_latency - 5
+#else
+		*(volatile unsigned long *)0xF0302014 = 0x0000000A; 	// cas_latency - 5
+#endif		
+	
+			
+	*(volatile unsigned long *)0xF030201c = 0x00000003; 		// tMRD
+
+	*(volatile unsigned long *)0xF0302020 = 0x0000000D; // tRAS - 45ns
+	*(volatile unsigned long *)0xF0302024 = 0x00000011; // tRC	- 60ns
+	*(volatile unsigned long *)0xF0302028 = 0x00000205; // tRCD - 15ns
+	*(volatile unsigned long *)0xF030202c = 0x00001B1E; // tRFC - 105ns
+	*(volatile unsigned long *)0xF0302030 = 0x00000205; // tRP	- 15ns
+	*(volatile unsigned long *)0xF0302034 = 0x00000005; // tRRD
+	*(volatile unsigned long *)0xF0302038 = 0x00000006; // tWR
+	*(volatile unsigned long *)0xF030203c = 0x00000003; // tWTR
+	*(volatile unsigned long *)0xF0302040 = 0x00000003; // tXP
+	*(volatile unsigned long *)0xF0302044 = 0x00000022; // tXSR
+	*(volatile unsigned long *)0xF0302048 = 0x000000FA; // tESR
+	*(volatile unsigned long *)0xF0302054 = 0x00001619; // tFAW
+
+	*(volatile unsigned long *)0xF0302200 = 0x000040f0; 		//256MB  config_chip0
+ //	*(volatile unsigned long *)0xF0302200 = 0x000040f8; 		//128MB config_chip0  //soc1-3
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000001; 		// PL341_SLEEP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 3);	// Wait until SLEEP
+
+	*(volatile unsigned long *)0xF030302C |= 0x00004000; 		// SSTL SDRAM IO Control Register 
+	
+	*(volatile unsigned long *)0xF0303020 = 0x00010103; 		// emccfg_config0
+	*(volatile unsigned long *)0xF0303024 = 0x00000000; 		// SDRAM PHY Control Register 
+	*(volatile unsigned long *)0xF0304400 = 0x00000000; 		// DDR2PHY_PHYMODE
+	*(volatile unsigned long *)0xF0304404 = 0x00000001; 		// DLLCTRL
+	
+	*(volatile unsigned long *)0xF0304408 = 0x00003E3E; 	// DLLPDCFG
+		
+	*(volatile unsigned long *)0xF0304404 = 0x00000003; 		// DLLCTRL
+	while (((*(volatile unsigned long *)0xF0304404) & (0x00000018)) != (0x00000018)); // Wait DLL Lock
+
+	*(volatile unsigned long *)0xF0304424 = 0x00000035; 		// DLLFORCELOCK
+	*(volatile unsigned long *)0xF030440C = 0x00000006; 		// GATECTRL
+	#if defined(DRAM_CAS6)
+		*(volatile unsigned long *) 0xF0304430=0x00000006; // RDDELAY - SOC
+	#else
+		*(volatile unsigned long *) 0xF0304430=0x00000005; // RDDELAY - SOC
+	#endif
+
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+	
+	while (!((*(volatile unsigned long *)0xF030442c) & (1)));	// Wait until Calibration completion without error
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+	
+	//*(volatile unsigned long *) 0xF0304404 &= ~(0x00000003); // DLLCTRL - DLL OFF, Not Useing DLL 
+	
+	*(volatile unsigned long *)0xF0302004 = 0x00000002; 		// PL34X_WAKEUP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 0);	// Wait until CONFIGURE
+
+	*(volatile unsigned long *)0xF0302008 = 0x000c0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000a0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000b0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090000; 		// Direct COmmnad Register	  
+	
+#if defined(DRAM_CAS6)
+	//	*(volatile unsigned long *)0xF0302008 = 0x00080962; 	// Direct COmmnad Register 
+		*(volatile unsigned long *)0xF0302008 = 0x00080362; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080952; 	// Direct COmmnad Register 
+#endif
+		
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+
+	i = 100;
+	while(i)
+	{
+		*(volatile unsigned long *) 0xF0302008=0x00040000; // dir_cmd
+		i--;
+	}
+
+#if defined(DRAM_CAS6)
+	//	*(volatile unsigned long *)0xF0302008 = 0x00080862; 	// Direct COmmnad Register 
+		*(volatile unsigned long *)0xF0302008 = 0x00080262; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080852; 	// Direct COmmnad Register 
+#endif
+
+	#if defined(DRAM_ODTOFF)
+
+#else
+	*(volatile unsigned long *)0xF0302008 = 0x00090380; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090004; 		// Direct COmmnad Register //soc1-3
+#endif
+
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000000; 		// PL341_GO
+}
+
+void init_clockchange141Mhz(void)
+{
+	unsigned int lpll1	=282;
+	unsigned int lmem_source =1; // 0 : PLL0 , 1 : PLL1 
+	unsigned int lmem_div	=2; // Fmbus 130Mhz
+	
+	volatile unsigned int i = 0;	
+	unsigned int ldiv = 0;
+	unsigned int lcycle = 0;
+
+//Enter Mode		
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xF0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xF0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xF030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+		
+	*(volatile unsigned long *)0xF0400030 = 0x01010101;
+	*(volatile unsigned long *)0xF0400034 = 0x01010101;
+	
+	*(volatile unsigned long *)0xF0400008 = 0x00200014; 		// XI - memebus
+	
+	//PLL1
+	*(volatile unsigned long *)0xF0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xF0400024= 0x01002F01;		// pms - pllout_276M
+	*(volatile unsigned long *)0xF0400024= 0x81002F01;		//	pll pwr on
+	*(volatile unsigned long *)0xF0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+//Init DDR2 
+	*(volatile unsigned long *) 0xF0302004=0x00000003;			// PL341_PAUSE
+	*(volatile unsigned long *) 0xF0302004=0x00000004;			// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+// memory arb.
+	*(volatile unsigned long *)0xF030200C |= 0x00140000; 
+// memory arb. end
+	
+	*(volatile unsigned long *)0xF030200C = 0x00150012; 		// config0 cas 10bit, ras 13bit
+	*(volatile unsigned long *)0xF0302010 = 0x00000445; 	// refresh 
+	
+#if defined(DRAM_BANK3)
+			*(volatile unsigned long *) 0xF030204c=0x00000571; // config2 - SOC
+#else
+			*(volatile unsigned long *) 0xF030204c=0x00000541; // config2 - SOC
+#endif		
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302014 = 0x0000000C; 	// cas_latency - 5
+#else
+		*(volatile unsigned long *)0xF0302014 = 0x0000000A; 	// cas_latency - 5
+#endif		
+	
+			
+	*(volatile unsigned long *)0xF030201c = 0x00000003; 		// tMRD
+
+	ldiv = 10000/(lpll1/lmem_div);
+
+	lcycle = 450/ldiv;
+	*(volatile unsigned long *)0xF0302020 = lcycle+1; 			// tRAS - 45ns
+	lcycle = 600/ldiv;
+	*(volatile unsigned long *)0xF0302024 = lcycle+1; 			// tRC	- 60ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302028 = (((lcycle+1-3)<<8) | (lcycle+1)); // tRCD - 15ns
+	lcycle = 1050/ldiv;
+	*(volatile unsigned long *)0xF030202c = (((lcycle+1-3)<<8) | (lcycle+1)); // tRFC - 105ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302030 = (((lcycle+1-3)<<8) | (lcycle+1)); // tRP	- 15ns
+	lcycle = 100/ldiv;
+	*(volatile unsigned long *)0xF0302034 = lcycle+1; 			// tRRD - 10ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302038 = lcycle+1; 			// tWR - 15ns
+	lcycle = 75/ldiv;
+	*(volatile unsigned long *)0xF030203c = lcycle+1; 			// tWTR - 7.5ns
+	*(volatile unsigned long *)0xF0302040 = 0x00000003; 		// tXP - min 2tCK
+
+	*(volatile unsigned long *)0xF0302044 = 0x00000022; 	// tXSR
+	*(volatile unsigned long *)0xF0302048 = 0x000000FA; 	// tESR
+	*(volatile unsigned long *)0xF0302054 = 0x00001619; 	// tFAW
+
+	*(volatile unsigned long *)0xF0302200 = 0x000040f0; 		//256MB  config_chip0
+ //	*(volatile unsigned long *)0xF0302200 = 0x000040f8; 		//128MB config_chip0  //soc1-3
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000001; 		// PL341_SLEEP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 3);	// Wait until SLEEP
+
+	*(volatile unsigned long *)0xF030302C |= 0x00004000; 		// SSTL SDRAM IO Control Register 
+	
+	*(volatile unsigned long *)0xF0303020 = 0x00010103; 		// emccfg_config0
+	*(volatile unsigned long *)0xF0303024 = 0x00000000; 		// SDRAM PHY Control Register 
+	*(volatile unsigned long *)0xF0304400 = 0x00000000; 		// DDR2PHY_PHYMODE
+	*(volatile unsigned long *)0xF0304404 = 0x00000001; 		// DLLCTRL
+	
+	*(volatile unsigned long *)0xF0304408 = 0x00001717; 	// DLLPDCFG
+		
+	*(volatile unsigned long *)0xF0304404 = 0x00000003; 		// DLLCTRL
+	while (((*(volatile unsigned long *)0xF0304404) & (0x00000018)) != (0x00000018)); // Wait DLL Lock
+
+	*(volatile unsigned long *)0xF0304424 = 0x00000035; 		// DLLFORCELOCK
+	*(volatile unsigned long *)0xF030440C = 0x00000006; 		// GATECTRL
+	#if defined(DRAM_CAS6)
+		*(volatile unsigned long *) 0xF0304430=0x00000006; // RDDELAY - SOC
+	#else
+		*(volatile unsigned long *) 0xF0304430=0x00000005; // RDDELAY - SOC
+	#endif
+
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+	
+	while (!((*(volatile unsigned long *)0xF030442c) & (1)));	// Wait until Calibration completion without error
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+	
+	*(volatile unsigned long *)0xF0302004 = 0x00000002; 		// PL34X_WAKEUP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 0);	// Wait until CONFIGURE
+
+	*(volatile unsigned long *)0xF0302008 = 0x000c0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000a0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000b0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090000; 		// Direct COmmnad Register	  
+	
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080962; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080952; 	// Direct COmmnad Register 
+#endif
+		
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+
+	i = 100;
+	while(i)
+	{
+		*(volatile unsigned long *) 0xF0302008=0x00040000; // dir_cmd
+		i--;
+	}
+
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080862; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080852; 	// Direct COmmnad Register 
+#endif
+
+#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0302008 = 0x00090002; 		// Direct COmmnad Register 
+#else
+	*(volatile unsigned long *)0xF0302008 = 0x00090380; 		// Direct COmmnad Register 
+	//*(volatile unsigned long *)0xF0302008 = 0x00090000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090004; 		// Direct COmmnad Register //soc1-3
+#endif
+
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000000; 		// PL341_GO
+}
+
+//145Mhz
+void init_clockchange145Mhz(void)
+{
+	unsigned int lpll1	=580;
+	unsigned int lmem_source =1; // 0 : PLL0 , 1 : PLL1 
+	unsigned int lmem_div	=4; // Fmbus 130Mhz
+	
+	volatile unsigned int i = 0;	
+	unsigned int ldiv = 0;
+	unsigned int lcycle = 0;
+
+//Enter Mode		
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xF0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xF0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xF030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+		
+	*(volatile unsigned long *)0xF0400030 = 0x01010101;
+	*(volatile unsigned long *)0xF0400034 = 0x01010101;
+	
+	*(volatile unsigned long *)0xF0400008 = 0x00200014; 		// XI - memebus
+	
+	//PLL1
+	*(volatile unsigned long *)0xF0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xF0400024= 0x00009103;		// pms - pllout_580M
+	*(volatile unsigned long *)0xF0400024= 0x80009103;		//	pll pwr on
+
+	*(volatile unsigned long *)0xF0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+//Init DDR2 
+	*(volatile unsigned long *) 0xF0302004=0x00000003;			// PL341_PAUSE
+	*(volatile unsigned long *) 0xF0302004=0x00000004;			// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+// memory arb.
+	*(volatile unsigned long *)0xF030200C |= 0x00140000; 
+// memory arb. end
+	
+	*(volatile unsigned long *)0xF030200C = 0x00150012; 		// config0 cas 10bit, ras 13bit
+	*(volatile unsigned long *)0xF0302010 = 0x00000445; 	// refresh 
+	
+#if defined(DRAM_BANK3)
+	*(volatile unsigned long *) 0xF030204c=0x00000571; // config2 - SOC
+#else
+	*(volatile unsigned long *) 0xF030204c=0x00000541; // config2 - SOC
+#endif		
+	
+#if defined(DRAM_CAS6)
+	*(volatile unsigned long *)0xF0302014 = 0x0000000C; 	// cas_latency - 5
+#else
+	*(volatile unsigned long *)0xF0302014 = 0x0000000A; 	// cas_latency - 5
+#endif		
+			
+	*(volatile unsigned long *)0xF030201c = 0x00000003; 		// tMRD
+
+	ldiv = 10000/(lpll1/lmem_div);
+
+	lcycle = 450/ldiv;
+	*(volatile unsigned long *)0xF0302020 = lcycle+1; 			// tRAS - 45ns
+	lcycle = 600/ldiv;
+	*(volatile unsigned long *)0xF0302024 = lcycle+1; 			// tRC	- 60ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302028 = (((lcycle+1-3)<<8) | (lcycle+1)); // tRCD - 15ns
+	lcycle = 1050/ldiv;
+	*(volatile unsigned long *)0xF030202c = (((lcycle+1-3)<<8) | (lcycle+1)); // tRFC - 105ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302030 = (((lcycle+1-3)<<8) | (lcycle+1)); // tRP	- 15ns
+	lcycle = 100/ldiv;
+	*(volatile unsigned long *)0xF0302034 = lcycle+1; 			// tRRD - 10ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302038 = lcycle+1; 			// tWR - 15ns
+	lcycle = 75/ldiv;
+	*(volatile unsigned long *)0xF030203c = lcycle+1; 			// tWTR - 7.5ns
+	*(volatile unsigned long *)0xF0302040 = 0x00000003; 		// tXP - min 2tCK
+
+	*(volatile unsigned long *)0xF0302044 = 0x00000022; 	// tXSR
+	*(volatile unsigned long *)0xF0302048 = 0x000000FA; 	// tESR
+	*(volatile unsigned long *)0xF0302054 = 0x00001619; 	// tFAW
+
+	*(volatile unsigned long *)0xF0302200 = 0x000040f0; 		//256MB  config_chip0
+ //	*(volatile unsigned long *)0xF0302200 = 0x000040f8; 		//128MB config_chip0  //soc1-3
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000001; 		// PL341_SLEEP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 3);	// Wait until SLEEP
+
+	*(volatile unsigned long *)0xF030302C |= 0x00004000; 		// SSTL SDRAM IO Control Register 
+	
+	*(volatile unsigned long *)0xF0303020 = 0x00010103; 		// emccfg_config0
+	*(volatile unsigned long *)0xF0303024 = 0x00000000; 		// SDRAM PHY Control Register 
+	*(volatile unsigned long *)0xF0304400 = 0x00000000; 		// DDR2PHY_PHYMODE
+	*(volatile unsigned long *)0xF0304404 = 0x00000001; 		// DLLCTRL
+	
+	*(volatile unsigned long *)0xF0304408 = 0x00001717; 	// DLLPDCFG
+		
+	*(volatile unsigned long *)0xF0304404 = 0x00000003; 		// DLLCTRL
+	while (((*(volatile unsigned long *)0xF0304404) & (0x00000018)) != (0x00000018)); // Wait DLL Lock
+
+	*(volatile unsigned long *)0xF0304424 = 0x00000035; 		// DLLFORCELOCK
+	*(volatile unsigned long *)0xF030440C = 0x00000006; 		// GATECTRL
+	#if defined(DRAM_CAS6)
+		*(volatile unsigned long *) 0xF0304430=0x00000006; // RDDELAY - SOC
+	#else
+		*(volatile unsigned long *) 0xF0304430=0x00000005; // RDDELAY - SOC
+	#endif
+	
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+	
+	while (!((*(volatile unsigned long *)0xF030442c) & (1)));	// Wait until Calibration completion without error
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+	
+	*(volatile unsigned long *)0xF0302004 = 0x00000002; 		// PL34X_WAKEUP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 0);	// Wait until CONFIGURE
+
+	*(volatile unsigned long *)0xF0302008 = 0x000c0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000a0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000b0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090000; 		// Direct COmmnad Register	  
+	
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080962; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080952; 	// Direct COmmnad Register 
+#endif
+		
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+
+	i = 100;
+	while(i)
+	{
+		*(volatile unsigned long *) 0xF0302008=0x00040000; // dir_cmd
+		i--;
+	}
+
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080862; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080852; 	// Direct COmmnad Register 
+#endif
+
+#if defined(DRAM_ODTOFF)
+
+#else
+	*(volatile unsigned long *)0xF0302008 = 0x00090380; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090004; 		// Direct COmmnad Register //soc1-3
+#endif
+
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000000; 		// PL341_GO
+}
+
+//150Mhz
+void init_clockchange150Mhz(void)
+{
+	unsigned int lpll1	=600;
+	unsigned int lmem_source =1; // 0 : PLL0 , 1 : PLL1 
+	unsigned int lmem_div	=4; // Fmbus 130Mhz
+	
+	volatile unsigned int i = 0;	
+	unsigned int ldiv = 0;
+	unsigned int lcycle = 0;
+
+//Enter Mode		
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xF0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xF0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xF030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+		
+
+	*(volatile unsigned long *)0xF0400030 = 0x01010101;
+	*(volatile unsigned long *)0xF0400034 = 0x01010101;
+	
+	*(volatile unsigned long *)0xF0400008 = 0x00200014; 		// XI - memebus
+	
+	//PLL1
+	*(volatile unsigned long *)0xF0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xF0400024= 0x00003201;		// pms - pllout_600M
+	*(volatile unsigned long *)0xF0400024= 0x80003201;		//	pll pwr on
+
+	*(volatile unsigned long *)0xF0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+//Init DDR2 
+	*(volatile unsigned long *) 0xF0302004=0x00000003;			// PL341_PAUSE
+	*(volatile unsigned long *) 0xF0302004=0x00000004;			// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+// memory arb.
+	*(volatile unsigned long *)0xF030200C |= 0x00140000; 
+// memory arb. end
+	
+	*(volatile unsigned long *)0xF030200C = 0x00150012; 		// config0 cas 10bit, ras 13bit
+	*(volatile unsigned long *)0xF0302010 = 0x00000445; 	// refresh 
+	
+#if defined(DRAM_BANK3)
+	*(volatile unsigned long *) 0xF030204c=0x00000571; // config2 - SOC
+#else
+	*(volatile unsigned long *) 0xF030204c=0x00000541; // config2 - SOC
+#endif		
+	
+#if defined(DRAM_CAS6)
+	*(volatile unsigned long *)0xF0302014 = 0x0000000C; 	// cas_latency - 5
+#else
+	*(volatile unsigned long *)0xF0302014 = 0x0000000A; 	// cas_latency - 5
+#endif		
+			
+	*(volatile unsigned long *)0xF030201c = 0x00000003; 		// tMRD
+
+	ldiv = 10000/(lpll1/lmem_div);
+
+	lcycle = 450/ldiv;
+	*(volatile unsigned long *)0xF0302020 = lcycle+1; 			// tRAS - 45ns
+	lcycle = 600/ldiv;
+	*(volatile unsigned long *)0xF0302024 = lcycle+1; 			// tRC	- 60ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302028 = (((lcycle+1-3)<<8) | (lcycle+1)); // tRCD - 15ns
+	lcycle = 1050/ldiv;
+	*(volatile unsigned long *)0xF030202c = (((lcycle+1-3)<<8) | (lcycle+1)); // tRFC - 105ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302030 = (((lcycle+1-3)<<8) | (lcycle+1)); // tRP	- 15ns
+	lcycle = 100/ldiv;
+	*(volatile unsigned long *)0xF0302034 = lcycle+1; 			// tRRD - 10ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302038 = lcycle+1; 			// tWR - 15ns
+	lcycle = 75/ldiv;
+	*(volatile unsigned long *)0xF030203c = lcycle+1; 			// tWTR - 7.5ns
+	*(volatile unsigned long *)0xF0302040 = 0x00000003; 		// tXP - min 2tCK
+
+	*(volatile unsigned long *)0xF0302044 = 0x00000022; 	// tXSR
+	*(volatile unsigned long *)0xF0302048 = 0x000000FA; 	// tESR
+	*(volatile unsigned long *)0xF0302054 = 0x00001619; 	// tFAW
+
+	*(volatile unsigned long *)0xF0302200 = 0x000040f0; 		//256MB  config_chip0
+ //	*(volatile unsigned long *)0xF0302200 = 0x000040f8; 		//128MB config_chip0  //soc1-3
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000001; 		// PL341_SLEEP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 3);	// Wait until SLEEP
+
+	*(volatile unsigned long *)0xF030302C |= 0x00004000; 		// SSTL SDRAM IO Control Register 
+	
+	*(volatile unsigned long *)0xF0303020 = 0x00010103; 		// emccfg_config0
+	*(volatile unsigned long *)0xF0303024 = 0x00000000; 		// SDRAM PHY Control Register 
+	*(volatile unsigned long *)0xF0304400 = 0x00000000; 		// DDR2PHY_PHYMODE
+	*(volatile unsigned long *)0xF0304404 = 0x00000001; 		// DLLCTRL
+	
+	*(volatile unsigned long *)0xF0304408 = 0x00001717; 	// DLLPDCFG
+		
+	*(volatile unsigned long *)0xF0304404 = 0x00000003; 		// DLLCTRL
+	while (((*(volatile unsigned long *)0xF0304404) & (0x00000018)) != (0x00000018)); // Wait DLL Lock
+
+	*(volatile unsigned long *)0xF0304424 = 0x00000035; 		// DLLFORCELOCK
+	*(volatile unsigned long *)0xF030440C = 0x00000006; 		// GATECTRL
+	#if defined(DRAM_CAS6)
+		*(volatile unsigned long *) 0xF0304430=0x00000006; // RDDELAY - SOC
+	#else
+		*(volatile unsigned long *) 0xF0304430=0x00000005; // RDDELAY - SOC
+	#endif
+	
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+	
+	while (!((*(volatile unsigned long *)0xF030442c) & (1)));	// Wait until Calibration completion without error
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000002; 		// PL34X_WAKEUP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 0);	// Wait until CONFIGURE
+
+	*(volatile unsigned long *)0xF0302008 = 0x000c0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000a0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000b0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090000; 		// Direct COmmnad Register	  
+	
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080962; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080952; 	// Direct COmmnad Register 
+#endif
+		
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+
+	i = 100;
+	while(i)
+	{
+		*(volatile unsigned long *) 0xF0302008=0x00040000; // dir_cmd
+		i--;
+	}
+
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080862; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080852; 	// Direct COmmnad Register 
+#endif
+
+#if defined(DRAM_ODTOFF)
+
+#else
+	*(volatile unsigned long *)0xF0302008 = 0x00090380; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090004; 		// Direct COmmnad Register //soc1-3
+#endif
+
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000000; 		// PL341_GO
+}
+
+//160Mhz
+void init_clockchange160Mhz(void)
+{
+	unsigned int lpll1	=320;
+	unsigned int lmem_source =1; // 0 : PLL0 , 1 : PLL1 
+	unsigned int lmem_div	=2; // Fmbus 130Mhz
+	
+	volatile unsigned int i = 0;	
+	unsigned int ldiv = 0;
+	unsigned int lcycle = 0;
+
+//Enter Mode		
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xF0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xF0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xF030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+		
+	*(volatile unsigned long *)0xF0400030 = 0x01010101;
+	*(volatile unsigned long *)0xF0400034 = 0x01010101;
+	
+	*(volatile unsigned long *)0xF0400008 = 0x00200014; 		// XI - memebus
+	
+	//PLL1
+	*(volatile unsigned long *)0xF0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xF0400024= 0x00005003;		// pms - pllout_320M
+	*(volatile unsigned long *)0xF0400024= 0x80005003;		//	pll pwr on
+	*(volatile unsigned long *)0xF0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+//Init DDR2 
+	*(volatile unsigned long *) 0xF0302004=0x00000003;			// PL341_PAUSE
+	*(volatile unsigned long *) 0xF0302004=0x00000004;			// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+// memory arb.
+	*(volatile unsigned long *)0xF030200C |= 0x00140000; 
+// memory arb. end
+	
+	*(volatile unsigned long *)0xF030200C = 0x00150012; 		// config0 cas 10bit, ras 13bit
+	*(volatile unsigned long *)0xF0302010 = 0x00000445; 	// refresh 
+
+#if defined(DRAM_BANK3)
+	*(volatile unsigned long *) 0xF030204c=0x00000571; // config2 - SOC
+#else
+	*(volatile unsigned long *) 0xF030204c=0x00000541; // config2 - SOC
+#endif		
+	
+#if defined(DRAM_CAS6)
+	*(volatile unsigned long *)0xF0302014 = 0x0000000C; 	// cas_latency - 5
+#else
+	*(volatile unsigned long *)0xF0302014 = 0x0000000A; 	// cas_latency - 5
+#endif		
+			
+	*(volatile unsigned long *)0xF030201c = 0x00000003; 		// tMRD
+
+	ldiv = 10000/(lpll1/lmem_div);
+
+	lcycle = 450/ldiv;
+	*(volatile unsigned long *)0xF0302020 = lcycle+1; 			// tRAS - 45ns
+	lcycle = 600/ldiv;
+	*(volatile unsigned long *)0xF0302024 = lcycle+1; 			// tRC	- 60ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302028 = (((lcycle+1-3)<<8) | (lcycle+1)); // tRCD - 15ns
+	lcycle = 1050/ldiv;
+	*(volatile unsigned long *)0xF030202c = (((lcycle+1-3)<<8) | (lcycle+1)); // tRFC - 105ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302030 = (((lcycle+1-3)<<8) | (lcycle+1)); // tRP	- 15ns
+	lcycle = 100/ldiv;
+	*(volatile unsigned long *)0xF0302034 = lcycle+1; 			// tRRD - 10ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302038 = lcycle+1; 			// tWR - 15ns
+	lcycle = 75/ldiv;
+	*(volatile unsigned long *)0xF030203c = lcycle+1; 			// tWTR - 7.5ns
+	*(volatile unsigned long *)0xF0302040 = 0x00000003; 		// tXP - min 2tCK
+
+	*(volatile unsigned long *)0xF0302044 = 0x00000022; 	// tXSR
+	*(volatile unsigned long *)0xF0302048 = 0x000000FA; 	// tESR
+	*(volatile unsigned long *)0xF0302054 = 0x00001619; 	// tFAW
+
+	*(volatile unsigned long *)0xF0302200 = 0x000040f0; 		//256MB  config_chip0
+ //	*(volatile unsigned long *)0xF0302200 = 0x000040f8; 		//128MB config_chip0  //soc1-3
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000001; 		// PL341_SLEEP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 3);	// Wait until SLEEP
+
+	*(volatile unsigned long *)0xF030302C |= 0x00004000; 		// SSTL SDRAM IO Control Register 
+	
+	*(volatile unsigned long *)0xF0303020 = 0x00010103; 		// emccfg_config0
+	*(volatile unsigned long *)0xF0303024 = 0x00000000; 		// SDRAM PHY Control Register 
+	*(volatile unsigned long *)0xF0304400 = 0x00000000; 		// DDR2PHY_PHYMODE
+	*(volatile unsigned long *)0xF0304404 = 0x00000001; 		// DLLCTRL
+	
+	*(volatile unsigned long *)0xF0304408 = 0x00001717; 	// DLLPDCFG
+		
+	*(volatile unsigned long *)0xF0304404 = 0x00000003; 		// DLLCTRL
+	while (((*(volatile unsigned long *)0xF0304404) & (0x00000018)) != (0x00000018)); // Wait DLL Lock
+
+	*(volatile unsigned long *)0xF0304424 = 0x00000035; 		// DLLFORCELOCK
+	*(volatile unsigned long *)0xF030440C = 0x00000006; 		// GATECTRL
+	#if defined(DRAM_CAS6)
+		*(volatile unsigned long *) 0xF0304430=0x00000006; // RDDELAY - SOC
+	#else
+		*(volatile unsigned long *) 0xF0304430=0x00000005; // RDDELAY - SOC
+	#endif
+	
+	
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+	
+	while (!((*(volatile unsigned long *)0xF030442c) & (1)));	// Wait until Calibration completion without error
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+	
+	*(volatile unsigned long *)0xF0302004 = 0x00000002; 		// PL34X_WAKEUP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 0);	// Wait until CONFIGURE
+
+	*(volatile unsigned long *)0xF0302008 = 0x000c0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000a0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000b0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090000; 		// Direct COmmnad Register	  
+	
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080962; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080952; 	// Direct COmmnad Register 
+#endif
+		
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+
+	i = 100;
+	while(i)
+	{
+		*(volatile unsigned long *) 0xF0302008=0x00040000; // dir_cmd
+		i--;
+	}
+
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080862; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080852; 	// Direct COmmnad Register 
+#endif
+
+#if defined(DRAM_ODTOFF)
+
+#else
+	*(volatile unsigned long *)0xF0302008 = 0x00090380; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090004; 		// Direct COmmnad Register //soc1-3
+#endif
+
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000000; 		// PL341_GO
+}
+
+//170Mhz
+void init_clockchange170Mhz(void)
+{
+	unsigned int lpll1	=340;
+	unsigned int lmem_source =1; // 0 : PLL0 , 1 : PLL1 
+	unsigned int lmem_div	=2; // Fmbus 130Mhz
+	
+	volatile unsigned int i = 0;	
+	unsigned int ldiv = 0;
+	unsigned int lcycle = 0;
+
+//Enter Mode		
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xF0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xF0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xF030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+		
+	*(volatile unsigned long *)0xF0400030 = 0x01010101;
+	*(volatile unsigned long *)0xF0400034 = 0x01010101;
+	
+	*(volatile unsigned long *)0xF0400008 = 0x00200014; 		// XI - memebus
+	
+	//PLL1
+	*(volatile unsigned long *)0xF0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xF0400024= 0x00005503;		// pms - pllout_320M
+	*(volatile unsigned long *)0xF0400024= 0x80005503;		//	pll pwr on
+
+	*(volatile unsigned long *)0xF0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+//Init DDR2 
+	*(volatile unsigned long *) 0xF0302004=0x00000003;			// PL341_PAUSE
+	*(volatile unsigned long *) 0xF0302004=0x00000004;			// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+// memory arb.
+	*(volatile unsigned long *)0xF030200C |= 0x00140000; 
+// memory arb. end
+	
+	*(volatile unsigned long *)0xF030200C = 0x00150012; 		// config0 cas 10bit, ras 13bit
+	*(volatile unsigned long *)0xF0302010 = 0x00000445; 	// refresh 
+	
+#if defined(DRAM_BANK3)
+	*(volatile unsigned long *) 0xF030204c=0x00000571; // config2 - SOC
+#else
+	*(volatile unsigned long *) 0xF030204c=0x00000541; // config2 - SOC
+#endif		
+	
+#if defined(DRAM_CAS6)
+	*(volatile unsigned long *)0xF0302014 = 0x0000000C; 	// cas_latency - 5
+#else
+	*(volatile unsigned long *)0xF0302014 = 0x0000000A; 	// cas_latency - 5
+#endif		
+			
+	*(volatile unsigned long *)0xF030201c = 0x00000003; 		// tMRD
+
+	ldiv = 10000/(lpll1/lmem_div);
+
+	lcycle = 450/ldiv;
+	*(volatile unsigned long *)0xF0302020 = lcycle+1; 			// tRAS - 45ns
+	lcycle = 600/ldiv;
+	*(volatile unsigned long *)0xF0302024 = lcycle+1; 			// tRC	- 60ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302028 = (((lcycle+1-3)<<8) | (lcycle+1)); // tRCD - 15ns
+	lcycle = 1050/ldiv;
+	*(volatile unsigned long *)0xF030202c = (((lcycle+1-3)<<8) | (lcycle+1)); // tRFC - 105ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302030 = (((lcycle+1-3)<<8) | (lcycle+1)); // tRP	- 15ns
+	lcycle = 100/ldiv;
+	*(volatile unsigned long *)0xF0302034 = lcycle+1; 			// tRRD - 10ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302038 = lcycle+1; 			// tWR - 15ns
+	lcycle = 75/ldiv;
+	*(volatile unsigned long *)0xF030203c = lcycle+1; 			// tWTR - 7.5ns
+	*(volatile unsigned long *)0xF0302040 = 0x00000003; 		// tXP - min 2tCK
+
+	*(volatile unsigned long *)0xF0302044 = 0x00000022; 	// tXSR
+	*(volatile unsigned long *)0xF0302048 = 0x000000FA; 	// tESR
+	*(volatile unsigned long *)0xF0302054 = 0x00001619; 	// tFAW
+
+	*(volatile unsigned long *)0xF0302200 = 0x000040f0; 		//256MB  config_chip0
+ //	*(volatile unsigned long *)0xF0302200 = 0x000040f8; 		//128MB config_chip0  //soc1-3
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000001; 		// PL341_SLEEP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 3);	// Wait until SLEEP
+
+	*(volatile unsigned long *)0xF030302C |= 0x00004000; 		// SSTL SDRAM IO Control Register 
+	
+	*(volatile unsigned long *)0xF0303020 = 0x00010103; 		// emccfg_config0
+	*(volatile unsigned long *)0xF0303024 = 0x00000000; 		// SDRAM PHY Control Register 
+	*(volatile unsigned long *)0xF0304400 = 0x00000000; 		// DDR2PHY_PHYMODE
+	*(volatile unsigned long *)0xF0304404 = 0x00000001; 		// DLLCTRL
+	
+	*(volatile unsigned long *)0xF0304408 = 0x00001717; 	// DLLPDCFG
+		
+	*(volatile unsigned long *)0xF0304404 = 0x00000003; 		// DLLCTRL
+	while (((*(volatile unsigned long *)0xF0304404) & (0x00000018)) != (0x00000018)); // Wait DLL Lock
+
+	*(volatile unsigned long *)0xF0304424 = 0x00000035; 		// DLLFORCELOCK
+	*(volatile unsigned long *)0xF030440C = 0x00000006; 		// GATECTRL
+	#if defined(DRAM_CAS6)
+		*(volatile unsigned long *) 0xF0304430=0x00000006; // RDDELAY - SOC
+	#else
+		*(volatile unsigned long *) 0xF0304430=0x00000005; // RDDELAY - SOC
+	#endif
+	
+	
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+	
+	while (!((*(volatile unsigned long *)0xF030442c) & (1)));	// Wait until Calibration completion without error
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000002; 		// PL34X_WAKEUP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 0);	// Wait until CONFIGURE
+
+	*(volatile unsigned long *)0xF0302008 = 0x000c0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000a0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000b0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090000; 		// Direct COmmnad Register	  
+	
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080962; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080952; 	// Direct COmmnad Register 
+#endif
+		
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+
+	i = 100;
+	while(i)
+	{
+		*(volatile unsigned long *) 0xF0302008=0x00040000; // dir_cmd
+		i--;
+	}
+
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080862; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080852; 	// Direct COmmnad Register 
+#endif
+
+#if defined(DRAM_ODTOFF)
+
+#else
+	*(volatile unsigned long *)0xF0302008 = 0x00090380; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090004; 		// Direct COmmnad Register //soc1-3
+#endif
+
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000000; 		// PL341_GO
+}
+
+//180Mhz
+void init_clockchange180Mhz(void)
+{
+	unsigned int lpll1	=360;
+	unsigned int lmem_source =1; // 0 : PLL0 , 1 : PLL1 
+	unsigned int lmem_div	=2; // Fmbus 130Mhz
+	
+	volatile unsigned int i = 0;	
+	unsigned int ldiv = 0;
+	unsigned int lcycle = 0;
+
+//Enter Mode		
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xF0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xF0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xF030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+		
+	*(volatile unsigned long *)0xF0400030 = 0x01010101;
+	*(volatile unsigned long *)0xF0400034 = 0x01010101;
+	
+	*(volatile unsigned long *)0xF0400008 = 0x00200014; 		// XI - memebus
+	
+	//PLL1
+	*(volatile unsigned long *)0xF0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xF0400024= 0x00001E01;		// pms - pllout_320M
+	*(volatile unsigned long *)0xF0400024= 0x80001E01;		//	pll pwr on
+
+	*(volatile unsigned long *)0xF0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+//Init DDR2 
+	*(volatile unsigned long *) 0xF0302004=0x00000003;			// PL341_PAUSE
+	*(volatile unsigned long *) 0xF0302004=0x00000004;			// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+// memory arb.
+	*(volatile unsigned long *)0xF030200C |= 0x00140000; 
+// memory arb. end
+	
+	*(volatile unsigned long *)0xF030200C = 0x00150012; 		// config0 cas 10bit, ras 13bit
+	*(volatile unsigned long *)0xF0302010 = 0x00000445; 	// refresh 
+	
+#if defined(DRAM_BANK3)
+	*(volatile unsigned long *) 0xF030204c=0x00000571; // config2 - SOC
+#else
+	*(volatile unsigned long *) 0xF030204c=0x00000541; // config2 - SOC
+#endif		
+	
+#if defined(DRAM_CAS6)
+	*(volatile unsigned long *)0xF0302014 = 0x0000000C; 	// cas_latency - 5
+#else
+	*(volatile unsigned long *)0xF0302014 = 0x0000000A; 	// cas_latency - 5
+#endif		
+			
+	*(volatile unsigned long *)0xF030201c = 0x00000003; 		// tMRD
+
+	ldiv = 10000/(lpll1/lmem_div);
+
+	lcycle = 450/ldiv;
+	*(volatile unsigned long *)0xF0302020 = lcycle+1; 			// tRAS - 45ns
+	lcycle = 600/ldiv;
+	*(volatile unsigned long *)0xF0302024 = lcycle+1; 			// tRC	- 60ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302028 = (((lcycle+1-3)<<8) | (lcycle+1)); // tRCD - 15ns
+	lcycle = 1050/ldiv;
+	*(volatile unsigned long *)0xF030202c = (((lcycle+1-3)<<8) | (lcycle+1)); // tRFC - 105ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302030 = (((lcycle+1-3)<<8) | (lcycle+1)); // tRP	- 15ns
+	lcycle = 100/ldiv;
+	*(volatile unsigned long *)0xF0302034 = lcycle+1; 			// tRRD - 10ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302038 = lcycle+1; 			// tWR - 15ns
+	lcycle = 75/ldiv;
+	*(volatile unsigned long *)0xF030203c = lcycle+1; 			// tWTR - 7.5ns
+	*(volatile unsigned long *)0xF0302040 = 0x00000003; 		// tXP - min 2tCK
+
+	*(volatile unsigned long *)0xF0302044 = 0x00000022; 	// tXSR
+	*(volatile unsigned long *)0xF0302048 = 0x000000FA; 	// tESR
+	*(volatile unsigned long *)0xF0302054 = 0x00001619; 	// tFAW
+
+	*(volatile unsigned long *)0xF0302200 = 0x000040f0; 		//256MB  config_chip0
+ //	*(volatile unsigned long *)0xF0302200 = 0x000040f8; 		//128MB config_chip0  //soc1-3
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000001; 		// PL341_SLEEP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 3);	// Wait until SLEEP
+
+	*(volatile unsigned long *)0xF030302C |= 0x00004000; 		// SSTL SDRAM IO Control Register 
+	
+	*(volatile unsigned long *)0xF0303020 = 0x00010103; 		// emccfg_config0
+	*(volatile unsigned long *)0xF0303024 = 0x00000000; 		// SDRAM PHY Control Register 
+	*(volatile unsigned long *)0xF0304400 = 0x00000000; 		// DDR2PHY_PHYMODE
+	*(volatile unsigned long *)0xF0304404 = 0x00000001; 		// DLLCTRL
+	
+	*(volatile unsigned long *)0xF0304408 = 0x00001717; 	// DLLPDCFG
+		
+	*(volatile unsigned long *)0xF0304404 = 0x00000003; 		// DLLCTRL
+	while (((*(volatile unsigned long *)0xF0304404) & (0x00000018)) != (0x00000018)); // Wait DLL Lock
+
+	*(volatile unsigned long *)0xF0304424 = 0x00000035; 		// DLLFORCELOCK
+	*(volatile unsigned long *)0xF030440C = 0x00000006; 		// GATECTRL
+	#if defined(DRAM_CAS6)
+		*(volatile unsigned long *) 0xF0304430=0x00000006; // RDDELAY - SOC
+	#else
+		*(volatile unsigned long *) 0xF0304430=0x00000005; // RDDELAY - SOC
+	#endif
+	
+	
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+	
+	while (!((*(volatile unsigned long *)0xF030442c) & (1)));	// Wait until Calibration completion without error
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000002; 		// PL34X_WAKEUP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 0);	// Wait until CONFIGURE
+
+	*(volatile unsigned long *)0xF0302008 = 0x000c0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000a0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000b0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090000; 		// Direct COmmnad Register	  
+	
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080962; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080952; 	// Direct COmmnad Register 
+#endif
+		
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+
+	i = 100;
+	while(i)
+	{
+		*(volatile unsigned long *) 0xF0302008=0x00040000; // dir_cmd
+		i--;
+	}
+
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080862; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080852; 	// Direct COmmnad Register 
+#endif
+
+#if defined(DRAM_ODTOFF)
+
+#else
+	*(volatile unsigned long *)0xF0302008 = 0x00090380; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090004; 		// Direct COmmnad Register //soc1-3
+#endif
+
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000000; 		// PL341_GO
+}
+
+//190Mhz
+void init_clockchange190Mhz(void)
+{
+	unsigned int lpll1	=380;
+	unsigned int lmem_source =1; // 0 : PLL0 , 1 : PLL1 
+	unsigned int lmem_div	=2; // Fmbus 130Mhz
+	
+	volatile unsigned int i = 0;	
+	unsigned int ldiv = 0;
+	unsigned int lcycle = 0;
+
+//Enter Mode		
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xF0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xF0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xF030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+		
+	*(volatile unsigned long *)0xF0400030 = 0x01010101;
+	*(volatile unsigned long *)0xF0400034 = 0x01010101;
+	
+	*(volatile unsigned long *)0xF0400008 = 0x00200014; 		// XI - memebus
+	
+	//PLL1
+	*(volatile unsigned long *)0xF0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xF0400024= 0x00005F03;		// pms - pllout_320M
+	*(volatile unsigned long *)0xF0400024= 0x80005F03;		//	pll pwr on
+
+	*(volatile unsigned long *)0xF0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+//Init DDR2 
+	*(volatile unsigned long *) 0xF0302004=0x00000003;			// PL341_PAUSE
+	*(volatile unsigned long *) 0xF0302004=0x00000004;			// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+// memory arb.
+	*(volatile unsigned long *)0xF030200C |= 0x00140000; 
+// memory arb. end
+	
+	*(volatile unsigned long *)0xF030200C = 0x00150012; 		// config0 cas 10bit, ras 13bit
+	*(volatile unsigned long *)0xF0302010 = 0x00000445; 	// refresh 
+	
+#if defined(DRAM_BANK3)
+	*(volatile unsigned long *) 0xF030204c=0x00000571; // config2 - SOC
+#else
+	*(volatile unsigned long *) 0xF030204c=0x00000541; // config2 - SOC
+#endif		
+	
+#if defined(DRAM_CAS6)
+	*(volatile unsigned long *)0xF0302014 = 0x0000000C; 	// cas_latency - 5
+#else
+	*(volatile unsigned long *)0xF0302014 = 0x0000000A; 	// cas_latency - 5
+#endif		
+			
+	*(volatile unsigned long *)0xF030201c = 0x00000003; 		// tMRD
+
+	ldiv = 10000/(lpll1/lmem_div);
+
+	lcycle = 450/ldiv;
+	*(volatile unsigned long *)0xF0302020 = lcycle+1; 			// tRAS - 45ns
+	lcycle = 600/ldiv;
+	*(volatile unsigned long *)0xF0302024 = lcycle+1; 			// tRC	- 60ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302028 = (((lcycle+1-3)<<8) | (lcycle+1)); // tRCD - 15ns
+	lcycle = 1050/ldiv;
+	*(volatile unsigned long *)0xF030202c = (((lcycle+1-3)<<8) | (lcycle+1)); // tRFC - 105ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302030 = (((lcycle+1-3)<<8) | (lcycle+1)); // tRP	- 15ns
+	lcycle = 100/ldiv;
+	*(volatile unsigned long *)0xF0302034 = lcycle+1; 			// tRRD - 10ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302038 = lcycle+1; 			// tWR - 15ns
+	lcycle = 75/ldiv;
+	*(volatile unsigned long *)0xF030203c = lcycle+1; 			// tWTR - 7.5ns
+	*(volatile unsigned long *)0xF0302040 = 0x00000003; 		// tXP - min 2tCK
+
+	*(volatile unsigned long *)0xF0302044 = 0x00000022; 	// tXSR
+	*(volatile unsigned long *)0xF0302048 = 0x000000FA; 	// tESR
+	*(volatile unsigned long *)0xF0302054 = 0x00001619; 	// tFAW
+	*(volatile unsigned long *)0xF0302200 = 0x000040f0; 		//256MB  config_chip0
+ //	*(volatile unsigned long *)0xF0302200 = 0x000040f8; 		//128MB config_chip0  //soc1-3
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000001; 		// PL341_SLEEP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 3);	// Wait until SLEEP
+
+	*(volatile unsigned long *)0xF030302C |= 0x00004000; 		// SSTL SDRAM IO Control Register 
+	
+	*(volatile unsigned long *)0xF0303020 = 0x00010103; 		// emccfg_config0
+	*(volatile unsigned long *)0xF0303024 = 0x00000000; 		// SDRAM PHY Control Register 
+	*(volatile unsigned long *)0xF0304400 = 0x00000000; 		// DDR2PHY_PHYMODE
+	*(volatile unsigned long *)0xF0304404 = 0x00000001; 		// DLLCTRL
+	
+	*(volatile unsigned long *)0xF0304408 = 0x00001717; 	// DLLPDCFG
+		
+	*(volatile unsigned long *)0xF0304404 = 0x00000003; 		// DLLCTRL
+	while (((*(volatile unsigned long *)0xF0304404) & (0x00000018)) != (0x00000018)); // Wait DLL Lock
+
+	*(volatile unsigned long *)0xF0304424 = 0x00000035; 		// DLLFORCELOCK
+	*(volatile unsigned long *)0xF030440C = 0x00000006; 		// GATECTRL
+	#if defined(DRAM_CAS6)
+		*(volatile unsigned long *) 0xF0304430=0x00000006; // RDDELAY - SOC
+	#else
+		*(volatile unsigned long *) 0xF0304430=0x00000005; // RDDELAY - SOC
+	#endif
+	
+	
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+	
+	while (!((*(volatile unsigned long *)0xF030442c) & (1)));	// Wait until Calibration completion without error
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000002; 		// PL34X_WAKEUP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 0);	// Wait until CONFIGURE
+
+	*(volatile unsigned long *)0xF0302008 = 0x000c0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000a0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000b0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090000; 		// Direct COmmnad Register	  
+	
+#if defined(DRAM_CAS6)
+	*(volatile unsigned long *)0xF0302008 = 0x00080962; 	// Direct COmmnad Register 
+#else
+	*(volatile unsigned long *)0xF0302008 = 0x00080952; 	// Direct COmmnad Register 
+#endif
+		
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+
+	i = 100;
+	while(i)
+	{
+		*(volatile unsigned long *) 0xF0302008=0x00040000; // dir_cmd
+		i--;
+	}
+
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080862; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080852; 	// Direct COmmnad Register 
+#endif
+
+#if defined(DRAM_ODTOFF)
+
+#else
+	*(volatile unsigned long *)0xF0302008 = 0x00090380; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090004; 		// Direct COmmnad Register //soc1-3
+#endif
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000000; 		// PL341_GO
+}
+#endif
Index: linux-2.6.29/arch/arm/mach-tcc8900/tcc8900/tcc_ckcddr2_141to190.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/tcc8900/tcc_ckcddr2_141to190.h	2010-04-07 13:00:58.000000000 -0400
@@ -0,0 +1,23 @@
+#if defined(_LINUX_)
+    #include "../../../../../../bootloader/tcboot/include/ddr.h"
+#else
+    #include "windows.h"
+
+    #include "bsp.h"
+    #include "tca_ckc.h"
+#endif
+
+
+#if !defined(DRAM_MDDR)
+extern void init_clockchange125Mhz(void);
+extern void init_clockchange130Mhz(void);
+extern void init_clockchange135Mhz(void);
+extern void init_clockchange141Mhz(void);
+extern void init_clockchange145Mhz(void);
+extern void init_clockchange150Mhz(void);
+extern void init_clockchange160Mhz(void);
+extern void init_clockchange170Mhz(void);
+extern void init_clockchange180Mhz(void);
+extern void init_clockchange190Mhz(void);
+#endif
+
Index: linux-2.6.29/arch/arm/mach-tcc8900/tcc8900/tcc_ckcddr2_200to290.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/tcc8900/tcc_ckcddr2_200to290.c	2010-04-07 12:59:47.000000000 -0400
@@ -0,0 +1,2287 @@
+#include "tcc_ckcddr2_200to290.h"
+
+#if !defined(DRAM_MDDR)
+
+//200Mhz
+void init_clockchange200Mhz(void)
+{
+	unsigned int lpll1	=400;
+	unsigned int lmem_source =1; // 0 : PLL0 , 1 : PLL1 
+	unsigned int lmem_div	=2; // Fmbus 130Mhz
+	
+	volatile unsigned int i = 0;	
+	unsigned int ldiv = 0;
+	unsigned int lcycle = 0;
+
+//Enter Mode		
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xF0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xF0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xF030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+		
+
+	*(volatile unsigned long *)0xF0400030 = 0x01010101;
+	*(volatile unsigned long *)0xF0400034 = 0x01010101;
+	
+	*(volatile unsigned long *)0xF0400008 = 0x00200014; 		// XI - memebus
+	
+	//PLL1
+	*(volatile unsigned long *)0xF0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xF0400024= 0x00006403;		// pms - pllout_400M
+	*(volatile unsigned long *)0xF0400024= 0x80006403;		//	pll pwr on
+
+	*(volatile unsigned long *)0xF0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+//Init DDR2 
+	*(volatile unsigned long *) 0xF0302004=0x00000003;			// PL341_PAUSE
+	*(volatile unsigned long *) 0xF0302004=0x00000004;			// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+// memory arb.
+	*(volatile unsigned long *)0xF030200C |= 0x00140000; 
+// memory arb. end
+	
+	*(volatile unsigned long *)0xF030200C = 0x00150012; 		// config0 cas 10bit, ras 13bit
+	*(volatile unsigned long *)0xF0302010 = 0x00000445; 	// refresh 
+	
+#if defined(DRAM_BANK3)
+	*(volatile unsigned long *) 0xF030204c=0x00000571; // config2 - SOC
+#else
+	*(volatile unsigned long *) 0xF030204c=0x00000541; // config2 - SOC
+#endif		
+	
+#if defined(DRAM_CAS6)
+	*(volatile unsigned long *)0xF0302014 = 0x0000000C; 	// cas_latency - 5
+#else
+	*(volatile unsigned long *)0xF0302014 = 0x0000000A; 	// cas_latency - 5
+#endif		
+			
+	*(volatile unsigned long *)0xF030201c = 0x00000003; 		// tMRD
+
+	ldiv = 10000/(lpll1/lmem_div);
+
+	lcycle = 450/ldiv;
+	*(volatile unsigned long *)0xF0302020 = lcycle+1; 			// tRAS - 45ns
+	lcycle = 600/ldiv;
+	*(volatile unsigned long *)0xF0302024 = lcycle+1; 			// tRC	- 60ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302028 = (((lcycle+1-3)<<8) | (lcycle+1)); // tRCD - 15ns
+	lcycle = 1050/ldiv;
+	*(volatile unsigned long *)0xF030202c = (((lcycle+1-3)<<8) | (lcycle+1)); // tRFC - 105ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302030 = (((lcycle+1-3)<<8) | (lcycle+1)); // tRP	- 15ns
+	lcycle = 100/ldiv;
+	*(volatile unsigned long *)0xF0302034 = lcycle+1; 			// tRRD - 10ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302038 = lcycle+1; 			// tWR - 15ns
+	lcycle = 75/ldiv;
+	*(volatile unsigned long *)0xF030203c = lcycle+1; 			// tWTR - 7.5ns
+	*(volatile unsigned long *)0xF0302040 = 0x00000003; 		// tXP - min 2tCK
+
+	*(volatile unsigned long *)0xF0302044 = 0x00000022; 	// tXSR
+	*(volatile unsigned long *)0xF0302048 = 0x000000FA; 	// tESR
+	*(volatile unsigned long *)0xF0302054 = 0x00001619; 	// tFAW
+	*(volatile unsigned long *)0xF0302200 = 0x000040f0; 		//256MB  config_chip0
+ //	*(volatile unsigned long *)0xF0302200 = 0x000040f8; 		//128MB config_chip0  //soc1-3
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000001; 		// PL341_SLEEP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 3);	// Wait until SLEEP
+
+	*(volatile unsigned long *)0xF030302C |= 0x00004000; 		// SSTL SDRAM IO Control Register 
+	
+	*(volatile unsigned long *)0xF0303020 = 0x00010103; 		// emccfg_config0
+	*(volatile unsigned long *)0xF0303024 = 0x00000000; 		// SDRAM PHY Control Register 
+	*(volatile unsigned long *)0xF0304400 = 0x00000000; 		// DDR2PHY_PHYMODE
+	*(volatile unsigned long *)0xF0304404 = 0x00000001; 		// DLLCTRL
+	
+	*(volatile unsigned long *)0xF0304408 = 0x00001717; 	// DLLPDCFG
+		
+	*(volatile unsigned long *)0xF0304404 = 0x00000003; 		// DLLCTRL
+	while (((*(volatile unsigned long *)0xF0304404) & (0x00000018)) != (0x00000018)); // Wait DLL Lock
+
+	*(volatile unsigned long *)0xF0304424 = 0x00000035; 		// DLLFORCELOCK
+	*(volatile unsigned long *)0xF030440C = 0x00000006; 		// GATECTRL
+	#if defined(DRAM_CAS6)
+		*(volatile unsigned long *) 0xF0304430=0x00000006; // RDDELAY - SOC
+	#else
+		*(volatile unsigned long *) 0xF0304430=0x00000005; // RDDELAY - SOC
+	#endif
+	
+	
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+	
+	while (!((*(volatile unsigned long *)0xF030442c) & (1)));	// Wait until Calibration completion without error
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000002; 		// PL34X_WAKEUP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 0);	// Wait until CONFIGURE
+
+	*(volatile unsigned long *)0xF0302008 = 0x000c0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000a0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000b0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090000; 		// Direct COmmnad Register	  
+	
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080962; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080952; 	// Direct COmmnad Register 
+#endif
+		
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+
+	i = 100;
+	while(i)
+	{
+		*(volatile unsigned long *) 0xF0302008=0x00040000; // dir_cmd
+		i--;
+	}
+
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080862; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080852; 	// Direct COmmnad Register 
+#endif
+
+#if defined(DRAM_ODTOFF)
+
+#else
+	*(volatile unsigned long *)0xF0302008 = 0x00090380; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090004; 		// Direct COmmnad Register //soc1-3
+#endif
+
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000000; 		// PL341_GO
+}
+
+//210Mhz
+void init_clockchange210Mhz(void)
+{
+	unsigned int lpll1	=420;
+	unsigned int lmem_source =1; // 0 : PLL0 , 1 : PLL1 
+	unsigned int lmem_div	=2; // Fmbus 130Mhz
+	
+	volatile unsigned int i = 0;	
+	unsigned int ldiv = 0;
+	unsigned int lcycle = 0;
+
+//Enter Mode		
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xF0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xF0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xF030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+		
+	*(volatile unsigned long *)0xF0400030 = 0x01010101;
+	*(volatile unsigned long *)0xF0400034 = 0x01010101;
+	
+	*(volatile unsigned long *)0xF0400008 = 0x00200014; 		// XI - memebus
+	
+	//PLL1
+	*(volatile unsigned long *)0xF0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xF0400024= 0x00002301;		// pms - pllout_420M
+	*(volatile unsigned long *)0xF0400024= 0x80002301;		//	pll pwr on
+
+	*(volatile unsigned long *)0xF0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+//Init DDR2 
+	*(volatile unsigned long *) 0xF0302004=0x00000003;			// PL341_PAUSE
+	*(volatile unsigned long *) 0xF0302004=0x00000004;			// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+// memory arb.
+	*(volatile unsigned long *)0xF030200C |= 0x00140000; 
+// memory arb. end
+	
+	*(volatile unsigned long *)0xF030200C = 0x00150012; 		// config0 cas 10bit, ras 13bit
+	*(volatile unsigned long *)0xF0302010 = 0x00000445; 	// refresh 
+	
+#if defined(DRAM_BANK3)
+	*(volatile unsigned long *) 0xF030204c=0x00000571; // config2 - SOC
+#else
+	*(volatile unsigned long *) 0xF030204c=0x00000541; // config2 - SOC
+#endif		
+	
+#if defined(DRAM_CAS6)
+	*(volatile unsigned long *)0xF0302014 = 0x0000000C; 	// cas_latency - 5
+#else
+	*(volatile unsigned long *)0xF0302014 = 0x0000000A; 	// cas_latency - 5
+#endif		
+			
+	*(volatile unsigned long *)0xF030201c = 0x00000003; 		// tMRD
+
+	ldiv = 10000/(lpll1/lmem_div);
+
+	lcycle = 450/ldiv;
+	*(volatile unsigned long *)0xF0302020 = lcycle+1; 			// tRAS - 45ns
+	lcycle = 600/ldiv;
+	*(volatile unsigned long *)0xF0302024 = lcycle+1; 			// tRC	- 60ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302028 = (((lcycle+1-3)<<8) | (lcycle+1)); // tRCD - 15ns
+	lcycle = 1050/ldiv;
+	*(volatile unsigned long *)0xF030202c = (((lcycle+1-3)<<8) | (lcycle+1)); // tRFC - 105ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302030 = (((lcycle+1-3)<<8) | (lcycle+1)); // tRP	- 15ns
+	lcycle = 100/ldiv;
+	*(volatile unsigned long *)0xF0302034 = lcycle+1; 			// tRRD - 10ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302038 = lcycle+1; 			// tWR - 15ns
+	lcycle = 75/ldiv;
+	*(volatile unsigned long *)0xF030203c = lcycle+1; 			// tWTR - 7.5ns
+	*(volatile unsigned long *)0xF0302040 = 0x00000003; 		// tXP - min 2tCK
+
+	*(volatile unsigned long *)0xF0302044 = 0x00000022; 	// tXSR
+	*(volatile unsigned long *)0xF0302048 = 0x000000FA; 	// tESR
+	*(volatile unsigned long *)0xF0302054 = 0x00001619; 	// tFAW
+	*(volatile unsigned long *)0xF0302200 = 0x000040f0; 		//256MB  config_chip0
+ //	*(volatile unsigned long *)0xF0302200 = 0x000040f8; 		//128MB config_chip0  //soc1-3
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000001; 		// PL341_SLEEP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 3);	// Wait until SLEEP
+
+	*(volatile unsigned long *)0xF030302C |= 0x00004000; 		// SSTL SDRAM IO Control Register 
+	
+	*(volatile unsigned long *)0xF0303020 = 0x00010103; 		// emccfg_config0
+	*(volatile unsigned long *)0xF0303024 = 0x00000000; 		// SDRAM PHY Control Register 
+	*(volatile unsigned long *)0xF0304400 = 0x00000000; 		// DDR2PHY_PHYMODE
+	*(volatile unsigned long *)0xF0304404 = 0x00000001; 		// DLLCTRL
+	
+	*(volatile unsigned long *)0xF0304408 = 0x00001717; 	// DLLPDCFG
+		
+	*(volatile unsigned long *)0xF0304404 = 0x00000003; 		// DLLCTRL
+	while (((*(volatile unsigned long *)0xF0304404) & (0x00000018)) != (0x00000018)); // Wait DLL Lock
+
+	*(volatile unsigned long *)0xF0304424 = 0x00000035; 		// DLLFORCELOCK
+	*(volatile unsigned long *)0xF030440C = 0x00000006; 		// GATECTRL
+	#if defined(DRAM_CAS6)
+		*(volatile unsigned long *) 0xF0304430=0x00000006; // RDDELAY - SOC
+	#else
+		*(volatile unsigned long *) 0xF0304430=0x00000005; // RDDELAY - SOC
+	#endif
+	
+	
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+	
+	while (!((*(volatile unsigned long *)0xF030442c) & (1)));	// Wait until Calibration completion without error
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000002; 		// PL34X_WAKEUP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 0);	// Wait until CONFIGURE
+
+	*(volatile unsigned long *)0xF0302008 = 0x000c0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000a0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000b0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090000; 		// Direct COmmnad Register	  
+	
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080962; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080952; 	// Direct COmmnad Register 
+#endif
+		
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+
+	i = 100;
+	while(i)
+	{
+		*(volatile unsigned long *) 0xF0302008=0x00040000; // dir_cmd
+		i--;
+	}
+
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080862; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080852; 	// Direct COmmnad Register 
+#endif
+
+#if defined(DRAM_ODTOFF)
+
+#else
+	*(volatile unsigned long *)0xF0302008 = 0x00090380; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090004; 		// Direct COmmnad Register //soc1-3
+#endif
+
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000000; 		// PL341_GO
+}
+
+//220Mhz
+void init_clockchange220Mhz(void)
+{
+	unsigned int lpll1	=440;
+	unsigned int lmem_source =1; // 0 : PLL0 , 1 : PLL1 
+	unsigned int lmem_div	=2; // Fmbus 130Mhz
+	
+	volatile unsigned int i = 0;	
+	unsigned int ldiv = 0;
+	unsigned int lcycle = 0;
+
+//Enter Mode		
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xF0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xF0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xF030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+		
+	*(volatile unsigned long *)0xF0400030 = 0x01010101;
+	*(volatile unsigned long *)0xF0400034 = 0x01010101;
+	
+	*(volatile unsigned long *)0xF0400008 = 0x00200014; 		// XI - memebus
+	
+	
+	//PLL1
+	*(volatile unsigned long *)0xF0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xF0400024= 0x00006E03;		// pms - pllout_600M
+	*(volatile unsigned long *)0xF0400024= 0x80006E03;		//	pll pwr on
+
+	*(volatile unsigned long *)0xF0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+//Init DDR2 
+	*(volatile unsigned long *) 0xF0302004=0x00000003;			// PL341_PAUSE
+	*(volatile unsigned long *) 0xF0302004=0x00000004;			// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+// memory arb.
+	*(volatile unsigned long *)0xF030200C |= 0x00140000; 
+// memory arb. end
+	
+	*(volatile unsigned long *)0xF030200C = 0x00150012; 		// config0 cas 10bit, ras 13bit
+	*(volatile unsigned long *)0xF0302010 = 0x00000445; 	// refresh 
+	
+#if defined(DRAM_BANK3)
+	*(volatile unsigned long *) 0xF030204c=0x00000571; // config2 - SOC
+#else
+	*(volatile unsigned long *) 0xF030204c=0x00000541; // config2 - SOC
+#endif		
+	
+#if defined(DRAM_CAS6)
+	*(volatile unsigned long *)0xF0302014 = 0x0000000C; 	// cas_latency - 5
+#else
+	*(volatile unsigned long *)0xF0302014 = 0x0000000A; 	// cas_latency - 5
+#endif		
+			
+	*(volatile unsigned long *)0xF030201c = 0x00000003; 		// tMRD
+
+	ldiv = 10000/(lpll1/lmem_div);
+
+	lcycle = 450/ldiv;
+	*(volatile unsigned long *)0xF0302020 = lcycle+1; 			// tRAS - 45ns
+	lcycle = 600/ldiv;
+	*(volatile unsigned long *)0xF0302024 = lcycle+1; 			// tRC	- 60ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302028 = (((lcycle+1-3)<<8) | (lcycle+1)); // tRCD - 15ns
+	lcycle = 1050/ldiv;
+	*(volatile unsigned long *)0xF030202c = (((lcycle+1-3)<<8) | (lcycle+1)); // tRFC - 105ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302030 = (((lcycle+1-3)<<8) | (lcycle+1)); // tRP	- 15ns
+	lcycle = 100/ldiv;
+	*(volatile unsigned long *)0xF0302034 = lcycle+1; 			// tRRD - 10ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302038 = lcycle+1; 			// tWR - 15ns
+	lcycle = 75/ldiv;
+	*(volatile unsigned long *)0xF030203c = lcycle+1; 			// tWTR - 7.5ns
+	*(volatile unsigned long *)0xF0302040 = 0x00000003; 		// tXP - min 2tCK
+
+	*(volatile unsigned long *)0xF0302044 = 0x00000022; 	// tXSR
+	*(volatile unsigned long *)0xF0302048 = 0x000000FA; 	// tESR
+	*(volatile unsigned long *)0xF0302054 = 0x00001619; 	// tFAW
+
+	*(volatile unsigned long *)0xF0302200 = 0x000040f0; 		//256MB  config_chip0
+ //	*(volatile unsigned long *)0xF0302200 = 0x000040f8; 		//128MB config_chip0  //soc1-3
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000001; 		// PL341_SLEEP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 3);	// Wait until SLEEP
+
+	*(volatile unsigned long *)0xF030302C |= 0x00004000; 		// SSTL SDRAM IO Control Register 
+	
+	*(volatile unsigned long *)0xF0303020 = 0x00010103; 		// emccfg_config0
+	*(volatile unsigned long *)0xF0303024 = 0x00000000; 		// SDRAM PHY Control Register 
+	*(volatile unsigned long *)0xF0304400 = 0x00000000; 		// DDR2PHY_PHYMODE
+	*(volatile unsigned long *)0xF0304404 = 0x00000001; 		// DLLCTRL
+	
+	*(volatile unsigned long *)0xF0304408 = 0x00001717; 	// DLLPDCFG
+		
+	*(volatile unsigned long *)0xF0304404 = 0x00000003; 		// DLLCTRL
+	while (((*(volatile unsigned long *)0xF0304404) & (0x00000018)) != (0x00000018)); // Wait DLL Lock
+
+	*(volatile unsigned long *)0xF0304424 = 0x00000035; 		// DLLFORCELOCK
+	*(volatile unsigned long *)0xF030440C = 0x00000006; 		// GATECTRL
+	#if defined(DRAM_CAS6)
+		*(volatile unsigned long *) 0xF0304430=0x00000006; // RDDELAY - SOC
+	#else
+		*(volatile unsigned long *) 0xF0304430=0x00000005; // RDDELAY - SOC
+	#endif
+	
+	
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+	
+	while (!((*(volatile unsigned long *)0xF030442c) & (1)));	// Wait until Calibration completion without error
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000002; 		// PL34X_WAKEUP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 0);	// Wait until CONFIGURE
+
+	*(volatile unsigned long *)0xF0302008 = 0x000c0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000a0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000b0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090000; 		// Direct COmmnad Register	  
+	
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080962; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080952; 	// Direct COmmnad Register 
+#endif
+		
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+
+	i = 100;
+	while(i)
+	{
+		*(volatile unsigned long *) 0xF0302008=0x00040000; // dir_cmd
+		i--;
+	}
+
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080862; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080852; 	// Direct COmmnad Register 
+#endif
+
+#if defined(DRAM_ODTOFF)
+
+#else
+	*(volatile unsigned long *)0xF0302008 = 0x00090380; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090004; 		// Direct COmmnad Register //soc1-3
+#endif
+
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000000; 		// PL341_GO
+}
+
+//230Mhz
+void init_clockchange230Mhz(void)
+{
+	unsigned int lpll1	=460;
+	unsigned int lmem_source =1; // 0 : PLL0 , 1 : PLL1 
+	unsigned int lmem_div	=2; // Fmbus 130Mhz
+	
+	volatile unsigned int i = 0;	
+	unsigned int ldiv = 0;
+	unsigned int lcycle = 0;
+
+//Enter Mode		
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xF0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xF0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xF030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+		
+	*(volatile unsigned long *)0xF0400030 = 0x01010101;
+	*(volatile unsigned long *)0xF0400034 = 0x01010101;
+	
+	*(volatile unsigned long *)0xF0400008 = 0x00200014; 		// XI - memebus
+	
+	//PLL1
+	*(volatile unsigned long *)0xF0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xF0400024= 0x00007303;		// pms - pllout_320M
+	*(volatile unsigned long *)0xF0400024= 0x80007303;		//	pll pwr on
+
+	*(volatile unsigned long *)0xF0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+//Init DDR2 
+	*(volatile unsigned long *) 0xF0302004=0x00000003;			// PL341_PAUSE
+	*(volatile unsigned long *) 0xF0302004=0x00000004;			// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+// memory arb.
+	*(volatile unsigned long *)0xF030200C |= 0x00140000; 
+// memory arb. end
+	
+	*(volatile unsigned long *)0xF030200C = 0x00150012; 		// config0 cas 10bit, ras 13bit
+	*(volatile unsigned long *)0xF0302010 = 0x00000445; 	// refresh 
+	
+#if defined(DRAM_BANK3)
+	*(volatile unsigned long *) 0xF030204c=0x00000571; // config2 - SOC
+#else
+	*(volatile unsigned long *) 0xF030204c=0x00000541; // config2 - SOC
+#endif		
+	
+#if defined(DRAM_CAS6)
+	*(volatile unsigned long *)0xF0302014 = 0x0000000C; 	// cas_latency - 5
+#else
+	*(volatile unsigned long *)0xF0302014 = 0x0000000A; 	// cas_latency - 5
+#endif		
+			
+	*(volatile unsigned long *)0xF030201c = 0x00000003; 		// tMRD
+
+	ldiv = 10000/(lpll1/lmem_div);
+
+	lcycle = 450/ldiv;
+	*(volatile unsigned long *)0xF0302020 = lcycle+1; 			// tRAS - 45ns
+	lcycle = 600/ldiv;
+	*(volatile unsigned long *)0xF0302024 = lcycle+1; 			// tRC	- 60ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302028 = (((lcycle+1-3)<<8) | (lcycle+1)); // tRCD - 15ns
+	lcycle = 1050/ldiv;
+	*(volatile unsigned long *)0xF030202c = (((lcycle+1-3)<<8) | (lcycle+1)); // tRFC - 105ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302030 = (((lcycle+1-3)<<8) | (lcycle+1)); // tRP	- 15ns
+	lcycle = 100/ldiv;
+	*(volatile unsigned long *)0xF0302034 = lcycle+1; 			// tRRD - 10ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302038 = lcycle+1; 			// tWR - 15ns
+	lcycle = 75/ldiv;
+	*(volatile unsigned long *)0xF030203c = lcycle+1; 			// tWTR - 7.5ns
+	*(volatile unsigned long *)0xF0302040 = 0x00000003; 		// tXP - min 2tCK
+
+	*(volatile unsigned long *)0xF0302044 = 0x00000022; 	// tXSR
+	*(volatile unsigned long *)0xF0302048 = 0x000000FA; 	// tESR
+	*(volatile unsigned long *)0xF0302054 = 0x00001619; 	// tFAW
+
+	*(volatile unsigned long *)0xF0302200 = 0x000040f0; 		//256MB  config_chip0
+ //	*(volatile unsigned long *)0xF0302200 = 0x000040f8; 		//128MB config_chip0  //soc1-3
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000001; 		// PL341_SLEEP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 3);	// Wait until SLEEP
+
+	*(volatile unsigned long *)0xF030302C |= 0x00004000; 		// SSTL SDRAM IO Control Register 
+	
+	*(volatile unsigned long *)0xF0303020 = 0x00010103; 		// emccfg_config0
+	*(volatile unsigned long *)0xF0303024 = 0x00000000; 		// SDRAM PHY Control Register 
+	*(volatile unsigned long *)0xF0304400 = 0x00000000; 		// DDR2PHY_PHYMODE
+	*(volatile unsigned long *)0xF0304404 = 0x00000001; 		// DLLCTRL
+	
+	*(volatile unsigned long *)0xF0304408 = 0x00001717; 	// DLLPDCFG
+		
+	*(volatile unsigned long *)0xF0304404 = 0x00000003; 		// DLLCTRL
+	while (((*(volatile unsigned long *)0xF0304404) & (0x00000018)) != (0x00000018)); // Wait DLL Lock
+
+	*(volatile unsigned long *)0xF0304424 = 0x00000035; 		// DLLFORCELOCK
+	*(volatile unsigned long *)0xF030440C = 0x00000006; 		// GATECTRL
+	#if defined(DRAM_CAS6)
+		*(volatile unsigned long *) 0xF0304430=0x00000006; // RDDELAY - SOC
+	#else
+		*(volatile unsigned long *) 0xF0304430=0x00000005; // RDDELAY - SOC
+	#endif
+	
+	
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+	
+	while (!((*(volatile unsigned long *)0xF030442c) & (1)));	// Wait until Calibration completion without error
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000002; 		// PL34X_WAKEUP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 0);	// Wait until CONFIGURE
+
+	*(volatile unsigned long *)0xF0302008 = 0x000c0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000a0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000b0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090000; 		// Direct COmmnad Register	  
+	
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080962; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080952; 	// Direct COmmnad Register 
+#endif
+		
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+
+	i = 100;
+	while(i)
+	{
+		*(volatile unsigned long *) 0xF0302008=0x00040000; // dir_cmd
+		i--;
+	}
+
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080862; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080852; 	// Direct COmmnad Register 
+#endif
+
+#if defined(DRAM_ODTOFF)
+
+#else
+	*(volatile unsigned long *)0xF0302008 = 0x00090380; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090004; 		// Direct COmmnad Register //soc1-3
+#endif
+
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000000; 		// PL341_GO
+}
+
+//240Mhz
+void init_clockchange240Mhz(void)
+{
+	unsigned int lpll1	=480;
+	unsigned int lmem_source =1; // 0 : PLL0 , 1 : PLL1 
+	unsigned int lmem_div	=2; // Fmbus 
+	
+	volatile unsigned int i = 0;	
+	unsigned int ldiv = 0;
+	unsigned int lcycle = 0;
+
+//Enter Mode		
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xF0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xF0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xF030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+		
+	*(volatile unsigned long *)0xF0400030 = 0x01010101;
+	*(volatile unsigned long *)0xF0400034 = 0x01010101;
+	
+	*(volatile unsigned long *)0xF0400008 = 0x00200014; 		// XI - memebus
+	
+	//PLL1
+	*(volatile unsigned long *)0xF0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xF0400024= 0x00002801;		// pms - pllout_480M
+	*(volatile unsigned long *)0xF0400024= 0x80002801;		//	pll pwr on
+
+	*(volatile unsigned long *)0xF0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+//Init DDR2 
+	*(volatile unsigned long *) 0xF0302004=0x00000003;			// PL341_PAUSE
+	*(volatile unsigned long *) 0xF0302004=0x00000004;			// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+// memory arb.
+	*(volatile unsigned long *)0xF030200C |= 0x00140000; 
+// memory arb. end
+	
+	*(volatile unsigned long *)0xF030200C = 0x00150012; 		// config0 cas 10bit, ras 13bit
+	*(volatile unsigned long *)0xF0302010 = 0x00000445; 	// refresh 
+	
+#if defined(DRAM_BANK3)
+	*(volatile unsigned long *) 0xF030204c=0x00000571; // config2 - SOC
+#else
+	*(volatile unsigned long *) 0xF030204c=0x00000541; // config2 - SOC
+#endif		
+	
+#if defined(DRAM_CAS6)
+	*(volatile unsigned long *)0xF0302014 = 0x0000000C; 	// cas_latency - 5
+#else
+	*(volatile unsigned long *)0xF0302014 = 0x0000000A; 	// cas_latency - 5
+#endif		
+			
+	*(volatile unsigned long *)0xF030201c = 0x00000003; 		// tMRD
+
+	ldiv = 10000/(lpll1/lmem_div);
+
+	lcycle = 450/ldiv;
+	*(volatile unsigned long *)0xF0302020 = lcycle+1; 			// tRAS - 45ns
+	lcycle = 600/ldiv;
+	*(volatile unsigned long *)0xF0302024 = lcycle+1; 			// tRC	- 60ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302028 = (((lcycle+1-3)<<8) | (lcycle+1)); // tRCD - 15ns
+	lcycle = 1050/ldiv;
+	*(volatile unsigned long *)0xF030202c = (((lcycle+1-3)<<8) | (lcycle+1)); // tRFC - 105ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302030 = (((lcycle+1-3)<<8) | (lcycle+1)); // tRP	- 15ns
+	lcycle = 100/ldiv;
+	*(volatile unsigned long *)0xF0302034 = lcycle+1; 			// tRRD - 10ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302038 = lcycle+1; 			// tWR - 15ns
+	lcycle = 75/ldiv;
+	*(volatile unsigned long *)0xF030203c = lcycle+1; 			// tWTR - 7.5ns
+	*(volatile unsigned long *)0xF0302040 = 0x00000003; 		// tXP - min 2tCK
+
+	*(volatile unsigned long *)0xF0302044 = 0x00000022; 	// tXSR
+	*(volatile unsigned long *)0xF0302048 = 0x000000FA; 	// tESR
+	*(volatile unsigned long *)0xF0302054 = 0x00001619; 	// tFAW
+
+	*(volatile unsigned long *)0xF0302200 = 0x000040f0; 		//256MB  config_chip0
+ //	*(volatile unsigned long *)0xF0302200 = 0x000040f8; 		//128MB config_chip0  //soc1-3
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000001; 		// PL341_SLEEP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 3);	// Wait until SLEEP
+
+	*(volatile unsigned long *)0xF030302C |= 0x00004000; 		// SSTL SDRAM IO Control Register 
+	
+	*(volatile unsigned long *)0xF0303020 = 0x00010103; 		// emccfg_config0
+	*(volatile unsigned long *)0xF0303024 = 0x00000000; 		// SDRAM PHY Control Register 
+	*(volatile unsigned long *)0xF0304400 = 0x00000000; 		// DDR2PHY_PHYMODE
+	*(volatile unsigned long *)0xF0304404 = 0x00000001; 		// DLLCTRL
+	
+	*(volatile unsigned long *)0xF0304408 = 0x00001717; 	// DLLPDCFG
+		
+	*(volatile unsigned long *)0xF0304404 = 0x00000003; 		// DLLCTRL
+	while (((*(volatile unsigned long *)0xF0304404) & (0x00000018)) != (0x00000018)); // Wait DLL Lock
+
+	*(volatile unsigned long *)0xF0304424 = 0x00000035; 		// DLLFORCELOCK
+	*(volatile unsigned long *)0xF030440C = 0x00000006; 		// GATECTRL
+	#if defined(DRAM_CAS6)
+		*(volatile unsigned long *) 0xF0304430=0x00000006; // RDDELAY - SOC
+	#else
+		*(volatile unsigned long *) 0xF0304430=0x00000005; // RDDELAY - SOC
+	#endif
+	
+	
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+	
+	while (!((*(volatile unsigned long *)0xF030442c) & (1)));	// Wait until Calibration completion without error
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+	
+	*(volatile unsigned long *)0xF0302004 = 0x00000002; 		// PL34X_WAKEUP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 0);	// Wait until CONFIGURE
+
+	*(volatile unsigned long *)0xF0302008 = 0x000c0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000a0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000b0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090000; 		// Direct COmmnad Register	  
+	
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080962; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080952; 	// Direct COmmnad Register 
+#endif
+		
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+
+	i = 100;
+	while(i)
+	{
+		*(volatile unsigned long *) 0xF0302008=0x00040000; // dir_cmd
+		i--;
+	}
+
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080862; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080852; 	// Direct COmmnad Register 
+#endif
+
+#if defined(DRAM_ODTOFF)
+
+#else
+	*(volatile unsigned long *)0xF0302008 = 0x00090380; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090004; 		// Direct COmmnad Register //soc1-3
+#endif
+
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000000; 		// PL341_GO
+}
+
+//250Mhz
+void init_clockchange250Mhz(void)
+{
+	unsigned int lpll1	=500;
+	unsigned int lmem_source =1; // 0 : PLL0 , 1 : PLL1 
+	unsigned int lmem_div	=2; // Fmbus 130Mhz
+	
+	volatile unsigned int i = 0;	
+	unsigned int ldiv = 0;
+	unsigned int lcycle = 0;
+
+//Enter Mode		
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xF0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xF0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xF030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+		
+	*(volatile unsigned long *)0xF0400030 = 0x01010101;
+	*(volatile unsigned long *)0xF0400034 = 0x01010101;
+	
+	*(volatile unsigned long *)0xF0400008 = 0x00200014; 		// XI - memebus
+	
+	//PLL1
+	*(volatile unsigned long *)0xF0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xF0400024= 0x00007D03;		// pms - pllout_320M
+	*(volatile unsigned long *)0xF0400024= 0x80007D03;		//	pll pwr on
+
+	*(volatile unsigned long *)0xF0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+//Init DDR2 
+	*(volatile unsigned long *) 0xF0302004=0x00000003;			// PL341_PAUSE
+	*(volatile unsigned long *) 0xF0302004=0x00000004;			// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+// memory arb.
+	*(volatile unsigned long *)0xF030200C |= 0x00140000; 
+// memory arb. end
+	
+	*(volatile unsigned long *)0xF030200C = 0x00150012; 		// config0 cas 10bit, ras 13bit
+	*(volatile unsigned long *)0xF0302010 = 0x00000445; 	// refresh 
+	
+#if defined(DRAM_BANK3)
+	*(volatile unsigned long *) 0xF030204c=0x00000571; // config2 - SOC
+#else
+	*(volatile unsigned long *) 0xF030204c=0x00000541; // config2 - SOC
+#endif		
+	
+#if defined(DRAM_CAS6)
+	*(volatile unsigned long *)0xF0302014 = 0x0000000C; 	// cas_latency - 5
+#else
+	*(volatile unsigned long *)0xF0302014 = 0x0000000A; 	// cas_latency - 5
+#endif		
+			
+	*(volatile unsigned long *)0xF030201c = 0x00000003; 		// tMRD
+
+	ldiv = 10000/(lpll1/lmem_div);
+
+	lcycle = 450/ldiv;
+	*(volatile unsigned long *)0xF0302020 = lcycle+1; 			// tRAS - 45ns
+	lcycle = 600/ldiv;
+	*(volatile unsigned long *)0xF0302024 = lcycle+1; 			// tRC	- 60ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302028 = (((lcycle+1-3)<<8) | (lcycle+1)); // tRCD - 15ns
+	lcycle = 1050/ldiv;
+	*(volatile unsigned long *)0xF030202c = (((lcycle+1-3)<<8) | (lcycle+1)); // tRFC - 105ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302030 = (((lcycle+1-3)<<8) | (lcycle+1)); // tRP	- 15ns
+	lcycle = 100/ldiv;
+	*(volatile unsigned long *)0xF0302034 = lcycle+1; 			// tRRD - 10ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302038 = lcycle+1; 			// tWR - 15ns
+	lcycle = 75/ldiv;
+	*(volatile unsigned long *)0xF030203c = lcycle+1; 			// tWTR - 7.5ns
+	*(volatile unsigned long *)0xF0302040 = 0x00000003; 		// tXP - min 2tCK
+
+	*(volatile unsigned long *)0xF0302044 = 0x00000022; 	// tXSR
+	*(volatile unsigned long *)0xF0302048 = 0x000000FA; 	// tESR
+	*(volatile unsigned long *)0xF0302054 = 0x00001619; 	// tFAW
+
+	*(volatile unsigned long *)0xF0302200 = 0x000040f0; 		//256MB  config_chip0
+ //	*(volatile unsigned long *)0xF0302200 = 0x000040f8; 		//128MB config_chip0  //soc1-3
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000001; 		// PL341_SLEEP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 3);	// Wait until SLEEP
+
+	*(volatile unsigned long *)0xF030302C |= 0x00004000; 		// SSTL SDRAM IO Control Register 
+	
+	*(volatile unsigned long *)0xF0303020 = 0x00010103; 		// emccfg_config0
+	*(volatile unsigned long *)0xF0303024 = 0x00000000; 		// SDRAM PHY Control Register 
+	*(volatile unsigned long *)0xF0304400 = 0x00000000; 		// DDR2PHY_PHYMODE
+	*(volatile unsigned long *)0xF0304404 = 0x00000001; 		// DLLCTRL
+	
+	*(volatile unsigned long *)0xF0304408 = 0x00001717; 	// DLLPDCFG
+		
+	*(volatile unsigned long *)0xF0304404 = 0x00000003; 		// DLLCTRL
+	while (((*(volatile unsigned long *)0xF0304404) & (0x00000018)) != (0x00000018)); // Wait DLL Lock
+
+	*(volatile unsigned long *)0xF0304424 = 0x00000035; 		// DLLFORCELOCK
+	*(volatile unsigned long *)0xF030440C = 0x00000006; 		// GATECTRL
+	#if defined(DRAM_CAS6)
+		*(volatile unsigned long *) 0xF0304430=0x00000006; // RDDELAY - SOC
+	#else
+		*(volatile unsigned long *) 0xF0304430=0x00000005; // RDDELAY - SOC
+	#endif
+	
+	
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+	
+	while (!((*(volatile unsigned long *)0xF030442c) & (1)));	// Wait until Calibration completion without error
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000002; 		// PL34X_WAKEUP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 0);	// Wait until CONFIGURE
+
+	*(volatile unsigned long *)0xF0302008 = 0x000c0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000a0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000b0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090000; 		// Direct COmmnad Register	  
+	
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080962; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080952; 	// Direct COmmnad Register 
+#endif
+		
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+
+	i = 100;
+	while(i)
+	{
+		*(volatile unsigned long *) 0xF0302008=0x00040000; // dir_cmd
+		i--;
+	}
+
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080862; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080852; 	// Direct COmmnad Register 
+#endif
+
+#if defined(DRAM_ODTOFF)
+
+#else
+	*(volatile unsigned long *)0xF0302008 = 0x00090380; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090004; 		// Direct COmmnad Register //soc1-3
+#endif
+
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000000; 		// PL341_GO
+}
+
+//260Mhz
+void init_clockchange260Mhz(void)
+{
+	unsigned int lpll1	=520;
+	unsigned int lmem_source =1; // 0 : PLL0 , 1 : PLL1 
+	unsigned int lmem_div	=2; // Fmbus 
+	
+	volatile unsigned int i = 0;	
+	unsigned int ldiv = 0;
+	unsigned int lcycle = 0;
+
+//Enter Mode		
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xF0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xF0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xF030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+		
+	*(volatile unsigned long *)0xF0400030 = 0x01010101;
+	*(volatile unsigned long *)0xF0400034 = 0x01010101;
+	
+	*(volatile unsigned long *)0xF0400008 = 0x00200014; 		// XI - memebus
+	
+	//PLL1
+	*(volatile unsigned long *)0xF0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xF0400024= 0x00008203;		// pms - pllout_520M
+	*(volatile unsigned long *)0xF0400024= 0x80008203;		//	pll pwr on
+
+	*(volatile unsigned long *)0xF0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+//Init DDR2 
+	*(volatile unsigned long *) 0xF0302004=0x00000003;			// PL341_PAUSE
+	*(volatile unsigned long *) 0xF0302004=0x00000004;			// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+// memory arb.
+	*(volatile unsigned long *)0xF030200C |= 0x00140000; 
+// memory arb. end
+	
+	*(volatile unsigned long *)0xF030200C = 0x00150012; 		// config0 cas 10bit, ras 13bit
+	*(volatile unsigned long *)0xF0302010 = 0x00000445; 	// refresh 
+	
+#if defined(DRAM_BANK3)
+	*(volatile unsigned long *) 0xF030204c=0x00000571; // config2 - SOC
+#else
+	*(volatile unsigned long *) 0xF030204c=0x00000541; // config2 - SOC
+#endif		
+	
+#if defined(DRAM_CAS6)
+	*(volatile unsigned long *)0xF0302014 = 0x0000000C; 	// cas_latency - 5
+#else
+	*(volatile unsigned long *)0xF0302014 = 0x0000000A; 	// cas_latency - 5
+#endif		
+			
+	*(volatile unsigned long *)0xF030201c = 0x00000003; 		// tMRD
+
+	ldiv = 10000/(lpll1/lmem_div);
+
+	lcycle = 450/ldiv;
+	*(volatile unsigned long *)0xF0302020 = lcycle+1; 			// tRAS - 45ns
+	lcycle = 600/ldiv;
+	*(volatile unsigned long *)0xF0302024 = lcycle+1; 			// tRC	- 60ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302028 = (((lcycle+1-3)<<8) | (lcycle+1)); // tRCD - 15ns
+	lcycle = 1050/ldiv;
+	*(volatile unsigned long *)0xF030202c = (((lcycle+1-3)<<8) | (lcycle+1)); // tRFC - 105ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302030 = (((lcycle+1-3)<<8) | (lcycle+1)); // tRP	- 15ns
+	lcycle = 100/ldiv;
+	*(volatile unsigned long *)0xF0302034 = lcycle+1; 			// tRRD - 10ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302038 = lcycle+1; 			// tWR - 15ns
+	lcycle = 75/ldiv;
+	*(volatile unsigned long *)0xF030203c = lcycle+1; 			// tWTR - 7.5ns
+	*(volatile unsigned long *)0xF0302040 = 0x00000003; 		// tXP - min 2tCK
+
+	*(volatile unsigned long *)0xF0302044 = 0x00000022; 	// tXSR
+	*(volatile unsigned long *)0xF0302048 = 0x000000FA; 	// tESR
+	*(volatile unsigned long *)0xF0302054 = 0x00001619; 	// tFAW
+
+	*(volatile unsigned long *)0xF0302200 = 0x000040f0; 		//256MB  config_chip0
+ //	*(volatile unsigned long *)0xF0302200 = 0x000040f8; 		//128MB config_chip0  //soc1-3
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000001; 		// PL341_SLEEP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 3);	// Wait until SLEEP
+
+	*(volatile unsigned long *)0xF030302C |= 0x00004000; 		// SSTL SDRAM IO Control Register 
+	
+	*(volatile unsigned long *)0xF0303020 = 0x00010103; 		// emccfg_config0
+	*(volatile unsigned long *)0xF0303024 = 0x00000000; 		// SDRAM PHY Control Register 
+	*(volatile unsigned long *)0xF0304400 = 0x00000000; 		// DDR2PHY_PHYMODE
+	*(volatile unsigned long *)0xF0304404 = 0x00000001; 		// DLLCTRL
+	
+	*(volatile unsigned long *)0xF0304408 = 0x00001717; 	// DLLPDCFG
+		
+	*(volatile unsigned long *)0xF0304404 = 0x00000003; 		// DLLCTRL
+	while (((*(volatile unsigned long *)0xF0304404) & (0x00000018)) != (0x00000018)); // Wait DLL Lock
+
+	*(volatile unsigned long *)0xF0304424 = 0x00000035; 		// DLLFORCELOCK
+	*(volatile unsigned long *)0xF030440C = 0x00000006; 		// GATECTRL
+	#if defined(DRAM_CAS6)
+		*(volatile unsigned long *) 0xF0304430=0x00000006; // RDDELAY - SOC
+	#else
+		*(volatile unsigned long *) 0xF0304430=0x00000005; // RDDELAY - SOC
+	#endif
+	
+	
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+	
+	while (!((*(volatile unsigned long *)0xF030442c) & (1)));	// Wait until Calibration completion without error
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000002; 		// PL34X_WAKEUP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 0);	// Wait until CONFIGURE
+
+	*(volatile unsigned long *)0xF0302008 = 0x000c0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000a0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000b0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090000; 		// Direct COmmnad Register	  
+	
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080962; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080952; 	// Direct COmmnad Register 
+#endif
+		
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+
+	i = 100;
+	while(i)
+	{
+		*(volatile unsigned long *) 0xF0302008=0x00040000; // dir_cmd
+		i--;
+	}
+
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080862; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080852; 	// Direct COmmnad Register 
+#endif
+
+#if defined(DRAM_ODTOFF)
+
+#else
+	*(volatile unsigned long *)0xF0302008 = 0x00090380; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090004; 		// Direct COmmnad Register //soc1-3
+#endif
+
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000000; 		// PL341_GO
+}
+
+
+//270Mhz
+void init_clockchange270Mhz(void)
+{
+	unsigned int lpll1	=540;
+	unsigned int lmem_source =1; // 0 : PLL0 , 1 : PLL1 
+	unsigned int lmem_div	=2; // Fmbus 
+	
+	volatile unsigned int i = 0;	
+	unsigned int ldiv = 0;
+	unsigned int lcycle = 0;
+
+//Enter Mode		
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xF0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xF0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xF030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+		
+	*(volatile unsigned long *)0xF0400030 = 0x01010101;
+	*(volatile unsigned long *)0xF0400034 = 0x01010101;
+	
+	*(volatile unsigned long *)0xF0400008 = 0x00200014; 		// XI - memebus
+	
+	//PLL1
+	*(volatile unsigned long *)0xF0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xF0400024= 0x00002D01;		// pms - pllout_520M
+	*(volatile unsigned long *)0xF0400024= 0x80002D01;		//	pll pwr on
+
+	*(volatile unsigned long *)0xF0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+//Init DDR2 
+	*(volatile unsigned long *) 0xF0302004=0x00000003;			// PL341_PAUSE
+	*(volatile unsigned long *) 0xF0302004=0x00000004;			// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+// memory arb.
+	*(volatile unsigned long *)0xF030200C |= 0x00140000; 
+// memory arb. end
+	
+	*(volatile unsigned long *)0xF030200C = 0x00150012; 		// config0 cas 10bit, ras 13bit
+	*(volatile unsigned long *)0xF0302010 = 0x00000445; 	// refresh 
+	
+#if defined(DRAM_BANK3)
+	*(volatile unsigned long *) 0xF030204c=0x00000571; // config2 - SOC
+#else
+	*(volatile unsigned long *) 0xF030204c=0x00000541; // config2 - SOC
+#endif		
+	
+#if defined(DRAM_CAS6)
+	*(volatile unsigned long *)0xF0302014 = 0x0000000C; 	// cas_latency - 5
+#else
+	*(volatile unsigned long *)0xF0302014 = 0x0000000A; 	// cas_latency - 5
+#endif		
+			
+	*(volatile unsigned long *)0xF030201c = 0x00000003; 		// tMRD
+
+	ldiv = 10000/(lpll1/lmem_div);
+
+	lcycle = 450/ldiv;
+	*(volatile unsigned long *)0xF0302020 = lcycle+1; 			// tRAS - 45ns
+	lcycle = 600/ldiv;
+	*(volatile unsigned long *)0xF0302024 = lcycle+1; 			// tRC	- 60ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302028 = (((lcycle+1-3)<<8) | (lcycle+1)); // tRCD - 15ns
+	lcycle = 1050/ldiv;
+	*(volatile unsigned long *)0xF030202c = (((lcycle+1-3)<<8) | (lcycle+1)); // tRFC - 105ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302030 = (((lcycle+1-3)<<8) | (lcycle+1)); // tRP	- 15ns
+	lcycle = 100/ldiv;
+	*(volatile unsigned long *)0xF0302034 = lcycle+1; 			// tRRD - 10ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302038 = lcycle+1; 			// tWR - 15ns
+	lcycle = 75/ldiv;
+	*(volatile unsigned long *)0xF030203c = lcycle+1; 			// tWTR - 7.5ns
+	*(volatile unsigned long *)0xF0302040 = 0x00000003; 		// tXP - min 2tCK
+
+	*(volatile unsigned long *)0xF0302044 = 0x00000022; 	// tXSR
+	*(volatile unsigned long *)0xF0302048 = 0x000000FA; 	// tESR
+	*(volatile unsigned long *)0xF0302054 = 0x00001619; 	// tFAW
+
+	*(volatile unsigned long *)0xF0302200 = 0x000040f0; 		//256MB  config_chip0
+ //	*(volatile unsigned long *)0xF0302200 = 0x000040f8; 		//128MB config_chip0  //soc1-3
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000001; 		// PL341_SLEEP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 3);	// Wait until SLEEP
+
+	*(volatile unsigned long *)0xF030302C |= 0x00004000; 		// SSTL SDRAM IO Control Register 
+	
+	*(volatile unsigned long *)0xF0303020 = 0x00010103; 		// emccfg_config0
+	*(volatile unsigned long *)0xF0303024 = 0x00000000; 		// SDRAM PHY Control Register 
+	*(volatile unsigned long *)0xF0304400 = 0x00000000; 		// DDR2PHY_PHYMODE
+	*(volatile unsigned long *)0xF0304404 = 0x00000001; 		// DLLCTRL
+	
+	*(volatile unsigned long *)0xF0304408 = 0x00001717; 	// DLLPDCFG
+		
+	*(volatile unsigned long *)0xF0304404 = 0x00000003; 		// DLLCTRL
+	while (((*(volatile unsigned long *)0xF0304404) & (0x00000018)) != (0x00000018)); // Wait DLL Lock
+
+	*(volatile unsigned long *)0xF0304424 = 0x00000035; 		// DLLFORCELOCK
+	*(volatile unsigned long *)0xF030440C = 0x00000006; 		// GATECTRL
+	#if defined(DRAM_CAS6)
+		*(volatile unsigned long *) 0xF0304430=0x00000006; // RDDELAY - SOC
+	#else
+		*(volatile unsigned long *) 0xF0304430=0x00000005; // RDDELAY - SOC
+	#endif
+	
+	
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+	
+	while (!((*(volatile unsigned long *)0xF030442c) & (1)));	// Wait until Calibration completion without error
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000002; 		// PL34X_WAKEUP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 0);	// Wait until CONFIGURE
+
+	*(volatile unsigned long *)0xF0302008 = 0x000c0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000a0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000b0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090000; 		// Direct COmmnad Register	  
+	
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080962; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080952; 	// Direct COmmnad Register 
+#endif
+		
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+
+	i = 100;
+	while(i)
+	{
+		*(volatile unsigned long *) 0xF0302008=0x00040000; // dir_cmd
+		i--;
+	}
+
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080862; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080852; 	// Direct COmmnad Register 
+#endif
+
+#if defined(DRAM_ODTOFF)
+
+#else
+	*(volatile unsigned long *)0xF0302008 = 0x00090380; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090004; 		// Direct COmmnad Register //soc1-3
+#endif
+
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000000; 		// PL341_GO
+}
+
+
+//280Mhz
+void init_clockchange280Mhz(void)
+{
+	unsigned int lpll1	=560;
+	unsigned int lmem_source =1; // 0 : PLL0 , 1 : PLL1 
+	unsigned int lmem_div	=2; // Fmbus 
+	
+	volatile unsigned int i = 0;	
+	unsigned int ldiv = 0;
+	unsigned int lcycle = 0;
+
+//Enter Mode		
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xF0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xF0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xF030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+		
+	*(volatile unsigned long *)0xF0400030 = 0x01010101;
+	*(volatile unsigned long *)0xF0400034 = 0x01010101;
+	
+	*(volatile unsigned long *)0xF0400008 = 0x00200014; 		// XI - memebus
+	
+	//PLL1
+	*(volatile unsigned long *)0xF0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xF0400024= 0x00008C03;		// pms - pllout_560M
+	*(volatile unsigned long *)0xF0400024= 0x80008C03;		//	pll pwr on
+
+	*(volatile unsigned long *)0xF0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+//Init DDR2 
+	*(volatile unsigned long *) 0xF0302004=0x00000003;			// PL341_PAUSE
+	*(volatile unsigned long *) 0xF0302004=0x00000004;			// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+// memory arb.
+	*(volatile unsigned long *)0xF030200C |= 0x00140000; 
+// memory arb. end
+	
+	*(volatile unsigned long *)0xF030200C = 0x00150012; 		// config0 cas 10bit, ras 13bit
+	*(volatile unsigned long *)0xF0302010 = 0x00000445; 	// refresh 
+	
+#if defined(DRAM_BANK3)
+	*(volatile unsigned long *) 0xF030204c=0x00000571; // config2 - SOC
+#else
+	*(volatile unsigned long *) 0xF030204c=0x00000541; // config2 - SOC
+#endif		
+	
+#if defined(DRAM_CAS6)
+	*(volatile unsigned long *)0xF0302014 = 0x0000000C; 	// cas_latency - 5
+#else
+	*(volatile unsigned long *)0xF0302014 = 0x0000000A; 	// cas_latency - 5
+#endif		
+			
+	*(volatile unsigned long *)0xF030201c = 0x00000003; 		// tMRD
+
+	ldiv = 10000/(lpll1/lmem_div);
+
+	lcycle = 450/ldiv;
+	*(volatile unsigned long *)0xF0302020 = lcycle+1; 			// tRAS - 45ns
+	lcycle = 600/ldiv;
+	*(volatile unsigned long *)0xF0302024 = lcycle+1; 			// tRC	- 60ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302028 = (((lcycle+1-3)<<8) | (lcycle+1)); // tRCD - 15ns
+	lcycle = 1050/ldiv;
+	*(volatile unsigned long *)0xF030202c = (((lcycle+1-3)<<8) | (lcycle+1)); // tRFC - 105ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302030 = (((lcycle+1-3)<<8) | (lcycle+1)); // tRP	- 15ns
+	lcycle = 100/ldiv;
+	*(volatile unsigned long *)0xF0302034 = lcycle+1; 			// tRRD - 10ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302038 = lcycle+1; 			// tWR - 15ns
+	lcycle = 75/ldiv;
+	*(volatile unsigned long *)0xF030203c = lcycle+1; 			// tWTR - 7.5ns
+	*(volatile unsigned long *)0xF0302040 = 0x00000003; 		// tXP - min 2tCK
+
+	*(volatile unsigned long *)0xF0302044 = 0x00000022; 	// tXSR
+	*(volatile unsigned long *)0xF0302048 = 0x000000FA; 	// tESR
+	*(volatile unsigned long *)0xF0302054 = 0x00001619; 	// tFAW
+
+	*(volatile unsigned long *)0xF0302200 = 0x000040f0; 		//256MB  config_chip0
+ //	*(volatile unsigned long *)0xF0302200 = 0x000040f8; 		//128MB config_chip0  //soc1-3
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000001; 		// PL341_SLEEP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 3);	// Wait until SLEEP
+
+	*(volatile unsigned long *)0xF030302C |= 0x00004000; 		// SSTL SDRAM IO Control Register 
+	
+	*(volatile unsigned long *)0xF0303020 = 0x00010103; 		// emccfg_config0
+	*(volatile unsigned long *)0xF0303024 = 0x00000000; 		// SDRAM PHY Control Register 
+	*(volatile unsigned long *)0xF0304400 = 0x00000000; 		// DDR2PHY_PHYMODE
+	*(volatile unsigned long *)0xF0304404 = 0x00000001; 		// DLLCTRL
+	
+	*(volatile unsigned long *)0xF0304408 = 0x00001717; 	// DLLPDCFG
+		
+	*(volatile unsigned long *)0xF0304404 = 0x00000003; 		// DLLCTRL
+	while (((*(volatile unsigned long *)0xF0304404) & (0x00000018)) != (0x00000018)); // Wait DLL Lock
+
+	*(volatile unsigned long *)0xF0304424 = 0x00000035; 		// DLLFORCELOCK
+	*(volatile unsigned long *)0xF030440C = 0x00000006; 		// GATECTRL
+	#if defined(DRAM_CAS6)
+		*(volatile unsigned long *) 0xF0304430=0x00000006; // RDDELAY - SOC
+	#else
+		*(volatile unsigned long *) 0xF0304430=0x00000005; // RDDELAY - SOC
+	#endif
+	
+	
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+	
+	while (!((*(volatile unsigned long *)0xF030442c) & (1)));	// Wait until Calibration completion without error
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000002; 		// PL34X_WAKEUP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 0);	// Wait until CONFIGURE
+
+	*(volatile unsigned long *)0xF0302008 = 0x000c0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000a0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000b0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090000; 		// Direct COmmnad Register	  
+	
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080962; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080952; 	// Direct COmmnad Register 
+#endif
+		
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+
+	i = 100;
+	while(i)
+	{
+		*(volatile unsigned long *) 0xF0302008=0x00040000; // dir_cmd
+		i--;
+	}
+
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080862; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080852; 	// Direct COmmnad Register 
+#endif
+
+#if defined(DRAM_ODTOFF)
+
+#else
+	*(volatile unsigned long *)0xF0302008 = 0x00090380; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090004; 		// Direct COmmnad Register //soc1-3
+#endif
+
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000000; 		// PL341_GO
+}
+
+
+
+//290Mhz
+void init_clockchange290Mhz(void)
+{
+	unsigned int lpll1	=580;
+	unsigned int lmem_source =1; // 0 : PLL0 , 1 : PLL1 
+	unsigned int lmem_div	=2; // Fmbus 
+	
+	volatile unsigned int i = 0;	
+	unsigned int ldiv = 0;
+	unsigned int lcycle = 0;
+
+//Enter Mode		
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xF0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xF0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xF030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+		
+	*(volatile unsigned long *)0xF0400030 = 0x01010101;
+	*(volatile unsigned long *)0xF0400034 = 0x01010101;
+	
+	*(volatile unsigned long *)0xF0400008 = 0x00200014; 		// XI - memebus
+	
+	//PLL1
+	*(volatile unsigned long *)0xF0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xF0400024= 0x00009103;		// pms - pllout_580M
+	*(volatile unsigned long *)0xF0400024= 0x80009103;		//	pll pwr on
+
+	*(volatile unsigned long *)0xF0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+//Init DDR2 
+	*(volatile unsigned long *) 0xF0302004=0x00000003;			// PL341_PAUSE
+	*(volatile unsigned long *) 0xF0302004=0x00000004;			// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+// memory arb.
+	*(volatile unsigned long *)0xF030200C |= 0x00140000; 
+// memory arb. end
+	
+	*(volatile unsigned long *)0xF030200C = 0x00150012; 		// config0 cas 10bit, ras 13bit
+	*(volatile unsigned long *)0xF0302010 = 0x00000445; 	// refresh 
+	
+#if defined(DRAM_BANK3)
+	*(volatile unsigned long *) 0xF030204c=0x00000571; // config2 - SOC
+#else
+	*(volatile unsigned long *) 0xF030204c=0x00000541; // config2 - SOC
+#endif		
+	
+#if defined(DRAM_CAS6)
+	*(volatile unsigned long *)0xF0302014 = 0x0000000C; 	// cas_latency - 5
+#else
+	*(volatile unsigned long *)0xF0302014 = 0x0000000A; 	// cas_latency - 5
+#endif		
+			
+	*(volatile unsigned long *)0xF030201c = 0x00000003; 		// tMRD
+
+	ldiv = 10000/(lpll1/lmem_div);
+
+	lcycle = 450/ldiv;
+	*(volatile unsigned long *)0xF0302020 = lcycle; 			// tRAS - 45ns
+	lcycle = 600/ldiv;
+	*(volatile unsigned long *)0xF0302024 = lcycle; 			// tRC	- 60ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302028 = ((lcycle-3)<<8 | lcycle); // tRCD - 15ns
+	lcycle = 1050/ldiv;
+	*(volatile unsigned long *)0xF030202c = ((lcycle-3)<<8 | lcycle); // tRFC - 105ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302030 = ((lcycle-3)<<8 | lcycle); // tRP	- 15ns
+	lcycle = 100/ldiv;
+	*(volatile unsigned long *)0xF0302034 = lcycle; 			// tRRD - 10ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302038 = lcycle; 			// tWR - 15ns
+	lcycle = 75/ldiv;
+	*(volatile unsigned long *)0xF030203c = lcycle; 			// tWTR - 7.5ns
+	*(volatile unsigned long *)0xF0302040 = 0x00000003; 		// tXP - min 2tCK
+
+	*(volatile unsigned long *)0xF0302044 = 0x00000022; 	// tXSR
+	*(volatile unsigned long *)0xF0302048 = 0x000000FA; 	// tESR
+	*(volatile unsigned long *)0xF0302054 = 0x00001619; 	// tFAW
+
+	*(volatile unsigned long *)0xF0302200 = 0x000040f0; 		//256MB  config_chip0
+ //	*(volatile unsigned long *)0xF0302200 = 0x000040f8; 		//128MB config_chip0  //soc1-3
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000001; 		// PL341_SLEEP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 3);	// Wait until SLEEP
+
+	*(volatile unsigned long *)0xF030302C |= 0x00004000; 		// SSTL SDRAM IO Control Register 
+	
+	*(volatile unsigned long *)0xF0303020 = 0x00010103; 		// emccfg_config0
+	*(volatile unsigned long *)0xF0303024 = 0x00000000; 		// SDRAM PHY Control Register 
+	*(volatile unsigned long *)0xF0304400 = 0x00000000; 		// DDR2PHY_PHYMODE
+	*(volatile unsigned long *)0xF0304404 = 0x00000001; 		// DLLCTRL
+	
+	*(volatile unsigned long *)0xF0304408 = 0x00001717; 	// DLLPDCFG
+		
+	*(volatile unsigned long *)0xF0304404 = 0x00000003; 		// DLLCTRL
+	while (((*(volatile unsigned long *)0xF0304404) & (0x00000018)) != (0x00000018)); // Wait DLL Lock
+
+	*(volatile unsigned long *)0xF0304424 = 0x00000035; 		// DLLFORCELOCK
+	*(volatile unsigned long *)0xF030440C = 0x00000006; 		// GATECTRL
+	#if defined(DRAM_CAS6)
+		*(volatile unsigned long *) 0xF0304430=0x00000006; // RDDELAY - SOC
+	#else
+		*(volatile unsigned long *) 0xF0304430=0x00000005; // RDDELAY - SOC
+	#endif
+	
+	
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+	
+	while (!((*(volatile unsigned long *)0xF030442c) & (1)));	// Wait until Calibration completion without error
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000002; 		// PL34X_WAKEUP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 0);	// Wait until CONFIGURE
+
+	*(volatile unsigned long *)0xF0302008 = 0x000c0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000a0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000b0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090000; 		// Direct COmmnad Register	  
+	
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080962; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080952; 	// Direct COmmnad Register 
+#endif
+		
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+
+	i = 100;
+	while(i)
+	{
+		*(volatile unsigned long *) 0xF0302008=0x00040000; // dir_cmd
+		i--;
+	}
+
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080862; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080852; 	// Direct COmmnad Register 
+#endif
+
+#if defined(DRAM_ODTOFF)
+
+#else
+	*(volatile unsigned long *)0xF0302008 = 0x00090380; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090004; 		// Direct COmmnad Register //soc1-3
+#endif
+
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000000; 		// PL341_GO
+}
+
+#endif
Index: linux-2.6.29/arch/arm/mach-tcc8900/tcc8900/tcc_ckcddr2_200to290.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/tcc8900/tcc_ckcddr2_200to290.h	2010-04-07 13:00:58.000000000 -0400
@@ -0,0 +1,24 @@
+#if defined(_LINUX_)
+    #include <bsp.h>
+    #include "../../../../../../bootloader/tcboot/include/ddr.h"
+#else
+    #include "windows.h"
+    
+    #include "bsp.h"
+    #include "tca_ckc.h"
+#endif
+
+
+#if !defined(DRAM_MDDR)
+
+extern void init_clockchange200Mhz(void);
+extern void init_clockchange210Mhz(void);
+extern void init_clockchange220Mhz(void);
+extern void init_clockchange230Mhz(void);
+extern void init_clockchange240Mhz(void);
+extern void init_clockchange250Mhz(void);
+extern void init_clockchange260Mhz(void);
+extern void init_clockchange270Mhz(void);
+extern void init_clockchange280Mhz(void);
+extern void init_clockchange290Mhz(void);
+#endif
Index: linux-2.6.29/arch/arm/mach-tcc8900/tcc8900/tcc_ckcddr2_300to330.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/tcc8900/tcc_ckcddr2_300to330.c	2010-04-07 12:59:47.000000000 -0400
@@ -0,0 +1,916 @@
+#include "tcc_ckcddr2_300to330.h"
+
+#if !defined(DRAM_MDDR)
+
+//300Mhz
+void init_clockchange300Mhz(void)
+{
+	unsigned int lpll1	=600;
+	unsigned int lmem_source =1; // 0 : PLL0 , 1 : PLL1 
+	unsigned int lmem_div	=2; // Fmbus 130Mhz
+	
+	volatile unsigned int i = 0;	
+	unsigned int ldiv = 0;
+	unsigned int lcycle = 0;
+
+//Enter Mode		
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xF0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xF0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xF030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+		
+
+	*(volatile unsigned long *)0xF0400030 = 0x01010101;
+	*(volatile unsigned long *)0xF0400034 = 0x01010101;
+	
+	*(volatile unsigned long *)0xF0400008 = 0x00200014; 		// XI - memebus
+	
+	//PLL1
+	*(volatile unsigned long *)0xF0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xF0400024= 0x00003201;		// pms - pllout_600M
+	*(volatile unsigned long *)0xF0400024= 0x80003201;		//	pll pwr on
+	*(volatile unsigned long *)0xF0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+//Init DDR2 
+	*(volatile unsigned long *) 0xF0302004=0x00000003;			// PL341_PAUSE
+	*(volatile unsigned long *) 0xF0302004=0x00000004;			// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+// memory arb.
+	*(volatile unsigned long *)0xF030200C |= 0x00140000; 
+// memory arb. end
+	
+	*(volatile unsigned long *)0xF030200C = 0x00150012; 		// config0 cas 10bit, ras 13bit
+	*(volatile unsigned long *)0xF0302010 = 0x00000445; 	// refresh 
+	
+#if defined(DRAM_BANK3)
+	*(volatile unsigned long *) 0xF030204c=0x00000571; // config2 - SOC
+#else
+	*(volatile unsigned long *) 0xF030204c=0x00000541; // config2 - SOC
+#endif		
+	
+#if defined(DRAM_CAS6)
+	*(volatile unsigned long *)0xF0302014 = 0x0000000C; 	// cas_latency - 5
+#else
+	*(volatile unsigned long *)0xF0302014 = 0x0000000A; 	// cas_latency - 5
+#endif		
+			
+	*(volatile unsigned long *)0xF030201c = 0x00000003; 		// tMRD
+
+	ldiv = 10000/(lpll1/lmem_div);
+
+	lcycle = 450/ldiv;
+	*(volatile unsigned long *)0xF0302020 = lcycle; 			// tRAS - 45ns
+	lcycle = 600/ldiv;
+	*(volatile unsigned long *)0xF0302024 = lcycle; 			// tRC	- 60ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302028 = ((lcycle-3)<<8 | lcycle); // tRCD - 15ns
+	lcycle = 1050/ldiv;
+	*(volatile unsigned long *)0xF030202c = ((lcycle-3)<<8 | lcycle); // tRFC - 105ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302030 = ((lcycle-3)<<8 | lcycle); // tRP	- 15ns
+	lcycle = 100/ldiv;
+	*(volatile unsigned long *)0xF0302034 = lcycle; 			// tRRD - 10ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302038 = lcycle; 			// tWR - 15ns
+	lcycle = 75/ldiv;
+	*(volatile unsigned long *)0xF030203c = lcycle; 			// tWTR - 7.5ns
+	*(volatile unsigned long *)0xF0302040 = 0x00000003; 		// tXP - min 2tCK
+
+	*(volatile unsigned long *)0xF0302044 = 0x00000022; 	// tXSR
+	*(volatile unsigned long *)0xF0302048 = 0x000000FA; 	// tESR
+	*(volatile unsigned long *)0xF0302054 = 0x00001619; 	// tFAW
+
+	*(volatile unsigned long *)0xF0302200 = 0x000040f0; 		//256MB  config_chip0
+ //	*(volatile unsigned long *)0xF0302200 = 0x000040f8; 		//128MB config_chip0  //soc1-3
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000001; 		// PL341_SLEEP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 3);	// Wait until SLEEP
+
+	*(volatile unsigned long *)0xF030302C |= 0x00004000; 		// SSTL SDRAM IO Control Register 
+	
+	*(volatile unsigned long *)0xF0303020 = 0x00010103; 		// emccfg_config0
+	*(volatile unsigned long *)0xF0303024 = 0x00000000; 		// SDRAM PHY Control Register 
+	*(volatile unsigned long *)0xF0304400 = 0x00000000; 		// DDR2PHY_PHYMODE
+	*(volatile unsigned long *)0xF0304404 = 0x00000001; 		// DLLCTRL
+	
+	*(volatile unsigned long *)0xF0304408 = 0x00001717; 	// DLLPDCFG
+		
+	*(volatile unsigned long *)0xF0304404 = 0x00000003; 		// DLLCTRL
+	while (((*(volatile unsigned long *)0xF0304404) & (0x00000018)) != (0x00000018)); // Wait DLL Lock
+
+	*(volatile unsigned long *)0xF0304424 = 0x00000035; 		// DLLFORCELOCK
+	*(volatile unsigned long *)0xF030440C = 0x00000006; 		// GATECTRL
+	#if defined(DRAM_CAS6)
+		*(volatile unsigned long *) 0xF0304430=0x00000006; // RDDELAY - SOC
+	#else
+		*(volatile unsigned long *) 0xF0304430=0x00000005; // RDDELAY - SOC
+	#endif
+	
+	
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+	
+	while (!((*(volatile unsigned long *)0xF030442c) & (1)));	// Wait until Calibration completion without error
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000002; 		// PL34X_WAKEUP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 0);	// Wait until CONFIGURE
+
+	*(volatile unsigned long *)0xF0302008 = 0x000c0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000a0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000b0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090000; 		// Direct COmmnad Register	  
+	
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080962; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080952; 	// Direct COmmnad Register 
+#endif
+		
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+
+	i = 100;
+	while(i)
+	{
+		*(volatile unsigned long *) 0xF0302008=0x00040000; // dir_cmd
+		i--;
+	}
+
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080862; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080852; 	// Direct COmmnad Register 
+#endif
+
+#if defined(DRAM_ODTOFF)
+
+#else
+	*(volatile unsigned long *)0xF0302008 = 0x00090380; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090004; 		// Direct COmmnad Register //soc1-3
+#endif
+
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000000; 		// PL341_GO
+}
+
+//312Mhz
+void init_clockchange312Mhz(void)
+{
+	unsigned int lpll1	=624;
+	unsigned int lmem_source =1; // 0 : PLL0 , 1 : PLL1 
+	unsigned int lmem_div	=2; // Fmbus 130Mhz
+	
+	volatile unsigned int i = 0;	
+	unsigned int ldiv = 0;
+	unsigned int lcycle = 0;
+
+//Enter Mode		
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xF0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xF0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xF030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+		
+	*(volatile unsigned long *)0xF0400030 = 0x01010101;
+	*(volatile unsigned long *)0xF0400034 = 0x01010101;
+	
+	*(volatile unsigned long *)0xF0400008 = 0x00200014; 		// XI - memebus
+	
+	//PLL1
+	*(volatile unsigned long *)0xF0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xF0400024= 0x00006802;		// pms - pllout_624M
+	*(volatile unsigned long *)0xF0400024= 0x80006802;		//	pll pwr on
+	*(volatile unsigned long *)0xF0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+//Init DDR2 
+	*(volatile unsigned long *) 0xF0302004=0x00000003;			// PL341_PAUSE
+	*(volatile unsigned long *) 0xF0302004=0x00000004;			// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+// memory arb.
+	*(volatile unsigned long *)0xF030200C |= 0x00140000; 
+// memory arb. end
+	
+	*(volatile unsigned long *)0xF030200C = 0x00150012; 		// config0 cas 10bit, ras 13bit
+	*(volatile unsigned long *)0xF0302010 = 0x00000445; 	// refresh 
+	
+#if defined(DRAM_BANK3)
+	*(volatile unsigned long *) 0xF030204c=0x00000571; // config2 - SOC
+#else
+	*(volatile unsigned long *) 0xF030204c=0x00000541; // config2 - SOC
+#endif		
+	
+#if defined(DRAM_CAS6)
+	*(volatile unsigned long *)0xF0302014 = 0x0000000C; 	// cas_latency - 5
+#else
+	*(volatile unsigned long *)0xF0302014 = 0x0000000A; 	// cas_latency - 5
+#endif		
+			
+	*(volatile unsigned long *)0xF030201c = 0x00000003; 		// tMRD
+
+	ldiv = 10000/(lpll1/lmem_div);
+
+	lcycle = 450/ldiv;
+	*(volatile unsigned long *)0xF0302020 = lcycle; 			// tRAS - 45ns
+	lcycle = 600/ldiv;
+	*(volatile unsigned long *)0xF0302024 = lcycle; 			// tRC	- 60ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302028 = ((lcycle-3)<<8 | lcycle); // tRCD - 15ns
+	lcycle = 1050/ldiv;
+	*(volatile unsigned long *)0xF030202c = ((lcycle-3)<<8 | lcycle); // tRFC - 105ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302030 = ((lcycle-3)<<8 | lcycle); // tRP	- 15ns
+	lcycle = 100/ldiv;
+	*(volatile unsigned long *)0xF0302034 = lcycle; 			// tRRD - 10ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302038 = lcycle; 			// tWR - 15ns
+	lcycle = 75/ldiv;
+	*(volatile unsigned long *)0xF030203c = lcycle; 			// tWTR - 7.5ns
+	*(volatile unsigned long *)0xF0302040 = 0x00000003; 		// tXP - min 2tCK
+
+	*(volatile unsigned long *)0xF0302044 = 0x00000022; 	// tXSR
+	*(volatile unsigned long *)0xF0302048 = 0x000000FA; 	// tESR
+	*(volatile unsigned long *)0xF0302054 = 0x00001619; 	// tFAW
+
+	*(volatile unsigned long *)0xF0302200 = 0x000040f0; 		//256MB  config_chip0
+ //	*(volatile unsigned long *)0xF0302200 = 0x000040f8; 		//128MB config_chip0  //soc1-3
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000001; 		// PL341_SLEEP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 3);	// Wait until SLEEP
+
+	*(volatile unsigned long *)0xF030302C |= 0x00004000; 		// SSTL SDRAM IO Control Register 
+	
+	*(volatile unsigned long *)0xF0303020 = 0x00010103; 		// emccfg_config0
+	*(volatile unsigned long *)0xF0303024 = 0x00000000; 		// SDRAM PHY Control Register 
+	*(volatile unsigned long *)0xF0304400 = 0x00000000; 		// DDR2PHY_PHYMODE
+	*(volatile unsigned long *)0xF0304404 = 0x00000001; 		// DLLCTRL
+	
+	*(volatile unsigned long *)0xF0304408 = 0x00001717; 	// DLLPDCFG
+		
+	*(volatile unsigned long *)0xF0304404 = 0x00000003; 		// DLLCTRL
+	while (((*(volatile unsigned long *)0xF0304404) & (0x00000018)) != (0x00000018)); // Wait DLL Lock
+
+	*(volatile unsigned long *)0xF0304424 = 0x00000035; 		// DLLFORCELOCK
+	*(volatile unsigned long *)0xF030440C = 0x00000006; 		// GATECTRL
+	#if defined(DRAM_CAS6)
+		*(volatile unsigned long *) 0xF0304430=0x00000006; // RDDELAY - SOC
+	#else
+		*(volatile unsigned long *) 0xF0304430=0x00000005; // RDDELAY - SOC
+	#endif
+	
+	
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+	
+	while (!((*(volatile unsigned long *)0xF030442c) & (1)));	// Wait until Calibration completion without error
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000002; 		// PL34X_WAKEUP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 0);	// Wait until CONFIGURE
+
+	*(volatile unsigned long *)0xF0302008 = 0x000c0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000a0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000b0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090000; 		// Direct COmmnad Register	  
+	
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080962; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080952; 	// Direct COmmnad Register 
+#endif
+		
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+
+	i = 100;
+	while(i)
+	{
+		*(volatile unsigned long *) 0xF0302008=0x00040000; // dir_cmd
+		i--;
+	}
+
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080862; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080852; 	// Direct COmmnad Register 
+#endif
+
+#if defined(DRAM_ODTOFF)
+
+#else
+	*(volatile unsigned long *)0xF0302008 = 0x00090380; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090004; 		// Direct COmmnad Register //soc1-3
+#endif
+
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000000; 		// PL341_GO
+}
+
+//320Mhz
+void init_clockchange320Mhz(void)
+{
+	unsigned int lpll1	=640;
+	unsigned int lmem_source =1; // 0 : PLL0 , 1 : PLL1 
+	unsigned int lmem_div	=2; // Fmbus 130Mhz
+	
+	volatile unsigned int i = 0;	
+	unsigned int ldiv = 0;
+	unsigned int lcycle = 0;
+
+//Enter Mode		
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xF0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xF0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xF030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+		
+
+	*(volatile unsigned long *)0xF0400030 = 0x01010101;
+	*(volatile unsigned long *)0xF0400034 = 0x01010101;
+	
+	*(volatile unsigned long *)0xF0400008 = 0x00200014; 		// XI - memebus
+	
+	//PLL1
+	*(volatile unsigned long *)0xF0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xF0400024= 0x0000A003;		// pms - pllout_640M
+	*(volatile unsigned long *)0xF0400024= 0x8000A003;		//	pll pwr on
+
+	*(volatile unsigned long *)0xF0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+//Init DDR2 
+	*(volatile unsigned long *) 0xF0302004=0x00000003;			// PL341_PAUSE
+	*(volatile unsigned long *) 0xF0302004=0x00000004;			// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+// memory arb.
+	*(volatile unsigned long *)0xF030200C |= 0x00140000; 
+// memory arb. end
+	
+	*(volatile unsigned long *)0xF030200C = 0x00150012; 		// config0 cas 10bit, ras 13bit
+	*(volatile unsigned long *)0xF0302010 = 0x00000445; 	// refresh 
+	
+#if defined(DRAM_BANK3)
+	*(volatile unsigned long *) 0xF030204c=0x00000571; // config2 - SOC
+#else
+	*(volatile unsigned long *) 0xF030204c=0x00000541; // config2 - SOC
+#endif		
+	
+#if defined(DRAM_CAS6)
+	*(volatile unsigned long *)0xF0302014 = 0x0000000C; 	// cas_latency - 5
+#else
+	*(volatile unsigned long *)0xF0302014 = 0x0000000A; 	// cas_latency - 5
+#endif		
+			
+	*(volatile unsigned long *)0xF030201c = 0x00000003; 		// tMRD
+
+	ldiv = 10000/(lpll1/lmem_div);
+
+	lcycle = 450/ldiv;
+	*(volatile unsigned long *)0xF0302020 = lcycle; 			// tRAS - 45ns
+	lcycle = 600/ldiv;
+	*(volatile unsigned long *)0xF0302024 = lcycle; 			// tRC	- 60ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302028 = ((lcycle-3)<<8 | lcycle); // tRCD - 15ns
+	lcycle = 1050/ldiv;
+	*(volatile unsigned long *)0xF030202c = ((lcycle-3)<<8 | lcycle); // tRFC - 105ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302030 = ((lcycle-3)<<8 | lcycle); // tRP	- 15ns
+	lcycle = 100/ldiv;
+	*(volatile unsigned long *)0xF0302034 = lcycle; 			// tRRD - 10ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302038 = lcycle; 			// tWR - 15ns
+	lcycle = 75/ldiv;
+	*(volatile unsigned long *)0xF030203c = lcycle; 			// tWTR - 7.5ns
+	*(volatile unsigned long *)0xF0302040 = 0x00000003; 		// tXP - min 2tCK
+
+	*(volatile unsigned long *)0xF0302044 = 0x00000022; 	// tXSR
+	*(volatile unsigned long *)0xF0302048 = 0x000000FA; 	// tESR
+	*(volatile unsigned long *)0xF0302054 = 0x00001619; 	// tFAW
+	*(volatile unsigned long *)0xF0302200 = 0x000040f0; 		//256MB  config_chip0
+ //	*(volatile unsigned long *)0xF0302200 = 0x000040f8; 		//128MB config_chip0  //soc1-3
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000001; 		// PL341_SLEEP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 3);	// Wait until SLEEP
+
+	*(volatile unsigned long *)0xF030302C |= 0x00004000; 		// SSTL SDRAM IO Control Register 
+	
+	*(volatile unsigned long *)0xF0303020 = 0x00010103; 		// emccfg_config0
+	*(volatile unsigned long *)0xF0303024 = 0x00000000; 		// SDRAM PHY Control Register 
+	*(volatile unsigned long *)0xF0304400 = 0x00000000; 		// DDR2PHY_PHYMODE
+	*(volatile unsigned long *)0xF0304404 = 0x00000001; 		// DLLCTRL
+	
+	*(volatile unsigned long *)0xF0304408 = 0x00001717; 	// DLLPDCFG
+		
+	*(volatile unsigned long *)0xF0304404 = 0x00000003; 		// DLLCTRL
+	while (((*(volatile unsigned long *)0xF0304404) & (0x00000018)) != (0x00000018)); // Wait DLL Lock
+
+	*(volatile unsigned long *)0xF0304424 = 0x00000035; 		// DLLFORCELOCK
+	*(volatile unsigned long *)0xF030440C = 0x00000006; 		// GATECTRL
+	#if defined(DRAM_CAS6)
+		*(volatile unsigned long *) 0xF0304430=0x00000006; // RDDELAY - SOC
+	#else
+		*(volatile unsigned long *) 0xF0304430=0x00000005; // RDDELAY - SOC
+	#endif
+	
+	
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+	
+	while (!((*(volatile unsigned long *)0xF030442c) & (1)));	// Wait until Calibration completion without error
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000002; 		// PL34X_WAKEUP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 0);	// Wait until CONFIGURE
+
+	*(volatile unsigned long *)0xF0302008 = 0x000c0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000a0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000b0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090000; 		// Direct COmmnad Register	  
+	
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080962; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080952; 	// Direct COmmnad Register 
+#endif
+		
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+
+	i = 100;
+	while(i)
+	{
+		*(volatile unsigned long *) 0xF0302008=0x00040000; // dir_cmd
+		i--;
+	}
+
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080862; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080852; 	// Direct COmmnad Register 
+#endif
+
+#if defined(DRAM_ODTOFF)
+
+#else
+	*(volatile unsigned long *)0xF0302008 = 0x00090380; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090004; 		// Direct COmmnad Register //soc1-3
+#endif
+
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000000; 		// PL341_GO
+}
+
+//330Mhz
+void init_clockchange330Mhz(void)
+{
+	unsigned int lpll1	=660;
+	unsigned int lmem_source =1; // 0 : PLL0 , 1 : PLL1 
+	unsigned int lmem_div	=2; // Fmbus 130Mhz
+	
+	volatile unsigned int i = 0;	
+	unsigned int ldiv = 0;
+	unsigned int lcycle = 0;
+
+//Enter Mode		
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xF0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xF0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xF030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+		
+	*(volatile unsigned long *)0xF0400030 = 0x01010101;
+	*(volatile unsigned long *)0xF0400034 = 0x01010101;
+	
+	*(volatile unsigned long *)0xF0400008 = 0x00200014; 		// XI - memebus
+	
+	//PLL1
+	*(volatile unsigned long *)0xF0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xF0400024= 0x00006E02;		// pms - pllout_660M
+	*(volatile unsigned long *)0xF0400024= 0x80006E02;		//	pll pwr on
+	*(volatile unsigned long *)0xF0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+//Init DDR2 
+	*(volatile unsigned long *) 0xF0302004=0x00000003;			// PL341_PAUSE
+	*(volatile unsigned long *) 0xF0302004=0x00000004;			// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+// memory arb.
+	*(volatile unsigned long *)0xF030200C |= 0x00140000; 
+// memory arb. end
+	
+	*(volatile unsigned long *)0xF030200C = 0x00150012; 		// config0 cas 10bit, ras 13bit
+	*(volatile unsigned long *)0xF0302010 = 0x00000507; 	// refresh 
+	
+#if defined(DRAM_BANK3)
+	*(volatile unsigned long *) 0xF030204c=0x00000571; // config2 - SOC
+#else
+	*(volatile unsigned long *) 0xF030204c=0x00000541; // config2 - SOC
+#endif		
+
+	
+#if defined(DRAM_CAS6)
+	*(volatile unsigned long *)0xF0302014 = 0x0000000C; 	// cas_latency - 5
+#else
+	*(volatile unsigned long *)0xF0302014 = 0x0000000A; 	// cas_latency - 5
+#endif		
+			
+	*(volatile unsigned long *)0xF030201c = 0x00000003; 		// tMRD
+
+	ldiv = 10000/(lpll1/lmem_div);
+
+	lcycle = 450/ldiv;
+	*(volatile unsigned long *)0xF0302020 = lcycle; 			// tRAS - 45ns
+	lcycle = 600/ldiv;
+	*(volatile unsigned long *)0xF0302024 = lcycle; 			// tRC	- 60ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302028 = ((lcycle-3)<<8 | lcycle); // tRCD - 15ns
+	lcycle = 1050/ldiv;
+	*(volatile unsigned long *)0xF030202c = ((lcycle-3)<<8 | lcycle); // tRFC - 105ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302030 = ((lcycle-3)<<8 | lcycle); // tRP	- 15ns
+	lcycle = 100/ldiv;
+	*(volatile unsigned long *)0xF0302034 = lcycle; 			// tRRD - 10ns
+	lcycle = 150/ldiv;
+	*(volatile unsigned long *)0xF0302038 = lcycle; 			// tWR - 15ns
+	lcycle = 75/ldiv;
+	*(volatile unsigned long *)0xF030203c = lcycle; 			// tWTR - 7.5ns
+	*(volatile unsigned long *)0xF0302040 = 0x00000003; 		// tXP - min 2tCK
+
+	*(volatile unsigned long *)0xF0302044 = 0x00000022; 	// tXSR
+	*(volatile unsigned long *)0xF0302048 = 0x000000FA; 	// tESR
+	*(volatile unsigned long *)0xF0302054 = 0x00001619; 	// tFAW
+
+	*(volatile unsigned long *)0xF0302200 = 0x000040f0; 		//256MB  config_chip0
+ //	*(volatile unsigned long *)0xF0302200 = 0x000040f8; 		//128MB config_chip0  //soc1-3
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000001; 		// PL341_SLEEP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 3);	// Wait until SLEEP
+
+	*(volatile unsigned long *)0xF030302C |= 0x00004000; 		// SSTL SDRAM IO Control Register 
+	
+	*(volatile unsigned long *)0xF0303020 = 0x00010103; 		// emccfg_config0
+	*(volatile unsigned long *)0xF0303024 = 0x00000000; 		// SDRAM PHY Control Register 
+	*(volatile unsigned long *)0xF0304400 = 0x00000000; 		// DDR2PHY_PHYMODE
+	*(volatile unsigned long *)0xF0304404 = 0x00000001; 		// DLLCTRL
+	
+	*(volatile unsigned long *)0xF0304408 = 0x00001717; 	// DLLPDCFG
+		
+	*(volatile unsigned long *)0xF0304404 = 0x00000003; 		// DLLCTRL
+	while (((*(volatile unsigned long *)0xF0304404) & (0x00000018)) != (0x00000018)); // Wait DLL Lock
+
+	*(volatile unsigned long *)0xF0304424 = 0x00000035; 		// DLLFORCELOCK
+	*(volatile unsigned long *)0xF030440C = 0x00000006; 		// GATECTRL
+	#if defined(DRAM_CAS6)
+		*(volatile unsigned long *) 0xF0304430=0x00000006; // RDDELAY - SOC
+	#else
+		*(volatile unsigned long *) 0xF0304430=0x00000005; // RDDELAY - SOC
+	#endif
+	
+	
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+	
+	while (!((*(volatile unsigned long *)0xF030442c) & (1)));	// Wait until Calibration completion without error
+	#if defined(DRAM_ODTOFF)
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#else
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (0 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	#endif
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000002; 		// PL34X_WAKEUP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 0);	// Wait until CONFIGURE
+
+	*(volatile unsigned long *)0xF0302008 = 0x000c0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000a0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000b0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090000; 		// Direct COmmnad Register	  
+	
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080962; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080952; 	// Direct COmmnad Register 
+#endif
+		
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+
+	i = 100;
+	while(i)
+	{
+		*(volatile unsigned long *) 0xF0302008=0x00040000; // dir_cmd
+		i--;
+	}
+
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *)0xF0302008 = 0x00080862; 	// Direct COmmnad Register 
+#else
+		*(volatile unsigned long *)0xF0302008 = 0x00080852; 	// Direct COmmnad Register 
+#endif
+
+#if defined(DRAM_ODTOFF)
+
+#else
+	*(volatile unsigned long *)0xF0302008 = 0x00090380; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090004; 		// Direct COmmnad Register //soc1-3
+#endif
+
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000000; 		// PL341_GO
+}
+
+#endif
Index: linux-2.6.29/arch/arm/mach-tcc8900/tcc8900/tcc_ckcddr2_300to330.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/tcc8900/tcc_ckcddr2_300to330.h	2010-04-07 13:00:58.000000000 -0400
@@ -0,0 +1,19 @@
+#if defined(_LINUX_)
+    #include <bsp.h>
+    #include "../../../../../../bootloader/tcboot/include/ddr.h"
+#else
+    #include "windows.h"
+    
+    #include "bsp.h"
+    #include "tca_ckc.h"
+#endif
+
+
+#if !defined(DRAM_MDDR)
+
+extern void init_clockchange300Mhz(void);
+extern void init_clockchange312Mhz(void);
+extern void init_clockchange320Mhz(void);
+extern void init_clockchange330Mhz(void);
+#endif
+
Index: linux-2.6.29/arch/arm/mach-tcc8900/tcc8900/tcc_ckcmddr_100to160.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/tcc8900/tcc_ckcmddr_100to160.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,1403 @@
+#include "tcc_ckcmddr_100to160.h"
+
+#if defined(DRAM_MDDR)
+
+//141Mhz
+void init_clockchange100Mhz(void)
+{
+	#define lchange_source 2
+	#define lchange_div 4
+	
+	#define lmem_source 1 // 0 : PLL0 , 1 : PLL1	
+	#define lmem_div	4
+
+	
+	*(volatile unsigned long *)0xB0301004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xB0301004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xB0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xB0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xB030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lchange_div-1) << 4)|lchange_source); // CKC-CLKCTRL2 - Mem
+
+	//PLL1
+	*(volatile unsigned long *)0xB0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xB0400024= 0x00006403;		// pms - pllout_400M
+	*(volatile unsigned long *)0xB0400024= 0x80006403;		//	pll pwr on
+	
+//Init DDR2 
+	*(volatile unsigned long *)0xB030100C = 0x00210012; 		// config0 cas 10bit, ras 13bit , AP bit 10, Burst 4, 2chips
+
+	*(volatile unsigned long *) 0xB0303000 |= 0x00800000;		// bit23 enable -synopt enable
+	*(volatile unsigned long *) 0xB0303010 |= 0x00800000;		// bit23 enable -synopt enable
+
+	*(volatile unsigned long *)0xB030104C= 0x000002D1;
+	*(volatile unsigned long *)0xB0301010 = 0x000003E8; // refresh_prd = 1000
+
+#if defined(DRAM_CAS3)
+	*(volatile unsigned long *)0xB0301014 = 0x00000006; // cas_latency = 3
+#else
+	*(volatile unsigned long *)0xB0301014 = 0x00000004; // cas_latency = 2
+#endif					
+
+	*(volatile unsigned long *)0xB030101C = 0x00000002; // tMRD 2tck 
+	*(volatile unsigned long *)0xB0301020 = 0x0000000A; // tRAS 42ns
+	*(volatile unsigned long *)0xB0301024 = 0x0000000F; // tRC 60ns
+	*(volatile unsigned long *)0xB0301028 = 0x00000014; // tRCD 18ns
+	*(volatile unsigned long *)0xB030102c = 0x00000E11; // tRFC 72ns
+	*(volatile unsigned long *)0xB0301030 = 0x00000014; // tRP 18ns
+	*(volatile unsigned long *)0xB0301034 = 0x00000001; // tRRD 12ns
+	*(volatile unsigned long *)0xB0301038 = 0x00000002; // tWR 15ns
+	*(volatile unsigned long *)0xB030103c = 0x00000001; // tWTR 1tck
+	*(volatile unsigned long *)0xB0301040 = 0x00000002; // tXP=3
+	*(volatile unsigned long *)0xB0301044 = 0x00000016; // tXSR 120ns
+	*(volatile unsigned long *)0xB0301048 = 0x00000032; // tESR=200
+
+	*(volatile unsigned long *)0xB0301200 = 0x000040F0; // Chip 0
+	
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	while (!((*(volatile unsigned long *)0xB030442c) & (1)));	// Wait until Calibration completion without error
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+
+	*(volatile unsigned long *)0xB0301008 = 0x00000032; //MRS
+	*(volatile unsigned long *)0xB0301008 = 0x000a0000;//EMRS
+	*(volatile unsigned long *)0xB0301008 = 0x00080032;
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+//Change MEM Source 
+
+
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+	
+	*(volatile unsigned long *) 0xB0301004=0x00000000; // PL341_GO
+	while (((*(volatile unsigned long *)0xB0301000) & (0x03)) != 1);	// Wait until READY
+
+}
+
+void init_clockchange105Mhz(void)
+{
+	#define lchange_source 2
+	#define lchange_div 4
+	
+	#define lmem_source 1 // 0 : PLL0 , 1 : PLL1	
+	#define lmem_div	4
+
+	
+	*(volatile unsigned long *)0xB0301004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xB0301004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xB0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xB0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xB030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lchange_div-1) << 4)|lchange_source); // CKC-CLKCTRL2 - Mem
+
+	//PLL1
+	*(volatile unsigned long *)0xB0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xB0400024= 0x00002301;		// pms - pllout_420M
+	*(volatile unsigned long *)0xB0400024= 0x80002301;		//	pll pwr on
+	
+//Init DDR2 
+	*(volatile unsigned long *)0xB030100C = 0x00210012; 		// config0 cas 10bit, ras 13bit , AP bit 10, Burst 4, 2chips
+
+	*(volatile unsigned long *) 0xB0303000 |= 0x00800000;		// bit23 enable -synopt enable
+	*(volatile unsigned long *) 0xB0303010 |= 0x00800000;		// bit23 enable -synopt enable
+
+	*(volatile unsigned long *)0xB030104C= 0x000002D1;
+	*(volatile unsigned long *)0xB0301010 = 0x000003E8; // refresh_prd = 1000
+
+#if defined(DRAM_CAS3)
+	*(volatile unsigned long *)0xB0301014 = 0x00000006; // cas_latency = 3
+#else
+	*(volatile unsigned long *)0xB0301014 = 0x00000004; // cas_latency = 2
+#endif					
+
+	*(volatile unsigned long *)0xB030101C = 0x00000002; // tMRD 2tck 
+	*(volatile unsigned long *)0xB0301020 = 0x0000000A; // tRAS 42ns
+	*(volatile unsigned long *)0xB0301024 = 0x0000000F; // tRC 60ns
+	*(volatile unsigned long *)0xB0301028 = 0x00000014; // tRCD 18ns
+	*(volatile unsigned long *)0xB030102c = 0x00000E11; // tRFC 72ns
+	*(volatile unsigned long *)0xB0301030 = 0x00000014; // tRP 18ns
+	*(volatile unsigned long *)0xB0301034 = 0x00000001; // tRRD 12ns
+	*(volatile unsigned long *)0xB0301038 = 0x00000002; // tWR 15ns
+	*(volatile unsigned long *)0xB030103c = 0x00000001; // tWTR 1tck
+	*(volatile unsigned long *)0xB0301040 = 0x00000002; // tXP=3
+	*(volatile unsigned long *)0xB0301044 = 0x00000016; // tXSR 120ns
+	*(volatile unsigned long *)0xB0301048 = 0x00000032; // tESR=200
+
+	*(volatile unsigned long *)0xB0301200 = 0x000040F0; // Chip 0
+	
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	while (!((*(volatile unsigned long *)0xB030442c) & (1)));	// Wait until Calibration completion without error
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+
+	*(volatile unsigned long *)0xB0301008 = 0x00000032; //MRS
+	*(volatile unsigned long *)0xB0301008 = 0x000a0000;//EMRS
+	*(volatile unsigned long *)0xB0301008 = 0x00080032;
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+//Change MEM Source 
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+	
+	*(volatile unsigned long *) 0xB0301004=0x00000000; // PL341_GO
+	while (((*(volatile unsigned long *)0xB0301000) & (0x03)) != 1);	// Wait until READY
+}
+
+//145Mhz
+void init_clockchange110Mhz(void)
+{
+	#define lchange_source 2
+	#define lchange_div 4
+	
+	#define lmem_source 1 // 0 : PLL0 , 1 : PLL1	
+	#define lmem_div	4
+
+	
+	*(volatile unsigned long *)0xB0301004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xB0301004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xB0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xB0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xB030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lchange_div-1) << 4)|lchange_source); // CKC-CLKCTRL2 - Mem
+
+	//PLL1
+	*(volatile unsigned long *)0xB0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xB0400024= 0x00006E03;		// pms - pllout_440M
+	*(volatile unsigned long *)0xB0400024= 0x80006E03;		//	pll pwr on
+	
+//Init DDR2 
+	*(volatile unsigned long *)0xB030100C = 0x00210012; 		// config0 cas 10bit, ras 13bit , AP bit 10, Burst 4, 2chips
+
+	*(volatile unsigned long *) 0xB0303000 |= 0x00800000;		// bit23 enable -synopt enable
+	*(volatile unsigned long *) 0xB0303010 |= 0x00800000;		// bit23 enable -synopt enable
+
+	*(volatile unsigned long *)0xB030104C= 0x000002D1;
+	*(volatile unsigned long *)0xB0301010 = 0x000003E8; // refresh_prd = 1000
+
+#if defined(DRAM_CAS3)
+	*(volatile unsigned long *)0xB0301014 = 0x00000006; // cas_latency = 3
+#else
+	*(volatile unsigned long *)0xB0301014 = 0x00000004; // cas_latency = 2
+#endif					
+
+	*(volatile unsigned long *)0xB030101C = 0x00000002; // tMRD 2tck 
+	*(volatile unsigned long *)0xB0301020 = 0x0000000A; // tRAS 42ns
+	*(volatile unsigned long *)0xB0301024 = 0x0000000F; // tRC 60ns
+	*(volatile unsigned long *)0xB0301028 = 0x00000014; // tRCD 18ns
+	*(volatile unsigned long *)0xB030102c = 0x00000E11; // tRFC 72ns
+	*(volatile unsigned long *)0xB0301030 = 0x00000014; // tRP 18ns
+	*(volatile unsigned long *)0xB0301034 = 0x00000001; // tRRD 12ns
+	*(volatile unsigned long *)0xB0301038 = 0x00000002; // tWR 15ns
+	*(volatile unsigned long *)0xB030103c = 0x00000001; // tWTR 1tck
+	*(volatile unsigned long *)0xB0301040 = 0x00000002; // tXP=3
+	*(volatile unsigned long *)0xB0301044 = 0x00000016; // tXSR 120ns
+	*(volatile unsigned long *)0xB0301048 = 0x00000032; // tESR=200
+
+	*(volatile unsigned long *)0xB0301200 = 0x000040F0; // Chip 0
+	
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	while (!((*(volatile unsigned long *)0xB030442c) & (1)));	// Wait until Calibration completion without error
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+
+	*(volatile unsigned long *)0xB0301008 = 0x00000032; //MRS
+	*(volatile unsigned long *)0xB0301008 = 0x000a0000;//EMRS
+	*(volatile unsigned long *)0xB0301008 = 0x00080032;
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+//Change MEM Source 
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+	
+	*(volatile unsigned long *) 0xB0301004=0x00000000; // PL341_GO
+	while (((*(volatile unsigned long *)0xB0301000) & (0x03)) != 1);	// Wait until READY
+
+}
+
+void init_clockchange115Mhz(void)
+{
+	#define lchange_source 2
+	#define lchange_div 4
+	
+	#define lmem_source 1 // 0 : PLL0 , 1 : PLL1	
+	#define lmem_div	4
+
+	
+	*(volatile unsigned long *)0xB0301004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xB0301004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xB0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xB0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xB030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lchange_div-1) << 4)|lchange_source); // CKC-CLKCTRL2 - Mem
+
+	//PLL1
+	*(volatile unsigned long *)0xB0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xB0400024= 0x00007303;		// pms - pllout_460M
+	*(volatile unsigned long *)0xB0400024= 0x80007303;		//	pll pwr on
+	
+//Init DDR2 
+	*(volatile unsigned long *)0xB030100C = 0x00210012; 		// config0 cas 10bit, ras 13bit , AP bit 10, Burst 4, 2chips
+
+	*(volatile unsigned long *) 0xB0303000 |= 0x00800000;		// bit23 enable -synopt enable
+	*(volatile unsigned long *) 0xB0303010 |= 0x00800000;		// bit23 enable -synopt enable
+
+	*(volatile unsigned long *)0xB030104C= 0x000002D1;
+	*(volatile unsigned long *)0xB0301010 = 0x000003E8; // refresh_prd = 1000
+
+#if defined(DRAM_CAS3)
+	*(volatile unsigned long *)0xB0301014 = 0x00000006; // cas_latency = 3
+#else
+	*(volatile unsigned long *)0xB0301014 = 0x00000004; // cas_latency = 2
+#endif					
+
+	*(volatile unsigned long *)0xB030101C = 0x00000002; // tMRD 2tck 
+	*(volatile unsigned long *)0xB0301020 = 0x0000000A; // tRAS 42ns
+	*(volatile unsigned long *)0xB0301024 = 0x0000000F; // tRC 60ns
+	*(volatile unsigned long *)0xB0301028 = 0x00000014; // tRCD 18ns
+	*(volatile unsigned long *)0xB030102c = 0x00000E11; // tRFC 72ns
+	*(volatile unsigned long *)0xB0301030 = 0x00000014; // tRP 18ns
+	*(volatile unsigned long *)0xB0301034 = 0x00000001; // tRRD 12ns
+	*(volatile unsigned long *)0xB0301038 = 0x00000002; // tWR 15ns
+	*(volatile unsigned long *)0xB030103c = 0x00000001; // tWTR 1tck
+	*(volatile unsigned long *)0xB0301040 = 0x00000002; // tXP=3
+	*(volatile unsigned long *)0xB0301044 = 0x00000016; // tXSR 120ns
+	*(volatile unsigned long *)0xB0301048 = 0x00000032; // tESR=200
+
+	*(volatile unsigned long *)0xB0301200 = 0x000040F0; // Chip 0
+	
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	while (!((*(volatile unsigned long *)0xB030442c) & (1)));	// Wait until Calibration completion without error
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+						
+	*(volatile unsigned long *)0xB0301008 = 0x00000032; //MRS
+	*(volatile unsigned long *)0xB0301008 = 0x000a0000;//EMRS
+	*(volatile unsigned long *)0xB0301008 = 0x00080032;
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+//Change MEM Source 
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+	
+	*(volatile unsigned long *) 0xB0301004=0x00000000; // PL341_GO
+	while (((*(volatile unsigned long *)0xB0301000) & (0x03)) != 1);	// Wait until READY
+
+}
+//150Mhz
+void init_clockchange120Mhz(void)
+{
+	#define lchange_source 2
+	#define lchange_div 4
+	
+	#define lmem_source 1 // 0 : PLL0 , 1 : PLL1	
+	#define lmem_div	4
+
+	
+	*(volatile unsigned long *)0xB0301004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xB0301004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xB0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xB0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xB030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lchange_div-1) << 4)|lchange_source); // CKC-CLKCTRL2 - Mem
+
+	//PLL1
+	*(volatile unsigned long *)0xB0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xB0400024= 0x00002801;		// pms - pllout_480M
+	*(volatile unsigned long *)0xB0400024= 0x80002801;		//	pll pwr on
+	
+//Init DDR2 
+	*(volatile unsigned long *)0xB030100C = 0x00210012; 		// config0 cas 10bit, ras 13bit , AP bit 10, Burst 4, 2chips
+
+	*(volatile unsigned long *) 0xB0303000 |= 0x00800000;		// bit23 enable -synopt enable
+	*(volatile unsigned long *) 0xB0303010 |= 0x00800000;		// bit23 enable -synopt enable
+
+	*(volatile unsigned long *)0xB030104C= 0x000002D1;
+	*(volatile unsigned long *)0xB0301010 = 0x000003E8; // refresh_prd = 1000
+
+#if defined(DRAM_CAS3)
+	*(volatile unsigned long *)0xB0301014 = 0x00000006; // cas_latency = 3
+#else
+	*(volatile unsigned long *)0xB0301014 = 0x00000004; // cas_latency = 2
+#endif					
+
+	*(volatile unsigned long *)0xB030101C = 0x00000002; // tMRD 2tck 
+	*(volatile unsigned long *)0xB0301020 = 0x0000000A; // tRAS 42ns
+	*(volatile unsigned long *)0xB0301024 = 0x0000000F; // tRC 60ns
+	*(volatile unsigned long *)0xB0301028 = 0x00000014; // tRCD 18ns
+	*(volatile unsigned long *)0xB030102c = 0x00000E11; // tRFC 72ns
+	*(volatile unsigned long *)0xB0301030 = 0x00000014; // tRP 18ns
+	*(volatile unsigned long *)0xB0301034 = 0x00000001; // tRRD 12ns
+	*(volatile unsigned long *)0xB0301038 = 0x00000002; // tWR 15ns
+	*(volatile unsigned long *)0xB030103c = 0x00000001; // tWTR 1tck
+	*(volatile unsigned long *)0xB0301040 = 0x00000002; // tXP=3
+	*(volatile unsigned long *)0xB0301044 = 0x00000016; // tXSR 120ns
+	*(volatile unsigned long *)0xB0301048 = 0x00000032; // tESR=200
+
+	*(volatile unsigned long *)0xB0301200 = 0x000040F0; // Chip 0
+	
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	while (!((*(volatile unsigned long *)0xB030442c) & (1)));	// Wait until Calibration completion without error
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+
+	*(volatile unsigned long *)0xB0301008 = 0x00000032; //MRS
+	*(volatile unsigned long *)0xB0301008 = 0x000a0000;//EMRS
+	*(volatile unsigned long *)0xB0301008 = 0x00080032;
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+//Change MEM Source 
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+	
+	*(volatile unsigned long *) 0xB0301004=0x00000000; // PL341_GO
+	while (((*(volatile unsigned long *)0xB0301000) & (0x03)) != 1);	// Wait until READY
+
+}
+
+void init_clockchange125Mhz(void)
+{
+	#define lchange_source 2
+	#define lchange_div 4
+	
+	#define lmem_source 1 // 0 : PLL0 , 1 : PLL1	
+	#define lmem_div	4
+
+	
+	*(volatile unsigned long *)0xB0301004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xB0301004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xB0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xB0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xB030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lchange_div-1) << 4)|lchange_source); // CKC-CLKCTRL2 - Mem
+
+	//PLL1
+	*(volatile unsigned long *)0xB0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xB0400024= 0x00007D03;		// pms - pllout_500M
+	*(volatile unsigned long *)0xB0400024= 0x80007D03;		//	pll pwr on
+	
+//Init DDR2 
+	*(volatile unsigned long *)0xB030100C = 0x00210012; 		// config0 cas 10bit, ras 13bit , AP bit 10, Burst 4, 2chips
+
+	*(volatile unsigned long *) 0xB0303000 |= 0x00800000;		// bit23 enable -synopt enable
+	*(volatile unsigned long *) 0xB0303010 |= 0x00800000;		// bit23 enable -synopt enable
+
+	*(volatile unsigned long *)0xB030104C= 0x000002D1;
+	*(volatile unsigned long *)0xB0301010 = 0x000003E8; // refresh_prd = 1000
+
+#if defined(DRAM_CAS3)
+	*(volatile unsigned long *)0xB0301014 = 0x00000006; // cas_latency = 3
+#else
+	*(volatile unsigned long *)0xB0301014 = 0x00000004; // cas_latency = 2
+#endif					
+
+	*(volatile unsigned long *)0xB030101C = 0x00000002; // tMRD 2tck 
+	*(volatile unsigned long *)0xB0301020 = 0x0000000A; // tRAS 42ns
+	*(volatile unsigned long *)0xB0301024 = 0x0000000F; // tRC 60ns
+	*(volatile unsigned long *)0xB0301028 = 0x00000014; // tRCD 18ns
+	*(volatile unsigned long *)0xB030102c = 0x00000E11; // tRFC 72ns
+	*(volatile unsigned long *)0xB0301030 = 0x00000014; // tRP 18ns
+	*(volatile unsigned long *)0xB0301034 = 0x00000001; // tRRD 12ns
+	*(volatile unsigned long *)0xB0301038 = 0x00000002; // tWR 15ns
+	*(volatile unsigned long *)0xB030103c = 0x00000001; // tWTR 1tck
+	*(volatile unsigned long *)0xB0301040 = 0x00000002; // tXP=3
+	*(volatile unsigned long *)0xB0301044 = 0x00000016; // tXSR 120ns
+	*(volatile unsigned long *)0xB0301048 = 0x00000032; // tESR=200
+
+	*(volatile unsigned long *)0xB0301200 = 0x000040F0; // Chip 0
+	
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	while (!((*(volatile unsigned long *)0xB030442c) & (1)));	// Wait until Calibration completion without error
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+
+	*(volatile unsigned long *)0xB0301008 = 0x00000032; //MRS
+	*(volatile unsigned long *)0xB0301008 = 0x000a0000;//EMRS
+	*(volatile unsigned long *)0xB0301008 = 0x00080032;
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+//Change MEM Source 
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+	
+	*(volatile unsigned long *) 0xB0301004=0x00000000; // PL341_GO
+	while (((*(volatile unsigned long *)0xB0301000) & (0x03)) != 1);	// Wait until READY
+
+}
+//160Mhz
+
+void init_clockchange130Mhz(void)
+{
+	#define lchange_source 2
+	#define lchange_div 4
+	
+	#define lmem_source 1 // 0 : PLL0 , 1 : PLL1	
+	#define lmem_div	2
+
+	
+	*(volatile unsigned long *)0xB0301004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xB0301004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xB0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xB0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xB030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lchange_div-1) << 4)|lchange_source); // CKC-CLKCTRL2 - Mem
+
+	//PLL1
+	//PLL1
+	*(volatile unsigned long *)0xB0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xB0400024= 0x01008203;		// pms - pllout_260M
+	*(volatile unsigned long *)0xB0400024= 0x81008203;		//	pll pwr on
+	
+//Init DDR2 
+	*(volatile unsigned long *)0xB030100C = 0x00210012; 		// config0 cas 10bit, ras 13bit , AP bit 10, Burst 4, 2chips
+
+	*(volatile unsigned long *) 0xB0303000 |= 0x00800000;		// bit23 enable -synopt enable
+	*(volatile unsigned long *) 0xB0303010 |= 0x00800000;		// bit23 enable -synopt enable
+
+	*(volatile unsigned long *)0xB030104C= 0x000002D1;
+	*(volatile unsigned long *)0xB0301010 = 0x000003E8; // refresh_prd = 1000
+
+#if defined(DRAM_CAS3)
+	*(volatile unsigned long *)0xB0301014 = 0x00000006; // cas_latency = 3
+#else
+	*(volatile unsigned long *)0xB0301014 = 0x00000004; // cas_latency = 2
+#endif					
+
+	*(volatile unsigned long *)0xB030101C = 0x00000002; // tMRD 2tck 
+	*(volatile unsigned long *)0xB0301020 = 0x0000000A; // tRAS 42ns
+	*(volatile unsigned long *)0xB0301024 = 0x0000000F; // tRC 60ns
+	*(volatile unsigned long *)0xB0301028 = 0x00000014; // tRCD 18ns
+	*(volatile unsigned long *)0xB030102c = 0x00000E11; // tRFC 72ns
+	*(volatile unsigned long *)0xB0301030 = 0x00000014; // tRP 18ns
+	*(volatile unsigned long *)0xB0301034 = 0x00000001; // tRRD 12ns
+	*(volatile unsigned long *)0xB0301038 = 0x00000002; // tWR 15ns
+	*(volatile unsigned long *)0xB030103c = 0x00000001; // tWTR 1tck
+	*(volatile unsigned long *)0xB0301040 = 0x00000002; // tXP=3
+	*(volatile unsigned long *)0xB0301044 = 0x00000016; // tXSR 120ns
+	*(volatile unsigned long *)0xB0301048 = 0x00000032; // tESR=200
+
+	*(volatile unsigned long *)0xB0301200 = 0x000040F0; // Chip 0
+	
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	while (!((*(volatile unsigned long *)0xB030442c) & (1)));	// Wait until Calibration completion without error
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+
+	*(volatile unsigned long *)0xB0301008 = 0x00000032; //MRS
+	*(volatile unsigned long *)0xB0301008 = 0x000a0000;//EMRS
+	*(volatile unsigned long *)0xB0301008 = 0x00080032;
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+//Change MEM Source 
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+	
+	*(volatile unsigned long *) 0xB0301004=0x00000000; // PL341_GO
+	while (((*(volatile unsigned long *)0xB0301000) & (0x03)) != 1);	// Wait until READY
+
+}
+
+void init_clockchange135Mhz(void)
+{
+	#define lchange_source 2
+	#define lchange_div 4
+	
+	#define lmem_source 1 // 0 : PLL0 , 1 : PLL1	
+	#define lmem_div	4
+
+	
+	*(volatile unsigned long *)0xB0301004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xB0301004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xB0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xB0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xB030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lchange_div-1) << 4)|lchange_source); // CKC-CLKCTRL2 - Mem
+
+	//PLL1
+	*(volatile unsigned long *)0xB0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xB0400024= 0x00002D01;		// pms - pllout_540M
+	*(volatile unsigned long *)0xB0400024= 0x80002D01;		//	pll pwr on
+	
+//Init DDR2 
+	*(volatile unsigned long *)0xB030100C = 0x00210012; 		// config0 cas 10bit, ras 13bit , AP bit 10, Burst 4, 2chips
+
+	*(volatile unsigned long *) 0xB0303000 |= 0x00800000;		// bit23 enable -synopt enable
+	*(volatile unsigned long *) 0xB0303010 |= 0x00800000;		// bit23 enable -synopt enable
+
+	*(volatile unsigned long *)0xB030104C= 0x000002D1;
+	*(volatile unsigned long *)0xB0301010 = 0x000003E8; // refresh_prd = 1000
+
+#if defined(DRAM_CAS3)
+	*(volatile unsigned long *)0xB0301014 = 0x00000006; // cas_latency = 3
+#else
+	*(volatile unsigned long *)0xB0301014 = 0x00000004; // cas_latency = 2
+#endif					
+
+	*(volatile unsigned long *)0xB030101C = 0x00000002; // tMRD 2tck 
+	*(volatile unsigned long *)0xB0301020 = 0x0000000A; // tRAS 42ns
+	*(volatile unsigned long *)0xB0301024 = 0x0000000F; // tRC 60ns
+	*(volatile unsigned long *)0xB0301028 = 0x00000014; // tRCD 18ns
+	*(volatile unsigned long *)0xB030102c = 0x00000E11; // tRFC 72ns
+	*(volatile unsigned long *)0xB0301030 = 0x00000014; // tRP 18ns
+	*(volatile unsigned long *)0xB0301034 = 0x00000001; // tRRD 12ns
+	*(volatile unsigned long *)0xB0301038 = 0x00000002; // tWR 15ns
+	*(volatile unsigned long *)0xB030103c = 0x00000001; // tWTR 1tck
+	*(volatile unsigned long *)0xB0301040 = 0x00000002; // tXP=3
+	*(volatile unsigned long *)0xB0301044 = 0x00000016; // tXSR 120ns
+	*(volatile unsigned long *)0xB0301048 = 0x00000032; // tESR=200
+
+	*(volatile unsigned long *)0xB0301200 = 0x000040F0; // Chip 0
+	
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	while (!((*(volatile unsigned long *)0xB030442c) & (1)));	// Wait until Calibration completion without error
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	
+	*(volatile unsigned long *)0xB0301008 = 0x00000032; //MRS
+	*(volatile unsigned long *)0xB0301008 = 0x000a0000;//EMRS
+	*(volatile unsigned long *)0xB0301008 = 0x00080032;
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+//Change MEM Source 
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+	
+	*(volatile unsigned long *) 0xB0301004=0x00000000; // PL341_GO
+	while (((*(volatile unsigned long *)0xB0301000) & (0x03)) != 1);	// Wait until READY
+}
+
+
+//170Mhz
+void init_clockchange140Mhz(void)
+{
+	#define lchange_source 2
+	#define lchange_div 4
+	
+	#define lmem_source 1 // 0 : PLL0 , 1 : PLL1	
+	#define lmem_div	4
+
+	
+	*(volatile unsigned long *)0xB0301004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xB0301004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xB0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xB0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xB030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lchange_div-1) << 4)|lchange_source); // CKC-CLKCTRL2 - Mem
+
+	//PLL1
+	*(volatile unsigned long *)0xB0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xB0400024= 0x00008C03;		// pms - pllout_560M
+	*(volatile unsigned long *)0xB0400024= 0x80008C03;		//	pll pwr on
+	
+//Init DDR2 
+	*(volatile unsigned long *)0xB030100C = 0x00210012; 		// config0 cas 10bit, ras 13bit , AP bit 10, Burst 4, 2chips
+
+	*(volatile unsigned long *) 0xB0303000 |= 0x00800000;		// bit23 enable -synopt enable
+	*(volatile unsigned long *) 0xB0303010 |= 0x00800000;		// bit23 enable -synopt enable
+
+	*(volatile unsigned long *)0xB030104C= 0x000002D1;
+	*(volatile unsigned long *)0xB0301010 = 0x000003E8; // refresh_prd = 1000
+
+#if defined(DRAM_CAS3)
+	*(volatile unsigned long *)0xB0301014 = 0x00000006; // cas_latency = 3
+#else
+	*(volatile unsigned long *)0xB0301014 = 0x00000004; // cas_latency = 2
+#endif					
+
+	*(volatile unsigned long *)0xB030101C = 0x00000002; // tMRD 2tck 
+	*(volatile unsigned long *)0xB0301020 = 0x0000000A; // tRAS 42ns
+	*(volatile unsigned long *)0xB0301024 = 0x0000000F; // tRC 60ns
+	*(volatile unsigned long *)0xB0301028 = 0x00000014; // tRCD 18ns
+	*(volatile unsigned long *)0xB030102c = 0x00000E11; // tRFC 72ns
+	*(volatile unsigned long *)0xB0301030 = 0x00000014; // tRP 18ns
+	*(volatile unsigned long *)0xB0301034 = 0x00000001; // tRRD 12ns
+	*(volatile unsigned long *)0xB0301038 = 0x00000002; // tWR 15ns
+	*(volatile unsigned long *)0xB030103c = 0x00000001; // tWTR 1tck
+	*(volatile unsigned long *)0xB0301040 = 0x00000002; // tXP=3
+	*(volatile unsigned long *)0xB0301044 = 0x00000016; // tXSR 120ns
+	*(volatile unsigned long *)0xB0301048 = 0x00000032; // tESR=200
+
+	*(volatile unsigned long *)0xB0301200 = 0x000040F0; // Chip 0
+	
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	while (!((*(volatile unsigned long *)0xB030442c) & (1)));	// Wait until Calibration completion without error
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+
+	*(volatile unsigned long *)0xB0301008 = 0x00000032; //MRS
+	*(volatile unsigned long *)0xB0301008 = 0x000a0000;//EMRS
+	*(volatile unsigned long *)0xB0301008 = 0x00080032;
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+//Change MEM Source 
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+	
+	*(volatile unsigned long *) 0xB0301004=0x00000000; // PL341_GO
+	while (((*(volatile unsigned long *)0xB0301000) & (0x03)) != 1);	// Wait until READY
+
+}
+
+void init_clockchange145Mhz(void)
+{
+	#define lchange_source 2
+	#define lchange_div 4
+	
+	#define lmem_source 1 // 0 : PLL0 , 1 : PLL1	
+	#define lmem_div	4
+
+	
+	*(volatile unsigned long *)0xB0301004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xB0301004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xB0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xB0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xB030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lchange_div-1) << 4)|lchange_source); // CKC-CLKCTRL2 - Mem
+
+	//PLL1
+	*(volatile unsigned long *)0xB0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xB0400024= 0x00009103;		// pms - pllout_580M
+	*(volatile unsigned long *)0xB0400024= 0x80009103;		//	pll pwr on
+	
+//Init DDR2 
+	*(volatile unsigned long *)0xB030100C = 0x00210012; 		// config0 cas 10bit, ras 13bit , AP bit 10, Burst 4, 2chips
+
+	*(volatile unsigned long *) 0xB0303000 |= 0x00800000;		// bit23 enable -synopt enable
+	*(volatile unsigned long *) 0xB0303010 |= 0x00800000;		// bit23 enable -synopt enable
+
+	*(volatile unsigned long *)0xB030104C= 0x000002D1;
+	*(volatile unsigned long *)0xB0301010 = 0x000003E8; // refresh_prd = 1000
+
+#if defined(DRAM_CAS3)
+	*(volatile unsigned long *)0xB0301014 = 0x00000006; // cas_latency = 3
+#else
+	*(volatile unsigned long *)0xB0301014 = 0x00000004; // cas_latency = 2
+#endif					
+
+	*(volatile unsigned long *)0xB030101C = 0x00000002; // tMRD 2tck 
+	*(volatile unsigned long *)0xB0301020 = 0x0000000A; // tRAS 42ns
+	*(volatile unsigned long *)0xB0301024 = 0x0000000F; // tRC 60ns
+	*(volatile unsigned long *)0xB0301028 = 0x00000014; // tRCD 18ns
+	*(volatile unsigned long *)0xB030102c = 0x00000E11; // tRFC 72ns
+	*(volatile unsigned long *)0xB0301030 = 0x00000014; // tRP 18ns
+	*(volatile unsigned long *)0xB0301034 = 0x00000001; // tRRD 12ns
+	*(volatile unsigned long *)0xB0301038 = 0x00000002; // tWR 15ns
+	*(volatile unsigned long *)0xB030103c = 0x00000001; // tWTR 1tck
+	*(volatile unsigned long *)0xB0301040 = 0x00000002; // tXP=3
+	*(volatile unsigned long *)0xB0301044 = 0x00000016; // tXSR 120ns
+	*(volatile unsigned long *)0xB0301048 = 0x00000032; // tESR=200
+
+
+	*(volatile unsigned long *)0xB0301200 = 0x000040F0; // Chip 0
+	
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	while (!((*(volatile unsigned long *)0xB030442c) & (1)));	// Wait until Calibration completion without error
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+
+	*(volatile unsigned long *)0xB0301008 = 0x00000032; //MRS
+	*(volatile unsigned long *)0xB0301008 = 0x000a0000;//EMRS
+	*(volatile unsigned long *)0xB0301008 = 0x00080032;
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+//Change MEM Source 
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+	
+	*(volatile unsigned long *) 0xB0301004=0x00000000; // PL341_GO
+	while (((*(volatile unsigned long *)0xB0301000) & (0x03)) != 1);	// Wait until READY
+	
+}
+//150Mhz
+void init_clockchange150Mhz(void)
+{
+	#define lchange_source 2
+	#define lchange_div 4
+	
+	#define lmem_source 1 // 0 : PLL0 , 1 : PLL1	
+	#define lmem_div	4
+
+	
+	*(volatile unsigned long *)0xB0301004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xB0301004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xB0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xB0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xB030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lchange_div-1) << 4)|lchange_source); // CKC-CLKCTRL2 - Mem
+
+	//PLL1
+	*(volatile unsigned long *)0xB0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xB0400024= 0x00003201;		// pms - pllout_600M
+	*(volatile unsigned long *)0xB0400024= 0x80003201;		//	pll pwr on
+	
+//Init DDR2 
+	*(volatile unsigned long *)0xB030100C = 0x00210012; 		// config0 cas 10bit, ras 13bit , AP bit 10, Burst 4, 2chips
+
+	*(volatile unsigned long *) 0xB0303000 |= 0x00800000;		// bit23 enable -synopt enable
+	*(volatile unsigned long *) 0xB0303010 |= 0x00800000;		// bit23 enable -synopt enable
+
+	*(volatile unsigned long *)0xB030104C= 0x000002D1;
+	*(volatile unsigned long *)0xB0301010 = 0x000003E8; // refresh_prd = 1000
+
+#if defined(DRAM_CAS3)
+	*(volatile unsigned long *)0xB0301014 = 0x00000006; // cas_latency = 3
+#else
+	*(volatile unsigned long *)0xB0301014 = 0x00000004; // cas_latency = 2
+#endif					
+
+	*(volatile unsigned long *)0xB030101C = 0x00000002; // tMRD 2tck 
+	*(volatile unsigned long *)0xB0301020 = 0x0000000A; // tRAS 42ns
+	*(volatile unsigned long *)0xB0301024 = 0x0000000F; // tRC 60ns
+	*(volatile unsigned long *)0xB0301028 = 0x00000014; // tRCD 18ns
+	*(volatile unsigned long *)0xB030102c = 0x00000E11; // tRFC 72ns
+	*(volatile unsigned long *)0xB0301030 = 0x00000014; // tRP 18ns
+	*(volatile unsigned long *)0xB0301034 = 0x00000001; // tRRD 12ns
+	*(volatile unsigned long *)0xB0301038 = 0x00000002; // tWR 15ns
+	*(volatile unsigned long *)0xB030103c = 0x00000001; // tWTR 1tck
+	*(volatile unsigned long *)0xB0301040 = 0x00000002; // tXP=3
+	*(volatile unsigned long *)0xB0301044 = 0x00000016; // tXSR 120ns
+	*(volatile unsigned long *)0xB0301048 = 0x00000032; // tESR=200
+
+
+	*(volatile unsigned long *)0xB0301200 = 0x000040F0; // Chip 0
+	
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	while (!((*(volatile unsigned long *)0xB030442c) & (1)));	// Wait until Calibration completion without error
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+
+	*(volatile unsigned long *)0xB0301008 = 0x00000032; //MRS
+	*(volatile unsigned long *)0xB0301008 = 0x000a0000;//EMRS
+	*(volatile unsigned long *)0xB0301008 = 0x00080032;
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+//Change MEM Source 
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+	
+	*(volatile unsigned long *) 0xB0301004=0x00000000; // PL341_GO
+	while (((*(volatile unsigned long *)0xB0301000) & (0x03)) != 1);	// Wait until READY
+}
+void init_clockchange156Mhz(void)
+{
+	#define lchange_source 2
+	#define lchange_div 4
+	
+	#define lmem_source 1 // 0 : PLL0 , 1 : PLL1	
+	#define lmem_div	2
+
+	
+	*(volatile unsigned long *)0xB0301004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xB0301004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xB0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xB0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xB030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lchange_div-1) << 4)|lchange_source); // CKC-CLKCTRL2 - Mem
+
+	//PLL1
+	*(volatile unsigned long *)0xB0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xB0400024= 0x00001A01;		// pms - pllout_312M
+	*(volatile unsigned long *)0xB0400024= 0x80001A01;		//	pll pwr on
+	
+//Init DDR2 
+	*(volatile unsigned long *)0xB030100C = 0x00210012; 		// config0 cas 10bit, ras 13bit , AP bit 10, Burst 4, 2chips
+
+	*(volatile unsigned long *) 0xB0303000 |= 0x00800000;		// bit23 enable -synopt enable
+	*(volatile unsigned long *) 0xB0303010 |= 0x00800000;		// bit23 enable -synopt enable
+
+	*(volatile unsigned long *)0xB030104C= 0x000002D1;
+	*(volatile unsigned long *)0xB0301010 = 0x000003E8; // refresh_prd = 1000
+
+//#if defined(DRAM_CAS3)
+	*(volatile unsigned long *)0xB0301014 = 0x00000006; // cas_latency = 3
+//#else
+//	*(volatile unsigned long *)0xB0301014 = 0x00000004; // cas_latency = 2
+//#endif					
+
+	*(volatile unsigned long *)0xB030101C = 0x00000002; // tMRD 2tck 
+	*(volatile unsigned long *)0xB0301020 = 0x0000000A; // tRAS 42ns
+	*(volatile unsigned long *)0xB0301024 = 0x0000000F; // tRC 60ns
+	*(volatile unsigned long *)0xB0301028 = 0x00000014; // tRCD 18ns
+	*(volatile unsigned long *)0xB030102c = 0x00000E11; // tRFC 72ns
+	*(volatile unsigned long *)0xB0301030 = 0x00000014; // tRP 18ns
+	*(volatile unsigned long *)0xB0301034 = 0x00000001; // tRRD 12ns
+	*(volatile unsigned long *)0xB0301038 = 0x00000002; // tWR 15ns
+	*(volatile unsigned long *)0xB030103c = 0x00000001; // tWTR 1tck
+	*(volatile unsigned long *)0xB0301040 = 0x00000002; // tXP=3
+	*(volatile unsigned long *)0xB0301044 = 0x00000016; // tXSR 120ns
+	*(volatile unsigned long *)0xB0301048 = 0x00000032; // tESR=200
+
+
+	*(volatile unsigned long *)0xB0301200 = 0x000040F0; // Chip 0
+	
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	while (!((*(volatile unsigned long *)0xB030442c) & (1)));	// Wait until Calibration completion without error
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+
+	*(volatile unsigned long *)0xB0301008 = 0x00000032; //MRS
+	*(volatile unsigned long *)0xB0301008 = 0x000a0000;//EMRS
+	*(volatile unsigned long *)0xB0301008 = 0x00080032;
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+//Change MEM Source 
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+	
+	*(volatile unsigned long *) 0xB0301004=0x00000000; // PL341_GO
+	while (((*(volatile unsigned long *)0xB0301000) & (0x03)) != 1);	// Wait until READY
+	
+}
+
+void init_clockchange160Mhz(void)
+{
+	#define lchange_source 2
+	#define lchange_div 4
+	
+	#define lmem_source 1 // 0 : PLL0 , 1 : PLL1	
+	#define lmem_div	2
+
+	
+	*(volatile unsigned long *)0xB0301004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xB0301004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xB0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xB0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xB030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lchange_div-1) << 4)|lchange_source); // CKC-CLKCTRL2 - Mem
+
+	//PLL1
+	*(volatile unsigned long *)0xB0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xB0400024= 0x00005003;		// pms - pllout_320M
+	*(volatile unsigned long *)0xB0400024= 0x80005003;		// pms - pllout_320M
+	
+//Init DDR2 
+	*(volatile unsigned long *)0xB030100C = 0x00210012; 		// config0 cas 10bit, ras 13bit , AP bit 10, Burst 4, 2chips
+
+	*(volatile unsigned long *) 0xB0303000 |= 0x00800000;		// bit23 enable -synopt enable
+	*(volatile unsigned long *) 0xB0303010 |= 0x00800000;		// bit23 enable -synopt enable
+
+	*(volatile unsigned long *)0xB030104C= 0x000002D1;
+	*(volatile unsigned long *)0xB0301010 = 0x000003E8; // refresh_prd = 1000
+
+#if defined(DRAM_CAS3)
+	*(volatile unsigned long *)0xB0301014 = 0x00000006; // cas_latency = 3
+#else
+	*(volatile unsigned long *)0xB0301014 = 0x00000004; // cas_latency = 2
+#endif					
+
+	*(volatile unsigned long *)0xB030101C = 0x00000002; // tMRD 2tck 
+	*(volatile unsigned long *)0xB0301020 = 0x0000000A; // tRAS 42ns
+	*(volatile unsigned long *)0xB0301024 = 0x0000000F; // tRC 60ns
+	*(volatile unsigned long *)0xB0301028 = 0x00000014; // tRCD 18ns
+	*(volatile unsigned long *)0xB030102c = 0x00000E11; // tRFC 72ns
+	*(volatile unsigned long *)0xB0301030 = 0x00000014; // tRP 18ns
+	*(volatile unsigned long *)0xB0301034 = 0x00000001; // tRRD 12ns
+	*(volatile unsigned long *)0xB0301038 = 0x00000002; // tWR 15ns
+	*(volatile unsigned long *)0xB030103c = 0x00000001; // tWTR 1tck
+	*(volatile unsigned long *)0xB0301040 = 0x00000002; // tXP=3
+	*(volatile unsigned long *)0xB0301044 = 0x00000016; // tXSR 120ns
+	*(volatile unsigned long *)0xB0301048 = 0x00000032; // tESR=200
+
+	*(volatile unsigned long *)0xB0301200 = 0x000040F0; // Chip 0
+	
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	while (!((*(volatile unsigned long *)0xB030442c) & (1)));	// Wait until Calibration completion without error
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+
+	*(volatile unsigned long *)0xB0301008 = 0x00000032; //MRS
+	*(volatile unsigned long *)0xB0301008 = 0x000a0000;//EMRS
+	*(volatile unsigned long *)0xB0301008 = 0x00080032;
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+//Change MEM Source 
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+	
+	*(volatile unsigned long *) 0xB0301004=0x00000000; // PL341_GO
+	while (((*(volatile unsigned long *)0xB0301000) & (0x03)) != 1);	// Wait until READY
+
+}
+
+#endif
+
Index: linux-2.6.29/arch/arm/mach-tcc8900/tcc8900/tcc_ckcmddr_100to160.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/tcc8900/tcc_ckcmddr_100to160.h	2010-04-07 13:00:58.000000000 -0400
@@ -0,0 +1,27 @@
+#if defined(_LINUX_)
+    #include <bsp.h>
+    #include "../../../../../../bootloader/tcboot/include/ddr.h"
+#else
+#include "windows.h"
+
+#include "bsp.h"
+#include "tca_ckc.h"
+#endif
+
+#if defined(DRAM_MDDR)
+
+extern void init_clockchange100Mhz(void);
+extern void init_clockchange105Mhz(void);
+extern void init_clockchange110Mhz(void);
+extern void init_clockchange115Mhz(void);
+extern void init_clockchange120Mhz(void);
+extern void init_clockchange125Mhz(void);
+extern void init_clockchange130Mhz(void);
+extern void init_clockchange135Mhz(void);
+extern void init_clockchange140Mhz(void);
+extern void init_clockchange145Mhz(void);
+extern void init_clockchange150Mhz(void);
+extern void init_clockchange156Mhz(void);
+extern void init_clockchange160Mhz(void);
+#endif
+
Index: linux-2.6.29/arch/arm/mach-tcc8900/tcc8900/tcc_ckcmddr_20to90.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/tcc8900/tcc_ckcmddr_20to90.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,1570 @@
+#include "tcc_ckcmddr_20to90.h"
+
+#if defined(DRAM_MDDR)
+void init_clockchange25Mhz(void)
+{
+	#define lchange_source 2
+	#define lchange_div 4
+	
+	#define lmem_source 1 // 0 : PLL0 , 1 : PLL1	
+	#define lmem_div	4
+
+	
+	*(volatile unsigned long *)0xB0301004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xB0301004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xB0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xB0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xB030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lchange_div-1) << 4)|lchange_source); // CKC-CLKCTRL2 - Mem
+
+//PLL1
+	*(volatile unsigned long *)0xB0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xB0400024= 0x02006503;		// pms - pllout_101M
+	*(volatile unsigned long *)0xB0400024= 0x82006503;		//	pll pwr on
+	
+//Init DDR2 
+	*(volatile unsigned long *)0xB030100C = 0x00210012; 		// config0 cas 10bit, ras 13bit , AP bit 10, Burst 4, 2chips
+
+	*(volatile unsigned long *) 0xB0303000 |= 0x00800000;		// bit23 enable -synopt enable
+	*(volatile unsigned long *) 0xB0303010 |= 0x00800000;		// bit23 enable -synopt enable
+
+	*(volatile unsigned long *)0xB030104C= 0x000002D1;
+	*(volatile unsigned long *)0xB0301010 = 0x000003E8; // refresh_prd = 1000
+
+	*(volatile unsigned long *)0xB0301014 = 0x00000004; // cas_latency = 2
+
+	*(volatile unsigned long *)0xB030101C = 0x00000002; // tMRD 2tck 
+	*(volatile unsigned long *)0xB0301020 = 3; // tRAS 42ns
+	*(volatile unsigned long *)0xB0301024 = 4; // tRC 60ns
+	 
+	*(volatile unsigned long *)0xB0301028 =  0x14; // tRCD 18ns
+	*(volatile unsigned long *)0xB030102c = 0x87; // tRFC 72ns
+	*(volatile unsigned long *)0xB0301030 =  0x14;  // tRP 18ns
+	*(volatile unsigned long *)0xB0301034 = 0x2; // tRRD 12ns
+	*(volatile unsigned long *)0xB0301038 = 0x2; // tWR 15ns
+	*(volatile unsigned long *)0xB030103c = 0x1; // tWTR 1tck
+	*(volatile unsigned long *)0xB0301040 = 0x2; // tXP=3
+	*(volatile unsigned long *)0xB0301044 = 8; // tXSR 120ns
+	
+	*(volatile unsigned long *)0xB0301048 = 0x00000032; // tESR=200
+
+	*(volatile unsigned long *)0xB0301200 = 0x000040F0; // Chip 0
+	
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	while (!((*(volatile unsigned long *)0xB030442c) & (1)));	// Wait until Calibration completion without error
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	
+	*(volatile unsigned long *) 0xB0304404 &= ~(0x00000003); // DLLCTRL - DLL OFF, Not Useing DLL 
+	*(volatile unsigned long *)0xB0301008 = 0x00000022; //MRS
+	*(volatile unsigned long *)0xB0301008 = 0x000a0000;//EMRS
+	*(volatile unsigned long *)0xB0301008 = 0x00080022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+//Change MEM Source 
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+	
+	*(volatile unsigned long *) 0xB0301004=0x00000000; // PL341_GO
+	while (((*(volatile unsigned long *)0xB0301000) & (0x03)) != 1);	// Wait until READY
+
+}
+
+//30.5Mhz
+void init_clockchange30Mhz(void)
+{
+	#define lchange_source 2
+	#define lchange_div 4
+	
+	#define lmem_source 1 // 0 : PLL0 , 1 : PLL1	
+	#define lmem_div	8
+
+	
+	*(volatile unsigned long *)0xB0301004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xB0301004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xB0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xB0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xB030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lchange_div-1) << 4)|lchange_source); // CKC-CLKCTRL2 - Mem
+
+//PLL1
+	*(volatile unsigned long *)0xB0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xB0400024= 0x01007A03;		// pms - pllout_244M
+	*(volatile unsigned long *)0xB0400024= 0x81007A03;		//	pll pwr on
+	
+//Init DDR2 
+	*(volatile unsigned long *)0xB030100C = 0x00210012; 		// config0 cas 10bit, ras 13bit , AP bit 10, Burst 4, 2chips
+
+	*(volatile unsigned long *) 0xB0303000 |= 0x00800000;		// bit23 enable -synopt enable
+	*(volatile unsigned long *) 0xB0303010 |= 0x00800000;		// bit23 enable -synopt enable
+
+	*(volatile unsigned long *)0xB030104C= 0x000002D1;
+	*(volatile unsigned long *)0xB0301010 = 0x000003E8; // refresh_prd = 1000
+
+	*(volatile unsigned long *)0xB0301014 = 0x00000004; // cas_latency = 2
+
+	*(volatile unsigned long *)0xB030101C = 0x00000002; // tMRD 2tck 
+	*(volatile unsigned long *)0xB0301020 = 3; // tRAS 42ns
+	*(volatile unsigned long *)0xB0301024 = 4; // tRC 60ns
+	 
+	*(volatile unsigned long *)0xB0301028 =  0x14; // tRCD 18ns
+	*(volatile unsigned long *)0xB030102c = 0x87; // tRFC 72ns
+	*(volatile unsigned long *)0xB0301030 =  0x14;  // tRP 18ns
+	*(volatile unsigned long *)0xB0301034 = 0x2; // tRRD 12ns
+	*(volatile unsigned long *)0xB0301038 = 0x2; // tWR 15ns
+	*(volatile unsigned long *)0xB030103c = 0x1; // tWTR 1tck
+	*(volatile unsigned long *)0xB0301040 = 0x2; // tXP=3
+	*(volatile unsigned long *)0xB0301044 = 8; // tXSR 120ns
+	
+	*(volatile unsigned long *)0xB0301048 = 0x00000032; // tESR=200
+
+	*(volatile unsigned long *)0xB0301200 = 0x000040F0; // Chip 0
+	
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	while (!((*(volatile unsigned long *)0xB030442c) & (1)));	// Wait until Calibration completion without error
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+
+	
+	*(volatile unsigned long *) 0xB0304404 &= ~(0x00000003); // DLLCTRL - DLL OFF, Not Useing DLL 
+	*(volatile unsigned long *)0xB0301008 = 0x00000022; //MRS
+	*(volatile unsigned long *)0xB0301008 = 0x000a0000;//EMRS
+	*(volatile unsigned long *)0xB0301008 = 0x00080022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+//Change MEM Source 
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+	
+	*(volatile unsigned long *) 0xB0301004=0x00000000; // PL341_GO
+	while (((*(volatile unsigned long *)0xB0301000) & (0x03)) != 1);	// Wait until READY
+
+}
+
+//35.25Mhz
+void init_clockchange35Mhz(void)
+{
+	#define lchange_source 2
+	#define lchange_div 4
+	
+	#define lmem_source 1 // 0 : PLL0 , 1 : PLL1	
+	#define lmem_div	8
+
+	
+	*(volatile unsigned long *)0xB0301004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xB0301004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xB0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xB0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xB030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lchange_div-1) << 4)|lchange_source); // CKC-CLKCTRL2 - Mem
+
+//PLL1
+	*(volatile unsigned long *)0xB0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xB0400024= 0x01002F01;		// pms - pllout_282M
+	*(volatile unsigned long *)0xB0400024= 0x81002F01;		//	pll pwr on
+	
+//Init DDR2 
+	*(volatile unsigned long *)0xB030100C = 0x00210012; 		// config0 cas 10bit, ras 13bit , AP bit 10, Burst 4, 2chips
+
+	*(volatile unsigned long *) 0xB0303000 |= 0x00800000;		// bit23 enable -synopt enable
+	*(volatile unsigned long *) 0xB0303010 |= 0x00800000;		// bit23 enable -synopt enable
+
+	*(volatile unsigned long *)0xB030104C= 0x000002D1;
+	*(volatile unsigned long *)0xB0301010 = 0x000003E8; // refresh_prd = 1000
+
+	*(volatile unsigned long *)0xB0301014 = 0x00000004; // cas_latency = 2
+
+	*(volatile unsigned long *)0xB030101C = 0x00000002; // tMRD 2tck 
+	*(volatile unsigned long *)0xB0301020 = 3; // tRAS 42ns
+	*(volatile unsigned long *)0xB0301024 = 4; // tRC 60ns
+	 
+	*(volatile unsigned long *)0xB0301028 =  0x14; // tRCD 18ns
+	*(volatile unsigned long *)0xB030102c = 0x87; // tRFC 72ns
+	*(volatile unsigned long *)0xB0301030 =  0x14;  // tRP 18ns
+	*(volatile unsigned long *)0xB0301034 = 0x2; // tRRD 12ns
+	*(volatile unsigned long *)0xB0301038 = 0x2; // tWR 15ns
+	*(volatile unsigned long *)0xB030103c = 0x1; // tWTR 1tck
+	*(volatile unsigned long *)0xB0301040 = 0x2; // tXP=3
+	*(volatile unsigned long *)0xB0301044 = 8; // tXSR 120ns
+	
+	*(volatile unsigned long *)0xB0301048 = 0x00000032; // tESR=200
+
+	*(volatile unsigned long *)0xB0301200 = 0x000040F0; // Chip 0
+	
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	while (!((*(volatile unsigned long *)0xB030442c) & (1)));	// Wait until Calibration completion without error
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+
+	
+	*(volatile unsigned long *) 0xB0304404 &= ~(0x00000003); // DLLCTRL - DLL OFF, Not Useing DLL 
+	*(volatile unsigned long *)0xB0301008 = 0x00000022; //MRS
+	*(volatile unsigned long *)0xB0301008 = 0x000a0000;//EMRS
+	*(volatile unsigned long *)0xB0301008 = 0x00080022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+//Change MEM Source 
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+	
+	*(volatile unsigned long *) 0xB0301004=0x00000000; // PL341_GO
+	while (((*(volatile unsigned long *)0xB0301000) & (0x03)) != 1);	// Wait until READY
+	
+}
+void init_clockchange40Mhz(void)
+{
+	#define lchange_source 2
+	#define lchange_div 4
+	
+	#define lmem_source 1 // 0 : PLL0 , 1 : PLL1	
+	#define lmem_div	8
+
+	
+	*(volatile unsigned long *)0xB0301004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xB0301004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xB0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xB0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xB030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lchange_div-1) << 4)|lchange_source); // CKC-CLKCTRL2 - Mem
+
+//PLL1
+	*(volatile unsigned long *)0xB0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xB0400024= 0x00005003;		// pms - pllout_320M
+	*(volatile unsigned long *)0xB0400024= 0x80005003;		//	pll pwr on
+	
+//Init DDR2 
+	*(volatile unsigned long *)0xB030100C = 0x00210012; 		// config0 cas 10bit, ras 13bit , AP bit 10, Burst 4, 2chips
+
+	*(volatile unsigned long *) 0xB0303000 |= 0x00800000;		// bit23 enable -synopt enable
+	*(volatile unsigned long *) 0xB0303010 |= 0x00800000;		// bit23 enable -synopt enable
+
+	*(volatile unsigned long *)0xB030104C= 0x000002D1;
+	*(volatile unsigned long *)0xB0301010 = 0x000003E8; // refresh_prd = 1000
+
+	*(volatile unsigned long *)0xB0301014 = 0x00000004; // cas_latency = 2
+
+	*(volatile unsigned long *)0xB030101C = 0x00000002; // tMRD 2tck 
+	*(volatile unsigned long *)0xB0301020 = 3; // tRAS 42ns
+	*(volatile unsigned long *)0xB0301024 = 4; // tRC 60ns
+	 
+	*(volatile unsigned long *)0xB0301028 =  0x14; // tRCD 18ns
+	*(volatile unsigned long *)0xB030102c = 0x87; // tRFC 72ns
+	*(volatile unsigned long *)0xB0301030 =  0x14;  // tRP 18ns
+	*(volatile unsigned long *)0xB0301034 = 0x2; // tRRD 12ns
+	*(volatile unsigned long *)0xB0301038 = 0x2; // tWR 15ns
+	*(volatile unsigned long *)0xB030103c = 0x1; // tWTR 1tck
+	*(volatile unsigned long *)0xB0301040 = 0x2; // tXP=3
+	*(volatile unsigned long *)0xB0301044 = 8; // tXSR 120ns
+	*(volatile unsigned long *)0xB0301048 = 0x00000032; // tESR=200
+
+	*(volatile unsigned long *)0xB0301200 = 0x000040F0; // Chip 0
+	
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	while (!((*(volatile unsigned long *)0xB030442c) & (1)));	// Wait until Calibration completion without error
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+
+	
+	*(volatile unsigned long *) 0xB0304404 &= ~(0x00000003); // DLLCTRL - DLL OFF, Not Useing DLL 
+	*(volatile unsigned long *)0xB0301008 = 0x00000022; //MRS
+	*(volatile unsigned long *)0xB0301008 = 0x000a0000;//EMRS
+	*(volatile unsigned long *)0xB0301008 = 0x00080022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+//Change MEM Source 
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+	
+	*(volatile unsigned long *) 0xB0301004=0x00000000; // PL341_GO
+	while (((*(volatile unsigned long *)0xB0301000) & (0x03)) != 1);	// Wait until READY
+
+}
+
+void init_clockchange45Mhz(void)
+{
+	#define lchange_source 2
+	#define lchange_div 4
+	
+	#define lmem_source 1 // 0 : PLL0 , 1 : PLL1	
+	#define lmem_div	4
+
+	
+	*(volatile unsigned long *)0xB0301004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xB0301004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xB0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xB0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xB030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lchange_div-1) << 4)|lchange_source); // CKC-CLKCTRL2 - Mem
+
+//PLL1
+	*(volatile unsigned long *)0xB0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xB0400024= 0x01001E01;		// pms - pllout_180M
+	*(volatile unsigned long *)0xB0400024= 0x81001E01;		//	pll pwr on
+	
+//Init DDR2 
+	*(volatile unsigned long *)0xB030100C = 0x00210012; 		// config0 cas 10bit, ras 13bit , AP bit 10, Burst 4, 2chips
+
+	*(volatile unsigned long *) 0xB0303000 |= 0x00800000;		// bit23 enable -synopt enable
+	*(volatile unsigned long *) 0xB0303010 |= 0x00800000;		// bit23 enable -synopt enable
+
+	*(volatile unsigned long *)0xB030104C= 0x000002D1;
+	*(volatile unsigned long *)0xB0301010 = 0x000003E8; // refresh_prd = 1000
+
+	*(volatile unsigned long *)0xB0301014 = 0x00000004; // cas_latency = 2
+
+	*(volatile unsigned long *)0xB030101C = 0x00000002; // tMRD 2tck 
+	*(volatile unsigned long *)0xB0301020 = 3; // tRAS 42ns
+	*(volatile unsigned long *)0xB0301024 = 4; // tRC 60ns
+	 
+	*(volatile unsigned long *)0xB0301028 =  0x14; // tRCD 18ns
+	*(volatile unsigned long *)0xB030102c = 0x87; // tRFC 72ns
+	*(volatile unsigned long *)0xB0301030 =  0x14;  // tRP 18ns
+	*(volatile unsigned long *)0xB0301034 = 0x2; // tRRD 12ns
+	*(volatile unsigned long *)0xB0301038 = 0x2; // tWR 15ns
+	*(volatile unsigned long *)0xB030103c = 0x1; // tWTR 1tck
+	*(volatile unsigned long *)0xB0301040 = 0x2; // tXP=3
+	*(volatile unsigned long *)0xB0301044 = 8; // tXSR 120ns
+	*(volatile unsigned long *)0xB0301048 = 0x00000032; // tESR=200
+
+	*(volatile unsigned long *)0xB0301200 = 0x000040F0; // Chip 0
+	
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	while (!((*(volatile unsigned long *)0xB030442c) & (1)));	// Wait until Calibration completion without error
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+
+	
+	*(volatile unsigned long *) 0xB0304404 &= ~(0x00000003); // DLLCTRL - DLL OFF, Not Useing DLL 
+	*(volatile unsigned long *)0xB0301008 = 0x00000022; //MRS
+	*(volatile unsigned long *)0xB0301008 = 0x000a0000;//EMRS
+	*(volatile unsigned long *)0xB0301008 = 0x00080022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+//Change MEM Source 
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+	
+	*(volatile unsigned long *) 0xB0301004=0x00000000; // PL341_GO
+	while (((*(volatile unsigned long *)0xB0301000) & (0x03)) != 1);	// Wait until READY
+
+}
+
+void init_clockchange50Mhz(void)
+{
+	#define lchange_source 2
+	#define lchange_div 4
+	
+	#define lmem_source 1 // 0 : PLL0 , 1 : PLL1	
+	#define lmem_div	8
+
+	
+	*(volatile unsigned long *)0xB0301004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xB0301004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xB0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xB0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xB030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lchange_div-1) << 4)|lchange_source); // CKC-CLKCTRL2 - Mem
+
+//PLL1
+	*(volatile unsigned long *)0xB0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xB0400024= 0x00006403;		// pms - pllout_400M
+	*(volatile unsigned long *)0xB0400024= 0x80006403;		//	pll pwr on
+
+//Init DDR2 
+	*(volatile unsigned long *)0xB030100C = 0x00210012; 		// config0 cas 10bit, ras 13bit , AP bit 10, Burst 4, 2chips
+
+	*(volatile unsigned long *) 0xB0303000 |= 0x00800000;		// bit23 enable -synopt enable
+	*(volatile unsigned long *) 0xB0303010 |= 0x00800000;		// bit23 enable -synopt enable
+
+	*(volatile unsigned long *)0xB030104C= 0x000002D1;
+	*(volatile unsigned long *)0xB0301010 = 0x000003E8; // refresh_prd = 1000
+
+	*(volatile unsigned long *)0xB0301014 = 0x00000004; // cas_latency = 2
+
+	*(volatile unsigned long *)0xB030101C = 0x00000002; // tMRD 2tck 
+	*(volatile unsigned long *)0xB0301020 = 3; // tRAS 42ns
+	*(volatile unsigned long *)0xB0301024 = 4; // tRC 60ns
+	*(volatile unsigned long *)0xB0301028 =  0x14; // tRCD 18ns
+	*(volatile unsigned long *)0xB030102c = 0x66; // tRFC 72ns
+	*(volatile unsigned long *)0xB0301030 =  0x14;  // tRP 18ns
+	*(volatile unsigned long *)0xB0301034 = 0x00000002; // tRRD 12ns
+	*(volatile unsigned long *)0xB0301038 = 0x00000002; // tWR 15ns
+	*(volatile unsigned long *)0xB030103c = 0x00000001; // tWTR 1tck
+	*(volatile unsigned long *)0xB0301040 = 0x00000002; // tXP=3
+	*(volatile unsigned long *)0xB0301044 = 8; // tXSR 120ns
+
+	*(volatile unsigned long *)0xB0301048 = 0x00000032; // tESR=200
+
+	*(volatile unsigned long *)0xB0301200 = 0x000040F0; // Chip 0
+	
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	while (!((*(volatile unsigned long *)0xB030442c) & (1)));	// Wait until Calibration completion without error
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	
+	*(volatile unsigned long *) 0xB0304404 &= ~(0x00000003); // DLLCTRL - DLL OFF, Not Useing DLL 
+	*(volatile unsigned long *)0xB0301008 = 0x00000022; //MRS
+	*(volatile unsigned long *)0xB0301008 = 0x000a0000;//EMRS
+	*(volatile unsigned long *)0xB0301008 = 0x00080022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+//Change MEM Source 
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+	
+	*(volatile unsigned long *) 0xB0301004=0x00000000; // PL341_GO
+	while (((*(volatile unsigned long *)0xB0301000) & (0x03)) != 1);	// Wait until READY
+
+}
+
+
+void init_clockchange55Mhz(void)
+{
+	#define lchange_source 2
+	#define lchange_div 4
+	
+	#define lmem_source 1 // 0 : PLL0 , 1 : PLL1	
+	#define lmem_div	8
+
+	
+	*(volatile unsigned long *)0xB0301004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xB0301004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xB0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xB0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xB030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lchange_div-1) << 4)|lchange_source); // CKC-CLKCTRL2 - Mem
+
+//PLL1
+	*(volatile unsigned long *)0xB0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xB0400024= 0x00006E03;		// pms - pllout_440M
+	*(volatile unsigned long *)0xB0400024= 0x80006E03;		//	pll pwr on
+
+
+//Init DDR2 
+	*(volatile unsigned long *)0xB030100C = 0x00210012; 		// config0 cas 10bit, ras 13bit , AP bit 10, Burst 4, 2chips
+
+	*(volatile unsigned long *) 0xB0303000 |= 0x00800000;		// bit23 enable -synopt enable
+	*(volatile unsigned long *) 0xB0303010 |= 0x00800000;		// bit23 enable -synopt enable
+
+	*(volatile unsigned long *)0xB030104C= 0x000002D1;
+	*(volatile unsigned long *)0xB0301010 = 0x000003E8; // refresh_prd = 1000
+
+	*(volatile unsigned long *)0xB0301014 = 0x00000004; // cas_latency = 2
+
+	*(volatile unsigned long *)0xB030101C = 0x00000002; // tMRD 2tck 
+	*(volatile unsigned long *)0xB0301020 = 3; // tRAS 42ns
+	*(volatile unsigned long *)0xB0301024 = 4; // tRC 60ns
+	 
+	*(volatile unsigned long *)0xB0301028 =  0x14; // tRCD 18ns
+	*(volatile unsigned long *)0xB030102c = 0x87; // tRFC 72ns
+	*(volatile unsigned long *)0xB0301030 =  0x14;  // tRP 18ns
+	*(volatile unsigned long *)0xB0301034 = 0x2; // tRRD 12ns
+	*(volatile unsigned long *)0xB0301038 = 0x2; // tWR 15ns
+	*(volatile unsigned long *)0xB030103c = 0x1; // tWTR 1tck
+	*(volatile unsigned long *)0xB0301040 = 0x2; // tXP=3
+	*(volatile unsigned long *)0xB0301044 = 8; // tXSR 120ns
+
+	*(volatile unsigned long *)0xB0301048 = 0x00000032; // tESR=200
+
+	*(volatile unsigned long *)0xB0301200 = 0x000040F0; // Chip 0
+	
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	while (!((*(volatile unsigned long *)0xB030442c) & (1)));	// Wait until Calibration completion without error
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+
+	
+	*(volatile unsigned long *) 0xB0304404 &= ~(0x00000003); // DLLCTRL - DLL OFF, Not Useing DLL 
+	*(volatile unsigned long *)0xB0301008 = 0x00000022; //MRS
+	*(volatile unsigned long *)0xB0301008 = 0x000a0000;//EMRS
+	*(volatile unsigned long *)0xB0301008 = 0x00080022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+//Change MEM Source 
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+	
+	*(volatile unsigned long *) 0xB0301004=0x00000000; // PL341_GO
+	while (((*(volatile unsigned long *)0xB0301000) & (0x03)) != 1);	// Wait until READY
+
+}
+
+void init_clockchange60Mhz(void)
+{
+	#define lchange_source 2
+	#define lchange_div 4
+	
+	#define lmem_source 1 // 0 : PLL0 , 1 : PLL1	
+	#define lmem_div	8
+
+	
+	*(volatile unsigned long *)0xB0301004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xB0301004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xB0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xB0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xB030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lchange_div-1) << 4)|lchange_source); // CKC-CLKCTRL2 - Mem
+
+//PLL1
+	*(volatile unsigned long *)0xB0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xB0400024= 0x00002801;		// pms - pllout_480M
+	*(volatile unsigned long *)0xB0400024= 0x80002801;		//	pll pwr on
+
+	
+//Init DDR2 
+	*(volatile unsigned long *)0xB030100C = 0x00210012; 		// config0 cas 10bit, ras 13bit , AP bit 10, Burst 4, 2chips
+
+	*(volatile unsigned long *) 0xB0303000 |= 0x00800000;		// bit23 enable -synopt enable
+	*(volatile unsigned long *) 0xB0303010 |= 0x00800000;		// bit23 enable -synopt enable
+
+	*(volatile unsigned long *)0xB030104C= 0x000002D1;
+	*(volatile unsigned long *)0xB0301010 = 0x000003E8; // refresh_prd = 1000
+
+	*(volatile unsigned long *)0xB0301014 = 0x00000004; // cas_latency = 2
+
+	*(volatile unsigned long *)0xB030101C = 0x00000002; // tMRD 2tck 
+	*(volatile unsigned long *)0xB0301020 = 4; // tRAS 42ns
+	*(volatile unsigned long *)0xB0301024 = 5; // tRC 60ns
+	*(volatile unsigned long *)0xB0301028 =  0x14; // tRCD 18ns
+	*(volatile unsigned long *)0xB030102c = 0xE7; // tRFC 72ns
+	*(volatile unsigned long *)0xB0301030 =  0x14;  // tRP 18ns
+	*(volatile unsigned long *)0xB0301034 = 0x00000002; // tRRD 12ns
+	*(volatile unsigned long *)0xB0301038 = 0x00000002; // tWR 15ns
+	*(volatile unsigned long *)0xB030103c = 0x00000001; // tWTR 1tck
+	*(volatile unsigned long *)0xB0301040 = 0x00000002; // tXP=3
+	*(volatile unsigned long *)0xB0301044 = 10; // tXSR 120ns	
+
+	*(volatile unsigned long *)0xB0301048 = 0x00000032; // tESR=200
+
+	*(volatile unsigned long *)0xB0301200 = 0x000040F0; // Chip 0
+	
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	while (!((*(volatile unsigned long *)0xB030442c) & (1)));	// Wait until Calibration completion without error
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+
+	
+	*(volatile unsigned long *) 0xB0304404 &= ~(0x00000003); // DLLCTRL - DLL OFF, Not Useing DLL 
+	*(volatile unsigned long *)0xB0301008 = 0x00000022; //MRS
+	*(volatile unsigned long *)0xB0301008 = 0x000a0000;//EMRS
+	*(volatile unsigned long *)0xB0301008 = 0x00080022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+//Change MEM Source 
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+	
+	*(volatile unsigned long *) 0xB0301004=0x00000000; // PL341_GO
+	while (((*(volatile unsigned long *)0xB0301000) & (0x03)) != 1);	// Wait until READY
+
+}
+
+void init_clockchange65Mhz(void)
+{
+	#define lchange_source 2
+	#define lchange_div 4
+	
+	#define lmem_source 1 // 0 : PLL0 , 1 : PLL1	
+	#define lmem_div	8
+
+	
+	*(volatile unsigned long *)0xB0301004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xB0301004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xB0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xB0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xB030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lchange_div-1) << 4)|lchange_source); // CKC-CLKCTRL2 - Mem
+
+//PLL1
+	*(volatile unsigned long *)0xB0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xB0400024= 0x00008203;		// pms - pllout_520M
+	*(volatile unsigned long *)0xB0400024= 0x80008203;		//	pll pwr on
+
+	
+//Init DDR2 
+	*(volatile unsigned long *)0xB030100C = 0x00210012; 		// config0 cas 10bit, ras 13bit , AP bit 10, Burst 4, 2chips
+
+	*(volatile unsigned long *) 0xB0303000 |= 0x00800000;		// bit23 enable -synopt enable
+	*(volatile unsigned long *) 0xB0303010 |= 0x00800000;		// bit23 enable -synopt enable
+
+	*(volatile unsigned long *)0xB030104C= 0x000002D1;
+	*(volatile unsigned long *)0xB0301010 = 0x000003E8; // refresh_prd = 1000
+
+	*(volatile unsigned long *)0xB0301014 = 0x00000004; // cas_latency = 2
+
+	*(volatile unsigned long *)0xB030101C = 0x00000002; // tMRD 2tck 
+	*(volatile unsigned long *)0xB0301020 = 4; // tRAS 42ns
+	*(volatile unsigned long *)0xB0301024 = 5; // tRC 60ns
+	*(volatile unsigned long *)0xB0301028 =  0x14; // tRCD 18ns
+	*(volatile unsigned long *)0xB030102c = 0xE7; // tRFC 72ns
+	*(volatile unsigned long *)0xB0301030 =  0x14;  // tRP 18ns
+	*(volatile unsigned long *)0xB0301034 = 0x00000002; // tRRD 12ns
+	*(volatile unsigned long *)0xB0301038 = 0x00000002; // tWR 15ns
+	*(volatile unsigned long *)0xB030103c = 0x00000001; // tWTR 1tck
+	*(volatile unsigned long *)0xB0301040 = 0x00000002; // tXP=3
+	*(volatile unsigned long *)0xB0301044 = 10; // tXSR 120ns
+		
+
+	*(volatile unsigned long *)0xB0301048 = 0x00000032; // tESR=200
+
+	*(volatile unsigned long *)0xB0301200 = 0x000040F0; // Chip 0
+	
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	while (!((*(volatile unsigned long *)0xB030442c) & (1)));	// Wait until Calibration completion without error
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+
+	
+	*(volatile unsigned long *) 0xB0304404 &= ~(0x00000003); // DLLCTRL - DLL OFF, Not Useing DLL 
+	*(volatile unsigned long *)0xB0301008 = 0x00000022; //MRS
+	*(volatile unsigned long *)0xB0301008 = 0x000a0000;//EMRS
+	*(volatile unsigned long *)0xB0301008 = 0x00080022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+//Change MEM Source 
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+	
+	*(volatile unsigned long *) 0xB0301004=0x00000000; // PL341_GO
+	while (((*(volatile unsigned long *)0xB0301000) & (0x03)) != 1);	// Wait until READY
+
+}
+
+void init_clockchange70Mhz(void)
+{
+	#define lchange_source 2
+	#define lchange_div 4
+	
+	#define lmem_source 1 // 0 : PLL0 , 1 : PLL1	
+	#define lmem_div	4
+
+	
+	*(volatile unsigned long *)0xB0301004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xB0301004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xB0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xB0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xB030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lchange_div-1) << 4)|lchange_source); // CKC-CLKCTRL2 - Mem
+
+//PLL1
+	*(volatile unsigned long *)0xB0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xB0400024= 0x01002F01;		// pms - pllout_282M
+	*(volatile unsigned long *)0xB0400024= 0x81002F01;		//	pll pwr on
+
+	
+//Init DDR2 
+	*(volatile unsigned long *)0xB030100C = 0x00210012; 		// config0 cas 10bit, ras 13bit , AP bit 10, Burst 4, 2chips
+
+	*(volatile unsigned long *) 0xB0303000 |= 0x00800000;		// bit23 enable -synopt enable
+	*(volatile unsigned long *) 0xB0303010 |= 0x00800000;		// bit23 enable -synopt enable
+
+	*(volatile unsigned long *)0xB030104C= 0x000002D1;
+	*(volatile unsigned long *)0xB0301010 = 0x000003E8; // refresh_prd = 1000
+
+	*(volatile unsigned long *)0xB0301014 = 0x00000004; // cas_latency = 2
+
+	*(volatile unsigned long *)0xB030101C = 0x00000002; // tMRD 2tck 
+	*(volatile unsigned long *)0xB0301020 = 4; // tRAS 42ns
+	*(volatile unsigned long *)0xB0301024 = 9; // tRC 60ns
+	 
+	*(volatile unsigned long *)0xB0301028 =  0x14; // tRCD 18ns
+	*(volatile unsigned long *)0xB030102c = 0x18F; // tRFC 72ns
+	*(volatile unsigned long *)0xB0301030 =  0x14;  // tRP 18ns
+	*(volatile unsigned long *)0xB0301034 = 0x00000002; // tRRD 12ns
+	*(volatile unsigned long *)0xB0301038 = 0x00000002; // tWR 15ns
+	*(volatile unsigned long *)0xB030103c = 0x00000001; // tWTR 1tck
+	*(volatile unsigned long *)0xB0301040 = 0x00000002; // tXP=3
+	*(volatile unsigned long *)0xB0301044 = 20; // tXSR 120ns
+	
+
+	*(volatile unsigned long *)0xB0301048 = 0x00000032; // tESR=200
+
+	*(volatile unsigned long *)0xB0301200 = 0x000040F0; // Chip 0
+	
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	while (!((*(volatile unsigned long *)0xB030442c) & (1)));	// Wait until Calibration completion without error
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+
+	
+	*(volatile unsigned long *) 0xB0304404 &= ~(0x00000003); // DLLCTRL - DLL OFF, Not Useing DLL 
+	*(volatile unsigned long *)0xB0301008 = 0x00000022; //MRS
+	*(volatile unsigned long *)0xB0301008 = 0x000a0000;//EMRS
+	*(volatile unsigned long *)0xB0301008 = 0x00080022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+//Change MEM Source 
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+	
+	*(volatile unsigned long *) 0xB0301004=0x00000000; // PL341_GO
+	while (((*(volatile unsigned long *)0xB0301000) & (0x03)) != 1);	// Wait until READY
+
+}
+
+void init_clockchange75Mhz(void)
+{
+	#define lchange_source 2
+	#define lchange_div 4
+	
+	#define lmem_source 1 // 0 : PLL0 , 1 : PLL1	
+	#define lmem_div	8
+
+	
+	*(volatile unsigned long *)0xB0301004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xB0301004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xB0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xB0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xB030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lchange_div-1) << 4)|lchange_source); // CKC-CLKCTRL2 - Mem
+
+//PLL1
+	*(volatile unsigned long *)0xB0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xB0400024= 0x00003201;		// pms - pllout_600M
+	*(volatile unsigned long *)0xB0400024= 0x80003201;		//	pll pwr on
+
+	
+//Init DDR2 
+	*(volatile unsigned long *)0xB030100C = 0x00210012; 		// config0 cas 10bit, ras 13bit , AP bit 10, Burst 4, 2chips
+
+	*(volatile unsigned long *) 0xB0303000 |= 0x00800000;		// bit23 enable -synopt enable
+	*(volatile unsigned long *) 0xB0303010 |= 0x00800000;		// bit23 enable -synopt enable
+
+	*(volatile unsigned long *)0xB030104C= 0x000002D1;
+	*(volatile unsigned long *)0xB0301010 = 0x000003E8; // refresh_prd = 1000
+
+	*(volatile unsigned long *)0xB0301014 = 0x00000004; // cas_latency = 2
+
+	*(volatile unsigned long *)0xB030101C = 0x00000002; // tMRD 2tck 
+	*(volatile unsigned long *)0xB0301020 = 4; // tRAS 42ns
+	*(volatile unsigned long *)0xB0301024 = 9; // tRC 60ns
+	 
+	*(volatile unsigned long *)0xB0301028 =  0x14; // tRCD 18ns
+	*(volatile unsigned long *)0xB030102c = 0x18F; // tRFC 72ns
+	*(volatile unsigned long *)0xB0301030 =  0x14;  // tRP 18ns
+	*(volatile unsigned long *)0xB0301034 = 0x00000002; // tRRD 12ns
+	*(volatile unsigned long *)0xB0301038 = 0x00000002; // tWR 15ns
+	*(volatile unsigned long *)0xB030103c = 0x00000001; // tWTR 1tck
+	*(volatile unsigned long *)0xB0301040 = 0x00000002; // tXP=3
+	*(volatile unsigned long *)0xB0301044 = 20; // tXSR 120ns
+	
+
+	*(volatile unsigned long *)0xB0301048 = 0x00000032; // tESR=200
+
+	*(volatile unsigned long *)0xB0301200 = 0x000040F0; // Chip 0
+	
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	while (!((*(volatile unsigned long *)0xB030442c) & (1)));	// Wait until Calibration completion without error
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+
+	
+	*(volatile unsigned long *) 0xB0304404 &= ~(0x00000003); // DLLCTRL - DLL OFF, Not Useing DLL 
+	*(volatile unsigned long *)0xB0301008 = 0x00000022; //MRS
+	*(volatile unsigned long *)0xB0301008 = 0x000a0000;//EMRS
+	*(volatile unsigned long *)0xB0301008 = 0x00080022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+//Change MEM Source 
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+	
+	*(volatile unsigned long *) 0xB0301004=0x00000000; // PL341_GO
+	while (((*(volatile unsigned long *)0xB0301000) & (0x03)) != 1);	// Wait until READY
+
+}
+
+void init_clockchange80Mhz(void)
+{
+	#define lchange_source 2
+	#define lchange_div 4
+	
+	#define lmem_source 1 // 0 : PLL0 , 1 : PLL1	
+	#define lmem_div	4
+
+	
+	*(volatile unsigned long *)0xB0301004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xB0301004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xB0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xB0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xB030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lchange_div-1) << 4)|lchange_source); // CKC-CLKCTRL2 - Mem
+
+//PLL1
+	*(volatile unsigned long *)0xB0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xB0400024= 0x00005003;		// pms - pllout_320M
+	*(volatile unsigned long *)0xB0400024= 0x80005003;		//	pll pwr on
+	
+//Init DDR2 
+	*(volatile unsigned long *)0xB030100C = 0x00210012; 		// config0 cas 10bit, ras 13bit , AP bit 10, Burst 4, 2chips
+
+	*(volatile unsigned long *) 0xB0303000 |= 0x00800000;		// bit23 enable -synopt enable
+	*(volatile unsigned long *) 0xB0303010 |= 0x00800000;		// bit23 enable -synopt enable
+
+	*(volatile unsigned long *)0xB030104C= 0x000002D1;
+	*(volatile unsigned long *)0xB0301010 = 0x000003E8; // refresh_prd = 1000
+
+	*(volatile unsigned long *)0xB0301014 = 0x00000004; // cas_latency = 2
+
+	*(volatile unsigned long *)0xB030101C = 0x00000002; // tMRD 2tck 
+	*(volatile unsigned long *)0xB0301020 = 3; // tRAS 42ns
+	*(volatile unsigned long *)0xB0301024 = 5; // tRC 60ns
+	*(volatile unsigned long *)0xB0301028 =  0x14; // tRCD 18ns
+	*(volatile unsigned long *)0xB030102c = 0x66; // tRFC 72ns
+	*(volatile unsigned long *)0xB0301030 =  0x14;  // tRP 18ns
+	*(volatile unsigned long *)0xB0301034 = 0x00000001; // tRRD 12ns
+	*(volatile unsigned long *)0xB0301038 = 0x00000002; // tWR 15ns
+	*(volatile unsigned long *)0xB030103c = 0x00000001; // tWTR 1tck
+	*(volatile unsigned long *)0xB0301040 = 0x00000002; // tXP=3
+	*(volatile unsigned long *)0xB0301044 = 10; // tXSR 120ns
+
+	*(volatile unsigned long *)0xB0301200 = 0x000040F0; // Chip 0
+	
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	while (!((*(volatile unsigned long *)0xB030442c) & (1)));	// Wait until Calibration completion without error
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+
+	
+	*(volatile unsigned long *) 0xB0304404 &= ~(0x00000003); // DLLCTRL - DLL OFF, Not Useing DLL 
+	*(volatile unsigned long *)0xB0301008 = 0x00000022; //MRS
+	*(volatile unsigned long *)0xB0301008 = 0x000a0000;//EMRS
+	*(volatile unsigned long *)0xB0301008 = 0x00080022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+	*(volatile unsigned long *)0xB0301008 = 0x00040022;
+//Change MEM Source 
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+	
+	*(volatile unsigned long *) 0xB0301004=0x00000000; // PL341_GO
+	while (((*(volatile unsigned long *)0xB0301000) & (0x03)) != 1);	// Wait until READY
+}
+
+void init_clockchange85Mhz(void)
+{
+	#define lchange_source 2
+	#define lchange_div 4
+	
+	#define lmem_source 1 // 0 : PLL0 , 1 : PLL1	
+	#define lmem_div	4
+
+	
+	*(volatile unsigned long *)0xB0301004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xB0301004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xB0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xB0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xB030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lchange_div-1) << 4)|lchange_source); // CKC-CLKCTRL2 - Mem
+
+//PLL1
+	*(volatile unsigned long *)0xB0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xB0400024= 0x00005503;		// pms - pllout_340M
+	*(volatile unsigned long *)0xB0400024= 0x80005503;		//	pll pwr on
+	
+//Init DDR2 
+	*(volatile unsigned long *)0xB030100C = 0x00210012; 		// config0 cas 10bit, ras 13bit , AP bit 10, Burst 4, 2chips
+
+	*(volatile unsigned long *) 0xB0303000 |= 0x00800000;		// bit23 enable -synopt enable
+	*(volatile unsigned long *) 0xB0303010 |= 0x00800000;		// bit23 enable -synopt enable
+
+	*(volatile unsigned long *)0xB030104C= 0x000002D1;
+	*(volatile unsigned long *)0xB0301010 = 0x000003E8; // refresh_prd = 1000
+
+	*(volatile unsigned long *)0xB0301014 = 0x00000006; // cas_latency = 3
+
+	*(volatile unsigned long *)0xB030101C = 0x00000002; // tMRD 2tck 
+	*(volatile unsigned long *)0xB0301020 = 0x0000000A; // tRAS 42ns
+	*(volatile unsigned long *)0xB0301024 = 0x0000000F; // tRC 60ns
+	*(volatile unsigned long *)0xB0301028 = 0x00000014; // tRCD 18ns
+	*(volatile unsigned long *)0xB030102c = 0x00000E11; // tRFC 72ns
+	*(volatile unsigned long *)0xB0301030 = 0x00000014; // tRP 18ns
+	*(volatile unsigned long *)0xB0301034 = 0x00000001; // tRRD 12ns
+	*(volatile unsigned long *)0xB0301038 = 0x00000002; // tWR 15ns
+	*(volatile unsigned long *)0xB030103c = 0x00000001; // tWTR 1tck
+	*(volatile unsigned long *)0xB0301040 = 0x00000002; // tXP=3
+	*(volatile unsigned long *)0xB0301044 = 0x00000016; // tXSR 120ns
+	*(volatile unsigned long *)0xB0301048 = 0x00000032; // tESR=200
+
+	*(volatile unsigned long *)0xB0301200 = 0x000040F0; // Chip 0
+	
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	while (!((*(volatile unsigned long *)0xB030442c) & (1)));	// Wait until Calibration completion without error
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+
+	
+	*(volatile unsigned long *)0xB0301008 = 0x00000032; //MRS
+	*(volatile unsigned long *)0xB0301008 = 0x000a0000;//EMRS
+	*(volatile unsigned long *)0xB0301008 = 0x00080032;
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+//Change MEM Source 
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+	
+	*(volatile unsigned long *) 0xB0301004=0x00000000; // PL341_GO
+	while (((*(volatile unsigned long *)0xB0301000) & (0x03)) != 1);	// Wait until READY
+	
+}
+
+//190Mhz
+void init_clockchange90Mhz(void)
+{
+	#define lchange_source 2
+	#define lchange_div 4
+	
+	#define lmem_source 1 // 0 : PLL0 , 1 : PLL1	
+	#define lmem_div	4
+
+	
+	*(volatile unsigned long *)0xB0301004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xB0301004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xB0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xB0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xB030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lchange_div-1) << 4)|lchange_source); // CKC-CLKCTRL2 - Mem
+
+	//PLL1
+	*(volatile unsigned long *)0xB0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xB0400024= 0x00001E01;		// pms - pllout_360M
+	*(volatile unsigned long *)0xB0400024= 0x80001E01;		//	pll pwr on
+	
+//Init DDR2 
+	*(volatile unsigned long *)0xB030100C = 0x00210012; 		// config0 cas 10bit, ras 13bit , AP bit 10, Burst 4, 2chips
+
+	*(volatile unsigned long *) 0xB0303000 |= 0x00800000;		// bit23 enable -synopt enable
+	*(volatile unsigned long *) 0xB0303010 |= 0x00800000;		// bit23 enable -synopt enable
+
+	*(volatile unsigned long *)0xB030104C= 0x000002D1;
+	*(volatile unsigned long *)0xB0301010 = 0x000003E8; // refresh_prd = 1000
+
+	*(volatile unsigned long *)0xB0301014 = 0x00000006; // cas_latency = 3
+
+	*(volatile unsigned long *)0xB030101C = 0x00000002; // tMRD 2tck 
+	*(volatile unsigned long *)0xB0301020 = 0x0000000A; // tRAS 42ns
+	*(volatile unsigned long *)0xB0301024 = 0x0000000F; // tRC 60ns
+	*(volatile unsigned long *)0xB0301028 = 0x00000014; // tRCD 18ns
+	*(volatile unsigned long *)0xB030102c = 0x00000E11; // tRFC 72ns
+	*(volatile unsigned long *)0xB0301030 = 0x00000014; // tRP 18ns
+	*(volatile unsigned long *)0xB0301034 = 0x00000001; // tRRD 12ns
+	*(volatile unsigned long *)0xB0301038 = 0x00000002; // tWR 15ns
+	*(volatile unsigned long *)0xB030103c = 0x00000001; // tWTR 1tck
+	*(volatile unsigned long *)0xB0301040 = 0x00000002; // tXP=3
+	*(volatile unsigned long *)0xB0301044 = 0x00000016; // tXSR 120ns
+	*(volatile unsigned long *)0xB0301048 = 0x00000032; // tESR=200
+
+	*(volatile unsigned long *)0xB0301200 = 0x000040F0; // Chip 0
+	
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	while (!((*(volatile unsigned long *)0xB030442c) & (1)));	// Wait until Calibration completion without error
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+
+	
+	*(volatile unsigned long *)0xB0301008 = 0x00000032; //MRS
+	*(volatile unsigned long *)0xB0301008 = 0x000a0000;//EMRS
+	*(volatile unsigned long *)0xB0301008 = 0x00080032;
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+//Change MEM Source 
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+	
+	*(volatile unsigned long *) 0xB0301004=0x00000000; // PL341_GO
+	while (((*(volatile unsigned long *)0xB0301000) & (0x03)) != 1);	// Wait until READY
+	
+}
+
+void init_clockchange95Mhz(void)
+{
+	#define lchange_source 2
+	#define lchange_div 4
+	
+	#define lmem_source 1 // 0 : PLL0 , 1 : PLL1	
+	#define lmem_div	4
+
+	
+	*(volatile unsigned long *)0xB0301004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xB0301004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xB0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xB0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xB0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xB030302C &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lchange_div-1) << 4)|lchange_source); // CKC-CLKCTRL2 - Mem
+
+	//PLL1
+	*(volatile unsigned long *)0xB0400024= 0x0000fa03;		// pll pwr off
+	*(volatile unsigned long *)0xB0400024= 0x00005F03;		// pms - pllout_380M
+	*(volatile unsigned long *)0xB0400024= 0x80005F03;		//	pll pwr on
+	
+//Init DDR2 
+	*(volatile unsigned long *)0xB030100C = 0x00210012; 		// config0 cas 10bit, ras 13bit , AP bit 10, Burst 4, 2chips
+
+	*(volatile unsigned long *) 0xB0303000 |= 0x00800000;		// bit23 enable -synopt enable
+	*(volatile unsigned long *) 0xB0303010 |= 0x00800000;		// bit23 enable -synopt enable
+
+	*(volatile unsigned long *)0xB030104C= 0x000002D1;
+	*(volatile unsigned long *)0xB0301010 = 0x000003E8; // refresh_prd = 1000
+
+#if defined(DRAM_CAS3)
+	*(volatile unsigned long *)0xB0301014 = 0x00000006; // cas_latency = 3
+#else
+	*(volatile unsigned long *)0xB0301014 = 0x00000004; // cas_latency = 2
+#endif					
+
+	*(volatile unsigned long *)0xB030101C = 0x00000002; // tMRD 2tck 
+	*(volatile unsigned long *)0xB0301020 = 0x0000000A; // tRAS 42ns
+	*(volatile unsigned long *)0xB0301024 = 0x0000000F; // tRC 60ns
+	*(volatile unsigned long *)0xB0301028 = 0x00000014; // tRCD 18ns
+	*(volatile unsigned long *)0xB030102c = 0x00000E11; // tRFC 72ns
+	*(volatile unsigned long *)0xB0301030 = 0x00000014; // tRP 18ns
+	*(volatile unsigned long *)0xB0301034 = 0x00000001; // tRRD 12ns
+	*(volatile unsigned long *)0xB0301038 = 0x00000002; // tWR 15ns
+	*(volatile unsigned long *)0xB030103c = 0x00000001; // tWTR 1tck
+	*(volatile unsigned long *)0xB0301040 = 0x00000002; // tXP=3
+	*(volatile unsigned long *)0xB0301044 = 0x00000016; // tXSR 120ns
+	*(volatile unsigned long *)0xB0301048 = 0x00000032; // tESR=200
+
+	*(volatile unsigned long *)0xB0301200 = 0x000040F0; // Chip 0
+	
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	while (!((*(volatile unsigned long *)0xB030442c) & (1)));	// Wait until Calibration completion without error
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xB0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+
+	
+	*(volatile unsigned long *)0xB0301008 = 0x00000032; //MRS
+	*(volatile unsigned long *)0xB0301008 = 0x000a0000;//EMRS
+	*(volatile unsigned long *)0xB0301008 = 0x00080032;
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+	*(volatile unsigned long *)0xB0301008 = 0x00040032;	
+
+//Change MEM Source 
+
+
+	*(volatile unsigned long *)0xB0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+
+	
+	*(volatile unsigned long *) 0xB0301004=0x00000000; // PL341_GO
+	while (((*(volatile unsigned long *)0xB0301000) & (0x03)) != 1);	// Wait until READY
+
+}
+#endif
Index: linux-2.6.29/arch/arm/mach-tcc8900/tcc8900/tcc_ckcmddr_20to90.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/tcc8900/tcc_ckcmddr_20to90.h	2010-04-07 13:00:58.000000000 -0400
@@ -0,0 +1,29 @@
+
+#if defined(_LINUX_)
+    #include <bsp.h>
+    #include "../../../../../../bootloader/tcboot/include/ddr.h"
+#else
+#include "windows.h"
+
+#include "bsp.h"
+#include "tca_ckc.h"
+#endif
+
+#if defined(DRAM_MDDR)
+extern void init_clockchange25Mhz(void);
+extern void init_clockchange30Mhz(void);
+extern void init_clockchange35Mhz(void);
+extern void  init_clockchange40Mhz(void);
+extern void init_clockchange45Mhz(void);
+extern void init_clockchange50Mhz(void);
+extern void init_clockchange55Mhz(void);
+extern void init_clockchange60Mhz(void);
+extern void init_clockchange65Mhz(void);
+extern void init_clockchange70Mhz(void);
+extern void init_clockchange75Mhz(void);
+extern void init_clockchange80Mhz(void);
+extern void init_clockchange85Mhz(void);
+extern void init_clockchange90Mhz(void);
+extern void init_clockchange95Mhz(void);
+#endif
+
Index: linux-2.6.29/arch/arm/mach-tcc8900/tcc_ckc_ctrl.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/tcc_ckc_ctrl.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,744 @@
+/*
+ * linux/arch/arm/mach-tcc8900/tcc_ckc_ctrl.c
+ *
+ * Author:  <linux@telechips.com>
+ * Created: 10th February, 2009
+ * Description: Interrupt handler for Telechips TCC8900 chipset
+ *
+ * Copyright (C) Telechips, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <mach/hardware.h>
+#include <asm/tlbflush.h>
+#include <asm/cacheflush.h>
+#include <linux/spinlock.h>
+#include <linux/sched.h>
+#include <linux/tick.h>
+#include <linux/time.h>
+
+#if defined(CONFIG_MACH_TCC8900)
+#include <bsp.h>
+#include <linux/tcc_ioctl.h>
+#include <mach/tcc_ckc_ctrl.h>
+#include "tcc/tcc_ckcddr2_141to190.h"
+#include "tcc/tcc_ckcddr2_200to290.h"
+#include "tcc/tcc_ckcddr2_300to330.h"
+#include "tcc/tcc_ckcmddr_100to160.h"
+#include "tcc/tcc_ckcmddr_20to90.h"
+#endif
+
+#if 0
+//#define dbg(x...) printk(KERN_DEBUG "tcc uart: ");
+#define dbg printk
+#else /* no debug */
+#define dbg(x...) do {} while(0)
+#endif
+
+#define FBUS_STEP_NUM 34
+#define FCORE_STEP_NUM 60
+
+typedef void (*lpfunc)(void);
+lpfunc lpSelfRefresh;
+//#define SRAM_COPY_ADDR				0xF0800000
+#define SRAM_COPY_ADDR				0xEFF00000
+#define SRAM_COPY_FUNC_SIZE			0x600
+
+unsigned int retstack = 0;
+unsigned long flags;
+
+unsigned int FbusStepValue[FBUS_STEP_NUM] = {
+    2640000, // PLL3
+    2340000,
+    1760000, // PLL3
+    1560000,
+    1320000, // PLL3
+    1170000,
+    1056000, // PLL3
+    936000,
+    880000, // PLL3
+    780000,
+    754285, // PLL3
+    668571,
+    660000, // PLL3
+    586666, // PLL3
+    585000,
+    528000, // PLL3
+    520000,
+    480000, // PLL3
+    468000,
+    440000, // PLL3
+    425454,
+    406153, // PLL3
+    390000,
+    377142, // PLL3
+    360000,
+    352000, // PLL3
+    334285,
+    330000, // PLL3
+    312000,
+    292500,
+    60000, // XIN
+    30000, // XIN
+    10000, // XIN
+};
+
+unsigned int FcoreStepValue[FCORE_STEP_NUM] = {
+	6000000,
+	5062500,4860000,4725000,4556250,4387500,4252500,4050000,3948750,3780000,3712500,
+	3645000,3510000,3375000,3240000,3037500,2970000,2835000,2700000,2632500,2430000,
+	2362500,2227500,2160000,2025000,1890000,1822500,1750000,1687500,1620000,1518750,
+	1485000,1417500,1350000 ,1215000,1125000,1080000,1012500, 960000 ,945000, 907500 ,
+	883750 ,840000  , 810000  ,787500  ,757500 ,730000  ,712500  ,660000  ,631250,607500  ,
+	577500 ,540000  , 495000  ,450000  ,405000 ,378750  ,360000  ,330000 ,270000
+};
+
+unsigned int FcorePllValue[FCORE_STEP_NUM] = {
+	6000000,
+	5400000,	4860000,	5400000,	4860000,	5400000,	4860000,	4320000,	4860000,	4320000,	5400000,
+	4860000,	4320000,	5400000,	3240000,	3240000,	4320000,	3240000,	5400000,	3240000,	3240000,
+	5400000,	3240000,	2160000,	2160000,	2160000,	3240000,	2160000,	5400000,	2160000,	4860000,
+	2160000,3240000,	2160000,	2160000,	1800000,	2160000,	3240000,	1920000,	2160000,	1320000,
+	2020000,	1920000,	2160000,	1800000,	2020000,	1460000,	1900000,	1320000,	2020000,	3240000,
+	1320000,	1440000,	1320000,	1440000,	2160000, 2020000, 1440000,1320000,1440000,
+};
+
+unsigned int FcoreDividerValue[FCORE_STEP_NUM] = {
+	16,
+	15,	16,	14,	15,	13,	14,	15,	13,	14,	11,
+	12,	13,	10,	16,	15,	11,	14,	8,	13,	12,
+	7,	11,	16,	15,	14,	9,	13,	5,	12 ,  5, 
+	11,	7,	10,	9,	10,	8,	5,	8,	7,	11,
+	7,	7,	6,	7,	6,	8,	6,	8,	5,	3,
+	7,	6,	6,	5,	3,    3,     4,     4,   3
+
+};
+
+
+
+
+void ckc_delay(unsigned int cnt)
+{
+    volatile unsigned int count;
+	count = cnt*10000;
+    while(count--);
+}
+
+
+void ckc_etcblock(unsigned int lMask)
+{
+	volatile PUSBOTGCFG  pOTGCFG  = (volatile PUSBOTGCFG)tcc_p2v(HwUSBOTGCFG_BASE);
+	volatile PGPUGRPBUSCONFIG  pGPUGRPBUSCONFIG  = (volatile PGPUGRPBUSCONFIG)tcc_p2v(HwGRPBUS_BASE);
+	
+// Disable
+	if(lMask & ETCMASK_USBPHYOFF)
+	{
+        dbg("%s: ETC_USBPHYOFF\n", __func__);
+		BITCSET(pOTGCFG->UPCR2,Hw10|Hw9,Hw9);
+		pOTGCFG->UPCR0 = 0x4840;
+		pOTGCFG->UPCR0 = 0x6940;
+	}
+
+	if(lMask & ETCMASK_3DGPUOFF)
+	{
+        dbg("%s: ETCMASK_3DGPUOFF\n", __func__);
+		pGPUGRPBUSCONFIG->GRPBUS_PWRDOWN |= Hw0;
+	}
+	
+	if(lMask & ETCMASK_OVERLAYMIXEROFF)
+	{
+        dbg("%s: ETCMASK_OVERLAYMIXEROFF\n", __func__);
+		pGPUGRPBUSCONFIG->GRPBUS_PWRDOWN |= Hw1;
+	}
+
+//Enable 
+	if(lMask & ETCMASK_OVERLAYMIXERON)
+	{
+        dbg("%s: ETCMASK_OVERLAYMIXEROFF\n", __func__);
+		pGPUGRPBUSCONFIG->GRPBUS_PWRDOWN  &= ~Hw1;
+	}
+
+	if(lMask & ETCMASK_3DGPUON)
+	{
+        dbg("%s: ETCMASK_3DGPUON\n", __func__);
+		pGPUGRPBUSCONFIG->GRPBUS_PWRDOWN &= ~Hw0;
+	}
+
+	if(lMask & ETCMASK_USBPHYON)
+	{
+        dbg("%s: ETC_USBPHYON\n", __func__);
+		BITCSET(pOTGCFG->UPCR2,Hw10|Hw9,0);
+		pOTGCFG->UPCR0 = 0x2842;
+	}
+}
+
+
+void int_alldisable(void)
+{
+    /*
+    volatile unsigned int count;
+    count = 1;
+    while(count--);
+    */
+    local_irq_save(flags);
+    local_irq_disable();
+
+}
+
+void int_restore(void)
+{
+    /*
+    volatile unsigned int count;
+    count = 1;
+    while(count--);
+    */
+
+    local_irq_restore(flags);
+}
+
+
+
+static void init_copychangeclock(unsigned int lbusvalue)
+{
+
+	volatile unsigned int	*fptr;
+	volatile unsigned int	*p;
+	int 					i;
+
+#if defined(CONFIG_DRAM_DDR2)
+	if(lbusvalue == 1250000) 
+		fptr = (volatile unsigned int*)init_clockchange125Mhz;
+    else if(lbusvalue == 1300000)
+		fptr = (volatile unsigned int*)init_clockchange130Mhz;
+    else if(lbusvalue == 1350000) 
+		fptr = (volatile unsigned int*)init_clockchange135Mhz;
+    else if(lbusvalue == 1410000) 
+		fptr = (volatile unsigned int*)init_clockchange141Mhz;
+	else if(lbusvalue == 1450000) 
+		fptr = (volatile unsigned int*)init_clockchange145Mhz;
+	else if(lbusvalue == 1500000) 
+		fptr = (volatile unsigned int*)init_clockchange150Mhz;
+	else if(lbusvalue == 1600000) 
+		fptr = (volatile unsigned int*)init_clockchange160Mhz;
+	else if(lbusvalue == 1700000) 
+		fptr = (volatile unsigned int*)init_clockchange170Mhz;
+	else if(lbusvalue == 1800000) 
+		fptr = (volatile unsigned int*)init_clockchange180Mhz;
+	else if(lbusvalue == 1900000) 
+		fptr = (volatile unsigned int*)init_clockchange190Mhz;
+	else if(lbusvalue == 2000000) 
+		fptr = (volatile unsigned int*)init_clockchange200Mhz;
+	else if(lbusvalue == 2100000) 
+		fptr = (volatile unsigned int*)init_clockchange210Mhz;
+	else if(lbusvalue == 2200000) 
+		fptr = (volatile unsigned int*)init_clockchange220Mhz;
+	else if(lbusvalue == 2300000) 
+		fptr = (volatile unsigned int*)init_clockchange230Mhz;
+	else if(lbusvalue == 2400000) 
+		fptr = (volatile unsigned int*)init_clockchange240Mhz;
+	else if(lbusvalue == 2500000) 
+		fptr = (volatile unsigned int*)init_clockchange250Mhz;
+	else if(lbusvalue == 2600000) 
+		fptr = (volatile unsigned int*)init_clockchange260Mhz;
+	else if(lbusvalue == 2700000) 
+		fptr = (volatile unsigned int*)init_clockchange270Mhz;
+	else if(lbusvalue == 2800000) 
+		fptr = (volatile unsigned int*)init_clockchange280Mhz;
+	else if(lbusvalue == 2900000) 
+		fptr = (volatile unsigned int*)init_clockchange290Mhz;
+	else if(lbusvalue == 3000000) 
+		fptr = (volatile unsigned int*)init_clockchange300Mhz;
+	else if(lbusvalue == 3120000) 
+		fptr = (volatile unsigned int*)init_clockchange312Mhz;
+	else if(lbusvalue == 3200000) 
+		fptr = (volatile unsigned int*)init_clockchange320Mhz;
+	else if(lbusvalue == 3300000) 
+		fptr = (volatile unsigned int*)init_clockchange330Mhz;
+	else
+		fptr = (volatile unsigned int*)init_clockchange190Mhz;
+
+#elif defined(CONFIG_DRAM_MDDR)
+	if(lbusvalue == 250000) // idle
+		fptr = (volatile unsigned int*)init_clockchange25Mhz;
+	else if(lbusvalue == 305000) 
+		fptr = (volatile unsigned int*)init_clockchange30Mhz;
+	else if(lbusvalue == 352500) 
+		fptr = (volatile unsigned int*)init_clockchange35Mhz;
+	else if(lbusvalue == 400000) 
+		fptr = (volatile unsigned int*)init_clockchange40Mhz;
+	else if(lbusvalue == 450000) 
+		fptr = (volatile unsigned int*)init_clockchange45Mhz;
+	else if(lbusvalue == 500000) 
+		fptr = (volatile unsigned int*)init_clockchange50Mhz;
+	else if(lbusvalue == 550000) 
+		fptr = (volatile unsigned int*)init_clockchange55Mhz;
+	else if(lbusvalue == 600000) 
+		fptr = (volatile unsigned int*)init_clockchange60Mhz;
+	else if(lbusvalue == 650000) 
+		fptr = (volatile unsigned int*)init_clockchange65Mhz;
+	else if(lbusvalue == 705000) 
+		fptr = (volatile unsigned int*)init_clockchange70Mhz;
+	else if(lbusvalue == 750000) 
+		fptr = (volatile unsigned int*)init_clockchange75Mhz;
+	else if(lbusvalue == 800000) 
+		fptr = (volatile unsigned int*)init_clockchange80Mhz;
+	else if(lbusvalue == 850000) 
+		fptr = (volatile unsigned int*)init_clockchange85Mhz;
+	else if(lbusvalue == 900000) 
+		fptr = (volatile unsigned int*)init_clockchange90Mhz;
+	else if(lbusvalue == 950000) 
+		fptr = (volatile unsigned int*)init_clockchange95Mhz;
+	else if(lbusvalue == 1000000) 
+		fptr = (volatile unsigned int*)init_clockchange100Mhz;
+	else if(lbusvalue == 1050000) 
+		fptr = (volatile unsigned int*)init_clockchange105Mhz;
+	else if(lbusvalue == 1100000) 
+		fptr = (volatile unsigned int*)init_clockchange110Mhz;
+	else if(lbusvalue == 1150000) 
+		fptr = (volatile unsigned int*)init_clockchange115Mhz;
+	else if(lbusvalue == 1200000) 
+		fptr = (volatile unsigned int*)init_clockchange120Mhz;
+	else if(lbusvalue == 1250000) 
+		fptr = (volatile unsigned int*)init_clockchange125Mhz;
+	else if(lbusvalue == 1300000) 
+		fptr = (volatile unsigned int*)init_clockchange130Mhz;
+	else if(lbusvalue == 1350000) 
+		fptr = (volatile unsigned int*)init_clockchange135Mhz;
+	else if(lbusvalue == 1400000) 
+		fptr = (volatile unsigned int*)init_clockchange140Mhz;
+	else if(lbusvalue == 1450000) 
+		fptr = (volatile unsigned int*)init_clockchange145Mhz;
+	else if(lbusvalue == 1500000) 
+		fptr = (volatile unsigned int*)init_clockchange150Mhz;
+	else if(lbusvalue == 1560000) 
+		fptr = (volatile unsigned int*)init_clockchange156Mhz;
+	else if(lbusvalue == 1600000) 
+		fptr = (volatile unsigned int*)init_clockchange160Mhz;
+	else
+		fptr = (volatile unsigned int*)init_clockchange160Mhz;
+#endif
+
+
+	lpSelfRefresh = (lpfunc)(SRAM_COPY_ADDR);
+	
+	p = (volatile unsigned int*)SRAM_COPY_ADDR;
+	
+	for (i = 0;i < (SRAM_COPY_FUNC_SIZE);i++)
+	{
+		*p = *fptr;
+		p++;
+		fptr++;
+	}
+	
+	while(--i);
+	
+	// Jump to Function Start Point
+	lpSelfRefresh();
+}
+
+void ckc_set_peri(struct ckc_ioctl st)
+{
+    int_alldisable();
+    tca_ckc_setperi(st.in_ckc.pckcname, st.in_ckc.pckcenable, 
+                    st.in_ckc.pckcfreq, st.in_ckc.pckcsource);
+    int_restore();
+}
+
+int ckc_get_peri(struct ckc_ioctl st)
+{
+    return tca_ckc_getperi(st.in_ckc.pckcname);
+}
+
+int ckc_set_peribus(struct ckc_ioctl st)
+{
+    return tca_ckc_setiobus(st.in_ckc.prbname, st.in_ckc.mode);
+}
+
+int ckc_get_peribus(struct ckc_ioctl st)
+{
+    return tca_ckc_getiobus(st.in_ckc.prbname);
+}
+
+void ckc_set_periswreset(struct ckc_ioctl st)
+{
+    tca_ckc_set_iobus_swreset(st.in_ckc.prbname, OFF);
+    tca_ckc_set_iobus_swreset(st.in_ckc.prbname, ON);
+}
+
+void ckc_set_fbusswreset(struct ckc_ioctl st)
+{
+    tca_ckc_setswreset(st.in_ckc.fbusname, ON);
+    ckc_delay(100);
+    tca_ckc_setswreset(st.in_ckc.fbusname, OFF);
+}
+
+void ckc_set_cpu(struct ckc_ioctl st)
+{
+    int_alldisable();
+
+    tca_ckc_setcpu(st.in_ckc.cpudivider);
+    st.out_ckc.currentsysfreq = tca_ckc_getpll(0);
+    st.out_ckc.currentcpufreq = tca_ckc_getcpu();
+    st.out_ckc.currentbusfreq = tca_ckc_getbus();
+
+    int_restore();
+}
+
+void ckc_set_smui2c(struct ckc_ioctl st)
+{
+    tca_ckc_setsmui2c(st.in_ckc.pckcfreq);
+}
+
+unsigned int ckc_get_cpu(struct ckc_ioctl st)
+{
+    return tca_ckc_getcpu();
+}
+
+unsigned int ckc_get_bus(struct ckc_ioctl st)
+{
+    return tca_ckc_getbus();
+}
+
+void ckc_get_validpllinfo(struct ckc_ioctl st)
+{
+    tca_ckc_validpll(st.out_ckc.validpll);
+}
+
+void ckc_set_fbus(struct ckc_ioctl st)
+{
+    tca_ckc_setfbusctrl(st.in_ckc.fbusname, st.in_ckc.fbusenable,
+                        st.in_ckc.mode, st.in_ckc.fbusfreq,
+                        st.in_ckc.fbussource);
+}
+
+int ckc_get_fbus(struct ckc_ioctl st)
+{
+    return tca_ckc_getfbusctrl(st.in_ckc.fbusname);
+
+}
+
+void ckc_set_pmupower(struct ckc_ioctl st)
+{
+#if defined(CONFIG_TCC_R_AX)
+        if(st.in_ckc.mode == 0)
+        {
+            st.in_ckc.fbusenable = DISABLE;
+            st.in_ckc.mode = NORMAL_MD;
+            tca_ckc_setfbusctrl(st.in_ckc.fbusname, st.in_ckc.fbusenable, st.in_ckc.mode, st.in_ckc.fbusfreq, st.in_ckc.fbussource);
+            tca_ckc_setswreset(st.in_ckc.fbusname,ON);
+            ckc_delay(100);
+            tca_ckc_setswreset(st.in_ckc.fbusname,OFF);
+            tca_ckc_setpmupwroff(st.in_ckc.pmuoffname, st.in_ckc.fbusenable);
+        } else {
+            tca_ckc_setswreset(st.in_ckc.fbusname,ON);
+            ckc_delay(100);
+            tca_ckc_setswreset(st.in_ckc.fbusname,OFF);
+            tca_ckc_setpmupwroff(st.in_ckc.pmuoffname,ENABLE);			
+
+            st.in_ckc.fbusenable = ENABLE;
+            st.in_ckc.mode = NORMAL_MD;					
+            tca_ckc_setfbusctrl(st.in_ckc.fbusname,st.in_ckc.fbusenable,st.in_ckc.mode,st.in_ckc.fbusfreq,st.in_ckc.fbussource);					
+        }			
+#endif
+}
+
+void ckc_get_pmupower(struct ckc_ioctl st)    
+{
+    tca_ckc_getpmupwroff(st.in_ckc.pmuoffname);
+}
+
+void ckc_get_clockinfo(struct ckc_ioctl st)
+{
+    st.out_ckc.currentsysfreq = tca_ckc_getpll(0);
+    st.out_ckc.currentcpufreq = tca_ckc_getcpu();
+    st.out_ckc.currentbusfreq = tca_ckc_getbus();
+}
+
+void ckc_set_changefbus(struct ckc_ioctl st)
+{
+    int i, validFlag; 
+    // Except : FCORE_CPU, FMEM_BUS, FBUS_IOB
+    // Change Fbus : FBUS_DDI, FBUS_GRP, FBUS_VBUS, FBUS_VCODEC, FBUS_SMU
+    //
+    int_alldisable();
+    local_flush_tlb_all();
+    flush_cache_all();
+
+    if(st.in_ckc.fbusname != CLKCTRL0 && st.in_ckc.fbusname != CLKCTRL2 )
+    {
+        //if(st.in_ckc.fbusfreq == 60000 || st.in_ckc.fbusfreq == 0)
+        if( st.in_ckc.fbusfreq == 0)
+        {
+#if defined(CONFIG_TCC_R_AX)
+            st.in_ckc.fbusenable = DISABLE;
+            st.in_ckc.mode = NORMAL_MD;		
+            
+                if(st.in_ckc.fbusname == CLKCTRL1)
+                {
+                    st.in_ckc.pmuoffname = PMU_DDIBUS;
+                    validFlag = 0;
+                }
+                else if(st.in_ckc.fbusname == CLKCTRL5)
+                {
+                    st.in_ckc.pmuoffname = PMU_VIDEOBUS;
+                    validFlag = 1;
+                }
+                else if(st.in_ckc.fbusname == CLKCTRL3)
+                {
+                    st.in_ckc.pmuoffname = PMU_GRAPHICBUS;
+                    validFlag = 1;
+                }			
+                else 
+                    validFlag = 0;
+
+                if(validFlag == 1)
+                {
+                    if(st.in_ckc.fbusname == CLKCTRL5)
+                    {
+                        tca_ckc_setswreset(CLKCTRL5,ON);							
+                        tca_ckc_setswreset(CLKCTRL6,ON);		
+
+                        ckc_delay(10);
+                        tca_ckc_setfbusctrl(st.in_ckc.fbusname,st.in_ckc.fbusenable,st.in_ckc.mode,st.in_ckc.fbusfreq,st.in_ckc.fbussource);
+
+                        tca_ckc_setpmupwroff(PMU_VIDEOBUS,DISABLE);	
+                    }
+                    else
+                    {
+                        tca_ckc_setswreset(st.in_ckc.fbusname,ON);							
+                        ckc_delay(10);
+                        tca_ckc_setfbusctrl(st.in_ckc.fbusname,st.in_ckc.fbusenable,st.in_ckc.mode,st.in_ckc.fbusfreq,st.in_ckc.fbussource);
+                        tca_ckc_setpmupwroff(st.in_ckc.pmuoffname,DISABLE);	
+                    }
+
+                    if(st.in_ckc.fbusname == CLKCTRL5)
+                    {
+                        tca_ckc_setswreset(CLKCTRL6,OFF);							
+                        tca_ckc_setswreset(CLKCTRL5,OFF);							
+                    }
+                    else
+                        tca_ckc_setswreset(st.in_ckc.fbusname,OFF);							
+
+                }
+                else
+                {
+                    tca_ckc_setswreset(st.in_ckc.fbusname,ON);							
+                    ckc_delay(10);
+                    tca_ckc_setfbusctrl(st.in_ckc.fbusname,st.in_ckc.fbusenable,st.in_ckc.mode,st.in_ckc.fbusfreq,st.in_ckc.fbussource);
+                    tca_ckc_setswreset(st.in_ckc.fbusname,OFF);							
+                }
+        #else
+            //tca_ckc_setswreset(st.in_ckc.fbusname);
+            validFlag = 1;
+            tca_ckc_setfbusctrl(st.in_ckc.fbusname,ENABLE,NORMAL_MD,60000,DIRECTXIN);
+        #endif
+        }
+        else
+        {
+#if defined(CONFIG_TCC_R_AX)
+            if(st.in_ckc.fbusname == CLKCTRL1)
+            {
+                st.in_ckc.pmuoffname = PMU_DDIBUS;
+                validFlag = 0;
+            }
+            else if(st.in_ckc.fbusname == CLKCTRL5)
+            {
+                st.in_ckc.pmuoffname = PMU_VIDEOBUS;
+                validFlag = 1;
+            }
+            else if(st.in_ckc.fbusname == CLKCTRL3)
+            {
+                st.in_ckc.pmuoffname = PMU_GRAPHICBUS;
+                validFlag = 1;
+            }			
+            else 
+                validFlag = 0;
+
+            if(validFlag == 1)
+            {
+                if(st.in_ckc.fbusname == CLKCTRL5)
+                {
+                    tca_ckc_setswreset(CLKCTRL5,ON);							
+                    tca_ckc_setswreset(CLKCTRL6,ON);							
+                    tca_ckc_setpmupwroff(PMU_VIDEOBUS,ENABLE);			
+                }
+                else
+                {
+                    tca_ckc_setswreset(st.in_ckc.fbusname,ON);	
+                    tca_ckc_setpmupwroff(st.in_ckc.pmuoffname,ENABLE);			
+                }
+                
+                ckc_delay(100);
+                if(st.in_ckc.fbusname == CLKCTRL5)
+                {
+                    tca_ckc_setswreset(CLKCTRL6,OFF);							
+                    tca_ckc_setswreset(CLKCTRL5,OFF);							
+                }
+                else
+                    tca_ckc_setswreset(st.in_ckc.fbusname,OFF);							
+            }
+        #endif
+            {
+                //validFlag = 0;
+                for(i = 0; i < FBUS_STEP_NUM; i++)
+                {
+                    if(st.in_ckc.fbusfreq == FbusStepValue[i] ||  st.in_ckc.fbusfreq == 3300000)
+                    {
+                        validFlag = 1;
+                        break;
+                    }
+                }
+                
+                if( validFlag == 1)
+                {
+                    if(i <= 12)
+                    {
+                        if((i%2) == 1)
+                            st.in_ckc.fbussource = DIRECTPLL2;
+                        else
+                            st.in_ckc.fbussource = DIRECTPLL3;
+                    }
+                    else
+                    {
+                        if(i >= FBUS_STEP_NUM-3)
+                        {
+                            st.in_ckc.fbussource = DIRECTXIN;
+                        }
+                        else if(i == (FBUS_STEP_NUM-4))
+                        {
+                            st.in_ckc.fbussource = DIRECTPLL2;
+                        }
+                        else
+                        {
+                            if((i%2) == 1)
+                                st.in_ckc.fbussource = DIRECTPLL3;
+                            else
+                                st.in_ckc.fbussource = DIRECTPLL2;
+                        }
+                    }		
+                }
+            }
+            
+            if( validFlag == 1)
+            {
+                st.in_ckc.fbusenable = ENABLE;
+                st.in_ckc.mode = NORMAL_MD;					
+                tca_ckc_setfbusctrl(st.in_ckc.fbusname,st.in_ckc.fbusenable,st.in_ckc.mode,st.in_ckc.fbusfreq,st.in_ckc.fbussource);					
+            }	
+        }
+    int_restore();				
+    }
+}
+
+void ckc_set_changemem(struct ckc_ioctl st)
+{
+    volatile PLCDC	pLCDC_BASE0 = (volatile PLCDC)tcc_p2v(HwLCDC0_BASE);
+    volatile PLCDC	pLCDC_BASE1 = (volatile PLCDC)tcc_p2v(HwLCDC1_BASE);
+    volatile PTIMER	pTIMER	= (volatile PTIMER)tcc_p2v(HwTMR_BASE);
+
+    // Off LCD
+    pLCDC_BASE1->LCTRL &= ~Hw0;
+    pLCDC_BASE0->LCTRL &= ~Hw0;
+
+    int_alldisable();
+    local_flush_tlb_all();
+    flush_cache_all();
+
+    pTIMER->TC32EN &= ~Hw24;
+    
+    retstack = arm_changestack();
+
+    init_copychangeclock(st.in_ckc.busvalue);
+
+    arm_restorestack(retstack);
+
+    pTIMER->TC32EN |= Hw24;
+
+    int_restore();				
+
+    //	LCDC Power Up
+    pLCDC_BASE0->LCTRL |= Hw0;
+    pLCDC_BASE1->LCTRL |= Hw0;
+}
+
+void ckc_set_changecpu(struct ckc_ioctl st)
+{
+    int i, validFlag; 
+
+    int_alldisable();
+
+    for(i = 0; i < FCORE_STEP_NUM; i++)
+    {	
+        if(st.in_ckc.cpuvalue == FcoreStepValue[i]) {
+            validFlag = 1;
+            break;
+        }
+    }
+    
+    if( validFlag == 1)
+    {
+        // Change pll
+        if(tca_ckc_getpll(0) != FcorePllValue[i])
+            tca_ckc_setpll(FcorePllValue[i],0);
+        
+        tca_ckc_setcpu(FcoreDividerValue[i]);
+    }
+    int_restore();				
+}
+
+void ckc_set_ddipwdn(struct ckc_ioctl st)
+{
+    tca_ckc_setddipwdn(st.in_ckc.ddipdname, st.in_ckc.mode);
+}
+
+void ckc_get_ddipwdn(struct ckc_ioctl st)
+{
+    st.out_ckc.retVal = tca_ckc_getddipwdn(st.in_ckc.ddipdname);
+}
+
+void ckc_set_etcblock(struct ckc_ioctl st)
+{
+    ckc_etcblock(st.in_ckc.etcblock);
+}
+
+
+EXPORT_SYMBOL(ckc_set_peri);
+EXPORT_SYMBOL(ckc_get_peri);
+EXPORT_SYMBOL(ckc_set_peribus);
+EXPORT_SYMBOL(ckc_get_peribus);
+EXPORT_SYMBOL(ckc_set_periswreset);
+EXPORT_SYMBOL(ckc_set_fbusswreset);
+EXPORT_SYMBOL(ckc_set_cpu);
+EXPORT_SYMBOL(ckc_set_smui2c);
+EXPORT_SYMBOL(ckc_get_cpu);
+EXPORT_SYMBOL(ckc_get_bus);
+EXPORT_SYMBOL(ckc_get_validpllinfo);
+EXPORT_SYMBOL(ckc_set_fbus);
+EXPORT_SYMBOL(ckc_get_fbus);
+EXPORT_SYMBOL(ckc_set_pmupower);
+EXPORT_SYMBOL(ckc_get_pmupower);
+EXPORT_SYMBOL(ckc_get_clockinfo);
+EXPORT_SYMBOL(ckc_set_changefbus);
+EXPORT_SYMBOL(ckc_set_changemem);
+EXPORT_SYMBOL(ckc_set_changecpu);
+EXPORT_SYMBOL(ckc_set_ddipwdn);
+EXPORT_SYMBOL(ckc_get_ddipwdn);
+EXPORT_SYMBOL(ckc_set_etcblock);
Index: linux-2.6.29/arch/arm/mach-tcc8900/time.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/mach-tcc8900/time.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,135 @@
+/*
+ * linux/arch/arm/mach-tcc8900/time.c
+ *
+ * Author:  <linux@telechips.com>
+ * Created: 10th Feb, 2009
+ * Description: TCC8900 Timers
+ *
+ * Copyright (C) Telechips, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/* 
+ *  Returns elapsed usecs since last system timer interrupt
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/irq.h>	// for setup_irq()
+#include <linux/mm.h>	// for PAGE_ALIGN
+
+#include <asm/io.h>
+#include <asm/leds.h>
+#include <asm/mach/time.h>
+
+#include <bsp.h>
+
+#include <linux/tcc_ll.h>
+
+#define TCC_TIMER_FREQ (12 * 1000 * 1000) /* 12M */ 
+#define TCC_ENABLE_BIT(X) (1 << (X))
+
+#if (TCC_TIMER_FREQ < (1000 * 1000))
+#   define PRESCALE_TO_MICROSEC(X) ((X) * ((1000 * 1000) / (TCC_TIMER_FREQ)))
+#else
+#   define PRESCALE_TO_MICROSEC(X) ((X) / ((TCC_TIMER_FREQ) / (1000 * 1000)))
+#endif
+
+// Global 
+static volatile PTIMER pTIMER;
+static volatile PPIC pPIC;
+
+/*
+ * Returns elapsed usecs since last system timer interrupt
+ */
+static unsigned long tcc8900_timer_gettimeoffset(void)
+{
+    return PRESCALE_TO_MICROSEC(pTIMER->TC32PCNT);
+}
+
+static irqreturn_t tcc8900_timer_interrupt(int irq, void *dev_id)
+{
+    timer_tick();
+
+    BITSET(pPIC->CLR0, TCC_ENABLE_BIT(irq));
+    if(pTIMER->TC32IRQ & Hw31) 
+        BITSET(pTIMER->TC32IRQ, Hw31);
+
+    return IRQ_HANDLED;
+}
+
+static struct irqaction tcc8900_timer_irq = {
+    .name       = "TC1_timer",
+    .flags      = IRQF_DISABLED | IRQF_TIMER,
+    .handler    = tcc8900_timer_interrupt,
+};
+
+/*
+ * Scheduler clock - returns current time in nanosec units.
+ */
+unsigned long long sched_clock(void)
+{
+    return ((unsigned long long)jiffies) * (1000000000llu / HZ);
+}
+
+
+/* 
+ * Timer Initialization 
+ */
+static void __init tcc8900_timer_init(void)
+{
+    unsigned int cpu_clk;
+    unsigned int bus_clk;
+
+    init_pwm_list();
+	tca_ckc_init();
+    cpu_clk = (unsigned int)tca_ckc_getcpu();
+    bus_clk = (unsigned int)tca_ckc_getbus();
+
+    pTIMER  = (volatile PTIMER)tcc_p2v(HwTMR_BASE);
+   	pPIC    = (volatile PPIC)tcc_p2v(HwPIC_BASE);
+
+    printk(" ### CORE CLOCK (%u Hz), BUS CLOCK (%u Hz) ###\n", cpu_clk * 100, bus_clk * 100);
+
+    BITCLR(pTIMER->TC32EN, Hw24);
+    pTIMER->TC32EN = TCC_TIMER_FREQ / HZ;
+    pTIMER->TC32LDV = 0;
+    BITSET(pTIMER->TC32IRQ, Hw19);
+    BITSET(pTIMER->TC32EN, Hw24);
+
+    BITSET(pPIC->SEL0, TCC_ENABLE_BIT(INT_TC1));
+    BITSET(pPIC->IEN0, TCC_ENABLE_BIT(INT_TC1));
+    BITSET(pPIC->INTMSK0, TCC_ENABLE_BIT(INT_TC1));
+    BITSET(pPIC->MODEA0, TCC_ENABLE_BIT(INT_TC1));
+    //BITCLR(pPIC->CLR0, TCC_ENABLE_BIT(INT_TC1));
+
+    setup_irq(INT_TC1, &tcc8900_timer_irq);
+}
+
+struct sys_timer tcc8900_timer = {
+    .init       = tcc8900_timer_init,
+    .offset     = tcc8900_timer_gettimeoffset, 
+};
Index: linux-2.6.29/arch/arm/mm/init.c
===================================================================
--- linux-2.6.29.orig/arch/arm/mm/init.c	2010-04-07 12:29:33.000000000 -0400
+++ linux-2.6.29/arch/arm/mm/init.c	2010-04-07 12:29:36.000000000 -0400
@@ -484,6 +484,9 @@
 	unsigned int codesize, datasize, initsize;
 	int i, node;
 
+	printk("_etext:0x%p, _text:0x%p, _end:0x%p, _data:0x%p, __init_end:0x%p, __init_begin:0x%p\n", \
+			&_etext, &_text, &_end, &_data, &__init_end, &__init_begin);
+
 #ifndef CONFIG_DISCONTIGMEM
 	max_mapnr   = virt_to_page(high_memory) - mem_map;
 #endif
Index: linux-2.6.29/arch/arm/mm/mmu.c
===================================================================
--- linux-2.6.29.orig/arch/arm/mm/mmu.c	2010-04-07 12:29:33.000000000 -0400
+++ linux-2.6.29/arch/arm/mm/mmu.c	2010-04-07 12:29:36.000000000 -0400
@@ -239,6 +239,10 @@
 		.prot_sect = PMD_TYPE_SECT | PMD_SECT_AP_WRITE,
 		.domain    = DOMAIN_KERNEL,
 	},
+	[MT_MEMORY_TCC] = {
+		.prot_sect = PMD_TYPE_SECT | PMD_SECT_AP_WRITE | PMD_SECT_UNCACHED,
+		.domain    = DOMAIN_KERNEL,
+	},
 	[MT_ROM] = {
 		.prot_sect = PMD_TYPE_SECT,
 		.domain    = DOMAIN_KERNEL,
@@ -572,6 +576,8 @@
 	const struct mem_type *type;
 	pgd_t *pgd;
 
+	printk("create_mapping:0x%lx->0x%lx(0x%lx)\n", __pfn_to_phys(md->pfn), md->virtual, md->length);
+	
 	if (md->virtual != vectors_base() && md->virtual < TASK_SIZE) {
 		printk(KERN_WARNING "BUG: not creating mapping for "
 		       "0x%08llx at 0x%08lx in user region\n",
Index: linux-2.6.29/arch/arm/plat-tcc/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/plat-tcc/Makefile	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,10 @@
+
+#obj-$(CONFIG_TCA_CKC)	+= tca_ckc.o
+
+#obj-$(CONFIG_TCA_PM)	+= tcc_pm.o
+#ifeq ($(CONFIG_PM),y)
+#obj-$(CONFIG_TCA_PM)	+= tcc_asm.o
+#endif
+#
+obj-$(CONFIG_DPM) 		+= tcc_dpm.o
+
Index: linux-2.6.29/arch/arm/plat-tcc/include/plat/dpm.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/plat-tcc/include/plat/dpm.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,169 @@
+/*
+ * include/asm-arm/arch-tcc79x/dpm.h
+ *
+ * Author:  <linux@telechips.com>
+ * Created: June 10, 2008
+ * Description: DPM for Telechips 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Copyright (C) 2002-2004, MontaVista Software <source@mvista.com>
+ * Copyright (C) 2008-2009 Telechips 
+ *
+ * Initially based on include/asm-arm/arch-omap/omap_dpm.h
+ */
+
+#ifndef __ASM_ARCH_DPM_H__
+#define __ASM_ARCH_DPM_H__
+
+#include <bsp.h>
+
+#include <asm/io.h>
+#include <asm/timex.h>
+
+/*!
+ * machine dependent operating state
+ *
+ * An operating state is a cpu execution state that has implications for power
+ * management. The DPM will select operating points based largely on the
+ * current operating state.
+ *
+ * DPM_STATES is the number of supported operating states. Valid operating
+ * states are from 0 to DPM_STATES-1 but when setting an operating state the
+ * kernel should only specify a state from the set of "base states" and should
+ * do so by name.  During the context switch the new operating state is simply
+ * extracted from current->dpm_state.
+ *
+ * task states:
+ *
+ * APIs that reference task states use the range -(DPM_TASK_STATE_LIMIT + 1)
+ * through +DPM_TASK_STATE_LIMIT.  This value is added to DPM_TASK_STATE to
+ * obtain the downward or upward adjusted task state value. The
+ * -(DPM_TASK_STATE_LIMIT + 1) value is interpreted specially, and equates to
+ * DPM_NO_STATE.
+ *
+ * Tasks inherit their task operating states across calls to
+ * fork(). DPM_TASK_STATE is the default operating state for all tasks, and is
+ * inherited from init.  Tasks can change (or have changed) their tasks states
+ * using the DPM_SET_TASK_STATE variant of the sys_dpm() system call.
+ */
+#define DPM_IDLE_TASK_STATE  0
+#define DPM_IDLE_STATE       1
+#define DPM_SLEEP_STATE      2
+#define DPM_BASE_STATES      3
+
+#define DPM_TASK_STATE_LIMIT 4
+#define DPM_TASK_STATE       (DPM_BASE_STATES + DPM_TASK_STATE_LIMIT) /* 7 */
+#define DPM_STATES           (DPM_TASK_STATE + DPM_TASK_STATE_LIMIT + 1) /* 11 */
+#define DPM_TASK_STATES      (DPM_STATES - DPM_BASE_STATES) /* 5 */
+
+#define DPM_STATE_NAMES                  \
+{ "idle-task", "idle", "sleep",          \
+  "task-4", "task-3", "task-2", "task-1",\
+  "task",                                \
+  "task+1", "task+2", "task+3", "task+4" \
+}
+
+
+#define DPM_PARAM_NAMES				\
+{   "sys_cpu",\
+    "sys_bus",\
+    "fbus_grp",\
+    "fbus_vbus",\
+    "fbus_vcodec",\
+    "fbus_smu",\
+    "fbus_ddi",\
+    "fbus_iobus",\
+    "peri_lcd",\
+    "peri_sata",\
+    "peri_otg",\
+    "peri_ohci",\
+    "peri_userintr",\
+    "peri_tvout",\
+    "peri_hdmi",\
+    "peri_sdhc",\
+}
+
+
+/*!
+ * MD operating point parameters
+ */
+enum {
+    DPM_MD_CORE_CPU,    /* 0 */
+    DPM_MD_CORE_BUS,    /* 1 */
+    DPM_MD_FBUS_GRP,    /* 2 */
+    DPM_MD_FBUS_VBUS,   /* 3 */
+    DPM_MD_FBUS_VCODEC, /* 4 */
+    DPM_MD_FBUS_SMU,    /* 5 */
+    DPM_MD_FBUS_DDI,    /* 6 */
+    DPM_MD_FBUS_IOBUS,  /* 7 */
+    DPM_MD_PERI_LCD,    /* 8 */
+    DPM_MD_PERI_SATA,   /* 9 */
+    DPM_MD_PERI_OTG,    /* 10 */
+    DPM_MD_PERI_OHCI,   /* 11 */
+    DPM_MD_PERI_USERINTR,   /* 12 */
+    DPM_MD_PERI_TVOUT,   /* 13 */
+    DPM_MD_PERI_HDMI,    /* 14 */
+    DPM_MD_PERI_SDHC,    /* 15 */
+    DPM_MD_MAX,
+};
+
+#define DPM_PP_NBR DPM_MD_MAX 
+
+
+#ifndef __ASSEMBLER__
+
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+
+#define DPM_MD_STATS
+typedef __u64 dpm_md_count_t;
+typedef __u64 dpm_md_time_t;
+
+
+#define dpm_time() get_cycles() 
+#define dpm_time_to_usec(ticks) ({ \
+         unsigned long long quot = (unsigned long long) ticks * 10; \
+         do_div(quot, (unsigned long) (1000*2)); \
+           quot; })
+
+
+/*!
+ * Instances of this structure define valid Innovator operating points for DPM.
+ * Voltages are represented in mV, and frequencies are represented in KHz.
+ */ 
+/* TODO */
+/* Operating Points */
+struct dpm_md_opt {
+        unsigned int sys_cpu;       /* 0 */
+        unsigned int sys_bus;       /* 1 */
+        unsigned int fbus_grp;      /* 2 */
+        unsigned int fbus_vbus;     /* 3 */
+        unsigned int fbus_vcodec;   /* 4 */
+        unsigned int fbus_smu;      /* 5 */
+        unsigned int fbus_ddi;      /* 6 */
+        unsigned int fbus_iobus;    /* 7 */
+        unsigned int peri_lcd;      /* 8 */
+        unsigned int peri_sata;     /* 9 */
+        unsigned int peri_otg;      /* 10 */
+        unsigned int peri_ohci;     /* 11 */
+        unsigned int peri_userintr; /* 12 */
+        unsigned int peri_tvout;    /* 13 */
+        unsigned int peri_hdmi;     /* 14 */
+        unsigned int peri_sdhc;     /* 15 */
+};
+
+#endif /* __ASSEMBLER__ */
+#endif /* __ASM_ARCH_DPM_H__ */
Index: linux-2.6.29/arch/arm/plat-tcc/tcc_dpm.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/arch/arm/plat-tcc/tcc_dpm.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,897 @@
+/*
+ * arch/arm/plat-tcc/tcc_dpm.c  DPM support for Telecips Chips 
+ *
+ * Author:  <linux@telechips.com>
+ * Created: 10th Jun, 2008 
+ * Description: tcc clock control functions.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Copyright (C) 2002, 2004 MontaVista Software <source@mvista.com>.
+ * Copyright (C) 2008-2009 Telechips 
+ *
+ * Based on code by Matthew Locke, Dmitry Chigirev, and Bishop Brock.
+ */
+
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/kmod.h>
+#include <linux/module.h>
+#include <linux/stat.h>
+#include <linux/string.h>
+#include <linux/device.h>
+#include <linux/pm.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/sched.h>
+
+#include <asm/hardirq.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/processor.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+#include <mach/system.h>
+#include <asm/mach/time.h>
+
+#include <bsp.h>
+#include <linux/dpm.h>
+#include <plat/dpm.h>
+#include <mach/tcc_ckc_ctrl.h>
+
+#if 0
+#define dbg printk
+#define DEBUG
+#else /* no debug */
+#define dbg(x...) do {} while(0)
+#endif
+
+static int cur_lcd;
+static int cur_sata;
+static int cur_otg;
+static int cur_ohci;
+static int cur_userintr;
+static int cur_tvout;
+static int cur_hdmi;
+static int cur_sdhc;
+
+static void 
+set_cpu_clock(unsigned int sys_cpu)
+{
+    struct ckc_ioctl st;
+#ifdef DEBUG
+    int cpu = 0;
+#endif
+
+    memset(&st, 0, sizeof(struct ckc_ioctl)); 
+    st.in_ckc.cpuvalue = sys_cpu ;
+
+    ckc_set_changecpu(st);
+
+#ifdef DEBUG
+    cpu = ckc_get_cpu(st);
+    dbg("[%s] cpu = %d\n", __func__, cpu);
+#endif
+}
+
+static int 
+get_cpu_clock(void)
+{
+#ifdef DEBUG
+    int cpu = 0;
+#endif
+    struct ckc_ioctl st;
+    memset(&st, 0, sizeof(struct ckc_ioctl));
+#ifdef DEBUG
+    cpu = ckc_get_cpu(st);
+    dbg("[%s] cpu = %d \n", __func__, cpu);
+    return cpu;
+#else
+    return ckc_get_cpu(st);
+#endif
+    return 0;
+}
+
+static void 
+set_bus_clock(unsigned int sys_bus)
+{
+    struct ckc_ioctl st;
+#ifdef DEBUG
+    int bus = 0;
+#endif
+
+    memset(&st, 0, sizeof(struct ckc_ioctl)); 
+    st.in_ckc.busvalue = sys_bus ;
+
+    ckc_set_changemem(st);
+#ifdef DEBUG
+    bus = ckc_get_bus(st);
+    dbg("[%s] bus = %d\n", __func__, bus);
+#endif
+}
+
+
+static int 
+get_bus_clock(void)
+{
+#ifdef DEBUG
+    int bus = 0;
+#endif
+    struct ckc_ioctl st;
+    memset(&st, 0, sizeof(struct ckc_ioctl));
+#ifdef DEBUG
+    bus = ckc_get_bus(st);
+    dbg("[%s] bus = %d \n", __func__, bus);
+    return bus;
+#else
+    return ckc_get_bus(st);
+#endif
+    return 0;
+}
+
+static void 
+set_grp_clock(unsigned int fbus_grp)
+{
+    struct ckc_ioctl st;
+#ifdef DEBUG
+    int grp = 0;
+#endif
+
+    memset(&st, 0, sizeof(struct ckc_ioctl)); 
+    st.in_ckc.fbusname = CLKCTRL3;
+    st.in_ckc.fbusfreq = fbus_grp;
+
+    ckc_set_changefbus(st);
+#ifdef DEBUG
+    grp = ckc_get_fbus(st);
+    dbg("[%s] grp = %d\n", __func__, grp);
+#endif
+}
+
+
+static int 
+get_grp_clock(void)
+{
+#ifdef DEBUG
+    int grp = 0;
+#endif
+    struct ckc_ioctl st;
+    memset(&st, 0, sizeof(struct ckc_ioctl));
+    st.in_ckc.fbusname = CLKCTRL3;
+#ifdef DEBUG
+    grp = ckc_get_fbus(st);
+    dbg("[%s] grp = %d \n", __func__, grp);
+    return grp;
+#else
+    return ckc_get_fbus(st);
+#endif
+    return 0;
+}
+
+static void 
+set_vbus_clock(unsigned int fbus_vbus)
+{
+    struct ckc_ioctl st;
+#ifdef DEBUG
+    int vbus = 0;
+#endif
+
+    memset(&st, 0, sizeof(struct ckc_ioctl)); 
+    st.in_ckc.fbusname = CLKCTRL5;
+    st.in_ckc.fbusfreq = fbus_vbus;
+
+    ckc_set_changefbus(st);
+#ifdef DEBUG
+    vbus = ckc_get_fbus(st);
+    dbg("[%s] vbus = %d\n", __func__, vbus);
+#endif
+}
+
+
+static int 
+get_vbus_clock(void)
+{
+#ifdef DEBUG
+    int vbus = 0;
+#endif
+    struct ckc_ioctl st;
+    memset(&st, 0, sizeof(struct ckc_ioctl));
+    st.in_ckc.fbusname = CLKCTRL5;
+#ifdef DEBUG
+    vbus = ckc_get_fbus(st);
+    dbg("[%s] vbus = %d \n", __func__, vbus);
+    return vbus;
+#else
+    return ckc_get_fbus(st);
+#endif
+    return 0;
+}
+
+static void 
+set_vcodec_clock(unsigned int fbus_vcodec)
+{
+    struct ckc_ioctl st;
+#ifdef DEBUG
+    int vcodec = 0;
+#endif
+
+    memset(&st, 0, sizeof(struct ckc_ioctl)); 
+    st.in_ckc.fbusname = CLKCTRL6;
+    st.in_ckc.fbusfreq = fbus_vcodec;
+
+    ckc_set_changefbus(st);
+#ifdef DEBUG
+    vcodec = ckc_get_fbus(st);
+    dbg("[%s] vcodec = %d\n", __func__, vcodec);
+#endif
+}
+
+
+static int 
+get_vcodec_clock(void)
+{
+#ifdef DEBUG
+    int vcodec = 0;
+#endif
+    struct ckc_ioctl st;
+    memset(&st, 0, sizeof(struct ckc_ioctl));
+    st.in_ckc.fbusname = CLKCTRL6;
+#ifdef DEBUG
+    vcodec = ckc_get_fbus(st);
+    dbg("[%s] vcodec = %d \n", __func__, vcodec);
+    return vcodec;
+#else
+    return ckc_get_fbus(st);
+#endif
+    return 0;
+}
+
+
+static void 
+set_smu_clock(unsigned int fbus_smu)
+{
+    struct ckc_ioctl st;
+#ifdef DEBUG
+    int smu = 0;
+#endif
+
+    memset(&st, 0, sizeof(struct ckc_ioctl)); 
+    st.in_ckc.fbusname = CLKCTRL1;
+    st.in_ckc.fbusfreq = fbus_smu;
+
+    ckc_set_changefbus(st);
+#ifdef DEBUG
+    smu = ckc_get_fbus(st);
+    dbg("[%s] smu = %d\n", __func__, smu);
+#endif
+}
+
+
+static int 
+get_smu_clock(void)
+{
+#ifdef DEBUG
+    int smu = 0;
+#endif
+    struct ckc_ioctl st;
+    memset(&st, 0, sizeof(struct ckc_ioctl));
+    st.in_ckc.fbusname = CLKCTRL1;
+#ifdef DEBUG
+    smu = ckc_get_fbus(st);
+    dbg("[%s] smu = %d \n", __func__, smu);
+    return smu;
+#else
+    return ckc_get_fbus(st);
+#endif
+    return 0;
+}
+
+
+static void 
+set_ddi_clock(unsigned int fbus_ddi)
+{
+    struct ckc_ioctl st;
+#ifdef DEBUG
+    int ddi = 0;
+#endif
+
+    memset(&st, 0, sizeof(struct ckc_ioctl)); 
+    st.in_ckc.fbusname = CLKCTRL7;
+    st.in_ckc.fbusfreq = fbus_ddi;
+
+    ckc_set_changefbus(st);
+#ifdef DEBUG
+    ddi = ckc_get_fbus(st);
+    dbg("[%s] ddi = %d\n", __func__, ddi);
+#endif
+}
+
+
+static int 
+get_ddi_clock(void)
+{
+#ifdef DEBUG
+    int ddi = 0;
+#endif
+    struct ckc_ioctl st;
+    memset(&st, 0, sizeof(struct ckc_ioctl));
+    st.in_ckc.fbusname = CLKCTRL7;
+#ifdef DEBUG
+    ddi = ckc_get_fbus(st);
+    dbg("[%s] ddi = %d \n", __func__, ddi);
+    return ddi;
+#else
+    return ckc_get_fbus(st);
+#endif
+    return 0;
+}
+
+
+static void 
+set_iobus_clock(unsigned int fbus_iobus)
+{
+    struct ckc_ioctl st;
+#ifdef DEBUG
+    int iobus = 0;
+#endif
+
+    memset(&st, 0, sizeof(struct ckc_ioctl)); 
+    st.in_ckc.fbusname = CLKCTRL4;
+    st.in_ckc.fbusfreq = fbus_iobus;
+
+    ckc_set_changefbus(st);
+#ifdef DEBUG
+    iobus = ckc_get_fbus(st);
+    dbg("[%s] iobus = %d\n", __func__, iobus);
+#endif
+}
+
+
+static int 
+get_iobus_clock(void)
+{
+#ifdef DEBUG
+    int iobus = 0;
+#endif
+    struct ckc_ioctl st;
+    memset(&st, 0, sizeof(struct ckc_ioctl));
+    st.in_ckc.fbusname = CLKCTRL4;
+#ifdef DEBUG
+    iobus = ckc_get_fbus(st);
+    dbg("[%s] iobus = %d \n", __func__, iobus);
+    return iobus;
+#else
+    return ckc_get_fbus(st);
+#endif
+    return 0;
+}
+
+
+static void 
+set_lcd_clock(unsigned int peri_lcd)
+{
+    stpwrinfo out;
+
+    memset(&out, 0, sizeof(stpwrinfo));
+    if(peri_lcd == ENABLE) {   
+        dbg("[%s] LCD ON\n",__func__);
+        callback_pwm_node(DEVICE_LCD , PWR_CMD_ON, &(out));
+    } else if(peri_lcd == DISABLE){
+        dbg("[%s] LCD OFF\n", __func__);
+        callback_pwm_node(DEVICE_LCD , PWR_CMD_OFF, &(out));
+    }
+    cur_lcd = peri_lcd;
+}
+
+static int 
+get_lcd_clock(void)
+{
+#ifdef DEBUG
+    if(cur_lcd == ENABLE)  
+        dbg("[%s] LCD ON\n", __func__);
+    else if(cur_lcd == DISABLE) 
+        dbg("[%s] LCD OFF\n", __func__);
+#endif
+    return cur_lcd;
+}
+
+static void 
+set_sata_clock(unsigned int peri_sata)
+{
+    stpwrinfo out;
+
+    memset(&out, 0, sizeof(stpwrinfo));
+    if(peri_sata== ENABLE) {   
+        dbg("[%s] SATA ON\n", __func__);
+        callback_pwm_node(DEVICE_SATA, PWR_CMD_ON, &(out));
+    } else if(peri_sata== DISABLE){
+        dbg("[%s] SATA OFF\n", __func__);
+        callback_pwm_node(DEVICE_SATA, PWR_CMD_OFF, &(out));
+    }
+    cur_sata = peri_sata;
+}
+
+static int 
+get_sata_clock(void)
+{
+#ifdef DEBUG
+    if(cur_sata == ENABLE)  
+        dbg("[%s] SATA ON\n", __func__);
+    else if(cur_sata == DISABLE) 
+        dbg("[%s] SATA OFF\n", __func__);
+#endif
+    return cur_sata;
+}
+
+
+
+static void 
+set_otg_clock(unsigned int peri_otg)
+{
+    stpwrinfo out;
+
+    memset(&out, 0, sizeof(stpwrinfo));
+    if(peri_otg== ENABLE) {   
+        dbg("[%s] OTG ON\n", __func__);
+        callback_pwm_node(DEVICE_OTG, PWR_CMD_ON, &(out));
+    } else if(peri_otg== DISABLE){
+        dbg("[%s] OTG OFF\n", __func__);
+        callback_pwm_node(DEVICE_OTG, PWR_CMD_OFF, &(out));
+    }
+    cur_otg = peri_otg;
+}
+
+static int 
+get_otg_clock(void)
+{
+#ifdef DEBUG
+    if(cur_otg == ENABLE)  
+        dbg("[%s] OTG ON\n", __func__);
+    else if(cur_otg == DISABLE) 
+        dbg("[%s] OTG OFF\n", __func__);
+#endif
+    return cur_otg;
+}
+
+
+static void 
+set_ohci_clock(unsigned int peri_ohci)
+{
+    stpwrinfo out;
+
+    memset(&out, 0, sizeof(stpwrinfo));
+    if(peri_ohci== ENABLE) {   
+        dbg("[%s] OHCI ON\n", __func__);
+        callback_pwm_node(DEVICE_OHCI, PWR_CMD_ON, &(out));
+    } else if(peri_ohci== DISABLE){
+        dbg("[%s] OHCI OFF\n", __func__);
+        callback_pwm_node(DEVICE_OHCI, PWR_CMD_OFF, &(out));
+    }
+    cur_ohci = peri_ohci;
+}
+
+static int 
+get_ohci_clock(void)
+{
+#ifdef DEBUG
+    if(cur_ohci == ENABLE)  
+        dbg("[%s] OHCI ON\n", __func__);
+    else if(cur_ohci == DISABLE) 
+        dbg("[%s] OHCI OFF\n", __func__);
+#endif
+    return cur_ohci;
+}
+
+
+static void 
+set_userintr_clock(unsigned int peri_userintr)
+{
+    stpwrinfo out;
+
+    memset(&out, 0, sizeof(stpwrinfo));
+    if(peri_userintr== ENABLE) {   
+        dbg("[%s] USERINTR ON\n", __func__);
+        callback_pwm_node(DEVICE_USERINTR, PWR_CMD_ON, &(out));
+    } else if(peri_userintr== DISABLE){
+        dbg("[%s] USERINTR OFF\n", __func__);
+        callback_pwm_node(DEVICE_USERINTR, PWR_CMD_OFF, &(out));
+    }
+    cur_userintr = peri_userintr;
+}
+
+static int 
+get_userintr_clock(void)
+{
+#ifdef DEBUG
+    if(cur_userintr == ENABLE)  
+        dbg("[%s] USERINTR ON\n", __func__);
+    else if(cur_userintr == DISABLE) 
+        dbg("[%s] USERINTR OFF\n", __func__);
+#endif
+    return cur_userintr;
+}
+
+
+static void 
+set_tvout_clock(unsigned int peri_tvout)
+{
+    stpwrinfo out;
+
+    memset(&out, 0, sizeof(stpwrinfo));
+    if(peri_tvout == ENABLE) {   
+        dbg("[%s] TVOUT ON\n",__func__);
+        callback_pwm_node(DEVICE_TVOUT , PWR_CMD_ON, &(out));
+    } else if(peri_tvout == DISABLE){
+        dbg("[%s] TVOUT OFF\n", __func__);
+        callback_pwm_node(DEVICE_TVOUT , PWR_CMD_OFF, &(out));
+    }
+    cur_tvout = peri_tvout;
+}
+
+static int 
+get_tvout_clock(void)
+{
+#ifdef DEBUG
+    if(cur_tvout == ENABLE)  
+        dbg("[%s] TVOUT ON\n", __func__);
+    else if(cur_tvout == DISABLE) 
+        dbg("[%s] TVOUT OFF\n", __func__);
+#endif
+    return cur_tvout;
+}
+
+static void 
+set_hdmi_clock(unsigned int peri_hdmi)
+{
+    stpwrinfo out;
+
+    memset(&out, 0, sizeof(stpwrinfo));
+    if(peri_hdmi == ENABLE) {   
+        dbg("[%s] HDMI ON\n",__func__);
+        callback_pwm_node(DEVICE_HDMI , PWR_CMD_ON, &(out));
+    } else if(peri_hdmi == DISABLE){
+        dbg("[%s] HDMI OFF\n", __func__);
+        callback_pwm_node(DEVICE_HDMI , PWR_CMD_OFF, &(out));
+    }
+    cur_hdmi = peri_hdmi;
+}
+
+static int 
+get_hdmi_clock(void)
+{
+#ifdef DEBUG
+    if(cur_hdmi == ENABLE)  
+        dbg("[%s] HDMI ON\n", __func__);
+    else if(cur_hdmi == DISABLE) 
+        dbg("[%s] HDMI OFF\n", __func__);
+#endif
+    return cur_hdmi;
+}
+
+
+static void 
+set_sdhc_clock(unsigned int peri_sdhc)
+{
+    stpwrinfo out;
+
+    memset(&out, 0, sizeof(stpwrinfo));
+    if(peri_sdhc == ENABLE) {   
+        dbg("[%s] SDHC ON\n",__func__);
+        callback_pwm_node(DEVICE_SDHC , PWR_CMD_ON, &(out));
+    } else if(peri_sdhc == DISABLE){
+        dbg("[%s] SDHC OFF\n", __func__);
+        callback_pwm_node(DEVICE_SDHC , PWR_CMD_OFF, &(out));
+    }
+    cur_sdhc = peri_sdhc;
+}
+
+static int 
+get_sdhc_clock(void)
+{
+#ifdef DEBUG
+    if(cur_sdhc == ENABLE)  
+        dbg("[%s] SDHC ON\n", __func__);
+    else if(cur_sdhc == DISABLE) 
+        dbg("[%s] SDHC OFF\n", __func__);
+#endif
+    return cur_sdhc;
+}
+
+
+
+int
+dpm_tcc_init_opt(struct dpm_opt *opt)
+{
+    int sys_cpu = opt->pp[DPM_MD_CORE_CPU];
+    int sys_bus = opt->pp[DPM_MD_CORE_BUS];
+    int fbus_grp = opt->pp[DPM_MD_FBUS_GRP];
+    int fbus_vbus = opt->pp[DPM_MD_FBUS_VBUS];
+    int fbus_vcodec = opt->pp[DPM_MD_FBUS_VCODEC];
+    int fbus_smu = opt->pp[DPM_MD_FBUS_SMU];
+    int fbus_ddi = opt->pp[DPM_MD_FBUS_DDI];
+    int fbus_iobus = opt->pp[DPM_MD_FBUS_IOBUS];
+    int peri_lcd = opt->pp[DPM_MD_PERI_LCD];
+    int peri_sata = opt->pp[DPM_MD_PERI_SATA];
+    int peri_otg = opt->pp[DPM_MD_PERI_OTG];
+    int peri_ohci = opt->pp[DPM_MD_PERI_OHCI];
+    int peri_userintr = opt->pp[DPM_MD_PERI_USERINTR];
+    int peri_tvout = opt->pp[DPM_MD_PERI_TVOUT];
+    int peri_hdmi = opt->pp[DPM_MD_PERI_HDMI];
+    int peri_sdhc = opt->pp[DPM_MD_PERI_SDHC];
+
+    struct dpm_md_opt *md_opt = &opt->md_opt;
+
+    md_opt->sys_cpu = sys_cpu;
+    md_opt->sys_bus = sys_bus;
+    md_opt->fbus_grp = fbus_grp;
+    md_opt->fbus_vbus = fbus_vbus;
+    md_opt->fbus_vcodec = fbus_vcodec;
+    md_opt->fbus_smu = fbus_smu;
+    md_opt->fbus_ddi = fbus_ddi;
+    md_opt->fbus_iobus = fbus_iobus;
+    md_opt->peri_lcd = peri_lcd;
+    md_opt->peri_sata = peri_sata;
+    md_opt->peri_otg = peri_otg;
+    md_opt->peri_ohci = peri_ohci;
+    md_opt->peri_userintr = peri_userintr;
+    md_opt->peri_tvout = peri_tvout;
+    md_opt->peri_hdmi = peri_hdmi;
+    md_opt->peri_sdhc = peri_sdhc;
+
+    return 0;
+}
+
+int
+dpm_tcc_set_opt(struct dpm_opt *cur, struct dpm_opt *new)
+{
+    struct dpm_md_opt *md_cur, *md_new;
+    md_cur = &cur->md_opt;
+    md_new = &new->md_opt;
+
+    // system core cpu clock 
+    dbg("[%d]: md_cur->sys_cpu = %d",__LINE__, md_cur->sys_cpu);
+    dbg("[%d]: md_new->sys_cpu = %d\n",__LINE__, md_new->sys_cpu);
+    if(md_cur->sys_cpu != md_new->sys_cpu)
+    {
+        set_cpu_clock(md_new->sys_cpu);
+    }
+
+    // system bus clock 
+    dbg("[%d]: md_cur->sys_bus = %d",__LINE__, md_cur->sys_bus);
+    dbg("[%d]: md_new->sys_bus = %d\n",__LINE__, md_new->sys_bus);
+    if(md_cur->sys_bus != md_new->sys_bus)
+    {
+        set_bus_clock(md_new->sys_bus);
+    }
+
+    // system fbus grp clock 
+    dbg("[%d]: md_cur->fbus_grp = %d",__LINE__, md_cur->fbus_grp);
+    dbg("[%d]: md_new->fbus_grp = %d\n",__LINE__, md_new->fbus_grp);
+    if(md_cur->fbus_grp != md_new->fbus_grp)
+    {
+        set_grp_clock(md_new->fbus_grp);
+    }
+
+    // system fbus vbus clock 
+    dbg("[%d]: md_cur->fbus_vbus = %d",__LINE__, md_cur->fbus_vbus);
+    dbg("[%d]: md_new->fbus_vbus = %d\n",__LINE__, md_new->fbus_vbus);
+    if(md_cur->fbus_vbus != md_new->fbus_vbus)
+    {
+        set_vbus_clock(md_new->fbus_vbus);
+    }
+
+   // system fbus vcodec clock
+    dbg("[%d]: md_cur->fbus_vcodec = %d",__LINE__, md_cur->fbus_vcodec);
+    dbg("[%d]: md_new->fbus_vcodec = %d\n",__LINE__, md_new->fbus_vcodec);
+    if(md_cur->fbus_vcodec != md_new->fbus_vcodec)
+    {
+        set_vcodec_clock(md_new->fbus_vcodec);
+    }
+
+   // system fbus smu clock
+    dbg("[%d]: md_cur->fbus_smu = %d",__LINE__, md_cur->fbus_smu);
+    dbg("[%d]: md_new->fbus_smu = %d\n",__LINE__, md_new->fbus_smu);
+    if(md_cur->fbus_smu != md_new->fbus_smu)
+    {
+        set_smu_clock(md_new->fbus_smu);
+    }
+
+
+   // system fbus ddi clock
+    dbg("[%d]: md_cur->fbus_ddi = %d",__LINE__, md_cur->fbus_ddi);
+    dbg("[%d]: md_new->fbus_ddi = %d\n",__LINE__, md_new->fbus_ddi);
+    if(md_cur->fbus_ddi != md_new->fbus_ddi)
+    {
+        set_ddi_clock(md_new->fbus_ddi);
+    }
+
+   // system fbus iobus clock
+    dbg("[%d]: md_cur->fbus_iobus = %d",__LINE__, md_cur->fbus_iobus);
+    dbg("[%d]: md_new->fbus_iobus = %d\n",__LINE__, md_new->fbus_iobus);
+    if(md_cur->fbus_iobus != md_new->fbus_iobus)
+    {
+        set_iobus_clock(md_new->fbus_iobus);
+    }
+
+
+    // peri lcd clock 
+    dbg("[%d]: md_cur->peri_lcd = %d",__LINE__, md_cur->peri_lcd);
+    dbg("[%d]: md_new->peri_lcd = %d\n",__LINE__, md_new->peri_lcd);
+    if(md_cur->peri_lcd != md_new->peri_lcd)
+    {
+        set_lcd_clock(md_new->peri_lcd);
+    }
+
+    // peri sata clock 
+    dbg("[%d]: md_cur->peri_sata = %d",__LINE__, md_cur->peri_sata);
+    dbg("[%d]: md_new->peri_sata = %d\n",__LINE__, md_new->peri_sata);
+    if(md_cur->peri_sata != md_new->peri_sata)
+    {
+        set_sata_clock(md_new->peri_sata);
+    }
+
+    // peri otg clock 
+    dbg("[%d]: md_cur->peri_otg = %d",__LINE__, md_cur->peri_otg);
+    dbg("[%d]: md_new->peri_otg = %d\n",__LINE__, md_new->peri_otg);
+    if(md_cur->peri_otg != md_new->peri_otg)
+    {
+        set_otg_clock(md_new->peri_otg);
+    }
+
+    // peri ohci clock 
+    dbg("[%d]: md_cur->peri_ohci = %d",__LINE__, md_cur->peri_ohci);
+    dbg("[%d]: md_new->peri_ohci = %d\n",__LINE__, md_new->peri_ohci);
+    if(md_cur->peri_ohci != md_new->peri_ohci)
+    {
+        set_ohci_clock(md_new->peri_ohci);
+    }
+
+    // peri userintr clock 
+    dbg("[%d]: md_cur->peri_userintr = %d",__LINE__, md_cur->peri_userintr);
+    dbg("[%d]: md_new->peri_userintr = %d\n",__LINE__, md_new->peri_userintr);
+    if(md_cur->peri_userintr != md_new->peri_userintr)
+    {
+        set_userintr_clock(md_new->peri_userintr);
+    }
+
+    // peri tvout clock 
+    dbg("[%d]: md_cur->peri_tvout = %d",__LINE__, md_cur->peri_tvout);
+    dbg("[%d]: md_new->peri_tvout = %d\n",__LINE__, md_new->peri_tvout);
+    if(md_cur->peri_tvout != md_new->peri_tvout)
+    {
+        set_tvout_clock(md_new->peri_tvout);
+    }
+
+
+    // peri hdmi clock 
+    dbg("[%d]: md_cur->peri_hdmi = %d",__LINE__, md_cur->peri_hdmi);
+    dbg("[%d]: md_new->peri_hdmi = %d\n",__LINE__, md_new->peri_hdmi);
+    if(md_cur->peri_hdmi != md_new->peri_hdmi)
+    {
+        set_hdmi_clock(md_new->peri_hdmi);
+    }
+
+
+    // peri sdhc clock 
+    dbg("[%d]: md_cur->peri_sdhc = %d",__LINE__, md_cur->peri_sdhc);
+    dbg("[%d]: md_new->peri_sdhc = %d\n",__LINE__, md_new->peri_sdhc);
+    if(md_cur->peri_sdhc != md_new->peri_sdhc)
+    {
+        set_sdhc_clock(md_new->peri_sdhc);
+    }
+
+
+    return 0;
+}
+
+/* Fully determine the current machine-dependent operating point, and fill in a
+   structure presented by the caller. This should only be called when the
+   dpm_sem is held. This call can return an error if the system is currently at
+   an operating point that could not be constructed by dpm_md_init_opt(). */
+
+int
+dpm_tcc_get_opt(struct dpm_opt *opt)
+{
+	struct dpm_md_opt *md_opt = &opt->md_opt;
+
+	md_opt->sys_cpu = get_cpu_clock();
+	md_opt->sys_bus = get_bus_clock();
+	md_opt->fbus_grp = get_grp_clock();
+	md_opt->fbus_vbus = get_vbus_clock();
+	md_opt->fbus_vcodec = get_vcodec_clock();
+	md_opt->fbus_smu = get_smu_clock();
+	md_opt->fbus_ddi = get_ddi_clock();
+	md_opt->fbus_iobus = get_iobus_clock();
+	md_opt->peri_lcd = get_lcd_clock();
+	md_opt->peri_sata= get_sata_clock();
+	md_opt->peri_otg= get_otg_clock();
+	md_opt->peri_ohci= get_ohci_clock();
+	md_opt->peri_userintr= get_userintr_clock();
+	md_opt->peri_tvout = get_tvout_clock();
+	md_opt->peri_hdmi = get_hdmi_clock();
+	md_opt->peri_sdhc = get_sdhc_clock();
+
+	return 0;
+}
+
+
+/****************************************************************************
+ *  DPM Idle Handler
+ ****************************************************************************/
+
+static void (*orig_idle)(void);
+
+void dpm_tcc_idle(void)
+{
+	extern void default_idle(void);
+
+	if (orig_idle)
+		orig_idle();
+	else {
+		local_irq_disable();
+		if (!need_resched()) {
+			timer_dyn_reprogram();
+			arch_idle();
+		}
+		local_irq_enable();
+	}
+}
+
+/****************************************************************************
+ * Initialization/Exit
+ ****************************************************************************/
+
+extern void (*pm_idle)(void);
+
+static void
+dpm_tcc_startup(void)
+{
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+    /*
+	if (pm_idle != dpm_idle) {
+		orig_idle = pm_idle;
+		pm_idle = dpm_idle;
+	}
+    */
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+}
+
+static void
+dpm_tcc_cleanup(void)
+{
+    dbg("%s:%d\n", __func__, __LINE__);
+	pm_idle = orig_idle;
+}
+
+int __init
+dpm_tcc_init(void)
+{
+	printk("Telechips Dynamic Power Management.\n");
+	dpm_md.init_opt		= dpm_tcc_init_opt;
+	dpm_md.set_opt		= dpm_tcc_set_opt;
+	dpm_md.get_opt		= dpm_tcc_get_opt;
+	dpm_md.check_constraint	= dpm_default_check_constraint;
+	dpm_md.idle		= dpm_tcc_idle;
+	dpm_md.startup		= dpm_tcc_startup;
+	dpm_md.cleanup		= dpm_tcc_cleanup;
+
+	return 0;
+}
+
+__initcall(dpm_tcc_init);
+
Index: linux-2.6.29/drivers/Makefile
===================================================================
--- linux-2.6.29.orig/drivers/Makefile	2010-04-07 12:29:34.000000000 -0400
+++ linux-2.6.29/drivers/Makefile	2010-04-07 12:29:36.000000000 -0400
@@ -6,6 +6,8 @@
 #
 
 obj-y				+= gpio/
+obj-y				+= i2c/
+obj-$(CONFIG_SPI)		+= spi/
 obj-$(CONFIG_PCI)		+= pci/
 obj-$(CONFIG_PARISC)		+= parisc/
 obj-$(CONFIG_RAPIDIO)		+= rapidio/
@@ -37,6 +39,7 @@
 obj-y				+= serial/
 obj-$(CONFIG_PARPORT)		+= parport/
 obj-y				+= base/ block/ misc/ mfd/ net/ media/
+obj-$(CONFIG_DPM)		+= dpm/
 obj-$(CONFIG_NUBUS)		+= nubus/
 obj-$(CONFIG_ATM)		+= atm/
 obj-y				+= macintosh/
@@ -50,7 +53,6 @@
 obj-y				+= cdrom/
 obj-y				+= auxdisplay/
 obj-$(CONFIG_MTD)		+= mtd/
-obj-$(CONFIG_SPI)		+= spi/
 obj-$(CONFIG_PCCARD)		+= pcmcia/
 obj-$(CONFIG_DIO)		+= dio/
 obj-$(CONFIG_SBUS)		+= sbus/
@@ -70,7 +72,6 @@
 obj-$(CONFIG_INPUT)		+= input/
 obj-$(CONFIG_I2O)		+= message/
 obj-$(CONFIG_RTC_LIB)		+= rtc/
-obj-y				+= i2c/
 obj-$(CONFIG_W1)		+= w1/
 obj-$(CONFIG_POWER_SUPPLY)	+= power/
 obj-$(CONFIG_HWMON)		+= hwmon/
Index: linux-2.6.29/drivers/ata/Kconfig
===================================================================
--- linux-2.6.29.orig/drivers/ata/Kconfig	2010-04-07 12:29:33.000000000 -0400
+++ linux-2.6.29/drivers/ata/Kconfig	2010-04-07 12:29:36.000000000 -0400
@@ -734,5 +734,13 @@
 
 	  If unsure, say N.
 
+config SATA_TCC
+	bool "Telechips SATA support (TCC8900 only)"
+	default y
+	help
+	  Telechips Serial ATA.
+
+	  If unsure, say N.
+
 endif # ATA_SFF
 endif # ATA
Index: linux-2.6.29/drivers/ata/Makefile
===================================================================
--- linux-2.6.29.orig/drivers/ata/Makefile	2010-04-07 12:29:33.000000000 -0400
+++ linux-2.6.29/drivers/ata/Makefile	2010-04-07 12:29:36.000000000 -0400
@@ -18,6 +18,7 @@
 obj-$(CONFIG_SATA_INIC162X)	+= sata_inic162x.o
 obj-$(CONFIG_PDC_ADMA)		+= pdc_adma.o
 obj-$(CONFIG_SATA_FSL)		+= sata_fsl.o
+obj-$(CONFIG_SATA_TCC)		+= sata_snps.o
 
 obj-$(CONFIG_PATA_ALI)		+= pata_ali.o
 obj-$(CONFIG_PATA_AMD)		+= pata_amd.o
Index: linux-2.6.29/drivers/ata/sata_snps.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/ata/sata_snps.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,1294 @@
+/*
+ * linux/drivers/ata/sata_snps.c
+ *
+ * Author:  <linux@telechips.com>
+ * Created: 1st April, 2009
+ * Description: Driver for SATA Host Controller
+ *
+ * Copyright (c) 2009 Telechips, Inc.
+ * Copyright (c) 2005 SYNOPSYS, INC.  ALL RIGHTS RESERVED
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/blkdev.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <scsi/scsi_host.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi.h>
+#include <linux/libata.h>
+#include <linux/platform_device.h>
+
+#include <mach/TCC89x_Physical.h>
+#include <mach/TCC89x_Structures.h>
+#include <bsp.h>
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+#include <mach/tca_ckc.h>
+#include <linux/workqueue.h>
+#include <linux/time.h>
+#include <linux/kthread.h>
+#include <mach/tcc_pca953x.h>
+
+#include "sata_snps.h"
+
+#define DRV_NAME	"tcc_sata"
+#define DRV_VERSION	"0.1"
+
+//#define jprintk(f, a...)    printk("---J--- [%s:%d] " f, __func__, __LINE__, ##a) 
+#define jprintk(f, a...)
+
+//#define sata_printk(f, a...)    printk("---sata--- [%s:%d] " f, __func__, __LINE__, ##a) 
+#define sata_printk(f, a...)
+
+#if defined(CONFIG_TCC_R_AX)
+#define __RX_TEST_DBTSR__ 8
+#define __TX_TEST_DBTSR__ 8
+//#define HSATA_DMA_DBTSR_VAL (((__RX_TEST_DBTSR__) << 16) | ((__TX_TEST_DBTSR__) << 0))
+#define HSATA_DMA_DBTSR_VAL (((__RX_TEST_DBTSR__) << 16) | ((254 - 8) << 0))
+#elif defined(CONFIG_TCC_R_XX)
+#define __RX_TEST_DBTSR__ 1
+#define __TX_TEST_DBTSR__ 1
+#define HSATA_DMA_DBTSR_VAL (((__RX_TEST_DBTSR__) << 16) | ((__TX_TEST_DBTSR__) << 0))
+#else
+#error "Undefined TCC8900 revision type !!!"
+#endif
+
+#define WAIT_TIME_FOR_DMA_DONE (1000 * 10)
+
+static void tcc_exec_command_by_tag(struct ata_port *ap, const struct ata_taskfile *tf, u8 tag);
+static void tcc_sata_setup_port(struct ata_ioports *port, void __iomem *base);
+
+
+static struct task_struct *start_sata_thread(int (*threadfn)(void *data),
+                                             struct tcc_sata_dev *tcc_dev,
+                                             const char namefmt[])
+{
+    struct task_struct *ret_task = NULL;
+    if (tcc_dev) {
+        tcc_dev->is_continue = 1;
+        ret_task = kthread_run(threadfn, tcc_dev, namefmt);
+        if (IS_ERR(ret_task)) {
+            tcc_dev->is_continue = 0;
+            ret_task = NULL;
+            printk("[%s:%d] cannot run kernel_thread !!!! \n", __func__, __LINE__);
+        }
+    }
+    return ret_task;
+}
+
+static void stop_sata_thread(struct tcc_sata_dev *tcc_dev)
+{
+    if (tcc_dev) {
+        tcc_dev->is_continue = 0;
+        if (tcc_dev->fetch_task) {
+            wake_up(&(tcc_dev->job_wait_q));
+            kthread_stop(tcc_dev->fetch_task);
+            tcc_dev->fetch_task = NULL;
+        }
+    }
+}
+
+static void tcc_start_dma(GDMANCTRL *reg)
+{
+    BITSET(reg->CHCTRL, Hw0 | Hw2);
+}
+
+static void tcc_stop_dma(GDMANCTRL *reg)
+{
+    BITCLR(reg->CHCTRL, Hw0 | Hw2);
+}
+
+static int init_tx_dma(GDMANCTRL *reg, unsigned long fifo)
+{
+    if (reg) {
+        BITCLR(reg->CHCTRL, Hw0);
+
+        reg->ST_DADR = fifo;
+
+        (reg->DPARAM)[0] = 0xFFFFE000 | 4; // fifo mask
+        //(reg->DPARAM)[0] = 0; // fifo mask
+        (reg->SPARAM)[0] = 0x0 | 4;
+
+        reg->CHCTRL &= 0x00000001;
+
+#if (__TX_TEST_DBTSR__ == 8)
+        BITSET(reg->CHCTRL, (Hw3 | Hw5 | Hw6 | Hw7 | Hw8 | Hw9 | Hw12));
+#elif (__TX_TEST_DBTSR__ == 4)
+        BITSET(reg->CHCTRL, (Hw3 | Hw5 | Hw7 | Hw8 | Hw9 | Hw12));
+#elif (__TX_TEST_DBTSR__ == 2)
+        BITSET(reg->CHCTRL, (Hw3 | Hw5 | Hw6 | Hw8 | Hw9 | Hw12));
+#else
+        BITSET(reg->CHCTRL, (Hw3 | Hw5 | Hw8 | Hw9 | Hw12));
+#endif
+        /* clear DRI at RPTCTRL */
+        BITCLR(reg->RPTCTRL, Hw31);
+
+        BITSET(reg->EXTREQ, Hw14);
+
+        return 0;
+    }
+    return -1;
+}
+
+static int init_rx_dma(GDMANCTRL *reg, unsigned long fifo)
+{
+    if (reg) {
+        BITCLR(reg->CHCTRL, Hw0);
+
+        reg->ST_SADR = fifo;
+
+        (reg->SPARAM)[0] = 0xFFFFE000 | 4; // fifo mask
+        //(reg->SPARAM)[0] = 0; // fifo mask
+        (reg->DPARAM)[0] = 0x0 | 4;
+
+        reg->CHCTRL &= 0x00000001;
+
+#if (__RX_TEST_DBTSR__ == 8)
+        BITSET(reg->CHCTRL, (Hw3 | Hw5 | Hw6 | Hw7 | Hw8 | Hw9));
+#elif (__RX_TEST_DBTSR__ == 4)
+        BITSET(reg->CHCTRL, (Hw3 | Hw5 | Hw7 | Hw8 | Hw9));
+#elif (__RX_TEST_DBTSR__ == 2)
+        BITSET(reg->CHCTRL, (Hw3 | Hw5 | Hw6 | Hw8 | Hw9));
+#else
+        BITSET(reg->CHCTRL, (Hw3 | Hw5 | Hw8 | Hw9));
+#endif
+        /* clear DRI at RPTCTRL */
+        BITCLR(reg->RPTCTRL, Hw31);
+
+        BITSET(reg->EXTREQ, Hw13);
+        return 0;
+    }
+    return -1;
+}
+
+#if 0
+static void set_tx_dma(GDMANCTRL *reg, unsigned long dma_addr, unsigned int length)
+{
+    reg->ST_SADR = dma_addr;
+    reg->HCOUNT = length / (4 * __TX_TEST_DBTSR__);
+}
+#else
+static void set_tx_dma(struct tcc_sata_dev *tcc_dev, struct tcc_sg_list * p_list)
+{
+    tcc_dev->is_tx_complete = 0;
+    tcc_dev->is_last_tx = (p_list->flags & _TCC_DMA_END_) ? 1 : 0;
+
+    tcc_dev->dma_tx_reg->ST_SADR = p_list->dma_addr;
+    tcc_dev->dma_tx_reg->HCOUNT = p_list->length / (4 * __TX_TEST_DBTSR__);
+}
+#endif
+
+#if 0
+static void set_rx_dma(GDMANCTRL *reg, unsigned long dma_addr, unsigned int length)
+{
+    reg->ST_DADR = dma_addr;
+    reg->HCOUNT = length / (4 * __RX_TEST_DBTSR__);
+}
+#else
+static void set_rx_dma(struct tcc_sata_dev *tcc_dev, struct tcc_sg_list * p_list)
+{
+    tcc_dev->is_rx_complete = 0;
+    tcc_dev->is_last_rx = (p_list->flags & _TCC_DMA_END_) ? 1 : 0;
+
+    tcc_dev->dma_rx_reg->ST_DADR = p_list->dma_addr;
+    tcc_dev->dma_rx_reg->HCOUNT = p_list->length / (4 * __RX_TEST_DBTSR__);
+}
+#endif
+
+/*
+ * success: return value => (ret == 0)
+ * fail   : return value => (ret != 0)
+ */
+static int confirm_dma_job(struct tcc_dma_Q *h)
+{
+    if (h) {
+        if (h->top != h->pre) {
+            h->top = h->pre;
+            return 1;
+        }
+        return 0;
+    }
+    return -1;
+}
+
+/*
+ * success: return value => (ret == 0)
+ * fail   : return value => (ret != 0)
+ */
+static int flush_dma_job(struct tcc_dma_Q *h)
+{
+   if (h) {
+       h->pre = h->bottom = h->top = 0;
+        return 0;
+    }
+    return -1;
+}
+
+/*
+ * success: return value => (ret == 0)
+ * fail   : return value => (ret != 0)
+ */
+static int push_dma_job(struct tcc_dma_Q *h, unsigned int dma_addr, unsigned int len, int flags)
+{
+    if (h) {
+        h->sg_list[h->pre].dma_addr = dma_addr;
+        h->sg_list[h->pre].length = len;
+        h->sg_list[h->pre].flags = flags;
+
+        if (h->pre + 1 >= TCC_SG_LIST_MAX) {
+            h->pre = 0;
+        } else {
+            h->pre++;
+        }
+
+        if (h->pre == h->bottom) {
+            printk("!!!!!!!!!!!! overflow !!!!!!!!!!!!!!!!!\n");
+        }
+        return 0;
+    }
+    return -1;
+}
+
+/*
+ * success: return value => (ret > 0)
+ * empty  : return value => (ret == 0)
+ * fail   : return value => (ret < 0)
+ */
+static int pop_dma_job(struct tcc_dma_Q *h, struct tcc_sg_list *p)
+{
+    if (h && p) {
+        if (h->top != h->bottom) {
+            memcpy(p, &(h->sg_list[h->bottom]), sizeof(struct tcc_sg_list));
+            if (h->bottom + 1 >= TCC_SG_LIST_MAX) {
+                h->bottom = 0;
+            } else {
+                h->bottom++;
+            }
+            return 1;
+        }
+        return 0;
+    }
+    return -1;
+}
+
+static void wait_for_bits(volatile PSATA pSata, int ret_on_rst, int timeout_val, int exp_val, int mask, int *matched)
+{
+    int timeout_cnt = 0, error = 0;
+    int failed;
+    int rdata = 0, i = 0;
+    int phy_sig_det_w = 1;
+
+    *matched = 0;
+
+    // wait for busy, and Drq to be cleared.
+    // or timeout or reset, if checking reset
+    while ((timeout_cnt < timeout_val)
+           && !*matched && (error == 0)
+           && !(!phy_sig_det_w && ret_on_rst)) {
+        rdata = pSata->CDR7;
+        failed = 0;
+
+        for (i = 0; i <= 31; i = i + 1) {
+            if ((((mask >> i) & 1) == 1) && (((rdata >> i) & 1) != ((exp_val >> i) & 1))) {
+                failed = 1;
+            }
+        }  
+
+        if (failed == 0) {
+            *matched = 1;
+        }
+
+        // After bits matched, check for error
+        if (*matched) {
+            if (((rdata & 0xff) != 0x7f) // we're not in Power on reset
+                && (((rdata >> CDR7_ERR) & 1) == 1))   // we do have error bit set
+            {
+                error = 1;
+            }
+        } else {
+            timeout_cnt = timeout_cnt + 1;
+        }
+
+    }
+
+    if ((ret_on_rst == 1) && !phy_sig_det_w) {
+        printk("wait_for_bits: detected a Non recov err, while waiting for bits on reg 0x%x\n",
+                   0x1C);
+    } else if (timeout_cnt >= timeout_val) {
+        printk("wait_for_bits: Timeout waiting reg at address '0x%x' to equal '0x%x'\n",
+                   0x1C, exp_val );
+    } else {
+        printk("wait_for_bits: Got register at address '0x%x' reg expected_value='0x%x', actual='0x%x'\n",
+        	     0x1C, exp_val, rdata);
+    }
+}
+
+static void wait_for_bsydrq(volatile PSATA pSata, int ret_on_rst, int timeout_val, int *matched)
+{
+    int exp_val = 0;
+    int mask = 0x88;
+
+    wait_for_bits(pSata, ret_on_rst, timeout_val, exp_val, mask, matched);
+}
+
+static int prog_host_speed(volatile PSATA pSata, int speed, int *spd_ok)
+{
+    int spd_select;
+    int reset;
+    int reg_data;
+    //int i;
+    int ret_on_rst;
+    int timeout_val;
+    int matched;
+
+    // Initialize
+    ret_on_rst  = 0;
+    //timeout_val = 1000000; // Must Be Huge For Speed Negotiation
+    timeout_val =   1000000; // Must Be Huge For Speed Negotiation
+
+    // Set speed
+    spd_select = (speed == 2) ? 0x2 : 0x1;
+
+    // Reset Device with correct speed
+    reset = 1;
+    reg_data = (spd_select << 4) | reset;
+
+    // Write SCR2 with speed and reset
+    pSata->SCR2 = reg_data;
+
+    // Need to wait a few clocks of slowest
+    //mdelay(1);
+    mdelay(10);
+
+    // Set normal operation & correct speed
+    reset = 0;
+    reg_data = spd_select << 4 | reset;
+    //HwSATA->nSCR2 = reg_data;
+    pSata->SCR2 = reg_data;
+
+    // Wait for BSY & DRQ to be cleared
+    wait_for_bsydrq(pSata, ret_on_rst, timeout_val, &matched);
+
+    if (matched) {
+        printk("prog_host_speed: Host Speed selected [speed:%d] SCR0[0x%X]\n",
+               speed, pSata->SCR0);
+        *spd_ok = 1;
+        return 0;
+    } else {
+        printk("prog_host_speed: TIMEOUT - Host Speed timed out waiting for speed change! [speed:%d], SCR0[0x%X]\n",
+               speed, pSata->SCR0);
+        *spd_ok = 0;
+    }
+    return -1;
+} 
+
+static int tcc_sata_hw_init(unsigned long sata_base)
+{
+    int spd_ok = 0;
+    volatile PSATA pSata = (volatile PSATA)sata_base;
+
+    if (prog_host_speed(pSata, 2, &spd_ok) == 0) {
+        return 0;
+    } else if (prog_host_speed(pSata, 1, &spd_ok) == 0) {
+        return 0;
+    }
+    return -1;
+}
+
+static int tcc_sata_check_atapi_dma(struct ata_queued_cmd *qc)
+{
+    u8 cmnd = qc->scsicmd->cmnd[0];
+
+    switch (cmnd) {
+    case READ_10:
+    case READ_12:
+    case READ_16:
+    case WRITE_10:
+    case WRITE_12:
+    case WRITE_16:
+        //printk("ATAPI DMA OK ~~~[0x%X]\n", cmnd);
+        return 0;
+
+    default:
+        //printk("ATAPI DMA FAIL [0x%X] ~~~\n", cmnd);
+        return -1;
+    }
+}
+
+static irqreturn_t tcc_dma_isr(int irq, void *dev_id)
+{
+    struct ata_host *host = (struct ata_host *)dev_id;
+    struct tcc_sata_dev *tcc_dev = host->private_data;
+
+    struct tcc_sg_list list;
+    if (irq == tcc_dev->dma_rx_irq) {
+        tcc_dev->dma_rx_reg->CHCTRL |= Hw3;
+        tcc_stop_dma(tcc_dev->dma_rx_reg);
+
+        if (tcc_dev->is_last_rx) {
+            tcc_dev->is_rx_complete = 1;
+            wake_up(&(tcc_dev->rx_dma_wait_q));
+        } else {
+            if (pop_dma_job(&(tcc_dev->dma_q), &list) > 0) {
+                if (list.flags & _TCC_DMA_RX_) {
+                    set_rx_dma(tcc_dev, &list);
+                    tcc_start_dma(tcc_dev->dma_rx_reg);
+                }
+            } else {
+                printk("something wrong !!!!!!!!!!!!!!!!!!!! [%s:%d]\n", __func__, __LINE__);
+                tcc_dev->is_rx_complete = 1;
+                wake_up(&(tcc_dev->rx_dma_wait_q));
+            }
+        }
+    } else if (irq == tcc_dev->dma_tx_irq) {
+        tcc_dev->dma_tx_reg->CHCTRL |= Hw3;
+        tcc_stop_dma(tcc_dev->dma_tx_reg);
+        if (tcc_dev->is_last_tx) {
+            writel(HSATA_DMACR_TXRX_CLEAR, tcc_dev->membase + HSATA_DMACR_REG);  /* rx/tx disable */
+            tcc_dev->is_tx_complete = 1;
+            wake_up(&(tcc_dev->tx_dma_wait_q));
+        } else {
+            if (pop_dma_job(&(tcc_dev->dma_q), &list) > 0) {
+                if (list.flags & _TCC_DMA_TX_) {
+                    set_tx_dma(tcc_dev, &list);
+                    tcc_start_dma(tcc_dev->dma_tx_reg);
+                }
+            } else {
+                printk("something wrong !!!!!!!!!!!!!!!!!!!! [%s:%d]\n", __func__, __LINE__);
+                tcc_dev->is_tx_complete = 1;
+                wake_up(&(tcc_dev->tx_dma_wait_q));
+            }
+        }
+    }
+    return IRQ_HANDLED;
+}
+
+static void tcc_port_stop(struct ata_port *ap)
+{
+    struct tcc_sata_dev *tcc_dev = ap->host->private_data;
+
+    if (tcc_dev) {
+        stop_sata_thread(tcc_dev);
+        free_irq(tcc_dev->dma_tx_irq, ap->host);
+        free_irq(tcc_dev->dma_rx_irq, ap->host);
+
+        if (tcc_dev->membase) {
+            iounmap(tcc_dev->membase);
+            kfree(tcc_dev);
+        }
+    }
+    ap->host->private_data = NULL;
+}
+
+static int fetch_dma_thread(void *arg)
+{
+    struct tcc_sata_dev *tcc_dev = (struct tcc_sata_dev *)arg;
+    int ret = 0;
+
+    sata_printk("### start kernel thread ###\n");
+    if (tcc_dev) {
+        struct tcc_sg_list list;
+        do {
+            ret = wait_event_interruptible_timeout(tcc_dev->job_wait_q,
+                                                   (tcc_dev->dma_q.top != tcc_dev->dma_q.bottom) || !(tcc_dev->is_continue),
+                                                   msecs_to_jiffies(1000));
+            while (tcc_dev->is_continue) {
+                if (pop_dma_job(&(tcc_dev->dma_q), &list) > 0) {
+                    sata_printk("--- DMA [%s] dma_addr[0x%X], len[%d], flags[0x%X]\n",
+                                list.flags & _TCC_DMA_RX_ ? "RX" : "TX", list.dma_addr, list.length, list.flags);
+
+                    //ret = readl(tcc_dev->membase + HSATA_DBTSR_REG);
+                    //printk("before Rx/Tx DBTSR_REG[0x%X], dma HCOUNT[0x%X]\n", ret, tcc_dev->dma_rx_reg->HCOUNT);
+
+                    if (list.flags & _TCC_DMA_START_) {
+                        //printk("--- start DMA [%s] dma_addr[0x%X], len[%d], flags[0x%X]\n",
+                        //            list.flags & _TCC_DMA_RX_ ? "RX" : "TX", list.dma_addr, list.length, list.flags);
+
+                        writel(HSATA_DMACR_TXRX_CLEAR, tcc_dev->membase + HSATA_DMACR_REG);  /* rx/tx disable */
+                        writel(HSATA_DMA_DBTSR_VAL, tcc_dev->membase + HSATA_DBTSR_REG);
+
+                        writel((list.flags & _TCC_DMA_RX_) ? HSATA_DMACR_RX_EN : HSATA_DMACR_TX_EN,
+                               tcc_dev->membase + HSATA_DMACR_REG);
+                        if (list.flags & _TCC_DMA_RX_) {
+                            set_rx_dma(tcc_dev, &list);
+                            tcc_start_dma(tcc_dev->dma_rx_reg);
+                            if (wait_event_interruptible_timeout((tcc_dev->rx_dma_wait_q),
+                                                                 tcc_dev->is_rx_complete,
+                                                                 msecs_to_jiffies(WAIT_TIME_FOR_DMA_DONE)) == 0) {
+                                tcc_stop_dma(tcc_dev->dma_rx_reg);
+                                flush_dma_job(&(tcc_dev->dma_q));
+                                ret = readl(tcc_dev->membase + HSATA_DBTSR_REG);
+                                printk("[%s:%d] RX wait_event timeout  (%dms) !!!\n",
+                                       __func__, __LINE__, WAIT_TIME_FOR_DMA_DONE);
+                                printk("rx DBTSR_REG[0x%X], dma HCOUNT[0x%X]\n", ret, tcc_dev->dma_rx_reg->HCOUNT);
+                            }
+                        } else {
+                            set_tx_dma(tcc_dev, &list);
+                            tcc_start_dma(tcc_dev->dma_tx_reg);
+                            if (wait_event_interruptible_timeout((tcc_dev->tx_dma_wait_q),
+                                                                 tcc_dev->is_tx_complete,
+                                                                 msecs_to_jiffies(WAIT_TIME_FOR_DMA_DONE)) == 0) {
+                                tcc_stop_dma(tcc_dev->dma_tx_reg);
+                                flush_dma_job(&(tcc_dev->dma_q));
+                                ret = readl(tcc_dev->membase + HSATA_DBTSR_REG);
+                                printk("[%s:%d] TX wait_event timeout  (%dms) !!!\n",
+                                       __func__, __LINE__, WAIT_TIME_FOR_DMA_DONE);
+                                printk("tx DBTSR_REG[0x%X], dma HCOUNT[0x%X]\n", ret, tcc_dev->dma_tx_reg->HCOUNT);
+                            }
+                        }
+                    } else {
+                        flush_dma_job(&(tcc_dev->dma_q));
+                        printk("[%s:%d] mismatch q-list !!!\n", __func__, __LINE__);
+                    }
+                } else {
+                    break;
+                }
+            }
+        } while (!kthread_should_stop());
+    }
+    sata_printk("### end kernel thread ###\n");
+    return 0;
+}
+
+static int tcc_port_start(struct ata_port *ap)
+{
+    volatile u32 val32;
+    struct tcc_sata_dev *tcc_dev = NULL;
+	volatile PPIC pPIC = (volatile PPIC)tcc_p2v(HwPIC_BASE);
+    int ret = 0;
+    unsigned long sata_base = 0;
+    unsigned long tx_base = (unsigned long)tcc_p2v(HwGDMA2_BASE);
+    unsigned long rx_base = (unsigned long)tcc_p2v(HwGDMA3_BASE);
+    unsigned long mmio_base_addr = (unsigned long)(ap->private_data);
+
+    tcc_dev = kmalloc(sizeof(struct tcc_sata_dev), GFP_KERNEL);
+    if (tcc_dev) {
+        memset(tcc_dev, 0, sizeof(struct tcc_sata_dev));
+        tcc_dev->membase = ioremap_nocache(mmio_base_addr, 0x800);
+        tcc_sata_setup_port(&ap->ioaddr, tcc_dev->membase);
+        ap->host->private_data = tcc_dev;
+    } else {
+        printk("[%s:%d] cannot allocate 'tcc_dev struct' \n", __func__, __LINE__);
+        return -1;
+    }
+    HSATA_ENABLE_INTERRUPTS(tcc_dev);
+
+    tcc_dev->dma_tx_reg = (GDMANCTRL *)(tx_base + 0x60);
+    tcc_dev->dma_rx_reg = (GDMANCTRL *)(rx_base + 0x60);
+
+    tcc_dev->dma_tx_irq = INT_DMA2_CH2;
+    tcc_dev->dma_rx_irq = INT_DMA3_CH2;
+
+    BITSET(pPIC->MODE0, Hw29);	// level-trigger
+    BITCLR(pPIC->POL0, Hw29);	// active-high
+
+    init_waitqueue_head(&(tcc_dev->job_wait_q));
+    init_waitqueue_head(&(tcc_dev->tx_dma_wait_q));
+    init_waitqueue_head(&(tcc_dev->rx_dma_wait_q));
+
+    init_rx_dma(tcc_dev->dma_rx_reg, TCC_DMADR_REG_ADDR);
+    init_tx_dma(tcc_dev->dma_tx_reg, TCC_DMADR_REG_ADDR);
+    writel(HSATA_DMACR_TXMODE_BIT, tcc_dev->membase + HSATA_DMACR_REG);  /* disable */
+
+    tcc_dev->fetch_task = start_sata_thread(fetch_dma_thread, tcc_dev, "tcc_sata_task");
+    if (tcc_dev->fetch_task == NULL) {
+        return -1;
+    }
+
+    ret = request_irq(tcc_dev->dma_rx_irq,
+                      tcc_dma_isr,
+                      IRQF_SHARED,              /* flags */
+                      "HSATA-DMA-RX",    /* in /proc/interrupts */
+                      ap->host); /* user data passed to ISR */
+    if (!ret) {
+        ret = request_irq(tcc_dev->dma_tx_irq,
+                          tcc_dma_isr,
+                          IRQF_SHARED,              /* flags */
+                          "HSATA-DMA-TX",    /* in /proc/interrupts */
+                          ap->host); /* user data passed to ISR */
+        if (!ret) {
+            sata_base = (unsigned long)tcc_p2v(HwSATA_BASE);
+            tcc_sata_hw_init(sata_base);
+
+            writel(HSATA_DMA_DBTSR_VAL, tcc_dev->membase + HSATA_DBTSR_REG);
+
+            val32 = readl(tcc_dev->membase + HSATA_SCR0_REG);
+            switch (HSATA_SCR0_SPD_GET(val32)) {
+            case 0x0:
+                printk("Rx_DBTSR[%d] Tx_DBTSR[%d] **** NO NEGOTIATED SPEED!!! ****\n", __RX_TEST_DBTSR__, __TX_TEST_DBTSR__);
+                break;
+            case 0x1:
+                printk("Rx_DBTSR[%d] Tx_DBTSR[%d] **** GEN I RATE NEGOTIATED ****\n", __RX_TEST_DBTSR__, __TX_TEST_DBTSR__);
+                break;
+            case 0x2:
+                printk("Rx_DBTSR[%d] Tx_DBTSR[%d] **** GEN II RATE NEGOTIATED ****\n", __RX_TEST_DBTSR__, __TX_TEST_DBTSR__);
+                break;
+            }
+            return 0;
+        } else {
+            printk("ERROR rx request_irq ret[%d]\n", ret);
+            free_irq(tcc_dev->dma_rx_irq, ap->host);
+        }
+    } else {
+        printk("ERROR tx request_irq ret[%d]\n", ret);
+    }
+    return -1;
+}
+
+
+static int tcc_scr_read(struct ata_link *link, unsigned int sc_reg, u32 *val)
+{
+    if (sc_reg > SCR_CONTROL) {
+        return -EINVAL;
+    }
+    *val = readl((void *)link->ap->ioaddr.scr_addr + (sc_reg * 4));
+    return 0;
+}
+
+static int tcc_scr_write(struct ata_link *link, unsigned int sc_reg, u32 val)
+{
+    if (sc_reg > SCR_CONTROL) {
+        return -EINVAL;
+    }
+    writel(val, (void *)link->ap->ioaddr.scr_addr + (sc_reg * 4));
+    return 0;
+}
+
+static void tcc_tf_load(struct ata_port *ap, const struct ata_taskfile *tf)
+{
+    unsigned int is_addr = tf->flags & ATA_TFLAG_ISADDR;
+
+    sata_printk("TFLAGS: %s %s %s %s\n",
+                (tf->flags & ATA_TFLAG_LBA48) ? "LBA48" : "NOT-LBA48", 
+                (tf->flags & ATA_TFLAG_ISADDR) ? "ISADDR" : "", 
+                (tf->flags & ATA_TFLAG_DEVICE) ? "DEVICE" : "", 
+                (tf->flags & ATA_TFLAG_WRITE) ? "WRITE" : "READ"); 
+    sata_printk("CTL: %s %s %s\n", 
+                (tf->ctl & ATA_HOB) ? "HOB" : "NOT-HOB", 
+                (tf->ctl & ATA_SRST) ? "SRST" : "NOT-SRST", 
+                (tf->ctl & ATA_NIEN) ? "NIEN" : "INTERRUPTS-ENABLED"); 
+
+    if (is_addr && (tf->flags & ATA_TFLAG_LBA48)) {
+        sata_printk("hob: feat=0x%X nsect=0x%X, lba:0x%X 0x%X 0x%X\n",
+                    tf->hob_feature,
+                    tf->hob_nsect,
+                    tf->hob_lbal,
+                    tf->hob_lbam,
+                    tf->hob_lbah);
+    }
+
+    if (is_addr) {
+        sata_printk("feat=0x%X nsect=0x%X, lba:0x%X 0x%X 0x%X\n",
+                    tf->feature,
+                    tf->nsect,
+                    tf->lbal,
+                    tf->lbam,
+                    tf->lbah);
+    }
+
+    if (tf->flags & ATA_TFLAG_DEVICE) {
+        sata_printk("ATA_TFLAG_DEVICE device=0x%X (%s)\n", tf->device, 
+                    (tf->device & ATA_LBA) ? "LBA" : "CHS");
+    }
+
+    if (!is_addr) {
+        sata_printk("is_addr=%d\n", is_addr);
+    }
+
+    ata_sff_tf_load(ap, tf);
+}
+
+static void tcc_tf_read(struct ata_port *ap, struct ata_taskfile *tf)
+{
+    jprintk("          nsect=0x%X, lba:0x%X 0x%X 0x%X device=0x%x\n",
+            tf->nsect, tf->lbal, tf->lbam, tf->lbah, tf->device);
+
+    if (tf->flags & ATA_TFLAG_LBA48) {
+        jprintk("hob: feat=0x%X nsect=0x%X, lba:0x%X 0x%X 0x%X\n",
+                tf->hob_feature, tf->hob_nsect, tf->hob_lbal,
+                tf->hob_lbam, tf->hob_lbah);
+    }
+
+    ata_sff_tf_read(ap, tf);
+}
+
+static struct scsi_host_template tcc_sata_sht = {
+	ATA_BMDMA_SHT(DRV_NAME),
+};
+
+static u8 tcc_stat_check_status(struct ata_port *ap)
+{
+	return ioread8(ap->ioaddr.status_addr);
+}
+
+static void tcc_dma_setup_noexec_by_tag(struct ata_queued_cmd *qc, u8 tag)
+{
+    //struct tcc_sata_dev *tcc_dev = qc->ap->host->private_data;
+    jprintk("DMA SETUP tag=%d id=%d [%s]\n", tag, qc->ap->print_id, (qc->dma_dir == DMA_TO_DEVICE) ? "WRITE" : "READ");
+}
+
+static void tcc_exec_command(struct ata_port *ap, const struct ata_taskfile *tf)
+{
+    tcc_exec_command_by_tag(ap, tf, 0);
+}
+
+static void tcc_dma_setup_by_tag(struct ata_queued_cmd *qc, u8 tag)
+{
+    tcc_dma_setup_noexec_by_tag(qc, tag);
+    tcc_exec_command(qc->ap, &qc->tf);
+}
+
+
+void tcc_dma_setup(struct ata_queued_cmd *qc)
+{
+    //struct tcc_sata_dev *tcc_dev = qc->ap->host->private_data;
+    tcc_dma_setup_by_tag(qc, 0);
+
+}
+
+void tcc_dma_start_by_tag(struct ata_queued_cmd *qc, u8 tag)
+{
+    struct tcc_sata_dev *tcc_dev = qc->ap->host->private_data;
+
+    confirm_dma_job(&(tcc_dev->dma_q));
+    wake_up(&(tcc_dev->job_wait_q));
+}
+
+
+static void tcc_dma_start(struct ata_queued_cmd *qc)
+{
+    tcc_exec_command(qc->ap, &qc->tf);
+    tcc_dma_start_by_tag(qc, 0);
+}
+
+void tcc_dma_stop(struct ata_queued_cmd *qc)
+{
+    struct tcc_sata_dev *tcc_dev = qc->ap->host->private_data;
+    if (qc->dma_dir != DMA_TO_DEVICE) {
+        writel(HSATA_DMACR_TXRX_CLEAR, tcc_dev->membase + HSATA_DMACR_REG);  /* rx/tx disable */
+    } else {
+        //writel(HSATA_DMACR_TXRX_CLEAR, tcc_dev->membase + HSATA_DMACR_REG);  /* rx/tx disable */
+    }
+}
+
+
+u8 tcc_dma_status(struct ata_port *ap)
+{
+    //struct tcc_sata_dev *tcc_dev = qc->ap->host->private_data;
+    return ATA_DMA_INTR;
+}
+
+void tcc_irq_clear(struct ata_port *ap)
+{
+    /* read status reg to clear interrupt in controller */
+    ata_sff_check_status(ap);
+}
+
+static void tcc_exec_command_by_tag(struct ata_port *ap, const struct ata_taskfile *tf, u8 tag)
+{
+    struct ata_host *host = ap->host;
+    struct tcc_sata_dev *tcc_dev = host->private_data;
+    volatile u32 val32;
+
+    switch (tf->command) {
+    case ATA_CMD_CHK_POWER:
+        jprintk("ATA_CMD_CHK_POWER - tag=%d\n", tag); break;
+    case ATA_CMD_EDD:
+        jprintk("ATA_CMD_EDD - tag=%d\n", tag); break;
+    case ATA_CMD_FLUSH:
+        jprintk("ATA_CMD_FLUSH - tag=%d\n", tag); break;
+    case ATA_CMD_FLUSH_EXT:
+        jprintk("ATA_CMD_FLUSH_EXT - tag=%d\n", tag); break;
+    case ATA_CMD_ID_ATA:
+        jprintk("ATA_CMD_ID_ATA - tag=%d\n", tag); break;
+    case ATA_CMD_ID_ATAPI:
+        jprintk("ATA_CMD_ID_ATAPI - tag=%d\n", tag); break;
+    case ATA_CMD_READ:
+        jprintk("ATA_CMD_READ - tag=%d\n", tag); break;
+    case ATA_CMD_READ_EXT:
+        jprintk("ATA_CMD_READ_EXT - tag=%d\n", tag); break;
+    case ATA_CMD_WRITE:
+        jprintk("ATA_CMD_WRITE - tag=%d\n", tag); break;
+    case ATA_CMD_WRITE_EXT:
+        jprintk("ATA_CMD_WRITE_EXT - tag=%d\n", tag); break;
+    case ATA_CMD_PIO_READ:
+        jprintk("ATA_CMD_PIO_READ - tag=%d\n", tag); break;
+    case ATA_CMD_PIO_READ_EXT:
+        jprintk("ATA_CMD_PIO_READ_EXT - tag=%d\n", tag); break;
+    case ATA_CMD_PIO_WRITE:
+        jprintk("ATA_CMD_PIO_WRITE - tag=%d\n", tag); break;
+    case ATA_CMD_PIO_WRITE_EXT:
+        jprintk("ATA_CMD_PIO_WRITE_EXT - tag=%d\n", tag); break;
+    case ATA_CMD_SET_FEATURES:
+        jprintk("ATA_CMD_SET_FEATURES - tag=%d\n", tag); break;
+    case ATA_CMD_PACKET:
+        jprintk("ATA_CMD_PACKET - tag=%d\n", tag); break;
+    case HSATA_CMD_QWRITE:
+        jprintk("HSATA_CMD_QWRITE - tag=%d\n", tag); break;
+    case HSATA_CMD_QREAD:
+        jprintk("HSATA_CMD_QREAD - tag=%d\n", tag); break;
+    default:
+        jprintk("ATA_CMD_??? (0x%X)\n", tf->command); break;
+    }
+
+    val32 = readl(tcc_dev->membase + HSATA_SERROR_REG);
+    jprintk("SERROR=0x%X\n", val32 );
+    writel(val32, tcc_dev->membase + HSATA_SERROR_REG);
+    val32 = readl(tcc_dev->membase + HSATA_INTPR_REG);
+    jprintk("INTPR=0x%x\n",    val32);
+
+    ata_sff_exec_command(ap, tf);
+}
+
+void tcc_qc_prep_by_tag(struct ata_queued_cmd *qc, u8 tag)
+{
+    struct scatterlist *sg = qc->sg;  /* include/asm-arm/scatterlist.h */
+    struct ata_port *ap = qc->ap;
+    struct tcc_sata_dev *tcc_dev = ap->host->private_data;
+    unsigned int nelem;
+    int dir, flags = _TCC_DMA_START_;
+    unsigned int fis_len = 0, dma_addr = 0, sg_len = 0, offset = 0, len = 0;
+
+    if (!(qc->flags & ATA_QCFLAG_DMAMAP)) {
+        jprintk("NO DMA - exiting\n");
+        return;
+    }
+
+#if 0
+    assert(sg != NULL);
+    assert(qc->n_elem > 0);
+#endif
+
+    dir = qc->dma_dir;
+
+    jprintk("QC PREP id=%d dma dir=%s n_elem=%d\n", 
+            qc->ap->print_id, (dir == DMA_FROM_DEVICE) ? "FROM_DEVICE" : "TO_DEVICE", qc->n_elem);
+
+    for (nelem = qc->n_elem; nelem; nelem--) {
+        dma_addr = (unsigned int)sg_dma_address(sg);
+        sg_len = sg_dma_len(sg);
+        while (sg_len) {
+
+            flags |= ((dir == DMA_TO_DEVICE) ? _TCC_DMA_TX_ : _TCC_DMA_RX_);
+
+            offset = dma_addr & 0xFFFF;
+            len = sg_len;
+
+            if ((offset + sg_len) > 0x10000) {
+                printk("overflow !!!!!!!!!! offset[%u], sg_len[%u]\n", offset, sg_len);
+                len = 0x10000 - offset;
+            }
+
+            if ((fis_len + len) > 8192) {
+                sata_printk("SPLITTING: fis_len=%d/0x%x  len=%d/0x%x\n", fis_len, fis_len, len, len);
+                len = (8192 - fis_len);
+                fis_len = 0;
+            } else {
+                fis_len += len;
+            }
+
+            if (fis_len == 8192) {
+                fis_len = 0;
+            }
+
+            sata_printk("+++ DMA sg nelem=%d dma_addr=0x%X sg_len=%d [%s]\n",
+                   qc->n_elem, dma_addr, sg_len, (dir == DMA_TO_DEVICE) ? "TX" : "RX");
+
+            sg_len -= len;
+            if ((sg_len == 0) && (nelem == 1)) {
+                flags |= _TCC_DMA_END_;
+                sata_printk("********* LAST DMA LIST *********\n");
+            }
+
+            push_dma_job(&(tcc_dev->dma_q), dma_addr, len, flags);
+            dma_addr += len;
+            flags = 0;
+        }
+        sg++;
+    }
+}
+
+static void tcc_qc_prep(struct ata_queued_cmd *qc)
+{
+    if (!(qc->flags & ATA_QCFLAG_DMAMAP)) {
+        return;
+    }
+    tcc_qc_prep_by_tag(qc, 0);
+}
+
+
+static unsigned int tcc_qc_issue_prot(struct ata_queued_cmd *qc)
+{
+    jprintk("id=%d\n", qc->ap->print_id);
+
+    /* see promise driver also */
+    switch (qc->tf.protocol) {
+    case ATA_PROT_DMA:
+        jprintk("ATA_PROT_DMA\n");
+        break;
+    case ATA_PROT_PIO:
+        jprintk("ATA_PROT_PIO\n");
+        break;
+    }
+    return ata_sff_qc_issue(qc);
+}
+
+static struct ata_port_operations tcc_sata_ops = {
+	//.inherits		= &ata_bmdma_port_ops,
+	//.inherits		= &sata_pmp_port_ops,
+
+    .inherits       = &ata_sff_port_ops,
+    .mode_filter        = ata_bmdma_mode_filter,
+    .bmdma_setup        = tcc_dma_setup,
+    .bmdma_start        = tcc_dma_start,
+    .bmdma_stop     = tcc_dma_stop,
+    .bmdma_status       = tcc_dma_status,
+
+    .sff_exec_command     = tcc_exec_command,
+
+	.sff_tf_load		= tcc_tf_load,
+	.sff_tf_read		= tcc_tf_read,
+	.sff_check_status	= tcc_stat_check_status,
+	.check_atapi_dma	= tcc_sata_check_atapi_dma,
+
+	.scr_read		= tcc_scr_read,
+	.scr_write		= tcc_scr_write,
+
+	.port_start     = tcc_port_start,
+	.port_stop      = tcc_port_stop,
+    .sff_irq_clear      = tcc_irq_clear,
+
+    .qc_prep        = tcc_qc_prep,
+    .qc_issue       = tcc_qc_issue_prot,
+
+};
+
+static void tcc_sata_setup_port(struct ata_ioports *port, void __iomem *base)
+{
+    port->cmd_addr          = base + 0x00; 
+    port->data_addr         = base + 0x00;
+
+
+    port->error_addr        = base + 0x04;
+    port->feature_addr      = base + 0x04;
+
+    port->nsect_addr        = base + 0x08;
+
+    port->lbal_addr         = base + 0x0c;
+    port->lbam_addr         = base + 0x10;
+    port->lbah_addr         = base + 0x14;
+
+    port->device_addr       = base + 0x18;
+
+    port->command_addr      = base + 0x1c;
+    port->status_addr       = base + 0x1c;
+
+    port->altstatus_addr    = base + 0x20;
+    port->ctl_addr          = base + 0x20;
+
+    {
+        unsigned long sata_base = (unsigned long)tcc_p2v(HwGDMA2_BASE);
+        sata_base += 0x60;
+        port->bmdma_addr        = (void __iomem *)(sata_base);  /* we better never use this */
+    }
+    port->scr_addr          = base + 0x24;
+
+}
+
+static const struct ata_port_info sata_tcc_port_info[] = {
+    {
+        .flags = (ATA_FLAG_SATA /* loik ??? flags */
+                  | ATA_FLAG_NO_LEGACY /* no legacy mode check */
+                  //| ATA_FLAG_SRST /* use ATA SRST, not E.D.D. */
+                 | ATA_FLAG_MMIO), /* use MMIO, not PortIO */
+
+        .pio_mask   = 0x1f, /* pio0-4  - IDENTIFY DEVICE word 63 */
+        .udma_mask  = 0x7f, /* udma0-6 - IDENTIFY DEVICE word 88 */
+        //.mwdma_mask = 0x07, /* mwdma0-2  - IDENTIFY DEVICE word 64 */
+        .port_ops   = &tcc_sata_ops,
+    },
+};
+
+static irqreturn_t tcc_sata_isr(int irq, void *dev_id)
+{
+    struct ata_host *host = (struct ata_host *)dev_id;
+    struct tcc_sata_dev *tcc_dev = host->private_data;
+    struct ata_port *ap;
+    volatile u32 intpr;
+    volatile u32 val32;
+    unsigned int handled = 0;
+    unsigned int i;
+    u32 err_interrupt;
+    u8  tag;
+    volatile u32 sactive, tmp;
+    struct ata_queued_cmd *qc;
+    //unsigned long flags;
+
+    //spin_lock_irqsave(&host->lock, flags);
+
+    ap = host->ports[0];
+
+    intpr = readl(tcc_dev->membase + HSATA_INTPR_REG);
+    jprintk("INTPR=0x%x\n", intpr);
+
+    if (intpr & HSATA_INTMR_ERRM_BIT) {
+        val32 = readl(tcc_dev->membase + HSATA_SERROR_REG);  
+        sata_printk("============> SERROR=0x%08x INTPR=0x%x\n", val32, intpr);
+        writel(val32, tcc_dev->membase + HSATA_SERROR_REG);  /* to clear */
+        writel(HSATA_INTMR_ERRM_BIT, tcc_dev->membase + HSATA_INTPR_REG);  /* to clear */
+        err_interrupt = 1;
+        handled = 1;
+        goto DONE;
+    } else {
+        err_interrupt = 0;
+    }
+
+    tmp = readl(tcc_dev->membase + HSATA_SACTIVE_REG);
+    jprintk("SACTIVE=0x%x\n", tmp);
+
+    if (intpr & HSATA_INTMR_NEWFP_BIT) {
+        writel(HSATA_INTMR_NEWFP_BIT, tcc_dev->membase + HSATA_INTPR_REG);  /* to clear */
+        tag = ((u8)readl(tcc_dev->membase + HSATA_FPTAGR_REG)) & 0x1f;
+        sata_printk("============> NEWFP tag=%d\n", tag);
+        handled = 1;
+        goto DONE;
+    }
+
+    if (intpr & HSATA_INTMR_DMAT_BIT) {
+        writel(HSATA_INTMR_DMAT_BIT, tcc_dev->membase + HSATA_INTPR_REG);  /* to clear */
+        sata_printk("============> HSATA_INTMR_DMAT_BIT\n");
+        handled = 1;
+        goto DONE;
+    }
+    if (intpr & HSATA_INTMR_PMABORT) {
+        writel(HSATA_INTMR_PMABORT, tcc_dev->membase + HSATA_INTPR_REG);  /* to clear */
+        sata_printk("============> HSATA_INTMR_PMABORT\n");
+        handled = 1;
+        goto DONE;
+    }
+    if (intpr & HSATA_INTMR_NEWBIST_BIT) {
+        writel(HSATA_INTMR_NEWBIST_BIT, tcc_dev->membase + HSATA_INTPR_REG);  /* to clear */
+        sata_printk("============> HSATA_INTMR_NEWBIST_BIT\n");
+        handled = 1;
+        goto DONE;
+    }
+    if (intpr & HSATA_INTMR_PRIMERR_BIT) {
+        writel(HSATA_INTMR_PRIMERR_BIT, tcc_dev->membase + HSATA_INTPR_REG);  /* to clear */
+        sata_printk("============> HSATA_INTMR_PRIMERR_BIT\n");
+        handled = 1;
+        goto DONE;
+    }
+    if (intpr & HSATA_INTMR_CMDABORT_BIT) {
+        writel(HSATA_INTMR_CMDABORT_BIT, tcc_dev->membase + HSATA_INTPR_REG);  /* to clear */
+        sata_printk("============> HSATA_INTMR_CMDABORT_BIT\n");
+        handled = 1;
+        goto DONE;
+    }
+    if (intpr & HSATA_INTMR_CMDGOOD_BIT) {
+        writel(HSATA_INTMR_CMDGOOD_BIT, tcc_dev->membase + HSATA_INTPR_REG);  /* to clear */
+        jprintk("============> HSATA_INTMR_CMDGOOD_BIT\n");
+        handled = 1;
+        goto DONE;
+    }
+
+    sactive = readl(tcc_dev->membase + HSATA_SACTIVE_REG);  /* remaining pending */
+    if (sactive) {
+        sata_printk("UNEXPECTED SACTIVE???  sactive=0x%x\n", sactive );
+    }
+
+    for (i = 0; i < host->n_ports; i++) {
+        struct ata_port *ap;
+
+        ap = host->ports[i];
+        if (ap &&
+            !(ap->flags & ATA_FLAG_DISABLED)) {
+
+            qc = ata_qc_from_tag(ap, ap->link.active_tag);
+            if (qc && (!(qc->tf.flags & ATA_TFLAG_POLLING)) &&
+                (qc->flags & ATA_QCFLAG_ACTIVE)) {
+                handled |= ata_sff_host_intr(ap, qc);
+            }
+        }
+    }
+
+    sata_printk("====================> INTR DONE\n");
+    if (handled == 0) {
+        sata_printk("handled error !!!!!!!!!  \n");
+        if ((qc = ata_qc_from_tag(ap, ap->link.active_tag))) {
+            ata_qc_complete(qc);
+        }
+        ata_sff_check_status(ap); 
+        handled = 1;
+    }
+
+    //spin_unlock_irqrestore(&host->lock, flags);
+DONE:
+    return IRQ_RETVAL(handled);
+}
+
+static int tcc_sata_remove(struct platform_device *pdev)
+{
+    struct ata_host *host = platform_get_drvdata(pdev);
+    //struct tcc_sata_dev *tcc_dev = NULL;
+
+    if (host) {
+        ata_host_detach(host);
+    }
+    return 0;
+}
+
+static int __init tcc_sata_probe(struct platform_device *pdev)
+{
+	const struct ata_port_info *ppi[] = { &(sata_tcc_port_info[0]), NULL };
+	struct ata_host *host;
+	int n_ports;
+    struct resource *res;
+    struct ata_port *ap = NULL;
+    int irq = -1;
+    PPMU p_pmu = (PPMU)tcc_p2v(HwPMU_BASE);
+    volatile PPIC pPIC = (volatile PPIC)tcc_p2v(HwPIC_BASE);
+
+    printk("TCC SATA version " DRV_VERSION "\n");
+
+    BITCLR(p_pmu->PWROFF, Hw4); // SATA popwer on
+    tca_ckc_setiobus(RB_SATAHCONTROLLER, 1);
+
+    BITSET(pPIC->SEL1, 1 << (INT_SATA - 32));
+    BITSET(pPIC->MODE1, 1 << (INT_SATA - 32));
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		return -EINVAL;
+    }
+    irq = platform_get_irq(pdev, 0);
+
+	/* allocate host */
+	n_ports = 1;
+	host = ata_host_alloc_pinfo(&pdev->dev, ppi, n_ports);
+	if (!host) {
+		return -ENOMEM;
+    }
+
+    ap = host->ports[0];
+    ap->private_data = (void *)(res->start);
+	platform_set_drvdata(pdev, host);
+
+	return ata_host_activate(host, irq, tcc_sata_isr, IRQF_SHARED, &tcc_sata_sht);
+	//return ata_host_activate(host, irq, ata_sff_interrupt, IRQF_SHARED, &tcc_sata_sht);
+}
+
+static struct platform_driver tcc_sata_driver = {
+    .probe = tcc_sata_probe,
+	.remove = tcc_sata_remove,
+	.driver = {
+		.name = "tcc-sata",
+		.owner = THIS_MODULE,
+	},
+};
+
+#ifdef CONFIG_SATA_TCC
+static stpwrinfo sata_pwrinfo = { PWR_STATUS_ON };
+/**********************************************************************
+ * [The condition of SATA power control ]
+ *  1 The Main-Board must be greater than version 1.0 or equal.
+ *  2 And you need to fix the Main-Board. (refer to the schematic)
+ * ********************************************************************/
+static int sata_pwr_ctl(void *h_private, int cmd, void *p_out)
+{
+    int ret = -EINVAL;
+    PPMU p_pmu = (PPMU)tcc_p2v(HwPMU_BASE);
+
+    switch (cmd) {
+    case PWR_CMD_OFF:
+		sata_printk("PWR_CMD_OFF command ==> [%d]\n", cmd);
+        if (sata_pwrinfo.status == PWR_STATUS_ON) {
+            platform_driver_unregister(&tcc_sata_driver);
+            tcc_pca953x_setup(PCA9539_U2_SLAVE_ADDR, SATA_ON, OUTPUT, LOW, SET_DIRECTION | SET_VALUE);
+            BITSET(p_pmu->PWROFF, Hw4); // SATA popwer off
+            tca_ckc_setiobus(RB_SATAHCONTROLLER, 0);
+            sata_pwrinfo.status = PWR_STATUS_OFF;
+            ret = 0;
+        } else {
+            //printk("already SATA power is ON !!!\n");
+            ret = 0;
+        }
+		break;
+    case PWR_CMD_ON:
+		sata_printk("PWR_CMD_ON command ==> [%d]\n", cmd);
+        if (sata_pwrinfo.status == PWR_STATUS_OFF) {
+            tcc_pca953x_setup(PCA9539_U2_SLAVE_ADDR, SATA_ON, OUTPUT, HIGH, SET_DIRECTION | SET_VALUE);
+            if (platform_driver_register(&tcc_sata_driver) == 0) {
+                sata_pwrinfo.status = PWR_STATUS_ON;
+                ret = 0;
+            } else {
+                ret = -EIO;
+                tcc_pca953x_setup(PCA9539_U2_SLAVE_ADDR, SATA_ON, OUTPUT, LOW, SET_DIRECTION | SET_VALUE);
+                BITSET(p_pmu->PWROFF, Hw4); // SATA popwer off
+                tca_ckc_setiobus(RB_SATAHCONTROLLER, 0);
+                printk("cannot register a SATA driver !!!\n");
+            }
+        } else {
+            //printk("already SATA power is OFF !!!\n");
+            ret = 0;
+        }
+		break;
+    case PWR_CMD_GETSTATUS:
+		sata_printk("PWR_CMD_GETSTATUS command ==> [%d]\n", cmd);
+		memcpy(p_out, &sata_pwrinfo, sizeof(stpwrinfo));
+        ret = 0;
+		break;
+        /*
+	case PWR_CMD_MAX:
+		printk("PWR_CMD_MAX command ==> [%d]\n", cmd);
+		break;
+        */
+    default:
+        printk("unknown pwr command !!! ==> [%d]\n", cmd);
+        break;
+    }
+    return ret;
+}
+#endif
+
+static int __init tcc_sata_init(void)
+{
+    tcc_pca953x_setup(PCA9539_U3_SLAVE_ADDR, PWR_GP4, OUTPUT, HIGH, SET_DIRECTION | SET_VALUE);
+    tcc_pca953x_setup(PCA9539_U2_SLAVE_ADDR, SATA_ON, OUTPUT, HIGH, SET_DIRECTION | SET_VALUE);
+#ifdef CONFIG_SATA_TCC
+    sata_pwrinfo.status = PWR_STATUS_ON;
+    insert_pwm_node(DEVICE_SATA, sata_pwr_ctl, NULL);
+#endif
+	//return platform_driver_probe(&tcc_sata_driver, tcc_sata_probe);
+	return platform_driver_register(&tcc_sata_driver);
+}
+
+static void __exit tcc_sata_exit(void)
+{
+    PPMU p_pmu = (PPMU)tcc_p2v(HwPMU_BASE);
+#ifdef CONFIG_SATA_TCC
+	remove_pwm_node(DEVICE_SATA);
+#endif
+	platform_driver_unregister(&tcc_sata_driver);
+
+    BITSET(p_pmu->PWROFF, Hw4); // SATA popwer off
+    tca_ckc_setiobus(RB_SATAHCONTROLLER, 0);
+    tcc_pca953x_setup(PCA9539_U2_SLAVE_ADDR, SATA_ON, OUTPUT, LOW, SET_DIRECTION | SET_VALUE);
+}
+
+MODULE_AUTHOR("Telechips");
+MODULE_DESCRIPTION("TCC SATA controller");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
+
+module_init(tcc_sata_init);
+module_exit(tcc_sata_exit);
+
Index: linux-2.6.29/drivers/ata/sata_snps.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/ata/sata_snps.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,157 @@
+
+#ifndef __SATA_SNPS_H__
+#define __SATA_SNPS_H__
+
+/*
+ * HSATA Registers
+ */
+#define TCC_SATA_BASE_ADDR 0xF0560000
+#define HSATA_MEM_BASE    TCC_SATA_BASE_ADDR
+
+
+#define HSATA_SCR0_REG       0x0024
+#define HSATA_SCR0_SPD_GET(v) (((v) & 0x000000f0) >> 4)
+#define HSATA_SCR1_REG       0x0028
+#define HSATA_SCR2_REG       0x002C
+#define HSATA_SCR3_REG       0x0030
+#define HSATA_SCR4_REG       0x0034
+
+#define HSATA_SSTATUS_REG        HSATA_SCR0_REG
+#define HSATA_SERROR_REG         HSATA_SCR1_REG
+#define HSATA_SERROR_ERR_BITS    0x0000ffff
+#define HSATA_SCONTROL_REG       HSATA_SCR2_REG
+#define HSATA_SACTIVE_REG        HSATA_SCR3_REG
+#define HSATA_SNOTIFICATION_REG  HSATA_SCR4_REG
+
+#define HSATA_FPTAGR_REG         0x0064
+#define HSATA_FPBOR_REG          0x0068
+#define HSATA_FPTCR_REG          0x006C
+#define HSATA_DMACR_REG          0x0070
+
+#if 1
+#define HSATA_DMACR_TXMODE_BIT  0x04
+#define HSATA_DMACR_TX_EN    0x01 | HSATA_DMACR_TXMODE_BIT
+#define HSATA_DMACR_RX_EN    0x02 | HSATA_DMACR_TXMODE_BIT
+#define HSATA_DMACR_TXRX_EN  0x03 | HSATA_DMACR_TXMODE_BIT
+#define HSATA_DMACR_TXRX_CLEAR HSATA_DMACR_TXMODE_BIT
+#else
+#define HSATA_DMACR_TXMODE_BIT  0x00
+#define HSATA_DMACR_TX_EN    0x01 | HSATA_DMACR_TXMODE_BIT
+#define HSATA_DMACR_RX_EN    0x02 | HSATA_DMACR_TXMODE_BIT
+#define HSATA_DMACR_TXRX_EN  0x03 | HSATA_DMACR_TXMODE_BIT
+#define HSATA_DMACR_TXRX_CLEAR HSATA_DMACR_TXMODE_BIT
+#endif
+
+
+
+#define HSATA_DBTSR_REG          0x0074
+#define HSATA_INTPR_REG          0x0078
+//#define HSATA_INTPR_ERR_BIT      0x00000008
+//#define HSATA_INTPR_FP_BIT       0x00000002  /* new DMA setup FIS arrived */
+#define HSATA_INTMR_REG          0x007C
+
+
+
+#define HSATA_INTMR_DMAT_BIT     Hw0
+#define HSATA_INTMR_NEWFP_BIT    Hw1
+#define HSATA_INTMR_PMABORT      Hw2
+#define HSATA_INTMR_ERRM_BIT     Hw3
+#define HSATA_INTMR_NEWBIST_BIT  Hw4
+#define HSATA_INTMR_PRIMERR_BIT  Hw5
+#define HSATA_INTMR_CMDABORT_BIT Hw6
+#define HSATA_INTMR_CMDGOOD_BIT   Hw7
+
+#define TCC_INTR_CHECK_BIT (HSATA_INTMR_DMAT_BIT \
+                            | HSATA_INTMR_NEWFP_BIT \
+                            | HSATA_INTMR_PMABORT \
+                            | HSATA_INTMR_ERRM_BIT \
+                            | HSATA_INTMR_NEWBIST_BIT \
+                            | HSATA_INTMR_PRIMERR_BIT \
+                            | HSATA_INTMR_CMDABORT_BIT \
+                            | HSATA_INTMR_CMDGOOD_BIT)
+
+
+
+#define HSATA_ERRMR_REG          0x0080
+#define HSATA_LLCR_REG           0x0084
+#define HSATA_PHYCR_REG          0x0088
+#define HSATA_PHYSR_REG          0x008C
+#define HSATA_RXBISTPD_REG       0x0090
+#define HSATA_RXBISTD1_REG       0x0094
+#define HSATA_RXBISTD2_REG       0x0098
+#define HSATA_TXBISTPD_REG       0x009C
+#define HSATA_TXBISTD1_REG       0x00A0
+#define HSATA_TXBISTD2_REG       0x00A4
+#define HSATA_BISTCR_REG         0x00A8
+#define HSATA_BISTFCTR_REG       0x00AC
+#define HSATA_BISTSR_REG         0x00B0
+#define HSATA_BISTDECR_REG       0x00B4
+
+#define HSATA_TESTR_REG          0x00F4
+#define HSATA_VERSONR_REG        0x00F8
+#define HSATA_IDR_REG            0x00FC
+
+#define HSATA_CMD_QWRITE  0x61  /* these don't seem to be defined in ata.h/libata.h */
+#define HSATA_CMD_QREAD   0x60
+
+
+#define TCC_DMADR_REG          0x0400
+#define TCC_DMADR_REG_ADDR     (HSATA_MEM_BASE + TCC_DMADR_REG)
+
+
+#define HSATA_ENABLE_INTERRUPTS(tcc_dev) \
+   { \
+      volatile u32 val32; \
+      /* enable all err interrupts */ \
+      /* COMRESET clears reg INTMR so .. see where this func is called */ \
+      writel( 0xffffffff, tcc_dev->membase + HSATA_ERRMR_REG ); \
+      val32 = readl( tcc_dev->membase + HSATA_INTMR_REG ); \
+      writel( val32 | TCC_INTR_CHECK_BIT, \
+              tcc_dev->membase + HSATA_INTMR_REG ); \
+      val32 = readl( tcc_dev->membase + HSATA_INTMR_REG ); \
+      jprintk("INTMR=0x%x", val32);\
+   }
+
+
+#define TCC_QCMD_MAX    128
+#define TCC_SG_LIST_MAX (TCC_QCMD_MAX * 8)
+
+#define _TCC_DMA_TX_  0x01
+#define _TCC_DMA_RX_  0x02
+#define _TCC_DMA_END_ 0x04
+#define _TCC_DMA_START_ 0x08
+
+
+#define CDR7_ERR 0
+
+struct tcc_sg_list {
+    unsigned int dma_addr;
+    unsigned int length;
+    int flags;
+};
+
+struct tcc_dma_Q {
+    struct tcc_sg_list sg_list[TCC_SG_LIST_MAX];
+    int top, bottom, pre;
+};
+
+struct tcc_sata_dev {
+    void __iomem *membase;
+    GDMANCTRL *dma_tx_reg, *dma_rx_reg;
+    int dma_tx_irq, dma_rx_irq;
+
+    struct tcc_dma_Q dma_q;
+    int is_rx_complete, is_tx_complete;
+    int is_last_rx, is_last_tx;
+    wait_queue_head_t job_wait_q;
+    wait_queue_head_t tx_dma_wait_q;
+    wait_queue_head_t rx_dma_wait_q;
+    int is_continue;
+    struct task_struct *fetch_task;
+};
+
+
+
+
+#endif /*__SATA_SNPS_H__*/
+
Index: linux-2.6.29/drivers/base/power/Makefile
===================================================================
--- linux-2.6.29.orig/drivers/base/power/Makefile	2010-04-07 12:29:33.000000000 -0400
+++ linux-2.6.29/drivers/base/power/Makefile	2010-04-07 12:29:36.000000000 -0400
@@ -1,6 +1,7 @@
 obj-$(CONFIG_PM)	+= sysfs.o
 obj-$(CONFIG_PM_SLEEP)	+= main.o
 obj-$(CONFIG_PM_TRACE_RTC)	+= trace.o
+obj-$(CONFIG_DPM)	+= power-dpm.o
 
 ccflags-$(CONFIG_DEBUG_DRIVER) := -DDEBUG
 ccflags-$(CONFIG_PM_VERBOSE)   += -DDEBUG
Index: linux-2.6.29/drivers/base/power/power-dpm.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/base/power/power-dpm.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,464 @@
+/*
+ * power-dpm.c -- Dynamic Power Management LDM power hooks
+ *
+ * (c) 2003 MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express or
+ * implied.
+ */
+
+#include <linux/device.h>
+#include <linux/pm.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/notifier.h>
+#include <linux/list.h>
+
+#include "power.h"
+#include <plat/dpm.h>
+#include <linux/dpm.h>
+
+/*
+ * power hotplug events
+ */
+#if 0
+#define dbg printk
+#else /* no debug */
+#define dbg(x...) do {} while(0)
+#endif
+
+#define BUFFER_SIZE	1024	/* should be enough memory for the env */
+#define NUM_ENVP	32	/* number of env pointers */
+static unsigned long sequence_num;
+static spinlock_t sequence_lock = SPIN_LOCK_UNLOCKED;
+
+void power_event(char *eventstr)
+{
+	char *argv [3];
+	char **envp = NULL;
+	char *buffer = NULL;
+	char *scratch;
+	int i = 0;
+	int retval;
+	unsigned long seq;
+
+	if (!uevent_helper[0])
+		return;
+
+	envp = kmalloc(NUM_ENVP * sizeof (char *), GFP_KERNEL);
+	if (!envp)
+		return;
+	memset (envp, 0x00, NUM_ENVP * sizeof (char *));
+
+	buffer = kmalloc(BUFFER_SIZE, GFP_KERNEL);
+	if (!buffer)
+		goto exit;
+
+	argv [0] = uevent_helper;
+	argv [1] = "power";
+	argv [2] = 0;
+
+	/* minimal command environment */
+	envp [i++] = "HOME=/";
+	envp [i++] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
+
+	scratch = buffer;
+
+	envp [i++] = scratch;
+	scratch += sprintf(scratch, "ACTION=event") + 1;
+
+	spin_lock(&sequence_lock);
+	seq = sequence_num++;
+	spin_unlock(&sequence_lock);
+
+	envp [i++] = scratch;
+	scratch += sprintf(scratch, "SEQNUM=%ld", seq) + 1;
+	envp [i++] = scratch;
+	scratch += sprintf(scratch, "EVENT=%s", eventstr) + 1;
+
+	pr_debug ("%s: %s %s %s %s %s %s %s\n", __FUNCTION__, argv[0], argv[1],
+		  envp[0], envp[1], envp[2], envp[3], envp[4]);
+	retval = call_usermodehelper (argv[0], argv, envp, 0);
+	if (retval)
+		pr_debug ("%s - call_usermodehelper returned %d\n",
+			  __FUNCTION__, retval);
+
+exit:
+	kfree(buffer);
+	kfree(envp);
+	return;
+}
+
+void device_power_event(struct device * dev, char *eventstr)
+{
+	char *argv [3];
+	char **envp = NULL;
+	char *buffer = NULL;
+	char *scratch;
+	int i = 0;
+	int retval;
+	unsigned long seq;
+
+	if (!uevent_helper[0])
+		return;
+
+	envp = kmalloc(NUM_ENVP * sizeof (char *), GFP_KERNEL);
+	if (!envp)
+		return;
+	memset (envp, 0x00, NUM_ENVP * sizeof (char *));
+
+	buffer = kmalloc(BUFFER_SIZE, GFP_KERNEL);
+	if (!buffer)
+		goto exit;
+
+	argv [0] = uevent_helper;
+	argv [1] = "power";
+	argv [2] = 0;
+
+	/* minimal command environment */
+	envp [i++] = "HOME=/";
+	envp [i++] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
+
+	scratch = buffer;
+
+	envp [i++] = scratch;
+	scratch += sprintf(scratch, "ACTION=device-event") + 1;
+
+	spin_lock(&sequence_lock);
+	seq = sequence_num++;
+	spin_unlock(&sequence_lock);
+
+	envp [i++] = scratch;
+	scratch += sprintf(scratch, "SEQNUM=%ld", seq) + 1;
+	envp [i++] = scratch;
+	scratch += sprintf(scratch, "DEVICE=%s", dev->bus_id) + 1;
+	envp [i++] = scratch;
+	scratch += sprintf(scratch, "EVENT=%s", eventstr) + 1;
+	envp [i++] = scratch;
+	scratch += sprintf(scratch, "SUBSYSTEM=power") + 1;
+
+	pr_debug ("%s: %s %s %s %s %s %s %s %s %s\n", __FUNCTION__, argv[0], argv[1],
+		  envp[0], envp[1], envp[2], envp[3], envp[4], envp[5],
+		  envp[6]);
+	retval = call_usermodehelper (argv[0], argv, envp, 0);
+	if (retval)
+		pr_debug ("%s - call_usermodehelper returned %d\n",
+			  __FUNCTION__, retval);
+
+exit:
+	kfree(buffer);
+	kfree(envp);
+	return;
+}
+
+/*
+ * Device constraints
+ */
+
+#ifdef CONFIG_DPM
+LIST_HEAD(dpm_constraints);
+DECLARE_MUTEX(dpm_constraints_sem);
+
+void assert_constraints(struct constraints *constraints)
+{
+	if (! constraints || constraints->asserted)
+		return;
+
+	down(&dpm_constraints_sem);
+	constraints->asserted = 1;
+	list_add_tail(&constraints->entry, &dpm_constraints);
+	up(&dpm_constraints_sem);
+
+	/* DPM-PM-TODO: Check against DPM state. */
+
+}
+
+
+void deassert_constraints(struct constraints *constraints)
+{
+	if (! constraints || ! constraints->asserted)
+		return;
+
+	down(&dpm_constraints_sem);
+	constraints->asserted = 0;
+	list_del_init(&constraints->entry);
+	up(&dpm_constraints_sem);
+}
+
+
+EXPORT_SYMBOL(assert_constraints);
+EXPORT_SYMBOL(deassert_constraints);
+
+static ssize_t
+constraints_show(struct device * dev, struct device_attribute *attr,
+		 char * buf)
+{
+	int i, cnt = 0;
+
+	if (dev->constraints) {
+		for (i = 0; i < dev->constraints->count; i++) {
+			cnt += sprintf(buf + cnt,"%s: min=%d max=%d\n",
+				       dpm_param_names[dev->constraints->param[i].id],
+				       dev->constraints->param[i].min,
+				       dev->constraints->param[i].max);
+		}
+
+		cnt += sprintf(buf + cnt,"asserted=%s violations=%d\n",
+			       dev->constraints->asserted ?
+			       "yes" : "no", dev->constraints->violations);
+	} else {
+		cnt += sprintf(buf + cnt,"none\n");
+	}
+
+	return cnt;
+}
+
+static ssize_t
+constraints_store(struct device * dev, struct device_attribute *attr,
+		  const char * buf, size_t count)
+{
+	int num_args, paramid, min, max;
+	int cidx;
+	const char *cp, *paramname;
+	int paramnamelen;
+	int provisional = 0;
+	int ret = 0;
+
+	if (!dev->constraints) {
+		if (! (dev->constraints = kmalloc(sizeof(struct constraints),
+						  GFP_KERNEL)))
+			return -EINVAL;
+
+		memset(dev->constraints, 0,
+		       sizeof(struct constraints));
+		provisional = 1;
+	}
+
+	cp = buf;
+	while((cp - buf < count) && *cp && (*cp == ' '))
+		cp++;
+
+	paramname = cp;
+
+	while((cp - buf < count) && *cp && (*cp != ' '))
+		cp++;
+
+	paramnamelen = cp - paramname;
+	num_args = sscanf(cp, "%d %d", &min, &max);
+
+	if (num_args != 2) {
+		printk("DPM: Need 2 integer parameters for constraint min/max.\n");
+		ret = -EINVAL;
+		goto out;
+	}
+
+	for (paramid = 0; paramid < DPM_PP_NBR; paramid++) {
+		if (strncmp(paramname, dpm_param_names[paramid], paramnamelen) == 0)
+			break;
+	}
+
+	if (paramid >= DPM_PP_NBR) {
+		printk("DPM: Unknown power parameter name in device constraints\n");
+		ret = -EINVAL;
+		goto out;
+	}
+
+	for (cidx = 0; cidx < dev->constraints->count; cidx++)
+		/*
+		 * If the new range overlaps an existing range,
+		 * modify the existing one.
+		 */
+
+		if ((dev->constraints->param[cidx].id == paramid) &&
+		    ((max == -1) || 
+		     (max >= dev->constraints->param[cidx].min)) &&
+		    ((min == -1) ||
+		     (min <= dev->constraints->param[cidx].max)))
+			break;
+
+	if (cidx >= DPM_CONSTRAINT_PARAMS_MAX) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* Error if max is less than min */
+	if (max < min) {
+		printk("DPM: Max value of the constraint should not be less than min\n");
+		ret = -EINVAL;
+		goto out;
+	}
+
+	dev->constraints->param[cidx].id = paramid;
+	dev->constraints->param[cidx].max = max;
+	dev->constraints->param[cidx].min = min;
+
+	if (cidx == dev->constraints->count)
+		dev->constraints->count++;
+
+	/* New constraints should start off with same state as power
+	   state */
+	if (provisional && (dev->power.power_state.event == PM_EVENT_ON))
+		assert_constraints(dev->constraints);
+
+out:
+
+	if (provisional && (ret < 0)) {
+		kfree(dev->constraints);
+		dev->constraints = NULL;
+	}
+
+	return ret < 0 ? ret : count;
+}
+
+DEVICE_ATTR(constraints,S_IWUSR | S_IRUGO,
+            constraints_show,constraints_store);
+
+#else /* CONFIG_DPM */
+void assert_constraints(struct constraints *constraints)
+{
+}
+
+void deassert_constraints(struct constraints *constraints)
+{
+}
+#endif /* CONFIG_DPM */
+
+#ifdef CONFIG_DPM
+
+#if 0
+/*
+ * Driver scale callbacks
+ */
+
+static struct notifier_block *dpm_scale_notifier_list[SCALE_MAX];
+static DECLARE_MUTEX(dpm_scale_sem);
+
+/* This function may be called by the platform frequency scaler before
+   or after a frequency change, in order to let drivers adjust any
+   clocks or calculations for the new frequency. */
+
+void dpm_driver_scale(int level, struct dpm_opt *newop)
+{
+	atomic_notifier_call_chain(&dpm_scale_notifier_list[level], level, newop);
+	up(&dpm_scale_sem);
+}
+
+void dpm_register_scale(struct notifier_block *nb, int level)
+{
+	down(&dpm_scale_sem);
+	atomic_notifier_chain_register(&dpm_scale_notifier_list[level], nb);
+	up(&dpm_scale_sem);
+}
+
+void dpm_unregister_scale(struct notifier_block *nb, int level)
+{
+	down(&dpm_scale_sem);
+	atomic_notifier_chain_unregister(&dpm_scale_notifier_list[level], nb);
+	up(&dpm_scale_sem);
+}
+#endif
+
+
+int dpm_constraint_rejects = 0;
+
+//EXPORT_SYMBOL(dpm_default_check_constraint);
+int
+dpm_default_check_constraint(struct constraint_param *param,
+			     struct dpm_opt *opt)
+{
+	return (opt->pp[param->id] == -1) ||
+		((param->min == -1 || opt->pp[param->id] >= param->min) &&
+		 (param->max == -1 || opt->pp[param->id] <= param->max));
+}
+
+static int
+dpm_check_a_constraint(struct constraints *constraints, struct dpm_opt *opt)
+{
+	int i;
+	int failid = -1;
+	int ppconstraint[DPM_PP_NBR];
+
+
+	if (! constraints || !constraints->asserted)
+		return 1;
+
+	/*
+	 * ppconstraint[ppid] == 0  means power param has not been checked
+	 *                          for a constraint
+	 *                    == -1 means power param has matched a constraint
+	 *                     > 0  means constraint #n-1 mismatched
+	 *
+	 * failid == pp id of (a) failed constraint
+	 */
+
+	memset(ppconstraint, 0, sizeof(ppconstraint));
+
+	for (i = 0; i < constraints->count; i++) {
+		struct constraint_param *param = &constraints->param[i];
+
+		if (! dpm_md_check_constraint(param, opt)) {
+			if (ppconstraint[param->id] == 0) {
+				failid = param->id;
+				ppconstraint[failid] = i+1;
+			}
+		} else
+			ppconstraint[param->id] = -1;
+	}
+
+	if ((failid >= 0) && (ppconstraint[failid] > 0)) {
+#ifdef CONFIG_DPM_TRACE
+		struct constraint_param *param =
+			&constraints->param[ppconstraint[failid]-1];
+
+		dpm_trace(DPM_TRACE_CONSTRAINT_ASSERTED,
+			  param->id, param->min, param->max,
+			  opt);
+#endif
+		return 0;
+	}
+
+	return 1;
+}
+
+int dpm_check_constraints(struct dpm_opt *opt)
+{
+	struct list_head * entry;
+	int valid = 1;
+
+	list_for_each(entry,&dpm_constraints) {
+		struct constraints *constraints =
+			list_entry(entry, struct constraints, entry);
+		if (!dpm_check_a_constraint(constraints, opt)) {
+			constraints->violations++;
+			dpm_constraint_rejects++;
+			valid = 0;
+		}
+	}
+
+	return valid;
+}
+
+int dpm_show_opconstraints(struct dpm_opt *opt, char * buf)
+{
+#ifdef CONFIG_PM
+	struct list_head * entry;
+	int len = 0;
+
+	list_for_each_prev(entry,&dpm_list) {
+		struct device * dev = to_device(entry);
+
+		if (!dpm_check_a_constraint(dev->constraints, opt)) {
+			len += sprintf(buf + len, "%s/%s\n", dev->bus->name,
+				       dev->bus_id);
+		}
+	}
+
+	return len;
+#else /* CONFIG_PM */
+	return 0;
+#endif /* CONFIG_PM */
+}
+
+#endif /* CONFIG_DPM */
Index: linux-2.6.29/drivers/char/Kconfig
===================================================================
--- linux-2.6.29.orig/drivers/char/Kconfig	2010-04-07 12:29:34.000000000 -0400
+++ linux-2.6.29/drivers/char/Kconfig	2010-04-07 13:00:44.000000000 -0400
@@ -1101,5 +1101,34 @@
 
 source "drivers/s390/char/Kconfig"
 
+config TCC_CKC_IOCTL
+	tristate "Telechips clock io control driver"
+	default y
+	depends on ARCH_TCC
+	help
+	  If you say Y here, you can use clock ioctl.
+	  
+
+
+config TCC_USER_INTR
+	tristate "Telechips User-level interrupt driver"
+	default y
+	depends on ARCH_TCC
+	help
+	  If you say Y here, you can use H/W interrupt source.
+	  Telechips User-level interrupt driver.
+	  
+config TCC_BL
+   	tristate "Telechips Back-light driver"
+	default y
+	depends on ARCH_TCC
+	
+config TCC_POWER_CTL
+	tristate "Telechips power control driver"
+	default y
+	depends on ARCH_TCC
+	help
+	  If you say Y here, you can use power ctl driver.
+
 endmenu
 
Index: linux-2.6.29/drivers/char/Makefile
===================================================================
--- linux-2.6.29.orig/drivers/char/Makefile	2010-04-07 12:29:34.000000000 -0400
+++ linux-2.6.29/drivers/char/Makefile	2010-04-07 13:00:44.000000000 -0400
@@ -108,9 +108,17 @@
 
 obj-$(CONFIG_PS3_FLASH)		+= ps3flash.o
 
+obj-y                      += tcc_ll.o
+obj-$(CONFIG_TCC_POWER_CTL) += tcc_pwm.o
+
 obj-$(CONFIG_JS_RTC)		+= js-rtc.o
 js-rtc-y = rtc.o
 
+obj-$(CONFIG_TCC_CKC_IOCTL)	+= tcc_ckc_ioctl.o 
+obj-$(CONFIG_TCC_USER_INTR)	+= tcc_intr.o
+obj-$(CONFIG_TCC_BL)		+= tcc_backlight.o tca_backlight.o
+obj-y						+= tcc_proc.o
+
 # Files generated that shall be removed upon make clean
 clean-files := consolemap_deftbl.c defkeymap.c
 
Index: linux-2.6.29/drivers/char/tca_backlight.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/char/tca_backlight.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,133 @@
+
+/****************************************************************************
+ *   FileName    : tca_backlight.c
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+/*****************************************************************************
+*
+* Header Files Include
+*
+******************************************************************************/
+#include "bsp.h"
+#include "tca_backlight.h"
+
+/*****************************************************************************
+*
+* Defines
+*
+******************************************************************************/
+#define BKL_LEVEL_MAX	(50)
+/*****************************************************************************
+*
+* structures
+*
+******************************************************************************/
+
+/*****************************************************************************
+*
+* Variables
+*
+******************************************************************************/
+
+/*****************************************************************************
+*
+* Functions
+*
+******************************************************************************/
+
+/*****************************************************************************
+* Function Name : tca_bkl_init()
+******************************************************************************/
+void tca_bkl_init(unsigned int tmr_vaddr, unsigned int gpio_vaddr)
+{
+	PTIMER vTimerAddr = (PTIMER) tmr_vaddr;
+	PGPIO vGpioAddr = (PGPIO) gpio_vaddr;
+
+	vTimerAddr->TCFG3 = 0x124;
+	vTimerAddr->TREF3 = BKL_LEVEL_MAX;
+	vTimerAddr->TMREF3= BKL_LEVEL_MAX;
+	vTimerAddr->TCFG3 = 0x125;
+	
+	BITCSET(vGpioAddr->GPAFN0, Hw32-Hw28, Hw29);
+	BITSET(vGpioAddr->GPAEN,Hw7);
+	BITSET(vGpioAddr->GPADAT,Hw7);
+}
+
+/*****************************************************************************
+* Function Name : tca_bkl_powerup()
+******************************************************************************/
+void tca_bkl_powerup(unsigned int tmr_vaddr, unsigned int gpio_vaddr)
+{
+
+	//PTIMER vTimerAddr = (PTIMER) tmr_vaddr;
+	PGPIO vGpioAddr = (PGPIO) gpio_vaddr;
+
+	BITCSET(vGpioAddr->GPAFN0,Hw32-Hw28,Hw29);//set GPIO_A7 as TCO0 Mode
+	BITSET(vGpioAddr->GPAEN,Hw7);
+	BITSET(vGpioAddr->GPADAT,Hw7);
+}
+
+/*****************************************************************************
+* Function Name : tca_bkl_powerdown()
+******************************************************************************/
+void tca_bkl_powerdown(unsigned int tmr_vaddr, unsigned int gpio_vaddr)
+{
+
+	//PTIMER vTimerAddr = (PTIMER) tmr_vaddr;
+	PGPIO vGpioAddr = (PGPIO) gpio_vaddr;
+
+	//BL ON/OFF config
+	BITCLR(vGpioAddr->GPAFN0,Hw32-Hw28);//set GPIO_A7 as TCO0 Mode
+	BITSET(vGpioAddr->GPAEN,Hw7);
+	BITCLR(vGpioAddr->GPADAT,Hw7);
+}
+
+
+/*****************************************************************************
+* Function Name : tca_bkl_setpowerval()
+******************************************************************************/
+void tca_bkl_setpowerval(int inValue, unsigned int tmr_vaddr)
+{
+	PTIMER vTimerAddr = (PTIMER) tmr_vaddr;
+	
+	if(inValue <= 0)
+		inValue=1;
+
+	if(inValue > 100)
+		inValue=100;
+
+	vTimerAddr->TMREF3 = (BKL_LEVEL_MAX*inValue)/100;
+}
+
+
+/*****************************************************************************
+* Function Name : tca_bkl_getpowerval()
+******************************************************************************/
+int tca_bkl_getpowerval(unsigned int tmr_vaddr)
+{
+	int outValue=0;
+	PTIMER vTimerAddr = (PTIMER) tmr_vaddr;
+
+	outValue = (int)((100*vTimerAddr->TMREF3)/BKL_LEVEL_MAX);
+
+	return outValue;
+}
+
+/*****************************************************************************
+* Function Name : tca_bkl_getpowerval()
+******************************************************************************/
+int tca_bkl_gettmrref(unsigned int tmr_vaddr)
+{
+	int tmrref=0;
+	PTIMER vTimerAddr = (PTIMER) tmr_vaddr;
+
+	tmrref = vTimerAddr->TMREF3;
+	
+	return tmrref;
+}
Index: linux-2.6.29/drivers/char/tca_backlight.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/char/tca_backlight.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,74 @@
+/****************************************************************************
+ *   FileName    : tca_backlight.h
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+
+#ifndef __TCA_BKL_H__
+#define __TCA_BKL_H__
+
+/*****************************************************************************
+*
+* Defines
+*
+******************************************************************************/
+
+
+/*****************************************************************************
+*
+* Enum
+*
+******************************************************************************/
+
+
+/*****************************************************************************
+*
+* Type Defines
+*
+******************************************************************************/
+
+
+/*****************************************************************************
+*
+* Structures
+*
+******************************************************************************/
+
+
+/*****************************************************************************
+*
+* External Variables
+*
+******************************************************************************/
+
+
+/*****************************************************************************
+*
+* External Functions
+*
+******************************************************************************/
+#ifdef __cplusplus
+extern 
+"C" { 
+#endif
+
+void tca_bkl_init(unsigned int tmr_vaddr, unsigned int gpio_vaddr);
+void tca_bkl_powerup(unsigned int tmr_vaddr, unsigned int gpio_vaddr);
+void tca_bkl_powerdown(unsigned int tmr_vaddr, unsigned int gpio_vaddr);
+
+void tca_bkl_setpowerval(int inValue, unsigned int tmr_vaddr);
+int  tca_bkl_getpowerval(unsigned int tmr_vaddr);
+
+int  tca_bkl_gettmrref(unsigned int tmr_vaddr);
+
+#ifdef __cplusplus
+ } 
+#endif
+
+#endif	//__TCA_BKL_H__
+
Index: linux-2.6.29/drivers/char/tcc_backlight.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/char/tcc_backlight.c	2010-04-07 13:00:44.000000000 -0400
@@ -0,0 +1,362 @@
+/*
+ * linux/drivers/char/tcc_backlight.c
+ *
+ * Author:  <linux@telechips.com>
+ * Created: 10th Jun, 2008 
+ * Description: Telechips Linux BACK-LIGHT DRIVER
+ *
+ * Copyright (c) Telechips, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/moduleparam.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+
+#if CONFIG_MACH_TCC8900
+#include <bsp.h>
+#endif
+
+#include "tca_backlight.h"
+
+#define BL_DEV_NAME		"bl"
+#define BL_DEV_MAJOR	244
+
+#define IOCTL_BL_OFF		_IO(BL_DEV_MAJOR, 1)
+#define IOCTL_BL_ON			_IO(BL_DEV_MAJOR, 2)
+#define IOCTL_BL_GET_LEVEL	_IO(BL_DEV_MAJOR, 3)
+#define IOCTL_BL_SET_LEVEL	_IO(BL_DEV_MAJOR, 4)
+
+#include <mach/tcc_pca953x.h>
+#include <linux/tcc_ll.h>
+#include <linux/tcc_pwm.h>
+
+static stpwrinfo gLCDPwrInfo = {PWR_STATUS_ON};
+static stpwrinfo gBKLPwrInfo = {PWR_STATUS_ON};
+
+int pwr_ioctl_lcd(int onoff)
+{
+	/*
+	 *	LCD_ON off (gpio expand)
+	 *	LCDC on/off
+	 *	LCDC power down
+	 *	LCD Backlight on/off
+	 *	LCD data line
+	 *
+	 *	(for lcdc1-rgbif)
+	 */
+	 
+	static int flag=1;
+
+	PGPIO		pGPIO;
+	PLCDC 		pLCDC[2];
+	PDDICONFIG	pDDICfg;
+
+	pGPIO    = (PGPIO)((unsigned int)&HwGPIO_BASE);
+	pLCDC[0] = (PLCDC)((unsigned int)&HwLCDC0_BASE);
+	pLCDC[1] = (PLCDC)((unsigned int)&HwLCDC1_BASE);
+	pDDICfg  = (PDDICONFIG)((unsigned int)&HwDDI_CONFIG_BASE);
+
+
+	if (onoff)
+	{	// On
+
+		if (flag)
+			return 0;
+
+	//@ LCD_ON (gpio expand)
+	// high
+		tcc_pca953x_setup(PCA9539_U3_SLAVE_ADDR, Hw1 /*LCD_ON      */, OUTPUT, HIGH, SET_DIRECTION|SET_VALUE);
+
+	//@ RGB Interface
+	// rgb interface
+		BITSET(pGPIO->GPCFN0, 0x55555555);	//LCDC1 RGB Interface
+		BITSET(pGPIO->GPCFN1, 0x55555555);
+		BITSET(pGPIO->GPCFN2, 0x55555555);
+		BITCSET(pGPIO->GPCFN3, (Hw16-Hw0), 0x5555);
+
+	//@ LCDC
+	// lcdc pwdn disable
+		BITCLR(pDDICfg->PWDN, Hw3);	// lcdc1
+	// lcdc enable
+		BITSET(pLCDC[1]->LCTRL, Hw0);
+		
+	//@ LCD_DISP
+	// high
+		BITSET(pGPIO->GPCDAT, Hw28);
+
+	//@ Backlight
+	// tco mode
+		BITCSET(pGPIO->GPAFN0, Hw32-Hw28, 2<<28);
+
+		flag = 1;
+
+		gLCDPwrInfo.status = PWR_STATUS_ON;
+	}
+	else
+	{	// Off
+		if (!flag)
+			return 0;
+
+	//@ LCD_ON (gpio expand)
+	// low
+		tcc_pca953x_setup(PCA9539_U3_SLAVE_ADDR, Hw1 /*LCD_ON      */, OUTPUT, LOW, SET_DIRECTION|SET_VALUE);
+
+	//@LCDC0
+	#if (1)
+		// if lcdc0 enable ..
+		if (pLCDC[0]->LCTRL & Hw0)
+		{
+			if (pDDICfg->PWDN & Hw2)
+				BITCLR(pDDICfg->PWDN, Hw2);	// lcdc0 - pwdn disable
+
+		// lcdc0 disable
+			BITCLR(pLCDC[0]->LCTRL, Hw0);
+			while (pLCDC[0]->LSTATUS & Hw30) { {volatile int ttt;for(ttt=0;ttt<0x5000;ttt++);} };	// BUSY
+		}
+
+		if (!(pDDICfg->PWDN & Hw2))
+		{
+		// lcdc0 pwdn enable
+			BITSET(pDDICfg->PWDN, Hw2);	// lcdc0
+		}
+	#endif
+		
+	//@ Backlight
+	// gpio output low
+		BITCLR(pGPIO->GPADAT, Hw7);
+		BITSET(pGPIO->GPAEN, Hw7);
+		BITCLR(pGPIO->GPAFN0, Hw32-Hw28);
+
+	//@ LCDC
+	// lcdc disable
+		BITCLR(pLCDC[1]->LCTRL, Hw0);
+		while (pLCDC[1]->LSTATUS & Hw30) { {volatile int ttt;for(ttt=0;ttt<0x5000;ttt++);} };	// BUSY
+	
+	// lcdc pwdn enable
+	//	BITSET(pDDICfg->PWDN, Hw2);	// lcdc0
+		BITSET(pDDICfg->PWDN, Hw3);	// lcdc1
+
+	//@ RGB Interface
+	// gpio output low
+	    BITCLR(pGPIO->GPCDAT, Hw28-Hw0);	// low
+		BITSET(pGPIO->GPCEN , Hw28-Hw0);	// ouput
+		BITSET(pGPIO->GPCFN0, HwZERO);
+		BITSET(pGPIO->GPCFN1, HwZERO);
+		BITSET(pGPIO->GPCFN2, HwZERO);
+		BITCSET(pGPIO->GPCFN3, (Hw16-Hw0), HwZERO);
+
+	//@ LCD_DISP
+	// low
+		BITCLR(pGPIO->GPCDAT, Hw28);
+
+		flag = 0;
+
+		gLCDPwrInfo.status = PWR_STATUS_OFF;
+    }
+
+	return 0;
+}
+
+static void bl_init(void)
+{
+	PTIMER vTimerAddr = (PTIMER)((unsigned int)&HwTMR_BASE);
+	PGPIO vGpioAddr = (PGPIO)((unsigned int)&HwGPIO_BASE);
+
+	tca_bkl_init((unsigned int)vTimerAddr, (unsigned int)vGpioAddr);
+	gBKLPwrInfo.status = PWR_STATUS_ON;
+}
+
+static void bl_control(bool flag)
+{
+	PTIMER vTimerAddr = (PTIMER)((unsigned int)&HwTMR_BASE);
+	PGPIO vGpioAddr = (PGPIO)((unsigned int)&HwGPIO_BASE);
+
+	if (flag) {
+		tca_bkl_powerup((unsigned int)vTimerAddr,(unsigned int)vGpioAddr);
+		gBKLPwrInfo.status = PWR_STATUS_ON;
+	} else {
+		tca_bkl_powerdown((unsigned int)vTimerAddr,(unsigned int)vGpioAddr);
+		gBKLPwrInfo.status = PWR_STATUS_OFF;
+	}
+}
+
+static int tcc_bl_ioctl(struct inode *inode, struct file *filp, 
+							unsigned int cmd, unsigned long arg)
+{
+	unsigned long bl_val;
+
+	PTIMER vTimerAddr = (PTIMER)((unsigned int)&HwTMR_BASE);
+	//PGPIO vGpioAddr = (PGPIO)((unsigned int)&HwGPIO_BASE);
+
+
+	switch (cmd) {
+		case IOCTL_BL_OFF:
+			bl_control(false);
+			break;
+		case IOCTL_BL_ON:
+			bl_control(true);
+			break;
+		case IOCTL_BL_GET_LEVEL:
+			bl_val = tca_bkl_getpowerval((unsigned int)vTimerAddr);
+			copy_to_user((void *)arg, (const void *)&bl_val, sizeof(unsigned long));
+			break;
+		case IOCTL_BL_SET_LEVEL:
+			copy_from_user((void *)&bl_val, (const void *)arg, sizeof(unsigned long));
+			if (bl_val < 0) 
+				bl_val = 1;
+
+			tca_bkl_setpowerval(bl_val, (unsigned int)vTimerAddr);
+			break;
+		default:
+			printk("bl: unrecognized ioctl (0x%x)\n", cmd); 
+			return -EINVAL;
+			break;
+	}
+
+	return 0;
+}
+
+static int tcc_bl_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static int tcc_bl_open(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+struct file_operations tcc_bl_fops =
+{
+	.owner		= THIS_MODULE,
+	.open		= tcc_bl_open,
+	.release	= tcc_bl_release,
+	.ioctl		= tcc_bl_ioctl,
+};
+
+
+//static char *g_lcd_private = "hello world";
+static int lcd_pwr_ctl(void *h_private, int cmd, void *p_out)
+{
+	int ret = 0;
+//	if (h_private) {
+//		printk("private handle [%s] \n", (char *)h_private);
+//	}
+
+    switch (cmd) {
+    case PWR_CMD_OFF:
+		pwr_ioctl_lcd(0);
+		if (p_out)
+		{
+			memcpy(p_out, &gLCDPwrInfo, sizeof(stpwrinfo));
+		}
+		break;
+    case PWR_CMD_ON:
+		pwr_ioctl_lcd(1);
+		if (p_out)
+		{
+			memcpy(p_out, &gLCDPwrInfo, sizeof(stpwrinfo));
+		}
+		break;
+    case PWR_CMD_GETSTATUS:
+		if (p_out)
+		{
+			memcpy(p_out, &gLCDPwrInfo, sizeof(stpwrinfo));
+		}
+		else
+		{
+			ret = -EINVAL;
+		}
+		break;
+    default:
+		ret = -EINVAL;
+        break;
+    }
+    return ret;
+}
+
+static int bkl_pwr_ctl(void *h_private, int cmd, void *p_out)
+{
+	int ret = 0;
+	
+    switch (cmd) {
+    case PWR_CMD_OFF:
+		bl_control(0);
+		if (p_out)
+		{
+			memcpy(p_out, &gBKLPwrInfo, sizeof(stpwrinfo));
+		}
+		break;
+    case PWR_CMD_ON:
+		bl_control(1);
+		if (p_out)
+		{
+			memcpy(p_out, &gBKLPwrInfo, sizeof(stpwrinfo));
+		}
+		break;
+    case PWR_CMD_GETSTATUS:
+		if (p_out)
+		{
+			memcpy(p_out, &gBKLPwrInfo, sizeof(stpwrinfo));
+		}
+		else
+		{
+			ret = -EINVAL;
+		}
+		break;
+    default:
+        ret = -EINVAL;
+        break;
+    }
+    return ret;
+}
+
+static int __init tcc_bl_init(void)
+{
+	int res;
+
+	res = register_chrdev(BL_DEV_MAJOR, BL_DEV_NAME, &tcc_bl_fops);
+	if (res < 0)
+		return res;
+
+	insert_pwm_node(DEVICE_LCD, lcd_pwr_ctl, NULL);
+	insert_pwm_node(DEVICE_BACKLIGHT, bkl_pwr_ctl, NULL);
+
+	bl_init();
+
+	printk("bl: init\n");
+	return 0;
+}
+
+static void __exit tcc_bl_exit(void)
+{
+	remove_pwm_node(DEVICE_LCD);
+	remove_pwm_node(DEVICE_BACKLIGHT);
+	unregister_chrdev(BL_DEV_MAJOR, BL_DEV_NAME);
+	printk("bl: exit\n");
+}
+
+module_init(tcc_bl_init);
+module_exit(tcc_bl_exit);
+
+MODULE_AUTHOR("Telechips Inc. SYS4-3 linux@telechips.com");
+MODULE_DESCRIPTION("TCCxxx back-light driver");
+MODULE_LICENSE("GPL");
+
Index: linux-2.6.29/drivers/char/tcc_ckc_ioctl.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/char/tcc_ckc_ioctl.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,295 @@
+/*
+ * File:        drivers/char/tcc_ioctl.c
+ *
+ * Created:     June 10, 2008
+ * Copyright (C) 2008-2009 Telechips <linux@telechips.com>
+ * Description: User-level Clock Control IOCTL driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see the file COPYING, or write
+ * to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/ioctl.h>
+#include <mach/hardware.h>
+#include <asm/tlbflush.h>
+#include <asm/cacheflush.h>
+#include <linux/spinlock.h>
+#include <linux/sched.h>
+#include <linux/tick.h>
+#include <linux/time.h>
+
+#include <linux/init.h>
+#include <mach/tcc_ckc_ctrl.h>
+
+#define DEV_NAME "tcc-ioctl-ckc"
+#define BUF_LEN 80
+
+#if 0
+//#define dbg(x...) printk(KERN_DEBUG "tcc uart: ");
+#define dbg printk
+#else /* no debug */
+#define dbg(x...) do {} while(0)
+#endif
+
+static int tcc_open(struct inode *inode, struct file *file)
+{
+    return 0;
+}
+
+static int tcc_release(struct inode *inode, struct file *file)
+{
+    return 0;
+}
+
+int tcc_ioctl(struct inode *inode, struct file *file,
+                 unsigned int cmd, unsigned long arg)
+{
+    struct ckc_ioctl st;
+
+    memset(&st, 0, sizeof(struct ckc_ioctl));
+
+    switch(cmd)
+    {
+    case IOCTL_CKC_SET_PERI: // Set Peri Clock
+        dbg("%s: IOCTL_CKC_SET_PERI\n", __func__);
+        if(copy_from_user(&st, (void *)arg, sizeof(struct ckc_ioctl)))
+           return -EFAULT;
+
+        ckc_set_peri(st); 
+        break;
+
+    case IOCTL_CKC_GET_PERI:
+        dbg("%s: IOCTL_CKC_GET_PERI\n", __func__);
+        if(copy_from_user(&st, (void *)arg, sizeof(struct ckc_ioctl)))
+           return -EFAULT;
+        st.out_ckc.pckcfreq = ckc_get_peri(st);
+        if(copy_to_user((void *)arg, &st, sizeof(struct ckc_ioctl)))
+            return -EFAULT;
+        break;
+
+    case IOCTL_CKC_SET_PERIBUS:
+        dbg("%s: IOCTL_CKC_SET_PERIBUS\n", __func__);
+        if(copy_from_user(&st, (void *)arg, sizeof(struct ckc_ioctl)))
+           return -EFAULT;
+        st.out_ckc.retVal = ckc_set_peribus(st); // Enable or eisable
+        break;
+
+    case IOCTL_CKC_GET_PERIBUS:// Get io Bus State
+        dbg("%s: IOCTL_CKC_GET_PERIBUS\n", __func__);
+        if(copy_from_user(&st, (void *)arg, sizeof(struct ckc_ioctl)))
+           return -EFAULT;
+        st.out_ckc.retVal = ckc_get_peribus(st);
+        if(copy_to_user((void *)arg, &st, sizeof(struct ckc_ioctl)))
+            return -EFAULT;
+        break;
+
+    case IOCTL_CKC_SET_PERISWRESET:
+        dbg("%s: IOCTL_CKC_SET_PERISWRESET\n", __func__);
+        if(copy_from_user((void *)arg, &st, sizeof(struct ckc_ioctl)))
+            return -EFAULT;
+        ckc_set_periswreset(st);
+        break;
+
+    case IOCTL_CKC_SET_FBUSSWRESET:
+        dbg("%s: IOCTL_CKC_SET_FBUSSWRESET\n", __func__);
+        if(copy_from_user((void *)arg, &st, sizeof(struct ckc_ioctl)))
+            return -EFAULT;
+        ckc_set_fbusswreset(st);
+        break;
+
+    case IOCTL_CKC_SET_CPU:
+        dbg("%s: IOCTL_CKC_SET_CPU\n", __func__);
+        if(copy_from_user(&st, (void *)arg, sizeof(struct ckc_ioctl)))
+           return -EFAULT;
+        ckc_set_cpu(st);
+        break;
+
+    case IOCTL_CKC_SET_SMUI2C:
+        dbg("%s: IOCTL_CKC_SET_SMUI2C\n", __func__);
+        if(copy_from_user(&st, (void *)arg, sizeof(struct ckc_ioctl)))
+           return -EFAULT;
+        ckc_set_smui2c(st);
+        break;
+
+    case IOCTL_CKC_GET_CPU:
+        dbg("%s: IOCTL_CKC_GET_CPU\n", __func__);
+        if(copy_from_user(&st, (void *)arg, sizeof(struct ckc_ioctl)))
+           return -EFAULT;
+        st.out_ckc.currentcpufreq = ckc_get_cpu(st);
+        if(copy_to_user((void *)arg, &st, sizeof(struct ckc_ioctl)))
+            return -EFAULT;
+        break;
+        
+    case IOCTL_CKC_GET_BUS:
+        dbg("%s: IOCTL_CKC_GET_BUS\n", __func__);
+        if(copy_from_user(&st, (void *)arg, sizeof(struct ckc_ioctl)))
+           return -EFAULT;
+        st.out_ckc.currentbusfreq = ckc_get_bus(st);
+        if(copy_to_user((void *)arg, &st, sizeof(struct ckc_ioctl)))
+            return -EFAULT;
+        break;
+
+    case IOCTL_CKC_GET_VALIDPLLINFO:
+        dbg("%s: IOCTL_CKC_GET_VALIDPLLINFO\n", __func__);
+        if(copy_from_user(&st, (void *)arg, sizeof(struct ckc_ioctl)))
+           return -EFAULT;
+        ckc_get_validpllinfo(st);
+        if(copy_to_user((void *)arg, &st, sizeof(struct ckc_ioctl)))
+            return -EFAULT;
+        break;
+
+    case IOCTL_CKC_SET_FBUS:
+        dbg("%s: IOCTL_CKC_SET_FBUS\n", __func__);
+        if(copy_from_user(&st, (void *)arg, sizeof(struct ckc_ioctl)))
+           return -EFAULT;
+        ckc_set_fbus(st);
+        break;
+
+    case IOCTL_CKC_GET_FBUS:
+        dbg("%s: IOCTL_CKC_GET_FBUS\n", __func__);
+        if(copy_from_user(&st, (void *)arg, sizeof(struct ckc_ioctl)))
+           return -EFAULT;
+        st.out_ckc.fbusfreq = ckc_get_fbus(st);
+        if(copy_to_user((void *)arg, &st, sizeof(struct ckc_ioctl)))
+            return -EFAULT;
+        break;
+
+    case IOCTL_CKC_SET_PMUPOWER:
+        dbg("%s: IOCTL_CKC_SET_FBUS\n", __func__);
+        if(copy_from_user(&st, (void *)arg, sizeof(struct ckc_ioctl)))
+            return -EFAULT;
+        ckc_set_pmupower(st);
+        break;
+
+    case IOCTL_CKC_GET_PMUPOWER:
+        dbg("%s: IOCTL_CKC_GET_PMUPOWER\n", __func__);
+        if(copy_from_user(&st, (void *)arg, sizeof(struct ckc_ioctl)))
+           return -EFAULT;
+        ckc_get_pmupower(st);
+        if(copy_to_user((void *)arg, &st, sizeof(struct ckc_ioctl)))
+            return -EFAULT;
+        break;
+
+    case IOCTL_CKC_GET_CLOCKINFO:
+        dbg("%s: IOCTL_CKC_GET_CLOCKINFO\n", __func__);
+        if(copy_from_user(&st, (void *)arg, sizeof(struct ckc_ioctl)))
+           return -EFAULT;
+        ckc_get_clockinfo(st);
+        if(copy_to_user((void *)arg, &st, sizeof(struct ckc_ioctl)))
+            return -EFAULT;
+        break;
+
+    case IOCTL_CKC_SET_CHANGEFBUS:
+	{
+        dbg("%s: IOCTL_CKC_SET_CHANGEFBUS\n", __func__);
+        if(copy_from_user(&st, (void *)arg, sizeof(struct ckc_ioctl)))
+           return -EFAULT;
+
+        ckc_set_changefbus(st);
+               break;
+    }
+
+    case IOCTL_CKC_SET_CHANGEMEM:   
+	{
+        dbg("%s: IOCTL_CKC_SET_CHANGEMEM\n", __func__);
+        if(copy_from_user(&st, (void *)arg, sizeof(struct ckc_ioctl)))
+           return -EFAULT;
+
+        ckc_set_changemem(st);
+        break; 
+	}
+
+    case IOCTL_CKC_SET_CHANGECPU:
+        dbg("%s: IOCTL_CKC_SET_CHANGECPU\n", __func__);
+        if(copy_from_user(&st, (void *)arg, sizeof(struct ckc_ioctl)))
+           return -EFAULT;
+        ckc_set_changecpu(st);
+        break; 
+			
+    case IOCTL_CKC_SET_DDIPWDN:
+        dbg("%s: IOCTL_CKC_SET_DDIPWDN\n", __func__);
+        if(copy_from_user(&st, (void *)arg, sizeof(struct ckc_ioctl)))
+           return -EFAULT;
+
+        ckc_set_ddipwdn(st);
+        break;
+
+    case IOCTL_CKC_GET_DDIPWDN:
+        dbg("%s: IOCTL_CKC_GET_DDIPWDN\n", __func__);
+        if(copy_from_user(&st, (void *)arg, sizeof(struct ckc_ioctl)))
+           return -EFAULT;
+
+        ckc_get_ddipwdn(st);
+
+        if(copy_to_user((void *)arg, &st, sizeof(struct ckc_ioctl)))
+            return -EFAULT;
+        break;
+
+    case IOCTL_CKC_SET_ETCBLOCK:
+        dbg("%s: IOCTL_CKC_SET_ETCBLOCK\n", __func__);
+        if(copy_from_user(&st, (void *)arg, sizeof(struct ckc_ioctl)))
+           return -EFAULT;
+
+        ckc_set_etcblock(st);
+        break;
+
+
+    default :
+        break;
+    }
+
+    return 0;
+}
+
+struct file_operations tcc_fops = {
+    .owner      = THIS_MODULE,
+    .ioctl      = tcc_ioctl,
+    .open       = tcc_open,
+    .release    = tcc_release,
+};
+
+
+int init_module(void)
+{
+    int ret;
+
+    ret = register_chrdev(MAJOR_NUM, DEV_NAME, &tcc_fops);
+
+    if(ret < 0){
+        dbg(KERN_ALERT " %s failed with %d\n", "fail to register the character device", ret);
+        return ret;
+    }
+
+    return 0;
+}
+
+void cleanup_module(void)
+{
+    unregister_chrdev(MAJOR_NUM, DEV_NAME);
+}
+
+
+module_init(init_module);
+module_exit(cleanup_module);
+
+
+MODULE_AUTHOR("Telechips Inc. <linux@telechips.com>");
+MODULE_DESCRIPTION("TCC Clock IOCTL driver");
+MODULE_LICENSE("GPL");
+
Index: linux-2.6.29/drivers/char/tcc_intr.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/char/tcc_intr.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,578 @@
+/*
+ * linux/drivers/char/tcc_intr.c 
+ *
+ * Author:  <linux@telechips.com>
+ * Created: 31th March, 2009 
+ * Description: User-level interrupt Driver 
+ *
+ * Copyright (c) Telechips, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/time.h>
+#include <linux/timer.h>
+#include <linux/poll.h>
+
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+#include <bsp.h>
+#include <mach/irqs.h>
+#include <linux/tcc_intr.h>
+
+//#define DBG_GPIO
+#ifdef DBG_GPIO
+#define TEST_GPIO(x) test_gpio(x)	
+#else
+#define TEST_GPIO(x)
+#endif
+
+#define TCC_INTR_VERSION	"2.1"
+#define TCC_INTR_DEV_NAME	"tcc_intr"
+
+#define VIPC_TIG0	*(volatile long *)0xF0401030
+
+typedef struct _tcc_intr_data_t {
+	wait_queue_head_t wq;
+	spinlock_t lock;
+	unsigned int count;
+	unsigned int irq;
+	unsigned int irq_bit;
+	volatile PPIC irq_regs;
+} tcc_intr_data_t;
+
+
+/*
+ *	TEST GPIO FUNCTION
+ */
+#ifdef DBG_GPIO
+static int status;
+static void test_gpio(int flag)
+{
+	if (flag == 0) {
+		// gpio low
+		BITCLR(*(volatile unsigned int *)0xF0102100, Hw22);			// low
+	} else if (flag == 1) {
+		// gpio high
+		BITSET(*(volatile unsigned int *)0xF0102100, Hw22);			// high
+	} else if (flag == 2) {
+		// toggle
+		if (status)	{
+			BITCLR(*(volatile unsigned int *)0xF0102100, Hw22);			// low
+			status = 0;
+		} else { 
+			BITSET(*(volatile unsigned int *)0xF0102100, Hw22);			// high
+			status = 1;
+		}
+	} else if (flag == 3) {
+		// gpio init 
+		// GPIO_E22 - CAM_HS - JH2[5]
+		BITCLR(*(volatile unsigned int *)0xF010212C, Hw28-Hw24);	// GPIO_E22
+		BITSET(*(volatile unsigned int *)0xF0102104, Hw22);			// output
+		BITCLR(*(volatile unsigned int *)0xF0102100, Hw22);			// low
+
+		BITCLR(*(volatile unsigned int *)0xF0102130, Hw16-Hw12);	// GPIO_E26
+		BITSET(*(volatile unsigned int *)0xF0102104, Hw26);			// output
+		BITCLR(*(volatile unsigned int *)0xF0102100, Hw26);			// low
+	} else {
+	}
+}
+#endif
+
+/*
+ *	Video Codec Interface.
+ */
+static void init_vc_interrupt(tcc_intr_data_t *tcc_intr)
+{
+#if 0
+	BITCLR(tcc_intr->irq_regs->MODE0, tcc_intr->irq_bit);	// edge-triggered
+	BITCLR(tcc_intr->irq_regs->MODEA0, tcc_intr->irq_bit);	// single-edge
+	BITSET(tcc_intr->irq_regs->POL0, tcc_intr->irq_bit);	// active-low
+#endif
+#if 0
+	BITSET(tcc_intr->irq_regs->MODE0, tcc_intr->irq_bit);	// level-triggered
+	BITSET(tcc_intr->irq_regs->POL0, tcc_intr->irq_bit);	// active-low
+#endif
+	BITCLR(tcc_intr->irq_regs->MODE0, tcc_intr->irq_bit);	// edge-triggered
+	BITCLR(tcc_intr->irq_regs->MODEA0, tcc_intr->irq_bit);	// single-edge
+	BITCLR(tcc_intr->irq_regs->POL0, tcc_intr->irq_bit);	// active-high
+}
+
+static irqreturn_t vc_handler(int irq, void *dev_id)
+{
+	tcc_intr_data_t *tcc_intr = dev_id;
+
+	spin_lock_irq(&(tcc_intr->lock));
+	tcc_intr->count++;
+	spin_unlock_irq(&(tcc_intr->lock));
+
+	wake_up_interruptible(&(tcc_intr->wq));
+
+	return IRQ_HANDLED;
+}
+
+/*
+ *	Mem to Mem Scaler Interface.
+ */
+static void init_sc_interrupt(tcc_intr_data_t *tcc_intr)
+{
+	BITCLR(tcc_intr->irq_regs->MODE0, tcc_intr->irq_bit);	// edge-triggered
+	BITCLR(tcc_intr->irq_regs->MODEA0, tcc_intr->irq_bit);	// single-edge
+	BITSET(tcc_intr->irq_regs->POL0, tcc_intr->irq_bit);	// active-low
+}
+
+static irqreturn_t sc_handler(int irq, void *dev_id)
+{
+	tcc_intr_data_t *tcc_intr = dev_id;
+
+	spin_lock_irq(&(tcc_intr->lock));
+	tcc_intr->count++;
+	spin_unlock_irq(&(tcc_intr->lock));
+
+	wake_up_interruptible(&(tcc_intr->wq));
+
+	return IRQ_HANDLED;
+}
+
+/*
+ *	BroadCasting DXB Interface.
+ */
+static void init_bc_interrupt(tcc_intr_data_t *tcc_intr)
+{
+	PGPIO pGPIO = (volatile PGPIO)tcc_p2v(HwGPIO_BASE);
+	
+	/* DXB1_IRQ - GPIO_A11 - ExINT3 */	
+	BITCLR(pGPIO->GPAFN1, Hw16-Hw12);	// gpio
+	BITCLR(pGPIO->GPAEN, Hw11);			// input mode
+	//BITCSET(pGPIO->GPAPD0, Hw23, Hw22); // pull-up driving
+	
+	BITCSET(pGPIO->EINTSEL0, Hw30-Hw24, (11<<24));
+
+	/* Int trigger setting */
+	BITCLR(tcc_intr->irq_regs->MODE0, tcc_intr->irq_bit);	// edge-triggered
+	BITCLR(tcc_intr->irq_regs->MODEA0, tcc_intr->irq_bit);	// single-edge
+	BITCLR(tcc_intr->irq_regs->POL0, tcc_intr->irq_bit);	// active-high
+}
+
+static irqreturn_t bc_handler(int irq, void *dev_id)
+{
+	tcc_intr_data_t *tcc_intr = dev_id;
+
+	spin_lock_irq(&(tcc_intr->lock));
+	tcc_intr->count++;
+	spin_unlock_irq(&(tcc_intr->lock));
+
+	wake_up_interruptible(&(tcc_intr->wq));
+
+	return IRQ_HANDLED;
+}
+
+///////////////////////////////////////////////////////////////////////////
+//
+static long io_interrupt(tcc_intr_data_t *tcc_intr, long flag)
+{
+	/* NOTE: irq_regs->XXX0, XXX1 */
+	long ret = 0;
+	if (flag == 0) {
+		BITSET(tcc_intr->irq_regs->CLR0, tcc_intr->irq_bit);			// clear intr
+		BITCLR(tcc_intr->irq_regs->INTMSK0, tcc_intr->irq_bit);			// disable intr
+	} else if (flag == 1) {
+		BITSET(tcc_intr->irq_regs->CLR0, tcc_intr->irq_bit);
+		BITSET(tcc_intr->irq_regs->INTMSK0, tcc_intr->irq_bit);			// enable intr
+	} else if (flag == 2) {
+		ret = (tcc_intr->irq_regs->INTMSK0 & tcc_intr->irq_bit)?1:0;	// get int-mask status
+	} else {
+		ret = -1;
+	}
+	return ret;
+}
+
+static unsigned int intr_poll(struct file *filp, poll_table *wait)
+{
+	tcc_intr_data_t *tcc_intr = (tcc_intr_data_t *)filp->private_data;
+
+	if (tcc_intr == NULL)
+		return -EFAULT;
+
+	if (tcc_intr->count > 0) {
+		spin_lock_irq(&(tcc_intr->lock));
+		tcc_intr->count--;
+		spin_unlock_irq(&(tcc_intr->lock));
+		return (POLLIN | POLLRDNORM);
+	}
+	
+	poll_wait(filp, &(tcc_intr->wq), wait);
+
+	if (tcc_intr->count > 0) {
+		spin_lock_irq(&(tcc_intr->lock));
+		tcc_intr->count--;
+		spin_unlock_irq(&(tcc_intr->lock));
+		return (POLLIN | POLLRDNORM);
+	} else {
+		return 0;
+	}
+}
+
+static int intr_ioctl(struct inode *inode, struct file *filp, 
+							unsigned int cmd, unsigned long arg)
+{
+	unsigned long data;
+	tcc_intr_data_t *tcc_intr = (tcc_intr_data_t *)filp->private_data;
+
+	switch (cmd) {
+		case IOCTL_INTR_SET:
+			if (copy_from_user((void *)&data, (const void *)arg, sizeof(data)))
+				return -EFAULT;
+			if (data == 0 || data == 1) io_interrupt(tcc_intr, data);
+			else return -EFAULT;
+			break;
+		case IOCTL_INTR_GET:
+			data = io_interrupt(tcc_intr, 2);
+			if (copy_to_user((void *)arg, (const void *)&data, sizeof(data)))
+				return -EFAULT;
+			break;
+		default:
+			printk("tcc_intr(%d): unrecognized ioctl (0x%x)\n", MINOR(inode->i_rdev), cmd);
+			return -EINVAL;
+			break;
+	}
+
+	return 0;
+}
+
+static int intr_test_ioctl(struct inode *inode, struct file *filp, 
+							unsigned int cmd, unsigned long arg)
+{
+	unsigned long data;
+
+	switch (cmd) {
+		case IOCTL_INTR_TEST:
+			if (copy_from_user((void *)&data, (const void *)arg, sizeof(data))) {
+				return -EFAULT;
+			} else {
+				if (data == 1) {
+					BITSET(VIPC_TIG0, (1 << INT_VCDC));
+				} else if (data == 2) {
+					BITSET(VIPC_TIG0, (1 << INT_SC0));
+				} else if (data == 3) {
+					BITSET(VIPC_TIG0, (1 << INT_EI3));
+				} else if (data == 4) {
+					BITSET(VIPC_TIG0, (1 << INT_SC1));
+				} else {
+					return -EFAULT;
+				}
+			}
+			break;
+		default:
+			printk("tcc_intr(%d): unrecognized ioctl (0x%x)\n", MINOR(inode->i_rdev), cmd);
+			return -EINVAL;
+			break;
+	}
+
+	return 0;
+}
+
+static int intr_release(struct inode *inode, struct file *filp)
+{
+	tcc_intr_data_t *tcc_intr = (tcc_intr_data_t *)filp->private_data;
+
+	free_irq(tcc_intr->irq, tcc_intr);
+
+	/* DXB1_IRQ-GPIO_A11-ExINT3 -> set GPIO output low */
+	if (tcc_intr->irq == INT_EI3) {
+		PGPIO pGPIO = (volatile PGPIO)tcc_p2v(HwGPIO_BASE);
+		BITCLR(pGPIO->GPAFN1, Hw16-Hw12);
+		BITSET(pGPIO->GPAEN, Hw11);
+		BITCLR(pGPIO->GPADAT, Hw11);
+	}
+
+	kfree(tcc_intr);
+
+	return 0;
+}
+
+///////////////////////////////////////////////////////////////////////////
+//
+static int intr_sc_open(struct inode *inode, struct file *filp)
+{
+	int ret = 0;
+	tcc_intr_data_t *sc_data = NULL;
+
+	sc_data = (tcc_intr_data_t *)kmalloc(sizeof(tcc_intr_data_t), GFP_KERNEL);
+	if (sc_data == NULL) {
+		ret = -ENOMEM;
+		goto error;
+	}
+	memset(sc_data, 0, sizeof(tcc_intr_data_t));
+
+	spin_lock_init(&(sc_data->lock));
+	init_waitqueue_head(&(sc_data->wq));
+	sc_data->irq = INT_SC0;
+	sc_data->irq_bit = (1 << INT_SC0);
+	sc_data->irq_regs = (volatile PPIC)tcc_p2v(HwPIC_BASE);
+
+	init_sc_interrupt(sc_data);
+	ret = request_irq(sc_data->irq, sc_handler, IRQF_DISABLED, TCC_INTR_DEV_M2M_SCALER, sc_data);
+	if (ret) {
+		ret = -EFAULT;
+		goto error;
+	}
+
+	filp->private_data = (void *)sc_data;
+
+	return 0;
+error:
+	if (sc_data) 
+		kfree(sc_data);
+	return ret;
+}
+
+static int intr_sc1_open(struct inode *inode, struct file *filp)
+{
+	int ret = 0;
+	tcc_intr_data_t *sc_data = NULL;
+
+	sc_data = (tcc_intr_data_t *)kmalloc(sizeof(tcc_intr_data_t), GFP_KERNEL);
+	if (sc_data == NULL) {
+		ret = -ENOMEM;
+		goto error;
+	}
+	memset(sc_data, 0, sizeof(tcc_intr_data_t));
+
+	spin_lock_init(&(sc_data->lock));
+	init_waitqueue_head(&(sc_data->wq));
+	sc_data->irq = INT_SC1;
+	sc_data->irq_bit = (1 << INT_SC1);
+	sc_data->irq_regs = (volatile PPIC)tcc_p2v(HwPIC_BASE);
+
+	init_sc_interrupt(sc_data);
+	ret = request_irq(sc_data->irq, sc_handler, IRQF_DISABLED, TCC_INTR_DEV_M2M_SCALER1, sc_data);
+	if (ret) {
+		ret = -EFAULT;
+		goto error;
+	}
+
+	filp->private_data = (void *)sc_data;
+
+	return 0;
+error:
+	if (sc_data) 
+		kfree(sc_data);
+	return ret;
+}
+
+static int intr_vc_open(struct inode *inode, struct file *filp)
+{
+	int ret = 0;
+	tcc_intr_data_t *vc_data = NULL;
+
+	vc_data = (tcc_intr_data_t *)kmalloc(sizeof(tcc_intr_data_t), GFP_KERNEL);
+	if (vc_data == NULL) {
+		ret = -ENOMEM;
+		goto error;
+	}
+	memset(vc_data, 0, sizeof(tcc_intr_data_t));
+
+	spin_lock_init(&(vc_data->lock));
+	init_waitqueue_head(&(vc_data->wq));
+	vc_data->irq = INT_VCDC;
+	vc_data->irq_bit = (1 << INT_VCDC);
+	vc_data->irq_regs = (volatile PPIC)tcc_p2v(HwPIC_BASE);
+
+	init_vc_interrupt(vc_data);
+	ret = request_irq(vc_data->irq, vc_handler, IRQF_DISABLED, TCC_INTR_DEV_VIDEO_CODEC, vc_data);
+	if (ret) {
+		ret = -EFAULT;
+		goto error;
+	}
+
+	filp->private_data = (void *)vc_data;
+	
+	return 0;
+error:
+	if (vc_data) 
+		kfree(vc_data);
+	return ret;
+}
+
+static int intr_bc_open(struct inode *inode, struct file *filp)
+{
+	int ret = 0;
+	tcc_intr_data_t *bc_data = NULL;
+
+	bc_data = (tcc_intr_data_t *)kmalloc(sizeof(tcc_intr_data_t), GFP_KERNEL);
+	if (bc_data == NULL) {
+		ret = -ENOMEM;
+		goto error;
+	}
+	memset(bc_data, 0, sizeof(tcc_intr_data_t));
+
+	spin_lock_init(&(bc_data->lock));
+	init_waitqueue_head(&(bc_data->wq));
+	bc_data->irq = INT_EI3;
+	bc_data->irq_bit = (1 << INT_EI3);
+	bc_data->irq_regs = (volatile PPIC)tcc_p2v(HwPIC_BASE);
+
+	init_bc_interrupt(bc_data);
+	ret = request_irq(bc_data->irq, bc_handler, IRQF_DISABLED, TCC_INTR_DEV_BROADCAST, bc_data);
+	if (ret) {
+		ret = -EFAULT;
+		goto error;
+	}
+
+	filp->private_data = (void *)bc_data;
+	
+	return 0;
+error:
+	if (bc_data) 
+		kfree(bc_data);
+	return ret;
+}
+
+/*------------------------------------------------------------------------------
+ * User-level interrupt Power on/off control
+ * TODO: need something?
+ */
+static stpwrinfo pwrinfo = {PWR_STATUS_ON};
+static int intr_pwr_ctl(void *h_private, int cmd, void *p_out)
+{
+	switch (cmd) {
+	case PWR_CMD_OFF:
+		//printk("PWR_CMD_OFF command ==> [%d]\n", cmd);
+		if (pwrinfo.status == PWR_STATUS_OFF) {
+			return 0;
+		}
+		pwrinfo.status = PWR_STATUS_OFF;
+		break;
+	case PWR_CMD_ON:
+		//printk("PWR_CMD_ON command ==> [%d]\n", cmd);
+		if (pwrinfo.status == PWR_STATUS_ON) {
+			return 0;
+		}
+		pwrinfo.status = PWR_STATUS_ON;
+		break;
+	case PWR_CMD_GETSTATUS:
+		//printk("PWR_CMD_GETSTATUS command ==> [%d], status:[%d]\n", cmd, pwrinfo.status);
+		memcpy(p_out, &pwrinfo, sizeof(stpwrinfo));
+		break;
+	default:
+		//printk("unknown pwr command !!! ==> [%d]\n", cmd);
+		return -EINVAL;
+		break;
+	}
+    return 0;
+}
+
+
+struct file_operations intr_vc_fops =
+{
+	.owner		= THIS_MODULE,
+	.poll		= intr_poll,
+	.ioctl		= intr_ioctl,
+	.open		= intr_vc_open,
+	.release	= intr_release,
+};
+
+struct file_operations intr_sc_fops =
+{
+	.owner		= THIS_MODULE,
+	.poll		= intr_poll,
+	.ioctl		= intr_ioctl,
+	.open		= intr_sc_open,
+	.release	= intr_release,
+};
+
+struct file_operations intr_sc1_fops =
+{
+	.owner		= THIS_MODULE,
+	.poll		= intr_poll,
+	.ioctl		= intr_ioctl,
+	.open		= intr_sc1_open,
+	.release	= intr_release,
+};
+
+struct file_operations intr_bc_fops =
+{
+	.owner		= THIS_MODULE,
+	.poll		= intr_poll,
+	.ioctl		= intr_ioctl,
+	.open		= intr_bc_open,
+	.release	= intr_release,
+};
+
+struct file_operations intr_test_fops =
+{
+	.owner		= THIS_MODULE,
+	.ioctl		= intr_test_ioctl,
+};
+
+static int tcc_intr_open(struct inode *inode, struct file *filp)
+{
+	switch (MINOR(inode->i_rdev)) {
+		case 1: filp->f_op = &intr_vc_fops; break;
+		case 2: filp->f_op = &intr_sc_fops; break;
+		case 3: filp->f_op = &intr_bc_fops; break;
+		case 4: filp->f_op = &intr_test_fops; break;
+		case 5: filp->f_op = &intr_sc1_fops; break;
+		default : return -ENXIO;
+	}
+
+	if (filp->f_op && filp->f_op->open)
+		return filp->f_op->open(inode, filp);
+
+	return 0;
+}
+
+struct file_operations tcc_intr_fops =
+{
+	.owner		= THIS_MODULE,
+	.open		= tcc_intr_open,
+};
+
+static int __init tcc_intr_init(void)
+{
+	int res;
+
+	res = register_chrdev(TCC_INTR_DEV_MAJOR, TCC_INTR_DEV_NAME, &tcc_intr_fops);
+	if (res < 0)
+		return res;
+
+	/* add power control functions */
+	insert_pwm_node(DEVICE_USERINTR, intr_pwr_ctl, NULL);
+	
+    printk("tcc_intr: init (ver %s)\n", TCC_INTR_VERSION);
+    return 0;
+}
+
+static void __exit tcc_intr_exit(void)
+{
+	unregister_chrdev(TCC_INTR_DEV_MAJOR, TCC_INTR_DEV_NAME);
+
+	/* remove power control functions */
+	remove_pwm_node(DEVICE_USERINTR);
+	
+    printk("tcc_intr: exit\n");
+}
+
+
+module_init(tcc_intr_init);
+module_exit(tcc_intr_exit);
+
+MODULE_AUTHOR("Telechips Inc. SYS4-3 linux@telechips.com");
+MODULE_DESCRIPTION("Telechips user level interrut driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.29/drivers/char/tcc_ll.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/char/tcc_ll.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,256 @@
+/*
+ * linux/drivers/char/tcc_ll.c 
+ *
+ * Author:  <linux@telechips.com>
+ * Created: 21th August, 2009 
+ * Description: Telechips linked list 
+ *
+ * Copyright (c) Telechips, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/types.h>
+
+#include <linux/tcc_ll.h>
+
+#define jprintk printk
+
+static void copy_data_node(data_node_t *dst, data_node_t *src)
+{
+    if (dst && src) {
+        dst->id = get_node_id(src);
+        dst->callback = get_node_cb(src);
+        dst->h_pri = get_node_pri(src);
+    }
+}
+
+/* data_node_t functions */
+static data_node_t *new_node(data_node_t *p_node)
+{
+    data_node_t *p = NULL;
+
+    if (p_node) {
+        p = (data_node_t *)kmalloc(sizeof(data_node_t), GFP_KERNEL);
+        if (p) {
+            memset(p, 0, sizeof(data_node_t));
+            copy_data_node(p, p_node);
+        }
+    }
+    return p;
+}
+
+static data_node_t *free_node(data_node_t *p_node)
+{
+    if (p_node) {
+        kfree(p_node);
+    }
+    return NULL;
+}
+
+/************************************/
+
+
+int init_ll(list_handle_t *h)
+{
+    if (h) {
+        memset(h, 0, sizeof(list_handle_t));
+        return 0;
+    }
+    return -1;
+}
+
+static void set_pos_node(list_handle_t *h, int pos)
+{
+    if (h) {
+        int i = 0;
+        for (h->p_pos = h->p_head; h->p_pos; h->p_pos = get_next_node(h->p_pos)) {
+            i++;
+            if (i > pos) { break; }
+        }
+    }
+}
+
+int insert_ll(list_handle_t *h, data_node_t *p_node)
+{
+    if (h) {
+        data_node_t *p = new_node(p_node);
+
+        if (p) {
+            if (!(h->p_head)) {
+                h->p_head = h->p_tail = h->p_pos = p;
+            } else {
+                set_next_node(h->p_tail, p);
+                h->p_tail = p;
+            }
+            (h->node_cnt)++;
+            return 0;
+        }
+    }
+    return -1;
+}
+
+int remove_internal_ll(list_handle_t *h, data_node_t *p_pre, data_node_t *p)
+{
+    if (h && p) {
+        if ((p == h->p_head) || (p == h->p_tail)) {
+            if (p == h->p_head) {
+                h->p_head = get_next_node(p);
+            }
+            if (p == h->p_tail) {
+                h->p_tail = p_pre;
+                if (h->p_tail) {
+                    set_next_node(h->p_tail, NULL);
+                }
+            }
+        } else {
+            set_next_node(p_pre, get_next_node(p));
+        }
+
+        if (p == h->p_pos) {
+            h->p_pos =  get_next_node(h->p_pos);
+            if (h->p_pos == NULL) {
+                h->p_pos = h->p_head;
+            }
+        }
+        p = free_node(p);
+
+        if (h->node_cnt > 0) {
+            h->node_cnt--;
+        } else {
+            printk("h->node_cnt error ...\n");
+        }
+        return 0;
+    }
+    return -1;
+}
+
+int remove_ll(list_handle_t *h, unsigned int id)
+{
+    int ret = -1;
+    if (h) {
+        data_node_t *p, *p_pre = NULL;
+        for (p = h->p_head; p; p = get_next_node(p)) {
+            if (p->id == id) {
+                ret = remove_internal_ll(h, p_pre, p);
+                break;
+            }
+            p_pre = p;
+        }
+    }
+    return ret;
+}
+
+void remove_all_ll(list_handle_t *h)
+{
+    if (h) {
+        for (h->p_tail = h->p_head; h->p_tail; h->p_tail = h->p_head) {
+            h->p_head = get_next_node(h->p_head);
+            free_node(h->p_tail);
+        }
+        h->p_head = h->p_tail = h->p_pos = NULL;
+        h->node_cnt = 0;
+    }
+}
+
+data_node_t *find_by_id(list_handle_t *h, unsigned int id)
+{
+    data_node_t *p = NULL;
+
+    if (h) {
+        set_pos_node(h, 0);
+        for (p = h->p_pos; p; p = get_next_node(p)) {
+            if (p->id == id) { return p; }
+        }
+    }
+    return NULL;
+}
+
+
+
+typedef struct power_man {
+    list_handle_t tcc_pwm_list;
+    struct mutex mutex;
+} power_man_t;
+
+static power_man_t pwr_man;
+
+int init_pwm_list(void)
+{
+    int ret = -1;
+    memset(&pwr_man, 0, sizeof(pwr_man));
+    ret = init_ll(&(pwr_man.tcc_pwm_list));
+    mutex_init(&(pwr_man.mutex));
+    return ret;
+}
+EXPORT_SYMBOL(init_pwm_list);
+
+int insert_pwm_node(unsigned int id, power_control_t func, void *h_pri)
+{
+    int ret = -1;
+    list_handle_t *h = &(pwr_man.tcc_pwm_list);
+    if (h && func) {
+        mutex_lock(&(pwr_man.mutex));
+        if (!find_by_id(h, id)) {
+            data_node_t node;
+
+            memset(&node, 0, sizeof(node));
+            node.id = id;
+            node.callback = func;
+            node.h_pri = h_pri;
+
+            ret = insert_ll(h, &node);
+        } else {
+            printk("--- err --- already exist dev-node !!! -> id[%d]\n", id);
+        }
+        mutex_unlock(&(pwr_man.mutex));
+    }
+    return ret;
+}
+EXPORT_SYMBOL(insert_pwm_node);
+
+int remove_pwm_node(unsigned int id)
+{
+    int ret = -1;
+    list_handle_t *h = &(pwr_man.tcc_pwm_list);
+    mutex_lock(&(pwr_man.mutex));
+    ret = remove_ll(h, id);
+    mutex_unlock(&(pwr_man.mutex));
+    return ret;
+}
+EXPORT_SYMBOL(remove_pwm_node);
+
+//int callback_pwm_node(stpwrioctl *p_arg)
+int callback_pwm_node(unsigned int id, unsigned int cmd, void *p_info)
+{
+    int ret = -1;
+    list_handle_t *h = &(pwr_man.tcc_pwm_list);
+    if (h) {
+        data_node_t *p_node = NULL;
+
+        mutex_lock(&(pwr_man.mutex));
+        p_node = find_by_id(h, id);
+        if (p_node) {
+            jprintk("call dev-callback -> id[%d]\n", p_node->id);
+            if (p_node->callback) {
+                ret = p_node->callback(get_node_pri(p_node), cmd, p_info);
+            } else {
+                printk("callback is NULL !!!  -> id[%d]\n", p_node->id);
+            }
+        } else {
+            printk("--- err --- cannot find dev-node !!! -> id[%d]\n", id);
+        }
+        mutex_unlock(&(pwr_man.mutex));
+    }
+    return ret;
+}
+EXPORT_SYMBOL(callback_pwm_node);
+
+
Index: linux-2.6.29/drivers/char/tcc_proc.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/char/tcc_proc.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,92 @@
+#include <linux/module.h>
+#include <linux/tty.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/proc_fs.h>
+#include <linux/sched.h>
+#include <asm/uaccess.h>
+
+#include <mach/memory.h>
+
+#define MODULE_NAME		"tcc"
+#define VCODEC_ADDR		"vcodec_addr"
+#define VCODEC_SIZE		"vcodec_size"
+#define ADDR_LEN		10
+
+char vcodec_addr_data[ADDR_LEN + 1];
+char vcodec_size_data[ADDR_LEN + 1];
+
+static struct proc_dir_entry *tcc_proc, *vcodec_addr, *vcodec_size;
+
+static int proc_read_vcodec_addr(char *page, char **start, off_t off, 
+		int count, int *eof, void *data)
+{
+	int len;
+	char *vcodec_addr_data = (char *)data;
+	len = sprintf(page, "%s", vcodec_addr_data);
+	return len;
+}
+
+static int proc_read_vcodec_size(char *page, char **start, off_t off, 
+		int count, int *eof, void *data)
+{
+	int len;
+	char *vcodec_size_data = (char *)data;
+	len = sprintf(page, "%s", vcodec_size_data);
+	return len;
+}
+
+static int init_tccproc(void)
+{
+	int rv = 0;
+
+	tcc_proc = proc_mkdir(MODULE_NAME, NULL);
+	if (tcc_proc == NULL) {
+		rv = -ENOMEM;
+		goto out;
+	}
+
+	vcodec_addr = create_proc_entry(VCODEC_ADDR, 0444, tcc_proc);
+	vcodec_size = create_proc_entry(VCODEC_SIZE, 0444, tcc_proc);
+	if (vcodec_addr == NULL || vcodec_size == NULL) {
+		rv = -ENOMEM;
+		goto error;
+	}
+
+	/* 
+	 * Set VPU start address & size
+	 */
+	sprintf(vcodec_addr_data, "0x%08x", TCC_VPU_OFFSET);
+	sprintf(vcodec_size_data, "%d", TCC_VPU_SIZE);
+
+	vcodec_addr->data = vcodec_addr_data;
+	vcodec_addr->read_proc = proc_read_vcodec_addr;
+	vcodec_addr->owner = THIS_MODULE;
+
+	vcodec_size->data = vcodec_size_data;
+	vcodec_size->read_proc = proc_read_vcodec_size;
+	vcodec_size->owner = THIS_MODULE;
+
+	printk("%s proc filesystem initialised\n", MODULE_NAME);
+
+	return 0;
+error:
+	remove_proc_entry(VCODEC_ADDR, tcc_proc);
+	remove_proc_entry(VCODEC_SIZE, tcc_proc);
+out:
+	return rv;
+}
+
+static void cleanup_tccproc(void) 
+{
+	remove_proc_entry(VCODEC_ADDR, tcc_proc);
+	remove_proc_entry(VCODEC_SIZE, tcc_proc);
+}
+
+module_init(init_tccproc);
+module_exit(cleanup_tccproc);
+
+MODULE_AUTHOR("<linux@telechips.com>");
+MODULE_DESCRIPTION("Telechips Proc Filesystem");
+MODULE_LICENSE("GPL");
+
Index: linux-2.6.29/drivers/char/tcc_pwm.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/char/tcc_pwm.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,118 @@
+/*
+ * linux/drivers/char/tcc_intr.c 
+ *
+ * Author:  <linux@telechips.com>
+ * Created: 31th March, 2009 
+ * Description: User-level interrupt Driver 
+ *
+ * Copyright (c) Telechips, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/time.h>
+#include <linux/timer.h>
+#include <linux/poll.h>
+
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <bsp.h>
+
+#include <linux/tcc_pwm.h>
+#include <linux/tcc_pwm_ioctl.h>
+#include <linux/tcc_ll.h>
+
+
+#define TCC_PWM_DEV_NAME            "tcc-pwm"
+#define TCC_PWM_VERSION             "0.1"
+
+
+static int tcc_pwm_ioctl(struct inode *inode, struct file *filp, 
+							unsigned int cmd, unsigned long arg)
+{
+    int ret = -1;
+    pwr_ioctl_param_t data;
+
+    switch (cmd) {
+    case IOCTL_PWR_CONTROL:
+        if (copy_from_user((void *)&data, (const void *)arg, sizeof(pwr_ioctl_param_t))) {
+            printk("(%s:%d) cannot copy data from user !!!\n", __func__, __LINE__);
+            return -EFAULT;
+        }
+
+        ret = callback_pwm_node(data.in.deviceid, data.in.cmd, &(data.out));
+        if (ret == 0) {
+            if (copy_to_user((void *)arg, (const void *)&data, sizeof(pwr_ioctl_param_t))) {
+                printk("(%s:%d) cannot copy data to user !!!\n", __func__, __LINE__);
+                return -EFAULT;
+            }
+        }
+
+        break;
+    default:
+        printk("(%s:%d) unknown ioctl cmd (0x%x)\n", __func__, __LINE__, cmd);
+        return -EINVAL;
+        break;
+    }
+
+    return ret;
+}
+
+static int tcc_pwm_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+
+static int tcc_pwm_open(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+struct file_operations tcc_pwm_fops =
+{
+	.owner		= THIS_MODULE,
+	.ioctl		= tcc_pwm_ioctl,
+	.open		= tcc_pwm_open,
+	.release	= tcc_pwm_release,
+};
+
+static int __init tcc_pwm_init(void)
+{
+	int res;
+
+	res = register_chrdev(TCC_PWM_DEV_MAJOR, TCC_PWM_DEV_NAME, &tcc_pwm_fops);
+	if (res < 0)
+		return res;
+
+    printk("tcc_pwm: init (ver %s)\n", TCC_PWM_VERSION);
+    return 0;
+}
+
+static void __exit tcc_pwm_exit(void)
+{
+	unregister_chrdev(TCC_PWM_DEV_MAJOR, TCC_PWM_DEV_NAME);
+    printk("tcc_pwm: exit\n");
+}
+
+
+module_init(tcc_pwm_init);
+module_exit(tcc_pwm_exit);
+
+MODULE_AUTHOR("Telechips Inc. SYS4-3 linux@telechips.com");
+MODULE_DESCRIPTION("Telechips power control driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.29/drivers/char/tcc_pwrkey.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/char/tcc_pwrkey.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,454 @@
+/*
+ * linux/drivers/char/tcc_pwrkey.c  
+ *
+ * Author:  <linux@telechips.com>
+ * Created: July 7, 2009
+ * Description: Power Key Driver for Telechips Boards.
+ *
+ * Copyright (C) 2009 Telechips 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ *
+ * ChangeLog:
+ *
+ *	July, 2009	:	Added Sleep Test functions
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/moduleparam.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+
+#include <linux/interrupt.h>
+#include <asm/arch/irqs.h>
+#include <linux/workqueue.h>
+#include <mach/io.h>
+#include <asm/tlbflush.h>
+#include <asm/cacheflush.h>
+
+#include <bsp.h>
+
+#define PM_DEV_NAME		"pwr"
+#define PM_DEV_MAJOR 	201
+
+extern int plat_tcc_pm(int mode);
+
+extern int arm_changestack(void);
+extern void arm_restorestack(unsigned int rst);
+extern void IO_ARM_CleanCACHE(unsigned int val);
+extern void IO_ARM_FlushCACHE(void);
+
+
+/*****************************************************************************
+* Function Name : tca_off_sleep()
+******************************************************************************/
+volatile static void tca_off_sleep(void)
+{
+
+        volatile unsigned int nCount = 0;
+
+        unsigned long   *lPLL0,*lPLL1, *lPLL2, *lPLL3, *BACK4, *BACK5, *BACK6, *BACK7;
+        unsigned long   *lFBUS_CORE,*lFBUS_MEM, *lFBUS_DDI,*lFBUS_GRP, *lFBUS_IOB, *lFBUS_VBUS, *lFBUS_VCODEC, *lFBUS_SMU;
+        unsigned long   *i, *j, *pPCK, *BAKPCK;
+
+        int lmem_div = 0;
+        int lmem_source = 0;
+        int tmpread = *(volatile unsigned long *)0xF0400008;
+        int count = 0;
+
+
+        tmpread &= ~0x00200000;
+        lmem_source = tmpread & 0xf;
+        tmpread &= 0xf0;
+
+        while(tmpread){
+            tmpread -= 16;
+            lmem_div++;
+        }
+
+        lmem_div += 1;
+
+
+
+        // Let CPU Speed Lower, Low Clock Operation
+        // Assign Registers to Pointers
+        lPLL0       = (unsigned long*)(SRAM_ADDR_VAR);
+        lPLL1       = (unsigned long*)(SRAM_ADDR_VAR+0x04);
+        lPLL2       = (unsigned long*)(SRAM_ADDR_VAR+0x08);
+        lPLL3       = (unsigned long*)(SRAM_ADDR_VAR+0x0C);
+        BACK4       = (unsigned long*)(SRAM_ADDR_VAR+0x10);
+        BACK5       = (unsigned long*)(SRAM_ADDR_VAR+0x14);
+        lFBUS_CORE  = (unsigned long*)(SRAM_ADDR_VAR+0x18);
+        lFBUS_MEM   = (unsigned long*)(SRAM_ADDR_VAR+0x1C);
+        lFBUS_DDI   = (unsigned long*)(SRAM_ADDR_VAR+0x20);
+        lFBUS_GRP   = (unsigned long*)(SRAM_ADDR_VAR+0x24);
+        lFBUS_IOB   = (unsigned long*)(SRAM_ADDR_VAR+0x28);
+        lFBUS_VBUS  = (unsigned long*)(SRAM_ADDR_VAR+0x30);
+        lFBUS_VCODEC = (unsigned long*)(SRAM_ADDR_VAR+0x34);
+        lFBUS_SMU   = (unsigned long*)(SRAM_ADDR_VAR+0x38);
+        i = (unsigned long*)(SRAM_ADDR_VAR+0x3C);
+        BAKPCK =    (unsigned long*)(SRAM_ADDR_VAR+0x40);
+
+        *lFBUS_CORE  = *(volatile unsigned long *)0xF0400000 ;
+        *lFBUS_DDI   = *(volatile unsigned long *)0xF0400004;
+        *lFBUS_MEM   = *(volatile unsigned long *)0xF0400008;
+        *lFBUS_GRP   = *(volatile unsigned long *)0xF040000C;
+        *lFBUS_IOB   = *(volatile unsigned long *)0xF0400010;
+        *lFBUS_VBUS  = *(volatile unsigned long *)0xF0400014;
+        *lFBUS_VCODEC  = *(volatile unsigned long *)0xF0400018;
+        *lFBUS_SMU     = *(volatile unsigned long *)0xF040001C;
+
+        *lPLL0 = *(volatile unsigned long *)0xF0400020;
+        *lPLL1 = *(volatile unsigned long *)0xF0400024;
+        *lPLL2 = *(volatile unsigned long *)0xF0400028;
+        *lPLL3 = *(volatile unsigned long *)0xF040002c;
+
+        // Save All of PCK_XXX Register
+        pPCK    =   (unsigned long*)(0xF0400080);
+
+        for( *i=0; *i<37; (*i)++ )
+        {
+            BAKPCK[*i] = *pPCK;
+            if(((BAKPCK[*i] & 0x1f000000) != 0x14000000) ){
+                    *pPCK = (BAKPCK[*i] & ~0x10000000);
+            }
+            pPCK ++;
+        }
+
+        *BACK4 = *(volatile unsigned long *)0xF0404004;
+        *BACK5 = *(volatile unsigned long *)0xF0404000;
+
+
+    //Enter Self-Refresh Mode
+        *(volatile unsigned long *)0xF0302004 = 0x00000003; // PL341_PAUSE
+        while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+        *(volatile unsigned long *)0xF0302004 = 0x00000001; // PL341_SLEEP
+        while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=3); // Wait PL34X_STATUS_LOWPOWER
+
+        // To prevent input leakage
+        *(volatile unsigned long *)0xF0304400 |= 0x00000004;
+    // DLL OFF
+        *(volatile unsigned long *)0xF0304404 &=  ~(0x00000003);     // DLL-0FF,DLL-Stop running
+        *(volatile unsigned long *)0xF0304428 &= ~(0x00000003); // Calibration Start,Update Calibration
+        *(volatile unsigned long *)0xF030302c &=  ~(0x00004000);  //SDRAM IO Control Register Gatein Signal Power Down
+
+        nCount = ((*(volatile unsigned long *)0xF030200C) & ~(0x00004000));
+        *(volatile unsigned long *)0xF030200C = nCount| (1<<14);        // Stop-MCLK Enter Self-refresh mode
+
+
+        nCount = 800;
+        for ( ; nCount > 0 ; nCount --);        // Wait
+        nCount = 800;
+        for ( ; nCount > 0 ; nCount --);        // Wait
+
+    *(volatile unsigned long *)0xF0400000 = 0x002ffff4; // CKC-CLKCTRL0 - set cpu clk to XIN
+    *(volatile unsigned long *)0xF0400004 = 0x00200014; // CKC-CLKCTRL1 - set display clk to XIN
+    *(volatile unsigned long *)0xF0400008 = 0x00200014; // CKC-CLKCTRL2 - set memory clk to XIN
+
+
+    *(volatile unsigned long *)0xF040000c = 0x00200014; // CKC-CLKCTRL3 - set graphic clk to XIN
+    *(volatile unsigned long *)0xF0400010 = 0x00200014; // CKC-CLKCTRL4 - set io clk to XIN
+
+    *(volatile unsigned long *)0xF0400014 = 0x00200014; // CKC-CLKCTRL5 - set video bus clk to XIN
+    *(volatile unsigned long *)0xF0400018 = 0x00200014; // CKC-CLKCTRL6 - set video core clk to XIN
+    *(volatile unsigned long *)0xF040001c = 0x00200014; // CKC-CLKCTRL7 - set SMU clk to XIN
+
+
+    *(volatile unsigned long *)0xF0400020 &= ~0x80000000; // CKC-PLL0CFG - PLL disable
+    *(volatile unsigned long *)0xF0400024 &= ~0x80000000; // CKC-PLL1CFG - PLL disable
+    *(volatile unsigned long *)0xF0400028 &= ~0x80000000; // CKC-PLL2CFG - PLL disable
+    *(volatile unsigned long *)0xF040002c &= ~0x80000000; // CKC-PLL3CFG - PLL disable
+
+
+
+
+
+    //go power down mode......
+
+
+    *(volatile unsigned long *)0xF0102024 &= ~(0x0000f000); //
+    *(volatile unsigned long *)0xF0102004 &= ~(0x00000008); //
+
+
+    *(volatile unsigned long *)0xF0404008 = 0x00008000; // PMU-WKUPPOL  - SRCS[15](GPIO A3) active low
+    *(volatile unsigned long *)0xF0404004 = 0x00008000; // PMU-WKUPEN  - SRCS[15](GPIO A3) enable
+    *(volatile unsigned long *)0xF0404000 |= 0x00000004; // PMU-CONTROL - Power Off
+
+
+
+
+    //wakeup start
+
+        nCount = 10;
+        for ( ; nCount > 0 ; nCount --);        // Wait
+
+        *(volatile unsigned long *)0xF0400020 = *lPLL0;
+        *(volatile unsigned long *)0xF0400024 = *lPLL1;
+        *(volatile unsigned long *)0xF0400028 = *lPLL2;
+        *(volatile unsigned long *)0xF040002c = *lPLL3;
+
+        nCount = 10;
+        for ( ; nCount > 0 ; nCount --);        // Wait
+
+        *(volatile unsigned long *)0xF0400000 = *lFBUS_CORE ;
+        *(volatile unsigned long *)0xF0400008 = *lFBUS_MEM;
+        /*
+        for (nCount=0;nCount<10;nCount++)
+            *(volatile unsigned long *)0xF0302008 = 0x00040000; // Direct COmmnad Register
+        */
+
+        pPCK = (unsigned long*)(0xF0400080);
+
+        for( (*i)=0; (*i)<37; (*i)++)
+            *pPCK++ = BAKPCK[*i];
+
+        nCount = 0x100;
+        for ( ; nCount > 0 ; nCount --);        // Wait
+
+        *(volatile unsigned long *)0xF0400004 = *lFBUS_DDI;
+        *(volatile unsigned long *)0xF040000C = *lFBUS_GRP;
+        *(volatile unsigned long *)0xF0400010 = *lFBUS_IOB;
+        *(volatile unsigned long *)0xF0400014 = *lFBUS_VBUS;
+        *(volatile unsigned long *)0xF0400018 = *lFBUS_VCODEC;
+        *(volatile unsigned long *)0xF040001C = *lFBUS_SMU;
+
+    //Exit Self-Refresh Mode
+        // Exit SelfRefresh
+        *(volatile unsigned long *)0xF030200C   &= ~(0x00004000);
+        *(volatile unsigned long *)0xF0304400 &= ~(0x00000004);
+
+        /*
+        *(volatile unsigned long *)0xF0302004 = 0x00000002; // PL341_WakeUP
+        while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+        *(volatile unsigned long *)0xF0302004 = 0x00000004; // PL341_Configure
+        while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+        *(volatile unsigned long *)0xF0302004 = 0x00000003; // PL341_PAUSE
+        while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+        *(volatile unsigned long *)0xF0302004 = 0x00000001; // PL341_SLEEP
+        while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=3); // Wait PL34X_STATUS_LOWPOWER
+        */
+
+    // DLL ON
+        *(volatile unsigned long *)0xF030302C |= 0x00004000; // SSTL SDRAM IO Control Register
+        *(volatile unsigned long *)0xF0303020 |= 0x00000001; // Common Register AXI_SEL
+        *(volatile unsigned long *)0xF0303020 |= 0x00000002; // Common Register IO_SEL
+        *(volatile unsigned long *)0xF0303024 &= ~(0x00000100); // PHYCTRL  Seletct DDR2
+
+        *(volatile unsigned long *)0xF0304400 =  0x0;
+        *(volatile unsigned long *)0xF0304404 =  0x00000001;      // DLL-On
+        //330Mhz
+        if(lmem_div == 1){
+            if((*lPLL0/1) >= 400 && lmem_source == 0)
+                *(volatile unsigned long *)0xF0304408 = 0x00001212; // DLLPDCFG
+            else
+                *(volatile unsigned long *)0xF0304408 = 0x00001717; // DLLPDCFG
+        }
+        else{
+            if((*lPLL0/2) >= 400 && lmem_source == 0)
+                *(volatile unsigned long *)0xF0304408 = 0x00001212; // DLLPDCFG
+            else
+                *(volatile unsigned long *)0xF0304408 = 0x00001717; // DLLPDCFG
+        }
+
+
+//      *(volatile unsigned long *)0xF0304408 = 0x00001414; // DLLPDCFG
+        *(volatile unsigned long *)0xF0304404 =  (0x00000003);    // DLL-On, DLL-Start
+        while (((*(volatile unsigned long *)0xF0304404) & (0x00000018)) != (0x00000018)); // Wait DLL Lock
+
+        *(volatile unsigned long *)0xF0304424 = 0x35; // DLL Force Lock Value Register
+        *(volatile unsigned long *)0xF030440C = 0x6; // Gate Control
+
+        if(lmem_div == 1){
+            if((*lPLL0/1) >= 400 && lmem_source == 0)
+                *(volatile unsigned long *)0xF0304430 = 0x1; // uRDDELAY  Read Delay Register
+            else
+                *(volatile unsigned long *)0xF0304430 = 0x4; // uRDDELAY  Read Delay Register
+        }
+        else{
+
+            if((*lPLL0/2) >= 400 && lmem_source == 0)
+                *(volatile unsigned long *)0xF0304430 = 0x1; // uRDDELAY  Read Delay Register
+            else
+                *(volatile unsigned long *)0xF0304430 = 0x4; // uRDDELAY  Read Delay Register
+
+        }
+
+
+        //DBG_PRINT ("ZQ Cal ...");
+        *(volatile unsigned long *)0xF0304428 = 0
+                                                | (0x1      << 0)   // Calibration Start
+                                                | (0x0      << 1)   // Update Calibration
+                                                | (0x0      << 2)   // Override ctrl_force_impp[2:0]/impn[2:0]
+                                                | (0x2      << 3)   // Calibration PULL-UP forced value
+                                                | (0x5      << 6)   // Calibration PULL-DOWN forced value
+                                                | (0x0      << 9)   // On-Die Termination Resistor Value Selection
+                                                | (0x1      << 12)  // Termination Selection    : 0 for disable
+                                                | (0x4      << 13)  // Drive Strength
+                                                | (0x0      << 16)  // Periodic Calibration
+                                                | (0x3      << 17)  // Update Counter Load Value
+                                                    ;
+        //ZQCalWait
+        while (((*(volatile unsigned long *)0xF030442C  & (0x00000001)) != (0x00000001)));
+
+        //ZQCalUpdate
+        *(volatile unsigned long *)0xF0304428 |= 0x00000002;
+        *(volatile unsigned long *)0xF0304428 &= ~0x00000002;
+    // END DLL On
+
+        *(volatile unsigned long *)0xF0302004 = 0x00000002; // PL341_WakeUP
+        while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+        *(volatile unsigned long *)0xF0302004 = 0x00000004; // PL341_Configure
+        while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+        *(volatile unsigned long *)0xF0302004 = 0x00000000; // PL341_GO
+        while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=1); //Wait PL34X_STATUS_READY
+
+
+
+}
+
+
+volatile static void tca_off_copysram(void)
+{
+    // Setup Pointer
+    volatile unsigned int   *fptr;
+    volatile unsigned int   *p;
+    int                     i;
+    unsigned int lstack = 0;
+
+
+    // Copy Function Contents to SRAM
+    fptr = (volatile unsigned int*)tca_off_sleep;
+    lpSelfRefresh = (lpfunc)(SRAM_ADDR_STANDBY);
+
+    p = (volatile unsigned int*)SRAM_ADDR_STANDBY;
+
+    for (i = 0;i < (SRAM_FUNC_SIZE+0x100);i++)
+    {
+        *p = *fptr;
+        p++;
+        fptr++;
+    }
+
+    while(--i);
+
+    // Jump to Function Start Point
+    lstack = arm_changestack();
+    lpSelfRefresh();
+    arm_restorestack(lstack);
+}
+
+void selfrefresh_test(void)
+{
+    int i;
+    unsigned long flags; 
+    unsigned int retstack = 0;
+    volatile PLCDC	pLCDC_BASE0 = (volatile PLCDC)tcc_p2v(HwLCDC0_BASE);
+    volatile PLCDC	pLCDC_BASE1 = (volatile PLCDC)tcc_p2v(HwLCDC1_BASE);
+    volatile PTIMER	pTIMER	= (volatile PTIMER)tcc_p2v(HwTMR_BASE);
+
+    // Off LCD
+    pLCDC_BASE1->LCTRL &= ~Hw0;
+    pLCDC_BASE0->LCTRL &= ~Hw0;
+
+    local_flush_tlb_all();
+    flush_cache_all();
+
+    IO_ARM_CleanDCACHE(1);
+    IO_ARM_FlushCACHE();
+
+    //WinCE
+    //OALCleanDCache();
+    //OALFlushICache();
+    
+    local_irq_save(flags);
+    local_irq_disable();
+
+    pTIMER->TC32EN &= ~Hw24;
+    
+    retstack = arm_changestack();
+
+    tca_off_copysram();
+
+    arm_restorestack(retstack);
+
+    pTIMER->TC32EN |= Hw24;
+    local_irq_restore(flags);
+
+    //	LCDC Power Up
+    pLCDC_BASE0->LCTRL |= Hw0;
+    pLCDC_BASE1->LCTRL |= Hw0;
+}
+
+
+
+static int tcc_pwrkey_ioctl(struct inode *inode, struct file *filp, 
+							unsigned int cmd, unsigned long arg)
+{
+	return 0;
+}
+
+static int tcc_pwrkey_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+int tcc_pwrkey_open(struct inode *inode, struct file *filp)
+{
+    selfrefresh_test();
+	return 0;
+}
+
+struct file_operations tcc_pwrkey_fops =
+{
+	.owner		= THIS_MODULE,
+	.open		= tcc_pwrkey_open,
+	.ioctl		= tcc_pwrkey_ioctl,
+	.release	= tcc_pwrkey_release,
+};
+
+
+
+static int __init pwrkey_init(void)
+{
+	int res;
+
+	res = register_chrdev(PM_DEV_MAJOR, PM_DEV_NAME, &tcc_pwrkey_fops);
+	if (res < 0)
+		return res;
+
+    printk("pwrkey: init\n");
+    return 0;
+}
+
+static void __exit pwrkey_exit(void)
+{
+	unregister_chrdev(PM_DEV_MAJOR, PM_DEV_NAME);
+    printk("pwrkey: exit\n");
+}
+
+module_init(pwrkey_init);
+module_exit(pwrkey_exit);
+
+MODULE_AUTHOR("Telechips Inc. <linux@telechips.com>");
+MODULE_DESCRIPTION("TCC Power Button driver");
+MODULE_LICENSE("GPL");
+
Index: linux-2.6.29/drivers/dpm/Kconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/dpm/Kconfig	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,29 @@
+#
+# Dynamic Power Management
+#
+menu "Dynamic Power Management"
+
+config DPM
+    bool "Dynamic Power Management"
+	help
+	  Enable Dynamic Power Management, if implemented for your platform.
+	  DPM conserves power by adjusting power parameters according to
+	  system state (such as idle, running a high-power-usage task, etc.)
+	  and enables associated power management features such as device
+	  constraints on power parameters.  DPM relies on power policy and
+	  machine-dependent power operating points and such to be configured
+	  from userspace after boot.
+
+	  If in doubt, say N.
+
+config DPM_PROCFS
+	bool "Enable old DPM /proc interface (deprecated)"
+	depends on DPM && PROC_FS
+	help
+	  This enables the /proc/driver/dpm interface for controlling
+	  DPM.  Please note that it is recommended to use the sysfs
+	  interface instead (which is built automatically).
+	  
+	  If in doubt, say N.
+
+endmenu
Index: linux-2.6.29/drivers/dpm/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/dpm/Makefile	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,7 @@
+#
+# Makefile for the kernel DPM driver.
+#
+
+obj-$(CONFIG_DPM)		+= dpm.o dpm-idle.o dpm-ui.o
+obj-$(CONFIG_DPM_PROCFS)	+= proc.o
+
Index: linux-2.6.29/drivers/dpm/dpm-idle.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/dpm/dpm-idle.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,175 @@
+/*
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Copyright (C) 2002, MontaVista Software <source@mvista.com>.
+ *
+ * Based on ibm405lp_dpm.c by Bishop Brock, Copyright (C) 2002,
+ * International Business Machines Corporation.
+ */
+
+#include <linux/dpm.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/kmod.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/string.h>
+#include <linux/sched.h>
+
+#include <asm/delay.h>
+#include <asm/hardirq.h>
+#include <asm/page.h>
+#include <asm/processor.h>
+#include <asm/system.h>
+#include <asm/uaccess.h>
+
+#if 0
+#define dbg printk
+#else /* no debug */
+#define dbg(x...) do {} while(0)
+#endif
+
+/****************************************************************************
+ *  DPM Idle Handler
+ ****************************************************************************/
+
+/*
+   The idle handler is one of the most important parts of DPM, as very
+   significant amounts of energy are saved by moving to a low-power idle state
+   whenever possible.  The basic coding of the core of this routine is simply:
+
+   dpm_set_os(DPM_IDLE_STATE);
+   machine-dependent-idle-routine();
+   dpm_set_os(DPM_IDLE_TASK_STATE);
+
+   The added complexity found here is introduced to avoid unnecessary work, and
+   especially to reduce the latencies associated with going in and out of idle.
+   Idle power can be greatly reduced by moving to a very low-frequency
+   operating point, but we also need to be aware of the impact on interrupt
+   latencies.  The DPM implementation of idle attempts to balance these
+   competing needs.
+
+   We support 2 "idle" states: DPM_IDLE_TASK_STATE and DPM_IDLE_STATE.  The
+   idle thread is marked as a "no-state" task, so that operating point changes
+   are not automatically made when the idle thread is scheduled. The
+   "idle-task" state is used for the majority of the idle thread.  Interrupts
+   that occur during idle are handled in this state as well. The "idle" state
+   is only entered from the idle-task state, and only for the express purpose
+   of allowing an ultra-low-power operating point.
+
+   The introduction of the idle-task state supports a stepped voltage and
+   frequency scaling at idle.  On the IBM 405LP we would not want to go from,
+   e.g., 266/133 @ 1.8 V directly to 8/8 @ 1.0 V and back.  Why not?  Because
+   we would get "stuck" at 8MHz even though we need to wake up and resume
+   useful work, e.g., we would have to set the 266/133 operating point while
+   running at 8/8.  So instead when going idle first step down to idle-task,
+   e.g., 100/50 @ 1.0 V, and then step down to e.g. 8/8 to halt.  The interrupt
+   that takes us out of idle takes us back to idle-task (100/50) for interrupt
+   processing and the potential return to 266/133.
+
+   The best policies for this implementation will be able to transition between
+   idle-task and idle without voltage scaling or driver notification. In these
+   cases the transitions are handled with minimal latency by simple frequency
+   scaling. */
+
+static inline void
+quick_idle(void)
+{
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+	dpm_quick_enter_state(DPM_IDLE_STATE);
+	dpm_md_idle();
+	dpm_quick_enter_state(DPM_IDLE_TASK_STATE);
+}
+
+static void
+full_idle(struct dpm_opt *idle_task_opt, struct dpm_opt *idle_opt)
+{
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+	dpm_quick_enter_state(DPM_IDLE_STATE);
+#ifdef CONFIG_DPM_STATS
+	dpm_update_stats(&idle_opt->stats, &idle_task_opt->stats);
+#endif
+	dpm_set_opt(idle_opt, DPM_SYNC);
+	dpm_md_idle();
+	dpm_set_opt(idle_task_opt, DPM_SYNC);
+	dpm_quick_enter_state(DPM_IDLE_TASK_STATE);
+#ifdef CONFIG_DPM_STATS
+	dpm_update_stats(&idle_task_opt->stats, &idle_opt->stats);
+#endif
+}
+
+
+/* If DPM is currently disabled here we simply do the standard
+   idle wait.
+
+   If we're not actually in DPM_IDLE_TASK_STATE, we need to go back and get
+   into this state.  This could happen in rare instances - an interrupt between
+   dpm_set_os() and the critical section.
+
+   If we are not yet at the idle-task operating point, or if there is no
+   difference between idle-task and idle, we can enter/exit the idle state
+   quickly since it's only for statistical purposes.  This is also true if for
+   some reason we can't get the DPM lock, since obviously an asynchronous event
+   is going to have to occur to clear the lock, and this event is going to take
+   us out of idle.
+
+   Otherwise the full idle shutdown is done. */
+
+
+void
+dpm_idle(void)
+{
+	unsigned long flags;
+	struct dpm_opt *idle_task_opt, *idle_opt;
+
+	current->dpm_state = DPM_NO_STATE;
+	dpm_set_os(DPM_IDLE_TASK_STATE);
+	local_irq_save(flags);
+
+	if (! need_resched()) {
+		if (!dpm_enabled) {
+			dpm_md_idle();
+
+		} else if (dpm_active_state != DPM_IDLE_TASK_STATE) {
+
+
+		} else {
+			idle_task_opt = dpm_choose_opt(dpm_active_policy,
+						       DPM_IDLE_TASK_STATE);
+			idle_opt = dpm_choose_opt(dpm_active_policy,
+						  DPM_IDLE_STATE);
+
+			if (dpm_trylock()) {
+				dpm_md_idle();
+			} else {
+
+				if ((dpm_active_opt != idle_task_opt) ||
+				    (idle_task_opt == idle_opt)) {
+
+					quick_idle();
+					dpm_unlock();
+				} else {
+					dpm_unlock();
+					full_idle(idle_task_opt, idle_opt);
+				}
+			}
+		}
+	}
+	local_irq_restore(flags);
+}
+
Index: linux-2.6.29/drivers/dpm/dpm-ui.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/dpm/dpm-ui.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,1378 @@
+/*
+ * drivers/dpm/dpm-ui.c - userspace interface to Dynamic Power Management
+ *
+ * (c) 2003 MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express or
+ * implied.
+ */
+
+#include <linux/dpm.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/kobject.h>
+#include <linux/sysfs.h>
+#include <linux/sched.h>
+
+#include <plat/dpm.h>
+#include <bsp.h>
+
+
+#if 0
+#define dbg printk
+#else /* no debug */
+#define dbg(x...) do {} while(0)
+#endif
+
+/* Common sysfs/proc support */
+
+char *dpm_state_names[DPM_STATES] = DPM_STATE_NAMES;
+char *dpm_param_names[DPM_PP_NBR] = DPM_PARAM_NAMES;
+
+#define MAXTOKENS 80
+
+static int 
+tokenizer(char **tbuf, const char *userbuf, ssize_t n, char **tokptrs,
+	  int maxtoks)
+{
+	char *cp, *tok;
+	char *whitespace = " \t\r\n";
+	int ntoks = 0;
+
+	if (!(cp = kmalloc(n + 1, GFP_KERNEL)))
+		return -ENOMEM;
+
+	*tbuf = cp;
+	memcpy(cp, userbuf, n);
+	cp[n] = '\0';
+
+	do {
+		cp = cp + strspn(cp, whitespace);
+		tok = strsep(&cp, whitespace);
+		if ((*tok == '\0') || (ntoks == maxtoks))
+			break;
+		tokptrs[ntoks++] = tok;
+	} while(cp);
+
+	return ntoks;
+}
+
+
+/* SysFS Interface */
+
+#define dpm_attr(_name,_prefix) \
+static struct kobj_attribute _prefix##_attr = { \
+        .attr   = {                             \
+                .name = __stringify(_name),     \
+                .mode = 0644,                   \
+        },                                      \
+        .show   = _prefix##_show,                 \
+        .store  = _prefix##_store,                \
+}
+
+
+static void dpm_kobj_release(struct kobject *kobj)
+{
+	/* 
+	 * No sysfs/kobject state to release, DPM layer will handle the
+	 * the containing object.
+	 */
+	   
+	return;
+}
+
+/*
+ * Top-level control
+ */
+
+static ssize_t dpm_control_show(struct kobject *dpm_kobj, struct kobj_attribute *attr, char * buf)
+{
+	unsigned long flags;
+	ssize_t len = 0;
+
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	if (dpm_lock_interruptible())
+		return -ERESTARTSYS;
+
+	if (!dpm_enabled) {
+		len += sprintf(buf, "disabled\n");
+	} else {
+		spin_lock_irqsave(&dpm_policy_lock, flags);
+		len += sprintf(buf,"enabled %s %d %s %s %s\n",
+			       dpm_active_policy->name, 
+			       dpm_active_state,
+			       dpm_state_names[dpm_active_state],
+			       dpm_classopt_name(dpm_active_policy,
+						 dpm_active_state),
+			       dpm_active_opt ? dpm_active_opt->name : "[none]");
+		spin_unlock_irqrestore(&dpm_policy_lock, flags);
+	}
+
+	dpm_unlock();
+	return len;
+}
+
+static ssize_t dpm_control_store(struct kobject *dpm_kobj, struct kobj_attribute *attr, const char * buf,
+				 size_t n)
+{
+	int error = 0;
+
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	if (strncmp(buf, "init", 4) == 0) {
+		error = dynamicpower_init();
+	} else if (strncmp(buf, "enable", 6) == 0) {
+		error = dynamicpower_enable();
+	} else if (strncmp(buf, "disable", 7) == 0) {
+		error = dynamicpower_disable();
+	} else if (strncmp(buf, "terminate", 9) == 0) {
+		error = dynamicpower_terminate();
+	} else 
+		error = -EINVAL;
+
+        return error ? error : n;
+}
+
+dpm_attr(control,dpm_control);
+
+static struct attribute * g[] = {
+        &dpm_control_attr.attr,
+        NULL,
+};
+
+static struct attribute_group dpm_attr_group = {
+        .attrs = g,
+};
+
+/* kset to create /sys/dpm/  */
+static struct kobject *dpm_kobj;
+static struct kset *dpm_kset;
+
+/*
+ * policy
+ */
+
+struct dpm_policy_attribute {
+        struct attribute        attr;
+        ssize_t (*show)(struct kobject * kobj, char * buf);
+        ssize_t (*store)(struct kobject * kobj, const char * buf, size_t count);
+};
+
+#define to_policy(obj) container_of(obj,struct dpm_policy,kobj)
+#define to_policy_attr(_attr) container_of(_attr,struct dpm_policy_attribute,attr)
+
+static struct kobject *dpm_policy_kobj;
+/*
+static struct kobject dpm_policy_kobj = {
+	.kset = &dpm_kset,
+};
+*/
+
+static ssize_t policy_control_show(struct kobject *dpm_kobj, struct kobj_attribute *attr, char * buf)
+{
+	ssize_t len = 0;
+	struct list_head  * p;
+
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	if (dpm_lock_interruptible())
+		return -ERESTARTSYS;
+
+	len += sprintf(buf + len, "policies: ");
+
+	list_for_each(p, &dpm_policies) {
+		len += sprintf(buf + len, "%s ", 
+			       ((struct dpm_policy *) 
+				list_entry(p, struct dpm_policy, list))->name);
+	}
+
+	len += sprintf(buf + len, "\n");
+	dpm_unlock();
+	return len;
+}
+
+static ssize_t policy_control_store(struct kobject *dpm_kobj, struct kobj_attribute *attr, const char * buf,
+				   size_t n)
+{
+	int error = 0;
+	char *tbuf = NULL;
+	char *token[MAXTOKENS];
+	int ntoks = tokenizer(&tbuf, buf, n, (char **) &token, MAXTOKENS);
+	
+	if (ntoks <= 0) {
+		error = ntoks;
+		goto out;
+	}
+
+	if (strcmp(token[0],"create") == 0) {
+		error = dpm_create_policy(token[1], &token[2], ntoks - 2);
+	} else if (strcmp(token[0],"set") == 0) {
+		if (ntoks != 2)
+			printk("dpm: policy set requires 1 policy name argument\n");
+		else
+			error = dpm_set_policy(token[1]);
+	} else
+		error = -EINVAL;
+
+ out:
+	if (tbuf)
+		kfree(tbuf);
+        return error ? error : n;
+}
+
+static ssize_t active_policy_show(struct kobject *dpm_kobj, struct kobj_attribute *attr, char * buf)
+{
+	unsigned long flags;
+	ssize_t len = 0;
+
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	if (dpm_lock_interruptible())
+		return -ERESTARTSYS;
+
+	if (!dpm_enabled || (dpm_active_state == DPM_NO_STATE)) {
+		len += sprintf(buf + len, "[none]\n");
+	} else {
+		spin_lock_irqsave(&dpm_policy_lock, flags);
+		len += sprintf(buf + len,"%s\n",
+			       dpm_active_policy->name);
+		spin_unlock_irqrestore(&dpm_policy_lock, flags);
+	}
+
+	dpm_unlock();
+	return len;
+}
+
+static ssize_t active_policy_store(struct kobject *dpm_kobj, struct kobj_attribute *attr, const char * buf,
+				   size_t n)
+{
+	int error = 0;
+	char *tbuf = NULL;
+	char *token[MAXTOKENS];
+	int ntoks = tokenizer(&tbuf, buf, n, (char **) &token, MAXTOKENS);
+	
+	if (ntoks <= 0) {
+		error = ntoks;
+		goto out;
+	}
+
+	error = dpm_set_policy(token[0]);
+
+ out:
+	if (tbuf)
+		kfree(tbuf);
+        return error ? error : n;
+}
+
+dpm_attr(control,policy_control);
+dpm_attr(active,active_policy);
+
+#ifdef CONFIG_DPM_STATS
+static ssize_t policy_stats_show(struct kobject *dpm_kobj, char * buf)
+{
+	int len = 0;
+	struct dpm_policy *policy;
+	struct list_head *p;
+	unsigned long long total_time;
+
+	if (dpm_lock_interruptible())
+		return -ERESTARTSYS;
+
+	if (!dpm_enabled) {
+		dpm_unlock();
+		len += sprintf(buf + len, "DPM IS DISABLED\n");
+		return len;
+	}
+
+	for (p = dpm_policies.next; p != &dpm_policies; p = p->next) {
+		policy = list_entry(p, struct dpm_policy, list);
+		len += sprintf(buf + len, "policy: %s", policy->name);
+		total_time = policy->stats.total_time;
+		if (policy == dpm_active_policy)
+			total_time += (unsigned long long) dpm_time() -
+				policy->stats.start_time;
+		len += sprintf(buf + len, " ticks: %Lu times: %lu\n",
+			       total_time,
+			       policy->stats.count);
+	}
+
+	dpm_unlock();
+	return len;
+}
+
+static ssize_t policy_stats_store(struct kobject *dpm_kobj, const char * buf,
+				  size_t n)
+{
+	return n;
+}
+
+dpm_attr(stats, policy_stats);
+#endif /* CONFIG_DPM_STATS */
+
+static ssize_t a_policy_control_show(struct kobject * kobj, char * buf)
+{
+	struct dpm_policy *policy = to_policy(kobj);
+	ssize_t len = 0;
+	int i;
+
+	len += sprintf(buf + len, "ops/classes: ");
+
+	for (i = 0; i < DPM_STATES; i++)
+		len += sprintf(buf + len, "%s ", dpm_classopt_name(policy,i));
+
+	len += sprintf(buf + len, "\n");
+	return len;
+}
+
+static ssize_t a_policy_control_store(struct kobject * kobj, const char * buf,
+				      size_t n)
+{
+	struct dpm_policy *policy = to_policy(kobj);
+	int error = 0;
+	char *tbuf = NULL;
+	char *token[MAXTOKENS];
+	int ntoks = tokenizer(&tbuf, buf, n, (char **) &token, MAXTOKENS);
+	
+	if (ntoks <= 0) {
+		error = ntoks;
+		goto out;
+	}
+
+	if (strcmp(token[0],"destroy") == 0) {
+		dpm_destroy_policy(policy->name);
+	} else
+		error = -EINVAL;
+
+ out:
+	if (tbuf)
+		kfree(tbuf);
+        return error ? error : n;
+}
+
+#define POLICY_STATE_ATTR(index) \
+static ssize_t policy_state ## index ## _show(struct kobject * kobj, \
+					      char * buf) \
+{ \
+	ssize_t len = 0; \
+	struct dpm_policy *policy = to_policy(kobj); \
+	len += sprintf(buf + len, "%s\n", policy->classopt[index].opt ? policy->classopt[index].opt->name :policy->classopt[index].class->name ); \
+	return len; \
+} \
+static ssize_t policy_state ## index ## _store(struct kobject * kobj, \
+					       const char * buf, \
+			      size_t n) \
+{ \
+	struct dpm_policy *policy = to_policy(kobj); \
+	struct dpm_classopt old_classopt; \
+	int ret; \
+ \
+	dpm_lock(); \
+	old_classopt = policy->classopt[index]; \
+	if ((ret = dpm_map_policy_state(policy,index,(char *)buf))) \
+		policy->classopt[index] = old_classopt; \
+	dpm_unlock(); \
+	return ret ? -EINVAL : n; \
+} \
+static struct dpm_policy_attribute policy_state ## index ## _attr = { \
+        .attr   = { \
+                .mode = 0644, \
+        }, \
+        .show   = policy_state ## index ## _show, \
+        .store  = policy_state ## index ## _store, \
+}; \
+
+#define MAX_POLICY_STATES 20
+POLICY_STATE_ATTR(0);
+POLICY_STATE_ATTR(1);
+POLICY_STATE_ATTR(2);
+POLICY_STATE_ATTR(3);
+POLICY_STATE_ATTR(4);
+POLICY_STATE_ATTR(5);
+POLICY_STATE_ATTR(6);
+POLICY_STATE_ATTR(7);
+POLICY_STATE_ATTR(8);
+POLICY_STATE_ATTR(9);
+POLICY_STATE_ATTR(10);
+POLICY_STATE_ATTR(11);
+#if 0
+POLICY_STATE_ATTR(12);
+POLICY_STATE_ATTR(13);
+POLICY_STATE_ATTR(14);
+POLICY_STATE_ATTR(15);
+POLICY_STATE_ATTR(16);
+POLICY_STATE_ATTR(17);
+POLICY_STATE_ATTR(18);
+POLICY_STATE_ATTR(19);
+#endif
+
+static struct dpm_policy_attribute *policy_state_attr[MAX_POLICY_STATES] = {
+	&policy_state0_attr,
+	&policy_state1_attr,
+	&policy_state2_attr,
+	&policy_state3_attr,
+	&policy_state4_attr,
+	&policy_state5_attr,
+	&policy_state6_attr,
+	&policy_state7_attr,
+	&policy_state8_attr,
+	&policy_state9_attr,
+	&policy_state10_attr,
+	&policy_state11_attr,
+#if 0
+	&policy_state12_attr,
+	&policy_state13_attr,
+	&policy_state14_attr,
+	&policy_state15_attr,
+	&policy_state16_attr,
+	&policy_state17_attr,
+	&policy_state18_attr,
+	&policy_state19_attr,
+#endif
+};
+
+static ssize_t
+policy_attr_show(struct kobject * kobj, struct attribute * attr, char * buf)
+{
+	struct dpm_policy_attribute * policy_attr = to_policy_attr(attr);
+	ssize_t ret = 0;
+
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	if (policy_attr->show)
+		ret = policy_attr->show(kobj,buf);
+	return ret;
+}
+
+static ssize_t
+policy_attr_store(struct kobject * kobj, struct attribute * attr, 
+		  const char * buf, size_t count)
+{
+	struct dpm_policy_attribute * policy_attr = to_policy_attr(attr);
+	ssize_t ret = 0;
+
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	if (policy_attr->store)
+		ret = policy_attr->store(kobj,buf,count);
+	return ret;
+}
+
+static struct dpm_policy_attribute a_policy_control_attr = {
+        .attr   = {
+                .name = "control",
+                .mode = 0644,
+        },
+        .show   = a_policy_control_show,
+        .store  = a_policy_control_store,
+};
+
+static struct sysfs_ops policy_sysfs_ops = {
+	.show	= policy_attr_show,
+	.store	= policy_attr_store,
+};
+
+static struct attribute * policy_default_attrs[] = {
+	&a_policy_control_attr.attr,
+	NULL,
+};
+
+static struct kobj_type ktype_policy = {
+	.release        = dpm_kobj_release,
+	.sysfs_ops	= &policy_sysfs_ops,
+	.default_attrs	= policy_default_attrs,
+};
+
+void dpm_sysfs_new_policy(struct dpm_policy *policy)
+{
+	int i;
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	memset(&policy->kobj, 0, sizeof(struct kobject));
+	//policy->kobj.kset = dpm_kobj->kset;
+    /*
+	kobject_set_name(&policy->kobj.kset, policy->name);
+	policy->kobj.parent = &dpm_policy_kobj;
+	policy->kobj.ktype = &ktype_policy;
+    */
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+    kobject_init_and_add(&policy->kobj, &ktype_policy, 
+                         dpm_policy_kobj, "%s", policy->name );  
+
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+    kobject_uevent(&policy->kobj, KOBJ_ADD);
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	for (i = 0; (i < DPM_STATES) && (i < MAX_POLICY_STATES); i++) {
+		policy_state_attr[i]->attr.name = dpm_state_names[i];
+		sysfs_create_file(&policy->kobj, &policy_state_attr[i]->attr);
+	}
+
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+	return;
+}
+
+void dpm_sysfs_destroy_policy(struct dpm_policy *policy)
+{
+	kobject_put(&policy->kobj);
+	return;
+}
+
+/*
+ * class
+ */
+
+struct dpm_class_attribute {
+        struct attribute        attr;
+        ssize_t (*show)(struct kobject * kobj, char * buf);
+        ssize_t (*store)(struct kobject * kobj, const char * buf, size_t count);
+};
+
+#define to_class(obj) container_of(obj,struct dpm_class,kobj)
+#define to_class_attr(_attr) container_of(_attr,struct dpm_class_attribute,attr)
+
+static ssize_t class_control_show(struct kobject *dpm_kobj, struct kobj_attribute *attr, char * buf)
+{
+	ssize_t len = 0;
+	struct list_head  * p;
+
+	len += sprintf(buf + len, "classes: ");
+
+	list_for_each(p, &dpm_classes) {
+		len += sprintf(buf + len, "%s ", 
+			       ((struct dpm_class *) 
+				list_entry(p, struct dpm_class, list))->name);
+	}
+
+	len += sprintf(buf + len, "\nactive: %s\n", 
+		       (dpm_enabled && dpm_active_class) ? 
+		       dpm_active_class->name : "[none]");
+	return len;
+}
+
+static ssize_t class_control_store(struct kobject *dpm_kobj, struct kobj_attribute *attr, const char * buf,
+				   size_t n)
+{
+	int error = 0;
+	char *tbuf = NULL;
+	char *token[MAXTOKENS];
+	int ntoks = tokenizer(&tbuf, buf, n, (char **) &token, MAXTOKENS);
+	
+	if (ntoks <= 0) {
+		error = ntoks;
+		goto out;
+	}
+
+	if (strcmp(token[0],"create") == 0) {
+		if (ntoks < 3) 
+			printk("dpm: class create requires 1 name and at least one operating point argument\n");
+		else 
+			error = dpm_create_class(token[1], &token[2], ntoks-2);
+	} else
+		error = -EINVAL;
+
+ out:
+	if (tbuf)
+		kfree(tbuf);
+        return error ? error : n;
+}
+
+static struct kobject *dpm_class_kobj;
+
+dpm_attr(control,class_control);
+
+static ssize_t a_class_control_show(struct kobject * kobj, char * buf)
+{
+	ssize_t len = 0;
+	struct dpm_class *class = to_class(kobj);
+	int i;
+
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	len += sprintf(buf + len, "ops: ");
+
+	for (i = 0; i < class->nops; i++)
+		len += sprintf(buf + len, "%s ", class->ops[i]->name);
+	
+
+	len += sprintf(buf + len, "\n");
+	return len;
+}
+
+static ssize_t a_class_control_store(struct kobject * kobj, const char * buf,
+				      size_t n)
+{
+	return n;
+}
+
+static ssize_t
+class_attr_show(struct kobject * kobj, struct attribute * attr, char * buf)
+{
+	struct dpm_class_attribute * class_attr = to_class_attr(attr);
+	ssize_t ret = 0;
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	if (class_attr->show)
+		ret = class_attr->show(kobj,buf);
+	return ret;
+}
+
+static ssize_t
+class_attr_store(struct kobject * kobj, struct attribute * attr, 
+		 const char * buf, size_t count)
+{
+	struct dpm_class_attribute * class_attr = to_class_attr(attr);
+	ssize_t ret = 0;
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	if (class_attr->store)
+		ret = class_attr->store(kobj,buf,count);
+	return ret;
+}
+
+static struct dpm_class_attribute a_class_control_attr = {
+        .attr   = {
+                .name = "control",
+                .mode = 0644,
+        },
+        .show   = a_class_control_show,
+        .store  = a_class_control_store,
+};
+
+static struct sysfs_ops class_sysfs_ops = {
+	.show	= class_attr_show,
+	.store	= class_attr_store,
+};
+
+static struct attribute * class_default_attrs[] = {
+	&a_class_control_attr.attr,
+	NULL,
+};
+
+static struct kobj_type ktype_class = {
+	.release        = dpm_kobj_release,
+	.sysfs_ops	= &class_sysfs_ops,
+	.default_attrs	= class_default_attrs,
+};
+
+void dpm_sysfs_new_class(struct dpm_class *class)
+{
+	memset(&class->kobj, 0, sizeof(struct kobject));
+	class->kobj.kset = dpm_kobj->kset;
+    /*
+	kobject_set_name(&class->kobj.kset, class->name);
+	class->kobj.parent = &dpm_class_kobj;
+	class->kobj.ktype = &ktype_class;
+    */
+    kobject_init_and_add(&class->kobj, &ktype_class, 
+                         dpm_class_kobj, "%s", class->name);  
+
+    kobject_uevent(&class->kobj, KOBJ_ADD);
+	return;
+}
+
+void dpm_sysfs_destroy_class(struct dpm_class *class)
+{
+	kobject_put(&class->kobj);
+	return;
+}
+
+
+/*
+ * op
+ */
+
+struct dpm_op_attribute {
+        struct attribute        attr;
+        ssize_t (*show)(struct kobject * kobj, char * buf);
+        ssize_t (*store)(struct kobject * kobj, const char * buf, size_t count);
+};
+
+#define to_op(obj) container_of(obj,struct dpm_opt,kobj)
+#define to_op_attr(_attr) container_of(_attr,struct dpm_op_attribute,attr)
+
+static ssize_t op_control_show(struct kobject *dpm_kobj, struct kobj_attribute *attr, char * buf)
+{
+	unsigned long flags;
+	ssize_t len = 0;
+
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	if (dpm_lock_interruptible())
+		return -ERESTARTSYS;
+
+	len += sprintf(buf + len, "active: ");
+
+	if (!dpm_enabled) {
+		len += sprintf(buf + len, "[none]\n");
+	} else {
+		spin_lock_irqsave(&dpm_policy_lock, flags);
+		len += sprintf(buf + len,"%s\n",
+			       dpm_active_opt ? dpm_active_opt->name : "[none]");
+		spin_unlock_irqrestore(&dpm_policy_lock, flags);
+	}
+
+	dpm_unlock();
+
+	len += sprintf(buf + len, "params: %d\n", DPM_PP_NBR);
+	return len;
+}
+
+static ssize_t op_control_store(struct kobject *dpm_kobj, struct kobj_attribute *attr, const char * buf,
+				size_t n)
+{
+	int error = 0;
+	char *tbuf = NULL;
+	char *token[MAXTOKENS];
+	int ntoks = tokenizer(&tbuf, buf, n, (char **) &token, MAXTOKENS);
+	
+	if (ntoks <= 0) {
+		error = ntoks;
+		goto out;
+	}
+
+	if ((strcmp(token[0],"create") == 0) && (ntoks >= 2)) {
+		dpm_md_pp_t pp[DPM_PP_NBR];
+		int i;
+			
+		for (i = 0; i < DPM_PP_NBR; i++) {
+			if (i >= ntoks - 2)
+				pp[i] = -1;
+			else
+				pp[i] = simple_strtol(token[i + 2],
+						      NULL, 0);
+		}
+
+		error = dpm_create_opt(token[1], pp, DPM_PP_NBR);
+	} else
+		error = -EINVAL;
+
+ out:
+	if (tbuf)
+		kfree(tbuf);
+        return error ? error : n;
+
+}
+
+dpm_attr(control,op_control);
+
+#ifdef CONFIG_DPM_STATS
+static ssize_t op_stats_show(struct kobject *dpm_kobj, char * buf)
+{
+	int len = 0;
+	struct dpm_opt *opt;
+	struct list_head *p;
+	unsigned long long total_time;
+
+	if (dpm_lock_interruptible())
+		return -ERESTARTSYS;
+
+	if (!dpm_enabled) {
+		dpm_unlock();
+		len += sprintf(buf + len, "DPM IS DISABLED\n");
+		return len;
+	}
+
+	for (p = dpm_opts.next; p != &dpm_opts; p = p->next) {
+		opt = list_entry(p, struct dpm_opt, list);
+		len += sprintf(buf + len, "op: %s", opt->name);
+		total_time = opt->stats.total_time;
+		if (opt == dpm_active_opt)
+			total_time += (unsigned long long) dpm_time() -
+				opt->stats.start_time;
+		len += sprintf(buf + len, " ticks: %Lu times: %lu\n",
+			       total_time, opt->stats.count);
+	}
+
+	dpm_unlock();
+	return len;
+}
+
+static ssize_t op_stats_store(struct kobject *dpm_kobj, const char * buf,
+			      size_t n)
+{
+	return n;
+}
+
+dpm_attr(stats, op_stats);
+#endif /* CONFIG_DPM_STATS */
+
+
+static struct kobject *dpm_op_kobj; 
+
+static ssize_t an_op_control_show(struct kobject * kobj, char * buf)
+{
+	ssize_t len = 0;
+	// struct dpm_opt *opt = to_op(kobj);
+
+	len += sprintf(buf + len, "\n");
+	return len;
+}
+
+static ssize_t an_op_control_store(struct kobject * kobj, const char * buf,
+				   size_t n)
+{
+	return n;
+}
+
+static struct dpm_op_attribute an_op_control_attr = {
+        .attr   = {
+                .name = "control",
+                .mode = 0644,
+        },
+        .show   = an_op_control_show,
+        .store  = an_op_control_store,
+};
+
+static ssize_t op_force_show(struct kobject * kobj, char * buf)
+{
+	ssize_t len = 0;
+	struct dpm_opt *opt = to_op(kobj);
+
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+	len += sprintf(buf + len, "%d\n", opt->flags & DPM_OP_FORCE ? 1 : 0);
+	return len;
+}
+
+static ssize_t op_force_store(struct kobject * kobj, const char * buf,
+			      size_t n)
+{
+	struct dpm_opt *opt = to_op(kobj);
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	opt->flags = (opt->flags & ~DPM_OP_FORCE) | 
+		(simple_strtol(buf, NULL, 0) ? DPM_OP_FORCE : 0);
+	return n;
+}
+
+static struct dpm_op_attribute op_force_attr = {
+        .attr   = {
+                .name = "force",
+                .mode = 0644,
+        },
+        .show   = op_force_show,
+        .store  = op_force_store,
+};
+
+#define OP_PARAM_ATTR(index) \
+static ssize_t op_param ## index ## _show(struct kobject * kobj, char * buf) \
+{ \
+	ssize_t len = 0; \
+	struct dpm_opt *opt = to_op(kobj); \
+	len += sprintf(buf + len, "%d\n", opt->pp[index]); \
+	return len; \
+} \
+static ssize_t op_param ## index ## _store(struct kobject * kobj, const char * buf, \
+			      size_t n) \
+{ \
+	struct dpm_opt *opt = to_op(kobj); \
+	int ret, oldval; \
+ \
+	oldval = opt->pp[index]; \
+	opt->pp[index] = simple_strtol(buf, NULL, 0); \
+	ret = dpm_md_init_opt(opt); \
+	if (ret) \
+		opt->pp[index] = oldval; \
+	return ret ? ret : n; \
+} \
+static struct dpm_op_attribute op_param ## index ## _attr = { \
+        .attr   = { \
+                .mode = 0644, \
+        }, \
+        .show   = op_param ## index ## _show, \
+        .store  = op_param ## index ## _store, \
+}; \
+
+#define MAX_OP_PARAMS DPM_MD_MAX
+OP_PARAM_ATTR(0);
+OP_PARAM_ATTR(1);
+OP_PARAM_ATTR(2);
+OP_PARAM_ATTR(3);
+OP_PARAM_ATTR(4);
+OP_PARAM_ATTR(5);
+OP_PARAM_ATTR(6);
+OP_PARAM_ATTR(7);
+OP_PARAM_ATTR(8);
+OP_PARAM_ATTR(9);
+OP_PARAM_ATTR(10);
+OP_PARAM_ATTR(11);
+OP_PARAM_ATTR(12);
+OP_PARAM_ATTR(13);
+OP_PARAM_ATTR(14);
+OP_PARAM_ATTR(15);
+#if 0
+OP_PARAM_ATTR(16);
+OP_PARAM_ATTR(17);
+OP_PARAM_ATTR(18);
+OP_PARAM_ATTR(19);
+#endif
+
+static struct dpm_op_attribute *op_param_attr[MAX_OP_PARAMS] = {
+	&op_param0_attr,
+	&op_param1_attr,
+	&op_param2_attr,
+	&op_param3_attr,
+	&op_param4_attr,
+	&op_param5_attr,
+	&op_param6_attr,
+	&op_param7_attr,
+	&op_param8_attr,
+	&op_param9_attr,
+	&op_param10_attr,
+	&op_param11_attr,
+	&op_param12_attr,
+	&op_param13_attr,
+	&op_param14_attr,
+	&op_param15_attr,
+#if 0
+	&op_param16_attr,
+	&op_param17_attr,
+	&op_param18_attr,
+	&op_param19_attr,
+#endif
+};
+
+static ssize_t
+op_attr_show(struct kobject * kobj, struct attribute * attr, char * buf)
+{
+	struct dpm_op_attribute * op_attr = to_op_attr(attr);
+	ssize_t ret = 0;
+
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	if (op_attr->show)
+		ret = op_attr->show(kobj,buf);
+	return ret;
+}
+
+static ssize_t
+op_attr_store(struct kobject * kobj, struct attribute * attr, 
+	      const char * buf, size_t count)
+{
+	struct dpm_op_attribute * op_attr = to_op_attr(attr);
+	ssize_t ret = 0;
+
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	if (op_attr->store)
+		ret = op_attr->store(kobj,buf,count);
+	return ret;
+}
+
+static struct sysfs_ops op_sysfs_ops = {
+	.show	= op_attr_show,
+	.store	= op_attr_store,
+};
+
+static struct attribute * op_default_attrs[] = {
+	&an_op_control_attr.attr,
+	&op_force_attr.attr,
+	NULL,
+};
+
+static struct kobj_type ktype_op = {
+	.release        = dpm_kobj_release,
+	.sysfs_ops	= &op_sysfs_ops,
+	.default_attrs	= op_default_attrs,
+};
+
+void dpm_sysfs_new_op(struct dpm_opt *opt)
+{
+	int i;
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	memset(&opt->kobj, 0, sizeof(struct kobject));
+	opt->kobj.kset = dpm_kobj->kset;
+    /*
+	kobject_set_name(&opt->kobj.kset, opt->name);
+	opt->kobj.parent = &dpm_op_kobj;
+	opt->kobj.ktype = &ktype_op;
+    */
+    kobject_init_and_add(&opt->kobj, &ktype_op, 
+                         dpm_op_kobj, "%s", opt->name);  
+
+    kobject_uevent(&opt->kobj, KOBJ_ADD);
+
+	for (i = 0; (i < DPM_PP_NBR) && (i < MAX_OP_PARAMS); i++) {
+		op_param_attr[i]->attr.name = dpm_param_names[i];
+		sysfs_create_file(&opt->kobj, &op_param_attr[i]->attr);
+	}
+
+	return;
+}
+
+void dpm_sysfs_destroy_op(struct dpm_opt *opt)
+{
+	kobject_put(&opt->kobj);
+	return;
+}
+
+
+/*
+ * state
+ */
+
+
+static ssize_t state_control_show(struct kobject *dpm_kobj, struct kobj_attribute *attr, char * buf)
+{
+	ssize_t len = 0;
+	int i;
+
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+	len += sprintf(buf + len, "states: ");
+
+	for (i = 0; i < DPM_STATES; i++) {
+		len += sprintf(buf + len, "%s ", dpm_state_names[i]);
+	}
+
+	len += sprintf(buf + len, "\ntask-states: min=%s norm=%s max=%s\n",
+		       dpm_state_names[DPM_TASK_STATE - DPM_TASK_STATE_LIMIT],
+		       dpm_state_names[DPM_TASK_STATE],
+		       dpm_state_names[DPM_TASK_STATE + DPM_TASK_STATE_LIMIT]);
+
+	return len;
+}
+
+static ssize_t state_control_store(struct kobject *dpm_kobj, struct kobj_attribute *attr, const char * buf,
+				   size_t n)
+{
+	return -EINVAL;
+}
+
+static ssize_t active_state_show(struct kobject *dpm_kobj, struct kobj_attribute *attr, char * buf)
+{
+	unsigned long flags;
+	ssize_t len = 0;
+
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	if (dpm_lock_interruptible())
+		return -ERESTARTSYS;
+
+	if (!dpm_enabled || (dpm_active_state == DPM_NO_STATE)) {
+		len += sprintf(buf + len, "[none]\n");
+	} else {
+		spin_lock_irqsave(&dpm_policy_lock, flags);
+		len += sprintf(buf + len,"%s\n",
+			       dpm_state_names[dpm_active_state]);
+		spin_unlock_irqrestore(&dpm_policy_lock, flags);
+	}
+
+	dpm_unlock();
+	return len;
+}
+
+static ssize_t active_state_store(struct kobject *dpm_kobj, struct kobj_attribute *attr, const char * buf,
+				  size_t n)
+{
+	int error = 0;
+	char *tbuf = NULL;
+	char *token[MAXTOKENS];
+	int ntoks = tokenizer(&tbuf, buf, n, (char **) &token, MAXTOKENS);
+	
+	if (ntoks <= 0) {
+		error = ntoks;
+		goto out;
+	}
+
+	error = dpm_set_op_state(token[0]);
+
+ out:
+	if (tbuf)
+		kfree(tbuf);
+        return error ? error : n;
+}
+
+#ifdef CONFIG_DPM_STATS
+static ssize_t state_stats_show(struct kobject *dpm_kobj, char * buf)
+{
+	unsigned long flags;
+	ssize_t len = 0;
+	int i;
+
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	spin_lock_irqsave(&dpm_policy_lock, flags);
+
+	for (i = 0; i < DPM_STATES; i++) {
+		unsigned long long total_time = dpm_state_stats[i].total_time;
+
+		if (i == dpm_active_state)
+			total_time += (unsigned long long) dpm_time() -
+				dpm_state_stats[i].start_time;
+		
+		len += sprintf(buf + len, "state: %s", dpm_state_names[i]);
+                len += sprintf(buf + len, " ticks: %Lu",
+			       total_time);
+		len += sprintf(buf + len, " times: %lu\n",
+			       dpm_state_stats[i].count);
+	}
+
+	spin_unlock_irqrestore(&dpm_policy_lock, flags);
+	return len;
+}
+
+static ssize_t state_stats_store(struct kobject *dpm_kobj, const char * buf,
+				 size_t n)
+{
+        return n;
+}
+#endif /* CONFIG_DPM_STATS */
+
+static struct kobject *dpm_state_kobj; 
+
+dpm_attr(control, state_control);
+dpm_attr(active, active_state);
+#ifdef CONFIG_DPM_STATS
+dpm_attr(stats, state_stats);
+#endif
+
+struct astate {
+	int index;
+	struct kobject *kobj;
+};
+
+struct astate_attribute {
+        struct attribute        attr;
+        ssize_t (*show)(struct kobject * kobj, char * buf);
+        ssize_t (*store)(struct kobject * kobj, const char * buf, size_t count);
+};
+
+#define to_astate(obj) container_of(obj,struct astate,kobj)
+#define to_astate_attr(_attr) container_of(_attr,struct astate_attribute,attr)
+
+static ssize_t
+astate_attr_show(struct kobject * kobj, struct attribute * attr, char * buf)
+{
+	struct astate_attribute * astate_attr = to_astate_attr(attr);
+	ssize_t ret = 0;
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	if (astate_attr->show)
+		ret = astate_attr->show(kobj,buf);
+	return ret;
+}
+
+static ssize_t
+astate_attr_store(struct kobject * kobj, struct attribute * attr, 
+		  const char * buf, size_t count)
+{
+	struct astate_attribute * astate_attr = to_astate_attr(attr);
+	ssize_t ret = 0;
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	if (astate_attr->store)
+		ret = astate_attr->store(kobj,buf,count);
+	return ret;
+}
+
+static int show_opconstrains(int state, char *buf)
+{
+	struct dpm_opt *opt;
+	int len = 0;
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	if (dpm_active_policy->classopt[state].opt) {
+		opt = dpm_active_policy->classopt[state].opt;
+
+		len += dpm_show_opconstraints(opt, buf);
+	}
+	else {
+		int i;
+
+		for (i = 0; 
+		     i < dpm_active_policy->classopt[state].class->nops; i++) {
+			len += dpm_show_opconstraints(
+				dpm_active_policy->classopt[state].class->ops[i], buf);
+		}
+	}
+
+	return len;
+}
+static ssize_t astate_constraints_show(struct kobject * kobj, char * buf)
+{
+	struct astate *astate = to_astate(kobj);
+	ssize_t len = 0;
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	if (dpm_enabled && dpm_active_policy)
+		len = show_opconstrains(astate->index, buf);
+
+	return len;
+}
+
+static ssize_t astate_constraints_store(struct kobject * kobj, 
+					const char * buf, size_t n)
+{
+	return n;
+}
+
+static struct astate_attribute astate_constraints_attr = {
+        .attr   = {
+                .name = "constraints",
+                .mode = 0644,
+        },
+        .show   = astate_constraints_show,
+        .store  = astate_constraints_store,
+};
+
+static struct sysfs_ops astate_sysfs_ops = {
+	.show	= astate_attr_show,
+	.store	= astate_attr_store,
+};
+
+static struct attribute * astate_default_attrs[] = {
+	&astate_constraints_attr.attr,
+	NULL,
+};
+
+static struct kobj_type ktype_astate = {
+	.release        = dpm_kobj_release,
+	.sysfs_ops	= &astate_sysfs_ops,
+	.default_attrs	= astate_default_attrs,
+};
+
+static struct astate astate[DPM_STATES];
+
+/*
+ * Init 
+ */
+
+
+static int __init dpm_sysfs_init(void)
+{
+    int error, i;
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+    dpm_kset = kset_create_and_add("dpm", NULL, NULL);
+    if(!dpm_kset)
+        return -ENOMEM;
+
+#if 1
+    dpm_kobj = kobject_create_and_add("dpm", &dpm_kset->kobj);
+    if(!dpm_kobj)
+        return -ENOMEM;
+#endif
+
+    //error = sysfs_create_group(&dpm_kset->kobj,&dpm_attr_group);
+    error = sysfs_create_group(dpm_kobj,&dpm_attr_group);
+    if(error) {
+        dbg("error creating sysfs files (%d)\n", error);
+        return error;
+    }
+    dpm_policy_kobj = kobject_create_and_add("policy", dpm_kobj);
+    //dpm_policy_kobj = kobject_create_and_add("policy", &dpm_kset->kobj);
+
+    if(!dpm_policy_kobj)
+        goto policy_kobj_err;
+    sysfs_create_file(dpm_policy_kobj, &policy_control_attr.attr);
+    sysfs_create_file(dpm_policy_kobj, &active_policy_attr.attr);
+#ifdef CONFIG_DPM_STATS
+    sysfs_create_file(dpm_policy_kobj, &policy_stats_attr.attr);
+#endif
+    for (i = 0; i < DPM_STATES; i++) {
+        astate[i].index = i;
+        astate[i].kobj = kobject_create_and_add(dpm_state_names[i], dpm_policy_kobj);
+        astate[i].kobj->kset = dpm_kobj->kset;
+        astate[i].kobj->parent = dpm_policy_kobj;
+        astate[i].kobj->ktype = &ktype_policy;
+    }
+
+    dpm_class_kobj = kobject_create_and_add("class", dpm_kobj);
+    //dpm_class_kobj = kobject_create_and_add("class", &dpm_kset->kobj);
+    if(!dpm_class_kobj)
+        goto class_kobj_err;
+    sysfs_create_file(dpm_class_kobj, &class_control_attr.attr);
+    for (i = 0; i < DPM_STATES; i++) {
+        astate[i].index = i;
+        astate[i].kobj = kobject_create_and_add(dpm_state_names[i], dpm_class_kobj);
+        astate[i].kobj->kset = dpm_kobj->kset;
+        astate[i].kobj->parent = dpm_class_kobj;
+        astate[i].kobj->ktype = &ktype_class;
+    }
+
+    dpm_op_kobj = kobject_create_and_add("op", dpm_kobj);
+    //dpm_op_kobj = kobject_create_and_add("op", &dpm_kset->kobj);
+    if(!dpm_op_kobj)
+        goto op_kobj_err;
+    sysfs_create_file(dpm_op_kobj, &op_control_attr.attr);
+#ifdef CONFIG_DPM_STATS
+    sysfs_create_file(dpm_op_kobj, &op_stats_attr.attr);
+#endif
+    for (i = 0; i < DPM_STATES; i++) {
+        astate[i].index = i;
+        astate[i].kobj = kobject_create_and_add(dpm_state_names[i], dpm_op_kobj);
+        astate[i].kobj->kset = dpm_kobj->kset;
+        astate[i].kobj->parent = dpm_op_kobj;
+        astate[i].kobj->ktype = &ktype_op;
+    }
+
+    dpm_state_kobj = kobject_create_and_add("state", dpm_kobj);
+    //dpm_state_kobj = kobject_create_and_add("state", &dpm_kset->kobj);
+    if(!dpm_state_kobj)
+        goto state_kobj_err;
+    sysfs_create_file(dpm_state_kobj, &state_control_attr.attr);
+    sysfs_create_file(dpm_state_kobj, &active_state_attr.attr);
+#ifdef CONFIG_DPM_STATS
+    sysfs_create_file(&dpm_state_kobj, &state_stats_attr.attr);
+#endif
+
+    for (i = 0; i < DPM_STATES; i++) {
+        astate[i].index = i;
+        astate[i].kobj = kobject_create_and_add(dpm_state_names[i], dpm_state_kobj);
+        astate[i].kobj->kset = dpm_kobj->kset;
+        astate[i].kobj->parent = dpm_state_kobj;
+        astate[i].kobj->ktype = &ktype_astate;
+    }
+
+policy_kobj_err:
+    kobject_put(dpm_policy_kobj);
+class_kobj_err:
+    kobject_put(dpm_class_kobj);
+op_kobj_err:
+    kobject_put(dpm_op_kobj);
+state_kobj_err:
+    kobject_put(dpm_state_kobj);
+
+
+    return error;
+}
+
+__initcall(dpm_sysfs_init);
+
+/* /proc interface */
+
+int dpm_set_task_state_by_name(struct task_struct *task, char *buf, ssize_t n)
+{
+	int task_state;
+	int ret = 0;
+	char *tbuf = NULL;
+	char *token[MAXTOKENS];
+	int ntoks = tokenizer(&tbuf, buf, n, (char **) &token, MAXTOKENS);
+
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+	
+	if (ntoks <= 0) {
+		ret = ntoks;
+		goto out;
+	}
+
+	for (task_state = DPM_TASK_STATE - DPM_TASK_STATE_LIMIT;
+	     task_state <= DPM_TASK_STATE + DPM_TASK_STATE_LIMIT; 
+	     task_state++)
+		if (strcmp(token[0], dpm_state_names[task_state]) == 0) {
+			task->dpm_state = task_state;
+			if (task == current)
+				dpm_set_os(task_state);
+
+			ret = 0;
+			break;
+		}
+
+out:
+	if (tbuf)
+		kfree(tbuf);
+
+	return ret;
+}
Index: linux-2.6.29/drivers/dpm/dpm.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/dpm/dpm.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,1141 @@
+/*
+ * drivers/dpm/policy.c  Dynamic Power Management Policies
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Copyright (C) 2002, International Business Machines Corporation
+ * All Rights Reserved
+ *
+ * Robert Paulsen
+ * IBM Linux Technology Center
+ * rpaulsen@us.ibm.com
+ * August, 2002
+ *
+ */
+
+/* TODO:
+
+   Rethink init/enable/disable: It may be redundant and/or unsafe
+   Fix initialization and stats
+*/
+
+#include <linux/dpm.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/preempt.h>
+
+#include <linux/semaphore.h>
+#include <asm/system.h>
+#include <asm/uaccess.h>
+
+#include <bsp.h>
+
+
+#if 0
+#define dbg printk
+#else /* no debug */
+#define dbg(x...) do {} while(0)
+#endif
+
+
+
+#define TRACE
+//#undef TRACE
+#if defined(TRACE)
+#define trace(args...) do { printk("TRACE: "); printk(args); } while(0)
+#else
+#define trace(args...) do {} while(0)
+#endif
+
+struct dpm_md dpm_md;
+
+static struct dpm_opt nop_op = {
+	.name  = "[nop]",
+	.flags = DPM_OP_NOP,
+};
+
+unsigned long dpm_compute_lpj(unsigned long ref, u_int div, u_int mult)
+{
+	unsigned long new_jiffy_l, new_jiffy_h;
+
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+	/*
+	 * Recalculate loops_per_jiffy.  We do it this way to
+	 * avoid math overflow on 32-bit machines.  Maybe we
+	 * should make this architecture dependent?  If you have
+	 * a better way of doing this, please replace!
+	 *
+	 *    new = old * mult / div
+	 */
+	new_jiffy_h = ref / div;
+	new_jiffy_l = (ref % div) / 100;
+	new_jiffy_h *= mult;
+	new_jiffy_l = new_jiffy_l * mult / div;
+
+	return new_jiffy_h + new_jiffy_l * 100;
+}
+
+/****************************************************************************
+
+DPM Synchronization and Operating Point Changes
+===============================================
+
+There are 2 aspects to synchronization in DPM: First, the usual requirement of
+serializing access to shared data structures, and second, the idea of
+synchronizing the operating point and the current operating state.  The second
+condition arises because setting an operating point may complete asynchronously
+for a number of reasons, whereas the operating state change that causes the
+operating point change succeeds immediately.
+
+Access to most of the global variables representing the current state of DPM
+and the current policy are protected by a spinlock, dpm_policy_lock.  The use
+of this lock appears in only a few critical places.
+
+Setting the operating point, reading the value of the current operating point
+or changing the current policy may only be done while holding the semaphore
+_dpm_lock.  Access to the _dpm_lock is abstracted by the dpm_lock() and
+dpm_unlock() calls as explained below.  (The semaphore should only be accessed
+this way to simplify future development).
+
+The _dpm_lock must be held (by a call to a dpm_lock function) by any caller of
+the interfaces that set the operating point, change the policy, or enable or
+disable DPM.  Note that the corresponding call to dpm_unlock() may be
+explicitly required, or implicit (see dpm_set_opt_async() below).
+
+For simplicity, the calls that create operating points and policies also use
+dpm_lock() and dpm_unlock() to protect access to the non-active policies as
+well. Since these are normally initialization calls, this should not interfere
+with the operation of the system once initialized.
+
+Three interfaces are provided for obtaining the _dpm_lock:
+
+void dpm_lock();
+int dpm_lock_interruptible();
+int dpm_trylock();
+
+dpm_lock_interruptible() returns -ERESTARTSYS if the wait for the _dpm_lock was
+interrupted, and dpm_trylock() returns -EBUSY if the semaphore is currently
+held. 
+
+Once the _dpm_lock is held, two interfaces are provided for setting the
+operating point:
+
+int dpm_set_opt_async()
+int dpm_set_opt_sync();
+
+Neither of these interfaces takes parameters since under DPM the operating
+point to select is always implied by the current policy and operating state.
+If the system is already at the correct operating point then no change is
+required or made.  To avoid deadlock, the caller must not be holding the
+dpm_policy_lock when either of these calls is made.
+
+dpm_set_opt_async() launches a change in the operating point that will
+potentially terminate asynchronously.  This interface never blocks the caller,
+thus there is no guarantee that the system is actually running at the implied
+operating point when control returns to the caller. This call is used by
+dpm_set_os() during an operating state change.  Note since this call terminates
+asynchronously, the call to dpm_unlock() is implicitly made when the operating
+point change is complete.  I.e., the caller obtains the _dpm_lock with
+dpm_lock(), calls dpm_set_opt_async(), then continues.
+
+dpm_set_opt_sync() launches a synchronous change in the operating point.  This
+call will block the caller as necessary during the call, thus it can only be
+issued from a process context.  When control returns to the caller, the caller
+can be sure that the implied operating point was set, and that the system is
+currently running at the correct operating point for the given policy and
+operating state.  This call is used by dpm_set_policy() and the device
+constraint update code to guarantee that the change to a new policy, or changes
+to operating point classes as a result of device constraits are reflected in
+the operating point.
+
+Note that regardless of whether an operating point change is synchrounous or
+asynchronous, it is still possible that the operating state may change during
+the call.  Setting the operating point is (currently) not preemptible,
+therefore at the time that the operating point change is complete, it may no
+longer be the correct operating point for the operating state.  This condition
+is always handled by the dpm_set_opt*() routines, which will launch a tasklet
+to re-synchronize the operating point to the operating state.
+
+It is possible that due to poorly designed policies and asynchronous
+termination of operating point changes that the operating point will always lag
+behind the operating state.  This is only a performance issue, not a
+correctness issue.  Since a valid policy has a valid operating point for every
+operating state, and changes to the policy and changes in devices constraints
+always use dpm_set_opt_sync(), there will never be a case where the current
+operating point does not support device constraints.
+
+****************************************************************************/
+
+/* curently installed policies and operating points */
+LIST_HEAD(dpm_policies);
+LIST_HEAD(dpm_classes);
+LIST_HEAD(dpm_opts);
+
+DECLARE_MUTEX(_dpm_lock);
+spinlock_t dpm_policy_lock = SPIN_LOCK_UNLOCKED;
+
+/* the currently active policy */
+struct dpm_policy *dpm_active_policy;
+
+/* the currently active operating state, class, and operating point */
+dpm_state_t dpm_active_state = DPM_NO_STATE;
+struct dpm_opt *dpm_active_opt;
+struct dpm_class *dpm_active_class;
+
+/* is DPM initialized and enabled? */
+int dpm_enabled;
+int dpm_initialized;
+
+#ifdef CONFIG_DPM_STATS
+#include <asm/div64.h>
+
+struct dpm_stats dpm_state_stats[DPM_STATES];
+
+/*
+ * Start counting DPM stats from the time DPM was enabled... in the case of
+ * operating states the stats are updated from the time userspace is started.
+ */
+
+void
+dpm_stats_reset(void)
+{
+	int i;
+
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	preempt_disable();
+	for (i = 0; i < DPM_STATES; i++) {
+		dpm_state_stats[i].total_time = 0;
+		dpm_state_stats[i].start_time = 0;
+		dpm_state_stats[i].count = 0;
+	}
+
+	if (dpm_active_state != DPM_NO_STATE) {
+		dpm_state_stats[dpm_active_state].start_time = dpm_time();
+		dpm_state_stats[dpm_active_state].count = 1;
+	}
+
+	preempt_enable();
+}
+
+unsigned long long
+dpm_update_stats(struct dpm_stats *new, struct dpm_stats *old)
+{
+	unsigned long long now = dpm_time();
+
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	if (old)
+		old->total_time += now - old->start_time;
+
+	if (new) {
+		new->start_time = now;
+		new->count += 1;
+	}
+
+	return now;
+}
+#else
+#define dpm_update_stats(a,b) do {} while (0)
+#define dpm_stats_reset() do {} while (0)
+#endif /* CONFIG_DPM_STATS */
+
+struct dpm_opt *
+dpm_choose_opt(struct dpm_policy *policy, int state)
+{
+	struct dpm_opt *opt = NULL;
+
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	if (policy->classopt[state].opt) {
+		opt = policy->classopt[state].opt;
+
+		if (! dpm_check_constraints(opt))
+			opt = NULL;
+
+		dpm_active_class = NULL;
+	}
+	else {
+		int i;
+
+		for (i = 0; i < policy->classopt[state].class->nops; i++) {
+			if (dpm_check_constraints(
+				    policy->classopt[state].class->ops[i])) {
+				opt = policy->classopt[state].class->ops[i];
+				break;
+			}
+		}
+
+		dpm_active_class = policy->classopt[state].class;
+	}
+
+	return opt;
+}
+
+
+
+/*****************************************************************************
+ * dpm_next_opt() returns the operating point that needs to be activated next,
+ * or NULL if the operating point is up-to-date or the DPM system is disabled.
+ * Since this call looks at the value of the current operating point, it can
+ * only be made when the _dpm_lock is held.
+ *****************************************************************************/
+
+static inline struct dpm_opt *
+dpm_next_opt(void)
+{
+	struct dpm_opt *opt = NULL;
+
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	if (! spin_trylock(&dpm_policy_lock))
+		return NULL;
+	if (dpm_enabled && dpm_active_state != DPM_NO_STATE) {
+		opt = dpm_choose_opt(dpm_active_policy,dpm_active_state);
+		if (opt == dpm_active_opt)
+			opt = NULL;
+	}
+	spin_unlock(&dpm_policy_lock);
+	return opt;
+}
+
+/*****************************************************************************
+ * Set the operating point implied by the current DPM policy. These calls can
+ * only be made while holding _dpm_lock, and the release of
+ * _dpm_lock is implied by the call (see below).
+ *****************************************************************************/
+
+static struct dpm_opt temp_opt = { name : "[System Operating Point]" };
+
+int
+dpm_set_opt(struct dpm_opt *new, unsigned flags)
+{
+	int error;
+
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	if (new->flags & DPM_OP_NOP) {
+		if (flags & DPM_UNLOCK)
+			dpm_unlock();
+		return 0;
+	}
+
+	/* Support for setting the operating point when DPM is not running, and
+	   setting the first operating point. */
+
+	if (!dpm_enabled || !dpm_active_opt) {
+        dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+		if (dpm_md_get_opt(&temp_opt)) {
+			printk(KERN_ERR "dpm_default_set_opt: "
+			      "DPM disabled and system "
+			      "operating point is illegal!\n");
+
+			if (flags & DPM_UNLOCK)
+				dpm_unlock();
+			return -EINVAL;
+		}
+		dpm_active_opt = &temp_opt;
+		dpm_active_class = NULL;
+	}
+
+	/*
+	 * Remove the IRQ disable since in some cases scheduling is needed
+	 * to set an operating point (only sleep mode).  The spinlock
+	 * should suffice.  If the machine-dependent code needs interrupts
+	 * turned off during the code used for that platform for that 
+	 * operating point set sequence then IRQs will need to be disabled
+	 * in that code instead.
+	 */
+	error = dpm_md.set_opt(dpm_active_opt, new);
+
+	if (error == 0) {
+		dpm_update_stats(&new->stats, &dpm_active_opt->stats);
+		dpm_active_opt = new;
+		mb();
+	}
+
+	if (flags & DPM_UNLOCK)
+		dpm_unlock();
+
+	return error;
+}
+
+/*****************************************************************************
+ * Set operating point asynchronously.  The _dpm_lock will be cleared whenever
+ * the change in operating point is complete.
+ *****************************************************************************/
+
+int
+dpm_set_opt_async(void)
+{
+	struct dpm_opt *opt = dpm_next_opt();
+
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	if (opt) {
+		dpm_trace(DPM_TRACE_SET_OPT_ASYNC, opt);
+		return dpm_set_opt(opt, DPM_UNLOCK);
+	} else {
+		dpm_trace(DPM_TRACE_SET_OPT_ASYNC, NULL);
+		dpm_unlock();
+		return 0;
+	}
+}
+
+/*****************************************************************************
+ * Set operating point synchronously.  The caller must clear _dpm_lock after the
+ * call returns.
+ *****************************************************************************/
+
+int
+dpm_set_opt_sync(void)
+{
+	struct dpm_opt *opt = dpm_next_opt();
+
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	if (opt) {
+		dpm_trace(DPM_TRACE_SET_OPT_SYNC, opt);
+		return dpm_set_opt(opt, DPM_SYNC);
+	} else
+		dpm_trace(DPM_TRACE_SET_OPT_SYNC, NULL);
+	return 0;
+}
+
+/*****************************************************************************
+ * Resynchronize the operating state and the operating point without
+ * blocking. If we don't get the lock it doesn't matter, since whenever the
+ * lock holder releases the lock the resynchronization will be tried again.
+ *****************************************************************************/
+
+static inline void
+dpm_resync(void)
+{
+	dpm_trace(DPM_TRACE_RESYNC);
+	if (! dpm_trylock())
+		dpm_set_opt_async();
+}
+
+void
+dpm_resync_task(unsigned long ignore)
+{
+	dpm_resync();
+}
+
+/*****************************************************************************
+ * unlock the DPM
+ *
+ * If the operating point and operating state are not in sync when _dpm_lock is
+ * released, a tasklet is launched to resynchronize them. A tasklet is used
+ * rather than simply calling dpm_set_op directly to avoid deep recursions.
+ * (I'm not sure this has worked, though).
+ *
+ * (The locking functions are inline in dpm_policy.h)
+ *
+ * This is not static since it needs to be called from dpm_policy.c
+ *****************************************************************************/
+
+DECLARE_TASKLET(dpm_resync_tasklet, dpm_resync_task, 0);
+
+void
+dpm_unlock(void)
+{
+	int retry;
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	retry = dpm_next_opt() != NULL;
+	dpm_trace(DPM_TRACE_UNLOCK, retry);
+	up(&_dpm_lock);
+	if (retry)
+		tasklet_schedule(&dpm_resync_tasklet);
+}
+
+/*****************************************************************************
+ * Enter a new operating state for statistical purposes.  Returns 1 if the new
+ * state may require a change in operating point and 0 otherwise.
+ * 
+ * The normal case that occurs during task scheduling, where we go from task
+ * state to task state, is quickly ignored, as are changes to the
+ * DPM_NO_STATE and changes when DPM is not running.  Otherwise,
+ * dpm_enter_state() has advertised that we are in a new state, and indicates
+ * whether an operating point change is required.
+ * 
+ * Note the system invariant that the operating point always eventually
+ * catches up with changes to the operating state.  This is what makes it
+ * correct here to check for common operating points.  We know
+ * that if a common operating point is not the current operating point, it
+ * will be soon.
+ *
+ * The 'quick' variant (in dpm.h) is called out separately to reduce latency
+ * for critical operating state changes where the following are known: 1) The
+ * dpm_policy_lock is held and/or interrupts are properly disabled.  2) DPM is
+ * enabled.  3) The new state is neither DPM_NO_STATE nor the same as the
+ * active state.  4) Any operating point change is being handled elsewhere.
+ *****************************************************************************/
+
+static int
+dpm_enter_state(int new_state)
+{
+	int ret = 0;
+
+	if (! spin_trylock(&dpm_policy_lock)) {
+		dpm_quick_enter_state(new_state);
+		return 0;
+	}
+
+        if ((new_state == dpm_active_state) || 
+            (new_state == DPM_NO_STATE) ||
+            !dpm_enabled) {
+		spin_unlock(&dpm_policy_lock);
+		return ret;
+        }
+
+        if ((dpm_active_policy->classopt[new_state].class !=
+             dpm_active_policy->classopt[dpm_active_state].class) ||
+            (dpm_active_policy->classopt[new_state].opt !=
+             dpm_active_policy->classopt[dpm_active_state].opt))
+                ret = 1;
+
+	dpm_quick_enter_state(new_state);
+        spin_unlock(&dpm_policy_lock);
+        return ret;
+}
+
+
+/*****************************************************************************
+ * set operating state
+ *
+ * This is used by the kernel to inform the DPM that the operating state has
+ * changed and that a new operating point should (possibly) be set as a
+ * result.
+ *
+ * If an operating point change is required it is attempted. If we can't get
+ * the lock here, then the operating point change will be activated when the
+ * current lock holder releases the lock.
+ *****************************************************************************/
+
+void
+dpm_set_os(dpm_state_t new_state)
+{
+	dpm_trace(DPM_TRACE_SET_OS, new_state);
+	if (dpm_enter_state(new_state))
+		dpm_resync();
+}
+
+EXPORT_SYMBOL(dpm_set_os);
+
+/*****************************************************************************
+ * initialize the DPM
+ *****************************************************************************/
+int
+dynamicpower_init(void)
+{
+	trace("in dynamicpower_init\n");
+
+	if (dpm_initialized) {
+		trace("DPM already initialized");
+		return -EALREADY;
+	}
+
+	/* mutex-style semaphore for access to policies and opts */
+	init_MUTEX(&_dpm_lock);
+
+	dpm_active_policy = 0;	/* this leaves the DPM temporarily
+				   disabled until a policy is
+				   activated */
+	dpm_enabled = 0;
+	dpm_initialized = 1;
+	dpm_active_state = DPM_TASK_STATE;
+
+
+	trace("DPM is now initialized\n");
+
+	return 0;
+}
+
+/*****************************************************************************
+ * (temporarily) disable the DPM
+ *****************************************************************************/
+int
+dynamicpower_disable(void)
+{
+	trace("in dynamicpower_disable\n");
+
+	if (! dpm_enabled) {
+		trace("DPM already disabled");
+		return -EALREADY;
+	}
+
+	dpm_lock();
+
+	dpm_enabled = 0;
+	dpm_md_cleanup();
+	dpm_active_opt = NULL;
+	dpm_active_class = NULL;
+
+	dpm_unlock();
+
+	trace("DPM is now disabled\n");
+
+	return 0;
+}
+
+/*****************************************************************************
+ * re-enable the DPM
+ * dpm_enabled = 1 implies that DPM is initialized and there is an active
+ * policy. The 'enable' call is really designed to be used after a temporary
+ * 'disable'.  All that's required to start DPM is to initialize it and set a
+ * policy. 
+ *****************************************************************************/
+
+/* Need to think through enable/disable */
+
+int
+dynamicpower_enable(void)
+{
+	trace("in dynamicpower_enable\n");
+
+	if (dpm_enabled) {
+		trace("DPM already enabled");
+		return -EALREADY;
+	}
+
+	dpm_lock();
+
+	if (dpm_active_policy) {
+		dpm_enabled = 1;
+		mb();
+		dpm_md_startup();
+		dpm_stats_reset();
+		dpm_set_opt_sync();
+		trace("DPM is now enabled\n");
+	} else {
+		trace("No active policy, dpm_enable is ignored\n");
+	}
+
+	dpm_unlock();
+	return 0;
+}
+
+/*****************************************************************************
+ * Suspend/Resume DPM 
+ * The current operating point is saved and restored. This
+ * interface is designed to be used by system suspend/resume code, to safely
+ * save/restore the DPM operating point across a system power-down, where the
+ * firmware may resume the system at a random operating point.  This does not
+ * require DPM to be enabled. Note that DPM remains locked across the
+ * suspend/resume.
+ *****************************************************************************/
+
+static struct dpm_opt suspend_opt = { name : "[Suspended Op. Point]" };
+struct dpm_opt *suspended_opt;
+
+int
+dynamicpm_suspend(void)
+{
+	int err;
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	trace("in dpm_suspend\n");
+
+	dpm_lock();
+
+	if (dpm_enabled && dpm_active_opt) {
+		suspended_opt = dpm_active_opt;
+	} else {
+		suspended_opt = &suspend_opt;
+		if ((err = dpm_md_get_opt(suspended_opt))) {
+			printk(KERN_CRIT 
+			       "DPM can not suspend the current op. point!\n");
+			suspended_opt = NULL;
+			return err;
+		}
+	}
+	return 0;
+}
+
+void
+dynamicpm_resume(void)
+{
+	trace("in dpm_resume\n");
+
+	if (suspended_opt) {
+		dpm_active_opt = NULL;	/* Force reinitialization of DPM */
+		dpm_active_class = NULL;
+		dpm_set_opt(suspended_opt, DPM_SYNC);
+		suspended_opt = NULL;
+	}
+	dpm_unlock();
+}
+
+
+/*****************************************************************************
+ * Create a named operating point
+ * The alternate entry point can be used to create anonymous operating points
+ *****************************************************************************/
+
+int
+_dpm_create_opt(struct dpm_opt **p, const char *name, 
+		const dpm_md_pp_t * md_pp, int npp)
+{
+	struct dpm_opt *opt;
+	int ret;
+
+	/* get memory for opt */
+	if (!
+	    (opt =
+	     (struct dpm_opt *) kmalloc(sizeof (struct dpm_opt), GFP_KERNEL))) {
+		return -ENOMEM;
+	}
+	trace("%s @ 0x%08lx\n", name, (unsigned long)opt);
+	memset(opt, 0, sizeof(struct dpm_opt));
+	if (!(opt->name = (char *) kmalloc(strlen(name) + 1, GFP_KERNEL))) {
+		kfree(opt);
+		return -ENOMEM;
+	}
+
+	/* initialize and validate the opt */
+	strcpy(opt->name, name);
+	memcpy(&opt->pp, md_pp, npp * sizeof(dpm_md_pp_t));
+	ret = dpm_md_init_opt(opt);
+	if (ret) {
+		kfree(opt->name);
+		kfree(opt);
+		return ret;
+	}
+	INIT_LIST_HEAD(&opt->list);
+	*p = opt;
+	dpm_sysfs_new_op(opt);
+	return 0;
+}
+
+int
+dpm_create_opt(const char *name, const dpm_md_pp_t * md_pp, int npp)
+{
+	int ret;
+	struct dpm_opt *opt;
+
+	trace("in dpm_create_opt for \"%s\"\n", name);
+
+	dpm_lock();
+
+	/* ensure name is unique */
+	list_find(opt, name, dpm_opts, struct dpm_opt);
+	if (opt) {
+		dpm_unlock();
+		return -EEXIST;
+	}
+
+	/* create the opt */
+	ret = _dpm_create_opt(&opt, name, md_pp, npp);
+
+	/* add opt to our list */
+	if (!ret)
+		list_add(&opt->list, &dpm_opts);
+
+	dpm_unlock();
+	return ret;
+}
+
+/*****************************************************************************
+ * destroy an operating point
+ * Assumes _dpm_lock is held and the opt is no longer needed *anywhere*
+ *****************************************************************************/
+void
+destroy_opt(struct dpm_opt *opt)
+{
+	dpm_sysfs_destroy_op(opt);
+	list_del(&opt->list);
+	kfree(opt->name);
+	kfree(opt);
+}
+
+/*****************************************************************************
+ * create a named class of operating points (to be used to map to an operating
+ * state)
+ *****************************************************************************/
+
+int
+dpm_create_class(const char *name, char **op_names, unsigned nops)
+{
+	int i;
+	struct dpm_class *cls;
+
+	trace("in dpm_create_class for \"%s\"\n", name);
+
+	dpm_lock();
+
+	/* ensure class is not empty */
+	if (nops == 0) {
+		dpm_unlock();
+		return -EINVAL;
+	}
+
+	/* ensure name is unique */
+	list_find(cls, name, dpm_classes, struct dpm_class);
+	if (cls) {
+		dpm_unlock();
+		return -EEXIST;
+	}
+
+	/* get memory for class */
+	cls = (struct dpm_class *) kmalloc(sizeof (struct dpm_class), GFP_KERNEL);
+	if (!cls) {
+		dpm_unlock();
+		return -ENOMEM;
+	}
+	trace("%s @ 0x%08lx\n", name, (unsigned long)cls);
+	memset(cls, 0, sizeof (struct dpm_class));
+	/* get memory for array of pointers to operating points */
+	cls->ops =
+	    (struct dpm_opt **) kmalloc(nops * sizeof (struct dpm_opt *),
+					GFP_KERNEL);
+	if (!cls->ops) {
+		kfree(cls);
+		dpm_unlock();
+		return -ENOMEM;
+	}
+
+	/* get memory for class name */
+	cls->name = (char *) kmalloc(strlen(name) + 1, GFP_KERNEL);
+	if (!cls->name) {
+		kfree(cls->ops);
+		kfree(cls);
+		dpm_unlock();
+		return -ENOMEM;
+	}
+
+	/* find named op points and put their pointers in the class */
+	for (i = 0; i < nops; ++i) {
+		struct dpm_opt *opt;
+		list_find(opt, op_names[i], dpm_opts, struct dpm_opt);
+		if (!opt) {
+			kfree(cls->name);
+			kfree(cls->ops);
+			kfree(cls);
+			dpm_unlock();
+			return -ENOENT;
+		}
+		cls->ops[i] = opt;
+	}
+	strcpy(cls->name, name);
+	cls->nops = nops;
+	/* add class to our list */
+	list_add(&cls->list, &dpm_classes);
+
+	dpm_unlock();
+	dpm_sysfs_new_class(cls);
+
+	return 0;
+}
+
+/*****************************************************************************
+ * destroy a class
+ * Assumes _dpm_lock is held and the class is no longer needed *anywhere*
+ *****************************************************************************/
+void
+destroy_class(struct dpm_class *cls)
+{
+	dpm_sysfs_destroy_class(cls);
+	list_del(&cls->list);
+	kfree(cls->ops);
+	kfree(cls->name);
+	kfree(cls);
+}
+
+int
+dpm_map_policy_state(struct dpm_policy *policy, int state, char *classopt)
+{
+	list_find(policy->classopt[state].opt, classopt, dpm_opts,
+		  struct dpm_opt);
+
+	if(!policy->classopt[state].opt) {
+		list_find(policy->classopt[state].class, classopt,
+			  dpm_classes, struct dpm_class);
+		if(!policy->classopt[state].class)
+			return -1;
+	}
+
+	return 0;
+}
+
+/*****************************************************************************
+ * create power policy
+ *****************************************************************************/
+int
+dpm_create_policy(const char *name, char **classopt_names, int nopts)
+{
+	int i;
+	struct dpm_policy *policy;
+
+	trace("in dpm_install_policy for \"%s\" policy\n", name);
+
+	dpm_lock();
+
+	/* ensure unique name */
+	list_find(policy, name, dpm_policies, struct dpm_policy);
+	if (policy) {
+		dpm_unlock();
+		return -EEXIST;
+	}
+
+	/* get memory for policy */
+	policy =
+	    (struct dpm_policy *) kmalloc(sizeof (struct dpm_policy),
+					  GFP_KERNEL);
+	if (!policy) {
+		dpm_unlock();
+		return -ENOMEM;
+	}
+	trace("%s @ 0x%08lx\n", name, (unsigned long)policy);
+	memset(policy, 0, sizeof (struct dpm_policy));
+	/* get memory for policy name */
+	policy->name = (char *) kmalloc(strlen(name) + 1, GFP_KERNEL);
+	if (!policy->name) {
+		kfree(policy);
+		dpm_unlock();
+		return -ENOMEM;
+	}
+
+	/* initialize the policy */
+	for (i = 0; i < DPM_STATES; ++i) {
+		if ((i >= nopts) || !classopt_names[i]) {
+			policy->classopt[i].opt	= &nop_op;
+		} else {
+			if (dpm_map_policy_state(policy, i, classopt_names[i])
+			    < 0) {
+				kfree(policy->name);
+				kfree(policy);
+				dpm_unlock();
+				return -ENOENT;
+			}
+		}
+	}
+	strcpy(policy->name, name);
+
+	/* add policy to our list */
+	list_add(&policy->list, &dpm_policies);
+	dpm_sysfs_new_policy(policy);
+	trace("installed \"%s\" policy\n", name);
+	dpm_unlock();
+	return 0;
+}
+
+/*****************************************************************************
+ * destroy a power policy
+ * Assumes _dpm_lock is held and the policy is no longer needed *anywhere*
+ *****************************************************************************/
+void
+destroy_policy(struct dpm_policy *policy)
+{
+	dpm_sysfs_destroy_policy(policy);
+	list_del(&policy->list);
+	kfree(policy->name);
+	kfree(policy);
+}
+
+/*****************************************************************************
+ * uninstall power policy
+ *****************************************************************************/
+int
+dpm_destroy_policy(const char *name)
+{
+	struct dpm_policy *policy;
+
+	trace("processing destroy request for \"%s\"\n", name);
+
+	dpm_lock();
+
+	/* find the named policy */
+	list_find(policy, name, dpm_policies, struct dpm_policy);
+	if (!policy) {
+		dpm_unlock();
+		return -ENOENT;
+	}
+
+	/* can't uninstall active policy */
+	if (policy == dpm_active_policy) {
+		dpm_unlock();
+		return -EBUSY;
+	}
+
+	/* remove the policy */
+	destroy_policy(policy);
+
+	dpm_unlock();
+	trace("destroyed \"%s\" policy\n", name);
+	return 0;
+}
+
+/*
+ * set active power policy
+ */
+int
+dpm_set_policy(const char *name)
+{
+	struct dpm_policy *new_p;
+
+	trace("in dpm_set_policy for \"%s\" policy\n", name);
+
+	dpm_lock();
+
+	list_find(new_p, name, dpm_policies, struct dpm_policy);
+	if (!new_p) {
+		dpm_trace(DPM_TRACE_SET_POLICY, name, -ENOENT);
+		dpm_unlock();
+		return -ENOENT;	/* invalid name */
+	}
+	if (new_p == dpm_active_policy) {
+		dpm_trace(DPM_TRACE_SET_POLICY, name, 0);
+		trace("\"%s\" policy already activated\n", name);
+		dpm_unlock();
+		return 0;
+	}
+
+	dpm_update_stats(&new_p->stats, 
+			 dpm_active_policy ? &dpm_active_policy->stats
+			 : NULL);
+
+	dpm_active_policy = new_p;
+
+	if (! dpm_enabled) {
+		dpm_enabled = 1;
+		dpm_md_startup();
+		dpm_stats_reset();
+	}
+
+	/* Start the policy synchronously */
+
+	mb();
+	dpm_trace(DPM_TRACE_SET_POLICY, name, 0);
+	dpm_set_opt_sync();
+	dpm_unlock();
+
+	return 0;
+}
+
+/*****************************************************************************
+ * set a raw op state
+ *****************************************************************************/
+
+int
+dpm_set_op_state(const char *name)
+{
+	int op_state;
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	for (op_state = 0; op_state < DPM_STATES; op_state++)
+		if (strcmp(dpm_state_names[op_state], name) == 0) {
+			dpm_set_os(op_state);
+			return 0;
+		}
+
+	return -ENOENT;
+}
+
+/*****************************************************************************
+ * terminate the DPM
+ *****************************************************************************/
+int
+dynamicpower_terminate(void)
+{
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+	trace("in dynamicpower_terminate\n");
+
+	if (!dpm_initialized)
+		return 0;
+
+	dpm_lock();
+
+	dpm_md_cleanup();
+
+	dpm_initialized = 0;
+	dpm_enabled = 0;
+	dpm_active_opt = NULL;
+	dpm_active_class = NULL;
+
+	/* destroy all entities */
+	while (!list_empty(&dpm_policies))
+		destroy_policy(list_entry
+			       (dpm_policies.next, struct dpm_policy, list));
+	while (!list_empty(&dpm_opts))
+		destroy_opt(list_entry(dpm_opts.next, struct dpm_opt, list));
+	while (!list_empty(&dpm_classes))
+		destroy_class(list_entry(dpm_classes.next, struct dpm_class,
+					 list));
+
+
+	mb();
+	dpm_unlock();
+
+	trace("DPM is now terminated\n");
+	printk("Dynamic Power Management is now terminated\n");
+
+	return 0;
+}
+
+EXPORT_SYMBOL(dynamicpower_init);
+EXPORT_SYMBOL(dynamicpower_terminate);
+EXPORT_SYMBOL(dynamicpower_disable);
+EXPORT_SYMBOL(dynamicpower_enable);
+EXPORT_SYMBOL(dpm_create_opt);
+EXPORT_SYMBOL(dpm_create_class);
+EXPORT_SYMBOL(dpm_create_policy);
+EXPORT_SYMBOL(dpm_destroy_policy);
+EXPORT_SYMBOL(dpm_set_policy);
+
+/****************************************************************************
+ * install dynamic power policy support
+ ****************************************************************************/
+static int __init
+dpm_init_module(void)
+{
+	int i;
+
+	/* Set the NOP operating point params to all -1. */
+
+	for (i = 0; i < DPM_PP_NBR; i++)
+		nop_op.pp[i] = -1;
+
+	trace("DPM is now installed\n");
+	return 0;
+}
+
+/****************************************************************************
+ * remove dynamic power policy support
+ ****************************************************************************/
+static void __exit
+dpm_exit_module(void)
+{
+	/* disable power management policy system */
+	dynamicpower_terminate();
+
+	trace("DPM module is now unloaded\n");
+}
+
+module_init(dpm_init_module);
+module_exit(dpm_exit_module);
+
+/*
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
Index: linux-2.6.29/drivers/dpm/proc.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/dpm/proc.c	2010-04-07 13:00:43.000000000 -0400
@@ -0,0 +1,613 @@
+/*
+ * drivers/dpm/proc.c  Dynamic Power Management /proc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Copyright (C) 2002, International Business Machines Corporation
+ * All Rights Reserved
+ *
+ * Bishop Brock
+ * IBM Research, Austin Center for Low-Power Computing
+ * bcbrock@us.ibm.com
+ * September, 2002
+ *
+ */
+
+#include <linux/dpm.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/semaphore.h>
+#include <asm/system.h>
+#include <asm/uaccess.h>
+
+
+#include <bsp.h>
+
+
+#define DEBUG
+#ifdef DEBUG
+#define DPRINT(args...) printk(KERN_CRIT args)
+#else
+#define DPRINT(args...) do {} while (0)
+#endif
+
+#if 0
+#define dbg printk
+#else /* no debug */
+#define dbg(x...) do {} while(0)
+#endif
+
+/****************************************************************************
+ * /proc/driver/dpm interfaces
+ *
+ * NB: Some of these are borrowed from the 405LP, and may need to be made
+ * machine independent.
+ ****************************************************************************/
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ * /proc/driver/dpm/cmd (Write-Only)
+ *
+ * Writing a string to this file is equivalent to issuing a DPM command. 
+ * Currently only one command per "write" is allowed, and there is a maximum on
+ * the number of tokens that will be accepted (PAGE_SIZE / sizeof(char *)).
+ * DPM can be initialized by a linewise copy of a configuration file to this
+ * /proc file. 
+ *
+ * DPM Control
+ * -----------
+ *
+ * init          : dynamicpower_init()
+ * enable        : dynamicpower_enable()
+ * disable       : dynamicpower_disable()
+ * terminate     : dynamicpower_terminate()
+ * 
+ * Policy Control
+ * --------------
+ *
+ * set_policy <policy>          : Set the policy by name
+ * set_task_state <pid> <state> : Set the task state for a given pid, 0 = self
+ *
+ * Policy Creation
+ * ---------------
+ *
+ * create_opt <name> <pp0> ... <ppn>
+ *     Create a named operating point from DPM_PP_NBR paramaters.  All
+ *     parameters must be  given. Parameter order and meaning are machine
+ *     dependent. 
+ *
+ * create_class <name> <opt0> [ ... <optn> ]
+ *     Create a named class from 1 or more named operating points.  All
+ *     operating points must be defined before the call.
+ *
+ * create_policy <name> <classopt0> [ ... <classoptn> ]
+ *     Create a named policy from DPM_STATES classes or operating
+ *     points.  All operating points must be defined before the call.
+ *     The order is machine dependent.
+ *
+ *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+
+static void
+pwarn(char *command, int ntoks, char *requirement, int require)
+{
+	printk(KERN_WARNING "/proc/driver/dpm/cmd: "
+	       "Command %s requires %s%d arguments - %d were given\n",
+	       command, requirement, require - 1, ntoks - 1);
+}
+
+/*****************************************************************************
+ * set a task state
+ *****************************************************************************/
+
+static int
+dpm_set_task_state(pid_t pid, dpm_state_t task_state)
+{
+	struct task_struct *p;
+
+    dbg("(%s)%s:%d\n", __FILE__, __func__, __LINE__);
+
+	if (task_state == -(DPM_TASK_STATE_LIMIT + 1)) 
+		task_state = DPM_NO_STATE;
+	else if (abs(task_state) > DPM_TASK_STATE_LIMIT) {
+		dpm_trace(DPM_TRACE_SET_TASK_STATE, pid, task_state, -EINVAL);
+		return -EINVAL;
+	} else 
+		task_state += DPM_TASK_STATE;
+
+	read_lock(&tasklist_lock);
+
+	if (pid == 0)
+		p = current;
+	else
+		p = find_task_by_vpid(pid);
+
+	if (!p) {
+		read_unlock(&tasklist_lock);
+		dpm_trace(DPM_TRACE_SET_TASK_STATE, pid, task_state, -ENOENT);
+		return -ENOENT;
+	}
+
+	p->dpm_state = task_state;
+	read_unlock(&tasklist_lock);
+
+	dpm_trace(DPM_TRACE_SET_TASK_STATE, pid, task_state, 0);
+
+	if (pid == 0)
+		dpm_set_os(p->dpm_state);
+	
+
+	return 0;
+}
+
+
+static int 
+write_proc_dpm_cmd (struct file *file, const char *buffer,
+		    unsigned long count, void *data)
+{
+	char *buf, *tok, **tokptrs;
+	char *whitespace = " \t\r\n";
+	int ret = 0, ntoks;
+
+	if (current->uid != 0)
+		return -EACCES;
+	if (count == 0)
+		return 0;
+	if (!(buf = kmalloc(count + 1, GFP_KERNEL)))
+		return -ENOMEM;
+	if (copy_from_user(buf, buffer, count)) {
+		ret = -EFAULT;
+		goto out0;
+	}
+
+	buf[count] = '\0';
+
+	if (!(tokptrs = (char **)__get_free_page(GFP_KERNEL))) {
+		ret = -ENOMEM;
+		goto out1;
+	}
+
+	ret = -EINVAL;
+	ntoks = 0;
+	do {
+		buf = buf + strspn(buf, whitespace);
+		tok = strsep(&buf, whitespace);
+		if (*tok == '\0') {
+			if (ntoks == 0) {
+				ret = 0;
+				goto out1;
+			} else
+				break;
+		}
+		if (ntoks == (PAGE_SIZE / sizeof(char **)))
+			goto out1;
+		tokptrs[ntoks++] = tok;
+	} while(buf);
+
+	if (ntoks == 1) {
+		if (strcmp(tokptrs[0], "init") == 0) {
+			ret = dynamicpower_init();
+		} else if (strcmp(tokptrs[0], "enable") == 0) {
+			ret = dynamicpower_enable();
+		} else if (strcmp(tokptrs[0], "disable") == 0) {
+			ret = dynamicpower_disable();
+		} else if (strcmp(tokptrs[0], "terminate") == 0) {
+			ret = dynamicpower_terminate();
+		}
+	} else if (ntoks == 2) {
+		if (strcmp(tokptrs[0], "set_policy") == 0)
+			ret = dpm_set_policy(tokptrs[1]);
+		else if (strcmp(tokptrs[0], "set_state") == 0)
+			ret = dpm_set_op_state(tokptrs[1]);
+	} else {
+		if (strcmp(tokptrs[0], "set_task_state") == 0) {
+			if (ntoks != 3) 
+				pwarn("set_task_state", ntoks, "", 3);
+			else
+				ret = dpm_set_task_state(simple_strtol(tokptrs[1],
+								       NULL, 0),
+							 simple_strtol(tokptrs[2],
+								       NULL, 0));
+		} else if (strcmp(tokptrs[0], "create_opt") == 0) {
+			if (ntoks != DPM_PP_NBR + 2)
+				pwarn("create_opt", ntoks, 
+				      "", DPM_PP_NBR + 2);
+			else {
+				dpm_md_pp_t pp[DPM_PP_NBR];
+				int i;
+			
+				for (i = 0; i < DPM_PP_NBR; i++)
+					pp[i] = simple_strtol(tokptrs[i + 2],
+							      NULL, 0);
+				ret = dpm_create_opt(tokptrs[1], pp, DPM_PP_NBR);
+			}
+
+		} else if (strcmp(tokptrs[0], "create_class") == 0) {
+			if (ntoks < 3) 
+				pwarn("create_class", ntoks, ">= ", 3);
+			else 
+				ret = dpm_create_class(tokptrs[1], &tokptrs[2],
+						       ntoks - 2);
+
+		} else if (strcmp(tokptrs[0], "create_policy") == 0) {
+			if (ntoks != (DPM_STATES + 2)) 
+				pwarn("create_policy", ntoks, "", 
+				      DPM_STATES + 2);
+			else 
+				ret = dpm_create_policy(tokptrs[1],
+							&tokptrs[2], ntoks-2);
+		}
+	}
+out1:
+	free_page((unsigned long)tokptrs);
+out0:
+	kfree(buf);
+	if (ret == 0)
+		return count;
+	else 
+		return ret;
+}
+
+#ifdef CONFIG_DPM_STATS
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ * /proc/driver/dpm/stats (Read-Only)
+ *
+ * Reading this file produces the following line for each defined operating
+ * state:
+ * 
+ * state_name total_time count opt_name
+ * 
+ * Where:
+ *
+ * state_name = The operating state name.
+ * total_time = The 64-bit number of microseconds spent in this
+ *              operating state.
+ * count      = The 64-bit number of times this operating state was entered.
+ * opt_name   = The name of the operating point currently assigned to this
+ *              operating state.
+ *
+ *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+
+static int
+sprintf_u64(char *buf, int fill, char *s, u64 ul)
+{
+	int len = 0;
+	u32 u, l;
+	
+	u = (u32)((ul >> 32) & 0xffffffffU);
+	l = (u32)(ul & 0xffffffffU);
+
+	len += sprintf(buf + len, s);
+	if (fill)
+		len += sprintf(buf + len, "0x%08x%08x", u, l);
+	else {
+		if (u)
+			len += sprintf(buf + len, "0x%x%x", u, l);
+		else
+			len += sprintf(buf + len, "0x%x", l);
+	}
+	return len;
+}
+
+/*****************************************************************************
+ * get statistics for all operating states
+ *****************************************************************************/
+
+int
+dpm_get_os_stats(struct dpm_stats *stats)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&dpm_policy_lock, flags);
+	memcpy(stats, dpm_state_stats, DPM_STATES * sizeof (struct dpm_stats));
+	stats[dpm_active_state].total_time +=
+		dpm_time() - stats[dpm_active_state].start_time;
+	spin_unlock_irqrestore(&dpm_policy_lock, flags);
+	return 0;
+}
+
+static int
+read_proc_dpm_stats(char *page, char **start, off_t offset, 
+		    int count, int *eof, void *data)
+{
+	int i, len = 0;
+	struct dpm_stats stats[DPM_STATES];
+
+	if (!dpm_enabled) {
+		len += sprintf(page + len, "DPM IS DISABLED\n");
+		*eof = 1;
+		return len;
+	}
+
+	dpm_get_os_stats(stats);
+
+	for (i = 0; i < DPM_STATES; i++) {
+		len += sprintf(page + len, "%20s", dpm_state_names[i]);
+                len += sprintf_u64(page + len, 1, " ", 
+				   (u64)stats[i].total_time);
+		len += sprintf_u64(page + len, 1, " ", (u64)stats[i].count);
+		len += sprintf(page + len, " %s\n", 
+			       dpm_classopt_name(dpm_active_policy,i));
+	}
+
+	*eof = 1;
+	return len;
+}
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ * /proc/driver/dpm/opt_stats (Read-Only)
+ *
+ * Reading this file produces the following line for each defined operating
+ * point:
+ * 
+ * name total_time count
+ * 
+ * Where:
+ *
+ * name       = The operating point name.
+ * total_time = The 64-bit number of microseconds spent in this
+ *              operating state.
+ * count      = The 64-bit number of times this operating point was entered.
+ *
+ *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+
+static int
+read_proc_dpm_opt_stats(char *page, char **start, off_t offset, 
+			int count, int *eof, void *data)
+{
+	int len = 0;
+	struct dpm_opt *opt;
+	struct list_head *p;
+	unsigned long long total_time;
+
+	if (dpm_lock_interruptible())
+		return -ERESTARTSYS;
+
+	if (!dpm_enabled) {
+		dpm_unlock();
+		len += sprintf(page + len, "DPM IS DISABLED\n");
+		*eof = 1;
+		return len;
+	}
+
+	for (p = dpm_opts.next; p != &dpm_opts; p = p->next) {
+		opt = list_entry(p, struct dpm_opt, list);
+		len += sprintf(page + len, "%s", opt->name);
+		total_time = opt->stats.total_time;
+		if (opt == dpm_active_opt)
+			total_time += dpm_time() - opt->stats.start_time;
+		len += sprintf_u64(page + len, 0, " ", opt->stats.total_time);
+		len += sprintf_u64(page + len, 0, " ", opt->stats.count);
+		len += sprintf(page + len, "\n");
+	}
+
+	dpm_unlock();
+	*eof = 1;
+	return len;
+}
+#endif /* CONFIG_DPM_STATS */
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ * /proc/driver/dpm/state (Read-Only)
+ *
+ * Reading this file produces the following:
+ * 
+ * policy_name os os_name os_opt_name opt_name hz
+ * 
+ * Where:
+ *
+ * policy_name = The name of the current policy
+ * os          = The curret operating state index
+ * os_name     = The current operating state name
+ * os_opt_name = The name of the implied operating point for the policy and
+ *               state.
+ * opt_name    = The name of the actual operating point; may be different if
+ *               the operating state and operating point are out of sync.
+ * hz          = The frequency of the statistics timer
+ *
+ * If DPM is disabled the line will appear as:
+ *
+ * N/A -1 N/A N/A N/A <hz>
+ *
+ *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+
+static int
+read_proc_dpm_state(char *page, char **start, off_t offset, 
+		    int count, int *eof, void *data)
+{
+	unsigned long flags;
+
+	int len = 0;
+
+	if (dpm_lock_interruptible())
+		return -ERESTARTSYS;
+
+	if (!dpm_enabled) {
+		len += sprintf(page + len, "N/A -1 N/A N/A N/A N/A\n");
+	} else {
+
+		spin_lock_irqsave(&dpm_policy_lock, flags);
+		len += sprintf(page + len,"%s %d %s %s %s\n",
+			       dpm_active_policy->name, 
+			       dpm_active_state,
+			       dpm_state_names[dpm_active_state],
+			       dpm_classopt_name(dpm_active_policy,
+						 dpm_active_state),
+			       dpm_active_opt ? dpm_active_opt->name : "none");
+		spin_unlock_irqrestore(&dpm_policy_lock, flags);
+	}
+
+	dpm_unlock();
+	*eof = 1;
+	return len;
+}
+
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ * /proc/driver/dpm/debug (Read-Only)
+ *
+ * Whatever it needs to be
+ *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+
+#ifdef DEBUG
+static int
+read_proc_dpm_debug(char *page, char **start, off_t offset, 
+		    int count, int *eof, void *data)
+{
+	int len = 0;
+
+	len += sprintf(page + len, "No DEBUG info\n");
+	*eof = 1;
+	return len;
+}
+#endif /* DEBUG */
+
+static struct proc_dir_entry *proc_dpm;
+static struct proc_dir_entry *proc_dpm_cmd;
+static struct proc_dir_entry *proc_dpm_state;
+
+#ifdef CONFIG_DPM_STATS
+static struct proc_dir_entry *proc_dpm_stats;
+static struct proc_dir_entry *proc_dpm_opt_stats;
+#endif
+
+#ifdef DEBUG
+static struct proc_dir_entry *proc_dpm_debug;
+#endif
+
+#ifdef CONFIG_DPM_TRACE
+static struct proc_dir_entry *proc_dpm_trace;
+#endif
+
+static int __init
+dpm_proc_init(void)
+{
+	proc_dpm = proc_mkdir("driver/dpm", NULL);
+
+	if (proc_dpm) {
+
+		proc_dpm_cmd =
+			create_proc_entry("cmd",
+					  S_IWUSR,
+					  proc_dpm);
+		if (proc_dpm_cmd)
+			proc_dpm_cmd->write_proc = write_proc_dpm_cmd;
+
+		proc_dpm_state =
+			create_proc_read_entry("state",
+					       S_IRUGO,
+					       proc_dpm,
+					       read_proc_dpm_state, 
+					       NULL); 
+#ifdef CONFIG_DPM_STATS
+		proc_dpm_stats =
+			create_proc_read_entry("stats",
+					       S_IRUGO,
+					       proc_dpm,
+					       read_proc_dpm_stats, 
+					       NULL); 
+		proc_dpm_opt_stats =
+			create_proc_read_entry("opt_stats",
+					       S_IRUGO,
+					       proc_dpm,
+					       read_proc_dpm_opt_stats, 
+					       NULL); 
+
+#endif /* CONFIG_DPM_STATS */
+
+#ifdef DEBUG
+		proc_dpm_debug =
+			create_proc_read_entry("debug",
+					       S_IRUGO,
+					       proc_dpm,
+					       read_proc_dpm_debug, 
+					       NULL); 
+#endif
+
+#ifdef CONFIG_DPM_TRACE
+		proc_dpm_trace =
+			create_proc_read_entry("trace",
+					       S_IWUSR | S_IRUGO,
+					       proc_dpm,
+					       read_proc_dpm_trace, 
+					       NULL); 
+		if (proc_dpm_trace)
+			proc_dpm_trace->write_proc = write_proc_dpm_trace;
+#endif
+	} else {
+	  printk(KERN_ERR "Attempt to create /proc/driver/dpm failed\n");
+
+	}
+	return 0;
+}
+
+static void __exit
+dpm_proc_exit(void)
+{
+	if (proc_dpm_cmd) {
+		remove_proc_entry("cmd", proc_dpm);
+		proc_dpm_cmd = NULL;
+	}
+
+	if (proc_dpm_state) {
+		remove_proc_entry("state", proc_dpm);
+		proc_dpm_state = NULL;
+	}
+
+#ifdef CONFIG_DPM_STATS
+	if (proc_dpm_stats) {
+		remove_proc_entry("stats", proc_dpm);
+		proc_dpm_stats = NULL;
+	}
+
+	if (proc_dpm_opt_stats) {
+		remove_proc_entry("opt_stats", proc_dpm);
+		proc_dpm_opt_stats = NULL;
+	}
+#endif /* CONFIG_DPM_STATS */
+
+#ifdef DEBUG
+	if (proc_dpm_debug) {
+		remove_proc_entry("debug", proc_dpm);
+		proc_dpm_debug = NULL;
+	}
+#endif
+
+#ifdef CONFIG_DPM_TRACE
+	if (proc_dpm_trace) {
+		remove_proc_entry("trace", proc_dpm);
+		proc_dpm_trace = NULL;
+	}
+#endif
+
+	remove_proc_entry("driver/dpm", NULL);
+}
+
+
+
+module_init(dpm_proc_init);
+module_exit(dpm_proc_exit);
+
+/*
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
+
Index: linux-2.6.29/drivers/i2c/busses/Kconfig
===================================================================
--- linux-2.6.29.orig/drivers/i2c/busses/Kconfig	2010-04-07 12:29:33.000000000 -0400
+++ linux-2.6.29/drivers/i2c/busses/Kconfig	2010-04-07 12:29:36.000000000 -0400
@@ -503,6 +503,15 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-versatile.
 
+config I2C_TCC
+	bool "Telechips I2C block bus driver"
+	depends on ARCH_TCC
+	default y
+	help
+	  If you say yes to this option, support will be included for the
+	  I2C interface on the Telechips System-on-Chip.
+	  Like TCC8900.
+
 comment "External I2C/SMBus adapter drivers"
 
 config I2C_PARPORT
Index: linux-2.6.29/drivers/i2c/busses/Makefile
===================================================================
--- linux-2.6.29.orig/drivers/i2c/busses/Makefile	2010-04-07 12:29:33.000000000 -0400
+++ linux-2.6.29/drivers/i2c/busses/Makefile	2010-04-07 12:29:36.000000000 -0400
@@ -48,6 +48,11 @@
 obj-$(CONFIG_I2C_SIMTEC)	+= i2c-simtec.o
 obj-$(CONFIG_I2C_VERSATILE)	+= i2c-versatile.o
 
+ifeq ($(CONFIG_ARCH_TCC),y)
+$(shell ln -fsn $(CONFIG_TCC_STRING)/ $(srctree)/drivers/i2c/busses/tcc)
+endif
+obj-$(CONFIG_I2C_TCC)		+= i2c-tcc.o tcc/tca_i2c.o
+
 # External I2C/SMBus adapter drivers
 obj-$(CONFIG_I2C_PARPORT)	+= i2c-parport.o
 obj-$(CONFIG_I2C_PARPORT_LIGHT)	+= i2c-parport-light.o
Index: linux-2.6.29/drivers/i2c/busses/i2c-tcc.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/i2c/busses/i2c-tcc.c	2010-04-07 13:01:42.000000000 -0400
@@ -0,0 +1,475 @@
+/* 
+ * linux/drivers/i2c/busses/i2c-tcc.c
+ *
+ * Author:  <linux@telechips.com>
+ * Created: 10th Jun, 2008 
+ * Description: Telechips I2C Controller
+ *
+ * Copyright (c) Telechips, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * ----------------------------
+ * for TCC DIBCOM DVB-T module 
+ * [M] i2c-core.c, i2c-dev.c
+ * [M] include/linux/i2c-dev.h, include/linux/i2c.h
+ *
+*/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/i2c-id.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/completion.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+
+#include <asm/io.h>
+
+#include <bsp.h>
+#include "tcc/tca_i2c.h"
+
+
+enum tcc_i2c_state {
+	STATE_IDLE,
+	STATE_START,
+	STATE_READ,
+	STATE_WRITE,
+	STATE_STOP
+};
+
+struct tcc_i2c {
+	spinlock_t lock;
+	wait_queue_head_t wait;
+	volatile struct tcc_i2c_regs *regs;
+    volatile unsigned long IRQSTR;
+	int ch;
+	unsigned int clk;
+
+	struct i2c_msg *msg;
+	unsigned int msg_num;
+	unsigned int msg_idx;
+	unsigned int msg_ptr;
+
+	enum tcc_i2c_state state;
+
+	struct device *dev;
+	struct i2c_adapter adap;
+};
+
+/* tcc_i2c_message_start
+ *
+ * put the start of a message onto the bus 
+*/
+static void tcc_i2c_message_start(struct tcc_i2c *i2c, struct i2c_msg *msg)
+{
+	unsigned int addr = (msg->addr & 0x7f) << 1;
+
+	if (msg->flags & I2C_M_RD)
+		addr |= 1;
+	if (msg->flags & I2C_M_REV_DIR_ADDR)
+		addr ^= 1;
+
+	i2c->regs->TXR = addr;
+	i2c->regs->CMD = Hw7 | Hw4;
+}
+
+static int wait_intr(struct tcc_i2c *i2c)
+{
+	unsigned long cnt = 0;
+
+	if (i2c->ch == 0 || i2c->ch == 1) {
+	while (!(tcc_readl(i2c->IRQSTR) & (i2c->ch?Hw1:Hw0))) {
+		cnt++;
+		if (cnt > 100000) {
+			printk("i2c-tcc: time out!\n");
+			return -1;
+		}
+	}
+	} else {
+		/* SMU_I2C wait */
+	while (1) {
+			cnt = i2c->regs->SR;
+			if (!(cnt & Hw1)) break;
+		}
+		for (cnt = 0; cnt <15; cnt++);
+		}
+
+	return 0;
+}
+
+static int recv_i2c(struct tcc_i2c *i2c)
+{
+	int ret, i;
+	dev_dbg(&i2c->adap.dev, "READ [%x][%d]\n", i2c->msg->addr, i2c->msg->len);		
+
+	tcc_i2c_message_start(i2c, i2c->msg);
+
+	ret = wait_intr(i2c);
+	if (ret != 0)
+		return ret;
+	BITSET(i2c->regs->CMD, Hw0);	/* Clear a pending interrupt */
+
+	for (i = 0; i < i2c->msg->len; i++) {
+		if (i2c->msg->flags & I2C_M_DIBCOM_MODE) {	/* if DIBCOM */
+			if (i == (i2c->msg->len - 1)) 
+				i2c->regs->CMD = Hw5 | Hw3;
+			else
+				i2c->regs->CMD = Hw5;
+		} else {
+			i2c->regs->CMD = Hw5 | Hw3;
+		}
+
+		ret = wait_intr(i2c);
+		if (ret != 0)
+			return ret;
+		BITSET(i2c->regs->CMD, Hw0);
+
+		i2c->msg->buf[i] = (unsigned char) i2c->regs->RXR;
+	}
+
+	i2c->regs->CMD = Hw6;
+
+	ret = wait_intr(i2c);
+	if (ret != 0)
+		return ret;
+	BITSET(i2c->regs->CMD, Hw0);
+
+	return 1;
+}
+
+static int send_i2c(struct tcc_i2c *i2c)
+{
+	int ret, i, no_stop = 0;
+	dev_dbg(&i2c->adap.dev, "SEND [%x][%d]", i2c->msg->addr, i2c->msg->len);		
+
+	tcc_i2c_message_start(i2c, i2c->msg);
+
+	ret = wait_intr(i2c);
+	if (ret != 0)
+		return ret;
+	BITSET(i2c->regs->CMD, Hw0);	/* Clear a pending interrupt */
+
+	for (i = 0; i < i2c->msg->len; i++) {
+		i2c->regs->TXR = i2c->msg->buf[i];
+		i2c->regs->CMD = Hw4;
+		ret = wait_intr(i2c);
+		if (ret != 0)
+			return ret;
+		BITSET(i2c->regs->CMD, Hw0);
+
+		//i2c->msg->buf[i] = (unsigned char) i2c->regs->RXR;	//XXX
+	}
+
+	/*
+	 *	Check no-stop operation condition (write -> read operation)
+	 *	1. DIBCOM 
+	 *  2. msg_num == 2
+	 */
+	if (i2c->msg->flags & I2C_M_DIBCOM_WR_RD)
+		no_stop = 1;
+	if (i2c->msg_num == 2)
+		no_stop = 1;
+	
+	//if ( (!(i2c->msg->flags & I2C_M_DIBCOM_WR_RD)) || (i2c->msg_num == 1) ) {
+	if (no_stop == 0) {
+		i2c->regs->CMD = Hw6;
+		ret = wait_intr(i2c);
+		if (ret != 0)
+			return ret;
+	}
+	BITSET(i2c->regs->CMD, Hw0);	/* Clear a pending interrupt */
+
+	return 1;
+}
+
+/* tcc_i2c_doxfer
+ *
+ * this starts an i2c transfer
+*/
+static int tcc_i2c_doxfer(struct tcc_i2c *i2c, struct i2c_msg *msgs, int num)
+{
+	int ret;
+
+#if 0
+	spin_lock_irq(&i2c->lock);
+	i2c->msg     = msgs;
+	i2c->msg_num = num;
+	i2c->msg_ptr = 0;
+	i2c->msg_idx = 0;
+	i2c->state   = STATE_START;
+	spin_unlock_irq(&i2c->lock);
+
+	if (msgs->flags & I2C_M_RD) {
+		ret = recv_i2c(i2c);
+		if (ret != 1)
+			printk("recv_i2c failed\n");
+	} else {
+		ret = send_i2c(i2c);
+		if (ret != 1)
+			printk("send_i2c failed\n");
+	}
+#else
+	int i;
+	for (i = 0; i < num; i++) {
+		spin_lock_irq(&i2c->lock);
+		i2c->msg 		= &msgs[i];
+		i2c->msg->flags = msgs[i].flags;
+		i2c->msg_num 	= num;
+		i2c->msg_ptr 	= 0;
+		i2c->msg_idx 	= 0;
+		i2c->state = STATE_START;
+		spin_unlock_irq(&i2c->lock);
+
+		if (i2c->msg->flags & I2C_M_RD) {
+			ret = recv_i2c(i2c);
+			if (ret != 1)
+				printk("recv_i2c failed\n");
+		} else {
+			ret = send_i2c(i2c);
+			if (ret != 1)
+				printk("send_i2c failed\n");
+		}
+	}
+#endif
+	return ret;
+}
+
+/* tcc_i2c_xfer
+ *
+ * first port of call from the i2c bus code when an message needs
+ * transferring across the i2c bus.
+*/
+static int tcc_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
+{
+	struct tcc_i2c *i2c = (struct tcc_i2c *)adap->algo_data;
+	int retry;
+	int ret;
+
+	for (retry = 0; retry < adap->retries; retry++) {
+		
+		ret = tcc_i2c_doxfer(i2c, msgs, num);
+
+		if (ret == 1)
+			return ret;
+
+		dev_dbg(&i2c->adap.dev, "Retrying transmission (%d)\n", retry);
+
+		udelay(100);
+	}
+
+	return -EREMOTEIO;
+}
+
+static u32 tcc_i2c_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
+}
+
+/* i2c bus registration info */
+static const struct i2c_algorithm tcc_i2c_algorithm = {
+	.master_xfer	= tcc_i2c_xfer,
+	.functionality	= tcc_i2c_func,
+};
+
+/* tcc_i2c_init
+ *
+ * initialize the I2C controller, set the IO lines and frequency
+ */
+static void tcc_i2c_init(struct tcc_i2c *i2c)
+{
+	if (i2c->ch == 0 || i2c->ch == 1) {
+	/* I2C GPIO setting */
+	tca_i2c_setgpio(i2c->ch);
+
+	/* I2C clock setting */
+	tca_i2c_setclock(i2c->ch, i2c->regs, i2c->clk);
+	} else {
+		/* SMU_I2C clock setting */
+		tcc_writel(0x80000000, i2c->IRQSTR);
+
+		i2c->regs->CTRL = 0;
+		i2c->regs->PRES = 4;
+		BITSET(i2c->regs->CTRL, Hw7|Hw6);
+	}
+}
+
+/* tcc83xx_i2c_probe
+ *
+ * called by the bus driver when a suitable device is found
+*/
+static int tcc_i2c_probe(struct platform_device *pdev)
+{
+	struct tcc_i2c *i2c;
+	struct resource *resource_mem, *resource_clk;
+	struct resource *resource_mem_smu_i2c, *resource_clk_smu_i2c;
+//	int irq;
+	int i, ret;
+
+	resource_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!resource_mem) {
+		dev_err(&pdev->dev, "no mem resource?\n");
+		return -ENODEV;
+	}
+	resource_clk = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!resource_clk) {
+		dev_err(&pdev->dev, "no clk resource?\n");
+		return -ENODEV;
+	}
+//	irq = platform_get_irq(pdev, 0);
+//	if (irq < 0) {
+//	    dev_err(&pdev->dev, "no ieq resource?\n");
+//	    return -ENODEV;
+//	}
+
+	/* SMU_I2C */
+	resource_mem_smu_i2c = platform_get_resource(pdev, IORESOURCE_MEM, 2);
+	if (!resource_mem_smu_i2c) {
+		dev_err(&pdev->dev, "no mem resource? (smu_i2c)\n");
+		return -ENODEV;
+	}
+	resource_clk_smu_i2c = platform_get_resource(pdev, IORESOURCE_MEM, 3);
+	if (!resource_clk_smu_i2c) {
+		dev_err(&pdev->dev, "no clk resource? (smu_i2c)\n");
+		return -ENODEV;
+	}
+
+	i2c = kzalloc(sizeof(struct tcc_i2c) * I2C_NUM_OF_CH, GFP_KERNEL);
+	if (!i2c) {
+		ret = -ENOMEM;
+		goto err_nockl;
+	}
+
+	for (i = 0; i < I2C_NUM_OF_CH; i++) {
+		i2c[i].adap.owner = THIS_MODULE;
+		i2c[i].adap.algo = &tcc_i2c_algorithm;
+		i2c[i].adap.retries = 2;
+		sprintf(i2c[i].adap.name, "tcc-i2c-%d", i);
+
+		spin_lock_init(&i2c[i].lock);
+		init_waitqueue_head(&i2c[i].wait);
+
+		if (i == 0) {
+			i2c[i].ch = 0;
+			i2c[i].clk = (unsigned int)resource_clk->start;
+			i2c[i].regs = (volatile struct tcc_i2c_regs *)resource_mem->start;
+			i2c[i].IRQSTR = resource_mem->start + I2C_IRQSTR_OFFSET;
+		} else if (i == 1) {
+			i2c[i].ch = 1;
+			i2c[i].clk = (unsigned int)resource_clk->end;
+			i2c[i].regs = (volatile struct tcc_i2c_regs *)resource_mem->end;
+			i2c[i].IRQSTR = resource_mem->start + I2C_IRQSTR_OFFSET;
+		} else if (i == 2) {
+			i2c[i].ch = 2;
+			i2c[i].clk = (unsigned int)resource_clk_smu_i2c->start;
+			i2c[i].regs = (volatile struct tcc_i2c_regs *)resource_mem_smu_i2c->start;
+			i2c[i].IRQSTR = resource_mem_smu_i2c->start + I2C_ICLK_OFFSET;
+		} else if (i == 3) {
+			i2c[i].ch = 3;
+			i2c[i].clk = (unsigned int)resource_clk_smu_i2c->end;
+			i2c[i].regs = (volatile struct tcc_i2c_regs *)resource_mem_smu_i2c->end;
+			i2c[i].IRQSTR = resource_mem_smu_i2c->start + I2C_ICLK_OFFSET;
+		} else {
+			dev_err(&pdev->dev, "no i2c channel?\n");
+			return -ENODEV;
+		}
+	}
+
+	/* I2C reset */
+	tca_i2c_reset();
+
+	for (i = 0; i < I2C_NUM_OF_CH; i++) {
+		tcc_i2c_init(i2c + i);
+
+		i2c[i].adap.algo_data = i2c + i;
+		i2c[i].adap.dev.parent = &pdev->dev;
+		//i2c[i].adap.class = I2C_CLASS_ALL;
+		i2c[i].adap.class = I2C_CLASS_HWMON || I2C_CLASS_TV_ANALOG || I2C_CLASS_TV_DIGITAL || I2C_CLASS_DDC ||I2C_CLASS_SPD;
+
+		ret = i2c_add_adapter(&i2c[i].adap);
+		if (ret < 0) {
+			printk("tcc-i2c-%d: Failed to add bus\n", i);
+			for (i--; i >= 0; i--)
+				i2c_del_adapter(&i2c[i].adap);
+			goto err_clk;
+		}
+	}
+
+	platform_set_drvdata(pdev, i2c);
+	dev_info(&pdev->dev, "%s: I2C adapter\n", i2c->adap.dev.bus_id);
+
+	return 0;
+
+err_clk:
+	//TODO: I2C peri bus disable
+
+err_nockl:
+	return ret;
+}
+
+static int tcc_i2c_remove(struct platform_device *pdev)
+{
+	int i;
+	struct tcc_i2c *i2c = platform_get_drvdata(pdev);
+
+	platform_set_drvdata(pdev, NULL);
+
+	for (i = 0; i < I2C_NUM_OF_CH; i++)
+		i2c_del_adapter(&i2c[i].adap);
+
+	/* I2C bus & clock disable */
+	tca_ckc_setiobus(RB_I2CCONTROLLER, DISABLE);
+
+	kfree(i2c);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int tcc_i2c_suspend(struct platform_device *dev, pm_message_t state)
+{
+	return 0;
+}
+
+static int tcc_i2c_resume(struct platform_device *dev)
+{
+	return 0;
+}
+#else
+#define tcc_i2c_suspend	NULL
+#define tcc_i2c_resume	NULL
+#endif
+
+/* device driver for platform bus bits */
+
+static struct platform_driver tcc_i2c_driver = {
+	.probe		= tcc_i2c_probe,
+	.remove		= tcc_i2c_remove,
+	.suspend	= tcc_i2c_suspend,
+	.resume		= tcc_i2c_resume,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "tcc-i2c",
+	},
+};
+
+static int __init tcc_i2c_adap_init(void)
+{
+	return platform_driver_register(&tcc_i2c_driver);
+}
+
+static void __exit tcc_i2c_adap_exit(void)
+{
+	platform_driver_unregister(&tcc_i2c_driver);
+}
+
+module_init(tcc_i2c_adap_init);
+module_exit(tcc_i2c_adap_exit);
+
+MODULE_AUTHOR("Telechips Inc. SYS4-3 linux@telechips.com");
+MODULE_DESCRIPTION("Telechips H/W I2C driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.29/drivers/i2c/busses/tcc8900/tca_i2c.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/i2c/busses/tcc8900/tca_i2c.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,82 @@
+/****************************************************************************
+ *   FileName    : tca_i2c.c
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+#include <linux/delay.h>
+
+#include <bsp.h>
+#include "tca_i2c.h"
+
+
+/*****************************************************************************
+* Function Name : tca_i2c_reset()
+* Description: I2C controller reset
+******************************************************************************/
+void tca_i2c_reset(void)
+{ 
+	tca_ckc_set_iobus_swreset(RB_I2CCONTROLLER, OFF);
+	tca_ckc_set_iobus_swreset(RB_I2CCONTROLLER, ON);
+}
+
+/*****************************************************************************
+* Function Name : tca_i2c_setgpio()
+* Description: I2C port configuration
+*              SCL0-GPA0, SDA0-GPA1
+*              SCL1-GPA8, SDA1-GPA9
+* input parameter:
+*       int ch;   // I2C master channel
+******************************************************************************/
+void tca_i2c_setgpio(int ch)
+{
+	volatile struct tcc_gpio *gpio;
+
+	gpio = (volatile struct tcc_gpio *)GPA_BASE;
+
+	switch (ch) {
+	case 0:
+		BITCSET(gpio->FN0, (Hw4-Hw0), Hw0);	// GPA[0] function set 1
+		BITCSET(gpio->FN0, (Hw8-Hw4), Hw4);	// GPA[1] function set 1
+		break;
+	case 1:
+		BITCSET(gpio->FN1, (Hw4-Hw0), Hw0);	// GPA[8] function set 1
+		BITCSET(gpio->FN1, (Hw8-Hw4), Hw4);	// GPA[9] function set 1
+		break;
+	default:
+		break;
+	}
+}
+
+/*****************************************************************************
+* Function Name : tca_i2c_setclock()
+* Description: I2C clock configuration
+* input parameter:
+*       int ch;   // I2C master channel
+******************************************************************************/
+void tca_i2c_setclock(int ch, volatile struct tcc_i2c_regs *i2c_reg, unsigned int i2c_clock)
+{
+	unsigned int i2c_clk_input_freq, prescale;
+
+	/* I2C IO-bus enable */
+	tca_ckc_setiobus(RB_I2CCONTROLLER, ENABLE);
+
+	/* get I2C bus clock
+	 * bootloader set I2C bus clock
+	 */
+	i2c_clk_input_freq = tca_ckc_getperi(PERI_I2C);
+
+	prescale = ((i2c_clk_input_freq / 10) / (i2c_clock * 5)) - 1;
+	i2c_reg->PRES = prescale;
+	i2c_reg->CTRL = Hw7 | Hw6 | HwZERO;	// start enable, stop enable, 8bit mode
+	BITSET(i2c_reg->CMD, Hw0);			// clear pending interrupt
+
+	printk("i2c%d SCK(%d) <-- input clk(%dKhz), prescale(%d)\n", 
+			ch, i2c_clock, i2c_clk_input_freq, prescale);
+}
+
+/* end of source */
Index: linux-2.6.29/drivers/i2c/busses/tcc8900/tca_i2c.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/i2c/busses/tcc8900/tca_i2c.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,43 @@
+/****************************************************************************
+ *   FileName    : tca_i2c.h
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+#ifndef __TCA_I2C_H__
+#define __TCA_I2C_H__
+
+/* Define
+ */
+#define I2C_NUM_OF_CH		4
+#define GPA_BASE 			0xF0102000
+
+#define I2C_IRQSTR_OFFSET	0xC0	/* only I2C */
+#define I2C_ICLK_OFFSET		0x80	/* only SMU_I2C */
+
+
+/* register structure
+ */
+#pragma pack(push, 4)
+struct tcc_gpio {
+	volatile unsigned long DAT, EN, SET, CLR, XOR, CD0, CD1, PD0, PD1, FN0, FN1, FN2, FN3;
+};
+
+struct tcc_i2c_regs {
+	volatile unsigned long PRES, CTRL, TXR, CMD, RXR, SR, TR;
+};
+#pragma pack(pop)
+
+
+/* extern functions
+ */
+extern void tca_i2c_reset(void);
+extern void tca_i2c_setgpio(int ch);
+extern void tca_i2c_setclock(int ch, volatile struct tcc_i2c_regs *i2c_reg, unsigned int i2c_clock);
+
+#endif	//__TCA_I2C_H__
+
Index: linux-2.6.29/drivers/i2c/chips/Kconfig
===================================================================
--- linux-2.6.29.orig/drivers/i2c/chips/Kconfig	2010-04-07 12:29:33.000000000 -0400
+++ linux-2.6.29/drivers/i2c/chips/Kconfig	2010-04-07 13:00:44.000000000 -0400
@@ -102,4 +102,16 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called tsl2550.
 
+config TCC_I2C_WM8731
+	bool "Telechips WM8731 Codec chip"
+	help
+	  If you say yes here you get support for the Telechips board's
+	  WM8731 Codec chip.
+
+config TCC_I2C_PCA953X
+	bool "Telechips PCA953X GPIO Expansion chip"
+	help
+	  If you say yes here you get support for the Telechips board's
+	  PCA9538 and PCA9539 GPIO Expansion chips.
+
 endmenu
Index: linux-2.6.29/drivers/i2c/chips/tcc_pca953x.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/i2c/chips/tcc_pca953x.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,257 @@
+/*
+ * linux/drivers/i2c/chips/tcc_pca953x.c
+ *
+ * Author:  <linux@telechips.com>
+ * Created: 31th March, 2009 
+ * Description: Tcc250 Driver 
+ *
+ * Copyright (c) Telechips, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * ====================================
+ *  Description
+ *  -----------
+ * Slave chip: two PCA9539, one PCA9538
+ * Slave address: PCA9539_U2: 0x77	// 1110 1HH[R/W]
+ *                PCA9539_U3: 0x74	// 1110 1LL[R/W]
+ *                PCA9538_U4: 0x70	// 1110 0LL[R/W]
+ * EXPORT_SYMBOL(tcc_pca953x_read);
+ * EXPORT_SYMBOL(tcc_pca953x_write);
+ * EXPORT_SYMBOL(tcc_pca953x_setup);
+ * ====================================
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <mach/tcc_pca953x.h>
+
+
+static unsigned short probe_i2c[] = {0, PCA9539_U2_SLAVE_ADDR, I2C_CLIENT_END};	/* { i2c_num, i2c_addr } */
+static unsigned short dummy[] = {I2C_CLIENT_END};
+
+static struct i2c_client_address_data addr_data = {
+	.normal_i2c = dummy,
+	.probe = probe_i2c,
+	.ignore = dummy,
+};
+
+static struct i2c_driver pca953x_i2c_driver;
+struct i2c_client *pca953x_i2c_client;
+//EXPORT_SYMBOL(pca953x_i2c_client);
+
+static int pca953x_i2c_probe(struct i2c_adapter *adap, int addr, int kind)
+{
+	struct i2c_client *i2c;
+
+	i2c = kzalloc(sizeof(*i2c), GFP_KERNEL);
+	if (!i2c)
+		return -ENOMEM;
+
+	strcpy(i2c->name, "PCA953X");
+	i2c->flags = 0;
+	i2c->addr = addr;
+	i2c->adapter = adap;
+	i2c->driver = &pca953x_i2c_driver;
+
+	pca953x_i2c_client = i2c;
+
+	return i2c_attach_client(i2c);
+}
+
+static int pca953x_i2c_detach(struct i2c_client *client)
+{
+	i2c_detach_client(client);
+	kfree(pca953x_i2c_client);
+	return 0;
+}
+
+static int pca953x_i2c_attach(struct i2c_adapter *adap)
+{
+	return i2c_probe(adap, &addr_data, pca953x_i2c_probe);
+}
+
+static struct i2c_driver pca953x_i2c_driver = {
+	.driver = {
+		.name = "PCA953X",
+		.owner = THIS_MODULE,
+	},
+	.id = 1,
+	.attach_adapter = pca953x_i2c_attach,
+	.detach_client = pca953x_i2c_detach,
+};
+
+static int __init pca953x_i2c_init(void)
+{
+	return i2c_add_driver(&pca953x_i2c_driver);
+}
+
+static void __exit pca953x_i2c_exit(void)
+{
+	i2c_del_driver(&pca953x_i2c_driver);
+}
+module_init(pca953x_i2c_init);
+module_exit(pca953x_i2c_exit);
+
+MODULE_AUTHOR("Telechips Inc. SYS4-3 linux@telechips.com");
+MODULE_DESCRIPTION("PCA953x I2C driver");
+MODULE_LICENSE("GPL");
+
+/*------------------------------------------------------------------------
+ * PCA953X Control APIs
+ *
+ *------------------------------------------------------------------------
+ */
+int tcc_pca953x_read(int slave, unsigned char cmd, unsigned char *rd_buf)
+{
+	struct i2c_adapter *adap = pca953x_i2c_client->adapter;
+	struct i2c_msg msgs[2];
+	int ret;
+		
+	/* write port_nr */
+	msgs[0].addr = slave;
+	msgs[0].flags = pca953x_i2c_client->flags & I2C_M_TEN;
+	msgs[0].len = 1;
+	msgs[0].buf = &cmd;
+
+	/* read port */
+	msgs[1].addr = slave;
+	msgs[1].flags = pca953x_i2c_client->flags & I2C_M_TEN;
+	msgs[1].flags |= I2C_M_RD;
+	msgs[1].len = 1;
+	msgs[1].buf = rd_buf;
+
+	ret = i2c_transfer(adap, msgs, 2);
+	if (ret != 1) {
+		return -1;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(tcc_pca953x_read);
+
+int tcc_pca953x_write(int slave, const unsigned char *wr_buf, int count)
+{
+	struct i2c_adapter *adap = pca953x_i2c_client->adapter;
+	struct i2c_msg msgs;
+	int ret;
+
+	msgs.addr = slave;
+	msgs.flags = pca953x_i2c_client->flags & I2C_M_TEN;
+	msgs.len = count;
+	msgs.buf = (__u8 *)wr_buf;
+	ret = i2c_transfer(adap, &msgs, 1);
+	if (ret != 1) {
+		return -1;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(tcc_pca953x_write);
+
+int tcc_pca953x_setup(int slave, int name, int direction, int value, int mode)
+{
+	int ret = 0, port_nr = 0, port[2], conf[2];
+	unsigned char buf[2];
+
+	switch (slave) {
+		case PCA9539_U2_SLAVE_ADDR:
+			port_nr = 2;
+			port[0] = direction ? PCA9539_INPUT_0 : PCA9539_OUTPUT_0;
+			port[1] = direction ? PCA9539_INPUT_1 : PCA9539_OUTPUT_1;
+			conf[0] = PCA9539_DIRECTION_0;
+			conf[1] = PCA9539_DIRECTION_1;
+			break;
+			
+		case PCA9539_U3_SLAVE_ADDR:
+			port_nr = 2;
+			port[0] = direction ? PCA9539_INPUT_0 : PCA9539_OUTPUT_0;
+			port[1] = direction ? PCA9539_INPUT_1 : PCA9539_OUTPUT_1;
+			conf[0] = PCA9539_DIRECTION_0;
+			conf[1] = PCA9539_DIRECTION_1;
+			break;
+			
+		case PCA9538_U4_SLAVE_ADDR:
+			port_nr = 1;
+			port[0] = direction ? PCA9538_INPUT_0 : PCA9538_OUTPUT_0;
+			conf[0] = PCA9538_DIRECTION_0;
+			break;
+			
+		default:
+			break;
+	}
+
+	/*
+	 * GET_VALUE is read only
+	 */
+	if (GET_VALUE == mode) {
+		ret |= tcc_pca953x_read(slave, port[0], &buf[0]);
+		if (port_nr == 2) {
+			ret |= tcc_pca953x_read(slave, port[1], &buf[1]);
+		} else {
+			buf[1] = 0;
+		}
+		
+		if (ret) ret = -1;
+		else ret = ((buf[1] << 8) | buf[0]) & 0x0000ffff;
+		return ret;
+	}
+
+	/*
+	 * What port number?
+	 */
+	if (name >= Hw0 && name <= Hw7) {
+		port_nr = 0;
+	} else if (name >= Hw8 && name <= Hw15) {
+		port_nr = 1;
+		name >>= 8;
+	} else {
+		return -1;
+	}
+
+	/*
+	 * Set direction
+	 */
+	if (SET_DIRECTION & mode) {
+		tcc_pca953x_read(slave, conf[port_nr], &buf[0]);
+		if (INPUT == direction) {
+			buf[1] = buf[0] | name;
+		} else if (OUTPUT == direction) {
+			buf[1] = buf[0] & ~name;
+		} else {
+			return -1;
+		}
+		
+		buf[0] = conf[port_nr];
+		ret = tcc_pca953x_write(slave, &buf[0], 2);
+		if (ret == -1)
+			return -1;
+	}
+
+	/*
+	 * Set value
+	 */
+	if (SET_VALUE & mode) {
+		tcc_pca953x_read(slave, port[port_nr], &buf[0]);
+		if (HIGH == value) {
+			buf[1] = buf[0] | name;
+		} else if (LOW == value) {
+			buf[1] = buf[0] & ~name;
+		} else {
+			return -1;
+		}
+		
+		buf[0] = port[port_nr];
+		tcc_pca953x_write(slave, &buf[0], 2);
+		if (ret == -1)
+			return -1;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(tcc_pca953x_setup);
+
Index: linux-2.6.29/drivers/i2c/chips/tcc_wm8731.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/i2c/chips/tcc_wm8731.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,99 @@
+/*
+ * linux/drivers/i2c/chips/wm8731.c
+ *
+ * Author:  <linux@telechips.com>
+ * Created: 21th March, 2009 
+ * Description: Tcc250 Driver 
+ *
+ * Copyright (c) Telechips, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * ====================================
+ *  Description
+ *  -----------
+ * Slave chip: WM8731
+ * Slave address: 0x1a
+ * EXPORT_SYMBOL(wm8731_i2c_client)
+ * ====================================
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/i2c.h>
+
+#define WM8731_SLAVE_ADDR	0x1a
+static unsigned short probe_i2c[] = {0, WM8731_SLAVE_ADDR, I2C_CLIENT_END};	/* { i2c_num, i2c_addr } */
+static unsigned short dummy[] = {I2C_CLIENT_END};
+
+static struct i2c_client_address_data addr_data = {
+	.normal_i2c = dummy,
+	.probe = probe_i2c,
+	.ignore = dummy,
+};
+
+static struct i2c_driver wm8731_i2c_driver;
+struct i2c_client *wm8731_i2c_client;
+EXPORT_SYMBOL(wm8731_i2c_client);
+
+static int wm8731_i2c_probe(struct i2c_adapter *adap, int addr, int kind)
+{
+	struct i2c_client *i2c;
+
+	i2c = kzalloc(sizeof(*i2c), GFP_KERNEL);
+	if (!i2c)
+		return -ENOMEM;
+
+	strcpy(i2c->name, "WM8731");
+	i2c->flags = 0;
+	i2c->addr = addr;
+	i2c->adapter = adap;
+	i2c->driver = &wm8731_i2c_driver;
+
+	wm8731_i2c_client = i2c;
+
+	return i2c_attach_client(i2c);
+}
+
+static int wm8731_i2c_detach(struct i2c_client *client)
+{
+	i2c_detach_client(client);
+	kfree(wm8731_i2c_client);
+	return 0;
+}
+
+static int wm8731_i2c_attach(struct i2c_adapter *adap)
+{
+	return i2c_probe(adap, &addr_data, wm8731_i2c_probe);
+}
+
+static struct i2c_driver wm8731_i2c_driver = {
+	.driver = {
+		.name = "WM8731",
+		.owner = THIS_MODULE,
+	},
+	.id = I2C_DRIVERID_WM8731,
+	.attach_adapter = wm8731_i2c_attach,
+	.detach_client = wm8731_i2c_detach,
+};
+
+static int __init wm8731_i2c_init(void)
+{
+	return i2c_add_driver(&wm8731_i2c_driver);
+}
+
+static void __exit wm8731_i2c_exit(void)
+{
+	i2c_del_driver(&wm8731_i2c_driver);
+}
+
+module_init(wm8731_i2c_init);
+module_exit(wm8731_i2c_exit);
+
+MODULE_AUTHOR("Telechips Inc. SYS4-3 linux@telechips.com");
+MODULE_DESCRIPTION("WM8731 I2C driver");
+MODULE_LICENSE("GPL");
+
Index: linux-2.6.29/drivers/i2c/i2c-core.c
===================================================================
--- linux-2.6.29.orig/drivers/i2c/i2c-core.c	2010-04-07 12:29:33.000000000 -0400
+++ linux-2.6.29/drivers/i2c/i2c-core.c	2010-04-07 12:29:36.000000000 -0400
@@ -1081,6 +1081,9 @@
 	msg.flags = client->flags & I2C_M_TEN;
 	msg.len = count;
 	msg.buf = (char *)buf;
+	/* for TCC DIBCOM module */
+	msg.flags |= (client->flags & I2C_M_DIBCOM_MODE);
+	msg.flags |= (client->flags & I2C_M_DIBCOM_WR_RD);
 
 	ret = i2c_transfer(adap, &msg, 1);
 
@@ -1109,6 +1112,8 @@
 	msg.flags |= I2C_M_RD;
 	msg.len = count;
 	msg.buf = buf;
+	/* for TCC DIBCOM module */
+	msg.flags |= (client->flags & I2C_M_DIBCOM_MODE);
 
 	ret = i2c_transfer(adap, &msg, 1);
 
Index: linux-2.6.29/drivers/i2c/i2c-dev.c
===================================================================
--- linux-2.6.29.orig/drivers/i2c/i2c-dev.c	2010-04-07 12:29:33.000000000 -0400
+++ linux-2.6.29/drivers/i2c/i2c-dev.c	2010-04-07 12:29:36.000000000 -0400
@@ -180,6 +180,9 @@
 		iminor(file->f_path.dentry->d_inode), count);
 
 	ret = i2c_master_send(client,tmp,count);
+	/* for TCC DIBCOM module */
+	if (client->flags & I2C_M_DIBCOM_WR_RD)
+		client->flags &= ~I2C_M_DIBCOM_WR_RD;
 	kfree(tmp);
 	return ret;
 }
@@ -379,6 +382,8 @@
 	switch ( cmd ) {
 	case I2C_SLAVE:
 	case I2C_SLAVE_FORCE:
+	/* for TCC DIBCOM module */
+	case I2C_SLAVE_DIBCOM:
 		/* NOTE:  devices set up to work with "new style" drivers
 		 * can't use I2C_SLAVE, even when the device node is not
 		 * bound to a driver.  Only I2C_SLAVE_FORCE will work.
@@ -396,7 +401,18 @@
 			return -EBUSY;
 		/* REVISIT: address could become busy later */
 		client->addr = arg;
+
+		/* for TCC DIBCOM module */
+		if (cmd == I2C_SLAVE_DIBCOM)
+			client->flags |= I2C_M_DIBCOM_MODE;
+
 		return 0;
+
+	/* for TCC DIBCOM module */
+	case I2C_DIBCOM_WR_RD:
+		client->flags |= I2C_M_DIBCOM_WR_RD;
+		break;
+
 	case I2C_TENBIT:
 		if (arg)
 			client->flags |= I2C_M_TEN;
Index: linux-2.6.29/drivers/ide/Kconfig
===================================================================
--- linux-2.6.29.orig/drivers/ide/Kconfig	2010-04-07 12:29:34.000000000 -0400
+++ linux-2.6.29/drivers/ide/Kconfig	2010-04-07 12:29:36.000000000 -0400
@@ -731,6 +731,17 @@
 	depends on ARM && (ARCH_RPC || ARCH_SHARK)
 	default y
 
+config BLK_DEV_IDE_TCC89X
+       bool
+
+config BLK_DEV_PATA_TCC89X
+       bool "PATA for TCC89x"
+       select BLK_DEV_IDE_TCC89X
+
+#config BLK_DEV_SATA_TCC89X
+#       bool "SATA for TCC89x"
+#       select BLK_DEV_IDE_TCC89X
+
 config BLK_DEV_IDE_ICSIDE
 	tristate "ICS IDE interface support"
 	depends on ARM && ARCH_ACORN
Index: linux-2.6.29/drivers/ide/Makefile
===================================================================
--- linux-2.6.29.orig/drivers/ide/Makefile	2010-04-07 12:29:34.000000000 -0400
+++ linux-2.6.29/drivers/ide/Makefile	2010-04-07 12:29:36.000000000 -0400
@@ -21,6 +21,8 @@
 
 obj-$(CONFIG_IDE_ARM)			+= ide_arm.o
 
+obj-$(CONFIG_BLK_DEV_IDE_TCC89X)	+= tcc89x_ide.o
+
 obj-$(CONFIG_BLK_DEV_ALI14XX)		+= ali14xx.o
 obj-$(CONFIG_BLK_DEV_UMC8672)		+= umc8672.o
 obj-$(CONFIG_BLK_DEV_DTC2278)		+= dtc2278.o
Index: linux-2.6.29/drivers/ide/tcc89x_ide.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/ide/tcc89x_ide.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,329 @@
+/*
+ * ARM default IDE host driver
+ *
+ * Copyright (C) 2004 Bartlomiej Zolnierkiewicz
+ * Based on code by: Russell King, Ian Molton and Alexander Schulz.
+ *
+ * May be copied or modified under the terms of the GNU General Public License.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/ide.h>
+#include <linux/delay.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include <bsp.h>
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+#include <mach/tca_ckc.h>
+#include <mach/tcc_pca953x.h>
+
+// Bit 0 CDR7 Access
+#define CDR7_ERR 0
+
+#define DBG_PRINTF printk
+
+#ifdef CONFIG_BLK_DEV_SATA_TCC89X
+static void wait_for_bits(volatile PSATA pSata, int ret_on_rst, int timeout_val, int exp_val, int mask, int *matched)
+{
+    int timeout_cnt = 0, error = 0;
+    int failed;
+    int rdata = 0, i = 0;
+    int phy_sig_det_w = 1;
+
+    //DBG_PRINTF("wait_for_bits: Waiting for register at address 0x%x,to have value=0x%x", addr, exp_val );
+
+    *matched = 0;
+
+    // wait for busy, and Drq to be cleared.
+    // or timeout or reset, if checking reset
+    while ((timeout_cnt < timeout_val)
+           && !*matched && (error == 0)
+           && !(!phy_sig_det_w && ret_on_rst))
+    {
+        rdata = pSata->CDR7;
+
+        //DBG_PRINTF ("!!!!!!actual rdata='0x%x' read at time=%d", rdata, timeout_cnt);
+        failed = 0;
+
+        for (i = 0; i <= 31; i = i + 1) {
+            if ((((mask >> i) & 1) == 1) && (((rdata >> i) & 1) != ((exp_val >> i) & 1))) {
+                // joo DBG_PRINTF("Cmp Fail bit %d: rdata='0x%x' exp_val='0x%x'", i, (rdata>>i)&1, (exp_val>>i)&1);
+                failed = 1;
+            }
+        }  
+
+        if (failed == 0) {
+            *matched = 1;
+        }
+
+        // After bits matched, check for error
+        if (*matched) {
+            if (((rdata & 0xff) != 0x7f) // we're not in Power on reset
+                && (((rdata >> CDR7_ERR) & 1) == 1))   // we do have error bit set
+            {
+                // joo DBG_PRINTF("wait_for_bits: detected err, bit 0 of reg at address 0x%x is set", addr);
+                error = 1;
+            }
+        } else {
+            timeout_cnt = timeout_cnt + 1;
+        }
+
+    } // while ((timeout_cnt < timeout_val) &&...
+
+    if ((ret_on_rst == 1) && !phy_sig_det_w) {
+        DBG_PRINTF("wait_for_bits: detected a Non recov err, while waiting for bits on reg 0x%x\n",
+                   0x1C);
+    } else if (timeout_cnt >= timeout_val) {
+        DBG_PRINTF("wait_for_bits: Timeout waiting reg at address '0x%x' to equal '0x%x'\n",
+                   0x1C, exp_val );
+    } else {
+        DBG_PRINTF("wait_for_bits: Got register at address '0x%x' reg expected_value='0x%x', actual='0x%x'\n",
+        	     0x1C, exp_val, rdata);
+    }
+}
+
+static void wait_for_bsydrq(volatile PSATA pSata, int ret_on_rst, int timeout_val, int *matched)
+{
+    int exp_val = 0;
+    int mask = 0x88;
+
+    wait_for_bits(pSata, ret_on_rst, timeout_val, exp_val, mask, matched);
+}
+
+static int prog_host_speed(volatile PSATA pSata, int speed, int *spd_ok)
+{
+    int spd_select;
+    int reset;
+    int reg_data;
+    //int i;
+    int ret_on_rst;
+    int timeout_val;
+    int matched;
+
+    // Initialize
+    ret_on_rst  = 0;
+    //timeout_val = 1000000; // Must Be Huge For Speed Negotiation
+    timeout_val =   2000000; // Must Be Huge For Speed Negotiation
+    //timeout_val = 0x7FFFFFFF; // Must Be Huge For Speed Negotiation
+
+    //	 DBG_PRINTF("prog_host_speed: Setting Host Gen Mode = %d", speed);
+
+    // Set speed
+    spd_select = (speed == 2) ? 0x2 : 0x1;
+
+    // Need to wait a hundred clocks of slowest
+    mdelay(1000);
+
+    // Reset Device with correct speed
+    reset = 1;
+    reg_data = (spd_select << 4) | reset;
+
+    // Write SCR2 with speed and reset
+    pSata->SCR2 = reg_data;
+
+    // Need to wait a few clocks of slowest
+    mdelay(100);
+
+    // Set normal operation & correct speed
+    reset = 0;
+    reg_data = spd_select << 4 | reset;
+    //HwSATA->nSCR2 = reg_data;
+    pSata->SCR2 = reg_data;
+
+    // Wait for BSY & DRQ to be cleared
+    wait_for_bsydrq(pSata, ret_on_rst, timeout_val, &matched);
+
+    if (matched) {
+        DBG_PRINTF("prog_host_speed: Host Speed selected [speed:%d]\n", speed);
+        *spd_ok = 1;
+        return 0;
+    } else {
+        printk("prog_host_speed: ERROR - Host Speed timed out waiting for speed change! [speed:%d]\n", speed);
+        *spd_ok = 0;
+    }
+    return -1;
+} 
+
+static void tca_sata_port_config(void)
+{
+    volatile PPIC pPIC = (volatile PPIC)tcc_p2v(HwPIC_BASE);
+
+    BITSET(pPIC->SEL1, 1 << (INT_SATA - 32));
+    BITSET(pPIC->MODE1, 1 << (INT_SATA - 32));
+}
+
+static int tcc_sata_hw_init(hw_regs_t *p_hw, unsigned long sata_base)
+{
+    int spd_ok = 0, i = 0;
+    volatile PSATA pSata = (volatile PSATA)sata_base;
+
+    memset(p_hw, 0, sizeof(hw_regs_t));
+
+    for (i = 0; i <= 7; i++) {
+        p_hw->io_ports_array[i] = sata_base + (i * 4);
+    }
+    p_hw->io_ports.ctl_addr = sata_base + 0x20;
+    p_hw->irq = INT_SATA;
+
+    if (prog_host_speed(pSata, 2, &spd_ok) == 0) {
+        return 0;
+    } else if (prog_host_speed(pSata, 1, &spd_ok) == 0) {
+        return 0;
+    }
+    return -1;
+}
+#endif
+
+#ifdef CONFIG_BLK_DEV_PATA_TCC89X
+static void tca_pata_pio_config(unsigned long base)
+{
+    volatile PIDE pIDE = NULL;
+    unsigned bus_total_cycle, setup, pw, hold;
+    unsigned int bus_clk = 0;
+
+    pIDE = (volatile PIDE)base;
+
+    bus_clk = tca_ckc_getbus();
+    printk("bus_clk :  BUS-%d\n", bus_clk);
+
+    bus_total_cycle = 120 * bus_clk / 10000000L;
+    if (bus_total_cycle <= 10) {
+        setup   = 2;    // 3 cycle
+        pw      = 5;    // 6 cycle
+        hold    = 0;    // 1 cycle
+    } else {
+        bus_total_cycle = bus_total_cycle - 2;  // assume Hold = 2
+
+        hold    = 1;    // 1 means 2 cycles
+        pw      = bus_total_cycle * 75 / 100 - 1;   // PW = 75% of remain cycles
+        setup   = bus_total_cycle - pw - 1;     // Stp = 25% of remain cycles                
+    }
+
+    printk("@@@ setup[%d], pw[%d]. hold[%d]\n", setup, pw, hold);
+
+    /* PIO mode setting */
+    //h->regs->PIOCTRL = (HwPIOCTRL_SYNC_2 | (setup << 13) | (pw << 7) | (hold << 1));
+    pIDE->PIOCTRL = (Hw22 | (setup << 13) | (pw << 7) | (hold << 1) | Hw0);
+}
+
+static void tca_pata_port_config(void)
+{
+    volatile PGPION pGPIO_F = (volatile PGPION)tcc_p2v(HwGPIOF_BASE);
+    volatile PGPION pGPIO_B = (volatile PGPION)tcc_p2v(HwGPIOB_BASE);
+    volatile PGPION pGPIO_A = (volatile PGPION)tcc_p2v(HwGPIOA_BASE);
+    volatile PGPIO pGPIO = (volatile PGPIO)tcc_p2v(HwGPIO_BASE);
+    volatile PPIC pPIC = (volatile PPIC)tcc_p2v(HwPIC_BASE);
+
+    /* HDD port config */
+    pGPIO_F->GPFN0 = 0x33333333;
+    pGPIO_F->GPFN1 = 0x33333333; 
+    pGPIO_F->GPFN2 = 0x33333333;
+    BITCLR(pGPIO_F->GPFN3, 0xFF);
+    BITSET(pGPIO_F->GPFN3, 0x33);
+
+    /* RESET port config (GPIOB_26) */
+    BITCLR(pGPIO_B->GPFN3, 0xF00);
+    BITSET(pGPIO_B->GPEN, Hw26);
+
+    /* Externel intr GPIOA_12 config */
+    BITCLR(pGPIO_A->GPFN1, 0xF0000);
+    //BITCLR(pGPIO_A->GPEN, Hw12);
+    //BITCLR(pGPIO_A->GPDAT, Hw12);
+    BITCLR(pGPIO_A->GPPD0, Hw24);
+    BITSET(pGPIO_A->GPPD0, Hw25);
+
+    /* EINT setting (GPIOA_12: EINT5) */
+    BITCLR(pGPIO->EINTSEL1, 0x3F << 8);
+    BITSET(pGPIO->EINTSEL1, 12 << 8);
+
+    BITSET(pPIC->SEL0, Hw8);
+    BITCLR(pPIC->POL0, Hw8);
+    BITSET(pPIC->MODE0, Hw8);
+}
+
+static void tca_pata_hw_reset(int deley_ms)
+{
+    volatile PGPION pGPIO_B = (volatile PGPION)tcc_p2v(HwGPIOB_BASE);
+
+    BITSET(pGPIO_B->GPDAT, Hw26);
+    mdelay(1);
+    BITCLR(pGPIO_B->GPDAT, Hw26);
+    mdelay(deley_ms);
+}
+
+static int tcc_pata_hw_init(hw_regs_t *p_hw, unsigned long pata_base)
+{
+    int i;
+    if (p_hw) {
+        tca_pata_hw_reset(500);
+        memset(p_hw, 0, sizeof(hw_regs_t));
+
+        for (i = 0; i <= 7; i++) {
+            p_hw->io_ports_array[i] = pata_base + (i * 4);
+        }
+        p_hw->io_ports.ctl_addr = pata_base + 0x20 + (6 * 4);
+
+        p_hw->irq = INT_EI5;
+        //p_hw->chipset = ide_generic;
+
+        return 0;
+    }
+    return -1;
+}
+#endif
+
+static int __init tcc_ide_init(void)
+{
+    hw_regs_t *hws[] = { NULL, NULL, NULL, NULL };
+    int hw_pos = 0;
+
+#ifdef CONFIG_BLK_DEV_PATA_TCC89X
+	unsigned long pata_base = (unsigned long)tcc_p2v(HwIDE_BASE);
+	hw_regs_t pata_hw;
+#endif
+
+#ifdef CONFIG_BLK_DEV_SATA_TCC89X
+    PPMU p_pmu = (PPMU)tcc_p2v(HwPMU_BASE);
+	unsigned long sata_base = (unsigned long)tcc_p2v(HwSATA_BASE);
+	hw_regs_t sata_hw;
+#endif
+
+    /* PATA */
+#ifdef CONFIG_BLK_DEV_PATA_TCC89X
+    tcc_pca953x_setup(PCA9539_U3_SLAVE_ADDR, ATAPI_ON, OUTPUT, HIGH, SET_DIRECTION | SET_VALUE);
+    tca_ckc_setiobus(RB_IDECONTROLLER, 1);
+
+    tca_pata_pio_config(pata_base);
+    tca_pata_port_config();
+    if (tcc_pata_hw_init(&pata_hw, pata_base) == 0) {
+        hws[hw_pos] = &pata_hw;
+        hw_pos++;
+    }
+#endif
+
+    /* SATA */
+#ifdef CONFIG_BLK_DEV_SATA_TCC89X
+    BITCLR(p_pmu->PWROFF, Hw4); // SATA Phy enable
+    tca_ckc_setiobus(RB_SATAHCONTROLLER, 1);
+
+    tca_sata_port_config();
+    if (tcc_sata_hw_init(&sata_hw, sata_base) == 0) {
+        hws[hw_pos] = &sata_hw;
+        hw_pos++;
+    }
+#endif
+
+	return ide_host_add(NULL, hws, NULL);
+}
+
+module_init(tcc_ide_init);
+
+MODULE_AUTHOR("linux@telechips.com");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("TCC89X IDE driver");
+
Index: linux-2.6.29/drivers/input/touchscreen/Kconfig
===================================================================
--- linux-2.6.29.orig/drivers/input/touchscreen/Kconfig	2010-04-07 12:29:34.000000000 -0400
+++ linux-2.6.29/drivers/input/touchscreen/Kconfig	2010-04-07 12:29:36.000000000 -0400
@@ -408,4 +408,35 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called tsc2007.
 
+config TOUCHSCREEN_TCCTS
+	tristate "Telechips adc touchscreen driver"
+	select TCC_TS_CORE
+	depends on ARCH_TCC 
+	default y
+	help
+	  Say Y here if you have a touchscreen interface using the
+	  i2c device. 
+ 
+choice 
+    prompt "LCD_TYPE"
+    depends on ARCH_TCC
+    default LCD10
+    help 
+        select LCD TYPE
+config LCD01
+    bool "LCD Type 0.1"
+    help 
+        select LCD 0.1 TYPE
+config LCD11
+    bool "LCD Type 1.1"
+    help 
+        select LCD 1.1 TYPE
+config LCD10
+    bool "LCD Type 1.0"
+    help 
+        select LCD 1.0 TYPE
+endchoice
+
+
+
 endif
Index: linux-2.6.29/drivers/input/touchscreen/Makefile
===================================================================
--- linux-2.6.29.orig/drivers/input/touchscreen/Makefile	2010-04-07 12:29:34.000000000 -0400
+++ linux-2.6.29/drivers/input/touchscreen/Makefile	2010-04-07 12:29:36.000000000 -0400
@@ -6,6 +6,10 @@
 
 wm97xx-ts-y := wm97xx-core.o
 
+#ifeq ($(CONFIG_ARCH_TCC),y)
+#$(shell ln -fsn $(CONFIG_TCC_STRING) $(srctree)/drivers/input/touchscreen/tcc) 
+#endif
+obj-$(CONFIG_TOUCHSCREEN_TCCTS)		+= tcc_ts.o
 obj-$(CONFIG_TOUCHSCREEN_ADS7846)	+= ads7846.o
 obj-$(CONFIG_TOUCHSCREEN_ATMEL_TSADCC)	+= atmel_tsadcc.o
 obj-$(CONFIG_TOUCHSCREEN_BITSY)		+= h3600_ts_input.o
Index: linux-2.6.29/drivers/input/touchscreen/tcc_ts.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/input/touchscreen/tcc_ts.c	2010-04-07 13:00:44.000000000 -0400
@@ -0,0 +1,695 @@
+/* linux/drivers/input/touchscreen/tcc-ts.c
+ *
+ * $Id: tcc-ts.c,v 1.3 2007/06/20 04:02:28 ihlee215 Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/init.h>
+#include <linux/serio.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/sched.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <mach/hardware.h>
+
+#include <bsp.h>
+#include <mach/irqs.h>
+
+#define CONFIG_TOUCHSCREEN_TCC_DEBUG
+//#undef CONFIG_TOUCHSCREEN_TCC_DEBUG
+
+/* For ts->dev.id.version */
+#define TCC_TSVERSION	0x0001
+#define IRQ_NO      INT_EI2
+
+#define ECFLG_END           (1<<15)
+#define ENABLE_START_EN (1<<0)
+
+
+// ADCTSC
+#define UD_SEN_DOWN     (0<<8)
+#define YM_SEN_EN           (1<<7)
+#define YP_SEN_DIS          (1<<6)
+#define XM_SEN_DIS          (0<<5)
+#define XP_SEN_DIS          (1<<4)
+#define PULL_UP_EN          (0<<3)
+#define AUTO_PST_DIS        (0<<2)
+#define AUTO_PST_EN         (1<<2)
+#define XY_PST_WAITINT      (3<<0)
+#define ADCTSC_AUTO_ADC4 AUTO_PST_EN
+#define ADCTSC_AUTO_ADC5 AUTO_PST_DIS
+
+#define TOUCH_COLLECT_NR        16  // (TOUCH_COLLECT_NR-TOUCH_VALID_VALUE) must be even
+#define TOUCH_VALID_VALUE       2  // among COLLECT_NR samples, OK should be over
+#if defined(CONFIG_LCD11)
+#define MAX_X   3850 
+#define MIN_X   240
+#define MAX_Y   3700
+#define MIN_Y   410
+#elif defined(CONFIG_LCD01)
+#define MAX_X   3830
+#define MIN_X   250
+#define MAX_Y   3830
+#define MIN_Y   440
+#elif defined(CONFIG_LCD10)
+#define MAX_X   3871
+#define MIN_X   204
+#define MAX_Y   3660
+#define MIN_Y   414
+#endif
+
+#define PEN_DOWN 1
+#define PEN_RELEASE 0
+
+#define ADCTSC_WAIT_PENDOWN (UD_SEN_DOWN |YM_SEN_EN|YP_SEN_DIS|XM_SEN_DIS|XP_SEN_DIS|PULL_UP_EN|AUTO_PST_DIS|XY_PST_WAITINT)
+
+#define ADCCON      (0x00)
+#define ADCTSC      (0x04)
+#define ADCDLY      (0x08)
+#define ADCDAT0     (0x0C)
+#define ADCDAT1     (0x10)
+#define ADCUPDN     (0x14)
+#define ADCCLRINT   (0x18)
+#define ADCCLRUPDN  (0x20)
+
+#if 0
+//#define dbg(x...) printk(KERN_DEBUG "tcc uart: ");
+#define dbg printk
+#else /* no debug */
+#define dbg(x...) do {} while(0)
+#endif
+
+
+
+/*
+ * Definitions & global arrays.
+ */
+static char *tcc_ts_name = "tcc-ts";
+
+static struct timer_list ts_timer;
+
+
+/*
+ * Per-touchscreen data.
+ */
+struct tcc_ts {
+	struct input_dev *dev;
+	long x;
+	long y;
+	char phys[32];
+    int pen_status, opened, running, valid;
+    struct mutex mutex;
+	struct work_struct work_q;
+};
+
+static struct tcc_ts *ts;
+static void __iomem *ts_base;
+
+#define D_XPDATA_MASK12(n)  ((n)&0xfff)
+#define D_YPDATA_MASK12(n)  ((n)&0xfff)
+#define ENABLE_START_EN (1<<0)
+
+int tea_tch_readadc_auto(int *x, int *y)
+{
+    writel(ADCTSC_AUTO_ADC4, ts_base + ADCTSC);
+    writel(readl(ts_base + ADCCON) | ENABLE_START_EN, ts_base + ADCCON);
+    
+    while(readl(ts_base + ADCCON) & ENABLE_START_EN)
+    {
+        ndelay(1);
+    }
+    while (!(readl(ts_base + ADCCON) & ECFLG_END))
+    {   // Wait for ADC Conversion Ended
+        ndelay(1);
+    }
+
+	*x = D_XPDATA_MASK12(readl(ts_base + ADCDAT0));
+	*y = D_YPDATA_MASK12(readl(ts_base + ADCDAT1));
+
+    writel(ADCTSC_AUTO_ADC5, ts_base + ADCTSC);
+
+    return 1;
+}
+
+#if 1
+int tea_tch_readadc_test(int *x, int *y, int *xm, int *ym)
+{
+    
+    unsigned int tmp;
+    volatile PGPIO pGPIO = (volatile PGPIO)tcc_p2v(HwGPIO_BASE);
+
+////////////////read x
+    writel(Hw3|Hw0, ts_base + ADCTSC);
+
+    //g_pADCReg->ADCTSC = Hw3|Hw0;
+    //gpio setting - 30 high
+    BITCLR(pGPIO->GPEFN3 ,Hw32-Hw24);//gpio E31, E30 using GPIO Mode
+    BITSET(pGPIO->GPEEN, Hw32-Hw30);//gpio E31, E30 using GPIO Output Mode
+    BITSET(pGPIO->GPEDAT, Hw31); // E31 High
+    BITCLR(pGPIO->GPEDAT, Hw30); // E30 Low
+    
+    tmp = readl(ts_base + ADCCON);
+    tmp &= ~(Hw5|Hw4|Hw3);
+    tmp |= (Hw5|Hw3);
+    writel(tmp, ts_base + ADCCON);
+    //BITCSET(readl(ts_base + ADCCON), Hw6-Hw3,  Hw5|Hw3);
+
+    writel(readl(ts_base + ADCCON) | ENABLE_START_EN, ts_base + ADCCON);
+
+    //g_pADCReg->ADCCON |= ENABLE_START_EN;   // ADC Conversion Start
+ 
+    while(readl(ts_base + ADCCON) & ENABLE_START_EN)
+    {
+        ndelay(1);
+    }
+    while (!(readl(ts_base + ADCCON) & ECFLG_END))
+    {   // Wait for ADC Conversion Ended
+        ndelay(1);
+    }
+
+    //read x value
+	*x = D_XPDATA_MASK12(readl(ts_base + ADCDAT0));
+    BITCSET(pGPIO->GPEFN3 ,Hw32-Hw16, Hw28|Hw24|Hw20|Hw16);
+    writel(ADCTSC_AUTO_ADC5, ts_base + ADCTSC);
+
+
+////////////////read y
+    writel(Hw3|Hw1, ts_base + ADCTSC);
+    //gpio setting - 31,28 high
+    BITCLR(pGPIO->GPEFN3 ,Hw24-Hw16);//gpio E29, E28 using GPIO Mode
+    BITSET(pGPIO->GPEEN, Hw30-Hw28);//gpio E29, E28 using GPIO Output Mode
+    BITSET(pGPIO->GPEDAT, Hw29); //
+    BITCLR(pGPIO->GPEDAT, Hw28); //
+
+    tmp = readl(ts_base + ADCCON);
+    tmp &= ~(Hw5|Hw4|Hw3);
+    tmp |= (Hw5|Hw4|Hw3);
+    writel(tmp, ts_base + ADCCON);
+
+    //BITCSET(readl(ts_base + ADCCON),Hw6-Hw3,  Hw5|Hw4|Hw3);
+    
+    writel(readl(ts_base + ADCCON) | ENABLE_START_EN, ts_base + ADCCON);
+
+    while(readl(ts_base + ADCCON) & ENABLE_START_EN)
+    {   // Wait for Start Bit Cleared
+        ndelay(1);
+    }
+
+    while (!(readl(ts_base + ADCCON) & ECFLG_END))
+    {   // Wait for ADC Conversion Ended
+        ndelay(1);
+    }
+    //read y value
+	*y = D_YPDATA_MASK12(readl(ts_base + ADCDAT1));
+
+    writel(ADCTSC_AUTO_ADC5, ts_base + ADCTSC);
+    BITCSET(pGPIO->GPEFN3 ,Hw32-Hw16, Hw28|Hw24|Hw20|Hw16);
+
+////////////////read xp
+    writel(Hw3|Hw1, ts_base + ADCTSC);
+
+    //g_pADCReg->ADCTSC = Hw3|Hw0;
+    //gpio setting - 30 high
+
+    BITCLR(pGPIO->GPEFN3 ,Hw27-Hw20);//gpio E30, E29 GPIO Mode
+    BITSET(pGPIO->GPEEN, Hw31-Hw29); //E30, E29 OUTPUT Mode
+    BITSET(pGPIO->GPEDAT, Hw29); // High
+    BITCLR(pGPIO->GPEDAT, Hw30); // Low
+
+    tmp = readl(ts_base + ADCCON);
+    tmp &= ~(Hw5|Hw4|Hw3);
+    tmp |= (Hw5);
+    writel(tmp, ts_base + ADCCON);
+    //BITCSET(readl(ts_base + ADCCON), Hw6-Hw3,  Hw5|Hw3);
+
+    writel(readl(ts_base + ADCCON) | ENABLE_START_EN, ts_base + ADCCON);
+
+    //g_pADCReg->ADCCON |= ENABLE_START_EN;   // ADC Conversion Start
+ 
+    while(readl(ts_base + ADCCON) & ENABLE_START_EN)
+    {
+        ndelay(1);
+    }
+    while (!(readl(ts_base + ADCCON) & ECFLG_END))
+    {   // Wait for ADC Conversion Ended
+        ndelay(1);
+    }
+
+    //read x value
+	*xm = D_XPDATA_MASK12(readl(ts_base + ADCDAT0));
+    BITCSET(pGPIO->GPEFN3 ,Hw32-Hw16, Hw28|Hw24|Hw20|Hw16);
+    writel(ADCTSC_AUTO_ADC5, ts_base + ADCTSC);
+
+
+////////////////read ym
+    writel(Hw3|Hw1, ts_base + ADCTSC);
+    //gpio setting - 31,28 high
+    BITCLR(pGPIO->GPEFN3 ,Hw27-Hw20);//gpio E30, E29 GPIO Mode
+    BITSET(pGPIO->GPEEN, Hw31-Hw29); //E30, E29 OUTPUT Mode
+    BITSET(pGPIO->GPEDAT, Hw29); // High
+    BITCLR(pGPIO->GPEDAT, Hw30); // Low
+
+    tmp = readl(ts_base + ADCCON);
+    tmp &= ~(Hw5|Hw4|Hw3);
+    tmp |= (Hw5|Hw4|Hw3);
+    writel(tmp, ts_base + ADCCON);
+
+    //BITCSET(readl(ts_base + ADCCON),Hw6-Hw3,  Hw5|Hw4|Hw3);
+    
+    writel(readl(ts_base + ADCCON) | ENABLE_START_EN, ts_base + ADCCON);
+
+    while(readl(ts_base + ADCCON) & ENABLE_START_EN)
+    {   // Wait for Start Bit Cleared
+        ndelay(1);
+    }
+
+    while (!(readl(ts_base + ADCCON) & ECFLG_END))
+    {   // Wait for ADC Conversion Ended
+        ndelay(1);
+    }
+    //read y value
+	*ym = D_YPDATA_MASK12(readl(ts_base + ADCDAT1));
+
+    writel(ADCTSC_AUTO_ADC5, ts_base + ADCTSC);
+    BITCSET(pGPIO->GPEFN3 ,Hw32-Hw16, Hw28|Hw24|Hw20|Hw16);
+
+    dbg("[TOUCH]     RAW:(x=%d, y=%d, xp=%d, yp=%d)\r\n", *x, *y, *xm, *ym);
+    return 1;
+
+}
+#endif
+
+
+void tca_touchbubblesort(unsigned int Number[],unsigned int num) 
+{
+	int i,j;
+	unsigned int temp;
+	for(i=0 ; i<(int)(num-1) ; i++)   
+	{    
+		for(j=i+1;j<(int)num;j++)
+		{ 
+			if(Number[i]>Number[j]) 
+			{ 
+				temp   = Number[i]; 
+				Number[i] = Number[j]; 
+				Number[j] = temp;
+			}
+		} 
+	}
+}
+
+
+int tca_getrawdata(int * x, int * y)
+{
+    unsigned int  i;
+    unsigned int r_x[TOUCH_COLLECT_NR], r_y[TOUCH_COLLECT_NR];
+    unsigned long  x_tol, y_tol;
+    unsigned int m_pos_x, m_pos_y;
+    unsigned int validcnt=0;
+    unsigned int index;
+
+    m_pos_x = m_pos_y = 0;
+
+    for(i = 0; i < TOUCH_COLLECT_NR; i ++)
+    {
+        int x, y, xp, yp;
+        //tea_tch_readadc_auto(&x, &y );
+        tea_tch_readadc_test(&x, &y, &xp, &yp);
+        if((x <= MAX_X && x >= MIN_X)&&(y <= MAX_Y || y >= MIN_Y) && (xp > 100) && (yp > 100))
+        {
+            r_x[validcnt]=x;
+            r_y[validcnt]=y;
+            validcnt++;
+        }
+    }
+    tca_touchbubblesort(r_x,TOUCH_COLLECT_NR);
+    tca_touchbubblesort(r_y,TOUCH_COLLECT_NR);
+
+    x_tol = y_tol = 0; //sum the coordinate values
+    index = (TOUCH_COLLECT_NR-TOUCH_VALID_VALUE)>>1;
+
+    for(i=index;i<(index+TOUCH_VALID_VALUE);++i)
+    {
+        x_tol += r_x[i];
+        y_tol += r_y[i];
+    }
+    m_pos_x = x_tol/TOUCH_VALID_VALUE;
+    m_pos_y = y_tol/TOUCH_VALID_VALUE;
+    dbg("m_pos_x=%d, m_pos_y=%d\n", m_pos_x, m_pos_y);
+
+    *x = m_pos_x;
+    *y = m_pos_y;
+    if((*x <= MAX_X && *x >= MIN_X)&&(*y <= MAX_Y && *y >= MIN_Y))
+    {
+        return 0;
+    }
+    else
+    {
+        return -1;
+    }
+}
+
+
+void tca_tch_poweroff(void)
+{
+    writel(Hw0, ts_base + ADCCLRINT);
+    writel(Hw0, ts_base + ADCCLRUPDN);
+    writel(ADCTSC_WAIT_PENDOWN, ts_base + ADCTSC);
+}
+
+
+
+
+static inline void tcc_pen_release(struct tcc_ts* ts_data, struct input_dev *dev)
+{
+    if (ts_data->pen_status != PEN_RELEASE) {
+        ts_data->pen_status = PEN_RELEASE;
+
+        input_report_key(dev, BTN_TOUCH, PEN_RELEASE);
+        input_sync(dev);
+        /* wake_up_interruptible(&ts->wait_q); */
+    }
+    dbg("PEN UP\n");
+}
+
+static inline void tcc_pen_pressure(struct tcc_ts* ts_data, struct input_dev *dev)
+{
+    ts_data->pen_status = PEN_DOWN;
+
+    input_report_key(dev, BTN_TOUCH, PEN_DOWN);
+    input_report_abs(dev, ABS_X, ts->x);
+    input_report_abs(dev, ABS_Y, ts->y);
+    input_sync(dev);
+
+    dbg("PEN DOWN (%d : %d)\n", ts_data->x, ts_data->y);
+
+    /* wake_up_interruptible(&ts->wait_q); */
+}
+
+#define ADCDAT0_XPDATA_MASK	(0x03FF)
+#define ADCDAT1_YPDATA_MASK	(0x03FF)
+
+static void ts_fetch_thread(struct work_struct *work)
+{
+    struct tcc_ts* ts_data = container_of(work, struct tcc_ts, work_q);
+    struct input_dev *dev = ts->dev;
+    int flag, valid;
+    int updown;
+	unsigned long data0;
+	unsigned long data1;
+    dbg("%s\n", __func__);
+
+    ts_data->running = 1;
+
+    dbg("(work_q)disable_irq\n");
+    //disable_irq(IRQ_NO);
+
+    data0 = readl(ts_base + ADCDAT0);
+    data1 = readl(ts_base + ADCDAT1);
+
+    updown = (!(data0 & Hw15)) && (!(data1 & Hw15)); 
+
+    if(!updown){
+#if 0
+        tcc_pen_release(ts_data, dev);
+        ts_data->running = 0;
+        dbg("(work_q_1)enable_irq\n");
+        enable_irq(IRQ_NO);
+    } else {
+        tcc_pen_pressure(ts_data, dev);
+
+        ts_timer.expires = jiffies + 1;
+        add_timer(&ts_timer);
+
+#else
+        tcc_pen_release(ts_data, dev);
+        ts_data->running = 0;
+        dbg("(work_q_1)enable_irq\n");
+        enable_irq(IRQ_NO);
+    }else {
+        flag = tca_getrawdata((int *)&(ts_data->x),(int *)&(ts_data->y));
+        dbg(" (%d, %d)\n", ts_data->x, ts_data->y);
+        tca_tch_poweroff();
+
+        ndelay(1);
+
+        valid = ts_data->x | ts_data->y;
+
+        if ((flag == 0) && valid) {
+            tcc_pen_pressure(ts_data, dev);
+            ts_timer.expires = jiffies + 1;
+            add_timer(&ts_timer);
+        } else {
+            tcc_pen_release(ts_data, dev);
+            ts_data->running = 0;
+            dbg("(work_q_2)enable_irq\n");
+            enable_irq(IRQ_NO);
+        }
+#endif
+    }
+}
+
+
+static irqreturn_t tcc_ts_interrupt(int irqno, void *param)
+{
+    //struct tcc_ts *ts_data = (struct tcc_ts *)param;
+    dbg("%s\n", __func__);
+
+    if (ts->running == 0) {
+        ts->running = 1;
+        dbg("(irq)disable_irq\n");
+        disable_irq(IRQ_NO);
+        ts_timer.expires = jiffies;
+        add_timer(&ts_timer);
+    }
+
+    return IRQ_HANDLED;
+
+}
+
+static void ts_timer_handler(unsigned long data)
+{
+    dbg("%s\n", __func__);
+    if(ts->opened){
+        if (schedule_work(&(ts->work_q)) == 0 ) {
+            dbg("cannot schedule work !!!\n");
+            ts->running = 0;
+            //dbg("(timer)enable_irq\n");
+            enable_irq(IRQ_NO);
+
+        }
+    }else {
+        //dbg("(timer)disable_irq\n");
+        disable_irq(IRQ_NO);
+    }
+}
+
+#define ADC_DELAY(n)        ((n+1)&0xffff)
+#define RESSEL_12BIT        (1<<16)
+#define PRESCALER_EN        (1<<14)
+#define PRESCALER_VAL(n)    (((n)&0xff)<<6)
+#define CLEAR_ADC_INT       (0xff)
+#define CLEAR_ADCWK_INT (0xff)
+
+
+/*
+ * The functions for inserting/removing us as a module.
+ */
+static int __devinit tcc_ts_probe(struct platform_device *pdev)
+{
+	struct input_dev *input_dev;
+    //struct resource *res;
+	int err = -ENOMEM;
+
+    //PGPIO       pGPIO = (GPIO *)&HwGPIO_BASE;
+    //PPIC        pPIC = (PIC *)&HwPIC_BASE;
+    volatile PGPIO pGPIO = (volatile PGPIO)tcc_p2v(HwGPIO_BASE);
+    volatile PPIC pPIC = (volatile PPIC)tcc_p2v(HwPIC_BASE);
+
+    
+
+    dbg("%s: probe=%p\n", __func__, pdev);   
+
+    tca_ckc_setperi(PERI_ADC,ENABLE,390000,PCDIRECTPLL3);
+    tca_ckc_setiobus(RB_TSADCCONTROLLER,1);
+
+    ts_base = (void __iomem *)tcc_p2v(HwTSADC_BASE); 
+
+    if (ts_base == NULL) {     
+        dbg("failed ioremap()\n"); 
+        return -ENOMEM;
+    }
+
+    BITCSET(pGPIO->GPEFN3, Hw32-Hw16, (Hw28|Hw24|Hw20|Hw16));
+
+    BITCLR(pGPIO->GPEPD1, Hw32-Hw25);
+
+
+    writel(ADC_DELAY(10000), ts_base + ADCTSC);
+    writel(RESSEL_12BIT | PRESCALER_EN | PRESCALER_VAL(12), ts_base + ADCCON);
+    writel(ADCTSC_WAIT_PENDOWN, ts_base + ADCTSC);
+    writel(CLEAR_ADC_INT, ts_base + ADCCLRINT);
+    writel(CLEAR_ADCWK_INT, ts_base + ADCCLRUPDN);
+ 
+    BITCSET(pGPIO->EINTSEL0, Hw22-Hw16, 58<<16);
+    BITSET(pPIC->INTMSK0, 1<<IRQ_NO);
+    BITSET(pPIC->POL0, 1<<IRQ_NO);
+    //BITCLR(pPIC->MODE0, 1<<IRQ_NO);
+
+
+
+	ts = kzalloc(sizeof(struct tcc_ts), GFP_KERNEL);
+	input_dev = input_allocate_device();
+
+	if (!ts || !input_dev) {
+		err = -ENOMEM;
+		goto fail1;
+	}
+
+    ts->running = 0;
+    ts->opened = 1;
+    ts->pen_status = PEN_RELEASE;
+
+	ts->dev = input_dev;
+
+	sprintf(ts->phys, "touchscreen");
+
+	ts->dev->name = tcc_ts_name;
+	ts->dev->phys = ts->phys;
+	ts->dev->id.bustype = BUS_RS232;
+	ts->dev->id.vendor = 0xDEAD;
+	ts->dev->id.product = 0xBEEF;
+	ts->dev->id.version = TCC_TSVERSION;
+    input_dev->dev.parent = &pdev->dev;
+
+	ts->dev->evbit[0] = BIT(EV_SYN) | BIT(EV_KEY) | BIT(EV_ABS);
+	//ts->dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	ts->dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+
+	input_set_abs_params(ts->dev, ABS_X, MIN_X, MAX_X, 0, 0);
+	input_set_abs_params(ts->dev, ABS_Y, MIN_Y, MAX_Y, 0, 0);
+	input_set_abs_params(ts->dev, ABS_PRESSURE, 0, 1, 0, 0);
+
+    INIT_WORK(&(ts->work_q), ts_fetch_thread);
+    mutex_init(&(ts->mutex));
+
+    init_timer(&ts_timer);
+    ts_timer.data = (unsigned long)ts;
+    ts_timer.function = ts_timer_handler;
+
+	/* Get irqs */
+	if (request_irq(IRQ_NO, tcc_ts_interrupt, IRQF_DISABLED, "tcc_ts", ts)) {
+		printk(KERN_ERR "tcc_ts.c: Could not allocate ts IRQ_NO !\n");
+        err = -EBUSY;
+        goto fail1;
+	}
+
+    tca_tch_poweroff();
+
+	printk(KERN_INFO "%s got loaded successfully.\n", tcc_ts_name);
+
+	/* All went ok, so register to the input system */
+	err = input_register_device(ts->dev);
+    if (err)
+        goto fail2;
+
+	return 0;
+
+fail2: free_irq(IRQ_NO, ts);
+fail1:	input_free_device(input_dev);
+	kfree(ts);
+	return err;
+}
+
+static int tcc_ts_remove(struct platform_device *dev)
+{
+	printk(KERN_INFO "tcc_ts_remove() of TS called !\n");
+
+    ts->opened = 0;
+    dbg("(remove)disable_irq\n");
+    disable_irq(IRQ_NO);
+    del_timer_sync(&ts_timer);
+    flush_scheduled_work();
+
+	free_irq(IRQ_NO, ts->dev);
+
+	input_unregister_device(ts->dev);
+    kfree(ts);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+#if 1
+
+static int tcc_ts_suspend(struct platform_device *dev, pm_message_t state)
+{
+	return 0;
+}
+
+static int tcc_ts_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+#endif
+#else
+#define tcc_ts_suspend NULL
+#define tcc_ts_resume  NULL
+#endif
+
+static struct platform_driver tcc_ts_driver = {
+       .probe          = tcc_ts_probe,
+       .remove         = tcc_ts_remove,
+       .suspend        = tcc_ts_suspend,
+       .resume         = tcc_ts_resume,
+       .driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "tcc-ts",
+	},
+};
+
+static char banner[] __initdata = KERN_INFO "Telechips Touchscreen driver, (c) 2009 Telechips\n";
+
+static int __init tcc_ts_init(void)
+{
+	printk(banner);
+	return platform_driver_register(&tcc_ts_driver);
+}
+
+static void __exit tcc_ts_exit(void)
+{
+	platform_driver_unregister(&tcc_ts_driver);
+}
+
+module_init(tcc_ts_init);
+module_exit(tcc_ts_exit);
+
+MODULE_AUTHOR("linux <linux@telechips.com>");
+MODULE_DESCRIPTION("tcc adc touchscreen driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.29/drivers/media/video/Kconfig
===================================================================
--- linux-2.6.29.orig/drivers/media/video/Kconfig	2010-04-07 12:29:35.000000000 -0400
+++ linux-2.6.29/drivers/media/video/Kconfig	2010-04-07 12:29:36.000000000 -0400
@@ -473,6 +473,8 @@
 
 endmenu # encoder / decoder chips
 
+source "drivers/media/video/tcccam/Kconfig"
+
 config VIDEO_VIVI
 	tristate "Virtual Video Driver"
 	depends on VIDEO_DEV && VIDEO_V4L2 && !SPARC32 && !SPARC64
Index: linux-2.6.29/drivers/media/video/Makefile
===================================================================
--- linux-2.6.29.orig/drivers/media/video/Makefile	2010-04-07 12:29:35.000000000 -0400
+++ linux-2.6.29/drivers/media/video/Makefile	2010-04-07 12:29:36.000000000 -0400
@@ -23,6 +23,8 @@
   obj-$(CONFIG_VIDEO_DEV) += v4l1-compat.o
 endif
 
+obj-$(CONFIG_VIDEO_TCCXX_CAMERA) += tcccam/
+
 obj-$(CONFIG_VIDEO_TUNER) += tuner.o
 
 obj-$(CONFIG_VIDEO_BT848) += bt8xx/
Index: linux-2.6.29/drivers/media/video/tcccam/Kconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/tcccam/Kconfig	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,44 @@
+config VIDEO_TCCXX_CAMERA
+	tristate "Telechips TCCXXX Camera support (EXPERIMENTAL)"
+	select VIDEOBUF_GEN
+	select VIDEOBUF_DMA_SG
+	select VIDEOBUF_VMALLOC
+	depends on VIDEO_DEV
+	help
+	  V4L2 camera driver support for TCCXXX.
+	
+config VIDEO_CAMERA_SENSOR
+	tristate "CAMERA sensor support"
+	depends on VIDEO_TCCXX_CAMERA
+	help
+	   camera sensor support
+
+config VIDEO_CAMERA_SENSOR_MT9D112
+	tristate "MT9D112 2MP-sensor support"
+	depends on VIDEO_CAMERA_SENSOR
+	help
+	   camera sensor support for 2MP
+
+config VIDEO_CAMERA_SENSOR_MT9D111
+	tristate "MT9D111 2MP-sensor support"
+	depends on VIDEO_CAMERA_SENSOR
+	help
+	   camera sensor support for 2MP
+
+config VIDEO_CAMERA_SENSOR_S5K4BAFB
+	tristate "S5K4BAFB 2MP-sensor support"
+	depends on VIDEO_CAMERA_SENSOR
+	help
+	   camera sensor support for 2MP
+
+config VIDEO_CAMERA_SENSOR_MV9317
+	tristate "MV9317 3MP-sensor support"
+	depends on VIDEO_CAMERA_SENSOR
+	help
+	   camera sensor support for 3MP
+
+config VIDEO_CAMERA_SENSOR_MT9P111
+	tristate "MT9P111 5MP-sensor support"
+	depends on VIDEO_CAMERA_SENSOR
+	help
+	   camera sensor support for 5MP	   
Index: linux-2.6.29/drivers/media/video/tcccam/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/tcccam/Makefile	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,13 @@
+# Makefile for TCCxxx camera driver
+
+obj-$(CONFIG_VIDEO_TCCXX_CAMERA) += camera_core.o tcc_cam.o cam.o tdd_cif.o
+obj-$(CONFIG_VIDEO_CAMERA_SENSOR) += sensor_if.o tcc_cam_i2c.o
+obj-$(CONFIG_VIDEO_CAMERA_SENSOR_MT9D111) += mt9d111_2mp.o
+obj-$(CONFIG_VIDEO_CAMERA_SENSOR_MT9D112) += mt9d112_2mp.o
+obj-$(CONFIG_VIDEO_CAMERA_SENSOR_MV9317) += mv9317_3mp.o
+obj-$(CONFIG_VIDEO_CAMERA_SENSOR_S5K4BAFB) += s5k4bafb_2mp.o
+obj-$(CONFIG_VIDEO_CAMERA_SENSOR_MT9P111) += mt9p111_5mp.o
+
+#tcc78xxcamera-objs := $(objs-yy)
+
+EXTRA_CFLAGS = -I$(src)/..
Index: linux-2.6.29/drivers/media/video/tcccam/cam.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/tcccam/cam.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1 @@
+/*************************************************************************    Telechips Multi Media Player*    ------------------------------------------------**    FUNCTION    : CAMERA INTERFACE API*    MODEL        : DMP*    CPU NAME    : TCCXXX*    SOURCE        : cam.c**    START DATE    : 2006. 4. 17.*    MODIFY DATE :*    DEVISION    : DEPT. SYSTEM 3-2 TEAM*                : TELECHIPS, INC.************************************************************************/#include <linux/delay.h>#include <mach/hardware.h>#include <asm/io.h>//(CONFIG_ARCH_TCC8900)#include <bsp.h>#include "cam.h"#include "cam_reg.h"#include "sensor_if.h"/************************************************************    Function of    **    **    Input    : *    Output    : *    Return    : **    Description    : **********************************************************/void CIF_Open(void){#if defined(CONFIG_ARCH_TCC8900)	BITCLR(HwDDI_CONFIG->PWDN, HwDDIC_PWDN_CIF);#endif//PLL : 154Mhz  //192Mhz#if defined(SENSOR_2M)//(CONFIG_ARCH_TCC8900)	#if defined(CONFIG_VIDEO_CAMERA_SENSOR_S5K4BAFB)	tca_ckc_setperi(PERI_CIFMC, ENABLE, 250000, DIRECTPLL0);	tca_ckc_setperi(PERI_CIFSC, ENABLE, 1000000, DIRECTPLL0);//	#elif defined(CONFIG_VIDEO_CAMERA_SENSOR_MT9D111)	//@storm//	tca_ckc_setperi(PERI_CIFMC, ENABLE, 400000, DIRECTPLL0);//	tca_ckc_setperi(PERI_CIFSC, ENABLE, 800000, DIRECTPLL0);		#elif defined(CONFIG_VIDEO_CAMERA_SENSOR_MT9D112)	//@storm//	tca_ckc_setperi(PERI_CIFMC, ENABLE, 245000, DIRECTPLL0);	tca_ckc_setperi(PERI_CIFMC, ENABLE, 400000, DIRECTPLL0);	tca_ckc_setperi(PERI_CIFSC, ENABLE, 2000000, DIRECTPLL0);		#else		tca_ckc_setperi(PERI_CIFMC, ENABLE, 400000, DIRECTPLL0);	tca_ckc_setperi(PERI_CIFSC, ENABLE, 800000, DIRECTPLL0);	#endif	#elif defined(SENSOR_3M)//(CONFIG_ARCH_TCC8900)	//JAZZ: 80Mhz:27.8fps, 70Mhz:23.8fps	tca_ckc_setperi(PERI_CIFMC, ENABLE, 900000/*500000*/, DIRECTPLL3);	tca_ckc_setperi(PERI_CIFSC, ENABLE, 900000, DIRECTPLL3);#elif defined(SENSOR_5M)	tca_ckc_setperi(PERI_CIFMC, ENABLE, 160000, DIRECTPLL2);	tca_ckc_setperi(PERI_CIFSC, ENABLE, 1660000, DIRECTPLL3);#endif//(CONFIG_ARCH_TCC8900)	BITSET(HwDDI_CONFIG->SWRESET, HwDDIC_SWRESET_CIF);   // Reset	BITCLR(HwDDI_CONFIG->SWRESET, HwDDIC_SWRESET_CIF);  // Normal}/************************************************************    Function of    **    **    Input    : *    Output    : *    Return    : **    Description    : **********************************************************/void CIF_Close(void){//(CONFIG_ARCH_TCC8900)	BITCLR(HwCKC->PCLK_CIFMC, Hw28);  // Master clk	BITCLR(HwCKC->PCLK_CIFSC, Hw28);  // Scaler clk		BITSET(HwDDI_CONFIG->PWDN, HwDDIC_PWDN_CIF);}/************************************************************    Function of    **    **    Input    : *    Output    : *    Return    : **    Description    : **********************************************************/void CIF_ONOFF(unsigned int uiOnOff){//(CONFIG_ARCH_TCC8900)	if(uiOnOff == ON)	{		BITCSET(HwCIF->ICPCR1, HwICPCR1_ON, (uiOnOff << 31));	}	else if(uiOnOff == OFF)	{		BITCSET(HwCIF->ICPCR1, HwICPCR1_ON, (uiOnOff << 31));	}}/************************************************************    Function of    ***    Input    : *    Output    : *    Return    : **    Description    : **********************************************************/void CIF_WaitFrameSync(unsigned int exp_timer){	unsigned int cnt=0;	//(CONFIG_ARCH_TCC8900)	while((HwCIF->CIRQ & HwCIRQ_SOF) != HwCIRQ_SOF)	{		msleep(1);		cnt++;		if(cnt>exp_timer)			break;	}}void CIF_OpStop(void){	//CIF_WaitFrameSync(200);	mdelay(20);	CIF_ONOFF(OFF);//(CONFIG_ARCH_TCC8900)	BITSET(HwDDI_CONFIG->SWRESET, HwDDIC_SWRESET_CIF);   // Reset	BITCLR(HwDDI_CONFIG->SWRESET, HwDDIC_SWRESET_CIF);  // Normal}/* end of file */
\ No newline at end of file
Index: linux-2.6.29/drivers/media/video/tcccam/cam.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/tcccam/cam.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1 @@
+/*************************************************************************   Telechips Multi Media Player*    ------------------------------------------------**   FUNCTION    : CAMERA INTERFACE API*   MODEL       : DMP*   CPU NAME    : TCCXXX*   SOURCE      : cam.h**   START DATE  : 2008. 4. 17.*   MODIFY DATE :*   DEVISION    : DEPT. SYSTEM 3-2 TEAM*               : TELECHIPS, INC.************************************************************************/#ifndef _CAM_H_#define _CAM_H_//CIF_SET_INFO#define SET_CIF_BYPASS_MODE             0x00000001#define SET_CIF_BYPASS_BUS              0x00000002#define SET_CIF_COLOR_PATTERN           0x00000004#define SET_CIF_PATTERN_FORMAT          0x00000008#define SET_CIF_RGB_MODE                0x00000010#define SET_CIF_RGBBIT_MODE             0x00000020#define SET_CIF_COLOR_SEQUENCE          0x00000040#define SET_CIF_BUS_ORDER               0x00000080#define SET_CIF_ALL                     0x000000FF//CIF_SET_INFO_II #define SET_CIF_PWDN                    0x00000001#define SET_CIF_BYPASS_SCALER           0x00000002#define SET_CIF_PXCLK_POL               0x00000004#define SET_CIF_SKPF                    0x00000008#define SET_CIF_M42_FC                  0x00000010#define SET_CIF_C656                    0x00000020#define SET_CIF_II_ALL                  0x0000003F#define SET_CIF_TRANSFER_MODE           0x00000001#define SET_CIF_TRANSFER_BURST          0x00000002#define SET_CIF_TRANSFER_LOCK           0x00000004#define SET_CIF_TRANSFER_ALL            0x00000007#define SET_CIF_OVERLAY_COUNT           0x00000001#define SET_CIF_OVERLAY_METHOD          0x00000002#define SET_CIF_OVERLAY_XOR0            0x00000004#define SET_CIF_OVERLAY_XOR1            0x00000008#define SET_CIF_OVERLAY_ALPHA0          0x00000010#define SET_CIF_OVERLAY_ALPHA1          0x00000020#define SET_CIF_OVERLAY_ALL             0x0000003F#define SET_CIF_OVERLAY_KEY             0x00000001#define SET_CIF_OVERLAY_MASKKEY         0x00000002#define SET_CIF_OVERLAYKEY_ALL          0x00000003#define SET_CIF_ALPHA_ENABLE            0x00000001#define SET_CIF_ALPHA_DISABLE           0x00000002#define SET_CIF_CHROMA_ENABLE           0x00000004#define SET_CIF_CHROMA_DISABLE          0x00000008#define SET_CIF_OVERLAY_ENABLE          0x00000010#define SET_CIF_OVERLAY_DISABLE         0x00000020#define SET_CIF_COLOR_CONV_ENABLE       0x00000040#define SET_CIF_COLOR_CONV_DISABLE      0x00000080//#define SET_CIF_OVERLAY_RGB_MODE      0x00000100#define SET_CIF_COLOR_MODE_RGB          0x00000200#define SET_CIF_COLOR_MODE_YUV          0x00000400#define SET_CIF_CR2Y_FMT                0x00000001#define SET_CIF_CR2Y_EN                 0x00000002#define SET_CIF_CR2Y_ALL                0x00000003#define INPUT_IMG                       0x00000001#define OVERLAY_IMG                     0x00000002#define IN_IMG_ROLLING                  0x00000004#define IN_ENC_START_ADDR               0x00000008#ifndef _82x  // CIF_API_INTERRUPT_FEATURE/////////////////////////////////////////////////////////////////////////////// CIF_SET_INTERRUPT///////////////////////////////////////////////////////////////////////////////IEN     Hw31  Interrupt Enable  0:interrupt disable, 1:interrupt enable      #define  SET_CIF_INT_ENABLE                         0x00000001#define  SET_CIF_INT_DISABLE                        0x00000002//URV    Hw30  Update Register in VSYNC   0:Register is update without VSYNC , 1:When VSYNC is posedge, register is updated. #define  SET_CIF_UPDATE_IN_VSYNC                    0x00000004#define  SET_CIF_UPDATE_WITHOUT_VSYNC               0x00000008//ITY     Hw29  Interrupt Type  0:Pulse type, 1:Hold-up type when respond signal(ICR) is high  #define  SET_CIF_INT_TYPE_HOLDUP                    0x00000010#define  SET_CIF_INT_TYPE_PULSE                     0x00000020//Hw28  Interrupt Clear 0:.... , 1:Interrupt Clear (using ITY is Hold-up type)  //Hw28#define  SET_CIF_INT_HOLD_CLEAR                     0x00000040/////////////////////////////////////////////////////////////////////////////// CIF_SET_INTERRUPT_MASK///////////////////////////////////////////////////////////////////////////////MVN    Hw26           // Mask interrupt of VS negative edge,  0:Don't mask, 1:Mask#define  SET_CIF_INT_VS_NEGA_MASK                   0x00000001#define  SET_CIF_INT_VS_NEGA_NOT_MASK               0x00000002//MVP    Hw25           // Mask interrupt of VS negative edge,  0:Don't mask, 1:Mask#define  SET_CIF_INT_VS_POSI_MASK                   0x00000004#define  SET_CIF_INT_VS_POSI_NOT_MASK               0x00000008//MVIT   Hw24           // Mask interrupt of VCNT Interrupt,  0:Don't mask, 1:Mask#define  SET_CIF_INT_VCNT_MASK                      0x00000010#define  SET_CIF_INT_VCNT_NOT_MASK                  0x00000020//MSE    Hw23           // Mask interrupt of Scaler Error,  0:Don't mask, 1:Mask#define  SET_CIF_INT_SCALER_ERR_MASK                0x00000040#define  SET_CIF_INT_SCALER_ERR_NOT_MASK            0x00000080//MSF    Hw22           // Mask interrupt of Scaler finish,  0:Don't mask, 1:Mask#define  SET_CIF_INT_SCALER_FINISH_MASK             0x00000100#define  SET_CIF_INT_SCALER_FINISH_NOT_MASK         0x00000200//MENS    Hw21           // Mask interrupt of Encoding start,  0:Don't mask, 1:Mask#define  SET_CIF_INT_ENC_STRT_MASK                  0x00000400#define  SET_CIF_INT_ENC_STRT_NOT_MASK              0x00000800//MRLV  Hw20           // Mask interrupt of Rolling V address,  0:Don't mask, 1:Mask#define  SET_CIF_INT_ROLL_VADDR_MASK                0x00001000#define  SET_CIF_INT_ROLL_VADDR_NOT_MASK            0x00002000//MRLU  Hw19           // Mask interrupt of Rolling U address,  0:Don't mask, 1:Mask#define  SET_CIF_INT_ROLL_UADDR_MASK                0x00004000#define  SET_CIF_INT_ROLL_UADDR_NOT_MASK            0x00008000//MRLY   Hw18           // Mask interrupt of Rolling Y address,  0:Don't mask, 1:Mask#define  SET_CIF_INT_ROLL_YADDR_MASK                0x00010000#define  SET_CIF_INT_ROLL_YADDR_NOT_MASK            0x00020000//MSCF  Hw17           // Mask interrupt of Capture frame,  0:Don't mask, 1:Mask#define  SET_CIF_INT_CAPTURE_FRM_MASK               0x00040000#define  SET_CIF_INT_CAPTURE_FRM_NOT_MASK           0x00080000//MSOF  Hw16           // Mask interrupt of Stored one frame,  0:Don't mask, 1:Mask#define  SET_CIF_INT_STORE_1FRM_MASK                0x00100000#define  SET_CIF_INT_STORE_1FRM_NOT_MASK            0x00200000#define  SET_CIF_INT_ALL_MASK                       0x00400000#define  SET_CIF_INT_ALL_CLEAR_MASK                 0x00800000//VSS    Hw12           // Status of vertical sync, 0: Non-vertical sync blank area. , 1: vertical sync blank area//#define  SET_CIF_INT_VS_STATUS                     0x00400000//#define  SET_CIF_INT_NON_VS_STATUS                 0x00800000//////////////////////////////////////////////////////////////////////////////// CIF_GET_INTERRUPT_STATUS//////////////////////////////////////////////////////////////////////////////// VSS    Hw12           // Status of vertical sync, 0: Non-vertical sync blank area. , 1: vertical sync blank area#define  GET_CIF_INT_VS_STATUS                      0x00000001//#define           HwCIRQ_VN                                       Hw10            // VS positive, 0:-, 1:When VS is generated if Negative edge#define  GET_CIF_INT_NEGA_VS_GEN                    0x00000002//#define           HwCIRQ_VP                                       Hw9            // VS positive, 0:-, 1:When VS is generated if positive edge#define  GET_CIF_INT_POSI_VS_GEN                    0x00000004//#define           HwCIRQ_VIT                                      Hw8            // VCNT Interrupt, 0:-, 1:When VCNT is generated....#define  GET_CIF_INT_VCNT_GEN                       0x00000008//#define           HwCIRQ_SE                                       Hw7            // Scaler Error, 0:-, 1:When Scale operation is not correct.#define  GET_CIF_INT_SCALER_ERR                     0x00000010//#define           HwCIRQ_SF                                       Hw6            // Scaler Finish, 0:-, 1:When Scale operation is finished#define  GET_CIF_INT_SCALER_FINISH                  0x00000020//#define           HwCIRQ_ENS                                      Hw5            // Encoding start status, 0:-, 1:When Y address is bigger than encoding start address, this bit is high#define  GET_CIF_INT_ENC_STRT                       0x00000040//#define           HwCIRQ_ROLV                                     Hw4            // Rolling V address status, 0:-, 1:If V address is move to start address, this bit is high#define  GET_CIF_INT_ROLL_VADDR_STRT                0x00000080//#define           HwCIRQ_ROLU                                     Hw3            // Rolling U address starus, 0:-, 1:If U address is move to start address, this bit is high #define  GET_CIF_INT_ROLL_UADDR_STRT                0x00000100//#define           HwCIRQ_ROLY                                     Hw2            // Rolling Y address starus, 0:-, 1:If Y address is move to start address, this bit is high #define  GET_CIF_INT_ROLL_YADDR_STRT                0x00000200//#define           HwCIRQ_SCF                                      Hw1            // Stored captured frame,  0:-, 1:If Captured frame is stored, this bit is high#define  GET_CIF_INT_CAPTURE_FRM_STORE              0x00000800//#define           HwCIRQ_SOF                                      Hw0            // Stored One frame, 0-, 1:If one frame if stored, this bit is high.#define  GET_CIF_INT_ONEFRAME_STORE                 0x00001000#endif  // _82x#define SET_CIF_CLOCK_DIV0                          0x00000001#define SET_CIF_CLOCK_DIV1                          0x00000002#define SET_CIF_CLOCK_DIV2                          0x00000004#define SET_CIF_CLOCK_DIV3                          0x00000008#define SET_CIF_CLOCKPOLHIGH_ENABLE                 0x00000010#define SET_CIF_CLOCKPOLHIGH_DISABLE                0x00000020#define SET_CIF_CLOCKINT_ENABLE                     0x00000040#define SET_CIF_CLOCKINT_DISABLE                    0x00000080#define SET_CIF_CLOCK_ALL                           0x000000FF#define SET_CIF_656_PSL                             0x00000001#define SET_CIF_656_FPV                             0x00000002#define SET_CIF_656_SPV                             0x00000004#define SET_CIF_656_TPV                             0x00000008#define SET_CIF_656_H_BLANK                         0x00000010#define SET_CIF_656_V_BLANK                         0x00000020#define SET_CIF_656_ALL                             0x0000003F#define GET_CIF_OVERLAY_READ_ERR                    0x00000001#define GET_CIF_VCH_READ_ERR                        0x00000002#define GET_CIF_UCH_READ_ERR                        0x00000004#define GET_CIF_YCH_READ_ERR                        0x00000008#define GET_CIF_OVERLAY_WRITE_ERR                   0x00000010#define GET_CIF_VCH_WRITE_ERR                       0x00000020#define GET_CIF_UCH_WRITE_ERR                       0x00000040#define GET_CIF_YCH_WRITE_ERR                       0x00000080#define GET_CIF_OVERLAY_EMPTY_ERR                   0x00000100#define GET_CIF_VCH_EMPTY_ERR                       0x00000200#define GET_CIF_UCH_EMPTY_ERR                       0x00000400#define GET_CIF_YCH_EMPTY_ERR                       0x00000800#define GET_CIF_OVERLAY_FULL_ERR                    0x00001000#define GET_CIF_VCH_FULL_ERR                        0x00002000#define GET_CIF_UCH_FULL_ERR                        0x00004000#define GET_CIF_YCH_FULL_ERR                        0x00008000#define SET_CIF_SKIP_NUM                            0x00000001#define SET_CIF_VCNT_NUM                            0x00000002#define SET_CIF_CCM1_ENCNUM                         0x00000001  // Encode INT number (using CAP mode) [31:28], value area (0~15), Encode interrupt number#define SET_CIF_CCM1_ROLNUMV                        0x00000002   // Rolling number in V (using CAP mode) [27:24], value area (0~15), Rolling number#define SET_CIF_CCM1_ROLNUMU                        0x00000004  // Rolling number in U (using CAP mode) [23:20], value area (0~15), Rolling number#define SET_CIF_CCM1_ROLNUMY                        0x00000008  // Rolling number in Y (using CAP mode) [19:16], value area (0~15), Rolling number#define SET_CIF_CCM1_CB                             0x00000010  // Capture Busy,   0:-, 1:Capture busy#define SET_CIF_EIT_ENC_INT                         0x00000001#define SET_CIF_EIT_ALWAYS_1_PULSE                  0x00000002#define SET_CIF_UES_ENABLE                          0x00000004#define SET_CIF_UES_DISABLE                         0x00000008#define SET_CIF_RLV_ENABLE                          0x00000010#define SET_CIF_RLV_DISABLE                         0x00000020#define SET_CIF_RLU_ENABLE                          0x00000040#define SET_CIF_RLU_DISABLE                         0x00000080#define SET_CIF_RLY_ENABLE                          0x00000100#define SET_CIF_RLY_DISABLE                         0x00000200#define SET_CIF_CAP_ENABLE                          0x00000400#define SET_CIF_CAP_DISABLE                         0x00000800#define SET_CIF_VEN_ENABLE                          0x00001000#define SET_CIF_VEN_DISABLE                         0x00002000#define READ_CIF_CUR_ADDR_Y                         0x00000001#define READ_CIF_CUR_ADDR_U                         0x00000002#define READ_CIF_CUR_ADDR_V                         0x00000004#define READ_CIF_CUR_LINE_CNT                       0x00000008#define SET_CIF_CEM_UVS                             0x00000001  // UV Swap  0:u-v-u-v sequence, 1:v-u-v-u sequence#define SET_CIF_CEM_VB                              0x00000002  // V Bias (V channel value offset),   0:disable, 1:Enable #define SET_CIF_CEM_UB                              0x00000004  // U Bias (U channel value offset),   0:disable, 1:Enable#define SET_CIF_CEM_YB                              0x00000008  // Y Bias (Y channel value offset),   0:disable, 1:Enable#define SET_CIF_CEM_YCS                             0x00000010  // YC Swap  0:u-y-v-y sequence, 1:y-u-y-v sequence#define SET_CIF_CEM_IVY                             0x00000020  // Invert Y,   0:disable, 1:Enable #define SET_CIF_CEM_STC                             0x00000040  // Strong C,   0:disable, 1:Enable #define SET_CIF_CEM_YCL                             0x00000080  // Y Clamp (Y value clipping),   0:disable, 1:Enable #define SET_CIF_CEM_CS                              0x00000100  // C Select (Color filter),   0:disable, 1:Enable(Color filter)  #define SET_CIF_CEM_SKT                             0x00000200  // Sketch Enable,   0:disable, 1:Enable #define SET_CIF_CEM_EMM                             0x00000400  // Emboss mode,   0:Positive emboss, 1:Negative emboss  // Only 0 SET  . #define SET_CIF_CEM_EMB                             0x00000800  // Emboss,   0:disable, 1:Enable                          #define SET_CIF_CEM_NEGA                            0x00001000  // Negative mode,   0:disable, 1:Enable#define SET_CIF_CEM_GRAY                            0x00002000  // Gray mode,   0:disable, 1:Enable #define SET_CIF_CEM_SEPI                            0x00004000  // Sepia mode,   0:disable, 1:Enable    #define SET_CIF_CEM_NOR                             0x00008000  // Normal mode,   0:Effect mode, 1:Normal mode  #define SET_CIF_CEM_ALL_CLEAR                       0x00010000#define SET_CIF_INPATH_H_WAIT                       0x00000001#define SET_CIF_INPATH_S_CYCLE                      0x00000002#define SET_CIF_INPATH_I_WAIT                       0x00000004#define SET_CIF_INPATH_R_ENABLE                     0x00000008#define SET_CIF_INPATH_R_DISABLE                    0x00000010#define SET_CIF_INPATH_FLUSH_ENABLE                 0x00000020#define SET_CIF_INPATH_FLUSH_DISABLE                0x00000040#define SET_CIF_INPATH_ENABLE                       0x00000080#define SET_CIF_INPATH_DISABLE                      0x00000100#define SET_CIF_INPATH_MEM                          0x00000200#define SET_CIF_INPATH_CAM                          0x00000400#define SET_CIF_INPATH_SRC_SIZE                     0x00000001#define SET_CIF_INPATH_SRC_OFFSET                   0x00000002#define SET_CIF_INPATH_DST_SIZE                     0x00000004#define SET_CIF_INPATH_SCALE                        0x00000008#define SET_CIF_INPATH_ALL                          0x0000000F#define SET_CIF_SCALER_ENABLE                       1#define SET_CIF_SCALER_DISABLE                      0                            #define SET_CIF_SCALER_SRC_SIZE                     0x00000001#define SET_CIF_SCALER_SRC_OFFSET                   0x00000002#define SET_CIF_SCALER_DST_SIZE                     0x00000004#define SET_CIF_SCALER_FACTOR                       0x00000008#define SET_CIF_SCALER_ALL                          0x0000000F/*#define SET_SCALE_TYPE_422SEQ0                      0#define SET_SCALE_TYPE_422SEQ1                      1#define SET_SCALE_TYPE_422SEPE                      2#define SET_SCALE_TYPE_INVALID                      3#define SET_SCALE_PATH_TOMEMORY                     0#define SET_SCALE_PATH_TOLCD                        1#define SCALE_BUSY_INT_ENABLE                       0#define SCALE_BUSY_INT_DISABLE                      1#define SCALE_READY_INT_ENABLE                      0#define SCALE_READY_INT_DISABLE                     1#define MSC_CFG_WAIT                                0x00000001#define MSC_CFG_RDY                                 0x00000002#define MSC_CFG_PATH                                0x00000004#define MSC_CFG_TYPE                                0x00000008#define MSC_CFG_ALL                                 0x0000000F#define MSC_CTRL_BUSY_INT_EN                        0x00000001#define MSC_CTRL_BUSY_INT_DIS                       0x00000002#define MSC_CTRL_RDY_INT_EN                         0x00000004#define MSC_CTRL_RDY_INT_DIS                        0x00000008#define MSC_CTRL_EN                                 0x00000010 #define MSC_CTRL_DIS                                0x00000020#define MSC_CTRL_ROLL_EN                            0x00000040#define MSC_CTRL_ROLL_DIS                           0x00000080#define MSC_CTRL_MIDDLE_EN                          0x00000100#define MSC_CTRL_MIDDLE_DIS                         0x00000200#define MSC_CTRL_ROLL_RESTR_SET                     0x00000400#define MSC_CTRL_ROLL_GOSTOP_EN                     0x00000800#define MSC_CTRL_ROLL_GOSTOP_DIS                    0x00001000#define MSC_CTRL_MIDDLE_GOSTOP_EN                   0x00002000#define MSC_CTRL_MIDDLE_GOSTOP_DIS                  0x00004000#define MSC_CTRL_ROLL_INT_EN                        0x00008000#define MSC_CTRL_ROLL_INT_DIS                       0x00010000#define MSC_CTRL_MIDDLE_INT_EN                      0x00020000#define MSC_CTRL_MIDDLE_INT_DIS                     0x00040000#define MSC_CTRL_ALL                                0x0007FFFF*//* Drivers IDs */enum{	MON = 0,	SEQ,	AE,	AWB,	FD,	AF,	AFM,	MODE,	JPEG = 9,	HG = 11,	MON_EXT = 16,	SEQ_EXT,	AE_EXT,	AWB_EXT,	FD_EXT,	AF_EXT,	AFM_EXT,	MODE_EXT,	JPEG_EXT = 25,	HG_EXT};#define     CAM_BW_16BIT                            0x00#define     CAM_BW_8BIT                             0x01#define     CAM_HSIZE_PREV                          320#define     CAM_VSIZE_PREV                          240#define     CAM_HSIZE                               320#define     CAM_VSIZE                               240#if defined (FEATURE_LCD_128x160)#define     CAMLCD_HSIZE                            128#define     CAMLCD_VSIZE                            160#elif defined (FEATURE_LCD_176x220)#define     CAMLCD_HSIZE                            176#define     CAMLCD_VSIZE                            220#define     CAMLCD_ROT90_HSIZE                      224#define     CAMLCD_ROT90_VSIZE                      176#elif defined (FEATURE_LCD_240x320)#define     CAMLCD_HSIZE                            240#define     CAMLCD_VSIZE                            320#define     CAMLCD_ROT90_HSIZE                      320#define     CAMLCD_ROT90_VSIZE                      240#else#define     CAMLCD_HSIZE                            240#define     CAMLCD_VSIZE                            320#endif#define     VOD_HSIZE                               176#define     VOD_VSIZE                               144#define     CAM_HSIZE_TV                            640#define     CAM_VSIZE_TV                            480typedef struct _CIF_CONTROL_INFO{	unsigned int uiFlag;	unsigned int uiBypass;	unsigned int uiBypassBusSel;	unsigned int uiColorPattern;	unsigned int uiPatternFormat;	unsigned int uiRGBMode;	unsigned int uiRGBBitMode;	unsigned int uiColorSequence;	unsigned int uiBusOrder;	unsigned int uiOverlayCNT;} CIF_CONTROL_INFO;typedef struct _CIF_TRANSFER_CONFIG{	unsigned int uiFlag;	unsigned int uiTransMode;	unsigned int uiBurst;	unsigned int uiLock;} CIF_TRANSFER_CONFIG;typedef struct _CIF_OVERLAY_CONFIG{	unsigned int uiFlag;	unsigned int uiOverlayCNT;	unsigned int uiOverlayMethod;	unsigned int uiXOR1;	unsigned int uiXOR0;	unsigned int uiAlpha1;	unsigned int uiAlpha0;} CIF_OVERLAY_CONFIG;typedef struct _CIF_OVERLAY_KEY{	unsigned int uiFlag;	unsigned int uiKEYR;	unsigned int uiKEYG;	unsigned int uiKEYB;	unsigned int uiMKEYR;	unsigned int uiMKEYG;	unsigned int uiMKEYB;} CIF_OVERLAY_KEY;typedef struct _CIF_SYNC_POLARITY{	unsigned int uiHPolarity;	unsigned int uiVpolarity;} CIF_SYNC_POLARITY;typedef struct _CIF_IMAGE_CONFIG{	unsigned int uiType;	unsigned int uiHsize;	unsigned int uiVsize;	unsigned int uiHorWindowingStart;	unsigned int uiHorWindowingEnd;	unsigned int uiVerWindowingStart;	unsigned int uiVerWindowingEnd;} CIF_IMAGE_CONFIG;typedef struct _CIF_SCALE_CONFIG{	unsigned int uiScaleEnable;	unsigned int uiXScale;	unsigned int uiYScale;} CIF_SCALE_CONFIG;typedef struct _CIF_BASE_ADDRESS{	unsigned int uiType;	unsigned int uiBaseAddr0;	unsigned int uiBaseAddr1;	unsigned int uiBaseAddr2;} CIF_BASE_ADDRESS;    typedef struct _CIF_OVERLAY_CONTROL{	unsigned int uiFlag;	unsigned int uiAlphaEnable;	unsigned int uiChromakeyEnable;	unsigned int uiOverlayEnable;} CIF_OVERLAY_CONTROL;        typedef struct _CIF_INTANDOPERATING_CONTROL{	unsigned int uiFlag;	unsigned int uiReadOneFrameStatus;} CIF_INTANDOPERATING_CONTROL;    extern void CIF_Open(void);extern void CIF_Close(void);extern void CIF_ONOFF(unsigned int uiOnOff);extern void CIF_OpStop (void);extern void CIF_WaitFrameSync(unsigned int exp_timer);#endif
\ No newline at end of file
Index: linux-2.6.29/drivers/media/video/tcccam/cam_reg.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/tcccam/cam_reg.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1 @@
+/*************************************************************************    Telechips Multi Media Player*    ------------------------------------------------**    FUNCTION    : CAMERA INTERFACE API*    MODEL        : DMP*    CPU NAME    : TCCXXX*    SOURCE        : cam_reg.h**    START DATE    : 2008. 4. 17.*    MODIFY DATE :*    DEVISION    : DEPT. SYSTEM 3-2 TEAM*                : TELECHIPS, INC.************************************************************************/#ifndef _CAM_REG_H_#define _CAM_REG_H_#define ON                              1#define OFF                             0#define ENABLE                          1#define DISABLE                         0// 1. On/Off on CIF >> 0:Can't operate CIF , 1:Operating CIF#define CIF_ON                          1#define CIF_OFF                         0// 4.  HwICPCR1_POL                            Hw21         // PXCLK Polarity >> 0:Positive edge, 1:Negative edge#define POSITIVE                        1#define NEGATIVE                        0#define CIF_PWDN_ENABLE                 1#define CIF_PWDN_DISABLE                0#define CIF_BYPASS_SCALER_ENABLE        1#define CIF_BYPASS_SCALER_DISABLE       0#define CIF_PXCLK_NEGATIVE_EDGE         1#define CIF_PXCLK_POSITIVE_EDGE         0#define CIF_656CONVERT_ENABLE           1#define CIF_656CONVERT_DISABLE          0// 5.  HwICPCR1_SKPF                                        // Skip Frame >> 0~7 #Frames skips   [20:18]#define FRAME_0                         0#define FRAME_1                         1#define FRAME_2                         2#define FRAME_3                         3#define FRAME_4                         4#define FRAME_5                         5#define FRAME_6                         6#define FRAME_7                         7// 6.//  HwICPCR1_M420_ZERO                      HwZERO        // Format Convert (YUV422->YUV420) , Not-Convert//  HwICPCR1_M420_ODD                       Hw17             // converted in odd line skip   // 10//  HwICPCR1_M420_EVEN                      (Hw17|Hw16)  // converted in even line skip  //11#define M420_ZERO                       0 // YUV422#define M420_ODD                        2 // YUV420#define M420_EVEN                       3// BP,  Hw15, Bypass (Non-Separate)#define SEPARATE                        0#define NON_SEPARATE                    1//#define NON_BYPASS                  0  // Not Bypass = Separate//#define BYPASS                           1  // Bypass = NON_Separate//BBS, Hw14, Bypass BUS Select#define MSB_FIRST                       0#define LSB_FIRST                       1// CP , Hw12, Color Pattern#define MODE_YUV                        0  //Ycbcr(YUV, RGB)#define MODE_RGB                        1  // RGB(555,565,bayer)// PF , Hw11,Hw10  , Pattern Format#define FMT444                          0  #define FMT422                          1#define FMTRGB                          2  // 4:2:0 format or RGB(555,565,bayer) color pattern//RGBM , Hw9,Hw8 , RGB mode #define BAYER_RGB                       0  #define RGB555                          1#define RGB565                          2//RGBBM, Hw7,Hw6 , RGB Bit Mode#define MODE16                          0  // 16bit mode (4:2:0 Ycbcr/ YUV, RGB555/565, 4:2:2/4:4:4 format)#define MODE8                           1  // 8bit non-sync#define MODE8SYNC                       2  // 8bit (Bayer/555/565RGB), 8bit enable sync (sync-port)// CS Hw5, Hw4 , Color Sequence#define SEQYUYV                         0#define SEQYVYU                         1#define SEQUYVY                         2#define SEQVYUY                         3//#define SEQ_YBYR                     0//#define SEQ_YRYB                     1//#define SEQ_BYRY                     2//#define SEQ_RYBY                     3// BO Hw2 , BUS Order#define SWICH_BUS                       1#define NON_SWICH_BUS                   0/////////////////////////////////////////////////////////////////////////////#define ACT_HIGH                        1#define ACT_LOW                         0#define NEGATIVE_EDGE                   1#define POSITIVE_EDGE                   0// Hw0, Hw1, BS , preamble and Status Location#define BURST1                          0#define BURST2                          1#define BURST4                          2#define BURST8                          3// Hw2, LOCK , Lock Transfer#define LOCK_TR                         1#define NON_LOCK_TR                     0// Hw3, TM, Transfer Method#define INC_TRANS                       1#define BURST_TRANS                     0#define OL_RGB_565                      0    // RGB mode 565RGB #define OL_RGB_555                      1   // RGB mode 555RGB#define OL_RGB_444                      2   // RGB mode 444RGB#define OL_RGB_332                      3   // RGB mode 332RGB#define D_SCALE1                        0#define D_SCALE2                        1#define D_SCALE4                        2#define D_SCALE8                        3#define RGB_SEQ_16                      0#define BGR_SEQ_16                      1#define RGB_GBG_16                      4#define BGR_GBG_16                      5#define GBG_RGB_16                      6#define GBG_BGR_16                      7#define RGB_SEQ_8_565                   8#define BGR_SEQ_8_565                   9#define RGB_GBG_8_555                   12  //C#define BGR_GBG_8_555                   13  //D#define GBG_RGB_8_555                   14  //E#define GBG_BGR_8_555                   15  //F#define FULL_OVERLAY                    0#define BLOCK_OVERLAY                   1#define OP_XOR                          0#define OP_ALPHA                        1#define ALPHA25                         0#define ALPHA50                         1#define ALPHA75                         2#define ALPHA100                        3#define PSL_1ST                         0#define PSL_2ND                         1#define PSL_3RD                         2#define PSL_4TH                         3#define INPATH_422SEQ0                  0#define INPATH_422SEQ1                  1#define INPATH_422SEPA                  2#define INPATH_420SEPA                  3#endif
\ No newline at end of file
Index: linux-2.6.29/drivers/media/video/tcccam/camera_core.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/tcccam/camera_core.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,1032 @@
+/*
+ * drivers/media/video/tcccam/camera_core.c
+ *
+ * Copyright (C) 2008 Telechips, Inc. 
+ *
+ * Video-for-Linux (Version 2) camera capture driver for
+ * the OMAP H2 and H3 camera controller.
+ *
+ * Adapted from omap24xx driver written by Andy Lowe (source@mvista.com)
+ * Copyright (C) 2003-2004 MontaVista Software, Inc.
+ * 
+ * This package is free software; you can redistribute it and/or modify 
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation. 
+ * 
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR 
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED 
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. 
+ *
+ * History:
+ *   
+ */
+ 
+#include <linux/autoconf.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+#include <linux/slab.h>
+#include <linux/proc_fs.h>
+#include <linux/ctype.h>
+#include <linux/pagemap.h>
+#include <linux/mm.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/videodev.h>
+#include <linux/pci.h>
+#include <linux/version.h>
+#include <linux/semaphore.h>
+#include <asm/processor.h>
+#include <linux/dma-mapping.h>
+#include <linux/fb.h>
+#include <media/v4l2-common.h>
+#include <media/v4l2-ioctl.h>
+
+#include <asm/io.h>
+#include <asm/byteorder.h>
+#include <asm/irq.h>
+
+#include "sensor_if.h"
+#include "camera_hw_if.h"
+#include "camera_core.h"
+#include "tcc_cam.h"
+#include "tdd_cif.h"
+
+
+#if 1
+static int debug	   = 1;
+#else
+static int debug	   = 0;
+#endif
+
+#define dprintk(msg...)	if (debug) { printk( "Camera_core: " msg); }
+
+
+#ifdef JPEG_ENCODE_WITH_CAPTURE
+#include "tcc83xx_jpeg.h"
+#endif
+
+//(CONFIG_ARCH_TCC8900)
+#include <bsp.h>
+
+#define DRIVER_VERSION "v1.0"
+#define DRIVER_AUTHOR  "Telechips.Co.Ltd"
+#define DRIVER_DESC    "TCC CAMERA driver"
+
+
+extern struct TCCxxxCIF hardware_data;
+struct v4l2_framebuffer fbuf;
+static struct video_device *vfd;
+static struct v4l2_pix_format pix;
+static unsigned long xclk;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    static struct early_suspend early_suspend;
+#endif	
+
+//int tmp_i2c_add(void);
+//void tmp_i2c_del(void);
+
+//static void camera_core_sgdma_process(struct tcc78xx_camera_device *cam);
+
+/* module parameters */
+static int video_nr = -1;	/* video device minor (-1 ==> auto assign) */
+
+/* Maximum amount of memory to use for capture buffers.
+ * Default is 4800KB, enough to double-buffer SXGA.
+ */
+static int capture_mem = 1280*960*2*2;
+
+/*Size of video overlay framebuffer. This determines the maximum image size
+ *that can be previewed. Default is 600KB, enough for sxga.
+ */
+//static int overlay_mem = 320*240*2*2;
+
+#if 0
+
+/* -------------------overlay routines ------------------------------*/
+/* callback routine for overlay DMA completion. We just start another DMA
+ * transfer unless overlay has been turned off
+ */
+
+static void
+camera_core_overlay_callback(void *arg1, void *arg)
+{
+	struct camera_device *cam = (struct camera_device *)arg1;
+	int err;
+	unsigned long irqflags;
+	int i, j;
+	int count, index;
+	unsigned char *fb_buf = phys_to_virt((unsigned long)camera_dev->fbuf.base);
+
+	spin_lock_irqsave(&cam->overlay_lock, irqflags);
+
+	if (!cam->previewing || cam->overlay_cnt == 0) {
+		spin_unlock_irqrestore(&cam->overlay_lock, irqflags);
+		return;
+	}
+
+	--cam->overlay_cnt;
+	sg_dma_address(&cam->overlay_sglist) = cam->overlay_base_phys;
+	sg_dma_len(&cam->overlay_sglist) = cam->pix.sizeimage;
+
+	count = 0;
+	j = ((cam->pix.width - 1) * cam->fbuf.fmt.bytesperline);
+	for (i = 0 ; i < cam->pix.sizeimage; i += cam->pix.bytesperline) {
+		for (index = 0; index < cam->pix.bytesperline; index++) {
+			fb_buf[j] = *(((unsigned char *) cam->overlay_base) +
+								 i + index);
+			index++;
+			fb_buf[j + 1] = *(((unsigned char *) cam->overlay_base) + i + index);
+			j = j - cam->fbuf.fmt.bytesperline;
+		}
+		count += 2;
+		j = ((cam->pix.width - 1) * cam->fbuf.fmt.bytesperline) + count;
+	}
+
+	while (cam->overlay_cnt < 2) {
+		err = camera_core_sgdma_queue(cam, &cam->overlay_sglist, 1,
+			camera_core_overlay_callback, NULL);
+		if (err)
+			break;
+		++cam->overlay_cnt;
+	}
+
+	spin_unlock_irqrestore(&cam->overlay_lock, irqflags);
+
+}
+
+ 
+static void
+camera_core_start_overlay(struct camera_device *cam)
+{
+	int err;
+	unsigned long irqflags;
+
+	if (!cam->previewing) 
+		return;
+
+	spin_lock_irqsave(&cam->overlay_lock, irqflags);
+
+	sg_dma_address(&cam->overlay_sglist) = cam->overlay_base_phys;
+	sg_dma_len(&cam->overlay_sglist)= cam->pix.sizeimage;
+	while (cam->overlay_cnt < 2) {
+		err = camera_core_sgdma_queue(cam, &cam->overlay_sglist, 1,
+				camera_core_overlay_callback, NULL);
+		if (err)
+			break;
+		++cam->overlay_cnt;
+	}
+
+	spin_unlock_irqrestore(&cam->overlay_lock, irqflags);
+}
+#endif
+
+/* ---------------------------------------------------------------------------- */
+
+int tcc_videobuf_inputenum(struct v4l2_input *input)
+{
+	/* default handler assumes 1 video input (the camera) */
+	int index = input->index;
+
+	memset(input, 0, sizeof(*input));
+	input->index = index;
+
+	if (index > 0)
+		return -EINVAL;
+
+	strlcpy(input->name, "camera", sizeof(input->name));
+	input->type = V4L2_INPUT_TYPE_CAMERA;
+
+	return 0;
+}
+
+int tcc_videobuf_g_input(unsigned int *input)
+{
+	*input = 0;
+	
+	return 0;
+}
+
+int tcc_videobuf_s_input(unsigned int *input)
+{
+	if (*input > 0)
+		return -EINVAL;
+
+	return 0;
+}
+
+int tcc_videobuf_g_param(struct v4l2_streamparm *gparam)
+{
+	memset(gparam,0x00,sizeof(*gparam));
+	gparam->parm.capture.capturemode=hardware_data.cif_cfg.oper_mode;
+	
+	return 0;
+}
+
+int tcc_videobuf_s_param(struct v4l2_streamparm *sparam)
+{
+	return 0;
+}
+
+int tcc_videobuf_enum_fmt(struct v4l2_fmtdesc *fmt)
+{	
+	return sensor_enum_pixformat(fmt);
+}
+
+int tcc_videobuf_try_fmt(struct v4l2_format *fmt)
+{	
+	//return sensor_try_format(&fmt->fmt.pix);
+
+	return 0;
+}
+
+int tcc_videobuf_g_fmt(struct v4l2_format *fmt)
+{
+	/* get the current format */
+	memset(&fmt->fmt.pix, 0, sizeof (fmt->fmt.pix));
+	fmt->fmt.pix = pix;
+	
+	return 0;
+}
+
+int tcc_videobuf_s_fmt(struct v4l2_format *fmt)
+{
+	unsigned int temp_sizeimage = 0;
+	temp_sizeimage = pix.sizeimage;
+	
+	pix.width	= fmt->fmt.pix.width;
+	pix.height	= fmt->fmt.pix.height;	
+
+	return tccxxx_cif_set_resolution(fmt->fmt.pix.pixelformat, fmt->fmt.pix.width, fmt->fmt.pix.height);
+}
+
+int tcc_videobuf_querycap(struct v4l2_capability *cap)
+{
+	memset(cap, 0, sizeof(struct v4l2_capability));
+	
+	strlcpy(cap->driver, CAM_NAME, sizeof(cap->driver));
+	strlcpy(cap->card, vfd->name, sizeof(cap->card));
+
+	cap->bus_info[0] = '\0';
+	cap->version = KERNEL_VERSION(2, 6, 28);
+	cap->capabilities = V4L2_CAP_VIDEO_CAPTURE |				
+						V4L2_CAP_VIDEO_OVERLAY |
+						V4L2_CAP_READWRITE | 
+						V4L2_CAP_STREAMING;
+	
+	return 0;
+}
+
+int tcc_videobuf_g_fbuf(struct v4l2_framebuffer *fargbuf)
+{
+	memcpy(fargbuf,&fbuf,sizeof(struct v4l2_framebuffer));
+
+	return 0;
+}
+
+int tcc_videobuf_s_fbuf(struct v4l2_framebuffer *fargbuf)
+{
+	fbuf.base = fargbuf->base;
+	fbuf.fmt = fargbuf->fmt;				
+
+	return 0;
+}
+
+int tcc_videobuf_reqbufs(struct v4l2_requestbuffers *req)
+{	
+	if (req->count < 1) {
+		printk("reqbufs: count invalid (%d)\n",req->count);
+		return -EINVAL;
+	}
+
+	if (req->memory != V4L2_MEMORY_MMAP     &&
+	    req->memory != V4L2_MEMORY_USERPTR  &&
+	    req->memory != V4L2_MEMORY_OVERLAY) 
+    {
+		printk("reqbufs: memory type invalid\n");
+		return -EINVAL;
+	}
+	
+	if (req->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+	{
+		printk("reqbufs: video type invalid\n");
+		return -EINVAL;			
+	}
+	
+	if (req->count > TCC_CAMERA_MAX_BUFNBRS)
+		req->count = TCC_CAMERA_MAX_BUFNBRS;
+	
+	return tccxxx_cif_buffer_set(req);
+}
+
+
+int tcc_videobuf_querybuf(struct v4l2_buffer *buf)
+{
+	struct TCCxxxCIF *data = (struct TCCxxxCIF *)(&hardware_data);
+	struct tccxxx_cif_buffer *cif_buf = data->buf + buf->index;
+	int index = buf->index;	
+
+	if (index < 0 || index > data->cif_cfg.pp_num)  
+	{
+		printk(KERN_WARNING "querybuf error : index : %d / %d",index, data->cif_cfg.pp_num);
+		return -EINVAL;
+	}
+	
+	memset(buf, 0, sizeof(*buf));
+	buf->type 					= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	buf->index 					= index;
+	buf->flags 					= V4L2_BUF_FLAG_MAPPED;
+
+	buf->flags					|= cif_buf->v4lbuf.flags;
+	buf->field 					= V4L2_FIELD_NONE;
+	buf->timestamp 				= cif_buf->v4lbuf.timestamp;
+	buf->sequence 				= cif_buf->v4lbuf.sequence;
+	buf->memory 				= V4L2_MEMORY_MMAP;
+	buf->m.offset 				= data->cif_cfg.preview_buf[index].p_Y;
+	cif_buf->v4lbuf.m.offset	= data->cif_cfg.preview_buf[index].p_Y;
+
+	if(data->cif_cfg.fmt == 0) //yuv420
+	{
+		buf->length 				= PAGE_ALIGN(pix.width*pix.height*2);	//  		
+	}
+	else
+	{
+//		buf->length 				= PAGE_ALIGN(pix.width*pix.height*3/2);	//  		
+		buf->length 				= PAGE_ALIGN(pix.width*pix.height*3/2);	//  		
+	}
+	cif_buf->v4lbuf.length		= buf->length;
+	cif_buf->v4lbuf.index		= index;
+
+	dprintk("<%d :: [PA]0x%x / flag: 0x%x  >\n", index, (unsigned int)(cif_buf->v4lbuf.m.offset), (unsigned int)(buf->flags));	
+	
+	return 0;
+}
+
+int tcc_videobuf_qbuf(struct v4l2_buffer *buf)
+{
+	struct TCCxxxCIF *data = (struct TCCxxxCIF *)(&hardware_data);
+	struct tccxxx_cif_buffer *cif_buf = data->buf + buf->index;
+	int retval = -EINVAL;
+
+	if (buf->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EAGAIN;
+
+	if (buf->index < 0 || buf->index >= data->cif_cfg.pp_num)
+		return -EAGAIN;
+
+	if (cif_buf->v4lbuf.flags & V4L2_BUF_FLAG_QUEUED) 
+	{
+		retval = 0; /* Already queued?? */
+		return -EAGAIN;
+	}
+
+	if (cif_buf->v4lbuf.flags & V4L2_BUF_FLAG_DONE) 
+	{	
+		retval = 0;
+		return -EAGAIN;
+	}
+	
+	cif_buf->v4lbuf.flags |= V4L2_BUF_FLAG_QUEUED;
+
+	list_add_tail(&cif_buf->buf_list, &data->list);	
+	
+	return 0;			
+}
+
+int tcc_videobuf_dqbuf(struct v4l2_buffer *buf, struct file *file )
+{
+	struct TCCxxxCIF *data = (struct TCCxxxCIF *)(&hardware_data);
+	struct tccxxx_cif_buffer *cif_buf;
+	int retval = -EINVAL;	
+
+	if(data->cif_cfg.esd_restart)
+	{
+		tccxxx_cif_cam_restart(&pix,xclk);
+	}
+
+	if(list_empty(&data->done_list))
+	{
+		if(file->f_flags&O_NONBLOCK)
+		{
+			return -EAGAIN;
+		}
+			
+		if(wait_event_interruptible(data->frame_wait,!list_empty(&data->done_list)))
+		{
+			retval = -ERESTARTSYS;
+			return -EAGAIN;
+		}
+
+		/* Should probably recheck !list_empty() here */
+		if(list_empty(&data->done_list))
+		{
+			return -EAGAIN;
+		}
+	}
+	else
+	{
+		dprintk(" list no_empty!! \n");
+	}
+	
+	cif_buf = list_entry(data->done_list.next, struct tccxxx_cif_buffer, buf_list);		
+	list_del(data->done_list.next);
+
+	cif_buf->v4lbuf.flags &= ~V4L2_BUF_FLAG_DONE;
+	memcpy(buf, &(cif_buf->v4lbuf),sizeof(struct v4l2_buffer));
+	
+	return 0;
+}
+
+
+int tcc_videobuf_streamon(enum v4l2_buf_type *type)
+{
+	if (*type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EAGAIN;
+		
+	return tccxxx_cif_start_stream();
+}
+
+//stop capture
+int tcc_videobuf_streamoff(enum v4l2_buf_type *type )
+{	
+	if (*type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EAGAIN;
+	
+	return tccxxx_cif_stop_stream();
+}
+
+int tcc_videobuf_cif_overlay(cif_SuperImpose *overlay)
+{
+	struct TCCxxxCIF *data = (struct TCCxxxCIF *) &hardware_data;
+
+	memcpy(&(data->cif_cfg.si_overlay), overlay, sizeof(cif_SuperImpose));
+	
+	tccxxx_cif_set_overlay();	
+	
+	return 0;
+}
+
+int tcc_videobuf_user_jpeg_capture(int * Jpeg_quality )
+{	
+	struct TCCxxxCIF *data = (struct TCCxxxCIF *) &hardware_data;	
+	struct tccxxx_cif_buffer *cif_buf;			
+		
+	while(!list_empty(&data->done_list)) 
+	{
+		cif_buf = list_entry(data->done_list.next, struct tccxxx_cif_buffer, buf_list);		
+		list_del(&cif_buf->buf_list);
+	
+		cif_buf->v4lbuf.flags &= ~V4L2_BUF_FLAG_DONE;
+		cif_buf->v4lbuf.flags |= V4L2_BUF_FLAG_QUEUED;
+		
+		list_add_tail(&cif_buf->buf_list, &data->list);	
+	}
+	data->done_list.next = &data->done_list;
+	data->cif_cfg.now_frame_num = 0;
+	data->cif_cfg.retry_cnt 	= 0;
+	
+	return tccxxx_cif_capture(*Jpeg_quality);
+	
+}
+
+
+int tcc_videobuf_user_get_capture_info(TCCXXX_JPEG_ENC_DATA * Jpeg_data )
+{	
+	struct TCCxxxCIF *data = (struct TCCxxxCIF *) &hardware_data;	
+	
+	if(data->cif_cfg.jpg_info.jpg_len != 0)
+	{
+		memcpy((void*)data->cif_cfg.jpg_info.jpg_buf_addr+data->cif_cfg.jpg_info.jpg_len, 
+						data->cif_cfg.jpg_info.jpg_hdr_addr, 
+						data->cif_cfg.jpg_info.jpg_hdr_len);
+	}
+
+	Jpeg_data->src 				= data->cif_cfg.jpg_info.jpg_buf_addr;
+	Jpeg_data->bitstream_size 	= data->cif_cfg.jpg_info.jpg_len;
+	Jpeg_data->header_size 		= data->cif_cfg.jpg_info.jpg_hdr_len;
+	Jpeg_data->thumb_size		= 0;
+	Jpeg_data->width 			= data->cif_cfg.main_set.target_x;
+	Jpeg_data->height 			= data->cif_cfg.main_set.target_y;
+
+	return 0;
+}
+
+/* ---------------------------------------------------------------------------- */
+
+
+static int camera_core_do_ioctl(struct inode *inode, struct file *file, unsigned int cmd, void *arg)
+{
+	//int err;
+	
+	switch (cmd) {
+		case VIDIOC_ENUMINPUT:
+			return tcc_videobuf_inputenum((struct v4l2_input *)arg);
+			
+		case VIDIOC_G_INPUT:
+			return tcc_videobuf_g_input((unsigned int*)arg);
+
+		case VIDIOC_S_INPUT:
+			return tcc_videobuf_s_input((unsigned int*)arg);
+		
+		case VIDIOC_G_PARM:
+			return tcc_videobuf_g_param((struct v4l2_streamparm*)arg);
+
+		case VIDIOC_S_PARM:
+			return tcc_videobuf_s_param((struct v4l2_streamparm*)arg);
+		
+		case VIDIOC_ENUM_FMT:
+			return tcc_videobuf_enum_fmt((struct v4l2_fmtdesc*)arg);
+
+		case VIDIOC_TRY_FMT:
+			return tcc_videobuf_try_fmt((struct v4l2_format*)arg);
+
+		case VIDIOC_G_FMT:
+			return tcc_videobuf_g_fmt((struct v4l2_format*)arg);
+
+		case VIDIOC_S_FMT:
+			return tcc_videobuf_s_fmt((struct v4l2_format*)arg);
+
+		case VIDIOC_QUERYCTRL:
+			return sensor_query_control((struct v4l2_queryctrl *)arg);
+
+		case VIDIOC_G_CTRL:
+			return sensor_get_control((struct v4l2_control *)arg);
+
+		case VIDIOC_S_CTRL:
+			return sensor_set_control((struct v4l2_control *)arg);
+		
+		case VIDIOC_QUERYCAP:
+			return tcc_videobuf_querycap((struct v4l2_capability *)arg);
+
+		case VIDIOC_G_FBUF: /* Get the frame buffer parameters */
+			return tcc_videobuf_g_fbuf((struct v4l2_framebuffer *)arg);
+
+		case VIDIOC_S_FBUF: /* set the frame buffer parameters */
+			return tcc_videobuf_s_fbuf((struct v4l2_framebuffer *)arg);
+
+		case VIDIOC_REQBUFS:
+			return tcc_videobuf_reqbufs((struct v4l2_requestbuffers *)arg);            
+
+		case VIDIOC_QUERYBUF:
+			return tcc_videobuf_querybuf((struct v4l2_buffer *)arg);			
+
+		case VIDIOC_QBUF:
+			return tcc_videobuf_qbuf((struct v4l2_buffer *)arg);						
+
+		case VIDIOC_DQBUF:
+			return tcc_videobuf_dqbuf((struct v4l2_buffer *)arg, file);						
+			
+		case VIDIOC_STREAMON:
+			return tcc_videobuf_streamon((enum v4l2_buf_type *)arg);
+
+		case VIDIOC_STREAMOFF:
+			return tcc_videobuf_streamoff((enum v4l2_buf_type *)arg);
+
+		case VIDIOC_OVERLAY:
+			return -EINVAL;
+
+		case VIDIOC_ENUMSTD:
+		case VIDIOC_G_STD:
+		case VIDIOC_S_STD:
+		case VIDIOC_QUERYSTD:
+		{
+			/* Digital cameras don't have an analog video standard, 
+			 * so we don't need to implement these ioctls.
+			 */
+			 return -EINVAL;
+		}
+		case VIDIOC_G_AUDIO:
+		case VIDIOC_S_AUDIO:
+		case VIDIOC_G_AUDOUT:
+		case VIDIOC_S_AUDOUT:
+		{
+			/* we don't have any audio inputs or outputs */
+			return -EINVAL;
+		}
+
+		case VIDIOC_G_JPEGCOMP:
+		case VIDIOC_S_JPEGCOMP:
+		{
+			/* JPEG compression is not supported */
+			return -EINVAL;
+		}
+
+		case VIDIOC_G_TUNER:
+		case VIDIOC_S_TUNER:
+		case VIDIOC_G_MODULATOR:
+		case VIDIOC_S_MODULATOR:
+		case VIDIOC_G_FREQUENCY:
+		case VIDIOC_S_FREQUENCY:
+		{
+			/* we don't have a tuner or modulator */
+			return -EINVAL;
+		}
+
+		case VIDIOC_ENUMOUTPUT:
+		case VIDIOC_G_OUTPUT:
+		case VIDIOC_S_OUTPUT:
+		{
+			/* we don't have any video outputs */
+			return -EINVAL;
+		}
+
+		case VIDIOC_USER_CIF_OVERLAY:
+			return tcc_videobuf_cif_overlay((cif_SuperImpose *)arg);
+			
+		case VIDIOC_USER_JPEG_CAPTURE:
+			return tcc_videobuf_user_jpeg_capture((int *)arg);
+
+		case VIDIOC_USER_GET_CAPTURE_INFO:
+			return tcc_videobuf_user_get_capture_info((TCCXXX_JPEG_ENC_DATA *)arg);
+
+		default:
+		{
+			/* unrecognized ioctl */
+			//return -ENOIOCTLCMD;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ *  file operations
+ */
+
+static unsigned int camera_core_poll(struct file *file, struct poll_table_struct *wait)
+{
+	poll_wait(file, &(hardware_data.frame_wait), wait);	
+
+	if(hardware_data.cif_cfg.cap_status == CAPTURE_DONE)
+	{
+		dprintk("POLL IN ! \r\n");
+		return POLLIN;
+	}
+	else if(hardware_data.cif_cfg.cap_status == CAPTURE_OVERFLOW)
+	{
+		dprintk("POLL ERR ! \r\n");
+		return POLLERR;
+	}
+	//else //cap_status = CAPTURE_NO_INT;
+	//	return 0;
+
+	//if (!list_empty(&(hardware_data.done_list)))
+	//	return POLLIN | POLLRDNORM;
+
+	return 0;
+
+}
+ 
+static ssize_t camera_core_read(struct file *file, char *data, size_t count, loff_t *ppos)
+{
+	struct camera_fh *fh = file->private_data;
+	struct tccxxx_camera_device *cam = fh->cam;
+	//int err;
+	//unsigned long irqflags;
+	//long timeout;
+#if 0	/* use video_buf to do capture */
+	int i;
+	for (i = 0; i < 14; i++)
+		videobuf_read_one(file, &fh->vbq, data, count, ppos);
+	i = videobuf_read_one(file, &fh->vbq, data, count, ppos);
+	return i;
+#endif 
+
+	if (!cam->capture_base) 
+	{
+		cam->capture_base = (unsigned long)dma_alloc_coherent(NULL,
+				cam->pix.sizeimage,
+				(dma_addr_t *) &cam->capture_base_phys,
+				GFP_KERNEL | GFP_DMA);
+	}
+	if (!cam->capture_base) 
+	{
+		printk(KERN_ERR CAM_NAME ": cannot allocate capture buffer\n");
+		return 0;
+	}
+#if 0 //MCC
+	spin_lock_irqsave(&cam->capture_lock, irqflags);
+	cam->reading = fh;
+	cam->capture_started = 1;
+	sg_dma_address(&cam->capture_sglist) = cam->capture_base_phys;
+	sg_dma_len(&cam->capture_sglist)= cam->pix.sizeimage;
+	spin_unlock_irqrestore(&cam->capture_lock, irqflags);
+
+	err = camera_core_sgdma_queue(cam, &cam->capture_sglist, 1,
+			camera_core_capture_callback, NULL);
+
+	/* Wait till DMA is completed */
+	timeout = HZ * 10;
+	cam->capture_completed = 0;
+	while (cam->capture_completed == 0) {
+		timeout = interruptible_sleep_on_timeout 
+				(&cam->new_video_frame, timeout);
+		if (timeout == 0) {
+			printk(KERN_ERR CAM_NAME ": timeout waiting video frame\n");	
+			return -EIO; /* time out */
+		}
+	}
+	/* copy the data to the user buffer */
+	err = copy_to_user(data, (void *)cam->capture_base, cam->pix.sizeimage);
+	return (cam->pix.sizeimage - err);
+#endif 
+    return 0;
+}
+
+#if 0
+static void camera_core_vm_open(struct vm_area_struct *vma)
+{
+//	long idx = (long)vma->vm_private_data;
+	
+//	camera_dev->hardware_data.vma_use_count[idx]++;
+}
+
+static void camera_core_vm_close(struct vm_area_struct *vma)
+{
+//	long idx = (long)vma->vm_private_data;
+	
+//	camera_dev->hardware_data->vma_use_count[idx]--;
+}
+
+static struct vm_operations_struct camera_core_vm_ops = {
+	.open		= camera_core_vm_open,
+	.close		= camera_core_vm_close,
+};
+
+#endif
+
+static int camera_core_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	if(remap_pfn_range(vma,vma->vm_start, vma->vm_pgoff , vma->vm_end - vma->vm_start, vma->vm_page_prot))
+	{
+		return -EAGAIN;
+	}
+
+	vma->vm_ops		= NULL;
+	vma->vm_flags 	|= VM_IO;
+	vma->vm_flags 	|= VM_RESERVED;
+	
+	return 0;
+}
+
+static int camera_core_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+
+	return video_usercopy(inode, file, cmd, arg, camera_core_do_ioctl);
+}
+
+static int camera_core_release(struct inode *inode, struct file *file)
+{
+	printk("camera_core_release \n");
+
+	tccxxx_cif_close();
+	sensor_cleanup();
+
+	// leesw, 2008.03.31, cam power off
+	//PM_CAM_PWR_OFF();
+
+	return 0;
+}
+
+static int camera_core_open(struct inode *inode, struct file *file)
+{
+	int minor = iminor(inode);
+	int status;
+	
+	if (!vfd || (vfd->minor != minor))
+		return -ENODEV;
+
+	dprintk("Sensor PWR-ON \n");
+
+	// leesw, 2008.03.31, cam power on
+	//PM_CAM_PWR_ON();
+	msleep(5);
+
+	dprintk("Sensor Device-Init \n");
+
+	/* initialize the sensor and define a default capture format cam->pix */
+	status = sensor_init(&pix);
+	if (status) 
+	{
+		TDD_CIF_Termination();
+	    printk(KERN_ERR CAM_NAME ": cannot initialize sensor\n");
+
+		// leesw, 2008.03.31, cam power off
+		//PM_CAM_PWR_OFF();
+		
+		return status;
+	}	
+	//msleep(5);
+
+	dprintk("Sensor Register-Init \n");
+	/* program the sensor for the capture format and rate */
+	if (sensor_configure(&pix,xclk))
+	{
+		printk (KERN_ERR CAM_NAME ": Camera sensor configuration failed\n");
+		return -ENODEV;
+	} 
+	
+	// ioremap probe  virtual address problem .!!
+	if (tccxxx_cif_init()) 
+	{
+		printk(KERN_ERR CAM_NAME ": cannot initialize interface hardware\n");
+		return -ENODEV;
+	}
+	
+	if (tccxxx_cif_open())
+	{
+		printk (KERN_ERR CAM_NAME ": Camera IF configuration failed\n");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+
+static struct file_operations camera_core_fops = 
+{
+	.owner			= THIS_MODULE,
+	.llseek			= no_llseek,
+	.read			= camera_core_read,
+	.poll			= camera_core_poll,
+	.ioctl			= camera_core_ioctl,
+	.mmap			= camera_core_mmap,
+	.open			= camera_core_open,
+	.release		= camera_core_release,
+};
+
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void tcc92xx_camera_early_suspend(struct early_suspend *h);
+static void tcc92xx_camera_late_resume(struct early_suspend *h);
+#endif
+
+static int __init camera_core_probe(struct platform_device *pdev)
+{
+	int	status;
+
+	dprintk("camera_core_probe \n");
+
+	/* initialize the video_device struct */
+	vfd = video_device_alloc();
+	if (!vfd) 
+	{
+		printk(KERN_ERR CAM_NAME": could not allocate video device struct\n");
+		status = -ENOMEM;
+		goto err0;
+	}
+	
+ 	vfd->release = video_device_release;
+
+ 	strlcpy(vfd->name, CAM_NAME, sizeof(vfd->name));
+ 	//vfd->type = VID_TYPE_CAPTURE | VID_TYPE_OVERLAY | VID_TYPE_CHROMAKEY;
+ 	
+ 	/* need to register for a VID_HARDWARE_* ID in videodev.h */
+ 	vfd->fops = &camera_core_fops;
+// 	video_set_drvdata(vfd, NULL);
+ 	vfd->minor = -1;
+
+
+	/* initialize the camera interface */
+/*	// ioremap probe  virtual address problem .!!
+	status = tccxxx_cif_init();	
+	if (status != 0) 
+	{
+		printk(KERN_ERR CAM_NAME ": cannot initialize interface hardware\n");
+		status = -ENODEV;
+		goto err1;
+	}
+*/
+
+//	platform_set_drvdata(pdev, cam);
+	
+	if (video_register_device(vfd, VFL_TYPE_GRABBER, video_nr) < 0) 
+	{
+		printk(KERN_ERR CAM_NAME ": could not register Video for Linux device\n");
+		status = -ENODEV;
+		goto err1;
+	}
+
+	printk(KERN_INFO CAM_NAME ": registered device video%d [v4l2]\n", vfd->minor);
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	early_suspend.suspend = tcc92xx_camera_early_suspend;
+	early_suspend.resume  = tcc92xx_camera_late_resume;
+	early_suspend.level   = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
+	register_early_suspend(&early_suspend);
+#endif
+
+//	tmp_i2c_add();
+	return 0;
+
+
+ err1:
+	video_device_release(vfd);
+ err0:
+	return status;
+}
+
+static int camera_core_remove(struct platform_device *pdev)
+{
+	dprintk("camera_core_remove \n");
+
+//	tmp_i2c_del();
+	video_unregister_device(vfd);
+	video_device_release(vfd);
+	return 0;
+}
+
+int camera_core_suspend(struct platform_device *pdev, pm_message_t state)
+{
+
+
+	return 0;
+}
+
+
+
+int camera_core_resume(struct platform_device *pdev)
+{
+
+
+
+	return 0;
+}
+
+
+
+
+static struct platform_driver camera_core_driver = {
+	.driver = {
+		.name		= CAM_NAME,
+		.owner		= THIS_MODULE,
+	},
+	.probe			= camera_core_probe,
+	.remove			= camera_core_remove,
+	.suspend		= camera_core_suspend,
+	.resume			= camera_core_resume,
+};
+
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void tcc92xx_camera_early_suspend(struct early_suspend *h)
+{
+	printk(" %s\n", __func__);
+	camera_core_driver.suspend;
+
+}
+static void tcc92xx_camera_late_resume(struct early_suspend *h)
+{
+	printk(" %s\n", __func__);
+	camera_core_driver.resume;
+}
+
+#endif
+
+
+static struct platform_device camera_core_device = {
+	.name	= CAM_NAME,
+	.dev	= {
+			.release 	= NULL,
+		  },
+	.id	= 0,
+};
+
+void __exit
+camera_core_cleanup(void)
+{
+	dprintk("camera_core_cleanup \n");
+
+	platform_driver_unregister(&camera_core_driver);
+	platform_device_unregister(&camera_core_device);
+
+	return;
+}
+
+static char banner[] __initdata = KERN_INFO "TCCXXX Camera driver initializing\n";
+
+int __init 
+camera_core_init(void)
+{
+	dprintk("camera_core_init \n");
+		
+	printk(banner);
+	platform_device_register(&camera_core_device);
+	platform_driver_register(&camera_core_driver);
+
+	return 0;
+}
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_VERSION(DRIVER_VERSION);
+MODULE_LICENSE("GPL");
+module_param(video_nr, int, 0);
+MODULE_PARM_DESC(video_nr, "Minor number for video device (-1 ==> auto assign)");
+module_param(capture_mem, int, 0);
+MODULE_PARM_DESC(capture_mem, "Maximum amount of memory for capture buffers (default 4800KB)");
+module_init(camera_core_init);
+module_exit(camera_core_cleanup);
+
Index: linux-2.6.29/drivers/media/video/tcccam/camera_core.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/tcccam/camera_core.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,137 @@
+/*
+ *  drivers/media/video/tcccam/camera_core.h
+ *
+ * Copyright (C) 2008 Telechips, Inc. 
+ * 
+ * This package is free software; you can redistribute it and/or modify 
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation. 
+ * 
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR 
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED 
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. 
+ */
+
+#ifndef CAMERA_CORE__H
+#define CAMERA_CORE__H
+
+struct camera_fh;
+
+#include <media/videobuf-dma-sg.h>
+#include <asm/scatterlist.h>
+//#include <linux/wakelock.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+struct tccxxx_camera_device;
+
+typedef void (*dma_callback_t)(void *arg1, void *arg2);
+ 
+/* per-device data structure */
+struct tccxxx_camera_device {
+	struct device dev;
+	struct video_device *vfd;
+	
+	spinlock_t overlay_lock;        /* spinlock for overlay DMA counter */
+	int overlay_cnt;                /* count of queued overlay DMA xfers */
+	unsigned long overlay_base_phys;
+	unsigned long overlay_base;
+	unsigned long overlay_size;
+
+	spinlock_t vbq_lock;            /* spinlock for videobuf queues */
+	unsigned long field_count;      /* field counter for videobuf_buffer */
+
+	/* The img_lock is used to serialize access to the image parameters for 
+	 * overlay and capture.  Need to use spin_lock_irq when writing to the 
+	 * reading, streaming, and previewing parameters.  A regular spin_lock 
+	 * will suffice for all other cases.
+	 */
+	spinlock_t img_lock;
+ 
+ 	/* We allow reading from at most one filehandle at a time.
+ 	 * non-NULL means reading is in progress.
+ 	 */
+ 	struct camera_fh *reading;
+ 	/* We allow streaming from at most one filehandle at a time.  
+ 	 * non-NULL means streaming is in progress.
+ 	 */
+	struct camera_fh *streaming;
+	/* We allow previewing from at most one filehandle at a time.  
+	 * non-NULL means previewing is in progress.
+	 */
+	struct camera_fh *previewing;
+
+	/* capture parameters (frame rate, number of buffers) */
+	struct v4l2_captureparm cparm;
+
+	/* This is the frame period actually requested by the user. */
+	struct v4l2_fract nominal_timeperframe;
+	
+	/* frequency (in Hz) of camera interface xclk output */
+	unsigned long xclk;
+
+	/* Pointer to the sensor interface ops */
+	struct tcc_camera_sensor *cam_sensor;
+	void *sensor_data;
+	
+	/* Pointer to the camera interface hardware ops */
+	struct camera_hardware *cam_hardware;
+	void *hardware_data;                                     //struct TCCxxxCIF 
+
+	/* pix defines the size and pixel format of the image captured by the 
+	 * sensor.  This also defines the size of the framebuffers.  The 
+	 * same pool of framebuffers is used for video capture and video 
+	 * overlay.  These parameters are set/queried by the 
+	 * VIDIOC_S_FMT/VIDIOC_G_FMT ioctls with a CAPTURE buffer type.
+	 */
+	struct v4l2_pix_format pix;
+	struct v4l2_pix_format pix2;
+
+	/* crop defines the size and offset of the video overlay source window 
+	 * within the framebuffer.  These parameters are set/queried by the 
+	 * VIDIOC_S_CROP/VIDIOC_G_CROP ioctls with an OVERLAY buffer type.  
+	 * The cropping rectangle allows a subset of the captured image to be 
+	 * previewed.  It only affects the portion of the image previewed, not 
+	 * captured; the entire camera image is always captured.
+	 */
+	struct v4l2_rect crop;
+
+	/* win defines the size and offset of the video overlay target window 
+	 * within the video display.  These parameters are set/queried by the 
+	 * VIDIOC_S_FMT/VIDIOC_G_FMT ioctls with an OVERLAY buffer type.
+	 */
+	struct v4l2_window win;
+
+	/* fbuf reflects the size of the video display.  It is queried with the 
+	 * VIDIOC_G_FBUF ioctl.  The size of the video display cannot be 
+	 * changed with the VIDIOC_S_FBUF ioctl.
+	 */
+	struct v4l2_framebuffer fbuf;
+
+	/* end of generic stuff, the above should be common to all omaps */
+
+	/* note, 2420 uses videobuf to do caprure, it is more memory efficient
+	   we need 1710 and 2420 do capture in the same way */
+	/* Variables to store the capture state */
+	/* Wait till DMA is completed */
+	//wkjung
+	//wait_queue_head_t new_video_frame;
+
+	char capture_completed;
+	char capture_started;
+ 	spinlock_t capture_lock;
+	unsigned long capture_base;
+	unsigned long capture_base_phys;
+	struct mutex	lock;
+	char active;
+};
+
+/* per-filehandle data structure */
+struct camera_fh {
+	struct tccxxx_camera_device *cam;
+	enum v4l2_buf_type type;
+};
+
+#define CAM_NAME "tccxxx-camera"
+
+#endif /* CAMERA_CORE__H */
Index: linux-2.6.29/drivers/media/video/tcccam/camera_hw_if.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/tcccam/camera_hw_if.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,22 @@
+/*
+ *  drivers/media/video/tcccam/camera_hw_if.h
+ *
+ * Copyright (C) 2008 Telechips, Inc. 
+ * 
+ * Camera interface to TCC camera capture drivers
+ * Camera interface hardware driver should implement this interface
+ *
+ * This package is free software; you can redistribute it and/or modify 
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation. 
+ * 
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR 
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED 
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. 
+ */
+ 
+#ifndef TCCXX_CAMERA_HW_IF_H
+#define TCCXX_CAMERA_HW_IF_H
+
+#define LEN_HW_IF_NAME		31
+#endif /* TCC78XX_CAMERA_HW_IF_H */
Index: linux-2.6.29/drivers/media/video/tcccam/mt9d111_2mp.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/tcccam/mt9d111_2mp.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,698 @@
+/*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*
+
+               CAMERA    API    M O D U L E
+
+                        EDIT HISTORY FOR MODULE
+
+when        who       what, where, why
+--------    ---       -------------------------------------------------------
+10/xx/08  Telechips   Created file.
+*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*/
+
+/*===========================================================================
+
+                           INCLUDE FILES FOR MODULE
+
+===========================================================================*/
+#include "sensor_if.h"
+
+#ifdef CONFIG_VIDEO_CAMERA_SENSOR_MT9D111
+
+/* Array of image sizes supported by MT9D111.  These must be ordered from 
+ * smallest image size to largest.
+ */
+struct capture_size sensor_sizes[] = {
+	{ 1600, 1200 },	/* UXGA */
+	{ 1280,  960 },	/* SXGA */
+	{ 1024,  768 },	/* XGA */
+	{  800,  600 },	/* SVGA */
+	{  640,  480 },	/* VGA */
+	{  320,  240 },	/* QVGA */
+	{  176,  144 },	/* QCIF */
+};
+
+
+/* register initialization tables for sensor */
+/* common sensor register initialization for all image sizes, pixel formats, 
+ * and frame rates
+ */
+static struct sensor_reg sensor_common[] = {
+    {0xF0, 0x0000},
+    {0x05, 0x012C},    // HORZ_BLANK_B
+    {0x06, 0x004E},    // VERT_BLANK_B
+    {0x07, 0x044C},     // HORZ_BLANK_A
+    {0x08, 0x0023},     // VERT_BLANK_A
+    {0x20, 0x0300},     // READ_MODE_B
+    {0x21, 0x8000},     // READ_MODE_A
+    {0x66, 0x1802},     // PLL_REG
+    {0x67, 0x0501},     // PLL2_REG
+    {0x65, 0xA000},     // CLOCK_ENABLING
+    
+    {0x65, 0x2000},    // CLOCK_ENABLING
+
+    // State Param.
+    {0xF0, 0x0001},
+    {0xC6, 0xA122},    //SEQ_PREVIEW_0_AE
+    {0xC8, 0x0001},    //SEQ_PREVIEW_0_AE
+    {0xC6, 0xA123},    //SEQ_PREVIEW_0_FD
+    {0xC8, 0x0000},    //SEQ_PREVIEW_0_FD
+    {0xC6, 0xA124},    //SEQ_PREVIEW_0_AWB
+    {0xC8, 0x0001},    //SEQ_PREVIEW_0_AWB
+    {0xC6, 0xA125},    //SEQ_PREVIEW_0_AF
+    {0xC8, 0x0000},    //SEQ_PREVIEW_0_AF
+    {0xC6, 0xA126},    //SEQ_PREVIEW_0_HG
+    {0xC8, 0x0001},    //SEQ_PREVIEW_0_HG
+    {0xC6, 0xA127},    //SEQ_PREVIEW_0_FLASH
+    {0xC8, 0x0000},    //SEQ_PREVIEW_0_FLASH
+    {0xC6, 0xA128},    //SEQ_PREVIEW_0_SKIPFRAME
+    {0xC8, 0x0040},    //SEQ_PREVIEW_0_SKIPFRAME
+    {0xC6, 0xA129},    //SEQ_PREVIEW_1_AE
+    {0xC8, 0x0003},    //SEQ_PREVIEW_1_AE
+    {0xC6, 0xA12A},    //SEQ_PREVIEW_1_FD
+    {0xC8, 0x0002},    //SEQ_PREVIEW_1_FD
+    {0xC6, 0xA12B},    //SEQ_PREVIEW_1_AWB
+    {0xC8, 0x0003},    //SEQ_PREVIEW_1_AWB
+    {0xC6, 0xA12C},    //SEQ_PREVIEW_1_AF
+    {0xC8, 0x0000},    //SEQ_PREVIEW_1_AF
+    {0xC6, 0xA12D},    //SEQ_PREVIEW_1_HG
+    {0xC8, 0x0003},    //SEQ_PREVIEW_1_HG
+    {0xC6, 0xA12E},    //SEQ_PREVIEW_1_FLASH
+    {0xC8, 0x0000},    //SEQ_PREVIEW_1_FLASH
+    {0xC6, 0xA12F},    //SEQ_PREVIEW_1_SKIPFRAME
+    {0xC8, 0x0000},    //SEQ_PREVIEW_1_SKIPFRAME
+    {0xC6, 0xA130},    //SEQ_PREVIEW_2_AE
+    {0xC8, 0x0004},    //SEQ_PREVIEW_2_AE
+    {0xC6, 0xA131},    //SEQ_PREVIEW_2_FD
+    {0xC8, 0x0000},    //SEQ_PREVIEW_2_FD
+    {0xC6, 0xA132},    //SEQ_PREVIEW_2_AWB
+    {0xC8, 0x0001},    //SEQ_PREVIEW_2_AWB
+    {0xC6, 0xA133},    //SEQ_PREVIEW_2_AF
+    {0xC8, 0x0000},    //SEQ_PREVIEW_2_AF
+    {0xC6, 0xA134},    //SEQ_PREVIEW_2_HG
+    {0xC8, 0x0001},    //SEQ_PREVIEW_2_HG
+    {0xC6, 0xA135},    //SEQ_PREVIEW_2_FLASH
+    {0xC8, 0x0000},    //SEQ_PREVIEW_2_FLASH
+    {0xC6, 0xA136},    //SEQ_PREVIEW_2_SKIPFRAME
+    {0xC8, 0x0000},    //SEQ_PREVIEW_2_SKIPFRAME
+    {0xC6, 0xA137},    //SEQ_PREVIEW_3_AE
+    {0xC8, 0x0000},    //SEQ_PREVIEW_3_AE
+    {0xC6, 0xA138},    //SEQ_PREVIEW_3_FD
+    {0xC8, 0x0000},    //SEQ_PREVIEW_3_FD
+    {0xC6, 0xA139},    //SEQ_PREVIEW_3_AWB
+    {0xC8, 0x0000},    //SEQ_PREVIEW_3_AWB
+    {0xC6, 0xA13A},    //SEQ_PREVIEW_3_AF
+    {0xC8, 0x0000},    //SEQ_PREVIEW_3_AF
+    {0xC6, 0xA13B},    //SEQ_PREVIEW_3_HG
+    {0xC8, 0x0000},    //SEQ_PREVIEW_3_HG
+    {0xC6, 0xA13C},    //SEQ_PREVIEW_3_FLASH
+    {0xC8, 0x0000},    //SEQ_PREVIEW_3_FLASH
+    {0xC6, 0xA13D},    //SEQ_PREVIEW_3_SKIPFRAME
+    {0xC8, 0x0040},    //SEQ_PREVIEW_3_SKIPFRAME
+    // Sensor Timing Setting (54MHz)
+    {0xC6, 0x2703},    //MODE_OUTPUT_WIDTH_A
+    {0xC8, 0x0320},    //MODE_OUTPUT_WIDTH_A
+    {0xC6, 0x2705},    //MODE_OUTPUT_HEIGHT_A
+    {0xC8, 0x0258},    //MODE_OUTPUT_HEIGHT_A
+    {0xC6, 0x2707},    //MODE_OUTPUT_WIDTH_B
+    {0xC8, 0x0640},    //MODE_OUTPUT_WIDTH_B
+    {0xC6, 0x2709},    //MODE_OUTPUT_HEIGHT_B
+    {0xC8, 0x04B0},    //MODE_OUTPUT_HEIGHT_B
+    {0xC6, 0x270B},    //MODE_CONFIG
+    {0xC8, 0x0030},    //MODE_CONFIG
+    {0xC6, 0x270F},    //MODE_SENSOR_ROW_START_A
+    {0xC8, 0x001C},    //MODE_SENSOR_ROW_START_A
+    {0xC6, 0x2711},    //MODE_SENSOR_COL_START_A
+    {0xC8, 0x003C},    //MODE_SENSOR_COL_START_A
+    {0xC6, 0x2713},    //MODE_SENSOR_ROW_HEIGHT_A
+    {0xC8, 0x04B0},    //MODE_SENSOR_ROW_HEIGHT_A
+    {0xC6, 0x2715},    //MODE_SENSOR_COL_WIDTH_A
+    {0xC8, 0x0640},    //MODE_SENSOR_COL_WIDTH_A
+    {0xC6, 0x2717},    //MODE_SENSOR_X_DELAY_A
+    {0xC8, 0x01AC},    //MODE_SENSOR_X_DELAY_A
+    {0xC6, 0x2719},    //MODE_SENSOR_ROW_SPEED_A
+    {0xC8, 0x0011},    //MODE_SENSOR_ROW_SPEED_A
+    {0xC6, 0x271B},    //MODE_SENSOR_ROW_START_B
+    {0xC8, 0x001C},    //MODE_SENSOR_ROW_START_B
+    {0xC6, 0x271D},    //MODE_SENSOR_COL_START_B
+    {0xC8, 0x003C},    //MODE_SENSOR_COL_START_B
+    {0xC6, 0x271F},    //MODE_SENSOR_ROW_HEIGHT_B
+    {0xC8, 0x04B0},    //MODE_SENSOR_ROW_HEIGHT_B
+    {0xC6, 0x2721},    //MODE_SENSOR_COL_WIDTH_B
+    {0xC8, 0x0640},    //MODE_SENSOR_COL_WIDTH_B
+    {0xC6, 0x2723},    //MODE_SENSOR_X_DELAY_B
+    {0xC8, 0x0359},    //MODE_SENSOR_X_DELAY_B
+    {0xC6, 0x2725},    //MODE_SENSOR_ROW_SPEED_B
+    {0xC8, 0x0011},    //MODE_SENSOR_ROW_SPEED_B
+    {0xC6, 0x2727},    //MODE_CROP_X0_A
+    {0xC8, 0x0000},    //MODE_CROP_X0_A
+    {0xC6, 0x2729},    //MODE_CROP_X1_A
+    {0xC8, 0x0320},    //MODE_CROP_X1_A
+    {0xC6, 0x272B},    //MODE_CROP_Y0_A
+    {0xC8, 0x0000},    //MODE_CROP_Y0_A
+    {0xC6, 0x272D},    //MODE_CROP_Y1_A
+    {0xC8, 0x0258},    //MODE_CROP_Y1_A
+    {0xC6, 0x2735},    //MODE_CROP_X0_B
+    {0xC8, 0x0000},    //MODE_CROP_X0_B
+    {0xC6, 0x2737},    //MODE_CROP_X1_B
+    {0xC8, 0x0640},    //MODE_CROP_X1_B
+    {0xC6, 0x2739},    //MODE_CROP_Y0_B
+    {0xC8, 0x0000},    //MODE_CROP_Y0_B
+    {0xC6, 0x273B},    //MODE_CROP_Y1_B
+    {0xC8, 0x04B0},    //MODE_CROP_Y1_B
+    // Gamma
+
+    {0xC6, 0xA743},    //MODE_GAM_CONT_A
+    {0xC8, 0x0041},    //MODE_GAM_CONT_A
+    {0xC6, 0xA744},    //MODE_GAM_CONT_B
+    {0xC8, 0x0041},    //MODE_GAM_CONT_B
+    {0xC6, 0xA745},    //MODE_GAM_TABLE_A_0
+    {0xC8, 0x0000},    //MODE_GAM_TABLE_A_0
+    {0xC6, 0xA746},    //MODE_GAM_TABLE_A_1
+    {0xC8, 0x0009},    //MODE_GAM_TABLE_A_1
+    {0xC6, 0xA747},    //MODE_GAM_TABLE_A_2
+    {0xC8, 0x0012},    //MODE_GAM_TABLE_A_2
+    {0xC6, 0xA748},    //MODE_GAM_TABLE_A_3
+    {0xC8, 0x0025},    //MODE_GAM_TABLE_A_3
+    {0xC6, 0xA749},    //MODE_GAM_TABLE_A_4
+    {0xC8, 0x0045},    //MODE_GAM_TABLE_A_4
+    {0xC6, 0xA74A},    //MODE_GAM_TABLE_A_5
+    {0xC8, 0x0061},    //MODE_GAM_TABLE_A_5
+    {0xC6, 0xA74B},    //MODE_GAM_TABLE_A_6
+    {0xC8, 0x0075},    //MODE_GAM_TABLE_A_6
+    {0xC6, 0xA74C},    //MODE_GAM_TABLE_A_7
+    {0xC8, 0x0086},    //MODE_GAM_TABLE_A_7
+    {0xC6, 0xA74D},    //MODE_GAM_TABLE_A_8
+    {0xC8, 0x0094},    //MODE_GAM_TABLE_A_8
+    {0xC6, 0xA74E},    //MODE_GAM_TABLE_A_9
+    {0xC8, 0x00A1},    //MODE_GAM_TABLE_A_9
+    {0xC6, 0xA74F},    //MODE_GAM_TABLE_A_10
+    {0xC8, 0x00AE},    //MODE_GAM_TABLE_A_10
+    {0xC6, 0xA750},    //MODE_GAM_TABLE_A_11
+    {0xC8, 0x00B9},    //MODE_GAM_TABLE_A_11
+    {0xC6, 0xA751},    //MODE_GAM_TABLE_A_12
+    {0xC8, 0x00C4},    //MODE_GAM_TABLE_A_12
+    {0xC6, 0xA752},    //MODE_GAM_TABLE_A_13
+    {0xC8, 0x00CF},    //MODE_GAM_TABLE_A_13
+    {0xC6, 0xA753},    //MODE_GAM_TABLE_A_14
+    {0xC8, 0x00D9},    //MODE_GAM_TABLE_A_14
+    {0xC6, 0xA754},    //MODE_GAM_TABLE_A_15
+    {0xC8, 0x00E3},    //MODE_GAM_TABLE_A_15
+    {0xC6, 0xA755},    //MODE_GAM_TABLE_A_16
+    {0xC8, 0x00ED},    //MODE_GAM_TABLE_A_16
+    {0xC6, 0xA756},    //MODE_GAM_TABLE_A_17
+    {0xC8, 0x00F6},    //MODE_GAM_TABLE_A_17
+    {0xC6, 0xA757},    //MODE_GAM_TABLE_A_18
+    {0xC8, 0x00FF},    //MODE_GAM_TABLE_A_18
+    {0xC6, 0xA758},    //MODE_GAM_TABLE_B_0
+    {0xC8, 0x0000},    //MODE_GAM_TABLE_B_0
+    {0xC6, 0xA759},    //MODE_GAM_TABLE_B_1
+    {0xC8, 0x0009},    //MODE_GAM_TABLE_B_1
+    {0xC6, 0xA75A},    //MODE_GAM_TABLE_B_2
+    {0xC8, 0x0012},    //MODE_GAM_TABLE_B_2
+    {0xC6, 0xA75B},    //MODE_GAM_TABLE_B_3
+    {0xC8, 0x0025},    //MODE_GAM_TABLE_B_3
+    {0xC6, 0xA75C},    //MODE_GAM_TABLE_B_4
+    {0xC8, 0x0045},    //MODE_GAM_TABLE_B_4
+    {0xC6, 0xA75D},    //MODE_GAM_TABLE_B_5
+    {0xC8, 0x0061},    //MODE_GAM_TABLE_B_5
+    {0xC6, 0xA75E},    //MODE_GAM_TABLE_B_6
+    {0xC8, 0x0075},    //MODE_GAM_TABLE_B_6
+    {0xC6, 0xA75F},    //MODE_GAM_TABLE_B_7
+    {0xC8, 0x0086},    //MODE_GAM_TABLE_B_7
+    {0xC6, 0xA760},    //MODE_GAM_TABLE_B_8
+    {0xC8, 0x0094},    //MODE_GAM_TABLE_B_8
+    {0xC6, 0xA761},    //MODE_GAM_TABLE_B_9
+    {0xC8, 0x00A1},    //MODE_GAM_TABLE_B_9
+    {0xC6, 0xA762},    //MODE_GAM_TABLE_B_10
+    {0xC8, 0x00AE},    //MODE_GAM_TABLE_B_10
+    {0xC6, 0xA763},    //MODE_GAM_TABLE_B_11
+    {0xC8, 0x00B9},    //MODE_GAM_TABLE_B_11
+    {0xC6, 0xA764},    //MODE_GAM_TABLE_B_12
+    {0xC8, 0x00C4},    //MODE_GAM_TABLE_B_12
+    {0xC6, 0xA765},    //MODE_GAM_TABLE_B_13
+    {0xC8, 0x00CF},    //MODE_GAM_TABLE_B_13
+    {0xC6, 0xA766},    //MODE_GAM_TABLE_B_14
+    {0xC8, 0x00D9},    //MODE_GAM_TABLE_B_14
+    {0xC6, 0xA767},    //MODE_GAM_TABLE_B_15
+    {0xC8, 0x00E3},    //MODE_GAM_TABLE_B_15
+    {0xC6, 0xA768},    //MODE_GAM_TABLE_B_16
+    {0xC8, 0x00ED},    //MODE_GAM_TABLE_B_16
+    {0xC6, 0xA769},    //MODE_GAM_TABLE_B_17
+    {0xC8, 0x00F6},    //MODE_GAM_TABLE_B_17
+    {0xC6, 0xA76A},    //MODE_GAM_TABLE_B_18
+    {0xC8, 0x00FF},    //MODE_GAM_TABLE_B_18
+    // AE Param.
+    {0xC6, 0x276D},    //MODE_FIFO_CONF1_A
+    {0xC8, 0xE0E2},    //MODE_FIFO_CONF1_A
+    {0xC6, 0xA76F},    //MODE_FIFO_CONF2_A
+    {0xC8, 0x00E1},    //MODE_FIFO_CONF2_A
+    {0xC6, 0x2774},    //MODE_FIFO_CONF1_B
+    {0xC8, 0xE0E1},    //MODE_FIFO_CONF1_B
+    {0xC6, 0xA776},    //MODE_FIFO_CONF2_B
+    {0xC8, 0x00E1},    //MODE_FIFO_CONF2_B
+    {0xC6, 0x220B},    //AE_MAX_R12
+    {0xC8, 0x024D},    //AE_MAX_R12
+    {0xC6, 0xA217},    //AE_INDEX_TH23
+    {0xC8, 0x0008},    //AE_INDEX_TH23
+    {0xC6, 0x2228},    //AE_ROWTIME
+    {0xC8, 0x01DB},    //AE_ROWTIME
+    {0xC6, 0x222F},    //AE_R9_STEP
+    {0xC8, 0x0075},    //AE_R9_STEP
+    {0xC6, 0xA408},    //FD_SEARCH_F1_50
+    {0xC8, 0x0016},    //FD_SEARCH_F1_50
+    {0xC6, 0xA409},    //FD_SEARCH_F2_50
+    {0xC8, 0x0018},    //FD_SEARCH_F2_50
+    {0xC6, 0xA40A},    //FD_SEARCH_F1_60
+    {0xC8, 0x001B},    //FD_SEARCH_F1_60
+    {0xC6, 0xA40B},    //FD_SEARCH_F2_60
+    {0xC8, 0x001D},    //FD_SEARCH_F2_60
+    {0xC6, 0x2411},    //FD_R9_STEP60
+    {0xC8, 0x0075},    //FD_R9_STEP60
+    {0xC6, 0x2413},    //FD_R9_STEP50
+    {0xC8, 0x008D},    //FD_R9_STEP50
+    // Initial - Refresh
+    {0xC6, 0xA103},    //SEQ_CMD
+    {0xC8, 0x0005},    //SEQ_CMD
+
+    {0xF0, 0x0001},
+    {0xC6, 0xA103}, 
+    {0xC8, 0x0006},    //SEQ_CMD
+
+    // Lens Shading
+    {0xF0, 0x0002},
+    {0x80, 0x01F0},     // LENS_CORRECTION_CONTROL
+    {0x81, 0x6432},     // ZONE_BOUNDS_X1_X2
+    {0x82, 0x3296},     // ZONE_BOUNDS_X0_X3
+    {0x83, 0x9664},     // ZONE_BOUNDS_X4_X5
+    {0x84, 0x5028},     // ZONE_BOUNDS_Y1_Y2
+    {0x85, 0x2878},     // ZONE_BOUNDS_Y0_Y3
+    {0x86, 0x7850},     // ZONE_BOUNDS_Y4_Y5
+    {0x87, 0x0000},     // CENTER_OFFSET
+    {0x88, 0x0107},     // FX_RED
+    {0x8B, 0x00B6},     // FY_RED
+    {0x8E, 0x091A},     // DF_DX_RED
+    {0x91, 0x0A98},     // DF_DY_RED
+    {0x94, 0xF615},     // SECOND_DERIV_ZONE_0_RED
+    {0x97, 0x1F22},     // SECOND_DERIV_ZONE_1_RED
+    {0x9A, 0x2D59},     // SECOND_DERIV_ZONE_2_RED
+    {0x9D, 0x464B},     // SECOND_DERIV_ZONE_3_RED
+    {0xA0, 0x4441},     // SECOND_DERIV_ZONE_4_RED
+    {0xA3, 0x5446},     // SECOND_DERIV_ZONE_5_RED
+    {0xA6, 0x0418},     // SECOND_DERIV_ZONE_6_RED
+    {0xA9, 0xF723},     // SECOND_DERIV_ZONE_7_RED
+    {0x89, 0x00C4},     // FX_GREEN
+    {0x8C, 0x007B},     // FY_GREEN
+    {0x8F, 0x09E1},     // DF_DX_GREEN
+    {0x92, 0x0B1C},     // DF_DY_GREEN
+    {0x95, 0x0B19},     // SECOND_DERIV_ZONE_0_GREEN
+    {0x98, 0x1435},     // SECOND_DERIV_ZONE_1_GREEN
+    {0x9B, 0x2646},     // SECOND_DERIV_ZONE_2_GREEN
+    {0x9E, 0x3C36},     // SECOND_DERIV_ZONE_3_GREEN
+    {0xA1, 0x3231},     // SECOND_DERIV_ZONE_4_GREEN
+    {0xA4, 0x4032},     // SECOND_DERIV_ZONE_5_GREEN
+    {0xA7, 0x0D25},     // SECOND_DERIV_ZONE_6_GREEN
+    {0xAA, 0xBAD3},     // SECOND_DERIV_ZONE_7_GREEN
+    {0x8A, 0x00BB},     // FX_BLUE
+    {0x8D, 0x00A0},     // FY_BLUE
+    {0x90, 0x0A11},     // DF_DX_BLUE
+    {0x93, 0x0BCC},     // DF_DY_BLUE
+    {0x96, 0x0E44},     // SECOND_DERIV_ZONE_0_BLUE
+    {0x99, 0x0F2F},     // SECOND_DERIV_ZONE_1_BLUE
+    {0x9C, 0x1D3E},     // SECOND_DERIV_ZONE_2_BLUE
+    {0x9F, 0x3027},     // SECOND_DERIV_ZONE_3_BLUE
+    {0xA2, 0x2725},     // SECOND_DERIV_ZONE_4_BLUE
+    {0xA5, 0x3A24},     // SECOND_DERIV_ZONE_5_BLUE
+    {0xA8, 0x0412},     // SECOND_DERIV_ZONE_6_BLUE
+    {0xAB, 0xEF29},     // SECOND_DERIV_ZONE_7_BLUE
+    {0xAC, 0x8018},     // X2_FACTORS
+    {0xAD, 0x0000},     // GLOBAL_OFFSET_FXY_FUNCTION
+    {0xAE, 0x0000},     // K_FACTOR_IN_K_FX_FY
+    {0xF0, 0x0001},
+    {0x08, 0x01FC},     // COLOR_PIPELINE_CONTROL
+    // AE Target
+    {0xC6, 0xA206},    //AE_TARGET
+    {0xC8, 0x004A},    //AE_TARGET
+    // AWB & CCM Param.
+    {0xC6, 0x2306},    //AWB_CCM_L_0
+    {0xC8, 0x0266},    //AWB_CCM_L_0
+    {0xC6, 0x2308},    //AWB_CCM_L_1
+    {0xC8, 0xFEA1},    //AWB_CCM_L_1
+    {0xC6, 0x230A},    //AWB_CCM_L_2
+    {0xC8, 0x0000},    //AWB_CCM_L_2
+    {0xC6, 0x230C},    //AWB_CCM_L_3
+    {0xC8, 0xFEDF},    //AWB_CCM_L_3
+    {0xC6, 0x230E},    //AWB_CCM_L_4
+    {0xC8, 0x0255},    //AWB_CCM_L_4
+    {0xC6, 0x2310},    //AWB_CCM_L_5
+    {0xC8, 0xFFD7},    //AWB_CCM_L_5
+    {0xC6, 0x2312},    //AWB_CCM_L_6
+    {0xC8, 0xFF31},    //AWB_CCM_L_6
+    {0xC6, 0x2314},    //AWB_CCM_L_7
+    {0xC8, 0xFD96},    //AWB_CCM_L_7
+    {0xC6, 0x2316},    //AWB_CCM_L_8
+    {0xC8, 0x046E},    //AWB_CCM_L_8
+    {0xC6, 0x2318},    //AWB_CCM_L_9
+    {0xC8, 0x0020},    //AWB_CCM_L_9
+    {0xC6, 0x231A},    //AWB_CCM_L_10
+    {0xC8, 0x0035},    //AWB_CCM_L_10
+    {0xC6, 0x231C},    //AWB_CCM_RL_0
+    {0xC8, 0xFF3C},    //AWB_CCM_RL_0
+    {0xC6, 0x231E},    //AWB_CCM_RL_1
+    {0xC8, 0x00B9},    //AWB_CCM_RL_1
+    {0xC6, 0x2320},    //AWB_CCM_RL_2
+    {0xC8, 0x0002},    //AWB_CCM_RL_2
+    {0xC6, 0x2322},    //AWB_CCM_RL_3
+    {0xC8, 0x00D4},    //AWB_CCM_RL_3
+    {0xC6, 0x2324},    //AWB_CCM_RL_4
+    {0xC8, 0xFF77},    //AWB_CCM_RL_4
+    {0xC6, 0x2326},    //AWB_CCM_RL_5
+    {0xC8, 0xFFE1},    //AWB_CCM_RL_5
+    {0xC6, 0x2328},    //AWB_CCM_RL_6
+    {0xC8, 0x00B4},    //AWB_CCM_RL_6
+    {0xC6, 0x232A},    //AWB_CCM_RL_7
+    {0xC8, 0x01D3},    //AWB_CCM_RL_7
+    {0xC6, 0x232C},    //AWB_CCM_RL_8
+    {0xC8, 0xFD3F},    //AWB_CCM_RL_8
+    {0xC6, 0x232E},    //AWB_CCM_RL_9
+    {0xC8, 0x000A},    //AWB_CCM_RL_9
+    {0xC6, 0x2330},    //AWB_CCM_RL_10
+    {0xC8, 0xFFF1},    //AWB_CCM_RL_10
+    {0xC6, 0xA348},    //AWB_GAIN_BUFFER_SPEED
+    {0xC8, 0x0008},    //AWB_GAIN_BUFFER_SPEED
+    {0xC6, 0xA349},    //AWB_JUMP_DIVISOR
+    {0xC8, 0x0002},    //AWB_JUMP_DIVISOR
+    {0xC6, 0xA34A},    //AWB_GAIN_MIN
+    {0xC8, 0x0053},    //AWB_GAIN_MIN
+    {0xC6, 0xA34B},    //AWB_GAIN_MAX
+    {0xC8, 0x00C0},    //AWB_GAIN_MAX
+    {0xC6, 0xA34F},    //AWB_CCM_POSITION_MIN
+    {0xC8, 0x0000},    //AWB_CCM_POSITION_MIN
+    {0xC6, 0xA350},    //AWB_CCM_POSITION_MAX
+    {0xC8, 0x007F},    //AWB_CCM_POSITION_MAX
+    {0xC6, 0xA352},    //AWB_SATURATION
+    {0xC8, 0x0090},    //AWB_SATURATION
+    {0xC6, 0xA35B},    //AWB_STEADY_BGAIN_OUT_MIN
+    {0xC8, 0x0073},    //AWB_STEADY_BGAIN_OUT_MIN
+    {0xC6, 0xA35C},    //AWB_STEADY_BGAIN_OUT_MAX
+    {0xC8, 0x008C},    //AWB_STEADY_BGAIN_OUT_MAX
+    {0xC6, 0xA35D},    //AWB_STEADY_BGAIN_IN_MIN
+    {0xC8, 0x007C},    //AWB_STEADY_BGAIN_IN_MIN
+    {0xC6, 0xA35E},    //AWB_STEADY_BGAIN_IN_MAX
+    {0xC8, 0x0083},    //AWB_STEADY_BGAIN_IN_MAX
+    {0xC6, 0x235F},    //AWB_CNT_PXL_TH
+    {0xC8, 0x0064},    //AWB_CNT_PXL_TH
+    {0xC6, 0xA361},    //AWB_TG_MIN0
+    {0xC8, 0x00E2},    //AWB_TG_MIN0
+    {0xC6, 0xA362},    //AWB_TG_MAX0
+    {0xC8, 0x00F6},    //AWB_TG_MAX0
+    {0xC6, 0xA302},    //AWB_WINDOW_POS
+    {0xC8, 0x0000},    //AWB_WINDOW_POS
+    {0xC6, 0xA303},    //AWB_WINDOW_SIZE
+    {0xC8, 0x00EF},    //AWB_WINDOW_SIZE
+    {0xC6, 0xA103},    //SEQ_CMD
+    {0xC8, 0x0005},    //SEQ_CMD        
+
+    {0xF0, 0x0002},    // 2 Page Select    
+    // Context B YUV Output Setting
+    {0xC6, 0x270B},     //MODE_CONFIG
+    {0xC8, 0x0030},     //MODE_CONFIG
+    {0xC6, 0xA77E},     //MODE_OUTPUT_FORMAT_B
+    {0xC8, 0x0000},     //MODE_OUTPUT_FORMAT_B
+    {0xC6, 0x2774},     //MODE_FIFO_CONF1_B
+    {0xC8, 0xE5E1},     //MODE_FIFO_CONF1_B
+    {0xC6, 0xA776},     //MODE_FIFO_CONF2_B
+    {0xC8, 0x00E3},     //MODE_FIFO_CONF2_B
+
+
+    {0xF0, 0x0001},
+    {0xC6, 0xA120},
+    {0xC8, 0x0000},
+    {0xC6, 0xA103},
+    {0xC8, 0x0001},
+    {REG_TERM, VAL_TERM}
+};
+
+
+static struct sensor_reg sensor_preview[] = {
+    {0xF0, 0x0001},
+    {0xC6, 0xA120},
+    {0xC8, 0x0000},
+    {0xC6, 0xA103},
+    {0xC8, 0x0001},
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_capture[] = {
+    {0xF0, 0x0001},
+    {0xC6, 0x270B},
+    {0xC8, 0x0030},
+    {0xC6, 0xA77E},
+    {0xC8, 0x0000},
+    {0xC6, 0x2774},
+    {0xC8, 0xE5E1},
+    {0xC6, 0xA776},
+    {0xC8, 0x00E3},
+    {0xF0, 0x0001},
+    {0xC6, 0xA120},
+    {0xC8, 0x0002},
+    {0xC6, 0xA103},
+    {0xC8, 0x0002},
+    {REG_TERM, VAL_TERM}
+};
+
+ struct sensor_reg* sensor_reg_common[3] =
+{
+	sensor_common,
+	sensor_preview,
+	sensor_capture
+};
+
+static struct sensor_reg sensor_brightness_0[] = {
+    {0xF0, 0x0001},
+    {0xC6, 0xA206},
+    {0xC8, 0x0025},    
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_brightness_1[] = {
+    {0xF0, 0x0001},
+    {0xC6, 0xA206},
+    {0xC8, 0x0034},    
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_brightness_2[] = {
+    {0xF0, 0x0001},
+    {0xC6, 0xA206},
+    {0xC8, 0x004A},    
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_brightness_3[] = {
+    {0xF0, 0x0001},
+    {0xC6, 0xA206},
+    {0xC8, 0x0069},    
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_brightness_4[] = {
+    {0xF0, 0x0001},
+    {0xC6, 0xA206},
+    {0xC8, 0x0094},    
+    {REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_brightness[5] =
+{
+	sensor_brightness_0,
+	sensor_brightness_1,
+	sensor_brightness_2,
+	sensor_brightness_3,
+	sensor_brightness_4
+};
+
+
+static struct sensor_reg sensor_awb_auto[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_awb_daylight[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_awb_incandescent[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_awb_fluorescent[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_awb_cloudy[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_awb_sunset[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_awb[6] =
+{
+	sensor_awb_auto,
+	sensor_awb_daylight,
+	sensor_awb_incandescent,
+	sensor_awb_fluorescent,
+	sensor_awb_cloudy,
+	sensor_awb_sunset
+	
+};
+
+
+static struct sensor_reg sensor_iso_auto[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_iso_100[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_iso_200[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_iso_400[] = {
+	{REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_iso[4] =
+{
+	sensor_iso_auto,
+	sensor_iso_100,
+	sensor_iso_200,
+	sensor_iso_400
+};
+
+
+static struct sensor_reg sensor_effect_normal[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_effect_gray[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_effect_negative[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_effect_sepia[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_effect_sharpness[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_effect_sketch[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_effect[6] =
+{
+	sensor_effect_normal,
+	sensor_effect_gray,
+	sensor_effect_negative,
+	sensor_effect_sepia,
+	sensor_effect_sharpness,
+	sensor_effect_sketch,
+};
+
+static struct sensor_reg sensor_reg_flipnone[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_reg_hflip[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_reg_vflip[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_reg_hvflip[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_flip[4] =
+{
+	sensor_reg_flipnone,
+	sensor_reg_hflip,
+	sensor_reg_vflip,
+	sensor_reg_hvflip,
+};
+
+
+static struct sensor_reg sensor_secne_auto[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_secne_night[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_secne_landscape[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_secne_portrait[] = {
+	{REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_secne_sport[] = {
+	{REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_scene[5] =
+{
+	sensor_secne_auto,
+	sensor_secne_night,
+	sensor_secne_landscape,
+	sensor_secne_portrait,
+	sensor_secne_sport
+};
+
+static struct sensor_reg sensor_me_mtrix[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_me_center_weighted[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_me_spot[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_metering_exposure[3] =
+{
+	sensor_me_mtrix,
+	sensor_me_center_weighted,
+	sensor_me_spot,
+};
+
+static struct sensor_reg sensor_af_single[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_af_manual[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_af[2] =
+{
+	sensor_af_single,
+	sensor_af_manual,
+};
+
+#endif
+
Index: linux-2.6.29/drivers/media/video/tcccam/mt9d111_2mp.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/tcccam/mt9d111_2mp.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,63 @@
+/*
+ * drivers/media/video/tcccam/mt9d111_2mp.h
+ *
+ * Register definitions for the mt9d111 CameraChip.
+ *
+ * Author: zzau (zzau@telechips.com)
+ *
+ * Copyright (C) 2008 Telechips, Inc.
+ *
+ * This file is licensed under the terms of the GNU General Public License 
+ * version 2. This program is licensed "as is" without any warranty of any 
+ * kind, whether express or implied.
+ */
+
+#ifndef MT9D111_H
+#define MT9D111_H
+
+/* The MT9D111 I2C sensor chip has a fixed slave address of 0x5D. */
+#define SENSOR_I2C_ADDR		0xBA
+
+#define REG_TERM 0xFF	/* terminating list entry for reg */
+#define VAL_TERM 0xFFFF	/* terminating list entry for val */
+
+
+// ZOOM Setting!!
+#define PRV_W			800
+#define PRV_H			600
+#define PRV_ZOFFX		8
+#define PRV_ZOFFY		6
+
+#define CAP_W			1600
+#define CAP_H			1200
+#define CAP_ZOFFX		16
+#define CAP_ZOFFY		12
+
+#define CAM_2XMAX_ZOOM_STEP 	25
+#define CAM_CAPCHG_WIDTH  		800
+
+
+struct sensor_reg {
+	unsigned char reg;
+	unsigned short/*char*/ val[1];
+};
+
+struct capture_size {
+	unsigned long width;
+	unsigned long height;
+};
+
+extern struct capture_size sensor_sizes[];
+
+extern struct sensor_reg* sensor_reg_common[];
+extern struct sensor_reg* sensor_reg_brightness[];
+extern struct sensor_reg* sensor_reg_awb[];
+extern struct sensor_reg* sensor_reg_iso[];
+extern struct sensor_reg* sensor_reg_effect[];
+extern struct sensor_reg* sensor_reg_flip[];
+extern struct sensor_reg* sensor_reg_scene[];
+extern struct sensor_reg* sensor_reg_metering_exposure[];
+extern struct sensor_reg* sensor_reg_af[];
+
+#endif /* MT9D111_H */
+
Index: linux-2.6.29/drivers/media/video/tcccam/mt9d112_2mp.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/tcccam/mt9d112_2mp.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,987 @@
+/*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*
+
+               CAMERA    API    M O D U L E
+
+                        EDIT HISTORY FOR MODULE
+
+when        who       what, where, why
+--------    ---       -------------------------------------------------------
+10/xx/08  Telechips   Created file.
+*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*/
+
+/*===========================================================================
+
+                           INCLUDE FILES FOR MODULE
+
+===========================================================================*/
+#include "sensor_if.h"
+
+#ifdef CONFIG_VIDEO_CAMERA_SENSOR_MT9D112
+
+/* Array of image sizes supported by MT9D112.  These must be ordered from 
+ * smallest image size to largest.
+ */
+struct capture_size sensor_sizes[] = {
+	{ 1600, 1200 },	/* UXGA */
+	{ 1280,  960 },	/* SXGA */
+	{ 1024,  768 },	/* XGA */
+	{  800,  600 },	/* SVGA */
+	{  640,  480 },	/* VGA */
+	{  320,  240 },	/* QVGA */
+	{  176,  144 },	/* QCIF */
+};
+
+
+/* register initialization tables for sensor */
+/* common sensor register initialization for all image sizes, pixel formats, 
+ * and frame rates
+ */
+static struct sensor_reg sensor_common[] = {
+	{0x3216, 0x0008},
+	{0x341E, 0x8F09},
+	{0x341C, 0x0120},
+	{0x341E, 0x8F09},
+	{0x341E, 0x8F08},
+	{0x301A, 0x0ACC},
+	{0x3202, 0x0008},
+	{0x33F4, 0x031D},
+
+	{CAMDLY, 100},
+
+	{0x3044, 0x0540}, //Reserved = 0x540
+	{0x3216, 0x02CF}, //Internal Clock Control = 0x2CF
+	{0x321C, 0x0402}, //OF Control Status = 0x402
+	{0x3212, 0x0001}, //Factory Bypass = 0x1
+
+	{0x338C, 0x2703},  //Output Width (A)
+	{0x3390, 0x0320},  //      = 800
+	{0x338C, 0x2705},  //Output Height (A)
+	{0x3390, 0x0258},  //      = 600
+	{0x338C, 0x2707}, //Output Width (B)
+	{0x3390, 0x0640}, //      = 1600
+	{0x338C, 0x2709}, //Output Height (B)
+	{0x3390, 0x04B2}, //      = 1202
+	{0x338C, 0x270D}, //Row Start (A)
+	{0x3390, 0x0000}, //      = 0
+	{0x338C, 0x270F}, //Column Start (A)
+	{0x3390, 0x0000}, //      = 0
+	{0x338C, 0x2711}, //Row End (A)
+	{0x3390, 0x04BD}, //      = 1213
+	{0x338C, 0x2713}, //Column End (A)
+	{0x3390, 0x064D}, //      = 1613
+	{0x338C, 0x2715}, //Extra Delay (A)
+	{0x3390, 0x030B}, //      = 779
+	{0x338C, 0x2717}, //Row Speed (A)
+	{0x3390, 0x2111}, //      = 8465
+	{0x338C, 0x2719}, //Read Mode (A)
+	{0x3390, 0x046C}, //      = 1132
+	{0x338C, 0x271B}, //sensor_sample_time_pck (A)
+	{0x3390, 0x024F}, //      = 591
+	{0x338C, 0x271D}, //sensor_fine_correction (A)
+	{0x3390, 0x0102}, //      = 258
+	{0x338C, 0x271F}, //sensor_fine_IT_min (A)
+	{0x3390, 0x0279}, //      = 633
+	{0x338C, 0x2721}, //sensor_fine_IT_max_margin (A)
+	{0x3390, 0x0155}, //      = 341
+	{0x338C, 0x2723}, //Frame Lines (A)
+	{0x3390, 0x02EA}, //      = 746
+	{0x338C, 0x2725}, //Line Length (A)
+	{0x3390, 0x0824}, //      = 2084
+	{0x338C, 0x2727}, //sensor_dac_id_4_5 (A)
+	{0x3390, 0x2020}, //      = 8224
+	{0x338C, 0x2729}, //sensor_dac_id_6_7 (A)
+	{0x3390, 0x2020}, //      = 8224
+	{0x338C, 0x272B}, //sensor_dac_id_8_9 (A)
+	{0x3390, 0x1020}, //      = 4128
+	{0x338C, 0x272D}, //sensor_dac_id_10_11 (A)
+	{0x3390, 0x2007}, //      = 8199
+	{0x338C, 0x272F}, //Row Start (B)
+	{0x3390, 0x0004}, //      = 4
+	{0x338C, 0x2731}, //Column Start (B)
+	{0x3390, 0x0004}, //      = 4
+	{0x338C, 0x2733}, //Row End (B)
+	{0x3390, 0x04BD}, //      = 1211 + ?
+	{0x338C, 0x2735}, //Column End (B)
+	{0x3390, 0x064B}, //      = 1611
+	{0x338C, 0x2737}, //Extra Delay (B)
+	{0x3390, 0x04C6}, //      = 1222
+	{0x338C, 0x2739}, //Row Speed (B)
+	{0x3390, 0x2111}, //      = 8465
+	{0x338C, 0x273B}, //Read Mode (B)
+	{0x3390, 0x0024}, //      = 36
+	{0x338C, 0x273D}, //sensor_sample_time_pck (B)
+	{0x3390, 0x0120}, //      = 288
+	{0x338C, 0x273F}, //sensor_fine_correction (B)
+	{0x3390, 0x00A4}, //      = 164
+	{0x338C, 0x2741}, //sensor_fine_IT_min (B)
+	{0x3390, 0x0169}, //      = 330 + ?
+	{0x338C, 0x2743}, //sensor_fine_IT_max_margin (B)
+	{0x3390, 0x00A4}, //      = 164
+	{0x338C, 0x2745}, //Frame Lines (B)
+	{0x3390, 0x0573}, //      = 1395
+	{0x338C, 0x2747}, //Line Length (B)
+	{0x3390, 0x0824}, //      = 2084
+	{0x338C, 0x2751}, //Crop_X0 (A)
+	{0x3390, 0x0000}, //      = 0
+	{0x338C, 0x2753}, //Crop_X1 (A)
+	{0x3390, 0x0320}, //      = 800
+	{0x338C, 0x2755}, //Crop_Y0 (A)
+	{0x3390, 0x0000}, //      = 0
+	{0x338C, 0x2757}, //Crop_Y1 (A)
+	{0x3390, 0x0258}, //      = 600
+	{0x338C, 0x275F}, //Crop_X0 (B)
+	{0x3390, 0x0000}, //      = 0
+	{0x338C, 0x2761}, //Crop_X1 (B)
+	{0x3390, 0x0640}, //      = 1600
+	{0x338C, 0x2763}, //Crop_Y0 (B)
+	{0x3390, 0x0000}, //      = 0
+	{0x338C, 0x2765}, //Crop_Y1 (B)
+	{0x3390, 0x04B2}, //      = 1202
+	{0x338C, 0x222E}, //R9 Step
+	{0x3390, 0x0062}, //      = 98
+	{0x338C, 0xA408}, //search_f1_50
+	{0x3390, 0x0011}, //      = 17
+	{0x338C, 0xA409}, //search_f2_50
+	{0x3390, 0x0014}, //      = 20
+	{0x338C, 0xA40A}, //search_f1_60
+	{0x3390, 0x0015}, //      = 21
+	{0x338C, 0xA40B}, //search_f2_60
+	{0x3390, 0x0018}, //      = 24
+	{0x338C, 0x2411}, //R9_Step_60_A
+	{0x3390, 0x0062}, //      = 98
+	{0x338C, 0x2413}, //R9_Step_50_A
+	{0x3390, 0x0076}, //      = 118
+	{0x338C, 0x2415}, //R9_Step_60_B
+	{0x3390, 0x0062}, //      = 98
+	{0x338C, 0x2417}, //R9_Step_50_B
+	{0x3390, 0x0076}, //      = 118
+	{0x338C, 0xA40D}, //Stat_min
+	{0x3390, 0x0002}, //      = 2
+	{0x338C, 0xA410}, //Min_amplitude
+	{0x3390, 0x0001}, //      = 1
+	{0x338C, 0xA404}, // MCU_ADDRESS
+	{0x3390, 0x0000}, // FD_MODE
+	{0x338C, 0xA20C}, // MCU_ADDRESS
+	{0x3390, 0x000C}, // AE_MAX_INDEX
+	{0x338C, 0xA215}, // MCU_ADDRESS
+	{0x3390, 0x0008}, // AE_INDEX_TH23
+	{0x338C, 0xA206}, // MCU_ADDRESS
+	{0x3390, 0x0046}, // AE_TARGET
+	{0x338C, 0xA207}, // MCU_ADDRESS
+	{0x3390, 0x000A}, // AE_GATE
+	{0x338C, 0xA202}, // MCU_ADDRESS
+	{0x3390, 0x0033}, // AE_WINDOW_POS
+	{0x338C, 0xA203}, // MCU_ADDRESS
+	{0x3390, 0x0099}, // AE_WINDOW_SIZE
+	{0x338C, 0xA217}, // MCU_ADDRESS
+	{0x3390, 0x00BF}, // AE_WEIGHTS
+
+	// Sequence
+	{0x338C, 0xA13E}, // MCU_ADDRESS
+	{0x3390, 0x0004}, // MCU_DATA_0
+	{0x338C, 0xA13F}, // MCU_ADDRESS
+	{0x3390, 0x000E}, // MCU_DATA_0
+	{0x338C, 0xA140}, // MCU_ADDRESS
+	{0x3390, 0x0004}, // MCU_DATA_0
+	{0x338C, 0xA141}, // MCU_ADDRESS
+	{0x3390, 0x0004}, // MCU_DATA_0
+	{0x338C, 0xA142}, // MCU_ADDRESS
+	{0x3390, 0x0032}, // MCU_DATA_0
+	{0x338C, 0xA143}, // MCU_ADDRESS
+	{0x3390, 0x000F}, // MCU_DATA_0
+	{0x338C, 0xA144}, // MCU_ADDRESS
+	{0x3390, 0x0032}, // MCU_DATA_0
+	{0x338C, 0xA145}, // MCU_ADDRESS
+	{0x3390, 0x0032}, // MCU_DATA_0
+	{0x338C, 0xA146}, // MCU_ADDRESS
+	{0x3390, 0x0005}, // MCU_DATA_0
+	{0x338C, 0xA147}, // MCU_ADDRESS
+	{0x3390, 0x003A}, // MCU_DATA_0
+	{0x338C, 0xA115}, // MCU_ADDRESS
+	{0x3390, 0x006F}, // MCU_DATA_0
+	{0x338C, 0xA118}, // MCU_ADDRESS
+	{0x3390, 0x0080}, // SEQ_LLSAT1
+	{0x338C, 0xA119}, // MCU_ADDRESS
+	{0x3390, 0x0060}, // SEQ_LLSAT2
+	{0x338C, 0xA11C}, // MCU_ADDRESS
+	{0x3390, 0x0003}, // SEQ_LLAPCORR1 : 4 => 3 20080108 edge 3 <- 4
+	{0x338C, 0xA11D}, // MCU_ADDRESS
+	{0x3390, 0x0002}, // SEQ_LLAPCORR2
+	{0x338C, 0xA12C}, // MCU_ADDRESS
+	{0x3390, 0x0003}, // SEQ_PREVIEW_1_AF
+	{0x338C, 0xA130}, // MCU_ADDRESS
+	{0x3390, 0x0000}, // SEQ_PREVIEW_2_AE
+	{0x338C, 0xA132}, // MCU_ADDRESS
+	{0x3390, 0x0000}, // SEQ_PREVIEW_2_AWB
+	{0x338C, 0xA134}, // MCU_ADDRESS
+	{0x3390, 0x0000}, // SEQ_PREVIEW_2_HG
+	{0x338C, 0xA136}, // MCU_ADDRESS
+	{0x3390, 0x0040}, // MCU_DATA_0
+	{0x326C, 0x1511}, // APERTURE_PARAMETERS
+
+	// LSC 
+	{0x34CE, 0x81A8}, 	// LENS_CORRECTION_CONTROL
+	{0x34D0, 0x6432}, 	// ZONE_BOUNDS_X1_X2
+	{0x34D2, 0x3296}, 	// ZONE_BOUNDS_X0_X3
+	{0x34D4, 0x9664}, 	// ZONE_BOUNDS_X4_X5
+	{0x34D6, 0x5028}, 	// ZONE_BOUNDS_Y1_Y2
+	{0x34D8, 0x2878}, 	// ZONE_BOUNDS_Y0_Y3
+	{0x34DA, 0x7850}, 	// ZONE_BOUNDS_Y4_Y5
+	{0x34DC, 0x0000}, 	// CENTER_OFFSET
+	{0x34DE, 0x0113}, 	// FX_RED
+	{0x34E6, 0x00BB}, 	// FY_RED
+	{0x34EE, 0x0955}, 	// DF_DX_RED
+	{0x34F6, 0x0B48}, 	// DF_DY_RED
+	{0x3500, 0x2249}, 	// SECOND_DERIV_ZONE_0_RED
+	{0x3508, 0x1E07}, 	// SECOND_DERIV_ZONE_1_RED
+	{0x3510, 0x1C33}, 	// SECOND_DERIV_ZONE_2_RED
+	{0x3518, 0x1D54}, 	// SECOND_DERIV_ZONE_3_RED
+	{0x3520, 0x2952}, 	// SECOND_DERIV_ZONE_4_RED
+	{0x3528, 0x2451}, 	// SECOND_DERIV_ZONE_5_RED
+	{0x3530, 0x0D34}, 	// SECOND_DERIV_ZONE_6_RED
+	{0x3538, 0x27B2}, 	// SECOND_DERIV_ZONE_7_RED
+	{0x354C, 0x0045}, 	// K_FACTOR_IN_K_FX_FY_R_TL
+	{0x3544, 0x0415}, 	// K_FACTOR_IN_K_FX_FY_R_TR
+	{0x355C, 0x00A5}, 	// K_FACTOR_IN_K_FX_FY_R_BL
+	{0x3554, 0x0449}, 	// K_FACTOR_IN_K_FX_FY_R_BR
+	{0x34E0, 0x010C}, 	// FX_GREEN
+	{0x34E8, 0x0095}, 	// FY_GREEN
+	{0x34F0, 0x0B02}, 	// DF_DX_GREEN
+	{0x34F8, 0x0BB5}, 	// DF_DY_GREEN
+	{0x3502, 0x3C22}, 	// SECOND_DERIV_ZONE_0_GREEN
+	{0x350A, 0x0B03}, 	// SECOND_DERIV_ZONE_1_GREEN
+	{0x3512, 0x1646}, 	// SECOND_DERIV_ZONE_2_GREEN
+	{0x351A, 0x193F}, 	// SECOND_DERIV_ZONE_3_GREEN
+	{0x3522, 0x2142}, 	// SECOND_DERIV_ZONE_4_GREEN
+	{0x352A, 0x1A21}, 	// SECOND_DERIV_ZONE_5_GREEN
+	{0x3532, 0x092A}, 	// SECOND_DERIV_ZONE_6_GREEN
+	{0x353A, 0x3E71}, 	// SECOND_DERIV_ZONE_7_GREEN
+	{0x354E, 0x0439}, 	// K_FACTOR_IN_K_FX_FY_G1_TL
+	{0x3546, 0x00F3}, 	// K_FACTOR_IN_K_FX_FY_G1_TR
+	{0x355E, 0x0025}, 	// K_FACTOR_IN_K_FX_FY_G1_BL
+	{0x3556, 0x0173}, 	// K_FACTOR_IN_K_FX_FY_G1_BR
+	{0x34E4, 0x00D9}, 	// FX_BLUE
+	{0x34EC, 0x006A}, 	// FY_BLUE
+	{0x34F4, 0x0B40}, 	// DF_DX_BLUE
+	{0x34FC, 0x0C75}, 	// DF_DY_BLUE
+	{0x3506, 0x3A30}, 	// SECOND_DERIV_ZONE_0_BLUE
+	{0x350E, 0x08FD}, 	// SECOND_DERIV_ZONE_1_BLUE
+	{0x3516, 0x152F}, 	// SECOND_DERIV_ZONE_2_BLUE
+	{0x351E, 0x1236}, 	// SECOND_DERIV_ZONE_3_BLUE
+	{0x3526, 0x1432}, 	// SECOND_DERIV_ZONE_4_BLUE
+	{0x352E, 0x1011}, 	// SECOND_DERIV_ZONE_5_BLUE
+	{0x3536, 0x153B}, 	// SECOND_DERIV_ZONE_6_BLUE
+	{0x353E, 0x3116}, 	// SECOND_DERIV_ZONE_7_BLUE
+	{0x3552, 0x00A0}, 	// K_FACTOR_IN_K_FX_FY_B_TL
+	{0x354A, 0x02BB}, 	// K_FACTOR_IN_K_FX_FY_B_TR
+	{0x3562, 0x0140}, 	// K_FACTOR_IN_K_FX_FY_B_BL
+	{0x355A, 0x0238}, 	// K_FACTOR_IN_K_FX_FY_B_BR
+	{0x34E2, 0x0111}, 	// FX_GREEN2
+	{0x34EA, 0x0085}, 	// FY_GREEN2
+	{0x34F2, 0x094C}, 	// DF_DX_GREEN2
+	{0x34FA, 0x0C02}, 	// DF_DY_GREEN2
+	{0x3504, 0x364A}, 	// SECOND_DERIV_ZONE_0_GREEN2
+	{0x350C, 0x0C08}, 	// SECOND_DERIV_ZONE_1_GREEN2
+	{0x3514, 0x1837}, 	// SECOND_DERIV_ZONE_2_GREEN2
+	{0x351C, 0x1A46}, 	// SECOND_DERIV_ZONE_3_GREEN2
+	{0x3524, 0x1846}, 	// SECOND_DERIV_ZONE_4_GREEN2
+	{0x352C, 0x1837}, 	// SECOND_DERIV_ZONE_5_GREEN2
+	{0x3534, 0x1127}, 	// SECOND_DERIV_ZONE_6_GREEN2
+	{0x353C, 0x3A1D}, 	// SECOND_DERIV_ZONE_7_GREEN2
+	{0x3550, 0x0122}, 	// K_FACTOR_IN_K_FX_FY_G2_TL
+	{0x3548, 0x0054}, 	// K_FACTOR_IN_K_FX_FY_G2_TR
+	{0x3560, 0x0099}, 	// K_FACTOR_IN_K_FX_FY_G2_BL
+	{0x3558, 0x0013}, 	// K_FACTOR_IN_K_FX_FY_G2_BR
+	{0x3540, 0x0001}, 	// X2_FACTORS
+	{0x3542, 0x0000}, 	// GLOBAL_OFFSET_FXY_FUNCTION
+	{0x3210, 0x01FC}, 	// COLOR_PIPELINE_CONTROL
+
+	// Gamma (Programmed)
+	{0x338C, 0xA76D}, 	// MCU_ADDRESS [MODE_GAM_CONT_A]
+	{0x3390, 0x0042}, 	// MCU_DATA_0
+	{0x338C, 0xA76E}, 	// MCU_ADDRESS [MODE_GAM_CONT_B]
+	{0x3390, 0x0042}, 	// MCU_DATA_0
+	{0x338C, 0xAB04}, 	// MCU_ADDRESS [HG_MAX_DLEVEL]
+	{0x3390, 0x0018}, 	// MCU_DATA_0
+	{0x338C, 0xAB05}, 	// MCU_ADDRESS [HG_PERCENT]
+	{0x3390, 0x0002}, 	// MCU_DATA_0
+
+	// AWB & CCM 
+	{0x338C, 0x2306}, 	// MCU_ADDRESS [AWB_CCM_L_0]
+	{0x3390, 0x02E1}, 	// MCU_DATA_0
+	{0x338C, 0x2308}, 	// MCU_ADDRESS [AWB_CCM_L_1]
+	{0x3390, 0xFE81}, 	// MCU_DATA_0
+	{0x338C, 0x230A}, 	// MCU_ADDRESS [AWB_CCM_L_2]
+	{0x3390, 0xFFC9}, 	// MCU_DATA_0
+	{0x338C, 0x230C}, 	// MCU_ADDRESS [AWB_CCM_L_3]
+	{0x3390, 0xFF64}, 	// MCU_DATA_0
+	{0x338C, 0x230E}, 	// MCU_ADDRESS [AWB_CCM_L_4]
+	{0x3390, 0x02A9}, 	// MCU_DATA_0
+	{0x338C, 0x2310}, 	// MCU_ADDRESS [AWB_CCM_L_5]
+	{0x3390, 0xFF41}, 	// MCU_DATA_0
+	{0x338C, 0x2312}, 	// MCU_ADDRESS [AWB_CCM_L_6]
+	{0x3390, 0xFF77}, 	// MCU_DATA_0
+	{0x338C, 0x2314}, 	// MCU_ADDRESS [AWB_CCM_L_7]
+	{0x3390, 0xFE15}, 	// MCU_DATA_0
+	{0x338C, 0x2316}, 	// MCU_ADDRESS [AWB_CCM_L_8]
+	{0x3390, 0x03D7}, 	// MCU_DATA_0
+	{0x338C, 0x2318}, 	// MCU_ADDRESS [AWB_CCM_L_9]
+	{0x3390, 0x0024}, 	// MCU_DATA_0
+	{0x338C, 0x231A}, 	// MCU_ADDRESS [AWB_CCM_L_10]
+	{0x3390, 0x003C}, 	// MCU_DATA_0
+	{0x338C, 0x231C}, 	// MCU_ADDRESS [AWB_CCM_RL_0]
+	{0x3390, 0x0072}, 	// MCU_DATA_0
+	{0x338C, 0x231E}, 	// MCU_ADDRESS [AWB_CCM_RL_1]
+	{0x3390, 0xFF68}, 	// MCU_DATA_0
+	{0x338C, 0x2320}, 	// MCU_ADDRESS [AWB_CCM_RL_2]
+	{0x3390, 0x002A}, 	// MCU_DATA_0
+	{0x338C, 0x2322}, 	// MCU_ADDRESS [AWB_CCM_RL_3]
+	{0x3390, 0x0000}, 	// MCU_DATA_0
+	{0x338C, 0x2324}, 	// MCU_ADDRESS [AWB_CCM_RL_4]
+	{0x3390, 0x005D}, 	// MCU_DATA_0
+	{0x338C, 0x2326}, 	// MCU_ADDRESS [AWB_CCM_RL_5]
+	{0x3390, 0xFFBA}, 	// MCU_DATA_0
+	{0x338C, 0x2328}, 	// MCU_ADDRESS [AWB_CCM_RL_6]
+	{0x3390, 0x005D},		// 94}, 	// MCU_DATA_0
+	{0x338C, 0x232A}, 	// MCU_ADDRESS [AWB_CCM_RL_7]
+	{0x3390, 0x0104},		//0C0}, 	// MCU_DATA_0
+	{0x338C, 0x232C}, 	// MCU_ADDRESS [AWB_CCM_RL_8]
+	{0x3390, 0xFE68},		//FE75}, 	// MCU_DATA_0
+	{0x338C, 0x232E}, 	// MCU_ADDRESS [AWB_CCM_RL_9]
+	{0x3390, 0x001C}, 	// MCU_DATA_0
+	{0x338C, 0x2330}, 	// MCU_ADDRESS [AWB_CCM_RL_10]
+	{0x3390, 0xFFEC}, 	// MCU_DATA_0
+	{0x338C, 0xA348}, 	// MCU_ADDRESS [AWB_GAIN_BUFFER_SPEED]
+	{0x3390, 0x0008}, 	// MCU_DATA_0
+	{0x338C, 0xA349}, 	// MCU_ADDRESS [AWB_JUMP_DIVISOR]
+	{0x3390, 0x0002}, 	// MCU_DATA_0
+	{0x338C, 0xA34A}, 	// MCU_ADDRESS [AWB_GAIN_MIN]
+	{0x3390, 0x0060}, 	// MCU_DATA_0
+	{0x338C, 0xA34B}, 	// MCU_ADDRESS [AWB_GAIN_MAX]
+	{0x3390, 0x008C}, 	// MCU_DATA_0
+	{0x338C, 0xA34F}, 	// MCU_ADDRESS [AWB_CCM_POSITION_MIN]
+	{0x3390, 0x0018}, 	// MCU_DATA_0
+	{0x338C, 0xA350}, 	// MCU_ADDRESS [AWB_CCM_POSITION_MAX]
+	{0x3390, 0x0076}, 	// MCU_DATA_0
+	{0x338C, 0xA352}, 	// MCU_ADDRESS [AWB_SATURATION]
+	{0x3390, 0x0080}, 	// MCU_DATA_0
+	{0x338C, 0xA353}, 	// MCU_ADDRESS [AWB_MODE]
+	{0x3390, 0x0002}, 	// MCU_DATA_0
+	{0x338C, 0xA35B}, 	// MCU_ADDRESS [AWB_STEADY_BGAIN_OUT_MIN]
+	{0x3390, 0x0078}, 	// MCU_DATA_0
+	{0x338C, 0xA35C}, 	// MCU_ADDRESS [AWB_STEADY_BGAIN_OUT_MAX]
+	{0x3390, 0x0086}, 	// MCU_DATA_0
+	{0x338C, 0xA35D}, 	// MCU_ADDRESS [AWB_STEADY_BGAIN_IN_MIN]
+	{0x3390, 0x007E}, 	// MCU_DATA_0
+	{0x338C, 0xA35E}, 	// MCU_ADDRESS [AWB_STEADY_BGAIN_IN_MAX]
+	{0x3390, 0x0082}, 	// MCU_DATA_0
+	{0x338C, 0x235F}, 	// MCU_ADDRESS [AWB_CNT_PXL_TH]
+	{0x3390, 0x0040}, 	// MCU_DATA_0
+	{0x338C, 0xA361}, 	// MCU_ADDRESS [AWB_TG_MIN0]
+	{0x3390, 0x00DB}, 	// MCU_DATA_0
+	{0x338C, 0xA362}, 	// MCU_ADDRESS [AWB_TG_MAX0]
+	{0x3390, 0x00E7}, 	// MCU_DATA_0
+	{0x338C, 0xA302}, 	// MCU_ADDRESS [AWB_WINDOW_POS]
+	{0x3390, 0x0000}, 	// MCU_DATA_0
+	{0x338C, 0xA303}, 	// MCU_ADDRESS [AWB_WINDOW_SIZE]
+	{0x3390, 0x00EF}, 	// MCU_DATA_0
+	{0x338C, 0xA364}, 	// MCU_ADDRESS [AWB_KR_L]
+	{0x3390, 0x0098}, 	// MCU_DATA_0
+	{0x338C, 0xA366}, 	// MCU_ADDRESS [AWB_KB_L]
+	{0x3390, 0x0088}, 	// MCU_DATA_0
+	{0x338C, 0xA367}, 	// MCU_ADDRESS [AWB_KR_R]
+	{0x3390, 0x0072}, 	// MCU_DATA_0
+	{0x338C, 0xA369}, 	// MCU_ADDRESS [AWB_KB_R]
+	{0x3390, 0x007A}, 	// MCU_DATA_0
+	{0x338C, 0xA36B}, 	// MCU_ADDRESS [AWB_EDGETH_MIN]
+	{0x3390, 0x0004}, 	// MCU_DATA_0
+
+	// Refresh
+	{0x338C, 0xA103}, // MCU_ADDRESS
+	{0x3390, 0x0006}, // MCU_DATA_0
+	//DELAY=200 ms    // OR Wait until state = 3
+	{CAMDLY, 200},
+	//{0xFFFF, 100},
+	//{0xFFFF, 100},
+
+	{0x338C, 0xA103}, // MCU_ADDRESS
+	{0x3390, 0x0005}, // MCU_DATA_0
+	{CAMDLY, 500},
+	//DELAY=500 ms    // OR Wait until state = 3
+	//{0xFFFF, 100},
+	//{0xFFFF, 100},
+	//{0xFFFF, 100},
+	//{0xFFFF, 100},
+	//{0xFFFF, 100},
+#if 0
+	// AF Driver - new 08.03 0~100%
+	{0x338C, 0x0400}, // MCU_ADDRESS
+	{0x3390, 0x3C3C}, // MCU_DATA_0
+	{0x3392, 0x3C3C}, // MCU_DATA_1
+	{0x3394, 0x3C3C}, // MCU_DATA_2
+	{0x3396, 0xFE10}, // MCU_DATA_3
+	{0x3398, 0x50EC}, // MCU_DATA_4
+	{0x339A, 0x0CFD}, // MCU_DATA_5
+	{0x339C, 0x0300}, // MCU_DATA_6
+	{0x339E, 0xFE03}, // MCU_DATA_7
+	{0x338C, 0x0410}, // MCU_ADDRESS
+	{0x3390, 0x00C6}, // MCU_DATA_0
+	{0x3392, 0x81E7}, // MCU_DATA_1
+	{0x3394, 0x02FE}, // MCU_DATA_2
+	{0x3396, 0x0300}, // MCU_DATA_3
+	{0x3398, 0xEE00}, // MCU_DATA_4
+	{0x339A, 0xEE00}, // MCU_DATA_5
+	{0x339C, 0xAD00}, // MCU_DATA_6
+	{0x339E, 0xFE03}, // MCU_DATA_7
+	{0x338C, 0x0420}, // MCU_ADDRESS
+	{0x3390, 0x00C6}, // MCU_DATA_0
+	{0x3392, 0x04E7}, // MCU_DATA_1
+	{0x3394, 0x02CC}, // MCU_DATA_2
+	{0x3396, 0x0400}, // MCU_DATA_3
+	{0x3398, 0xFD03}, // MCU_DATA_4
+	{0x339A, 0x02CC}, // MCU_DATA_5
+	{0x339C, 0x0485}, // MCU_DATA_6
+	{0x339E, 0xFD03}, // MCU_DATA_7
+	{0x338C, 0x0430}, // MCU_ADDRESS
+	{0x3390, 0x04FE}, // MCU_DATA_0
+	{0x3392, 0x0300}, // MCU_DATA_1
+	{0x3394, 0x1AEE}, // MCU_DATA_2
+	{0x3396, 0x0018}, // MCU_DATA_3
+	{0x3398, 0xEC04}, // MCU_DATA_4
+	{0x339A, 0xFD03}, // MCU_DATA_5
+	{0x339C, 0x061A}, // MCU_DATA_6
+	{0x339E, 0xEE00}, // MCU_DATA_7
+	{0x338C, 0x0440}, // MCU_ADDRESS
+	{0x3390, 0x18EC}, // MCU_DATA_0
+	{0x3392, 0x06FD}, // MCU_DATA_1
+	{0x3394, 0x0308}, // MCU_DATA_2
+	{0x3396, 0xCC03}, // MCU_DATA_3
+	{0x3398, 0x02ED}, // MCU_DATA_4
+	{0x339A, 0x00CC}, // MCU_DATA_5
+	{0x339C, 0x0001}, // MCU_DATA_6
+	{0x339E, 0xFD10}, // MCU_DATA_7
+	{0x338C, 0x0450}, // MCU_ADDRESS
+	{0x3390, 0x7EC6}, // MCU_DATA_0
+	{0x3392, 0xD130}, // MCU_DATA_1
+	{0x3394, 0xED0A}, // MCU_DATA_2
+	{0x3396, 0xCC00}, // MCU_DATA_3
+	{0x3398, 0x32ED}, // MCU_DATA_4
+	{0x339A, 0x085F}, // MCU_DATA_5
+	{0x339C, 0xED06}, // MCU_DATA_6
+	{0x339E, 0xED04}, // MCU_DATA_7
+	{0x338C, 0x0460}, // MCU_ADDRESS
+	{0x3390, 0xED02}, // MCU_DATA_0
+	{0x3392, 0xED00}, // MCU_DATA_1
+	{0x3394, 0x5CBD}, // MCU_DATA_2
+	{0x3396, 0x0545}, // MCU_DATA_3
+	{0x3398, 0xCE10}, // MCU_DATA_4
+	{0x339A, 0x801C}, // MCU_DATA_5
+	{0x339C, 0x3601}, // MCU_DATA_6
+	{0x339E, 0x1C35}, // MCU_DATA_7
+	{0x338C, 0x0470}, // MCU_ADDRESS
+	{0x3390, 0x011D}, // MCU_DATA_0
+	{0x3392, 0x3501}, // MCU_DATA_1
+	{0x3394, 0xCE10}, // MCU_DATA_2
+	{0x3396, 0x001D}, // MCU_DATA_3
+	{0x3398, 0x7101}, // MCU_DATA_4
+	{0x339A, 0xC6FF}, // MCU_DATA_5
+	{0x339C, 0xBD04}, // MCU_DATA_6
+	{0x339E, 0x8530}, // MCU_DATA_7
+	{0x338C, 0x0480}, // MCU_ADDRESS
+	{0x3390, 0xC60C}, // MCU_DATA_0
+	{0x3392, 0x3A35}, // MCU_DATA_1
+	{0x3394, 0x3937}, // MCU_DATA_2
+	{0x3396, 0x308F}, // MCU_DATA_3
+	{0x3398, 0xC3FF}, // MCU_DATA_4
+	{0x339A, 0xED8F}, // MCU_DATA_5
+	{0x339C, 0x35FE}, // MCU_DATA_6
+	{0x339E, 0x0300}, // MCU_DATA_7
+	{0x338C, 0x0490}, // MCU_ADDRESS
+	{0x3390, 0xE603}, // MCU_DATA_0
+	{0x3392, 0x30E1}, // MCU_DATA_1
+	{0x3394, 0x1322}, // MCU_DATA_2
+	{0x3396, 0x035F}, // MCU_DATA_3
+	{0x3398, 0x2002}, // MCU_DATA_4
+	{0x339A, 0xC601}, // MCU_DATA_5
+	{0x339C, 0xE712}, // MCU_DATA_6
+	{0x339E, 0xE613}, // MCU_DATA_7
+	{0x338C, 0x04A0}, // MCU_ADDRESS
+	{0x3390, 0x4FC3}, // MCU_DATA_0
+	{0x3392, 0x0002}, // MCU_DATA_1
+	{0x3394, 0xED10}, // MCU_DATA_2
+	{0x3396, 0xE613}, // MCU_DATA_3
+	{0x3398, 0xC1FF}, // MCU_DATA_4
+	{0x339A, 0x2614}, // MCU_DATA_5
+	{0x339C, 0x5F4F}, // MCU_DATA_6
+	{0x339E, 0xED0A}, // MCU_DATA_7
+	{0x338C, 0x04B0}, // MCU_ADDRESS
+	{0x3390, 0xED08}, // MCU_DATA_0
+	{0x3392, 0xED06}, // MCU_DATA_1
+	{0x3394, 0xED04}, // MCU_DATA_2
+	{0x3396, 0xED02}, // MCU_DATA_3
+	{0x3398, 0xED00}, // MCU_DATA_4
+	{0x339A, 0x5CBD}, // MCU_DATA_5
+	{0x339C, 0x0545}, // MCU_DATA_6
+	{0x339E, 0x2040}, // MCU_DATA_7
+	{0x338C, 0x04C0}, // MCU_ADDRESS
+	{0x3390, 0x6D13}, // MCU_DATA_0
+	{0x3392, 0x2617}, // MCU_DATA_1
+	{0x3394, 0xCC01}, // MCU_DATA_2
+	{0x3396, 0x03ED}, // MCU_DATA_3
+	{0x3398, 0x0A5F}, // MCU_DATA_4
+	{0x339A, 0x4FED}, // MCU_DATA_5
+	{0x339C, 0x08ED}, // MCU_DATA_6
+	{0x339E, 0x06ED}, // MCU_DATA_7
+	{0x338C, 0x04D0}, // MCU_ADDRESS
+	{0x3390, 0x04ED}, // MCU_DATA_0
+	{0x3392, 0x02ED}, // MCU_DATA_1
+	{0x3394, 0x005C}, // MCU_DATA_2
+	{0x3396, 0xBD05}, // MCU_DATA_3
+	{0x3398, 0x4520}, // MCU_DATA_4
+	{0x339A, 0x25CC}, // MCU_DATA_5
+	{0x339C, 0x0103}, // MCU_DATA_6
+	{0x339E, 0xA310}, // MCU_DATA_7
+	{0x338C, 0x04E0}, // MCU_ADDRESS
+	{0x3390, 0xED0A}, // MCU_DATA_0
+	{0x3392, 0xEC10}, // MCU_DATA_1
+	{0x3394, 0xED08}, // MCU_DATA_2
+	{0x3396, 0x5F4F}, // MCU_DATA_3
+	{0x3398, 0xED06}, // MCU_DATA_4
+	{0x339A, 0xED04}, // MCU_DATA_5
+	{0x339C, 0xED02}, // MCU_DATA_6
+	{0x339E, 0xED00}, // MCU_DATA_7
+	{0x338C, 0x04F0}, // MCU_ADDRESS
+	{0x3390, 0x5CBD}, // MCU_DATA_0
+	{0x3392, 0x0545}, // MCU_DATA_1
+	{0x3394, 0xCE10}, // MCU_DATA_2
+	{0x3396, 0x001D}, // MCU_DATA_3
+	{0x3398, 0x7101}, // MCU_DATA_4
+	{0x339A, 0xCE10}, // MCU_DATA_5
+	{0x339C, 0x801D}, // MCU_DATA_6
+	{0x339E, 0x3601}, // MCU_DATA_7
+	{0x338C, 0x0500}, // MCU_ADDRESS
+	{0x3390, 0x30E6}, // MCU_DATA_0
+	{0x3392, 0x134F}, // MCU_DATA_1
+	{0x3394, 0x175F}, // MCU_DATA_2
+	{0x3396, 0xED0E}, // MCU_DATA_3
+	{0x3398, 0x18FE}, // MCU_DATA_4
+	{0x339A, 0x0300}, // MCU_DATA_5
+	{0x339C, 0x18E6}, // MCU_DATA_6
+	{0x339E, 0x034F}, // MCU_DATA_7
+	{0x338C, 0x0510}, // MCU_ADDRESS
+	{0x3390, 0xED0C}, // MCU_DATA_0
+	{0x3392, 0xE30E}, // MCU_DATA_1
+	{0x3394, 0xCDEE}, // MCU_DATA_2
+	{0x3396, 0x0BEE}, // MCU_DATA_3
+	{0x3398, 0x04AD}, // MCU_DATA_4
+	{0x339A, 0x0030}, // MCU_DATA_5
+	{0x339C, 0x6D12}, // MCU_DATA_6
+	{0x339E, 0x2604}, // MCU_DATA_7
+	{0x338C, 0x0520}, // MCU_ADDRESS
+	{0x3390, 0xC602}, // MCU_DATA_0
+	{0x3392, 0x2002}, // MCU_DATA_1
+	{0x3394, 0xC606}, // MCU_DATA_2
+	{0x3396, 0xFE03}, // MCU_DATA_3
+	{0x3398, 0x00E7}, // MCU_DATA_4
+	{0x339A, 0x05FE}, // MCU_DATA_5
+	{0x339C, 0x0300}, // MCU_DATA_6
+	{0x339E, 0x3C18}, // MCU_DATA_7
+	{0x338C, 0x0530}, // MCU_ADDRESS
+	{0x3390, 0x38E6}, // MCU_DATA_0
+	{0x3392, 0x03E7}, // MCU_DATA_1
+	{0x3394, 0x0418}, // MCU_DATA_2
+	{0x3396, 0xFE03}, // MCU_DATA_3
+	{0x3398, 0x0030}, // MCU_DATA_4
+	{0x339A, 0xE613}, // MCU_DATA_5
+	{0x339C, 0x18E7}, // MCU_DATA_6
+	{0x339E, 0x0330}, // MCU_DATA_7
+	{0x338C, 0x0540}, // MCU_ADDRESS
+	{0x3390, 0xC614}, // MCU_DATA_0
+	{0x3392, 0x3A35}, // MCU_DATA_1
+	{0x3394, 0x3937}, // MCU_DATA_2
+	{0x3396, 0x3C3C}, // MCU_DATA_3
+	{0x3398, 0x3C30}, // MCU_DATA_4
+	{0x339A, 0x6F05}, // MCU_DATA_5
+	{0x339C, 0xA605}, // MCU_DATA_6
+	{0x339E, 0xC601}, // MCU_DATA_7
+	{0x338C, 0x0550}, // MCU_ADDRESS
+	{0x3390, 0xBD05}, // MCU_DATA_0
+	{0x3392, 0xCC30}, // MCU_DATA_1
+	{0x3394, 0xE406}, // MCU_DATA_2
+	{0x3396, 0x2765}, // MCU_DATA_3
+	{0x3398, 0xCC10}, // MCU_DATA_4
+	{0x339A, 0x80ED}, // MCU_DATA_5
+	{0x339C, 0x03E6}, // MCU_DATA_6
+	{0x339E, 0x0586}, // MCU_DATA_7
+	{0x338C, 0x0560}, // MCU_ADDRESS
+	{0x3390, 0x033D}, // MCU_DATA_0
+	{0x3392, 0x05E3}, // MCU_DATA_1
+	{0x3394, 0x03ED}, // MCU_DATA_2
+	{0x3396, 0x031A}, // MCU_DATA_3
+	{0x3398, 0xEE03}, // MCU_DATA_4
+	{0x339A, 0xEC13}, // MCU_DATA_5
+	{0x339C, 0x18ED}, // MCU_DATA_6
+	{0x339E, 0x001A}, // MCU_DATA_7
+	{0x338C, 0x0570}, // MCU_ADDRESS
+	{0x3390, 0xEE03}, // MCU_DATA_0
+	{0x3392, 0xEC11}, // MCU_DATA_1
+	{0x3394, 0x18ED}, // MCU_DATA_2
+	{0x3396, 0x021A}, // MCU_DATA_3
+	{0x3398, 0xEE03}, // MCU_DATA_4
+	{0x339A, 0xEC0F}, // MCU_DATA_5
+	{0x339C, 0x18ED}, // MCU_DATA_6
+	{0x339E, 0x041A}, // MCU_DATA_7
+	{0x338C, 0x0580}, // MCU_ADDRESS
+	{0x3390, 0xEE03}, // MCU_DATA_0
+	{0x3392, 0xEC0D}, // MCU_DATA_1
+	{0x3394, 0x18ED}, // MCU_DATA_2
+	{0x3396, 0x061A}, // MCU_DATA_3
+	{0x3398, 0xEE03}, // MCU_DATA_4
+	{0x339A, 0xEC0B}, // MCU_DATA_5
+	{0x339C, 0x18ED}, // MCU_DATA_6
+	{0x339E, 0x081A}, // MCU_DATA_7
+	{0x338C, 0x0590}, // MCU_ADDRESS
+	{0x3390, 0xEE03}, // MCU_DATA_0
+	{0x3392, 0xEC09}, // MCU_DATA_1
+	{0x3394, 0x18ED}, // MCU_DATA_2
+	{0x3396, 0x0AA6}, // MCU_DATA_3
+	{0x3398, 0x0544}, // MCU_DATA_4
+	{0x339A, 0x8B04}, // MCU_DATA_5
+	{0x339C, 0xC601}, // MCU_DATA_6
+	{0x339E, 0xBD05}, // MCU_DATA_7
+	{0x338C, 0x05A0}, // MCU_ADDRESS
+	{0x3390, 0xCC30}, // MCU_DATA_0
+	{0x3392, 0xA605}, // MCU_DATA_1
+	{0x3394, 0x44A7}, // MCU_DATA_2
+	{0x3396, 0x0286}, // MCU_DATA_3
+	{0x3398, 0x01ED}, // MCU_DATA_4
+	{0x339A, 0x00A6}, // MCU_DATA_5
+	{0x339C, 0x02E6}, // MCU_DATA_6
+	{0x339E, 0x00BD}, // MCU_DATA_7
+	{0x338C, 0x05B0}, // MCU_ADDRESS
+	{0x3390, 0x05CC}, // MCU_DATA_0
+	{0x3392, 0x30E7}, // MCU_DATA_1
+	{0x3394, 0x02EB}, // MCU_DATA_2
+	{0x3396, 0x01FA}, // MCU_DATA_3
+	{0x3398, 0x10B0}, // MCU_DATA_4
+	{0x339A, 0xF710}, // MCU_DATA_5
+	{0x339C, 0xB0E6}, // MCU_DATA_6
+	{0x339E, 0x05CB}, // MCU_DATA_7
+	{0x338C, 0x05C0}, // MCU_ADDRESS
+	{0x3390, 0x02E7}, // MCU_DATA_0
+	{0x3392, 0x05C1}, // MCU_DATA_1
+	{0x3394, 0x0825}, // MCU_DATA_2
+	{0x3396, 0x8538}, // MCU_DATA_3
+	{0x3398, 0x3838}, // MCU_DATA_4
+	{0x339A, 0x3139}, // MCU_DATA_5
+	{0x339C, 0x4D27}, // MCU_DATA_6
+	{0x339E, 0x0458}, // MCU_DATA_7
+	{0x338C, 0x05D0}, // MCU_ADDRESS
+	{0x3390, 0x4A26}, // MCU_DATA_0
+	{0x3392, 0xFC39}, // MCU_DATA_1
+	{0x338C, 0x2003}, // MCU_ADDRESS
+	{0x3390, 0x0400}, // MON_ARG1
+	{0x338C, 0xA002}, // MCU_ADDRESS
+	{0x3390, 0x0001}, // MON_CMD
+	{0x338C, 0xA102}, // MCU_ADDRESS
+	{0x3390, 0x001F}, // SEQ_MODE
+	{0x338C, 0x1070}, // MCU_ADDRESS
+	{0x3390, 0x0302}, // MCU_DATA_0
+	{0x338C, 0x1078}, // MCU_ADDRESS
+	{0x3390, 0x0CFC}, // MCU_DATA_0
+	{0x338C, 0xA505}, // MCU_ADDRESS
+	{0x3390, 0x0000}, // AF_MODE_EX
+	{0x338C, 0xA506}, // MCU_ADDRESS
+	{0x3390, 0x0010}, // AF_NUM_STEPS
+	{0x338C, 0xA514}, // MCU_ADDRESS
+	{0x3390, 0x0000}, // AF_POSITION_0
+	{0x338C, 0xA515}, // MCU_ADDRESS
+	{0x3390, 0x0011}, // AF_POSITION_1
+	{0x338C, 0xA516}, // MCU_ADDRESS
+	{0x3390, 0x0022}, // AF_POSITION_2
+	{0x338C, 0xA517}, // MCU_ADDRESS
+	{0x3390, 0x0033}, // AF_POSITION_3
+	{0x338C, 0xA518}, // MCU_ADDRESS
+	{0x3390, 0x0044}, // AF_POSITION_4
+	{0x338C, 0xA519}, // MCU_ADDRESS
+	{0x3390, 0x0055}, // AF_POSITION_5
+	{0x338C, 0xA51A}, // MCU_ADDRESS
+	{0x3390, 0x0066}, // AF_POSITION_6
+	{0x338C, 0xA51B}, // MCU_ADDRESS
+	{0x3390, 0x0077}, // AF_POSITION_7
+	{0x338C, 0xA51C}, // MCU_ADDRESS
+	{0x3390, 0x0088}, // AF_POSITION_8
+	{0x338C, 0xA51D}, // MCU_ADDRESS
+	{0x3390, 0x0099}, // AF_POSITION_9
+	{0x338C, 0xA51E}, // MCU_ADDRESS
+	{0x3390, 0x00AA}, // AF_POSITION_10
+	{0x338C, 0xA51F}, // MCU_ADDRESS
+	{0x3390, 0x00BB}, // AF_POSITION_11
+	{0x338C, 0xA520}, // MCU_ADDRESS
+	{0x3390, 0x00CC}, // AF_POSITION_12
+	{0x338C, 0xA521}, // MCU_ADDRESS
+	{0x3390, 0x00DD}, // AF_POSITION_13
+	{0x338C, 0xA522}, // MCU_ADDRESS
+	{0x3390, 0x00EE}, // AF_POSITION_14
+	{0x338C, 0xA523}, // MCU_ADDRESS
+	{0x3390, 0x00FE}, // AF_POSITION_15
+	{0x338C, 0xA505}, // MCU_ADDRESS
+	{0x3390, 0x0020}, // AF_MODE_EX
+	{0x338C, 0xA508}, // MCU_ADDRESS
+	{0x3390, 0x0004}, // AF_NUM_STEPS_2
+	{0x338C, 0xA509}, // MCU_ADDRESS
+	{0x3390, 0x0006}, // AF_STEP_SIZE
+
+	{0x338C, 0x1078},  // MCU_ADDRESS
+	{0x3390, 0x0CFC},  // MCU_DATA_0
+	{0x338C, 0x1070}, // MCU_ADDRESS
+	{0x3390, 0x0302}, // GPIO_DATA
+	{0x338C, 0x1074}, // MCU_ADDRESS
+	{0x3390, 0x0002}, // GPIO_OUTPUT_SET
+	{0x338C, 0x107E}, // MCU_ADDRESS
+	{0x3390, 0x0002}, // GPIO_DIR_OUT
+
+	{0x338C, 0xA603}, // MCU_ADDRESS  
+	{0x3390, 0x0000}, // AF_STEP_SIZE
+#endif
+    {REG_TERM, VAL_TERM}
+};
+
+
+static struct sensor_reg sensor_preview[] = {
+	{0x338C, 0xA120},
+	{0x3390, 0x0000},
+	{0x338C, 0xA103},
+	{0x3390, 0x0001},
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_capture[] = {
+	{0x338C, 0xA120},
+	{0x3390, 0x0002},
+	{0x338C, 0xA103},
+	{0x3390, 0x0002},
+    {REG_TERM, VAL_TERM}
+};
+
+ struct sensor_reg* sensor_reg_common[3] =
+{
+	sensor_common,
+	sensor_preview,
+	sensor_capture
+};
+
+static struct sensor_reg sensor_brightness_0[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_brightness_1[] = {
+	{REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_brightness_2[] = {	
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_brightness_3[] = {	
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_brightness_4[] = {	
+    {REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_brightness[5] =
+{
+	sensor_brightness_0,
+	sensor_brightness_1,
+	sensor_brightness_2,
+	sensor_brightness_3,
+	sensor_brightness_4
+};
+
+
+static struct sensor_reg sensor_awb_auto[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_awb_daylight[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_awb_incandescent[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_awb_fluorescent[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_awb_cloudy[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_awb_sunset[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_awb[6] =
+{
+	sensor_awb_auto,
+	sensor_awb_daylight,
+	sensor_awb_incandescent,
+	sensor_awb_fluorescent,
+	sensor_awb_cloudy,
+	sensor_awb_sunset
+	
+};
+
+
+static struct sensor_reg sensor_iso_auto[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_iso_100[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_iso_200[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_iso_400[] = {
+	{REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_iso[4] =
+{
+	sensor_iso_auto,
+	sensor_iso_100,
+	sensor_iso_200,
+	sensor_iso_400
+};
+
+
+static struct sensor_reg sensor_effect_normal[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_effect_gray[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_effect_negative[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_effect_sepia[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_effect_sharpness[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_effect_sketch[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_effect[6] =
+{
+	sensor_effect_normal,
+	sensor_effect_gray,
+	sensor_effect_negative,
+	sensor_effect_sepia,
+	sensor_effect_sharpness,
+	sensor_effect_sketch,
+};
+
+static struct sensor_reg sensor_reg_flipnone[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_reg_hflip[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_reg_vflip[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_reg_hvflip[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_flip[4] =
+{
+	sensor_reg_flipnone,
+	sensor_reg_hflip,
+	sensor_reg_vflip,
+	sensor_reg_hvflip,
+};
+
+
+static struct sensor_reg sensor_secne_auto[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_secne_night[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_secne_landscape[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_secne_portrait[] = {
+	{REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_secne_sport[] = {
+	{REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_scene[5] =
+{
+	sensor_secne_auto,
+	sensor_secne_night,
+	sensor_secne_landscape,
+	sensor_secne_portrait,
+	sensor_secne_sport
+};
+
+static struct sensor_reg sensor_me_mtrix[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_me_center_weighted[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_me_spot[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_metering_exposure[3] =
+{
+	sensor_me_mtrix,
+	sensor_me_center_weighted,
+	sensor_me_spot,
+};
+
+static struct sensor_reg sensor_af_single[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_af_manual[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_af[2] =
+{
+	sensor_af_single,
+	sensor_af_manual,
+};
+
+#endif
+
Index: linux-2.6.29/drivers/media/video/tcccam/mt9d112_2mp.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/tcccam/mt9d112_2mp.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,64 @@
+/*
+ * drivers/media/video/tcccam/mt9d112_2mp.h
+ *
+ * Register definitions for the mt9d112 CameraChip.
+ *
+ * Author: zzau (zzau@telechips.com)
+ *
+ * Copyright (C) 2008 Telechips, Inc.
+ *
+ * This file is licensed under the terms of the GNU General Public License 
+ * version 2. This program is licensed "as is" without any warranty of any 
+ * kind, whether express or implied.
+ */
+
+#ifndef MT9D112_H
+#define MT9D112_H
+
+/* The MT9D112 I2C sensor chip has a fixed slave address of 0x7A. */
+#define SENSOR_I2C_ADDR		0x7A
+
+#define REG_TERM 0x0000	/* terminating list entry for reg */
+#define VAL_TERM 0x0000	/* terminating list entry for val */
+
+#define CAMDLY 0xFFFF
+
+// ZOOM Setting!!
+#define PRV_W			800
+#define PRV_H			600
+#define PRV_ZOFFX		8
+#define PRV_ZOFFY		6
+
+#define CAP_W			1600
+#define CAP_H			1200
+#define CAP_ZOFFX		16
+#define CAP_ZOFFY		12
+
+#define CAM_2XMAX_ZOOM_STEP 	25
+#define CAM_CAPCHG_WIDTH  		800
+
+
+struct sensor_reg {
+	unsigned short reg;
+	unsigned short val[1];
+};
+
+struct capture_size {
+	unsigned long width;
+	unsigned long height;
+};
+
+extern struct capture_size sensor_sizes[];
+
+extern struct sensor_reg* sensor_reg_common[];
+extern struct sensor_reg* sensor_reg_brightness[];
+extern struct sensor_reg* sensor_reg_awb[];
+extern struct sensor_reg* sensor_reg_iso[];
+extern struct sensor_reg* sensor_reg_effect[];
+extern struct sensor_reg* sensor_reg_flip[];
+extern struct sensor_reg* sensor_reg_scene[];
+extern struct sensor_reg* sensor_reg_metering_exposure[];
+extern struct sensor_reg* sensor_reg_af[];
+
+#endif /* MT9D112_H */
+
Index: linux-2.6.29/drivers/media/video/tcccam/mt9p111_5mp.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/tcccam/mt9p111_5mp.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,1264 @@
+/*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*
+
+               CAMERA    API    M O D U L E
+
+                        EDIT HISTORY FOR MODULE
+
+when        who       what, where, why
+--------    ---       -------------------------------------------------------
+10/xx/08  Telechips   Created file.
+*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*/
+
+/*===========================================================================
+
+                           INCLUDE FILES FOR MODULE
+
+===========================================================================*/
+#include "sensor_if.h"
+
+#ifdef CONFIG_VIDEO_CAMERA_SENSOR_MT9P111
+
+/* Array of image sizes supported by MV9317.  These must be ordered from 
+ * smallest image size to largest.
+ */
+struct capture_size sensor_sizes[] = {
+	{ 2560, 1920 },	/* QQXGA */
+	{ 2048, 1536 },	/* QXGA */
+	{ 1600, 1200 },	/* UXGA */
+	{ 1280,  720 },	/* SXGA */
+	{ 1024,  768 },	/* XGA */
+	{  800,  600 },	/* SVGA */
+	{  640,  480 },	/* VGA */
+	{  320,  240 },	/* QVGA */
+	{  176,  144 },	/* QCIF */
+};
+
+
+/* register initialization tables for sensor */
+/* common sensor register initialization for all image sizes, pixel formats, 
+ * and frame rates
+ */
+static struct sensor_reg sensor_common[] = {
+//PART 0 BURST-DATA
+	{0x0010, 0x0120, 0x0070, 0x2025, 0x1111},
+	{0x001E, 0x0777, 0x1111},	  // PAD_SLEW_PAD_CONFIG
+	{0x0022, 0x01E0, 0x1111},	  // VDD_DIS_COUNTER
+	{0x002A, 0x7FFF, 0x0000, 0x0000, 0x1111},
+	{0x0018, 0x4008, 0x1111},	  // STANDBY_CONTROL_AND_STATUS
+	{0x098E, 0x8001, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [MON_MODE]
+	{0x0990, 0x0000, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x0982, 0x0000, 0x1111},	  // ACCESS_CTL_STAT
+	{0x098A, 0x0838, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0xC0F1, 0xC5E1, 0x246A, 0x1280, 0xC4E1, 0xD30E, 0x2069, 0x0000, 0x1111},
+	{0x098A, 0x0848, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x1305, 0x0084, 0x1730, 0x7005, 0xD801, 0x8B41, 0xD900, 0x0D0A, 0x1111},
+	{0x098A, 0x0858, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x0064, 0x8B63, 0xE809, 0xD509, 0xF004, 0x1504, 0x1400, 0x7840, 0x1111},
+	{0x098A, 0x0868, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0xD007, 0x0DFB, 0x9004, 0xC4C1, 0x2029, 0x0300, 0x0191, 0x0684, 0x1111},
+	{0x098A, 0x0878, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0xFF80, 0x0894, 0xFF80, 0x0838, 0xFF80, 0x0888, 0xFF80, 0x0894, 0x1111},
+	{0x098A, 0x0888, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0xFF80, 0x0AA4, 0xFF80, 0x0A10, 0xFF80, 0x0B78, 0x0001, 0x0003, 0x1111},
+	{0x098A, 0x0898, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x0000, 0x0000, 0xC0F1, 0x0DBA, 0x01C4, 0xD167, 0xD067, 0x1952, 0x1111},
+	{0x098A, 0x08A8, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x0024, 0x208A, 0x0004, 0x199C, 0x0024, 0xD165, 0x8101, 0x2004, 0x1111},
+	{0x098A, 0x08B8, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x8FBE, 0x0100, 0xF0F0, 0xF208, 0x8901, 0x080D, 0x005E, 0xD061, 0x1111},
+	{0x098A, 0x08C8, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0xD901, 0xA820, 0xC0D1, 0x7EE0, 0xC0F1, 0x08BE, 0x0684, 0xD75C, 0x1111},
+	{0x098A, 0x08D8, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x970E, 0x0813, 0x015E, 0xD15C, 0x814E, 0x9239, 0xB734, 0x925A, 0x1111},
+	{0x098A, 0x08E8, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0xF005, 0xD25A, 0x922A, 0x924B, 0xB734, 0xD653, 0xD558, 0x2053, 0x1111},
+	{0x098A, 0x08F8, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x8040, 0x1E40, 0x1064, 0x1E42, 0x10A4, 0xB755, 0xF220, 0x0A0E, 0x1111},
+	{0x098A, 0x0908, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x01E4, 0xD801, 0xD800, 0xAF00, 0x1E3C, 0x1024, 0x8500, 0x8009, 0x1111},
+	{0x098A, 0x0918, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x7860, 0xDF00, 0x8500, 0x8004, 0x7840, 0x8500, 0x8005, 0x7840, 0x1111},
+	{0x098A, 0x0928, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x8500, 0x8006, 0x7840, 0xD045, 0x1E52, 0x1024, 0x208A, 0x0004, 0x1111},
+	{0x098A, 0x0938, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x1E9C, 0x1024, 0x8500, 0x8003, 0x7840, 0xF021, 0x8500, 0x8003, 0x1111},
+	{0x098A, 0x0948, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x7840, 0xD800, 0x163C, 0x1901, 0x2153, 0x00C2, 0x0A25, 0x0153, 0x1111},
+	{0x098A, 0x0958, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x695C, 0xBAC3, 0x0A1D, 0x0153, 0x2942, 0x0202, 0xBAC3, 0xE284, 0x1111},
+	{0x098A, 0x0968, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x29C2, 0x032C, 0x21D3, 0x00EC, 0x21CC, 0x812C, 0x20CA, 0x006C, 0x1111},
+	{0x098A, 0x0978, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0xE86A, 0xDF00, 0x0996, 0x01E4, 0x70E9, 0xD032, 0x8800, 0xE809, 0x1111},
+	{0x098A, 0x0988, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x167E, 0x1900, 0xE080, 0x27CA, 0x1061, 0x1E7E, 0x13E4, 0x8500, 0x1111},
+	{0x098A, 0x0998, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x8007, 0x7840, 0x0059, 0x0684, 0xC0F1, 0x0A5A, 0x01C4, 0xD228, 0x1111},
+	{0x098A, 0x09A8, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x920E, 0x2051, 0x8180, 0x9212, 0xF205, 0x204F, 0x01C1, 0xB232, 0x1111},
+	{0x098A, 0x09B8, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0xF004, 0xB8A7, 0x7910, 0xB212, 0xD026, 0x1804, 0x0064, 0xF184, 0x1111},
+	{0x098A, 0x09C8, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0xC0F1, 0xC5E1, 0xD21E, 0x8A01, 0x9234, 0x9275, 0x0815, 0x009E, 0x1111},
+	{0x098A, 0x09D8, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x8A31, 0x8A12, 0x8A73, 0xB908, 0x7905, 0x8A14, 0xBB08, 0x7B05, 0x1111},
+	{0x098A, 0x09E8, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x8A00, 0x92AE, 0xB8A2, 0xAA00, 0x0D13, 0x105E, 0xDD05, 0xBD09, 0x1111},
+	{0x098A, 0x09F8, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x0D0B, 0x1043, 0xB882, 0xAA00, 0x71A9, 0xD017, 0x1808, 0x0064, 0x1111},
+	{0x098A, 0x0A08, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x180A, 0x00E4, 0x07F9, 0x0644, 0xC0F1, 0x0F82, 0x0664, 0xDA28, 0x1111},
+	{0x098A, 0x0A18, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0xD112, 0xD513, 0x76A9, 0x0D16, 0x0664, 0x70C9, 0xD011, 0xA507, 0x1111},
+	{0x098A, 0x0A28, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0xD011, 0xA502, 0xD011, 0xA503, 0xD011, 0xA509, 0xD008, 0x07C9, 0x1111},
+	{0x098A, 0x0A38, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x0664, 0xA0C0, 0xFF00, 0x3BC4, 0x0000, 0xFFFF, 0xFF80, 0x0290, 0x1111},
+	{0x098A, 0x0A48, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0xFF80, 0x0BF8, 0xFF80, 0x0340, 0xFF80, 0x02D0, 0x8000, 0x0070, 0x1111},
+	{0x098A, 0x0A58, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0xFF00, 0x3C3C, 0xFF00, 0x3C00, 0x0000, 0xE758, 0xFF80, 0x0BFC, 0x1111},
+	{0x098A, 0x0A68, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0xFF80, 0x089C, 0xFF80, 0x08D0, 0xFF80, 0x09A0, 0xFF80, 0x09C8, 0x1111},
+	{0x098A, 0x0A78, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0xC0F1, 0xC5E1, 0x099E, 0xFFE3, 0x7508, 0xD111, 0x79B6, 0x8910, 0x1111},
+	{0x098A, 0x0A88, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x080D, 0x0091, 0xD20F, 0x9201, 0xB886, 0xB201, 0x890F, 0x080D, 0x1111},
+	{0x098A, 0x0A98, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x0111, 0xD00D, 0xD905, 0xB021, 0x0765, 0x0644, 0xC0F1, 0x0EEA, 0x1111},
+	{0x098A, 0x0AA8, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x0664, 0xDA34, 0xD709, 0xD60A, 0x75E9, 0x70A9, 0x0D2E, 0x0664, 0x1111},
+	{0x098A, 0x0AB8, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x8620, 0xD008, 0xA701, 0x0739, 0x0664, 0xA6A0, 0xFF80, 0x01B0, 0x1111},
+	{0x098A, 0x0AC8, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0xFF80, 0x05E8, 0xFF80, 0x0698, 0xFF80, 0x0C24, 0x8000, 0x0000, 0x1111},
+	{0x098A, 0x0AD8, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0xFF80, 0x0A78, 0xC0F1, 0x0EAA, 0x0644, 0x0DAE, 0x0544, 0xD02D, 0x1111},
+	{0x098A, 0x0AE8, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0xD52D, 0x88D2, 0x08C2, 0x00A4, 0x8D04, 0x7EDB, 0xD72B, 0x218A, 0x1111},
+	{0x098A, 0x0AF8, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x0FCF, 0x2805, 0x03BE, 0x2941, 0x7140, 0x208C, 0x8FCF, 0x20CA, 0x1111},
+	{0x098A, 0x0B08, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x0046, 0x1F2E, 0x1024, 0x08A2, 0x00A4, 0x9507, 0xD624, 0x16E3, 0x1111},
+	{0x098A, 0x0B18, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x1082, 0x703A, 0x1660, 0x1104, 0x9507, 0x7148, 0x2186, 0x03FC, 0x1111},
+	{0x098A, 0x0B28, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0xB944, 0xBAC3, 0x0876, 0x00A4, 0x165E, 0x1103, 0x6018, 0x7815, 0x1111},
+	{0x098A, 0x0B38, 0x1111},	  // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x0F0E, 0x0664, 0x712A, 0x16E2, 0x1082, 0x2840, 0x0210, 0x1660, 0x1111},
+	{0x098A, 0x0B48, 0x1111}, // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x1104, 0x9507, 0x7148, 0x2186, 0x03FC, 0xB944, 0xBAC3, 0x084E, 0x1111},
+	{0x098A, 0x0B58, 0x1111}, // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x00A4, 0x165E, 0x1103, 0x6018, 0x7815, 0x0EE6, 0x0664, 0x712A, 0x1111},
+	{0x098A, 0x0B68, 0x1111}, // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0xB80C, 0x2005, 0x0400, 0x1F32, 0x1024, 0x0675, 0x0644, 0x78E0, 0x1111},
+	{0x098A, 0x0B78, 0x1111}, // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0xC0F1, 0x0E1A, 0x0664, 0xDA38, 0xD10A, 0xD50B, 0x76A9, 0x0BAE, 0x1111},
+	{0x098A, 0x0B88, 0x1111}, // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x0664, 0x70C9, 0xD009, 0xA503, 0xD009, 0x066D, 0x0664, 0xA0C0, 0x1111},
+	{0x098A, 0x0B98, 0x1111}, // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0xFF80, 0x05D4, 0xFF80, 0x07C8, 0xFF00, 0x3390, 0xFF80, 0x06E4, 0x1111},
+	{0x098A, 0x0BA8, 0x1111}, // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x0000, 0xF170, 0xFF80, 0x0C58, 0xFF80, 0x0ADC, 0x8000, 0x014C, 0x1111},
+	{0x098A, 0x0BB8, 0x1111}, // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0xEA0A, 0x242F, 0x7089, 0x78E0, 0x20A8, 0x0180, 0x1002, 0x0D02, 0x1111},
+	{0x098A, 0x0BC8, 0x1111}, // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x1902, 0x0094, 0x7FE0, 0x7028, 0x7308, 0x1000, 0x0900, 0x7904, 0x1111},
+	{0x098A, 0x0BD8, 0x1111}, // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x7947, 0x1B00, 0x0064, 0x7EE0, 0xEA0A, 0x242F, 0x7089, 0x78E0, 0x1111},
+	{0x098A, 0x0BE8, 0x1111}, // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x20A8, 0x0180, 0x1102, 0x0502, 0x1802, 0x00B4, 0x7FE0, 0x7028, 0x1111},
+	{0x098A, 0x0BF8, 0x1111}, // PHYSICAL_ADDRESS_ACCESS
+	{0x0990, 0x0000, 0x0000, 0x1111},
+	{0x098E, 0x0016, 0x1111}, // LOGICAL_ADDRESS_ACCESS [MON_ADDRESS_LO]
+	{0x0990, 0x0838, 0x1111}, // MCU_VARIABLE_DATA0
+	{0x098E, 0x0002, 0x1111}, // LOGICAL_ADDRESS_ACCESS [MON_CMD]
+	
+	{REG_TERM, 0x0050, 0x1111}, //delay 80ms
+
+//PART 1
+	{0x0990, 0x0001, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x30D4, 0xB080, 0x1111},	  // COLUMN_CORRECTION
+	{0x316E, 0xC400, 0x1111},	  // DAC_ECL
+	{0x305E, 0x10A0, 0x1111},	  // GLOBAL_GAIN
+	{0x3E00, 0x0010, 0x1111},	  // SAMP_CONTROL
+	{0x3E02, 0xED02, 0x1111},	  // SAMP_ADDR_EN
+	{0x3E04, 0xC88C, 0x1111},	  // SAMP_RD1_SIG
+	{0x3E06, 0xC88C, 0x1111},	  // SAMP_RD1_SIG_BOOST
+	{0x3E08, 0x700A, 0x1111},	  // SAMP_RD1_RST
+	{0x3E0A, 0x701E, 0x1111},	  // SAMP_RD1_RST_BOOST
+	{0x3E0C, 0x00FF, 0x1111},	  // SAMP_RST1_EN
+	{0x3E0E, 0x00FF, 0x1111},	  // SAMP_RST1_BOOST
+	{0x3E10, 0x00FF, 0x1111},	  // SAMP_RST1_CLOOP_SH
+	{0x3E12, 0x0000, 0x1111},	  // SAMP_RST_BOOST_SEQ
+	{0x3E14, 0xC78C, 0x1111},	  // SAMP_SAMP1_SIG
+	{0x3E16, 0x6E06, 0x1111},	  // SAMP_SAMP1_RST
+	{0x3E18, 0xA58C, 0x1111},	  // SAMP_TX_EN
+	{0x3E1A, 0xA58E, 0x1111},	  // SAMP_TX_BOOST
+	{0x3E1C, 0xA58E, 0x1111},	  // SAMP_TX_CLOOP_SH
+	{0x3E1E, 0xC0D0, 0x1111},	  // SAMP_TX_BOOST_SEQ
+	{0x3E20, 0xEB00, 0x1111},	  // SAMP_VLN_EN
+	{0x3E22, 0x00FF, 0x1111},	  // SAMP_VLN_HOLD
+	{0x3E24, 0xEB02, 0x1111},	  // SAMP_VCL_EN
+	{0x3E26, 0xEA02, 0x1111},	  // SAMP_COLCLAMP
+	{0x3E28, 0xEB0A, 0x1111},	  // SAMP_SH_VCL
+	{0x3E2A, 0xEC01, 0x1111},	  // SAMP_SH_VREF
+	{0x3E2C, 0xEB01, 0x1111},	  // SAMP_SH_VBST
+	{0x3E2E, 0x00FF, 0x1111},	  // SAMP_SPARE
+	{0x3E30, 0x00F3, 0x1111},	  // SAMP_READOUT
+	{0x3E32, 0x3DFA, 0x1111},	  // SAMP_RESET_DONE
+	{0x3E34, 0x00FF, 0x1111},	  // SAMP_VLN_CLAMP
+	{0x3E36, 0x00F3, 0x1111},	  // SAMP_ASC_INT
+	{0x3E38, 0x0000, 0x1111},	  // SAMP_RS_CLOOP_SH_R
+	{0x3E3A, 0xF802, 0x1111},	  // SAMP_RS_CLOOP_SH
+	{0x3E3C, 0x0FFF, 0x1111},	  // SAMP_RS_BOOST_SEQ
+	{0x3E3E, 0xEA10, 0x1111},	  // SAMP_TXLO_GND
+	{0x3E40, 0xEB05, 0x1111},	  // SAMP_VLN_PER_COL
+	{0x3E42, 0xE5C8, 0x1111},	  // SAMP_RD2_SIG
+	{0x3E44, 0xE5C8, 0x1111},	  // SAMP_RD2_SIG_BOOST
+	{0x3E46, 0x8C70, 0x1111},	  // SAMP_RD2_RST
+	{0x3E48, 0x8C71, 0x1111},	  // SAMP_RD2_RST_BOOST
+	{0x3E4A, 0x00FF, 0x1111},	  // SAMP_RST2_EN
+	{0x3E4C, 0x00FF, 0x1111},	  // SAMP_RST2_BOOST
+	{0x3E4E, 0x00FF, 0x1111},	  // SAMP_RST2_CLOOP_SH
+	{0x3E50, 0xE38D, 0x1111},	  // SAMP_SAMP2_SIG
+	{0x3E52, 0x8B0A, 0x1111},	  // SAMP_SAMP2_RST
+	{0x3E58, 0xEB0A, 0x1111},	  // SAMP_PIX_CLAMP_EN
+	{0x3E5C, 0x0A00, 0x1111},	  // SAMP_PIX_PULLUP_EN
+	{0x3E5E, 0x00FF, 0x1111},	  // SAMP_PIX_PULLDOWN_EN_R
+	{0x3E60, 0x00FF, 0x1111},	  // SAMP_PIX_PULLDOWN_EN_S
+	{0x3E90, 0x3C01, 0x1111},	  // RST_ADDR_EN
+	{0x3E92, 0x00FF, 0x1111},	  // RST_RST_EN
+	{0x3E94, 0x00FF, 0x1111},	  // RST_RST_BOOST
+	{0x3E96, 0x3C00, 0x1111},	  // RST_TX_EN
+	{0x3E98, 0x3C00, 0x1111},	  // RST_TX_BOOST
+	{0x3E9A, 0x3C00, 0x1111},	  // RST_TX_CLOOP_SH
+	{0x3E9C, 0xC0E0, 0x1111},	  // RST_TX_BOOST_SEQ
+	{0x3E9E, 0x00FF, 0x1111},	  // RST_RST_CLOOP_SH
+	{0x3EA0, 0x0000, 0x1111},	  // RST_RST_BOOST_SEQ
+	{0x3EA6, 0x3C00, 0x1111},	  // RST_PIX_PULLUP_EN
+	{0x3ED8, 0x3057, 0x1111},	  // DAC_LD_12_13
+	{0x3172, 0x0113, 0x1111},	  // ANALOG_CONTROL2
+	{0x316C, 0xB44F, 0x1111},	  // DAC_TXLO
+	{0x316E, 0xC6FF, 0x1111},	  // DAC_ECL
+	{0x3ED2, 0xEA0F, 0x1111},	  // DAC_LD_6_7
+	{0x3ED4, 0x0004, 0x1111},	  // DAC_LD_8_9
+	{0x3EDC, 0x6020, 0x1111},	  // DAC_LD_16_17
+	{0x3EE6, 0xA5C0, 0x1111},	  // DAC_LD_26_27
+	{0x098E, 0x483A, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_Y_ADDR_START]
+	{0x0990, 0x000C, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x483C, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_X_ADDR_START]
+	{0x0990, 0x0018, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x483E, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_Y_ADDR_END]
+	{0x0990, 0x07B1, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4840, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_X_ADDR_END]
+	{0x0990, 0x0A45, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4842, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_ROW_SPEED]
+	{0x0990, 0x0001, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4844, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_SKIP_X_CORE]
+	{0x0990, 0x0103, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4846, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_SKIP_Y_CORE]
+	{0x0990, 0x0103, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4848, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_SKIP_X_PIPE]
+	{0x0990, 0x0103, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x484A, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_SKIP_Y_PIPE]
+	{0x0990, 0x0103, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x484C, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_POWER_MODE]
+	{0x0990, 0x00F6, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x484E, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_BIN_MODE]
+	{0x0990, 0x0001, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xC850, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_ORIENTATION]
+	{0x0990, 0x0000, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xC851, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_PIXEL_ORDER]
+	{0x0990, 0x0000, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4852, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_FINE_CORRECTION]
+	{0x0990, 0x019C, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4854, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_FINE_ITMIN]
+	{0x0990, 0x0732, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4858, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_COARSE_ITMIN]
+	{0x0990, 0x0000, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x485A, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_COARSE_ITMAX_MARGIN]
+	{0x0990, 0x0001, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x485C, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_MIN_FRAME_LENGTH_LINES]
+	{0x0990, 0x0423, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x485E, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_MAX_FRAME_LENGTH_LINES]
+	{0x0990, 0xFFFF, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4860, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_BASE_FRAME_LENGTH_LINES]
+	{0x0990, 0x0423, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4862, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_MIN_LINE_LENGTH_PCLK]
+	{0x0990, 0x0F06, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4864, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_MAX_LINE_LENGTH_PCLK]
+	{0x0990, 0xFFFE, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4866, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_P4_5_6_DIVIDER]
+	{0x0990, 0x7F7C, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4868, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_FRAME_LENGTH_LINES]
+	{0x0990, 0x0423, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x486A, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_LINE_LENGTH_PCK]
+	{0x0990, 0x0F06, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x486C, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_OUTPUT_SIZE_WIDTH]
+	{0x0990, 0x0518, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x486E, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_OUTPUT_SIZE_HEIGHT]
+	{0x0990, 0x03D4, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4870, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_RX_FIFO_TRIGGER_MARK]
+	{0x0990, 0x0014, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x48B8, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_OUTPUT_0_JPEG_CONTROL]
+	{0x0990, 0x0004, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x48AE, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_OUTPUT_0_OUTPUT_FORMAT]
+	{0x0990, 0x0001, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x48AA, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_OUTPUT_0_IMAGE_WIDTH]
+	{0x0990, 0x0280, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x48AC, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_OUTPUT_0_IMAGE_HEIGHT]
+	{0x0990, 0x01E0, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4872, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_B_Y_ADDR_START]
+	{0x0990, 0x0010, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4874, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_B_X_ADDR_START]
+	{0x0990, 0x001C, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4876, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_B_Y_ADDR_END]
+	{0x0990, 0x07AF, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4878, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_B_X_ADDR_END]
+	{0x0990, 0x0A43, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x487A, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_B_ROW_SPEED]
+	{0x0990, 0x0001, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x487C, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_B_SKIP_X_CORE]
+	{0x0990, 0x0101, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x487E, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_B_SKIP_Y_CORE]
+	{0x0990, 0x0101, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4880, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_B_SKIP_X_PIPE]
+	{0x0990, 0x0101, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4882, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_B_SKIP_Y_PIPE]
+	{0x0990, 0x0101, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4884, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_B_POWER_MODE]
+	{0x0990, 0x00F2, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4886, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_B_BIN_MODE]
+	{0x0990, 0x0000, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xC888, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_B_ORIENTATION]
+	{0x0990, 0x0000, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xC889, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_B_PIXEL_ORDER]
+	{0x0990, 0x0000, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x488A, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_B_FINE_CORRECTION]
+	{0x0990, 0x009C, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x488C, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_B_FINE_ITMIN]
+	{0x0990, 0x034A, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4890, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_B_COARSE_ITMIN]
+	{0x0990, 0x0000, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4892, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_B_COARSE_ITMAX_MARGIN]
+	{0x0990, 0x0001, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4894, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_B_MIN_FRAME_LENGTH_LINES]
+	{0x0990, 0x082F, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4896, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_B_MAX_FRAME_LENGTH_LINES]
+	{0x0990, 0xFFFF, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4898, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_B_BASE_FRAME_LENGTH_LINES]
+	{0x0990, 0x082F, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x489A, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_B_MIN_LINE_LENGTH_PCLK]
+	{0x0990, 0x10CC, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x489C, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_B_MAX_LINE_LENGTH_PCLK]
+	{0x0990, 0xFFFE, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x489E, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_B_P4_5_6_DIVIDER]
+	{0x0990, 0x7F7C, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x48A0, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_B_FRAME_LENGTH_LINES]
+	{0x0990, 0x082F, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x48A2, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_B_LINE_LENGTH_PCK]
+	{0x0990, 0x10CC, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x48A4, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_B_OUTPUT_SIZE_WIDTH]
+	{0x0990, 0x0A28, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x48A6, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_B_OUTPUT_SIZE_HEIGHT]
+	{0x0990, 0x07A0, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x48A8, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_B_RX_FIFO_TRIGGER_MARK]
+	{0x0990, 0x0014, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x48CE, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_OUTPUT_1_JPEG_CONTROL]
+	{0x0990, 0x0015, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x48C4, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_OUTPUT_1_OUTPUT_FORMAT]
+	{0x0990, 0x0001, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x48C0, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_OUTPUT_1_IMAGE_WIDTH]
+	{0x0990, 0x0A20, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x48C2, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_OUTPUT_1_IMAGE_HEIGHT]
+	{0x0990, 0x0798, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x301A, 0x10F4, 0x1111},	  // RESET_REGISTER
+	{0x301E, 0x0000, 0x1111},	  // DATA_PEDESTAL
+	{0x301A, 0x10FC, 0x1111},	  // RESET_REGISTER
+	{0x098E, 0xDC33, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [SYS_FIRST_BLACK_LEVEL]
+	{0x0990, 0x0000, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xDC35, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [SYS_UV_COLOR_BOOST]
+	{0x0990, 0x0400, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x326E, 0x0004, 0x1111},	  // LOW_PASS_YUV_FILTER
+	{0x098E, 0x4858, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_COARSE_ITMIN]
+	{0x0990, 0x0002, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4890, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_B_COARSE_ITMIN]
+	{0x0990, 0x0002, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xDC37, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [SYS_BRIGHT_COLORKILL]
+	{0x0990, 0x6200, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x35A4, 0x0596, 0x1111},	  // BRIGHT_COLOR_KILL_CONTROLS
+	{0x35A2, 0x0094, 0x1111},	  // DARK_COLOR_KILL_CONTROLS
+	{0x098E, 0xDC36, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [SYS_DARK_COLOR_KILL]
+	{0x0990, 0x2300, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x8404, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [SEQ_CMD]
+	{0x0990, 0x0600, 0x1111},	  // MCU_VARIABLE_DATA0
+
+	{REG_TERM, 0x0050, 0x1111}, //delay 80ms
+
+//PART 2
+	{0x098E, 0x3C14, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_FADE_TO_BLACK_START_POS]
+	{0x0990, 0xFFFE, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x3C16, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_FADE_TO_BLACK_END_POS]
+	{0x0990, 0xFFFF, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x32BA, 0x0000, 0x1111},	  // RED_OFFSET_TO_CCM
+	{0x32BC, 0x0000, 0x1111},	  // GREEN_OFFSET_TO_CCM
+	{0x32BE, 0x0000, 0x1111},	  // BLUE_OFFSET_TO_CCM
+	{0x3330, 0x0000, 0x1111},	  // OUTPUT_FORMAT_TEST
+	{0x337C, 0x0004, 0x1111},	  // YUV_YCBCR_CONTROL
+	{0x337E, 0x0000, 0x1111},	  // Y_RGB_OFFSET
+	{0x0010, 0x0320, 0x1111},	  // PLL_DIVIDERS
+	{0x0010, 0x0360, 0x1111},	  // PLL_DIVIDERS
+	{0x32BA, 0x0000, 0x1111},	  // RED_OFFSET_TO_CCM
+	{0x32BC, 0x0000, 0x1111},	  // GREEN_OFFSET_TO_CCM
+	{0x32BE, 0x0000, 0x1111},	  // BLUE_OFFSET_TO_CCM
+	{0x098E, 0xA00E, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [FD_MAX_NUM_AUTOCOR_FUNC_VALUES_TO_CHECK]
+	{0x0990, 0x3200, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2018, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [FD_EXPECTED50HZ_FLICKER_PERIOD_IN_CONTEXT_A]
+	{0x0990, 0x0133, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x201A, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [FD_EXPECTED50HZ_FLICKER_PERIOD_IN_CONTEXT_B]
+	{0x0990, 0x0113, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x201C, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [FD_EXPECTED60HZ_FLICKER_PERIOD_IN_CONTEXT_A]
+	{0x0990, 0x00FF, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x201E, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [FD_EXPECTED60HZ_FLICKER_PERIOD_IN_CONTEXT_B]
+	{0x0990, 0x00E4, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2010, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [FD_MIN_EXPECTED50HZ_FLICKER_PERIOD]
+	{0x0990, 0x0129, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2012, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [FD_MAX_EXPECTED50HZ_FLICKER_PERIOD]
+	{0x0990, 0x013D, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2014, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [FD_MIN_EXPECTED60HZ_FLICKER_PERIOD]
+	{0x0990, 0x00F5, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2016, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [FD_MAX_EXPECTED60HZ_FLICKER_PERIOD]
+	{0x0990, 0x0109, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xA000, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [FD_STATUS]
+	{0x0990, 0x1400, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x3380, 0x0504, 0x1111},	  // KERNEL_CONFIG
+	{0x098E, 0xBCB2, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_CDC_DARK_CLUS_SLOPE]
+	{0x0990, 0x2800, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBCB3, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_CDC_DARK_CLUS_SATUR]
+	{0x0990, 0x5F00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2C46, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AWB_LEFT_CCM_0]
+	{0x0990, 0x0227, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2C48, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AWB_LEFT_CCM_1]
+	{0x0990, 0xFEBE, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2C4A, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AWB_LEFT_CCM_2]
+	{0x0990, 0x0038, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2C4C, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AWB_LEFT_CCM_3]
+	{0x0990, 0xFFCB, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2C4E, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AWB_LEFT_CCM_4]
+	{0x0990, 0x014D, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2C50, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AWB_LEFT_CCM_5]
+	{0x0990, 0x0006, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2C52, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AWB_LEFT_CCM_6]
+	{0x0990, 0xFFC6, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2C54, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AWB_LEFT_CCM_7]
+	{0x0990, 0xFED3, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2C56, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AWB_LEFT_CCM_8]
+	{0x0990, 0x0284, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2C5C, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AWB_RIGHT_CCM_0]
+	{0x0990, 0x024A, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2C5E, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AWB_RIGHT_CCM_1]
+	{0x0990, 0xFF25, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2C60, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AWB_RIGHT_CCM_2]
+	{0x0990, 0xFFAE, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2C62, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AWB_RIGHT_CCM_3]
+	{0x0990, 0xFFCC, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2C64, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AWB_RIGHT_CCM_4]
+	{0x0990, 0x0150, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2C66, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AWB_RIGHT_CCM_5]
+	{0x0990, 0x0002, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2C68, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AWB_RIGHT_CCM_6]
+	{0x0990, 0xFFFB, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2C6A, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AWB_RIGHT_CCM_7]
+	{0x0990, 0xFF69, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2C6C, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AWB_RIGHT_CCM_8]
+	{0x0990, 0x01B9, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2C58, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AWB_LEFT_CCM_R2BRATIO]
+	{0x0990, 0x00CD, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2C6E, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AWB_RIGHT_CCM_R2BRATIO]
+	{0x0990, 0x0050, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x3240, 0x0012, 0x1111},	  // AWB_XY_SCALE
+	{0x3242, 0xF31A, 0x1111},	  // AWB_WEIGHT_R0
+	{0x3244, 0xFE36, 0x1111},	  // AWB_WEIGHT_R1
+	{0x3246, 0xDF28, 0x1111},	  // AWB_WEIGHT_R2
+	{0x3248, 0xD724, 0x1111},	  // AWB_WEIGHT_R3
+	{0x324A, 0xE3B5, 0x1111},	  // AWB_WEIGHT_R4
+	{0x324C, 0xD587, 0x1111},	  // AWB_WEIGHT_R5
+	{0x324E, 0xD3F1, 0x1111},	  // AWB_WEIGHT_R6
+	{0x3250, 0x2C8F, 0x1111},	  // AWB_WEIGHT_R7
+	{0x098E, 0x3842, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [STAT_AWB_GRAY_CHECKER_OFFSET_X]
+	{0x0990, 0x003A, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x3844, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [STAT_AWB_GRAY_CHECKER_OFFSET_Y]
+	{0x0990, 0x0037, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xAC01, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AWB_MODE]
+	{0x0990, 0xAB00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xAC3C, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AWB_MIN_ACCEPTED_PRE_AWB_R2G_RATIO]
+	{0x0990, 0x3900, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xAC3D, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AWB_MAX_ACCEPTED_PRE_AWB_R2G_RATIO]
+	{0x0990, 0x6E00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xAC3E, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AWB_MIN_ACCEPTED_PRE_AWB_B2G_RATIO]
+	{0x0990, 0x2800, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xAC3F, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AWB_MAX_ACCEPTED_PRE_AWB_B2G_RATIO]
+	{0x0990, 0x6B00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBCDE, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_START_SYS_THRESHOLD]
+	{0x0990, 0x0400, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBCDF, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_STOP_SYS_THRESHOLD]
+	{0x0990, 0x1800, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBCE0, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_START_SYS_GAIN]
+	{0x0990, 0x0400, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBCE1, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_STOP_SYS_GAIN]
+	{0x0990, 0x0400, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xB801, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [STAT_MODE]
+	{0x0990, 0xE000, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xB862, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [STAT_BMTRACKING_SPEED]
+	{0x0990, 0x0400, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xB829, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [STAT_LL_BRIGHTNESS_METRIC_DIVISOR]
+	{0x0990, 0x1100, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xB863, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [STAT_BM_MUL]
+	{0x0990, 0x1700, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xB827, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [STAT_AE_EV_SHIFT]
+	{0x0990, 0x0E00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xA409, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AE_RULE_BASE_TARGET]
+	{0x0990, 0x3800, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x3C52, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_START_BRIGHTNESS_METRIC]
+	{0x0990, 0x00E0, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x3C54, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_END_BRIGHTNESS_METRIC]
+	{0x0990, 0x32B8, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x3C58, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_START_GAIN_METRIC]
+	{0x0990, 0x012C, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x3C5A, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_END_GAIN_METRIC]
+	{0x0990, 0x106C, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x3C5E, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_START_APERTURE_GAIN_BM]
+	{0x0990, 0x00FA, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x3C60, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_END_APERTURE_GAIN_BM]
+	{0x0990, 0x02B2, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x3C66, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_START_APERTURE_GM]
+	{0x0990, 0x00FA, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x3C68, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_END_APERTURE_GM]
+	{0x0990, 0x02B2, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x3C86, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_START_FFNR_GM]
+	{0x0990, 0x00C8, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x3C88, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_END_FFNR_GM]
+	{0x0990, 0x0658, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x3CBC, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_SFFB_START_GAIN]
+	{0x0990, 0x0040, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x3CBE, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_SFFB_END_GAIN]
+	{0x0990, 0x01FC, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x3CCC, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_SFFB_START_MAX_GM]
+	{0x0990, 0x00C8, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x3CCE, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_SFFB_END_MAX_GM]
+	{0x0990, 0x0633, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x3C90, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_START_GRB_GM]
+	{0x0990, 0x00C8, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x3C92, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_END_GRB_GM]
+	{0x0990, 0x0658, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x3C0E, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_CURVE_ADJ_START_POS]
+	{0x0990, 0x0001, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x3C10, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_CURVE_ADJ_MID_POS]
+	{0x0990, 0x0002, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x3C12, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_CURVE_ADJ_END_POS]
+	{0x0990, 0x02BC, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x3CAA, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_CDC_THR_ADJ_START_POS]
+	{0x0990, 0x32B8, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x3CAC, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_CDC_THR_ADJ_MID_POS]
+	{0x0990, 0x09B1, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x3CAE, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_CDC_THR_ADJ_END_POS]
+	{0x0990, 0x00E0, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x3CD8, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_PCR_START_BM]
+	{0x0990, 0x00E0, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x3CDA, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_PCR_END_BM]
+	{0x0990, 0x05DC, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC94, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GB_START_THRESHOLD_0]
+	{0x0990, 0x0600, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC95, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GB_START_THRESHOLD_1]
+	{0x0990, 0x0500, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC96, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GB_START_THRESHOLD_2]
+	{0x0990, 0x0600, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC97, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GB_START_THRESHOLD_3]
+	{0x0990, 0x0500, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC9C, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GB_END_THRESHOLD_0]
+	{0x0990, 0x0900, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC9D, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GB_END_THRESHOLD_1]
+	{0x0990, 0x0500, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC9E, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GB_END_THRESHOLD_2]
+	{0x0990, 0x0900, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC9F, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GB_END_THRESHOLD_3]
+	{0x0990, 0x0500, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x30B6, 0x0001, 0x1111},	  // AUTOLR_CONTROL
+	{0x33B0, 0x2A16, 0x1111},	  // FFNR_ALPHA_BETA
+	{0x098E, 0xBC8A, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_START_FF_MIX_THRESH_Y]
+	{0x0990, 0x2C00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC8B, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_END_FF_MIX_THRESH_Y]
+	{0x0990, 0xCF00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC8C, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_START_FF_MIX_THRESH_YGAIN]
+	{0x0990, 0x8B00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC8D, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_END_FF_MIX_THRESH_YGAIN]
+	{0x0990, 0xD700, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC8E, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_START_FF_MIX_THRESH_GAIN]
+	{0x0990, 0x7F00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC8F, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_END_FF_MIX_THRESH_GAIN]
+	{0x0990, 0x0000, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x33BA, 0x0086, 0x1111},	  // APEDGE_CONTROL
+	{0x33BE, 0x0000, 0x1111},	  // UA_KNEE_L
+	{0x33C2, 0x7300, 0x1111},	  // UA_WEIGHTS
+	{0x098E, 0xBC62, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_START_APERTURE_KPGAIN]
+	{0x0990, 0x1900, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC63, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_END_APERTURE_KPGAIN]
+	{0x0990, 0x1F00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC64, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_START_APERTURE_KNGAIN]
+	{0x0990, 0x1900, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC65, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_END_APERTURE_KNGAIN]
+	{0x0990, 0x1F00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC6A, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_START_APERTURE_INTEGER_GAIN]
+	{0x0990, 0x0400, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC6B, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_END_APERTURE_INTEGER_GAIN]
+	{0x0990, 0x0000, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC6C, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_START_APERTURE_EXP_GAIN]
+	{0x0990, 0x0000, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC6D, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_END_APERTURE_EXP_GAIN]
+	{0x0990, 0x0000, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x3284, 0x0000, 0x1111},	  // APERTURE_KNEE_VALUES
+	{0x3210, 0x49B0, 0x1111},	  // COLOR_PIPELINE_CONTROL
+	{0x098E, 0xBCC0, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_SFFB_RAMP_START]
+	{0x0990, 0x1F00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBCC1, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_SFFB_RAMP_STOP]
+	{0x0990, 0x0300, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBCC2, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_SFFB_SLOPE_START]
+	{0x0990, 0x1E00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBCC3, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_SFFB_SLOPE_STOP]
+	{0x0990, 0x0100, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBCC4, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_SFFB_THSTART]
+	{0x0990, 0x0A00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBCC5, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_SFFB_THSTOP]
+	{0x0990, 0x1F00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x3CBA, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_SFFB_CONFIG]
+	{0x0990, 0x0009, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x3CD0, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_SFFB_SOBEL_FLAT_START]
+	{0x0990, 0x000A, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x3CD2, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_SFFB_SOBEL_FLAT_STOP]
+	{0x0990, 0x00FE, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x3CD4, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_SFFB_SOBEL_SHARP_START]
+	{0x0990, 0x001E, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x3CD6, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_SFFB_SOBEL_SHARP_STOP]
+	{0x0990, 0x00FF, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBCC6, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_SFFB_SHARPENING_START]
+	{0x0990, 0x0000, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBCC7, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_SFFB_SHARPENING_STOP]
+	{0x0990, 0x0000, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBCC8, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_SFFB_FLATNESS_START]
+	{0x0990, 0x2000, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBCC9, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_SFFB_FLATNESS_STOP]
+	{0x0990, 0x4000, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBCCA, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_SFFB_TRANSITION_START]
+	{0x0990, 0x0400, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBCCB, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_SFFB_TRANSITION_STOP]
+	{0x0990, 0x0000, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC18, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_CONTRAST_CURVE_0]
+	{0x0990, 0x0000, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC19, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_CONTRAST_CURVE_1]
+	{0x0990, 0x1100, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC1A, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_CONTRAST_CURVE_2]
+	{0x0990, 0x2300, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC1B, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_CONTRAST_CURVE_3]
+	{0x0990, 0x3F00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC1C, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_CONTRAST_CURVE_4]
+	{0x0990, 0x6700, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC1D, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_CONTRAST_CURVE_5]
+	{0x0990, 0x8500, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC1E, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_CONTRAST_CURVE_6]
+	{0x0990, 0x9B00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC1F, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_CONTRAST_CURVE_7]
+	{0x0990, 0xAD00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC20, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_CONTRAST_CURVE_8]
+	{0x0990, 0xBB00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC21, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_CONTRAST_CURVE_9]
+	{0x0990, 0xC700, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC22, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_CONTRAST_CURVE_10]
+	{0x0990, 0xD100, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC23, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_CONTRAST_CURVE_11]
+	{0x0990, 0xDA00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC24, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_CONTRAST_CURVE_12]
+	{0x0990, 0xE100, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC25, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_CONTRAST_CURVE_13]
+	{0x0990, 0xE800, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC26, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_CONTRAST_CURVE_14]
+	{0x0990, 0xEE00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC27, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_CONTRAST_CURVE_15]
+	{0x0990, 0xF300, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC28, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_CONTRAST_CURVE_16]
+	{0x0990, 0xF700, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC29, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_CONTRAST_CURVE_17]
+	{0x0990, 0xFB00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC2A, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_CONTRAST_CURVE_18]
+	{0x0990, 0xFF00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC2B, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NEUTRAL_CURVE_0]
+	{0x0990, 0x0000, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC2C, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NEUTRAL_CURVE_1]
+	{0x0990, 0x1100, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC2D, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NEUTRAL_CURVE_2]
+	{0x0990, 0x2300, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC2E, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NEUTRAL_CURVE_3]
+	{0x0990, 0x3F00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC2F, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NEUTRAL_CURVE_4]
+	{0x0990, 0x6700, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC30, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NEUTRAL_CURVE_5]
+	{0x0990, 0x8500, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC31, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NEUTRAL_CURVE_6]
+	{0x0990, 0x9B00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC32, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NEUTRAL_CURVE_7]
+	{0x0990, 0xAD00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC33, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NEUTRAL_CURVE_8]
+	{0x0990, 0xBB00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC34, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NEUTRAL_CURVE_9]
+	{0x0990, 0xC700, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC35, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NEUTRAL_CURVE_10]
+	{0x0990, 0xD100, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC36, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NEUTRAL_CURVE_11]
+	{0x0990, 0xDA00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC37, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NEUTRAL_CURVE_12]
+	{0x0990, 0xE100, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC38, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NEUTRAL_CURVE_13]
+	{0x0990, 0xE800, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC39, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NEUTRAL_CURVE_14]
+	{0x0990, 0xEE00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC3A, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NEUTRAL_CURVE_15]
+	{0x0990, 0xF300, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC3B, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NEUTRAL_CURVE_16]
+	{0x0990, 0xF700, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC3C, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NEUTRAL_CURVE_17]
+	{0x0990, 0xFB00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC3D, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NEUTRAL_CURVE_18]
+	{0x0990, 0xFF00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC3E, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NR_CURVE_0]
+	{0x0990, 0x0000, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC3F, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NR_CURVE_1]
+	{0x0990, 0x1800, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC40, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NR_CURVE_2]
+	{0x0990, 0x2500, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC41, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NR_CURVE_3]
+	{0x0990, 0x3A00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC42, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NR_CURVE_4]
+	{0x0990, 0x5900, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC43, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NR_CURVE_5]
+	{0x0990, 0x7000, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC44, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NR_CURVE_6]
+	{0x0990, 0x8100, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC45, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NR_CURVE_7]
+	{0x0990, 0x9000, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC46, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NR_CURVE_8]
+	{0x0990, 0x9E00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC47, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NR_CURVE_9]
+	{0x0990, 0xAB00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC48, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NR_CURVE_10]
+	{0x0990, 0xB600, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC49, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NR_CURVE_11]
+	{0x0990, 0xC100, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC4A, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NR_CURVE_12]
+	{0x0990, 0xCB00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC4B, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NR_CURVE_13]
+	{0x0990, 0xD500, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC4C, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NR_CURVE_14]
+	{0x0990, 0xDE00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC4D, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NR_CURVE_15]
+	{0x0990, 0xE700, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC4E, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NR_CURVE_16]
+	{0x0990, 0xEF00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC4F, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NR_CURVE_17]
+	{0x0990, 0xF700, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xBC50, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_NR_CURVE_18]
+	{0x0990, 0xFF00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x8404, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [SEQ_CMD]
+	{0x0990, 0x0600, 0x1111},	  // MCU_VARIABLE_DATA0
+
+	{REG_TERM, 0x0050, 0x1111}, //delay 80ms
+
+//PART 3
+	{0x098E, 0x3C14, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_FADE_TO_BLACK_START_POS]
+	{0x0990, 0xFFFE, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x3C16, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [LL_GAMMA_FADE_TO_BLACK_END_POS]
+	{0x0990, 0xFFFF, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x31E0, 0x0003, 0x1111},	  // PIX_DEF_ID
+	{0x098E, 0x281C, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AE_TRACK_MIN_AGAIN]
+	{0x0990, 0x0040, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2820, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AE_TRACK_MAX_AGAIN]
+	{0x0990, 0x01FC, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2822, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AE_TRACK_MIN_DGAIN]
+	{0x0990, 0x0080, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2824, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AE_TRACK_MAX_DGAIN]
+	{0x0990, 0x0100, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x8404, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [SEQ_CMD]
+	{0x0990, 0x0600, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x0018, 0x2008, 0x1111},	  // STANDBY_CONTROL_AND_STATUS
+	{0x098E, 0x483A, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_Y_ADDR_START]
+	{0x0990, 0x0106, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x483C, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_X_ADDR_START]
+	{0x0990, 0x0018, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x483E, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_Y_ADDR_END]
+	{0x0990, 0x06B7, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4840, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_X_ADDR_END]
+	{0x0990, 0x0A45, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4842, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_ROW_SPEED]
+	{0x0990, 0x0001, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4844, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_SKIP_X_CORE]
+	{0x0990, 0x0103, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4846, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_SKIP_Y_CORE]
+	{0x0990, 0x0103, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4848, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_SKIP_X_PIPE]
+	{0x0990, 0x0103, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x484A, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_SKIP_Y_PIPE]
+	{0x0990, 0x0103, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x484C, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_POWER_MODE]
+	{0x0990, 0x00F6, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x484E, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_BIN_MODE]
+	{0x0990, 0x0001, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xC850, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_ORIENTATION]
+	{0x0990, 0x0000, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xC851, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_PIXEL_ORDER]
+	{0x0990, 0x0000, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4852, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_FINE_CORRECTION]
+	{0x0990, 0x019C, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4854, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_FINE_ITMIN]
+	{0x0990, 0x0732, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4858, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_COARSE_ITMIN]
+	{0x0990, 0x0000, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x485A, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_COARSE_ITMAX_MARGIN]
+	{0x0990, 0x0001, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x485C, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_MIN_FRAME_LENGTH_LINES]
+	{0x0990, 0x03E8, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x485E, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_MAX_FRAME_LENGTH_LINES]
+	{0x0990, 0xFFFF, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4860, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_BASE_FRAME_LENGTH_LINES]
+	{0x0990, 0x03E8, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4862, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_MIN_LINE_LENGTH_PCLK]
+	{0x0990, 0x0F06, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4864, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_MAX_LINE_LENGTH_PCLK]
+	{0x0990, 0xFFFE, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4866, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_P4_5_6_DIVIDER]
+	{0x0990, 0x7F7C, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4868, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_FRAME_LENGTH_LINES]
+	{0x0990, 0x03E8, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x486A, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_LINE_LENGTH_PCK]
+	{0x0990, 0x0F06, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x486C, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_OUTPUT_SIZE_WIDTH]
+	{0x0990, 0x0518, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x486E, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_OUTPUT_SIZE_HEIGHT]
+	{0x0990, 0x02D8, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4870, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_RX_FIFO_TRIGGER_MARK]
+	{0x0990, 0x0014, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x48B8, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_OUTPUT_0_JPEG_CONTROL]
+	{0x0990, 0x0004, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x48AE, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_OUTPUT_0_OUTPUT_FORMAT]
+	{0x0990, 0x0001, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x48AA, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_OUTPUT_0_IMAGE_WIDTH]
+	{0x0990, 0x0500, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x48AC, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_OUTPUT_0_IMAGE_HEIGHT]
+	{0x0990, 0x02D0, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xA80A, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AE_TRACK_NUM_FRAMES_TO_SKIP]
+	{0x0990, 0x0200, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xA807, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AE_TRACK_JUMP_DIVISOR]
+	{0x0990, 0x0800, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xA409, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AE_RULE_BASE_TARGET]
+	{0x0990, 0x4000, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2010, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [FD_MIN_EXPECTED50HZ_FLICKER_PERIOD]
+	{0x0990, 0x0122, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2012, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [FD_MAX_EXPECTED50HZ_FLICKER_PERIOD]
+	{0x0990, 0x0118, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2014, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [FD_MIN_EXPECTED60HZ_FLICKER_PERIOD]
+	{0x0990, 0x00D2, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2016, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [FD_MAX_EXPECTED60HZ_FLICKER_PERIOD]
+	{0x0990, 0x0118, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2018, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [FD_EXPECTED50HZ_FLICKER_PERIOD_IN_CONTEXT_A]
+	{0x0990, 0x0133, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x201C, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [FD_EXPECTED60HZ_FLICKER_PERIOD_IN_CONTEXT_A]
+	{0x0990, 0x00FF, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2818, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AE_TRACK_TARGET_INT_TIME_ROWS]
+	{0x0990, 0x03E8, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x281A, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AE_TRACK_MAX_INT_TIME_ROWS]
+	{0x0990, 0x03E8, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2824, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AE_TRACK_MAX_DGAIN]
+	{0x0990, 0x0180, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xB829, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [STAT_LL_BRIGHTNESS_METRIC_DIVISOR]
+	{0x0990, 0x0A00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x8404, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [SEQ_CMD]
+	{0x0990, 0x0600, 0x1111},	  // MCU_VARIABLE_DATA0
+
+	{REG_TERM, 0x0050, 0x1111}, //delay 80ms
+
+//PART 4
+	{0x098E, 0x483A, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_Y_ADDR_START]
+	{0x0990, 0x0106, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x483C, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_X_ADDR_START]
+	{0x0990, 0x0018, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x483E, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_Y_ADDR_END]
+	{0x0990, 0x06B7, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4840, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_X_ADDR_END]
+	{0x0990, 0x0A45, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4842, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_ROW_SPEED]
+	{0x0990, 0x0001, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4844, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_SKIP_X_CORE]
+	{0x0990, 0x0103, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4846, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_SKIP_Y_CORE]
+	{0x0990, 0x0103, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4848, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_SKIP_X_PIPE]
+	{0x0990, 0x0103, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x484A, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_SKIP_Y_PIPE]
+	{0x0990, 0x0103, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x484C, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_POWER_MODE]
+	{0x0990, 0x00F6, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x484E, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_BIN_MODE]
+	{0x0990, 0x0001, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xC850, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_ORIENTATION]
+	{0x0990, 0x0000, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xC851, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_PIXEL_ORDER]
+	{0x0990, 0x0000, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4852, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_FINE_CORRECTION]
+	{0x0990, 0x019C, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4854, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_FINE_ITMIN]
+	{0x0990, 0x0732, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4858, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_COARSE_ITMIN]
+	{0x0990, 0x0000, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x485A, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_COARSE_ITMAX_MARGIN]
+	{0x0990, 0x0001, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x485C, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_MIN_FRAME_LENGTH_LINES]
+	{0x0990, 0x03E8, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x485E, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_MAX_FRAME_LENGTH_LINES]
+	{0x0990, 0xFFFF, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4860, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_BASE_FRAME_LENGTH_LINES]
+	{0x0990, 0x03E8, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4862, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_MIN_LINE_LENGTH_PCLK]
+	{0x0990, 0x0F06, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4864, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_MAX_LINE_LENGTH_PCLK]
+	{0x0990, 0xFFFE, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4866, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_P4_5_6_DIVIDER]
+	{0x0990, 0x7F7C, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4868, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_FRAME_LENGTH_LINES]
+	{0x0990, 0x03E8, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x486A, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_LINE_LENGTH_PCK]
+	{0x0990, 0x0F06, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x486C, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_OUTPUT_SIZE_WIDTH]
+	{0x0990, 0x0518, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x486E, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_OUTPUT_SIZE_HEIGHT]
+	{0x0990, 0x02D8, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x4870, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_RX_FIFO_TRIGGER_MARK]
+	{0x0990, 0x0014, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x48B8, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_OUTPUT_0_JPEG_CONTROL]
+	{0x0990, 0x0004, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x48AE, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_OUTPUT_0_OUTPUT_FORMAT]
+	{0x0990, 0x0001, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x48AA, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_OUTPUT_0_IMAGE_WIDTH]
+	{0x0990, 0x0500, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x48AC, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [CAM_OUTPUT_0_IMAGE_HEIGHT]
+	{0x0990, 0x02D0, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xA80A, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AE_TRACK_NUM_FRAMES_TO_SKIP]
+	{0x0990, 0x0200, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xA807, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AE_TRACK_JUMP_DIVISOR]
+	{0x0990, 0x0800, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xA409, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AE_RULE_BASE_TARGET]
+	{0x0990, 0x4000, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2010, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [FD_MIN_EXPECTED50HZ_FLICKER_PERIOD]
+	{0x0990, 0x0122, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2012, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [FD_MAX_EXPECTED50HZ_FLICKER_PERIOD]
+	{0x0990, 0x0118, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2014, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [FD_MIN_EXPECTED60HZ_FLICKER_PERIOD]
+	{0x0990, 0x00D2, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2016, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [FD_MAX_EXPECTED60HZ_FLICKER_PERIOD]
+	{0x0990, 0x0118, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2018, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [FD_EXPECTED50HZ_FLICKER_PERIOD_IN_CONTEXT_A]
+	{0x0990, 0x0133, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x201C, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [FD_EXPECTED60HZ_FLICKER_PERIOD_IN_CONTEXT_A]
+	{0x0990, 0x00FF, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2818, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AE_TRACK_TARGET_INT_TIME_ROWS]
+	{0x0990, 0x03E8, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x281A, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AE_TRACK_MAX_INT_TIME_ROWS]
+	{0x0990, 0x03E8, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x2824, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [AE_TRACK_MAX_DGAIN]
+	{0x0990, 0x0180, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0xB829, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [STAT_LL_BRIGHTNESS_METRIC_DIVISOR]
+	{0x0990, 0x0A00, 0x1111},	  // MCU_VARIABLE_DATA0
+	{0x098E, 0x8404, 0x1111},	  // LOGICAL_ADDRESS_ACCESS [SEQ_CMD]
+	{0x0990, 0x0600, 0x1111},	  // MCU_VARIABLE_DATA0
+
+	{REG_TERM, 0x0050, 0x1111}, //delay 80ms
+    {REG_TERM, VAL_TERM}
+};
+
+
+static struct sensor_reg sensor_preview[] = {
+	{ 0x098E,0x843C, 0x1111},//LOGICAL_ADDRESS_ACCESs[SEQ_STATE_CFG_5_MAX_FRAME_CNT]
+	{ 0x0990,0x0100, 0x1111}, //MCU_VARIABLE_DATA0
+	{ 0x098E,0x8404, 0x1111}, //LOGICAL_ADDRESS_ACCESS[SEQ_CMD]
+	{ 0x0990,0x0100, 0x1111}, //MCU_VARIABLE_DATA0
+	{ 0x0016, 0x0647, 0x1111},  // CLOCKS_CONTROL
+
+	{REG_TERM, 0x0080, 0x1111}, //delay 120ms
+
+	{0xC83A, 0x0106, 0x1111},
+	{0xC83E, 0x06B7, 0x1111},
+	{0xC858, 0x0000, 0x1111},
+	{0xC85C, 0x03E8, 0x1111},
+	{0xC860, 0x03E8, 0x1111},
+	{0xC866, 0x7F7C, 0x1111},
+	{0xC868, 0x03E8, 0x1111},
+	{0xC86E, 0x02D8, 0x1111},
+	{0xC8AA, 0x0500, 0x1111},
+	{0xC8AC, 0x02D0, 0x1111},
+	{0xA80A, 0x0002, 0x1111},
+	{0xA807, 0x0008, 0x1111},
+	{0xA409, 0x0040, 0x1111},
+	{0xA010, 0x0122, 0x1111},
+	{0xA012, 0x0118, 0x1111},
+	{0xA014, 0x00D2, 0x1111},
+	{0xA016, 0x0118, 0x1111},
+	{0xA018, 0x0133, 0x1111},
+	{0xA01C, 0x00FF, 0x1111},
+	{0xA81A, 0x03E8, 0x1111},
+	{0xA824, 0x0180, 0x1111},
+	{0xAC09, 0x0035, 0x1111},
+	{0xB829, 0x000A, 0x1111},
+	{0x8404, 0x0006, 0x1111},
+
+	{REG_TERM, 0x0080, 0x1111}, //delay 120ms
+
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_capture[] = {
+	{ 0x3CA2, 0x0007, 0x1111},   // TXC_PARAMETERS
+	{ 0x098E, 0x5820, 0x1111},   // LOGICAL_ADDRESS_ACCESS [JPEG_JPSS_CTRL_VAR]
+	{ 0x0990, 0x4510, 0x1111},   // MCU_VARIABLE_DATA0
+	{ 0x098E, 0x8404, 0x1111},   // LOGICAL_ADDRESS_ACCESS [SEQ_CMD]
+	{ 0x0990, 0x0600, 0x1111},   // MCU_VARIABLE_DATA0
+
+	{REG_TERM, 0x0080, 0x1111}, //delay 120ms
+
+	{ 0x098E,0x843C, 0x1111}, //LOGICAL_ADDRESS_ACCESS[SEQ_STATE_CFG_5_MAX_FRAME_CNT]
+	{ 0x0990,0xFF00, 0x1111}, //MCU_VARIABLE_DATA0
+	{ 0x098E,0x8404, 0x1111}, //LOGICAL_ADDRESS_ACCESS[SEQ_CMD]
+	{ 0x0990,0x0200, 0x1111}, //MCU_VARIABLE_DATA0
+
+	{REG_TERM, 0x0080, 0x1111}, //delay 120ms
+	
+    {REG_TERM, VAL_TERM}
+};
+
+ struct sensor_reg* sensor_reg_common[3] =
+{
+	sensor_common,
+	sensor_preview,
+	sensor_capture
+};
+
+static struct sensor_reg sensor_brightness_0[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_brightness_1[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_brightness_2[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_brightness_3[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_brightness_4[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_brightness[5] =
+{
+	sensor_brightness_0,
+	sensor_brightness_1,
+	sensor_brightness_2,
+	sensor_brightness_3,
+	sensor_brightness_4
+};
+
+
+static struct sensor_reg sensor_awb_auto[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_awb_daylight[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_awb_incandescent[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_awb_fluorescent[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_awb_cloudy[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_awb_sunset[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_awb[6] =
+{
+	sensor_awb_auto,
+	sensor_awb_daylight,
+	sensor_awb_incandescent,
+	sensor_awb_fluorescent,
+	sensor_awb_cloudy,
+	sensor_awb_sunset
+	
+};
+
+
+static struct sensor_reg sensor_iso_auto[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_iso_100[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_iso_200[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_iso_400[] = {
+	{REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_iso[4] =
+{
+	sensor_iso_auto,
+	sensor_iso_100,
+	sensor_iso_200,
+	sensor_iso_400
+};
+
+
+static struct sensor_reg sensor_effect_normal[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_effect_gray[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_effect_negative[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_effect_sepia[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_effect_sharpness[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_effect_sketch[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_effect[6] =
+{
+	sensor_effect_normal,
+	sensor_effect_gray,
+	sensor_effect_negative,
+	sensor_effect_sepia,
+	sensor_effect_sharpness,
+	sensor_effect_sketch,
+};
+
+
+static struct sensor_reg sensor_reg_flipnone[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_reg_hflip[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_reg_vflip[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_reg_hvflip[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_flip[4] =
+{
+	sensor_reg_flipnone,
+	sensor_reg_hflip,
+	sensor_reg_vflip,
+	sensor_reg_hvflip,
+};
+
+
+static struct sensor_reg sensor_secne_auto[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_secne_night[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_secne_landscape[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_secne_portrait[] = {
+	{REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_secne_sport[] = {
+	{REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_scene[5] =
+{
+	sensor_secne_auto,
+	sensor_secne_night,
+	sensor_secne_landscape,
+	sensor_secne_portrait,
+	sensor_secne_sport
+};
+
+static struct sensor_reg sensor_me_mtrix[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_me_center_weighted[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_me_spot[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_metering_exposure[3] =
+{
+	sensor_me_mtrix,
+	sensor_me_center_weighted,
+	sensor_me_spot,
+};
+
+static struct sensor_reg sensor_af_single[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_af_manual[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_af[2] =
+{
+	sensor_af_single,
+	sensor_af_manual,
+};
+#endif
+
Index: linux-2.6.29/drivers/media/video/tcccam/mt9p111_5mp.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/tcccam/mt9p111_5mp.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,64 @@
+/*
+ * drivers/media/video/tcccam/mt9p111_5mp.h
+ *
+ * Register definitions for the mv9317 CameraChip.
+ *
+ * Author: zzau (zzau@telechips.com)
+ *
+ * Copyright (C) 2008 Telechips, Inc.
+ *
+ * This file is licensed under the terms of the GNU General Public License 
+ * version 2. This program is licensed "as is" without any warranty of any 
+ * kind, whether express or implied.
+ */
+
+#ifndef MT9P111_H
+#define MT9P111_H
+
+/* The MV9317 I2C sensor chip has a fixed slave address of 0x5D. */
+#define SENSOR_I2C_ADDR		0x78
+
+#define REG_TERM 0x0000	/* terminating list entry for reg */
+#define VAL_TERM 0x0000	/* terminating list entry for val */
+#define VAL_END 0x1111	/* ending entry for val-list */
+
+// ZOOM Setting!!
+#define PRV_W			1280
+#define PRV_H			720
+#define PRV_ZOFFX		8
+#define PRV_ZOFFY		6
+
+#define CAP_W			2560
+#define CAP_H			1920
+#define CAP_ZOFFX		16
+#define CAP_ZOFFY		12
+
+#define CAM_2XMAX_ZOOM_STEP 	31
+#define CAM_CAPCHG_WIDTH  		1024
+
+
+struct sensor_reg {
+	unsigned short reg;
+	unsigned short val[20];
+};
+
+struct capture_size {
+	unsigned long width;
+	unsigned long height;
+};
+
+extern struct capture_size sensor_sizes[];
+
+extern struct sensor_reg* sensor_reg_common[];
+extern struct sensor_reg* sensor_reg_brightness[];
+extern struct sensor_reg* sensor_reg_awb[];
+extern struct sensor_reg* sensor_reg_iso[];
+extern struct sensor_reg* sensor_reg_effect[];
+extern struct sensor_reg* sensor_reg_flip[];
+extern struct sensor_reg* sensor_reg_scene[];
+extern struct sensor_reg* sensor_reg_metering_exposure[];
+extern struct sensor_reg* sensor_reg_af[];
+
+#endif /* MT9P111_H */
+
+
Index: linux-2.6.29/drivers/media/video/tcccam/mv9317_3mp.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/tcccam/mv9317_3mp.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,303 @@
+/*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*
+
+               CAMERA    API    M O D U L E
+
+                        EDIT HISTORY FOR MODULE
+
+when        who       what, where, why
+--------    ---       -------------------------------------------------------
+10/xx/08  Telechips   Created file.
+*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*/
+
+/*===========================================================================
+
+                           INCLUDE FILES FOR MODULE
+
+===========================================================================*/
+#include "sensor_if.h"
+
+#ifdef CONFIG_VIDEO_CAMERA_SENSOR_MV9317
+
+/* Array of image sizes supported by MV9317.  These must be ordered from 
+ * smallest image size to largest.
+ */
+struct capture_size sensor_sizes[] = {
+	{ 2048, 1536 },	/* QXGA */
+	{ 1600, 1200 },	/* UXGA */
+	{ 1280,  960 },	/* SXGA */
+	{ 1024,  768 },	/* XGA */
+	{  800,  600 },	/* SVGA */
+	{  640,  480 },	/* VGA */
+	{  320,  240 },	/* QVGA */
+	{  176,  144 },	/* QCIF */
+};
+
+
+/* register initialization tables for sensor */
+/* common sensor register initialization for all image sizes, pixel formats, 
+ * and frame rates
+ */
+static struct sensor_reg sensor_common[] = {
+	{0x07, 0x07},			//XGA
+    {REG_TERM, VAL_TERM}
+};
+
+
+static struct sensor_reg sensor_preview[] = {
+	{0x07, 0x07},			//XGA
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_capture[] = {
+	{0x07, 0x0c},			//QXGA
+    {REG_TERM, VAL_TERM}
+};
+
+ struct sensor_reg* sensor_reg_common[3] =
+{
+	sensor_common,
+	sensor_preview,
+	sensor_capture
+};
+
+static struct sensor_reg sensor_brightness_0[] = {
+	{0x10, 0x83},			//M2
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_brightness_1[] = {
+	{0x10, 0x81},			//M1
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_brightness_2[] = {
+	{0x10, 0x00},			//DEFAULT
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_brightness_3[] = {
+	{0x10, 0x01},			//P1
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_brightness_4[] = {
+	{0x10, 0x03},			//P2
+    {REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_brightness[5] =
+{
+	sensor_brightness_0,
+	sensor_brightness_1,
+	sensor_brightness_2,
+	sensor_brightness_3,
+	sensor_brightness_4
+};
+
+
+static struct sensor_reg sensor_awb_auto[] = {
+	{0x14, 0x80},
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_awb_daylight[] = {
+	{0x14, 0x01},			//Daylight
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_awb_incandescent[] = {
+	{0x14, 0x04},			//A(Incandescent)
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_awb_fluorescent[] = {
+	{0x14, 0x03},			//Cool White Fluorescent
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_awb_cloudy[] = {
+	{0x14, 0x06},			//Cloudy
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_awb_sunset[] = {
+	{0x14, 0x05},			//Horizon(sunset)
+    {REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_awb[6] =
+{
+	sensor_awb_auto,
+	sensor_awb_daylight,
+	sensor_awb_incandescent,
+	sensor_awb_fluorescent,
+	sensor_awb_cloudy,
+	sensor_awb_sunset
+	
+};
+
+
+static struct sensor_reg sensor_iso_auto[] = {
+	{0x0d, 0x00},			//auto
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_iso_100[] = {
+	{0x0d, 0x01},			//100
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_iso_200[] = {
+	{0x0d, 0x02},			//200
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_iso_400[] = {
+	{0x0d, 0x03},			//400
+	{REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_iso[4] =
+{
+	sensor_iso_auto,
+	sensor_iso_100,
+	sensor_iso_200,
+	sensor_iso_400
+};
+
+
+static struct sensor_reg sensor_effect_normal[] = {
+	{0x1f, 0x00},			//NORMAL
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_effect_gray[] = {
+	{0x1f, 0x40},			//BW
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_effect_negative[] = {
+	{0x1f, 0x20},			//NEG_POSITIVE
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_effect_sepia[] = {
+	{0x1f, 0x10},			//SEPHIA
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_effect_sharpness[] = {
+	{0x1f, 0x02},			//SHARPNESS
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_effect_sketch[] = {
+	{0x1f, 0x04},			//SKETCH
+    {REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_effect[6] =
+{
+	sensor_effect_normal,
+	sensor_effect_gray,
+	sensor_effect_negative,
+	sensor_effect_sepia,
+	sensor_effect_sharpness,
+	sensor_effect_sketch,
+};
+
+
+static struct sensor_reg sensor_reg_flipnone[] = {
+	{0x09, 0x00},			//NORMAL
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_reg_hflip[] = {
+	{0x09, 0x01},			//MIRROR
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_reg_vflip[] = {
+	{0x09, 0x02},			//FLIP
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_reg_hvflip[] = {
+	{0x09, 0x03},			//MIRROR_FLIP
+    {REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_flip[4] =
+{
+	sensor_reg_flipnone,
+	sensor_reg_hflip,
+	sensor_reg_vflip,
+	sensor_reg_hvflip,
+};
+
+
+static struct sensor_reg sensor_secne_auto[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_secne_night[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_secne_landscape[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_secne_portrait[] = {
+	{REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_secne_sport[] = {
+	{REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_scene[5] =
+{
+	sensor_secne_auto,
+	sensor_secne_night,
+	sensor_secne_landscape,
+	sensor_secne_portrait,
+	sensor_secne_sport
+};
+
+static struct sensor_reg sensor_me_mtrix[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_me_center_weighted[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_me_spot[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_metering_exposure[3] =
+{
+	sensor_me_mtrix,
+	sensor_me_center_weighted,
+	sensor_me_spot,
+};
+
+static struct sensor_reg sensor_af_single[] = {
+    {0x19, 0x00},	
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_af_manual[] = {
+    {0x1A, 0x20},
+    {REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_af[2] =
+{
+	sensor_af_single,
+	sensor_af_manual,
+};
+#endif
+
Index: linux-2.6.29/drivers/media/video/tcccam/mv9317_3mp.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/tcccam/mv9317_3mp.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,64 @@
+/*
+ * drivers/media/video/tcccam/mv9317_3mp.h
+ *
+ * Register definitions for the mv9317 CameraChip.
+ *
+ * Author: zzau (zzau@telechips.com)
+ *
+ * Copyright (C) 2008 Telechips, Inc.
+ *
+ * This file is licensed under the terms of the GNU General Public License 
+ * version 2. This program is licensed "as is" without any warranty of any 
+ * kind, whether express or implied.
+ */
+
+#ifndef MV9317_H
+#define MV9317_H
+
+/* The MV9317 I2C sensor chip has a fixed slave address of 0x5D. */
+#define SENSOR_I2C_ADDR		0x50
+
+#define REG_TERM 0xFF	/* terminating list entry for reg */
+#define VAL_TERM 0xFF	/* terminating list entry for val */
+
+
+// ZOOM Setting!!
+#define PRV_W			1024
+#define PRV_H			768
+#define PRV_ZOFFX		8
+#define PRV_ZOFFY		6
+
+#define CAP_W			2048
+#define CAP_H			1536
+#define CAP_ZOFFX		16
+#define CAP_ZOFFY		12
+
+#define CAM_2XMAX_ZOOM_STEP 	31
+#define CAM_CAPCHG_WIDTH  		1024
+
+
+struct sensor_reg {
+	unsigned char reg;
+	unsigned char val[1];
+};
+
+struct capture_size {
+	unsigned long width;
+	unsigned long height;
+};
+
+extern struct capture_size sensor_sizes[];
+
+extern struct sensor_reg* sensor_reg_common[];
+extern struct sensor_reg* sensor_reg_brightness[];
+extern struct sensor_reg* sensor_reg_awb[];
+extern struct sensor_reg* sensor_reg_iso[];
+extern struct sensor_reg* sensor_reg_effect[];
+extern struct sensor_reg* sensor_reg_flip[];
+extern struct sensor_reg* sensor_reg_scene[];
+extern struct sensor_reg* sensor_reg_metering_exposure[];
+extern struct sensor_reg* sensor_reg_af[];
+
+#endif /* MV9317_H */
+
+
Index: linux-2.6.29/drivers/media/video/tcccam/s5k4bafb_2mp.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/tcccam/s5k4bafb_2mp.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,2793 @@
+/*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*
+
+               CAMERA    API    M O D U L E
+
+                        EDIT HISTORY FOR MODULE
+
+when        who       what, where, why
+--------    ---       -------------------------------------------------------
+10/xx/08  Telechips   Created file.
+*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*/
+
+/*===========================================================================
+
+                           INCLUDE FILES FOR MODULE
+
+===========================================================================*/
+#include "sensor_if.h"
+
+#ifdef CONFIG_VIDEO_CAMERA_SENSOR_S5K4BAFB
+
+/* Array of image sizes supported by S5K4BAFB.  These must be ordered from 
+ * smallest image size to largest.
+ */
+struct capture_size sensor_sizes[] = {
+	{ 1600, 1200 },	/* UXGA */
+	{ 1280,  960 },	/* SXGA */
+	{ 1024,  768 },	/* XGA */
+	{  800,  600 },	/* SVGA */
+	{  640,  480 },	/* VGA */
+	{  320,  240 },	/* QVGA */
+	{  176,  144 },	/* QCIF */
+};
+
+
+/* register initialization tables for sensor */
+/* common sensor register initialization for all image sizes, pixel formats, 
+ * and frame rates
+ */
+static struct sensor_reg sensor_common[] = {
+#ifdef	TCC_VCORE_30FPS_CAMERASENSOR		// // LG, LX600/VX8560 Camera
+	//==========================================================
+	//  Name         :  for s5K4BAFB EVT1(UXGA 1-Chip)	 
+	//  Version      :  v2.0 UXGA				    
+	//  S/W version  :  s02				    
+	//  PLL mode     :  MCLK 24MHz PCLK 32MHz)		   
+	//  AGC gain     :  s66					    
+	//  FPS          :  UXGA 7.5fps				   
+	//  Date         :  2008.01.11				    
+	//==========================================================
+
+	//History
+	//Gamma_Lee 
+	//==========================================================
+	//	PLL SET 
+	//==========================================================
+	{0xfc,0x02},
+	{0x50,0x59}, // Mclk:25M, Pclk:36M  
+	{0x51,0x0a}, // s=1, p=25           
+	{0x52,0xD0}, // 31 fps,
+
+	//==========================================================
+	//	 CAMERA INITIAL 
+	//==========================================================
+	{0xfc,0x07},
+	{0x66,0x01}, // Watch dog timer [0:off  1:on]   
+	{0xfc,0x00},                                    
+	{0x00,0xAA}, // For EDS Check                   
+	{0x21,0x03},	                                   
+	{0xfc,0x01},                                    
+	{0x04,0x01}, // ARM Clock Divider                
+	{0xfc,0x07},                                    
+	{0x05,0x00}, // AE initial_HH                   
+	{0x06,0x00}, // AE initial_HL                   
+	{0x07,0x8b}, // AE initial_LH                   
+	{0x08,0xf5}, // AE initial_LL                   
+	{0x09,0x00},                                    
+	{0x0a,0xb4}, // Rgain initial point             
+	{0x0b,0x00},                                    
+	{0x0c,0xea}, // Bgain initial point             
+	{0x0d,0x00},                                    
+	{0x0e,0x40}, // Ggain initial point             
+	{0xfc,0x00},                                                   
+	{0x70,0x02}, // Initial uploading               
+
+	//==========================================================
+	//	 Analog setting
+	//==========================================================
+	{0xfc,0x02},	      
+	{0x55,0x1E}, // LineADLC on(s551a) off(s550a)        
+	{0x56,0x10}, // BPR 16code                            
+	{0x30,0x82}, // Analog offset (capture =?h)          
+	{0x37,0x11}, //17	// Global Gain (default:31)             
+	{0x57,0x80}, // LineADLC Roffset               
+	{0x58,0x80}, // LineADLC Goffset           
+	{0x59,0x80}, // LineADLC offset don't care  
+	{0x44,0x64}, // clamp en[6]=1 on                      
+	{0x4a,0x40}, // clamp level 0011h [7]~[4]              
+	{0x2d,0x48}, // double shutter (default:00)          
+	{0x4D,0x08}, // Voltage doubler (default:04)          
+	{0x4e,0x1a}, // IO current 8mA set                   
+	{0x4f,0xba}, // IO current 48mA set                  
+	{0x66,0x41}, // 1st comp current 2uA                  
+	{0x43,0xEF}, // ec_comp                               
+	{0x62,0x60}, // LD control  CFPN_EN off              
+	{0xfc,0x20},     
+	{0x09,0x03}, // onejump delay for AE haunting    
+
+	//==========================================================//
+	//	 COMMAND SET                                         //
+	//==========================================================//
+	{0xfc,0x00},
+	{0x20,0x02}, // Change AWB Mode
+	{0x29,0x03}, // Y level   
+	{0x2a,0xd0}, //ec}, //	
+	{0x2b,0x04}, // C level   
+	{0x2c,0x00}, //
+	{0x62,0x02}, // Hue Control Enable
+	{0x6c,0xc0}, // AE target, revised for Flicker 
+	{0x6d,0x00}, 
+//	{0x73,0x11}, // Frmae AE Enable	 , frame rate control, VFR
+    {0x73,0x10}, // Frmae AE Enable	 , frame rate control, CFR
+	{0x78,0x66}, // AGC Max 
+	{0xfc,0x20}, 
+	{0x16,0x5a}, // AGC frame AE start _for Prevating AE Hunting 
+	{0x57,0x18}, // Stable_Frame_AE      
+	{0xfc,0x00}, 
+	{0x83,0x06}, // low condition shutter off  Double shutter off 
+	             
+	{0xfc,0x0b}, 
+	{0x5c,0x65}, // AGC value to start shutter on/off suppress 
+	{0x5d,0x65}, // AGC value to start double shutter on/off suppress                              
+	{0xfc,0x20},  
+	{0x25,0x00}, // CINTR Min         
+	{0x2a,0x01}, // forbidden          
+	{0x2b,0x02}, // For Forbidden Area 
+	{0x2c,0x0a}, 
+	{0x2d,0x00}, // For Forbidden Area  
+	{0x2e,0x00}, 
+	{0x2f,0x05}, // forbidden   
+	{0x14,0x80}, // Brightness offset
+	{0x01,0x00}, // Stepless_Off   
+	{0x02,0x02}, // Flicker Dgain Mode     
+	             
+	{0xfc,0x07}, 
+	{0x37,0x08}, // Flicker setting 	             
+	{0xfc,0x00}, 
+	{0x72,0xac}, // Flicker for 36MHz Revised for Flicker
+	{0x74,0x08}, // flicker 60Hz    
+	             
+	{0xfc,0x01}, 
+	{0x0c,0x02}, // Full YC Enable   
+	             
+	//==========================================================   
+	//	 Table Set for Sub-Sampling                          
+	//==========================================================  
+	{0xfc,0x03},
+	{0x00,0x06},
+	{0x01,0xe2},
+	{0x05,0x46},
+	{0x07,0xb6},
+	{0x0e,0x04},
+	{0x12,0x03},
+	{0x2c,0x00},
+
+	{0xfc,0x03},
+	{0x3d,0x00}, // POST_HSTART_H
+	{0x3e,0x02}, // POST_HSTART_L
+	{0x3f,0x06}, // POST_HWIDTH_H
+	{0x40,0x40}, // POST_HWIDTH_L
+	{0x41,0x00}, // POST_VSTART_H
+	{0x42,0x02}, // POST_VSTART_L
+	{0x43,0x04}, // POST_VHEIGHT_H
+	{0x44,0xb0}, // POST_VHEIGHT_L
+	{0x45,0x06}, // IMG_HSIZEH
+	{0x46,0x40}, // IMG_HSIZEL
+	{0x47,0x04}, // IMG_VSIZEH
+	{0x48,0xb0}, // IMG_VSIZEL
+	{0x49,0x00}, // PSF
+	{0x4a,0x40}, // MSFXH
+	{0x4b,0x00}, // MSFXL
+	{0x4c,0x40}, // MSFYH
+	{0x4d,0x00}, // MSFYL
+	{0x4e,0x05}, // DW_HSIZEH
+	{0x4f,0x00}, // DW_HSIZEL
+	{0x50,0x03}, // DW_VSIZEH
+	{0x51,0xc0}, // DW_VSIZEL
+	{0x52,0x00}, // STARTXH
+	{0x53,0x00}, // STARTXL
+	{0x54,0x00}, // STARTYH
+	{0x55,0x00}, // STARTYL
+	{0x56,0x05}, // CLIP_HSIZEH
+	{0x57,0x00}, // CLIP_HSIZEL
+	{0x58,0x03}, // CLIP_VSIZEH
+	{0x59,0xc0}, // CLIP_VSIZEL
+	{0x5a,0x00}, // SEL_MAIN
+	{0x5b,0x00}, // HTERMH
+	{0x5c,0x08}, // HTERMM
+	{0x5d,0x9c}, // HTERML
+
+	{0xfc,0x04},
+	{0xc0,0x05}, //04}, //05 
+	{0xc1,0x40}, 
+	{0xc2,0x02}, 
+	{0xc3,0x87}, 
+	{0xc4,0x03}, 
+	{0xc5,0x26}, 
+	{0xc6,0x02}, 
+	{0xc7,0x5c}, 
+	{0xc8,0x01}, 
+	{0xc9,0x03}, 
+	{0xca,0x01}, 
+	{0xcb,0x03}, 
+	{0xcc,0x08},
+	{0xce,0x01},
+	{0xd2,0x01},
+
+	{0xfc,0x03},  //snap shot: YCbCr order
+	{0x2e,0x01},	
+	{0x5e,0x00},
+	{0x8e,0x00},
+	{0xbe,0x00},
+	{0xee,0x00},
+
+	{0xfc,0x04},  //preview : YCbCr order
+	{0x2e,0x01},
+	{0x5e,0x01},
+	{0x8e,0x01},
+	{0xbe,0x01},
+	{0xee,0x00},  
+
+	//==========================================================
+	//	 COLOR MATRIX                                        
+	//==========================================================
+	{0xfc,0x01},		
+	{0x51,0x07},			
+	{0x52,0x40},			
+	{0x53,0xfc},			
+	{0x54,0x80},			
+	{0x55,0x00},			
+	{0x56,0x3f},			
+	{0x57,0xfe},			
+	{0x58,0x7f},			
+	{0x59,0x06},			
+	{0x5A,0x6a},			
+	{0x5B,0xff},			
+	{0x5C,0x18},			
+	{0x5D,0xff},			
+	{0x5E,0xd7},			
+	{0x5F,0xfd},			
+	{0x60,0x1c},			
+	{0x61,0x07},			
+	{0x62,0x0d},			               
+
+	//==========================================================
+	//	 EDGE ENHANCEMENT                                       
+	//==========================================================
+	{0xfc,0x0b}, //KF310
+	{0x42,0x50}, //50 //50},   // Edge AGC MIN              
+	{0x43,0x60}, //60 //60},   // Edge AGC MAX           
+	{0x45,0x0a}, //04 //0a},   //24  // positive gain AGC MIN 
+	{0x49,0x06}, //0a //06},   // positive gain AGC MAX  
+	{0x4d,0x09}, //10 //0a},   //24  // negative gain AGC MIN  
+	{0x51,0x06}, //0a //06},   // negative gain AGC MAX  
+	{0xfc,0x05}, //05 
+	{0x33,0x08}, //08  // APTCLP  
+	{0x34,0x38}, //40 //38},  //24  // APTCLP  
+	{0x35,0x0a}, //08 //08},  //04  // APTSC   
+	{0x36,0x1a}, //1f //1f},  //0b  // ENHANCE 
+	{0x3f,0x00}, //00  // NON-LIN 
+	{0x42,0x10}, //10  // EGFALL  
+	{0x43,0x00}, //00  // HLFALL  
+	{0x45,0xa0}, //a0  // EGREF   
+	{0x46,0x7a}, //7a  // HLREF   
+	{0x47,0x40}, //40  // LLREF   
+	{0x48,0x0c}, //0c    
+	{0x49,0x31}, //31  // CSSEL  EGSEL  CS_DLY 
+	{0x40,0x41}, //41  // Y delay  
+
+	//========================================================== 
+	//	 NEW EDGE ENHANCEMENT                                       
+	//========================================================== 	
+	{0xfc,0x1d},		
+	{0x86,0x02},		
+	{0x87,0xc0},		
+	{0x88,0x03},		
+	{0x89,0xc0},		
+	{0x8a,0x02},		
+	{0x8b,0x00},		
+	{0x8c,0x00},		
+	{0x8d,0x00},		
+	{0x8e,0x00},		
+	{0x8f,0xd0},		
+	{0x90,0x00},		
+	{0x91,0x00},		
+	{0x92,0x02},		
+	{0x93,0x00},		
+	{0x94,0x00},		
+	{0x95,0x00},		
+	{0x96,0x00},		
+	{0x97,0xd0},		
+	{0x98,0x00},		
+	{0x99,0x00},		
+	{0x9a,0x02},		
+	{0x9b,0x60},		
+	{0x9c,0x00},		
+	{0x9d,0x00},		
+	{0x9e,0x02},		
+	{0x9f,0x60},		
+	{0xa0,0x00},		
+	{0xa1,0x00},		
+	{0xa2,0x09},		
+	{0x85,0x01},  // EE_Wide_Luma ON/OFF 1:ON, 0:OFF
+	{0xfc,0x00},
+	{0x89,0x03},  // Edge negative/positive suppress ON
+
+	//========================================================== 
+	//	 GAMMA                                                
+	//==========================================================                  
+	{0xfc,0x1d},
+	{0x00,0x05},  
+	{0x01,0x0a},  
+	{0x02,0x33},  
+	{0x03,0xbd},  
+	{0x04,0x00},  
+	{0x05,0x33},  
+	{0x06,0x8f},  
+	{0x07,0xdc},  
+	{0x08,0x15},  
+	{0x09,0x56},  
+	{0x0a,0x38},  
+	{0x0b,0x57},  
+	{0x0c,0x74},  
+	{0x0d,0x8f},  
+	{0x0e,0xaa},  
+	{0x0f,0xa9},  
+	{0x10,0xc2},  
+	{0x11,0xdb},  
+	{0x12,0xf3},  
+	{0x13,0xaa},  
+	{0x14,0x0a},  
+	{0x15,0x22},  
+	{0x16,0x3d},  
+	{0x17,0x57},  
+	{0x18,0xff},  
+	{0x19,0x6b},  
+	{0x1a,0x7a},  
+	{0x1b,0x8f},  
+	{0x1c,0x9e},  
+	{0x1d,0xff},  
+	{0x1e,0xa8},  
+	{0x1f,0xb8},  
+	{0x20,0xc3},  
+	{0x21,0xd3},  
+	{0x22,0xff},  
+	{0x23,0xe0},  
+	{0x24,0xeb},  
+	{0x25,0xf2},  
+	{0x26,0xf8},  
+	{0x27,0xff},  
+	{0x28,0xfc},  
+	{0x29,0xff},  
+	{0x2a,0xf0},  
+	{0x2b,0x00},  
+	{0x2c,0x0a},  
+	{0x2d,0x33},  
+	{0x2e,0xbd},  
+	{0x2f,0x00},  
+	{0x30,0x33},  
+	{0x31,0x8f},  
+	{0x32,0xdc},  
+	{0x33,0x15},  
+	{0x34,0x56},  
+	{0x35,0x38},  
+	{0x36,0x57},  
+	{0x37,0x74},  
+	{0x38,0x8f},  
+	{0x39,0xaa},  
+	{0x3a,0xa9},  
+	{0x3b,0xc2},  
+	{0x3c,0xdb},  
+	{0x3d,0xf3},  
+	{0x3e,0xaa},  
+	{0x3f,0x0a},  
+	{0x40,0x22},  
+	{0x41,0x3d},  
+	{0x42,0x57},  
+	{0x43,0xff},  
+	{0x44,0x6b},  
+	{0x45,0x7a},  
+	{0x46,0x8f},  
+	{0x47,0x9e},  
+	{0x48,0xff},  
+	{0x49,0xa8},  
+	{0x4a,0xb8},  
+	{0x4b,0xc3},  
+	{0x4c,0xd3},  
+	{0x4d,0xff},  
+	{0x4e,0xe0},  
+	{0x4f,0xeb},  
+	{0x50,0xf2},  
+	{0x51,0xf8},  
+	{0x52,0xff},  
+	{0x53,0xfc},  
+	{0x54,0xff},  
+	{0x55,0xf0},  
+	{0x56,0x00},  
+	{0x57,0x0a},  
+	{0x58,0x33},  
+	{0x59,0xbd},  
+	{0x5a,0x00},  
+	{0x5b,0x33},  
+	{0x5c,0x8f},  
+	{0x5d,0xdc},  
+	{0x5e,0x15},  
+	{0x5f,0x56},  
+	{0x60,0x38},  
+	{0x61,0x57},  
+	{0x62,0x74},  
+	{0x63,0x8f},  
+	{0x64,0xaa},  
+	{0x65,0xa9},  
+	{0x66,0xc2},  
+	{0x67,0xdb},  
+	{0x68,0xf3},  
+	{0x69,0xaa},  
+	{0x6a,0x0a},  
+	{0x6b,0x22},  
+	{0x6c,0x3d},  
+	{0x6d,0x57},  
+	{0x6e,0xff},  
+	{0x6f,0x6b},  
+	{0x70,0x7a},  
+	{0x71,0x8f},  
+	{0x72,0x9e},  
+	{0x73,0xff},  
+	{0x74,0xa8},  
+	{0x75,0xb8},  
+	{0x76,0xc3},  
+	{0x77,0xd3},  
+	{0x78,0xff},  
+	{0x79,0xe0},  
+	{0x7a,0xeb},  
+	{0x7b,0xf2},  
+	{0x7c,0xf8},  
+	{0x7d,0xff},  
+	{0x7e,0xfc},  
+	{0x7f,0xff},  
+	{0x80,0xf0},                
+
+	//==========================================================    
+	//   HUE CONTROL                                          
+	//========================================================== 
+	{0xfc,0x00},                               
+	{0x48,0x40},	 // 2000K 
+	{0x49,0x40}, 
+	{0x4a,0xF0}, 
+	{0x4b,0x00}, 
+	{0x4c,0x40}, 
+	{0x4d,0x40}, 
+	{0x4e,0x00}, 
+	{0x4f,0x00}, 
+	             
+	{0x50,0x48}, 	 // 3000K          
+	{0x51,0x3e}, 	
+	{0x52,0xf6}, 	
+	{0x53,0x00}, 	
+	{0x54,0x40}, 	
+	{0x55,0x40},                    
+	{0x56,0x00}, 	                   
+	{0x57,0xf0},    
+
+	{0x58,0x35}, //36}, //3a}, //3d}, //40},   // 5000K          
+	{0x59,0x4a}, //40},//3a},//37}, //35},          
+	{0x5a,0xfc},	
+	{0x5b,0x00}, 
+	{0x5c,0x40}, 
+	{0x5d,0x3a}, 
+	{0x5e,0x00},          
+	{0x5f,0x08},//00}, //f8},//f4}, //f0},                                
+
+	//========================================================== //   
+	//	SUPPRESS FUNCTION                                    //
+	//========================================================== //
+	{0xfc,0x00},	    
+	{0x7e,0xf4},                                                            
+
+	//========================================================== //   
+	//	 BPR                                                  // 
+	//========================================================== // 
+	{0xfc,0x01},         
+	{0x3d,0x10},             
+	{0xfc,0x0b},   
+	{0x0b,0x00},	// ISP BPR On Start                  
+	{0x0c,0x40},	// Th13 AGC Min                     
+	{0x0d,0x5a},	// Th13 AGC Max                     
+	{0x0e,0x00},	// Th1 Max H for AGCMIN             
+	{0x0f,0x15},	// 0822 semi Th1 Max L for AGCMIN    
+	{0x10,0x00},	// Th1 Min H for AGCMAX             
+	{0x11,0x20},	// 0822 semi Th1 Min L for AGCMAX   
+	{0x12,0x00},	// Th3 Max H for AGCMIN             
+	{0x13,0x7f},	// Th3 Max L for AGCMIN             
+	{0x14,0x03},	// Th3 Min H for AGCMAX             
+	{0x15,0xff},	// Th3 Min L for AGCMAX             
+	{0x16,0x48},	// Th57 AGC Min                     
+	{0x17,0x60},	// Th57 AGC Max                     
+	{0x18,0x00},	// Th5 Max H for AGCMIN             
+	{0x19,0x00},	// Th5 Max L for AGCMIN             
+	{0x1a,0x00},	// Th5 Min H for AGCMAX             
+	{0x1b,0x20},	// Th5 Min L for AGCMAX             
+	{0x1c,0x00},	// Th7 Max H for AGCMIN             
+	{0x1d,0x00},	// Th7 Max L for AGCMIN             
+	{0x1e,0x00},	// Th7 Min H for AGCMAX             
+	{0x1f,0x20},	// Th7 Min L for AGCMAX 	                           
+
+	//========================================================== // 	  
+	//	 GR/GB CORRECTION                                     // 
+	//========================================================== //
+	{0xfc,0x01}, 
+	{0x45,0x0c},   	                       
+	{0xfc,0x0b},                                  
+	{0x21,0x00},	// Start AGC                   
+	{0x22,0x05},	// AGCMIN                      
+	{0x23,0x33},	// AGCMAX                      
+	{0x24,0x0a},	// G Th AGCMIN                 
+	{0x25,0x25},	// G Th AGCMAX                 
+	{0x26,0x0a},	// RB Th AGCMIN                
+	{0x27,0x25},	// RB Th AGCMAX                             
+
+	//==========================================================//   
+	//	 NR                                                  //   
+	//==========================================================// 
+	{0xfc,0x01},   
+	{0x4C,0x01},	// NR Enable   
+	{0x49,0x15},	// Sig_Th Mult 
+	{0x4B,0x0A},	// Pre_Th Mult 
+
+	{0xfc,0x0b},                              
+	{0x28,0x00},	// NR start AGC	                           
+	{0x29,0x00},	// SIG Th AGCMIN H       
+	{0x2a,0x14},	// SIG Th AGCMIN L       
+	{0x2b,0x00},	// SIG Th AGCMAX H       
+	{0x2c,0x14},	// SIG Th AGCMAX L       
+	{0x2d,0x00},	// PRE Th AGCMIN H       
+	{0x2e,0xc0},	// PRE Th AGCMIN L     
+	{0x2f,0x01},	// PRE Th AGCMAX H   
+	{0x30,0x00},	// PRE Th AGCMAX L   
+	{0x31,0x00},	// POST Th AGCMIN H      
+	{0x32,0xd0},	// POST Th AGCMIN L   
+	{0x33,0x01},	// POST Th AGCMAX H      
+	{0x34,0x10},	// POST Th AGCMAX L                 
+
+	//========================================================== //
+	//	 1D-Y/C-SIGMA-LPF                                     //
+	//========================================================== //
+	{0xfc,0x01},                             
+	{0x05,0xC0}, 
+
+	{0xfc,0x0b},                             
+	{0x35,0x00},	// YLPF start AGC         
+	{0x36,0x20},	// YLPF01 AGCMIN          
+	{0x37,0x50},	// YLPF01 AGCMAX          
+	{0x38,0x00},	// YLPF SIG01 Th AGCMINH  
+	{0x39,0x18},	// YLPF SIG01 Th AGCMINL   
+	{0x3a,0x00},	// YLPF SIG01 Th AGCMAXH   
+	{0x3b,0x40},	// YLPF SIG01 Th AGCMAXH               
+	{0x3c,0x20},	// YLPF02 AGCMIN                   
+	{0x3d,0x50},	// YLPF02 AGCMAX                   
+	{0x3e,0x00},	// YLPF SIG02 Th AGCMINH   
+	{0x3f,0x30},	// YLPF SIG02 Th AGCMINL   
+	{0x40,0x00},	// YLPF SIG02 Th AGCMAXH   
+	{0x41,0x40},	// YLPF SIG02 Th AGCMAXH   
+	{0xd4,0x20},	// CLPF AGCMIN            
+	{0xd5,0x50},	// CLPF AGCMAX            
+	{0xd6,0xb0},	// CLPF SIG01 Th AGCMIN   
+	{0xd7,0xf0},	// CLPF SIG01 Th AGCMAX   
+	{0xd8,0xb0},	// CLPF SIG02 Th AGCMIN   
+	{0xd9,0xf0},	// CLPF SIG02 Th AGCMAX                            
+
+	//==========================================================  //
+	//	COLOR SUPPRESS                                        //
+	//==========================================================  //
+	{0xfc,0x0b},	// COLOR SUPPRESS         
+	{0x08,0x58},	// Color suppress AGC MIN 
+	{0x09,0x04},	// Color suppress MIN H   
+	{0x0a,0x00},	// Color suppress MIN L                            
+
+	//==========================================================  //
+	//	 SHADING                                               //
+	//==========================================================  //
+	{0xfc,0x09},
+	//Shading file for 3BAFX
+	//90000  // shading off
+	// DSP9_SH_WIDTH_H 
+	{0x01,0x06},
+	{0x02,0x40},
+	// DSP9_SH_HEIGHT_H 
+	{0x03,0x04},
+	{0x04,0xB0},
+	// DSP9_SH_XCH_R 
+	{0x05,0x03},
+	{0x06,0x20},
+	{0x07,0x02},
+	{0x08,0xa5},
+	// DSP9_SH_XCH_G 
+	{0x09,0x03},
+	{0x0A,0x2a},
+	{0x0B,0x02},
+	{0x0C,0x78},
+	// DSP9_SH_XCH_B 
+	{0x0D,0x02},
+	{0x0E,0xF9},
+	{0x0F,0x02},
+	{0x10,0x58},
+	// DSP9_SH_Del_eH_R 
+	{0x1D,0x80},
+	{0x1E,0x00},
+	{0x1F,0x80},
+	{0x20,0x00},
+	{0x23,0x79},
+	{0x24,0xE6},
+	{0x21,0x82},
+	{0x22,0x9A},
+	// DSP9_SH_Del_eH_G 
+	{0x25,0x80},
+	{0x26,0x00},
+	{0x27,0x80},
+	{0x28,0x00},
+	{0x2B,0x79},
+	{0x2C,0xE6},
+	{0x29,0x86},
+	{0x2A,0xBC},
+	// DSP9_SH_Del_eH_B 
+	{0x2D,0x79},
+	{0x2E,0xE6},
+	{0x2F,0x78},
+	{0x30,0xBE},
+	{0x33,0x80},
+	{0x34,0x00},
+	{0x31,0x80},
+	{0x32,0x00},
+	//, DSP9_SH_VAL_R0H 
+	{0x35,0x01},
+	{0x36,0x00},
+	{0x37,0x01},
+	{0x38,0x10},
+	{0x39,0x01},
+	{0x3A,0x35},
+	{0x3B,0x01},
+	{0x3C,0x68},
+	{0x3D,0x01},
+	{0x3E,0x84},
+	{0x3F,0x01},
+	{0x40,0xA3},
+	{0x41,0x01},
+	{0x42,0xC7},
+	{0x43,0x01},
+	{0x44,0xEC},
+	// DSP9_SH_VAL_G0H 
+	{0x45,0x01},
+	{0x46,0x00},
+	{0x47,0x01},
+	{0x48,0x0C},
+	{0x49,0x01},
+	{0x4A,0x29},
+	{0x4B,0x01},
+	{0x4C,0x4D},
+	{0x4D,0x01},
+	{0x4E,0x5F},
+	{0x4F,0x01},
+	{0x50,0x78},
+	{0x51,0x01},
+	{0x52,0x8C},
+	{0x53,0x01},
+	{0x54,0xA7},
+	// DSP9_SH_VAL_B0H 
+	{0x55,0x01},
+	{0x56,0x00},
+	{0x57,0x01},
+	{0x58,0x0A},
+	{0x59,0x01},
+	{0x5A,0x23},
+	{0x5B,0x01},
+	{0x5C,0x43},
+	{0x5D,0x01},
+	{0x5E,0x57},
+	{0x5F,0x01},
+	{0x60,0x6A},
+	{0x61,0x01},
+	{0x62,0x7E},
+	{0x63,0x01},
+	{0x64,0x9C},
+	// DSP9_SH_M_R2_R1H 
+	{0x65,0x00},
+	{0x66,0xA5},
+	{0x67,0xDF},
+	{0x68,0x02},
+	{0x69,0x97},
+	{0x6A,0x7E},
+	{0x6B,0x05},
+	{0x6C,0xD4},
+	{0x6D,0xDB},
+	{0x6E,0x07},
+	{0x6F,0xEF},
+	{0x70,0xF2},
+	{0x71,0x0A},
+	{0x72,0x5D},
+	{0x73,0xF8},
+	{0x74,0x0D},
+	{0x75,0x1E},
+	{0x76,0xED},
+	{0x77,0x10},
+	{0x78,0x32},
+	{0x79,0xD3},
+	// DSP9_SH_M_R2_G1H 
+	{0x7A,0x00},
+	{0x7B,0x87},
+	{0x7C,0x7C},
+	{0x7D,0x02},
+	{0x7E,0x1D},
+	{0x7F,0xEE},
+	{0x80,0x04},
+	{0x81,0xC3},
+	{0x82,0x58},
+	{0x83,0x06},
+	{0x84,0x7B},
+	{0x85,0xAA},
+	{0x86,0x08},
+	{0x87,0x77},
+	{0x88,0xB9},
+	{0x89,0x0A},
+	{0x8A,0xB7},
+	{0x8B,0x87},
+	{0x8C,0x0D},
+	{0x8D,0x3B},
+	{0x8E,0x12},
+	// DSP9_SH_M_R2_B1H 
+	{0x8F,0x00},
+	{0x90,0x93},
+	{0x91,0x91},
+	{0x92,0x02},
+	{0x93,0x4E},
+	{0x94,0x42},
+	{0x95,0x05},
+	{0x96,0x30},
+	{0x97,0x15},
+	{0x98,0x07},
+	{0x99,0x0F},
+	{0x9A,0xAB},
+	{0x9B,0x09},
+	{0x9C,0x39},
+	{0x9D,0x09},
+	{0x9E,0x0B},
+	{0x9F,0xAC},
+	{0xA0,0x2F},
+	{0xA1,0x0E},
+	{0xA2,0x69},
+	{0xA3,0x1E},
+	// DSP9_SH_SUB_RR0H 
+	{0xA4,0x62},
+	{0xA5,0xC6},
+	{0xA6,0x20},
+	{0xA7,0xEC},
+	{0xA8,0x13},
+	{0xA9,0xC1},
+	{0xAA,0x1E},
+	{0xAB,0x64},
+	{0xAC,0x1A},
+	{0xAD,0x56},
+	{0xAE,0x17},
+	{0xAF,0x3D},
+	{0xB0,0x14},
+	{0xB1,0xCB},
+	// DSP9_SH_SUB_RG0H 
+	{0xB2,0x78},
+	{0xB3,0xEE},
+	{0xB4,0x28},
+	{0xB5,0x4F},
+	{0xB6,0x18},
+	{0xB7,0x2F},
+	{0xB8,0x25},
+	{0xB9,0x35},
+	{0xBA,0x20},
+	{0xBB,0x3F},
+	{0xBC,0x1C},
+	{0xBD,0x74},
+	{0xBE,0x19},
+	{0xBF,0x75},
+	// DSP9_SH_SUB_RB0H 
+	{0xC0,0x6F},
+	{0xC1,0x07},
+	{0xC2,0x25},
+	{0xC3,0x02},
+	{0xC4,0x16},
+	{0xC5,0x34},
+	{0xC6,0x22},
+	{0xC7,0x29},
+	{0xC8,0x1D},
+	{0xC9,0x9B},
+	{0xCA,0x1A},
+	{0xCB,0x1F},
+	{0xCC,0x17},
+	{0xCD,0x5F},
+
+	{0x00,0x02},	// shading on     
+
+	//==========================================================// 
+	//	 X-SHADING                                           // 
+	//==========================================================//
+	{0xfc,0x1B},	// X-SHADING 
+	{0x80,0x01},            
+	{0x81,0x00},
+	{0x82,0x4c},
+	{0x83,0x00},
+	{0x84,0x86},
+	{0x85,0x03},
+	{0x86,0x5e},
+	{0x87,0x00},
+	{0x88,0x07},
+	{0x89,0xa4},
+	{0x90,0x00},
+	{0x91,0xd3},
+	{0x92,0x01},
+	{0x93,0x09},
+	{0x94,0x01},
+	{0x95,0x3a},
+	{0x96,0x01},
+	{0x97,0x5c},
+	{0x98,0x01},
+	{0x99,0x70},
+	{0x9a,0x01},
+	{0x9b,0x5f},
+	{0x9c,0x01},
+	{0x9d,0x2d},
+	{0x9e,0x00},
+	{0x9f,0x9b},
+	{0xa0,0x00},
+	{0xa1,0xbd},
+	{0xa2,0x00},
+	{0xa3,0xd9},
+	{0xa4,0x00},
+	{0xa5,0xf8},
+	{0xa6,0x01},
+	{0xa7,0x05},
+	{0xa8,0x00},
+	{0xa9,0xfd},
+	{0xaa,0x00},
+	{0xab,0xdf},
+	{0xac,0x00},
+	{0xad,0x35},
+	{0xae,0x00},
+	{0xaf,0x33},
+	{0xb0,0x00},
+	{0xb1,0x29},
+	{0xb2,0x00},
+	{0xb3,0x20},
+	{0xb4,0x00},
+	{0xb5,0x2a},
+	{0xb6,0x00},
+	{0xb7,0x38},
+	{0xb8,0x00},
+	{0xb9,0x3d},
+	{0xba,0x07},
+	{0xbb,0xb2},
+	{0xbc,0x07},
+	{0xbd,0x86},
+	{0xbe,0x07},
+	{0xbf,0x54},
+	{0xc0,0x07},
+	{0xc1,0x2b},
+	{0xc2,0x07},
+	{0xc3,0x27},
+	{0xc4,0x07},
+	{0xc5,0x41},
+	{0xc6,0x07},
+	{0xc7,0x6e},
+	{0xc8,0x07},
+	{0xc9,0x4a},
+	{0xca,0x06},
+	{0xcb,0xfe},
+	{0xcc,0x06},
+	{0xcd,0xb5},
+	{0xce,0x06},
+	{0xcf,0x86},
+	{0xd0,0x06},
+	{0xd1,0x73},
+	{0xd2,0x06},
+	{0xd3,0x92},
+	{0xd4,0x06},
+	{0xd5,0xe0},
+
+	{0xfc,0x0b},	// x-shading temp. correlation factor
+	{0xda,0x00},	// t0(3100K)
+	{0xdb,0x9c},
+	{0xdc,0x00},	// tc(5100K)
+	{0xdd,0xd1},	// default eeh
+
+	{0xfc,0x1b},          
+	{0x80,0x01},	// X-Shading On                      
+
+	//=========================================================//
+	//	 AE WINDOW WEIGHT                                   //
+	//=========================================================//
+	{0xfc,0x00},	// AE WINDOW WEIGHT  
+	{0x03,0x4b},	// AE Suppress On   
+	{0xfc,0x06},
+	{0x01,0x35},	// UXGA AE Window   
+	{0x03,0xc2},
+	{0x05,0x48},
+	{0x07,0xb8},
+	{0x09,0x50},
+	{0x0b,0xbc},
+	{0x0d,0x2c},
+	{0x0f,0x8f},
+	{0x31,0x2a},	// Subsampling AE Window 
+	{0x33,0x61},
+	{0x35,0x28},
+	{0x37,0x5c},
+	{0x39,0x4d},
+	{0x3b,0x5a},
+	{0x3d,0x36},
+	{0x3f,0x43},   
+
+	{0xfc,0x20},	   	
+	{0x60,0x11},	 		
+	{0x61,0x11},	 		
+	{0x62,0x11},	 		
+	{0x63,0x11},	 		
+	{0x64,0x11},	 		
+	{0x65,0x11},	 	 
+	{0x66,0x11},	 	 
+	{0x67,0x11},	 		
+	{0x68,0x11},	 	 
+	{0x69,0x11},	 	 
+	{0x6a,0x11},	 	 
+	{0x6b,0x11},	 	 
+	{0x6c,0x11},	 	 
+	{0x6d,0x11},	 	 
+	{0x6e,0x11},	 	 
+	{0x6f,0x11},	 	 
+	{0x70,0x11},	 	 
+	{0x71,0x11},	 	 
+	{0x72,0x11},	 	 
+	{0x73,0x11},	 	 
+	{0x74,0x11},	 	 
+	{0x75,0x11},	 	 
+	{0x76,0x11},	 	 
+	{0x77,0x11},	 	                         
+
+	//========================================================== // 
+	//	 SAIT AWB                                             // 
+	//========================================================== //
+	{0xfc,0x07}, 
+	{0x3c,0x10},	// AWB cut R min  
+	{0x3d,0x10},	// AWB cut B min  
+	{0x3e,0x10},	// AWB cut R max  
+	{0x3f,0x10},	// AWB cut B max  
+
+	{0xfc,0x01},
+	{0xc8,0xe0},	// AWB Y Max 
+	{0xfc,0x00},
+	{0x3e,0x10},	// AWB Y_min   
+
+	{0xfc,0x00},	
+	{0x3e,0x10},	// AWB Y_min Normal     
+	{0x3d,0x04},	// AWB Y_min Low
+	{0x32,0x02},	// AWB moving average 8 frame 
+	{0x81,0x10},	// AWB G gain suppress Disable 
+	{0xbc,0xf0},	
+	{0xfc,0x22},	  
+	{0x8a,0x0a},	// AWB difference threshold check 
+	{0x8b,0x03},                       
+	{0x8c,0x04},	// AWB Min Y Weight check 
+	{0x8d,0x06},	// AWB Max Y Weight check 
+
+	{0xfc,0x07},
+	{0x97,0x00},	// S/W Y_lowpass Filter OFF                                  
+
+	//=================================                            
+	// White Point                                                 
+	//================================= 
+	{0xfc,0x22},	          
+	{0x01,0xd8},   // D65                                      
+	{0x03,0xa1},                                              
+	{0x05,0xcd},   // 5000K               
+	{0x07,0xba},                           
+	{0x09,0xb0},   // CWF                                   
+	{0x0b,0xe1},                                             
+	{0x0d,0xa0},   // 3000K                                        
+	{0x0f,0xf0},                                                     
+	{0x11,0x8f},   // A                                
+	{0x12,0x00},                                                     
+	{0x13,0xfc},                                        
+	{0x15,0x80},   // 2000K                               
+	{0x16,0x01},                                                      
+	                                     
+	//=================================                                   
+	// Basic Setting                             
+	//================================= 
+	{0xfc,0x22},
+	{0xA8,0xff},                 
+	{0xA0,0x01},
+	{0xA1,0x3D},
+	{0xA2,0x0D},
+	{0xA3,0xAD},
+	{0xA4,0x07},
+	{0xA5,0xE7},
+	{0xA6,0x12},
+	{0xA7,0xB7},
+	{0xA9,0x02},
+	{0xAA,0x8A},
+	{0xAB,0x23},
+	{0xAC,0xA2},
+	{0xAD,0x02},
+	{0xAE,0x04},
+	{0xAF,0x09},
+	{0xB0,0x84},
+	{0x94,0x36},
+	{0x95,0xB3},
+	{0x96,0x5E},
+	{0x97,0xE8},
+	{0xD0,0xb0},
+	{0xD1,0x30},
+	{0xD2,0x00},
+	{0xD3,0x21},
+	{0xD4,0xFF}, //Low Temp  
+	{0xDB,0x30},
+	{0xDC,0x7B},
+	{0xDD,0x21},
+	{0xE7,0x00},
+	{0xE8,0xB8},
+	{0xE9,0x00},
+	{0xEA,0xE0},
+	{0xEB,0x00},
+	{0xEC,0x00},
+	{0xEE,0xa0}, //AWB swing
+
+	//================================= 
+	// Pixel Filter Setting             
+	//================================= 
+	{0xFC,0x07},
+	{0x95,0xCF},
+
+	{0xfc,0x01},
+	{0xd3,0x4f},
+	{0xd4,0x00},
+	{0xd5,0x3a},
+	{0xd6,0x80},
+	{0xd7,0x60},
+	{0xd8,0x00},
+	{0xd9,0x49},
+	{0xda,0x00},
+	{0xdb,0x24},
+	{0xdc,0x4b},
+	{0xdd,0x26},
+	{0xde,0x54},
+	{0xdf,0x20},
+	{0xe0,0xc9},
+	{0xe1,0x19},
+	{0xe2,0x4c},
+	{0xe3,0x31},
+	{0xe4,0x40},
+	{0xe5,0x39},
+	{0xe6,0x40},
+	{0xe7,0x40},
+	{0xe8,0x37},
+	{0xe9,0x40},
+	{0xea,0x22},
+	{0xeb,0x00},                                         
+
+	//=================================
+	// AWB3 - Polygon Region  
+	//=================================
+	{0xfc,0x22},
+	{0x18,0x00},
+	{0x19,0x70},
+	{0x1a,0xca},
+	{0x1b,0x00},
+	{0x1c,0x65},
+	{0x1d,0xc9},
+	{0x1e,0x00},
+	{0x1f,0x67},
+	{0x20,0xb4},
+	{0x21,0x00},
+	{0x22,0x80},
+	{0x23,0x92},
+	{0x24,0x00},
+	{0x25,0x9e},
+	{0x26,0x7c},
+	{0x27,0x00},
+	{0x28,0xb3},
+	{0x29,0x6c},
+	{0x2a,0x00},
+	{0x2b,0xcd},
+	{0x2c,0x66},
+	{0x2d,0x00},
+	{0x2e,0xd0},
+	{0x2f,0x6f},
+	{0x30,0x00},
+	{0x31,0xbb},
+	{0x32,0x7a},
+	{0x33,0x00},
+	{0x34,0xac},
+	{0x35,0x86},
+	{0x36,0x00},
+	{0x37,0x95},
+	{0x38,0xa1},
+	{0x39,0x00},
+	{0x3a,0x83},
+	{0x3b,0xc2},
+	{0x3c,0x00},
+	{0x3d,0x00},                                                                 
+
+	//=================================  
+	// Moving Equation Weight            
+	//=================================  
+	{0xfc,0x22},
+	{0x98,0x07},	
+
+	//================================= 
+	// EIT Threshold                    
+	//================================= 
+	{0xfc,0x22},
+	{0xb1,0x00},  // Sunny 
+	{0xb2,0x03},	
+	{0xb3,0x00},
+	{0xb4,0xC1},
+
+	{0xb5,0x00},	// Cloudy 
+	{0xb6,0x03},	
+	{0xb7,0x00},
+	{0xb9,0xc2},
+
+	{0xd7,0x00},	// Shade 
+	{0xd8,0x35},
+	{0xd9,0x20},
+	{0xda,0x81},
+	                  
+	//================================= 
+	// Gain Offset                      
+	//================================= 
+	{0xfc,0x00},
+	{0x79,0xf2},  // Global R gain
+	{0x7a,0x0b},  // Global B gain 
+	              
+	{0xfc,0x07},  
+	{0x11,0xfe},  // Global G gain 
+	              
+	{0xfc,0x22},         
+	{0x58,0x00},  //ff}, //f8}, //f3},  // D65 R Offset   
+	{0x59,0xf6},  //f8},  // D65 B Offset   
+	{0x5A,0x00},  //ff}, //f9}, //f8},	// 5000K R Offset 
+	{0x5B,0xfe},  //00},	// 5000K B Offset 
+	{0x5C,0x02},  //00},	// CWF R Offset   
+	{0x5D,0x00},  // CWF B Offset   
+	{0x5E,0x02},	// 3000K R Offset 
+	{0x5F,0x00},  //08},	// 3000K B Offset 
+	{0x60,0x04},	// A R Offset     
+	{0x61,0x06},  //08},	// A B Offset     
+	{0x62,0x0a},	// 2000K R Offset 
+	{0x63,0x06},  //08},	// 2000K B Offset 
+
+	{0xde,0x00},	// LARGE OBJECT BUG FIX 
+	{0xf0,0x6a},	// RB Ratio 
+
+	//================================= 
+	// Green Stablity Enhance           
+	//================================= 
+	{0xfc,0x22},
+	{0xb9,0x00},
+	{0xba,0x00},
+	{0xbb,0x00},
+	{0xbc,0x00},
+	{0xe5,0x01},
+	{0xe6,0xff},
+	{0xbd,0x2c},   
+	{0x67,0x00},                                                   
+
+	//========================================================== 
+	//	 Special Effect                                        
+	//========================================================== 
+	//{0xfc,0x07},  // Special Effect 
+	//{0x30,0xc0},
+	//{0x31,0x20},
+	//{0x32,0x40},
+	//{0x33,0xc0},
+	//{0x34,0x00},
+	//{0x35,0xb0},                     
+
+	//==========================================================//
+	//	ETC                                                 //
+	//==========================================================//
+	{0xfc,0x01},                
+	{0x01,0x00}, //01},	// VCK Inversion //for high pclk setting
+	{0x00,0x90},	// sck inv.      
+	{0xfc,0x02},
+	{0x03,0x20},	// SCK inv.      
+	{0xfc,0x00},                                                    
+	{0x02,0x09},	// 800X600
+#else	// LG, Matterhorn Camera
+	//==========================================================
+	//	PLL SET 
+	//==========================================================
+	{0xfc,0x02},
+	{0x50,0x58},//5a},
+	{0x51,0x0a},
+	{0x52,0x80},
+	//==========================================================
+	//	CAMERA INITIAL 
+	//==========================================================
+	{0xfc,0x07},
+	{0x66,0x01},
+	{0xfc,0x00},
+	{0x00,0xaa},	//for ESD_CHECK
+	{0x21,0x03},
+	{0xfc,0x01},
+	{0x04,0x01},
+	{0xfc,0x02},
+	{0x55,0x1e},
+	{0x56,0x10},
+	{0x57,0x80},
+	{0x58,0x80},
+	{0x59,0x80},
+	{0x2d,0x48},
+	{0x4d,0x08},
+	{0x37,0x17},
+	{0x30,0x82},
+	{0x66,0x41},
+	{0x43,0xef},
+	{0x62,0x60},
+	{0xfc,0x02},
+	{0x4a,0x40},
+	//==========================================================   
+	//	Table Set for Sub-Sampling
+	//==========================================================  
+	{0xfc,0x03},
+	{0x2c,0x00},
+	{0x05,0x46},
+	{0x07,0xb6},
+	{0x0e,0x04},
+	{0x12,0x03},
+	{0xfc,0x04},
+	{0xc2,0x03},
+	{0xc3,0x17},
+	{0xc5,0x26},
+	{0xc7,0x5e},
+	{0xce,0x04},
+	{0xd2,0x04},
+	{0xec,0x00},
+	{0xc0,0x05},
+	{0xc1,0x40},
+	{0xfc,0x07},
+	{0x05,0x00},
+	{0x06,0x00},
+	{0x07,0x8b},
+	{0x08,0xf5},
+	{0x09,0x00},
+	{0x0a,0x89},
+	{0x0b,0x00},
+	{0x0c,0xb0},
+	{0x0d,0x00},
+	{0x0e,0x40},
+	{0xfc,0x00},
+	{0x70,0x02},
+	{0xfc,0x03},
+	{0x2e,0x00},
+	{0x5e,0x00},
+	{0x8e,0x00},
+	{0xbe,0x00},
+	{0xee,0x00},
+	{0xfc,0x04},
+	{0x2e,0x00},
+	{0x5e,0x00},
+	{0x8e,0x00},
+	{0xbe,0x00},
+	{0xee,0x00},
+	{0xfc,0x00},
+	{0x73,0x11},
+	{0x02,0x09},
+	{0x20,0x02},
+	{0xfc,0x00},                                                                        
+	{0x02,0x09},		 // 800 x 600
+
+	//==========================================================
+	//	ISP Setting
+	//==========================================================
+	{0xfc,0x00},
+	{0x6c,0xb0},
+	{0x6d,0x00},
+	{0xfc,0x20},
+	{0x16,0x5a},
+	{0xfc,0x00},
+	{0x78,0x63},	
+	{0xfc,0x20},    
+	{0x16,0x60},    
+	{0xfc,0x20},    
+	{0x57,0x18},
+	{0x2c,0x30},
+	{0x2e,0x00},
+	{0x14,0x70},
+	{0x01,0x02},
+	{0xfc,0x07},
+	{0x11,0x01},
+	{0xfc,0x07},
+	{0x3e,0x0a},
+	{0xfc,0x01},
+	{0xc8,0xa0},
+	{0xfc,0x00},
+	{0x3e,0x10},
+	{0x3d,0x04},
+	{0xfc,0x22},
+	{0x8c,0x04},
+	{0x8d,0x06},
+	{0xfc,0x00},
+	{0x32,0x02},
+	{0x81,0x10},
+	{0xbc,0xf0},
+	{0x29,0x03},	//Brightness Offset High
+	{0x2a,0xc0},	//Brightness Offset Low
+	{0x2b,0x03},	//Color Saturation High
+	{0x2c,0x80},	//Color Saturation Low
+	{0xfc,0x07},
+	{0x37,0x00},
+	{0x64,0x6f},
+	{0xfc,0x00},
+	{0x72,0xa0},//a3},
+	{0x74,0x18}, 	// 0x18 : 60hz auto 0x14 : 50hz auto 0x08 : 60hz fixed 0x04 : 50hz fixed flicker
+	{0xfc,0x20},
+	{0x02,0x02},
+	{0xfc,0x00},
+	{0x62,0x02},
+	{0xfc,0x02},
+	{0x4e,0x00},
+	{0x4e,0x00},
+	{0x4e,0x00},
+	{0x4e,0x00},
+	{0x4f,0x0a},
+	{0x4f,0x0a},
+	{0x4f,0x0a},
+	{0x4f,0x0a},
+	{0xfc,0x01},
+	{0x0c,0x03},
+	{0x0c,0x03},
+	{0x01,0x00},
+	{0xfc,0x00},
+	{0x7e,0xf4},
+	{0xfc,0x01},
+	{0x3d,0x10},
+	{0xfc,0x02},
+	{0x03,0x20},
+	{0xfc,0x01},
+	{0x00,0x90},
+	{0xfc,0x07},
+	{0x3a,0xaa},
+	{0xfc,0x02},
+	{0x4e,0x1b},
+	{0x4f,0xda},
+	{0xfc,0x07},
+	{0x97,0x00},
+
+	//==========================================================
+	//	COLOR MATRIX
+	//==========================================================
+	{0xfc,0x01},
+	{0x51,0x08},
+	{0x52,0x9b},
+	{0x53,0xfc},
+	{0x54,0x07},
+	{0x55,0xff},
+	{0x56,0x5e},
+	{0x57,0xfd},
+	{0x58,0x0e},
+	{0x59,0x07},
+	{0x5a,0xee},
+	{0x5b,0xff},
+	{0x5c,0x05},
+	{0x5d,0xff},
+	{0x5e,0x7a},
+	{0x5f,0xfc},
+	{0x60,0x23},
+	{0x61,0x08},
+	{0x62,0x64},
+	//==========================================================
+	//	EDGE SUPPRESSION
+	//==========================================================
+	{0xfc,0x00},
+	{0x89,0x03},
+	{0xfc,0x0b},
+	{0x42,0x50},
+	{0x43,0x60},
+	{0x45,0x30},
+	{0x49,0x10},
+	{0x4d,0x30},
+	{0x51,0x10},
+	//==========================================================
+	//	EDGE ENHANCEMENT
+	//==========================================================
+	{0xfc,0x05},
+	{0x34,0x34},
+	{0x35,0x08},
+	{0x36,0x0b},
+	{0x3f,0x00},
+	{0x42,0x10},
+	{0x43,0x00},
+	{0x45,0xa0},
+	{0x46,0x7a},
+	{0x47,0x40},
+	{0x48,0x0c},
+	{0x49,0x31},
+	{0x40,0x41},
+	//==========================================================
+	//	GAMMA
+	//==========================================================
+	{0xfc,0x1d},
+	{0x00,0x0a},
+	{0x01,0x1e},
+	{0x02,0x42},
+	{0x03,0x07},
+	{0x04,0x01},
+	{0x05,0x9e},
+	{0x06,0xfa},
+	{0x07,0x42},
+	{0x08,0x75},
+	{0x09,0x5a},
+	{0x0a,0xa5},
+	{0x0b,0xc9},
+	{0x0c,0xec},
+	{0x0d,0x0d},
+	{0x0e,0xab},
+	{0x0f,0x2b},
+	{0x10,0x48},
+	{0x11,0x64},
+	{0x12,0x7c},
+	{0x13,0xff},
+	{0x14,0x91},
+	{0x15,0xa2},
+	{0x16,0xb0},
+	{0x17,0xbd},
+	{0x18,0xff},
+	{0x19,0xc8},
+	{0x1a,0xd2},
+	{0x1b,0xda},
+	{0x1c,0xe0},
+	{0x1d,0xff},
+	{0x1e,0xe5},
+	{0x1f,0xea},
+	{0x20,0xed},
+	{0x21,0xef},
+	{0x22,0xff},
+	{0x23,0xf0},
+	{0x24,0xf3},
+	{0x25,0xf5},
+	{0x26,0xf8},
+	{0x27,0xff},
+	{0x28,0xfb},
+	{0x29,0xff},
+	{0x2a,0xf0},
+	{0x2b,0x0a},
+	{0x2c,0x1e},
+	{0x2d,0x42},
+	{0x2e,0x07},
+	{0x2f,0x01},
+	{0x30,0x9e},
+	{0x31,0xfa},
+	{0x32,0x42},
+	{0x33,0x75},
+	{0x34,0x5a},
+	{0x35,0xa5},
+	{0x36,0xc9},
+	{0x37,0xec},
+	{0x38,0x0d},
+	{0x39,0xab},
+	{0x3a,0x2b},
+	{0x3b,0x48},
+	{0x3c,0x64},
+	{0x3d,0x7c},
+	{0x3e,0xff},
+	{0x3f,0x91},
+	{0x40,0xa2},
+	{0x41,0xb0},
+	{0x42,0xbd},
+	{0x43,0xff},
+	{0x44,0xc8},
+	{0x45,0xd2},
+	{0x46,0xda},
+	{0x47,0xe0},
+	{0x48,0xff},
+	{0x49,0xe5},
+	{0x4a,0xea},
+	{0x4b,0xed},
+	{0x4c,0xef},
+	{0x4d,0xff},
+	{0x4e,0xf0},
+	{0x4f,0xf3},
+	{0x50,0xf5},
+	{0x51,0xf8},
+	{0x52,0xff},
+	{0x53,0xfb},
+	{0x54,0xff},
+	{0x55,0xf0},
+	{0x56,0x0a},
+	{0x57,0x1e},
+	{0x58,0x42},
+	{0x59,0x07},
+	{0x5a,0x01},
+	{0x5b,0x9e},
+	{0x5c,0xfa},
+	{0x5d,0x42},
+	{0x5e,0x75},
+	{0x5f,0x5a},
+	{0x60,0xa5},
+	{0x61,0xc9},
+	{0x62,0xec},
+	{0x63,0x0d},
+	{0x64,0xab},
+	{0x65,0x2b},
+	{0x66,0x48},
+	{0x67,0x64},
+	{0x68,0x7c},
+	{0x69,0xff},
+	{0x6a,0x91},
+	{0x6b,0xa2},
+	{0x6c,0xb0},
+	{0x6d,0xbd},
+	{0x6e,0xff},
+	{0x6f,0xc8},
+	{0x70,0xd2},
+	{0x71,0xda},
+	{0x72,0xe0},
+	{0x73,0xff},
+	{0x74,0xe5},
+	{0x75,0xea},
+	{0x76,0xed},
+	{0x77,0xef},
+	{0x78,0xff},
+	{0x79,0xf0},
+	{0x7a,0xf3},
+	{0x7b,0xf5},
+	{0x7c,0xf8},
+	{0x7d,0xff},
+	{0x7e,0xfb},
+	{0x7f,0xff},
+	{0x80,0xf0},
+	//==========================================================
+	//	HUE CONTROL
+	//==========================================================
+	{0xfc,0x00},
+	{0x62,0x03},
+	{0x48,0x42},	//2000K
+	{0x49,0x40},
+	{0x4a,0xf0},
+	{0x4b,0xf4},
+	{0x4c,0x40},
+	{0x4d,0x6a},
+	{0x4e,0x08},
+	{0x4f,0x03},
+	{0x50,0x46},	//3000K
+	{0x51,0x48},
+	{0x52,0xf8},
+	{0x53,0xf4},
+	{0x54,0x40},
+	{0x55,0x6a},
+	{0x56,0x08},
+	{0x57,0xfd},
+	{0x58,0x30},	//5000K
+	{0x59,0x38},
+	{0x5a,0x02},
+	{0x5b,0xf0},
+	{0x5c,0x30},
+	{0x5d,0x4a},
+	{0x5e,0x0c},
+	{0x5f,0xfd},
+
+	//==========================================================   
+	//	Bad Pixel Replacement
+	//==========================================================  		
+	{0xfc,0x0b},
+	{0x0b,0x00},
+	{0x0c,0x40},
+	{0x0d,0x5a},
+	{0x0e,0x00},
+	{0x0f,0x20},
+	{0x10,0x00},
+	{0x11,0x10},
+	{0x12,0x00},
+	{0x13,0x00},
+	{0x14,0xff},
+	{0x15,0xff},
+	{0x16,0x48},
+	{0x17,0x60},
+	{0x18,0x00},
+	{0x19,0x00},
+	{0x1a,0x00},
+	{0x1b,0x20},
+	{0x1c,0x00},
+	{0x1d,0x00},
+	{0x1e,0x00},
+	{0x1f,0x20},
+	//==========================================================
+	//	GR/GB CORRECTION
+	//==========================================================
+	{0xfc,0x01},
+	{0x45,0x0c},
+	{0xfc,0x0b},
+	{0x21,0x00},
+	{0x22,0x58},
+	{0x23,0x68},
+	{0x24,0x1a},
+	{0x25,0x28},//0x16
+	{0x26,0x1a},
+	{0x27,0x28},//0x20
+	//==========================================================
+	//	Noise Reduction
+	//==========================================================
+	{0xfc,0x01},
+	{0x4c,0x01},
+	{0x49,0x15},
+	{0x4b,0x0a},
+	{0xfc,0x0b},
+	{0x28,0x00},
+	{0x29,0x00},
+	{0x2a,0x14},
+	{0x2b,0x00},
+	{0x2c,0x14},
+	{0x2d,0x00},
+	{0x2e,0x90},
+	{0x2f,0x00},
+	{0x30,0xc0},
+	{0x31,0x00},
+	{0x32,0xa0},
+	{0x33,0x00},
+	{0x34,0xd0},
+	//==========================================================
+	//	1D-Y/C-SIGMA-LPF
+	//==========================================================
+	{0xfc,0x01},
+	{0x05,0xc0},
+	{0xfc,0x0b},
+	{0x35,0x00},
+	{0x36,0x60},
+	{0x37,0x68},
+	{0x38,0x00},
+	{0x39,0x08},
+	{0x3a,0x00},
+	{0x3b,0x30},
+	{0x3c,0x60},
+	{0x3d,0x68},
+	{0x3e,0x00},
+	{0x3f,0x30},
+	{0x40,0x00},
+	{0x41,0x38},
+	{0xd4,0x60},
+	{0xd5,0x68},
+	{0xd6,0xb0},
+	{0xd7,0xb8},
+	{0xd8,0xb0},
+	{0xd9,0xb8},
+	//==========================================================
+	//	COLOR SUPPRESS
+	//==========================================================
+	{0xfc,0x0b},
+	{0x08,0x73},
+	{0x09,0x03},
+	{0x0a,0x40},
+	//==========================================================
+	//	SHADING
+	//==========================================================
+	{0xfc,0x09},
+	{0x01,0x06},
+	{0x02,0x40},
+	{0x03,0x04},
+	{0x04,0xb0},
+	{0x05,0x03},	//0x02
+	{0x06,0x1a},	//0x10 0x08 0xf8
+	{0x07,0x02},
+	{0x08,0x2b},	//0x4b 0x5b 0x70 0x8a
+	{0x09,0x03},
+	{0x0a,0x02},
+	{0x0b,0x02},
+	{0x0c,0x58},
+	{0x0d,0x03},	//0x02
+	{0x0e,0x22},	//0x18  0x10 0xf0 0xd0
+	{0x0f,0x02},
+	{0x10,0x5d},	//0x51  0x39
+	{0x1d,0x80},
+	{0x1e,0x00},
+	{0x1f,0x80},
+	{0x20,0x00},
+	{0x21,0x80},
+	{0x22,0x00},
+	{0x23,0x80},
+	{0x24,0x00},
+	{0x25,0x80},
+	{0x26,0x00},
+	{0x27,0x80},
+	{0x28,0x00},
+	{0x29,0x80},
+	{0x2a,0x00},
+	{0x2b,0x80},
+	{0x2c,0x00},
+	{0x2d,0x80},
+	{0x2e,0x00},
+	{0x2f,0x80},
+	{0x30,0x00},
+	{0x31,0x80},
+	{0x32,0x00},
+	{0x33,0x7d},
+	{0x34,0x7c},
+	{0x35,0x01},
+	{0x36,0x0a},
+	{0x37,0x01},
+	{0x38,0x1e},
+	{0x39,0x01},
+	{0x3a,0x41},
+	{0x3b,0x01},
+	{0x3c,0x72},
+	{0x3d,0x01},
+	{0x3e,0x8c},
+	{0x3f,0x01},
+	{0x40,0xa7},
+	{0x41,0x01},
+	{0x42,0xc5},
+	{0x43,0x01},
+	{0x44,0xec},
+	{0x45,0x01},
+	{0x46,0x00},
+	{0x47,0x01},
+	{0x48,0x0c},
+	{0x49,0x01},
+	{0x4a,0x29},
+	{0x4b,0x01},
+	{0x4c,0x4d},
+	{0x4d,0x01},
+	{0x4e,0x5f},
+	{0x4f,0x01},
+	{0x50,0x78},
+	{0x51,0x01},
+	{0x52,0x92},
+	{0x53,0x01},
+	{0x54,0xb1},
+	{0x55,0x01},
+	{0x56,0x00},
+	{0x57,0x01},
+	{0x58,0x0a},
+	{0x59,0x01},
+	{0x5a,0x23},
+	{0x5b,0x01},
+	{0x5c,0x3d},
+	{0x5d,0x01},
+	{0x5e,0x4f},
+	{0x5f,0x01},
+	{0x60,0x62},
+	{0x61,0x01},
+	{0x62,0x76},
+	{0x63,0x01},
+	{0x64,0x8e},
+	{0x65,0x00},
+	{0x66,0xa4},
+	{0x67,0xdf},
+	{0x68,0x02},
+	{0x69,0x93},
+	{0x6a,0x7e},
+	{0x6b,0x05},
+	{0x6c,0xcb},
+	{0x6d,0xdb},
+	{0x6e,0x07},
+	{0x6f,0xe3},
+	{0x70,0xb2},
+	{0x71,0x0a},
+	{0x72,0x4d},
+	{0x73,0xf8},
+	{0x74,0x0d},
+	{0x75,0x0a},
+	{0x76,0xad},
+	{0x77,0x10},
+	{0x78,0x19},
+	{0x79,0xd3},
+	{0x7a,0x00},
+	{0x7b,0x93},
+	{0x7c,0xdd},
+	{0x7d,0x02},
+	{0x7e,0x4f},
+	{0x7f,0x75},
+	{0x80,0x05},
+	{0x81,0x32},
+	{0x82,0xc7},
+	{0x83,0x07},
+	{0x84,0x13},
+	{0x85,0x56},
+	{0x86,0x09},
+	{0x87,0x3d},
+	{0x88,0xd3},
+	{0x89,0x0b},
+	{0x8a,0xb2},
+	{0x8b,0x3f},
+	{0x8c,0x0e},
+	{0x8d,0x70},
+	{0x8e,0x9a},
+	{0x8f,0x00},
+	{0x90,0x9c},
+	{0x91,0xf4},
+	{0x92,0x02},
+	{0x93,0x73},
+	{0x94,0xcf},
+	{0x95,0x05},
+	{0x96,0x84},
+	{0x97,0x92},
+	{0x98,0x07},
+	{0x99,0x82},
+	{0x9a,0xaa},
+	{0x9b,0x09},
+	{0x9c,0xcf},
+	{0x9d,0x3c},
+	{0x9e,0x0c},
+	{0x9f,0x6a},
+	{0xa0,0x48},
+	{0xa1,0x0f},
+	{0xa2,0x53},
+	{0xa3,0xcd},
+	{0xa4,0x63},
+	{0xa5,0x5f},
+	{0xa6,0x21},
+	{0xa7,0x1f},
+	{0xa8,0x13},
+	{0xa9,0xdf},
+	{0xaa,0x1e},
+	{0xab,0x93},
+	{0xac,0x1a},
+	{0xad,0x7f},
+	{0xae,0x17},
+	{0xaf,0x61},
+	{0xb0,0x14},
+	{0xb1,0xeb},
+	{0xb2,0x6e},
+	{0xb3,0xcd},
+	{0xb4,0x24},
+	{0xb5,0xef},
+	{0xb6,0x16},
+	{0xb7,0x29},
+	{0xb8,0x22},
+	{0xb9,0x17},
+	{0xba,0x1d},
+	{0xbb,0x8c},
+	{0xbc,0x1a},
+	{0xbd,0x12},
+	{0xbe,0x17},
+	{0xbf,0x53},
+	{0xc0,0x68},
+	{0xc1,0x63},
+	{0xc2,0x22},
+	{0xc3,0xcb},
+	{0xc4,0x14},
+	{0xc5,0xe0},
+	{0xc6,0x20},
+	{0xc7,0x1e},
+	{0xc8,0x1b},
+	{0xc9,0xd6},
+	{0xca,0x18},
+	{0xcb,0x8f},
+	{0xcc,0x15},
+	{0xcd,0xf9},
+	{0x00,0x02},
+	//==========================================================
+	//	X-Shading
+	//==========================================================
+	{0xfc,0x1b},
+	{0x80,0x00},
+	{0x81,0x00},
+	{0x82,0x4c},
+	{0x83,0x00},
+	{0x84,0x86},
+	{0x85,0x03},
+	{0x86,0x5e},
+	{0x87,0x00},
+	{0x88,0x07},
+	{0x89,0xa4},
+	{0x90,0x00},
+	{0x91,0xd3},
+	{0x92,0x01},
+	{0x93,0x09},
+	{0x94,0x01},
+	{0x95,0x3a},
+	{0x96,0x01},
+	{0x97,0x5c},
+	{0x98,0x01},
+	{0x99,0x70},
+	{0x9a,0x01},
+	{0x9b,0x5f},
+	{0x9c,0x01},
+	{0x9d,0x2d},
+	{0x9e,0x00},
+	{0x9f,0x9b},
+	{0xa0,0x00},
+	{0xa1,0xbd},
+	{0xa2,0x00},
+	{0xa3,0xd9},
+	{0xa4,0x00},
+	{0xa5,0xf8},
+	{0xa6,0x01},
+	{0xa7,0x05},
+	{0xa8,0x00},
+	{0xa9,0xfd},
+	{0xaa,0x00},
+	{0xab,0xdf},
+	{0xac,0x00},
+	{0xad,0x35},
+	{0xae,0x00},
+	{0xaf,0x33},
+	{0xb0,0x00},
+	{0xb1,0x29},
+	{0xb2,0x00},
+	{0xb3,0x20},
+	{0xb4,0x00},
+	{0xb5,0x2a},
+	{0xb6,0x00},
+	{0xb7,0x38},
+	{0xb8,0x00},
+	{0xb9,0x3d},
+	{0xba,0x07},
+	{0xbb,0xb2},
+	{0xbc,0x07},
+	{0xbd,0x86},
+	{0xbe,0x07},
+	{0xbf,0x54},
+	{0xc0,0x07},
+	{0xc1,0x2b},
+	{0xc2,0x07},
+	{0xc3,0x27},
+	{0xc4,0x07},
+	{0xc5,0x41},
+	{0xc6,0x07},
+	{0xc7,0x6e},
+	{0xc8,0x07},
+	{0xc9,0x4a},
+	{0xca,0x06},
+	{0xcb,0xfe},
+	{0xcc,0x06},
+	{0xcd,0xb5},
+	{0xce,0x06},
+	{0xcf,0x86},
+	{0xd0,0x06},
+	{0xd1,0x73},
+	{0xd2,0x06},
+	{0xd3,0x92},
+	{0xd4,0x06},
+	{0xd5,0xe0},
+
+	{0xfc,0x0b},
+	{0xda,0x00},
+	{0xdb,0x9c},
+	{0xdc,0x00},
+	{0xdd,0xd1},
+	{0xfc,0x00},
+	{0x81,0x10},
+	{0xfc,0x1b},
+	{0x80,0x01},
+
+	//
+	{0xfc,0x00},
+	{0x03,0x4b},
+	{0xfc,0x06},
+	{0x01,0x35},
+	{0x03,0xc2},
+	{0x05,0x48},
+	{0x07,0xb8},
+	{0x31,0x2a},
+	{0x33,0x61},
+	{0x35,0x28},
+	{0x37,0x5c},
+	//==========================================================
+	// AE Window
+	//==========================================================
+	//ave
+	{0xfc,0x20},
+	{0x60,0x11},
+	{0x61,0x11},
+	{0x62,0x11},
+	{0x63,0x11},
+	{0x64,0x11},
+	{0x65,0x11},
+	{0x66,0x11},
+	{0x67,0x11},
+	{0x68,0x11},
+	{0x69,0x11},
+	{0x6a,0x11},
+	{0x6b,0x11},
+	{0x6c,0x11},
+	{0x6d,0x11},
+	{0x6e,0x11},
+	{0x6f,0x11},
+	{0x70,0x11},
+	{0x71,0x11},
+	{0x72,0x11},
+	{0x73,0x11},
+	{0x74,0x11},
+	{0x75,0x11},
+	{0x76,0x11},
+	{0x77,0x11},
+
+	//==========================================================
+	//	SAIT AWB
+	//==========================================================
+	// White Point For Hue Control MWB
+	{0xfc,0x22},
+	{0x01,0xcf},
+	{0x03,0x86},
+	{0x05,0xbc},
+	{0x07,0xb2},
+	{0x09,0xae},
+	{0x0b,0xd5},
+	{0x0d,0x95},
+	{0x0f,0xf4},
+	{0x10,0x00},
+	{0x11,0x79},
+	{0x12,0x00},
+	{0x13,0xfd},
+	{0x15,0x7f},
+	{0x16,0x00},
+	{0x17,0xff},
+
+
+	// Basic Setting
+	{0xfc,0x22}, 	//AWB Basic
+	{0xA0,0x01}, 
+	{0xA1,0x3F}, 
+	{0xA2,0x0E}, 
+	{0xA3,0x8A}, 
+	{0xA4,0x07}, 
+	{0xA5,0xF6}, 
+	{0xA6,0x11}, 
+	{0xA7,0x9A}, 
+	{0xA9,0x02},
+	{0xAA,0xA8},
+	{0xAB,0x7F},
+	{0xAC,0xE8},
+	{0xAD,0x02},
+	{0xAE,0xA1},
+	{0xAF,0x4F},
+	{0xB0,0xCF},
+	{0xBD,0x80},
+	{0x94,0x37},
+	{0x95,0xCC},
+	{0x96,0x62},
+	{0x97,0x3A},
+	{0xD0,0xA0},
+	{0xD1,0x25},
+	{0xD2,0x42},
+	{0xD3,0x20},
+	{0xD4,0xa0},	//Low Temp  
+	{0xDB,0x25},
+	{0xDC,0x78},
+	{0xDD,0x20},
+	{0xe7,0x00},	//Low Temp AWB
+	{0xe8,0xbb},
+	{0xe9,0x00},
+	{0xea,0x72},
+	{0xeb,0x03},
+	{0xec,0x84},
+	{0xEE,0x98},
+
+	{0xfc,0x00},
+	{0x8a,0x08},
+	{0x8b,0x03},
+
+
+	// Pixel Filter Setting 
+	{0xfc,0x07},
+	{0x95,0xcf},
+	{0xfc,0x01},
+	{0xd3,0x4e},
+	{0xd4,0x80},
+	{0xd5,0x3e},
+	{0xd6,0x00},
+	{0xd7,0x5d},
+	{0xd8,0x80},
+	{0xd9,0x4d},
+	{0xda,0x00},
+	{0xdb,0x1d},
+	{0xdc,0xa8},
+	{0xdd,0x26},
+	{0xde,0x95},
+	{0xdf,0x21},
+	{0xe0,0xb1},
+	{0xe1,0x1c},
+	{0xe2,0x1a},
+	{0xe3,0x40},
+	{0xe4,0x40},
+	{0xe5,0x40},
+	{0xe6,0x40},
+	{0xe7,0x1f},
+	{0xe8,0x39},
+	{0xe9,0x36},
+	{0xea,0x23},
+	{0xeb,0x00},
+
+	// Polygon AWB Region Tune
+	{0xfc,0x22},
+	{0x18,0x00},
+	{0x19,0x59},
+	{0x1a,0xe9},
+	{0x1b,0x00},
+	{0x1c,0x5b},
+	{0x1d,0xcb},
+	{0x1e,0x00},
+	{0x1f,0x7e},
+	{0x20,0xa0},
+	{0x21,0x00},
+	{0x22,0x91},
+	{0x23,0x88},
+	{0x24,0x00},
+	{0x25,0xa3},
+	{0x26,0x74},
+	{0x27,0x00},
+	{0x28,0xb9},
+	{0x29,0x60},
+	{0x2a,0x00},
+	{0x2b,0xd3},
+	{0x2c,0x5a},
+	{0x2d,0x00},
+	{0x2e,0xd5},
+	{0x2f,0x74},
+	{0x30,0x00},
+	{0x31,0xbc},
+	{0x32,0x7d},
+	{0x33,0x00},
+	{0x34,0xad},
+	{0x35,0x89},
+	{0x36,0x00},
+	{0x37,0x9a},
+	{0x38,0xa6},
+	{0x39,0x00},
+	{0x3a,0x75},
+	{0x3b,0xde},
+	{0x3c,0x00},
+	{0x3d,0x00},
+	{0x3e,0x00},
+	{0x3f,0x00},
+	{0x40,0x00},
+	{0x41,0x00},
+	{0x42,0x00},
+	{0x43,0x00},
+	{0x44,0x00},
+	{0x45,0x00},
+	{0x46,0x00},
+	{0x47,0x00},
+	{0x48,0x00},
+	{0x49,0x00},
+	{0x4a,0x00},
+	{0x4b,0x00},
+	{0x4c,0x00},
+	{0x4d,0x00},
+	{0x4e,0x00},
+	{0x4f,0x00},
+	{0x50,0x00},
+	{0x51,0x00},
+	{0x52,0x00},
+	{0x53,0x00},
+	{0x54,0x00},
+	{0x55,0x00},
+	{0x56,0x00},
+
+	// Moving Equation Weight
+	{0xfc,0x22},
+	{0x98,0x07},
+
+	//EIT Threshold
+	{0xfc,0x22},
+	{0xb1,0x00},
+	{0xb2,0x02},
+	{0xb3,0x00},
+	{0xb4,0xc1},
+	{0xb5,0x00},
+	{0xb6,0x02},
+	{0xb7,0x00},
+	{0xb9,0xc2},
+	{0xd7,0x00},
+	{0xd8,0x35},
+	{0xd9,0x20},
+	{0xda,0x81},
+
+	//==========================================================
+	//	R, B Offset
+	//==========================================================
+	{0xfc,0x00},
+	{0x79,0xf2},	//0xf1//0xf5//0xf6 Global R Offset
+	{0x7a,0x1c},	//0x09//0x05//0x08 Global B Offset
+	{0xde,0x00},
+	{0xf0,0x6a},
+	{0xfc,0x22},	// Offset
+	{0x58,0xf9},
+	{0x59,0xf7},
+	{0x5a,0x05},
+	{0x5b,0xf5},
+	{0x5c,0x0a},//0c
+	{0x5d,0xfb},
+	{0x5e,0x0a},//0c
+	{0x5f,0xfe},
+	{0x60,0x0a},
+	{0x61,0x06},
+	{0x62,0x0a},
+	{0x63,0x06},
+
+	// Green Stablity Enhance
+	{0xfc,0x22},
+	{0xb9,0x00},
+	{0xba,0x00},
+	{0xbb,0x00},
+	{0xbc,0x00},
+	{0xe5,0x01},
+	{0xe6,0xff},
+	// AWB2_OPTION : BD_OUTDOORCLASY
+	{0xbd,0x80},	//0x8c
+	{0x70,0xf0},
+
+	//==========================================================
+	//	Special function sephia B/W etc
+	//==========================================================
+	{0xfc,0x07},
+	{0x30,0xc0},
+	{0x31,0x20},
+	{0x32,0x40},
+	{0x33,0xc0},
+	{0x34,0x00},
+	{0x35,0xb0},
+
+
+	//==========================================================
+	//	EE Wide LUMA
+	//==========================================================
+	{0xfc,0x1d},
+	{0x86,0x02},
+	{0x87,0xc0},
+	{0x88,0x03},
+	{0x89,0xc0},
+	{0x8a,0x02},
+	{0x8b,0x00},
+	{0x8c,0x00},
+	{0x8d,0x00},
+	{0x8e,0x00},
+	{0x8f,0xd0},
+	{0x90,0x00},
+	{0x91,0x00},
+	{0x92,0x02},
+	{0x93,0x00},
+	{0x94,0x00},
+	{0x95,0x00},
+	{0x96,0x00},
+	{0x97,0xd0},
+	{0x98,0x00},
+	{0x99,0x00},
+	{0x9a,0x02},
+	{0x9b,0x60},
+	{0x9c,0x00},
+	{0x9d,0x00},
+	{0x9e,0x02},
+	{0x9f,0x60},
+	{0xa0,0x00},
+	{0xa1,0x00},
+	{0xa2,0x09},
+	{0x85,0x01},
+
+	//==========================================================
+	//	Color Correction Coefficient
+	//==========================================================
+	{0xfc,0x0b},
+	{0x60,0x08},
+	{0x61,0x9b},
+	{0x62,0xfc},
+	{0x63,0x07},
+	{0x64,0xff},
+	{0x65,0x5e},
+	{0x66,0xfd},
+	{0x67,0x0e},
+	{0x68,0x07},
+	{0x69,0xee},
+	{0x6a,0xff},
+	{0x6b,0x05},
+	{0x6c,0xff},
+	{0x6d,0x7a},
+	{0x6e,0xfc},
+	{0x6f,0x23},
+	{0x70,0x08},
+	{0x71,0x64},
+	{0x72,0x04},    
+	{0x73,0xfd},    
+	{0x74,0xfd},
+	{0x75,0xea},
+	{0x76,0x01},
+	{0x77,0x19},
+	{0x78,0xfd},
+	{0x79,0xbf},
+	{0x7a,0x05},
+	{0x7b,0x16},
+	{0x7c,0x01},
+	{0x7d,0x2b},
+	{0x7e,0xff},
+	{0x7f,0xbf},
+	{0x80,0xf8},
+	{0x81,0x8e},
+	{0x82,0x0b},
+	{0x83,0xb3},
+	{0x84,0x04},
+	{0x85,0xfd},
+	{0x86,0xfd},
+	{0x87,0xea},
+	{0x88,0x01},
+	{0x89,0x19},
+	{0x8a,0xfd},
+	{0x8b,0xbf},
+	{0x8c,0x05},
+	{0x8d,0x16},
+	{0x8e,0x01},
+	{0x8f,0x2b},
+	{0x90,0xff},
+	{0x91,0xbf},
+	{0x92,0xf8},
+	{0x93,0x8e},
+	{0x94,0x0b},
+	{0x95,0xb3},
+
+
+	///////////////////////////////////////////////////
+	//   Stable Range For Cintr
+	///////////////////////////////////////////////////
+	{0xfc,0x20},
+	{0x52,0x10},
+	{0x53,0x10},
+
+	///////////////////////////////////////////////////
+	//   Mirror Option
+	///////////////////////////////////////////////////
+	{0xfc,0x20},
+	{0x0f,0x01},       // Weight Mirrored  63 to 0
+	{0xfc,0x00},
+	{0x75,0x05},
+#endif
+    {REG_TERM, VAL_TERM}
+};
+
+
+static struct sensor_reg sensor_preview[] = {
+	//===================================
+	//	CAMERA PREVIEW(800*600)
+	//===================================
+	{0xfc,0x02},
+	{0x2d,0x48},  //double shutter width control.double shutter enable
+	{0x44,0x63},  //Reserved
+	{0xfc,0x03},  
+	{0x02,0x04}, //CIS_FRAME_V_DEPTH_H
+	{0xfc,0x20},  
+	{0x14,0x70},  //80 //BRIGHT_OFFSET,                   
+	{0xfc,0x00},  
+	{0x03,0x4b},  // AE/AWB On
+	{0x7e,0x74},  // Suppress On
+	{0x89,0x03},  // Edge Suppress On 
+	{0xfc,0x20},                     
+	{0x16,0x5a},  //50 // Frame AE Start
+	{0xfc,0x02},         
+	{0x30,0x82},  // Analog offset       
+	{0x37,0x11},  //0d // Global Gain
+	{0x60,0x00},  // Blank_Adrs
+	{0x45,0x0e},  // CDS Timing for Average Sub_Sampling
+	{0x47,0x2f},  // Reserved
+	{0xfc,0x00},                
+	{0x02,0x09},  // 800 x 600 Recovery
+	{REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_capture[] = {
+	//===================================
+	//	1600*1200 SNAPSHOT
+	//===================================
+	{0xfc, 0x00},
+	{0x03, 0x48},
+	{0xfc, 0x02},
+	{0x30, 0x90},
+	{0x37, 0x20},                                                                        
+	{0x60, 0x01},		                                                        
+	{0x45, 0xff},                                                                        
+	{0x47, 0x0f},		                                                     
+	{0xfc, 0x00},		 
+	{0x02, 0x00},
+//	{0xfc, 0x00},     
+//	{0x75, 0x05},  //H.V mirror	
+    {REG_TERM, VAL_TERM}
+};
+
+ struct sensor_reg* sensor_reg_common[3] =
+{
+	sensor_common,
+	sensor_preview,
+	sensor_capture
+};
+
+static struct sensor_reg sensor_brightness_0[] = {
+	{0xfc,0x00},
+	{0x29,0x02},
+	{0x2a,0xa0},
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_brightness_1[] = {
+	{0xfc,0x00},
+	{0x29,0x03},
+	{0x2a,0xa0},
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_brightness_2[] = {
+	{0xfc,0x00},
+	{0x29,0x04},
+	{0x2a,0xa0},
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_brightness_3[] = {
+	{0xfc,0x00},
+	{0x29,0x05},
+	{0x2a,0xa0},
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_brightness_4[] = {
+	{0xfc,0x00},
+	{0x29,0x03},
+	{0x2a,0xa0},
+    {REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_brightness[5] =
+{
+	sensor_brightness_0,
+	sensor_brightness_1,
+	sensor_brightness_2,
+	sensor_brightness_3,
+	sensor_brightness_4
+};
+
+
+static struct sensor_reg sensor_awb_auto[] = {
+	//===================================
+	//	CameraWB_Auto
+	//===================================
+	{0xfc,0x00},             
+	{0x04,0x00},
+	{0x05,0x00},
+
+	{0xfc,0x22},             
+	{0x05,0xca},	// CRWB
+	{0x07,0xc8},	// CBWB
+
+	{0xfc,0x00},
+	{0x30,0x00},
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_awb_daylight[] = {
+	//===================================
+	//	CameraWB_Daylight
+	//===================================
+
+	{0xfc,0x00},             
+	{0x04,0x00},
+	{0x05,0x00},
+
+	{0xfc,0x22},             
+	{0x05,0xd0},	// CRWB
+	{0x07,0x98},	// CBWB
+
+	{0xfc,0x00},
+	{0x30,0x02},
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_awb_incandescent[] = {
+//==========================================================
+//	CAMERA_WB_Tungsten  
+//==========================================================
+
+	{0xfc,0x00},             
+	{0x04,0x00},
+	{0x05,0x00},
+	{0xfc,0x22},            
+	{0x05,0xa0},  //9d	// CRWB
+	{0x07,0xdc},  //e0//f5// CBWB
+	{0xfc,0x00},
+	{0x30,0x02},
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_awb_fluorescent[] = {
+	//===================================
+	//	CameraWB_fluorescent
+	//===================================
+
+	{0xfc,0x00},             
+	{0x04,0x00},
+	{0x05,0x00},
+
+	{0xfc,0x22},             
+	{0x05,0xb0},	// CRWB
+	{0x07,0xbf},	// CBWB
+
+	{0xfc,0x00},
+	{0x30,0x02},
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_awb_cloudy[] = {
+	//===================================
+	//	CameraWB_Cloudy
+	//===================================
+	{0xfc,0x00},             
+	{0x04,0x00},
+	{0x05,0x00},
+
+	{0xfc,0x22},             
+	{0x05,0xe8},	// CRWB
+	{0x07,0x90},	// CBWB
+
+	{0xfc,0x00},
+	{0x30,0x05},
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_awb_sunset[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_awb[6] =
+{
+	sensor_awb_auto,
+	sensor_awb_daylight,
+	sensor_awb_incandescent,
+	sensor_awb_fluorescent,
+	sensor_awb_cloudy,
+	sensor_awb_sunset
+	
+};
+
+
+static struct sensor_reg sensor_iso_auto[] = {
+	//===================================
+	//	CameraIso_Auto 
+	//===================================
+
+	{0xfc,0x00},
+	{0x6c,0xa0},
+	{0x6d,0x00},
+	{0x78,0x6a},
+
+	{0xfc,0x01},
+	{0x2b,0x02},  // Gr_H
+	{0x2c,0x90},  // Gr_L
+	{0x2d,0x02},  // Gb_H
+	{0x2e,0x90},  // Gb_L
+	{0x2f,0x02},  // R_H 
+	{0x30,0x90},  // R_L 
+	{0x31,0x02},  // B_H 
+	{0x32,0x90},  // B_L 
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_iso_100[] = {
+	//===================================
+	//	CameraIso_100 
+	//===================================
+
+	{0xfc,0x00},
+	{0x6c,0x98},
+	{0x6d,0x00},
+	{0x78,0x6b},
+
+	{0xfc,0x01},
+	{0x2b,0x02},  // Gr_H
+	{0x2c,0xc0},  // Gr_L
+	{0x2d,0x02},  // Gb_H
+	{0x2e,0xc0},  // Gb_L
+	{0x2f,0x02},  // R_H 
+	{0x30,0xc0},  // R_L 
+	{0x31,0x02},  // B_H 
+	{0x32,0xc0},  // B_L 
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_iso_200[] = {
+	//===================================
+	//	CameraIso_200 
+	//===================================
+	{0xfc,0x00},
+	{0x6c,0xd0},
+	{0x6d,0x00},
+	{0x78,0x70},
+
+	{0xfc,0x01},
+	{0x2b,0x03},  // Gr_H
+	{0x2c,0x80},  // Gr_L
+	{0x2d,0x03},  // Gb_H
+	{0x2e,0x80},  // Gb_L
+	{0x2f,0x03},  // R_H 
+	{0x30,0x80},  // R_L 
+	{0x31,0x03},  // B_H 
+	{0x32,0x80},  // B_L 
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_iso_400[] = {
+	//===================================
+	//	CameraIso_400 
+	//===================================
+
+	{0xfc,0x00},
+	{0x6c,0x40},
+	{0x6d,0x01},
+	{0x78,0x6d},
+
+	{0xfc,0x01},
+	{0x2b,0x04},  // Gr_H
+	{0x2c,0x00},  // Gr_L
+	{0x2d,0x04},  // Gb_H
+	{0x2e,0x00},  // Gb_L
+	{0x2f,0x04},  // R_H 
+	{0x30,0x00},  // R_L 
+	{0x31,0x04},  // B_H 
+	{0x32,0x00},  // B_L 
+	{REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_iso[4] =
+{
+	sensor_iso_auto,
+	sensor_iso_100,
+	sensor_iso_200,
+	sensor_iso_400
+};
+
+
+static struct sensor_reg sensor_effect_normal[] = {
+	
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_effect_gray[] = {
+	
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_effect_negative[] = {
+	
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_effect_sepia[] = {
+	
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_effect_sharpness[] = {
+	
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_effect_sketch[] = {
+	
+    {REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_effect[6] =
+{
+	sensor_effect_normal,
+	sensor_effect_gray,
+	sensor_effect_negative,
+	sensor_effect_sepia,
+	sensor_effect_sharpness,
+	sensor_effect_sketch,
+};
+
+static struct sensor_reg sensor_reg_flipnone[] = {
+	//===================================
+	//	CAMERA_FLIP_NONE  (1/4)
+	//===================================
+	{0xfc,0x20},
+	{0x0f,0x00},        // Weight Mirrored  (0 - 63)
+	{0xfc,0x00},
+	{0x75,0x04},
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_reg_hflip[] = {
+	//===================================
+	//	CAMERA_FLIP_MIRROR_ONLY  (2/4)
+	//===================================
+	{0xfc,0x20},
+	{0x0f,0x00},        // Weight Mirrored  (0 - 63)
+	{0xfc,0x00},
+	{0x75,0x06},
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_reg_vflip[] = {
+	//===================================
+	//	CAMERA_FLIP_WATER_ONLY   (3/4)
+	//===================================
+	{0xfc,0x20},
+	{0x0f,0x01},        // Weight Mirrored  (63 - 0)
+	{0xfc,0x00},
+	{0x75,0x07},
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_reg_hvflip[] = {
+	//===================================
+	//	CAMERA_FLIP_WATER_MIRROR (4/4)
+	//===================================
+	{0xfc,0x20},
+	{0x0f,0x01},       // Weight Mirrored  (63 - 0)
+	{0xfc,0x00},
+	{0x75,0x05},
+    {REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_flip[4] =
+{
+	sensor_reg_flipnone,
+	sensor_reg_hflip,
+	sensor_reg_vflip,
+	sensor_reg_hvflip,
+};
+
+
+static struct sensor_reg sensor_secne_auto[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_secne_night[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_secne_landscape[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_secne_portrait[] = {
+	{REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_secne_sport[] = {
+	{REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_scene[5] =
+{
+	sensor_secne_auto,
+	sensor_secne_night,
+	sensor_secne_landscape,
+	sensor_secne_portrait,
+	sensor_secne_sport
+};
+
+static struct sensor_reg sensor_me_mtrix[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_me_center_weighted[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_me_spot[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_metering_exposure[3] =
+{
+	sensor_me_mtrix,
+	sensor_me_center_weighted,
+	sensor_me_spot,
+};
+
+static struct sensor_reg sensor_af_single[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+static struct sensor_reg sensor_af_manual[] = {
+    {REG_TERM, VAL_TERM}
+};
+
+struct sensor_reg* sensor_reg_af[2] =
+{
+	sensor_af_single,
+	sensor_af_manual,
+};
+
+#endif
+
Index: linux-2.6.29/drivers/media/video/tcccam/s5k4bafb_2mp.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/tcccam/s5k4bafb_2mp.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,63 @@
+/*
+ * drivers/media/video/tcccam/s5k4bafb_2mp.h
+ *
+ * Register definitions for the s5k4bafb CameraChip.
+ *
+ * Author: zzau (zzau@telechips.com)
+ *
+ * Copyright (C) 2008 Telechips, Inc.
+ *
+ * This file is licensed under the terms of the GNU General Public License 
+ * version 2. This program is licensed "as is" without any warranty of any 
+ * kind, whether express or implied.
+ */
+
+#ifndef S5K4BAFB_H
+#define S5K4BAFB_H
+
+/* The S5K4BAFB I2C sensor chip has a fixed slave address of 0x5D. */
+#define SENSOR_I2C_ADDR		0x52
+
+#define REG_TERM 0xFF	/* terminating list entry for reg */
+#define VAL_TERM 0xFF	/* terminating list entry for val */
+
+
+// ZOOM Setting!!
+#define PRV_W			800
+#define PRV_H			600
+#define PRV_ZOFFX		8
+#define PRV_ZOFFY		6
+
+#define CAP_W			1600
+#define CAP_H			1200
+#define CAP_ZOFFX		16
+#define CAP_ZOFFY		12
+
+#define CAM_2XMAX_ZOOM_STEP 	25
+#define CAM_CAPCHG_WIDTH  		800
+
+
+struct sensor_reg {
+	unsigned char reg;
+	unsigned char val[1];
+};
+
+struct capture_size {
+	unsigned long width;
+	unsigned long height;
+};
+
+extern struct capture_size sensor_sizes[];
+
+extern struct sensor_reg* sensor_reg_common[];
+extern struct sensor_reg* sensor_reg_brightness[];
+extern struct sensor_reg* sensor_reg_awb[];
+extern struct sensor_reg* sensor_reg_iso[];
+extern struct sensor_reg* sensor_reg_effect[];
+extern struct sensor_reg* sensor_reg_flip[];
+extern struct sensor_reg* sensor_reg_scene[];
+extern struct sensor_reg* sensor_reg_metering_exposure[];
+extern struct sensor_reg* sensor_reg_af[];
+
+#endif /* S5K4BAFB_H */
+
Index: linux-2.6.29/drivers/media/video/tcccam/sensor_if.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/tcccam/sensor_if.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,831 @@
+
+/*
+ * drivers/media/video/tcccam/sensor_if.c
+ *
+ * COMMON Sensor driver for  camera sensor interface
+ *
+ *
+ *
+ * This file is licensed under the terms of the GNU General Public License 
+ * version 2. This program is licensed "as is" without any warranty of any 
+ * kind, whether express or implied.
+ */
+
+#include <linux/errno.h>
+#include <linux/i2c.h>
+#include <linux/videodev.h>
+#include <linux/videodev2.h>
+//#include <media/video-buf.h>
+#include <linux/delay.h>
+#include <asm/mach-types.h>
+
+#include <asm/io.h>
+
+#include <bsp.h>
+#include "tcc_cam_i2c.h"  
+
+#include "sensor_if.h"
+#include "tdd_cif.h"
+#include "cam.h"
+
+#ifdef USING_HW_I2C
+#include <linux/i2c.h>
+#endif
+
+#ifdef USING_HW_I2C
+static int enabled = 0;
+#define SENSOR_DEVICE_I2C (SENSOR_I2C_ADDR>>1)
+static unsigned short probe[] = { 0, SENSOR_DEVICE_I2C, I2C_CLIENT_END };
+static unsigned short dummy[] = {I2C_CLIENT_END};
+
+static struct i2c_client_address_data addr_data = {
+	.normal_i2c = dummy,
+	.probe      = probe,
+	.ignore     = dummy,
+};
+
+static struct i2c_driver cam_i2c_driver;
+static struct i2c_client *cam_i2c_client = NULL;
+
+#if 0
+static void TOUCH_SEND_CMD(unsigned char reg, unsigned char val)
+{
+	unsigned char cmd[1];
+	cmd[0] = val;
+	i2c_master_send(cam_i2c_client, cmd, 1);
+}
+
+static void TOUCH_READ_DAT(unsigned char reg, unsigned int val)
+{
+	unsigned char *buf;
+	buf = (unsigned char *)val;
+	i2c_master_recv(cam_i2c_client, buf, 2);
+}
+#endif
+
+static int cam_i2c_probe(struct i2c_adapter *adap, int addr, int kind)
+{
+    struct i2c_client *i2c;
+    int ret;
+
+    i2c = kzalloc(sizeof(*i2c), GFP_KERNEL);
+    if (!i2c)
+        return -ENOMEM;
+
+    strcpy(i2c->name, "CAM_SENSOR");
+    i2c->flags = 0;
+    i2c->addr = addr;
+    i2c->adapter = adap;
+    i2c->driver = &cam_i2c_driver;
+
+    cam_i2c_client = i2c;
+
+    /* attach i2c client device */
+    ret = i2c_attach_client(i2c);
+    if (ret < 0) {
+        printk("%s: failed to attach codec at addr %x\n", __func__, addr);
+        goto err;
+    }
+
+    return ret;
+err:
+    kfree(i2c);
+    return ret;
+}
+
+static int cam_i2c_detach(struct i2c_client *client)
+{
+	i2c_detach_client(client);
+
+	if(cam_i2c_client)
+	{
+		kfree(cam_i2c_client);
+		cam_i2c_client = NULL;
+	}
+	return 0;
+}
+
+static int cam_i2c_attach(struct i2c_adapter *adap)
+{
+    return i2c_probe(adap, &addr_data, cam_i2c_probe);
+}
+
+/* tsc2003 i2c codec control layer */
+static struct i2c_driver cam_i2c_driver = {
+    .driver = {
+        .name   = "tcc-cam-sensor",
+        .owner  = THIS_MODULE,
+    },
+    .id             = I2C_DRIVERID_SENSOR,
+    .attach_adapter = cam_i2c_attach,
+    .detach_client  = cam_i2c_detach,
+    .command        = NULL,
+};
+#endif
+
+/* list of image formats supported by sensor sensor */
+const static struct v4l2_fmtdesc sensor_formats[] = {
+	{
+		/* Note:  V4L2 defines RGB565 as:
+		 *
+		 *	Byte 0			  Byte 1
+		 *	g2 g1 g0 r4 r3 r2 r1 r0	  b4 b3 b2 b1 b0 g5 g4 g3
+		 *
+		 * We interpret RGB565 as:
+		 *
+		 *	Byte 0			  Byte 1
+		 *	g2 g1 g0 b4 b3 b2 b1 b0	  r4 r3 r2 r1 r0 g5 g4 g3
+		 */
+		.description	= "RGB565, le",
+		.pixelformat	= V4L2_PIX_FMT_RGB565,
+	},{
+		/* Note:  V4L2 defines RGB565X as:
+		 *
+		 *	Byte 0			  Byte 1
+		 *	b4 b3 b2 b1 b0 g5 g4 g3	  g2 g1 g0 r4 r3 r2 r1 r0
+		 *
+		 * We interpret RGB565X as:
+		 *
+		 *	Byte 0			  Byte 1
+		 *	r4 r3 r2 r1 r0 g5 g4 g3	  g2 g1 g0 b4 b3 b2 b1 b0
+		 */
+		.description	= "RGB565, be",
+		.pixelformat	= V4L2_PIX_FMT_RGB565X,
+	},
+	{
+		.description	= "YUYV (YUV 4:2:2), packed",
+		.pixelformat	= V4L2_PIX_FMT_YUYV,
+	},{
+		.description	= "UYVY, packed",
+		.pixelformat	= V4L2_PIX_FMT_UYVY,
+	},
+	{
+		/* Note:  V4L2 defines RGB555 as:
+		 *
+		 *	Byte 0			  Byte 1
+		 *	g2 g1 g0 r4 r3 r2 r1 r0	  x  b4 b3 b2 b1 b0 g4 g3
+		 *
+		 * We interpret RGB555 as:
+		 *
+		 *	Byte 0			  Byte 1
+		 *	g2 g1 g0 b4 b3 b2 b1 b0	  x  r4 r3 r2 r1 r0 g4 g3
+		 */
+		.description	= "RGB555, le",
+		.pixelformat	= V4L2_PIX_FMT_RGB555,
+	},{
+		/* Note:  V4L2 defines RGB555X as:
+		 *
+		 *	Byte 0			  Byte 1
+		 *	x  b4 b3 b2 b1 b0 g4 g3	  g2 g1 g0 r4 r3 r2 r1 r0
+		 *
+		 * We interpret RGB555X as:
+		 *
+		 *	Byte 0			  Byte 1
+		 *	x  r4 r3 r2 r1 r0 g4 g3	  g2 g1 g0 b4 b3 b2 b1 b0
+		 */
+		.description	= "RGB555, be",
+		.pixelformat	= V4L2_PIX_FMT_RGB555X,
+	}
+};
+
+#define NUM_CAPTURE_FORMATS ARRAY_SIZE(sensor_formats)
+
+#if defined(SENSOR_2M)
+enum image_size { UXGA, SXGA, XGA, SVGA, VGA, QVGA, QCIF};
+#define NUM_IMAGE_SIZES 7
+#elif defined(SENSOR_3M)
+enum image_size { QXGA, UXGA, SXGA, XGA, SVGA, VGA, QVGA, QCIF};
+#define NUM_IMAGE_SIZES 8
+#elif defined(SENSOR_5M)
+enum image_size { QQXGA, QXGA, UXGA, SXGA, XGA, SVGA, VGA, QVGA, QCIF};
+#define NUM_IMAGE_SIZES 9
+#endif
+
+enum pixel_format { YUV, RGB565, RGB555 };
+#define NUM_PIXEL_FORMATS 3
+
+
+//need to revised  MCC
+#ifdef CONFIG_ARCH_OMAP24XX
+#define NUM_OVERLAY_FORMATS 4
+#else
+#define NUM_OVERLAY_FORMATS 2
+#endif
+
+
+#define DEF_BRIGHTNESS      	3
+#define DEF_ISO      			0
+#define DEF_AWB           		0
+#define DEF_EFFECT				0
+#define DEF_ZOOM				0
+#define DEF_FLIP				0
+#define DEF_SCENE				0
+#define DEF_METERING_EXPOSURE	0
+#define DEF_FLASH				0
+
+
+/* Our own specific controls */
+#define V4L2_CID_ISO 					V4L2_CID_PRIVATE_BASE+0
+#define V4L2_CID_EFFECT  				V4L2_CID_PRIVATE_BASE+1
+#define V4L2_CID_ZOOM					V4L2_CID_PRIVATE_BASE+2
+#define V4L2_CID_FLIP					V4L2_CID_PRIVATE_BASE+3
+#define V4L2_CID_SCENE					V4L2_CID_PRIVATE_BASE+4
+#define V4L2_CID_METERING_EXPOSURE		V4L2_CID_PRIVATE_BASE+5
+#define V4L2_CID_FLASH					V4L2_CID_PRIVATE_BASE+6
+
+#define V4L2_CID_LAST_PRIV				V4L2_CID_FLASH
+
+
+/*  Video controls  */
+static struct vcontrol {
+        struct v4l2_queryctrl qc;
+        int current_value;
+} control[] = {
+        { { V4L2_CID_BRIGHTNESS, V4L2_CTRL_TYPE_INTEGER, "Brightness", 0, 4, 1,
+            DEF_BRIGHTNESS },
+          0},
+          
+        { { V4L2_CID_AUTO_WHITE_BALANCE, V4L2_CTRL_TYPE_INTEGER, "Auto White Balance", 0,5,1,
+            DEF_AWB },
+          0},
+
+        { { V4L2_CID_ISO, V4L2_CTRL_TYPE_INTEGER, "Iso", 0, 3, 1,
+            DEF_ISO },
+          0},
+          
+        { { V4L2_CID_EFFECT, V4L2_CTRL_TYPE_INTEGER, "Special Effect", 0, 6, 1,
+            DEF_EFFECT },
+          0},
+          
+        { { V4L2_CID_ZOOM, V4L2_CTRL_TYPE_INTEGER, "Zoom", 0, 25, 1,
+            DEF_ZOOM },
+          0},    
+                    
+        { { V4L2_CID_FLIP, V4L2_CTRL_TYPE_INTEGER, "Flip", 0, 3, 1,
+            DEF_FLIP },
+          0},
+          
+        { { V4L2_CID_SCENE, V4L2_CTRL_TYPE_INTEGER, "Scene", 0, 5, 1,
+            DEF_SCENE},
+          0},  
+          
+        { { V4L2_CID_METERING_EXPOSURE, V4L2_CTRL_TYPE_INTEGER, "Metering Exposure", 0, 3, 1,
+            DEF_METERING_EXPOSURE},
+          0},
+          
+        { { V4L2_CID_FLASH, V4L2_CTRL_TYPE_INTEGER, "Flash", 0, 4, 1,
+            DEF_FLASH},
+          0},	
+};
+
+
+unsigned int sensor_control[] = 
+{
+	V4L2_CID_BRIGHTNESS,
+	V4L2_CID_AUTO_WHITE_BALANCE,
+	V4L2_CID_ISO,
+	//V4L2_CID_EFFECT,
+	//V4L2_CID_ZOOM,
+	V4L2_CID_FLIP,
+	V4L2_CID_SCENE,
+	V4L2_CID_METERING_EXPOSURE,
+	//V4L2_CID_FLASH
+};
+
+
+extern u8 current_effect_mode;
+extern int tccxxx_cif_set_effect (u8 nCameraEffect);
+extern int tccxxx_cif_set_zoom(unsigned char arg);
+extern int CAMERA_SEND_CMD(unsigned char hb, unsigned short lb);
+
+#ifdef USING_HW_I2C
+int sensor_write(ushort reg, ushort *val)
+{
+	unsigned char data[25];
+	unsigned char bytes;
+
+#if defined(CONFIG_VIDEO_CAMERA_SENSOR_MT9P111)
+	unsigned int cnt;
+
+	if(reg == REG_TERM && val[1] == VAL_END)
+	{
+		mdelay(val[0]);
+		printk("Sensor init Delay[%d]!!!! \n", val[0]);
+		return 0;
+	}
+	
+	data[0]= reg>>8;
+	data[1]= (u8)reg&0xff;
+	
+	for( cnt = 0; cnt<25 ; cnt++)
+	{
+		if(val[cnt] == VAL_END)
+			break;
+		
+		data[(cnt+1)*2] = val[cnt] >> 8;
+		data[(cnt+1)*2+1] = (char)val[cnt] & 0xff;
+	}
+
+	bytes = cnt*2 + 2;
+	//printk("write[0x%x, 0x%x (cnt:%d)]!!!! \n", reg, val[0], bytes);
+	
+#elif defined(CONFIG_VIDEO_CAMERA_SENSOR_MT9D112)
+
+	if (reg == CAMDLY)
+	{
+		mdelay(val[0]);
+		return 0;
+	}
+
+	data[0]= reg>>8;
+	data[1]= (u8)reg&0xff;
+	data[2]= val[0]>>8;
+	data[3]=(u8)val[0]&0xff;
+	bytes = 4;
+#elif defined(CONFIG_VIDEO_CAMERA_SENSOR_MT9D111)
+	data[0]= (u8)reg&0xff;
+	data[1]= val[0]>>8;
+	data[2]=(u8)val[0]&0xff;
+	bytes = 3;
+#else
+	data[0]= (u8)reg&0xff;
+	data[1]=(u8)val[0]&0xff;
+	bytes = 2;
+#endif
+	
+	if (i2c_master_send(cam_i2c_client, data, bytes) == bytes)
+	{
+	     mdelay(1);				
+	     return 0;
+	}
+	else
+	{
+		printk("write error!!!! \n");
+	    return -EIO;    
+	}
+}
+
+inline int sensor_read(u8 reg)
+{
+    int val;
+
+
+    return val;
+}
+#endif
+
+int sensor_write_regs(const struct sensor_reg reglist[])
+{
+	int err;
+	int err_cnt = 0;
+	int total_cnt = 0;
+	const struct sensor_reg *next = reglist;
+	
+	while (!((next->reg == REG_TERM) && (next->val[0] == VAL_TERM)))
+	{
+#ifdef USING_HW_I2C
+        err = sensor_write(next->reg, next->val);
+        //udelay(100);
+        if (err)
+        {
+            printk("try write!!!! \n");   
+			err_cnt++;
+			if(err_cnt >= 3)
+			{
+				printk("ERROR: Sensor I2C !!!! \n"); 
+				return err;
+			}
+        }
+        else
+        {
+        	total_cnt++;
+            next++;
+        }
+#else              
+		err= CAMERA_SEND_CMD(next->reg, next->val);
+		if(err)
+		{
+			total_cnt++;
+			err_cnt = 0;
+			next++;		
+		}
+		else
+		{
+			printk("try write!!!! \n"); 
+			err_cnt++;
+			if(err_cnt >= 3)
+			{
+				printk("ERROR: Sensor I2C !!!! \n"); 
+				return err;
+			}
+		}
+#endif 
+	}
+
+	printk("I2C %d write Success!!!! \n", total_cnt); 
+
+	return 0;
+}
+
+int sensor_change_mode(unsigned char capture_mode)
+{
+    int ret=0;
+
+	if(capture_mode)
+		ret = sensor_write_regs(sensor_reg_common[2]);
+	else
+	{
+#if defined(CONFIG_VIDEO_CAMERA_SENSOR_MT9D112)
+		ret = sensor_write_regs(sensor_reg_common[0]);
+		mdelay(10);
+#endif
+		ret = sensor_write_regs(sensor_reg_common[1]);
+//		mdelay(10);
+	}
+	
+    return ret;
+}
+
+int sensor_adjust_autofocus(void)
+{
+	sensor_write_regs(sensor_reg_af[0]);
+}
+
+/* Returns the index of the requested ID from the control structure array */
+static int find_vctrl(int id)
+{
+	int i;
+	int ctrl_cnt = ARRAY_SIZE(control);
+
+	if (id < V4L2_CID_BASE)
+		return -EDOM;
+
+	for (i = ctrl_cnt - 1; i >= 0; i--)
+	{
+		if (control[i].qc.id == id)
+			break;
+	}
+
+	if (i < 0)
+		i = -EINVAL;
+	
+	return i;
+}
+
+
+/* initialize Sensor after module was reset. */
+int sensor_init_module(enum image_size isize, enum pixel_format pfmt,unsigned long xclk)
+{
+	int err;
+
+	/* common register initialization */
+#if defined(CONFIG_VIDEO_CAMERA_SENSOR_MT9D112)
+#else
+	err = sensor_write_regs(sensor_reg_common[0]);
+	if (err)
+		return err;
+#endif
+
+	return 0;
+}
+
+
+/* Find the best match for a requested image capture size.  The best match 
+ * is chosen as the nearest match that has the same number or fewer pixels 
+ * as the requested size, or the smallest image size if the requested size 
+ * has fewer pixels than the smallest image.
+ */
+static enum image_size sensor_find_size(unsigned int width, unsigned int height)
+{
+	enum image_size isize;
+	unsigned long pixels = width*height;
+
+	for (isize = 0; isize < (NUM_IMAGE_SIZES-1); isize++) {
+		if (sensor_sizes[isize + 1].height*
+			sensor_sizes[isize + 1].width > pixels)
+		{
+			return isize;
+		}
+	}
+	return UXGA;
+}
+
+/* following are sensor interface functions implemented by 
+ * sensor driver.
+ */
+int sensor_query_control(struct v4l2_queryctrl *qc)
+{
+	int i;
+
+	i = find_vctrl (qc->id);
+	if (i == -EINVAL) 
+	{
+		qc->flags = V4L2_CTRL_FLAG_DISABLED;
+		return 0;
+	}
+	
+	if (i < 0)
+		return -EINVAL;
+
+	*qc = control[i].qc;
+	
+	return 0;
+}
+
+int sensor_get_control(struct v4l2_control *vc)
+{
+	int i;
+	struct vcontrol * lvc;
+	
+	if((i = find_vctrl(vc->id)) < 0)
+		return -EINVAL;
+
+	lvc = &control[i];	
+	vc->value = lvc->current_value;
+	
+	return 0;
+}
+
+int sensor_set_control(struct v4l2_control *vc)
+{	
+	struct vcontrol *lvc;
+	int val = vc->value;
+	int i;
+	int err;
+	
+	if((i = find_vctrl(vc->id)) < 0)
+		return -EINVAL;
+
+	lvc = &control[i];
+
+	if(lvc->qc.maximum < val)
+		return val;
+
+	switch(vc->id)
+	{
+		case V4L2_CID_BRIGHTNESS:
+			err = sensor_write_regs(sensor_reg_brightness[val]);
+		break;
+
+		case V4L2_CID_AUTO_WHITE_BALANCE:
+			err = sensor_write_regs(sensor_reg_awb[val]);
+		break;
+
+		case V4L2_CID_ISO:
+			err = sensor_write_regs(sensor_reg_iso[val]);
+		break;
+
+		case V4L2_CID_EFFECT:
+			err = tccxxx_cif_set_effect(val);
+			//err = sensor_write_regs(sensor_reg_effect[val]);
+		break;
+			
+		case V4L2_CID_ZOOM:
+			err = tccxxx_cif_set_zoom(val);
+			break;
+			
+		case V4L2_CID_FLIP:
+			err = sensor_write_regs(sensor_reg_flip[val]);
+		break;
+
+		case V4L2_CID_SCENE:
+			err = sensor_write_regs(sensor_reg_scene[val]);
+		break;
+			
+		case V4L2_CID_METERING_EXPOSURE:
+			err = sensor_write_regs(sensor_reg_metering_exposure[val]);
+			break;
+			
+		case V4L2_CID_FLASH:
+			//err = ;
+			break;	
+
+			
+		default:
+			break;	
+		
+	}
+	
+	lvc->current_value = val;
+	
+	return 0;
+}
+
+
+/* In case of ESD-detection, to set current value in sensor after module was resetted. */
+int sensor_set_current_control(void)
+{
+	struct v4l2_control vc;
+	int i;
+	int ctrl_cnt = ARRAY_SIZE(sensor_control);
+
+	printk("Setting Sensor-ctrl!! %d /n", ctrl_cnt);
+	
+	for (i = ctrl_cnt - 1; i >= 0; i--)
+	{
+		vc.id = sensor_control[i];
+		sensor_get_control(&vc);
+		sensor_set_control(&vc);
+	}
+
+	return 0;
+}
+
+/* Implement the VIDIOC_ENUM_FMT ioctl for the CAPTURE buffer type.
+ */
+int sensor_enum_pixformat(struct v4l2_fmtdesc *fmt)
+{
+	int index = fmt->index;
+	enum v4l2_buf_type type = fmt->type;
+
+	memset(fmt, 0, sizeof(*fmt));
+	fmt->index = index;
+	fmt->type = type;
+
+	switch (fmt->type) {
+		case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		if (index >= NUM_CAPTURE_FORMATS)
+			return -EINVAL;
+		break;
+
+		case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+		if (index >= NUM_OVERLAY_FORMATS)
+			return -EINVAL;
+		break;
+
+		default:
+			return -EINVAL;
+	}
+
+	fmt->flags = sensor_formats[index].flags;
+	strlcpy(fmt->description, sensor_formats[index].description, sizeof(fmt->description));
+	fmt->pixelformat = sensor_formats[index].pixelformat;
+
+	return 0;
+}
+
+/* Implement the VIDIOC_TRY_FMT ioctl for the CAPTURE buffer type.  This 
+ * ioctl is used to negotiate the image capture size and pixel format 
+ * without actually making it take effect.
+ */
+static int sensor_try_format(struct v4l2_pix_format *pix)
+{
+	enum image_size isize;
+	int ifmt;
+
+	isize = sensor_find_size(pix->width, pix->height);
+	pix->width  = sensor_sizes[isize].width;
+	pix->height = sensor_sizes[isize].height;
+	
+	for (ifmt = 0; ifmt < NUM_CAPTURE_FORMATS; ifmt++) 
+	{
+		if (pix->pixelformat == sensor_formats[ifmt].pixelformat)
+			break;
+	}
+	
+	if (ifmt == NUM_CAPTURE_FORMATS)
+		ifmt = 0;
+	
+	pix->pixelformat = sensor_formats[ifmt].pixelformat;
+	pix->field = V4L2_FIELD_NONE;
+	pix->bytesperline = pix->width*2;
+	pix->sizeimage = pix->bytesperline*pix->height;
+	pix->priv = 0;
+	
+	switch (pix->pixelformat) 
+	{
+		case V4L2_PIX_FMT_YUYV:
+		case V4L2_PIX_FMT_UYVY:
+		default:
+			pix->colorspace = V4L2_COLORSPACE_JPEG;
+			break;
+			
+		case V4L2_PIX_FMT_RGB565:
+		case V4L2_PIX_FMT_RGB565X:
+		case V4L2_PIX_FMT_RGB555:
+		case V4L2_PIX_FMT_RGB555X:
+			pix->colorspace = V4L2_COLORSPACE_SRGB;
+			break;
+	}
+	
+	return 0;
+}
+
+
+
+/* Given a capture format in pix, the frame period in timeperframe, and
+ * the xclk frequency, set the capture format of the sensor.
+ * The actual frame period will be returned in timeperframe.
+ */
+int sensor_configure(struct v4l2_pix_format *pix, unsigned long xclk)
+{
+  	enum pixel_format pfmt = YUV;
+
+	switch (pix->pixelformat) {
+		case V4L2_PIX_FMT_RGB565:
+		case V4L2_PIX_FMT_RGB565X:
+			pfmt = RGB565;
+			break;
+		case V4L2_PIX_FMT_RGB555:
+		case V4L2_PIX_FMT_RGB555X:
+			pfmt = RGB555;
+			break;
+		case V4L2_PIX_FMT_YUYV:
+		case V4L2_PIX_FMT_UYVY:
+		default:
+			pfmt = YUV;
+ 	}
+
+	return sensor_init_module(sensor_find_size(pix->width, pix->height), pfmt, xclk);
+}
+
+
+/* Initialize the sensor.
+ * This routine allocates and initializes the data structure for the sensor, 
+ * powers up the sensor, registers the I2C driver, and sets a default image 
+ * capture format in pix.  The capture format is not actually programmed 
+ * into the sensor by this routine.
+ * This function must return a non-NULL value to indicate that 
+ * initialization is successful.
+ */
+int sensor_init(struct v4l2_pix_format *pix)
+{
+ 	int ret;
+
+	//memset(&cam_sensor, 0x00, sizeof(struct dev_sensor));
+	TDD_CIF_Initialize();
+	//msleep(5);
+
+
+#ifdef USING_HW_I2C
+	if(!enabled)
+	{
+		ret = i2c_add_driver(&cam_i2c_driver);
+		if (ret != 0)
+		{
+	        printk(KERN_ERR "Failed to register Sensor I2C client.\n");
+	        return ENODEV;
+	    }
+		enabled = 1;
+	}
+#else 
+	DDI_I2C_Initialize();
+	i2c_init();       
+#endif 
+
+	/* Make the default capture format QVGA YUV422 */
+	pix->width = sensor_sizes[VGA].width;
+	pix->height = sensor_sizes[VGA].height;
+	pix->pixelformat = V4L2_PIX_FMT_YUYV;
+	sensor_try_format(pix);
+	
+	return 0;
+}
+
+/* Prepare for the driver to exit.
+ * Balances sensor_init().
+ * This function must de-initialize the sensor and its associated data 
+ * structures.
+ */
+int sensor_cleanup(void)
+{
+#ifdef USING_HW_I2C
+	if(enabled)
+	{
+		i2c_del_driver(&cam_i2c_driver);
+
+		if(cam_i2c_client)
+		{
+			kfree(cam_i2c_client);
+			cam_i2c_client = NULL;
+		}
+		enabled = 0;
+	}
+#endif 
+
+    return 0;
+}
+
+/* ----------------------------------------------------------------------- */
+
+
+
+#if 0
+static int __init sensor_init_module(void)
+{
+    return i2c_add_driver(&i2c_driver_sensor);
+}
+
+static int __exit sensor_exit(void)
+{
+    i2c_del_driver();
+}
+
+module_init(sensor_init_module);
+module_exit(sensor_exit);
+#endif
+
+MODULE_DESCRIPTION("Camera SENSOR  driver");
+MODULE_AUTHOR("Telechips");
+MODULE_LICENSE("GPL");
+
Index: linux-2.6.29/drivers/media/video/tcccam/sensor_if.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/tcccam/sensor_if.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,61 @@
+/*
+ * drivers/media/video/tcccam/sensor_if.h
+ *
+ * Copyright (C) 2008 Telechips, Inc. 
+ *
+ * Sensor interface to TCC camera capture drivers
+ * Sensor driver should implement this interface
+ *
+ * This package is free software; you can redistribute it and/or modify 
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation. 
+ * 
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR 
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED 
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. 
+ */
+
+#include <linux/videodev2.h>
+
+#ifndef TCC_SENSOR_IF_H
+#define TCC_SENSOR_IF_H
+
+#define USING_HW_I2C
+
+#if defined(CONFIG_VIDEO_CAMERA_SENSOR_MT9P111)
+#define SENSOR_5M
+#define I2C_DRIVERID_SENSOR	I2C_DRIVERID_MT9P111
+#include "mt9p111_5mp.h"
+#elif defined(CONFIG_VIDEO_CAMERA_SENSOR_MV9317)
+#define SENSOR_3M
+#define I2C_DRIVERID_SENSOR	I2C_DRIVERID_MV9317
+#include "mv9317_3mp.h"
+#elif defined(CONFIG_VIDEO_CAMERA_SENSOR_MT9D111)
+#define SENSOR_2M
+#define I2C_DRIVERID_SENSOR	I2C_DRIVERID_MT9D111
+#include "mt9d111_2mp.h"
+#elif defined(CONFIG_VIDEO_CAMERA_SENSOR_MT9D112)
+#define SENSOR_2M
+#define I2C_DRIVERID_SENSOR	I2C_DRIVERID_MT9D112
+#include "mt9d112_2mp.h"
+#elif defined(CONFIG_VIDEO_CAMERA_SENSOR_S5K4BAFB)
+#define SENSOR_2M
+#define I2C_DRIVERID_SENSOR	I2C_DRIVERID_S5K4BAFB
+#define TCC_VCORE_30FPS_CAMERASENSOR
+#include "s5k4bafb_2mp.h"
+#endif
+
+#define TCC_SENSOR_NAME_LEN		31
+
+extern int sensor_change_mode(unsigned char capture_mode);
+extern int sensor_adjust_autofocus(void);
+extern int sensor_query_control(struct v4l2_queryctrl *qc);
+extern int sensor_get_control(struct v4l2_control *vc);
+extern int sensor_set_control(struct v4l2_control *vc);
+extern int sensor_set_current_control(void);
+extern int sensor_enum_pixformat(struct v4l2_fmtdesc *fmt);
+extern int sensor_configure(struct v4l2_pix_format *pix, unsigned long xclk);	
+extern int sensor_init(struct v4l2_pix_format *pix);
+extern int sensor_cleanup(void);
+
+#endif
Index: linux-2.6.29/drivers/media/video/tcccam/tcc_cam.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/tcccam/tcc_cam.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,1397 @@
+
+/*
+ * drivers/media/video/tcccam/tcc83x_cif.c
+ *
+ * Copyright (C) 2008 Telechips, Inc. 
+ * 
+ * Video-for-Linux (Version 2) camera capture driver for
+ * the TCC78xx camera controller.
+ *
+ * leverage some code from CEE distribution 
+ * Copyright (C) 2003-2004 MontaVista Software, Inc.
+ * 
+ * This package is free software; you can redistribute it and/or modify 
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation. 
+ * 
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR 
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED 
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. 
+ */
+ 
+#include <linux/autoconf.h>
+#include <linux/vmalloc.h>
+#include <linux/slab.h>
+#include <linux/proc_fs.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+
+#include <mach/irqs.h>
+//#include <asm/arch/dma.h>
+#include <mach/hardware.h>
+#include <asm/io.h>
+
+#include <bsp.h>
+
+#include <mach/memory.h>
+#include <asm/scatterlist.h>
+#include <asm/mach-types.h>
+
+#include "sensor_if.h"
+#include "tcc_cam.h"
+#include "camera_hw_if.h"
+#include "camera_core.h"
+#include "tdd_cif.h"
+#include "cam.h"
+#include "cam_reg.h"
+#include "tcc_cam_inc.h"
+
+#if 0
+static int debug	   = 1;
+#else
+static int debug	   = 0;
+#endif
+
+#define dprintk(msg...)	if (debug) { printk( "Tcc_cam: " msg); }
+
+
+#ifdef JPEG_ENCODE_WITH_CAPTURE
+#include "tcc83xx/tcc83xx_jpeg.h"
+#include "tcc83xx/jpeg_param.h"
+
+JPEG_ENC_INFO  gJPEG_ENC_Info;
+JPEG_DEC_INFO  gJPEG_DEC_Info;
+JPEG_BUFFER_CTRL gJPEG_Buffer_Info;
+JPEG_DISPLAY_INFO JPEG_Info;
+jpeg_parser_rsp gJpegInfo;
+extern volatile char gJpegDecodeDone;
+extern volatile char gJpegEncodeDone;
+unsigned char gJpegCodecMode = JPEG_UNKNOWN_MODE;
+extern uint8 gIsExifThumbnailProcess;
+extern jpeg_encode_option_type gEncodeOption;
+
+unsigned char gIsRolling;
+
+void *jpeg_header_remapped_address;   // Header Buffer
+void *jpeg_remapped_base_address;
+
+//#define JPEG_STREAM      	0x180000 //1600*1024
+//#define JPEG_HEADER      	0x020000 //96*1024
+#define JPEG_STREAM      	0x1D0000 //1856*1024
+#define JPEG_HEADER      	0x030000 //192*1024
+
+#define CAPTURE_PHY_ADDRESS	PA_VIDEO_BASE
+#define JPEG_PHY_ADDRESS	PA_VIDEO_BASE + CAPTURE_MEM
+#endif
+
+u8 current_effect_mode = 0;
+struct TCCxxxCIF hardware_data;
+
+void cif_timer_register(void* priv, unsigned long timeover);
+void cif_dma_hw_reg(unsigned char frame_num);
+
+static unsigned char cam_irq = 0;
+static unsigned char skip_frm = 8, skipped_frm = 0;
+
+/* Clears the camera data FIFO by setting RAZ_FIFO bit in MODE configuration
+   register. */
+static void cif_clear_fifo(struct TCCxxxCIF *data)
+{
+ #if 0
+	data->camera_regs->mode |= RAZ_FIFO;
+	udelay(10);
+	data->camera_regs->mode &= ~RAZ_FIFO;
+#endif
+}
+  
+static void cif_reset(struct TCCxxxCIF *data, int yes)
+{
+#if 0    
+	if (machine_is_omap_h3())
+		data->camera_regs->gpio = yes ? 0 : 1;
+	else
+		data->camera_regs->gpio = yes ? 1 : 0;
+#endif
+}
+
+static void cif_data_init(void *priv)
+{
+//  
+	struct TCCxxxCIF *data = (struct TCCxxxCIF *) priv;
+
+	//Default Setting
+	data->cif_cfg.order422 			= CIF_YCBYCR;
+
+#if defined(CONFIG_VIDEO_CAMERA_SENSOR_MT9P111)
+	data->cif_cfg.polarity_pclk 	= POSITIVE_EDGE;
+#else
+	data->cif_cfg.polarity_pclk 	= NEGATIVE_EDGE;
+#endif
+
+#if defined(CONFIG_VIDEO_CAMERA_SENSOR_MV9317)
+	data->cif_cfg.polarity_vsync 	= ACT_LOW;
+#else
+	data->cif_cfg.polarity_vsync 	= ACT_HIGH;
+#endif
+	data->cif_cfg.polarity_href 	= ACT_HIGH;
+
+	data->cif_cfg.oper_mode 		= OPER_PREVIEW;
+	data->cif_cfg.zoom_step			= 0;
+	
+	data->cif_cfg.base_buf			= hardware_data.cif_buf.addr;
+	data->cif_cfg.pp_num			= 0;//TCC_CAMERA_MAX_BUFNBRS;
+	data->cif_cfg.fmt				= M420_ZERO;
+
+	data->cif_cfg.main_set.target_x = 0;
+	data->cif_cfg.main_set.target_y = 0;
+
+	data->cif_cfg.esd_restart 		= OFF;
+
+	data->cif_cfg.cap_status 		= CAPTURE_NONE;
+	data->cif_cfg.retry_cnt			= 0;
+	
+	current_effect_mode = 0;
+
+}
+
+
+static irqreturn_t cif_cam_isr(int irq, void *client_data/*, struct pt_regs *regs*/)
+{
+	struct TCCxxxCIF *data = (struct TCCxxxCIF *)&hardware_data;
+	struct tccxxx_cif_buffer *cif_buf;
+	unsigned int current_frame_num;
+
+	struct tccxxx_cif_buffer *next_1st_buf;
+	unsigned int next_1st_num;
+	
+#ifdef JPEG_ENCODE_WITH_CAPTURE
+	unsigned int uCLineCnt, uTempVCNT;
+#endif
+
+	client_data = client_data;
+
+#ifdef JPEG_ENCODE_WITH_CAPTURE
+	if (data->cif_cfg.oper_mode == OPER_CAPTURE) 
+	{
+		if(TDD_CIF_GetIntStatus(GET_CIF_INT_VCNT_GEN))
+		{
+			if (gIsRolling)
+			{
+				uCLineCnt = HwCIF->HwCCLC;
+				
+				BITSET(HwCIF->HwCIRQ, HwCIRQ_VIT);
+				
+				uTempVCNT = HwCIF->HwCCLC;
+				while(uTempVCNT%FRAME_LINE_CNT == 0 && uTempVCNT != data->cif_cfg.main_set.target_y)
+					uTempVCNT = HwCIF->HwCCLC;
+
+				BITSET(HwCIF->HwCIRQ, HwCIRQ_VIT);
+
+				if(gJpegCodecMode != JPEG_ENCODE_MODE)
+				{
+					gJpegCodecMode = JPEG_ENCODE_MODE;
+					BITCSET(HwJPEGENC->JP_START, 0x0000000F, HwJP_START_RUN);
+					BITCSET(HwJPEGENC->HwJP_SBUF_WCNT, 0x0000FFFF, uCLineCnt);
+				}
+				else if(((uCLineCnt%FRAME_LINE_CNT==0)||(uCLineCnt >= data->cif_cfg.main_set.target_y - FRAME_LINE_CNT)))
+				{
+					if(uCLineCnt >= (data->cif_cfg.main_set.target_y - FRAME_LINE_CNT))
+					{
+						BITCSET(HwJPEGENC->HwJP_SBUF_WCNT, 0x0000FFFF, data->cif_cfg.main_set.target_y);
+					}
+					else
+						BITCSET(HwJPEGENC->HwJP_SBUF_WCNT, 0x0000FFFF, uCLineCnt);
+				}
+			}
+
+			return IRQ_HANDLED;
+		}
+	
+		if(TDD_CIF_GetIntStatus(GET_CIF_INT_ENC_STRT))
+		{
+			BITSET(HwCIF->HwCIRQ, HwCIRQ_ENS);
+		
+			gJpegCodecMode = JPEG_ENCODE_MODE;
+			BITCSET(HwJPEGENC->JP_START, 0x0000000F, HwJP_START_RUN);
+			return IRQ_HANDLED;
+		}
+	}
+#else
+	if(TDD_CIF_GetIntStatus(GET_CIF_INT_ENC_STRT))
+	{
+		data->cif_cfg.now_frame_num = 0;
+		cif_buf = data->buf + data->cif_cfg.now_frame_num;		
+		
+		cif_buf->v4lbuf.bytesused =	data->cif_cfg.main_set.target_x*data->cif_cfg.main_set.target_y*2;
+		cif_buf->v4lbuf.flags &= ~V4L2_BUF_FLAG_QUEUED;
+		cif_buf->v4lbuf.flags |= V4L2_BUF_FLAG_DONE;
+
+		list_move_tail(&cif_buf->buf_list, &data->done_list);		
+
+		data->cif_cfg.cap_status = CAPTURE_DONE;
+
+		wake_up_interruptible(&data->frame_wait); //POLL
+		//if (!list_empty(&data->done_list))
+		//	wake_up(&data->frame_wait);
+		
+		//(CONFIG_ARCH_TCC8900)
+		BITSET(HwCIF->CIRQ, HwCIRQ_ENS);
+		BITSET(HwCIF->CIRQ, HwCIRQ_ENS);
+
+		return IRQ_HANDLED;
+	}
+#endif
+
+	//preview : Stored-One-Frame in DMA
+	if(TDD_CIF_GetIntStatus(GET_CIF_INT_ONEFRAME_STORE))
+	{
+		if(data->stream_state == STREAM_ON)
+		{	
+			TDD_CIF_SetInterrupt(SET_CIF_UPDATE_WITHOUT_VSYNC);
+		
+			if(skip_frm == 0)
+			{
+				current_frame_num = data->cif_cfg.now_frame_num;
+				cif_buf = data->buf + data->cif_cfg.now_frame_num;	
+
+				next_1st_num = (current_frame_num+1) % (data->cif_cfg.pp_num);
+				next_1st_buf = data->buf + next_1st_num;
+
+				if(cif_buf->v4lbuf.flags & V4L2_BUF_FLAG_QUEUED 
+					&& next_1st_buf->v4lbuf.flags & V4L2_BUF_FLAG_QUEUED
+				)
+				{
+					dprintk("[Isr=%d/%d]\n", current_frame_num, data->cif_cfg.pp_num);
+					cif_dma_hw_reg((data->cif_cfg.now_frame_num+1) % (data->cif_cfg.pp_num));
+					
+		//			spin_unlock_irqrestore(&data->dev_lock, flags);
+					cif_buf->v4lbuf.bytesused =	data->cif_cfg.main_set.target_x*data->cif_cfg.main_set.target_y*2;
+		//  		       cif_buf->v4lbuf.sequence = cam->buf_seq[bufno];
+					cif_buf->v4lbuf.flags &= ~V4L2_BUF_FLAG_QUEUED;
+					cif_buf->v4lbuf.flags |= V4L2_BUF_FLAG_DONE;
+		//			spin_lock_irqsave(&data->dev_lock, flags);
+		//			cif_buf->v4lbuf.timestamp = gettimeofday(.., ..);
+
+					list_move_tail(&cif_buf->buf_list, &data->done_list);		
+
+					if (!list_empty(&data->done_list))
+						wake_up(&data->frame_wait);
+					
+				}
+				else
+				{
+					skipped_frm++;
+				}
+			}
+			else
+			{
+				skip_frm--;
+			}
+			
+		//(CONFIG_ARCH_TCC8900)
+			BITSET(HwCIF->CIRQ, HwCIRQ_SOF);
+			BITSET(HwCIF->CIRQ, HwCIRQ_MSOF);
+			BITCLR(HwCIF->CIRQ, HwCIRQ_MSOF);
+
+			TDD_CIF_SetInterrupt(SET_CIF_UPDATE_IN_VSYNC);
+		}		
+
+	}
+
+	return IRQ_HANDLED;
+}
+ 
+/* ------------- below are interface functions ----------------- */
+/* ------------- these functions are named tccxxxcif_<name> -- */
+
+/* Enables the camera. Takes camera out of reset. Enables the clocks. */ 
+static int cif_enable(void *priv)
+{
+	struct TCCxxxCIF *data = (struct TCCxxxCIF *) priv;
+
+	cif_reset(data, 1);
+#if 0	
+	/* give clock to camera_module */
+	data->camera_regs->mode = (FIFO_TRIGGER_LVL << THRESHOLD_BIT);
+	data->camera_regs->ctrlclock = MCLK_EN | CAMEXCLK_EN;
+
+	omap16xx_cam_clear_fifo(data);
+#endif
+	/* wait for camera to settle down */
+	mdelay(5);
+
+	return 0;
+}
+ 
+/* Disables all the camera clocks. Put the camera interface in reset. */
+static int cif_disable(void)
+{ 	
+//	struct TCCxxxCIF *data = (struct TCCxxxCIF *) priv;
+
+	TDD_CIF_Termination();
+	
+//	cif_clear_fifo(data);
+//	cif_reset(data, 0);
+
+	return 0;
+}
+
+static int cif_cleanup(void)
+{  
+	cif_disable();
+	return 0;
+}
+
+
+/* Abort the data transfer */
+static int cif_abort(void *priv)
+{
+#if 0
+
+	return cif_disable();
+#endif 
+}
+
+static int cif_set_xclk(int xclk)
+{
+
+
+#if 0    
+ 	int xclk_val;
+	int divisor = 1;
+	divisor = data->ocp_clk/xclk;
+
+	if ( divisor * xclk < data->ocp_clk)
+		++divisor; 
+
+	switch (divisor) {
+		case 1:
+		case 2:
+			xclk_val = FOSCMOD_TC2_CK2;
+			break;
+		case 3:
+			xclk_val = FOSCMOD_TC2_CK3;
+			break;
+		case 4:
+		case 5:
+		case 6:
+		case 7:
+			xclk_val = FOSCMOD_TC2_CK4;
+			break;
+		case 8:
+		case 9:
+			xclk_val = FOSCMOD_TC2_CK8;
+			break;
+		case 10:
+		case 11:
+			xclk_val = FOSCMOD_TC2_CK10;
+			break;
+		case 12:
+		case 13:
+		case 14:
+		case 15:
+			xclk_val = FOSCMOD_TC2_CK12;
+			break;
+		case 16:
+			xclk_val = FOSCMOD_TC2_CK16;
+			break;
+		default:
+			xclk_val = FOSCMOD_TC2_CK16;
+	}
+	
+	/* follow the protocol to change the XCLK clock */
+	data->camera_regs->ctrlclock &= ~CAMEXCLK_EN;
+	data->camera_regs->ctrlclock |= xclk_val;
+	data->camera_regs->ctrlclock |= CAMEXCLK_EN;
+
+	return (data->ocp_clk/divisor);
+#endif
+        return 0;
+}
+
+
+static void cif_check_handler(unsigned long arg)
+{
+	struct TCCxxxCIF *data = (struct TCCxxxCIF *) arg;
+	unsigned long timeover = 0;
+		
+	if(data->cif_cfg.oper_mode == OPER_PREVIEW) 
+	{
+		if(0) // Check Sensor-ESD register!!
+		{
+			data->cif_cfg.esd_restart = ON;
+			timeover = 0;
+		}
+		else
+			timeover = HZ;
+
+		cif_timer_register(data, timeover);
+	}
+}
+
+void cif_timer_register(void* priv, unsigned long timeover)
+{
+	struct TCCxxxCIF *data = (struct TCCxxxCIF *) priv;
+
+	init_timer(&data->cam_timer);
+	data->cam_timer.function = cif_check_handler;
+	data->cam_timer.data = (unsigned long)data;
+	data->cam_timer.expires = get_jiffies_64()+ timeover;
+
+	add_timer(&data->cam_timer);
+}
+
+void cif_timer_deregister(void)
+{
+	struct TCCxxxCIF *data = (struct TCCxxxCIF *) &hardware_data;
+
+	del_timer(&data->cam_timer);
+	data->cam_timer.expires = 0;
+}
+
+
+void cif_scaler_set(void *priv)
+{
+	cif_main_set *data = (cif_main_set *) priv;
+	unsigned int sc_hfactor, sc_vfactor;
+	unsigned int crop_hor_ofst, crop_ver_ofst;
+	
+	if(((data->target_x /4)*3) == data->target_y  ||
+		((data->target_x /11)*9) == data->target_y) // if 4:3 ratio ?
+	{
+		data->scaler_x = data->target_x;
+		data->scaler_y = data->target_y;
+	}
+	else
+	{
+		if(data->target_y%3)
+			data->scaler_y = (data->target_y + (3 - data->target_y%3));
+		else
+			data->scaler_y = data->target_y;
+		
+		data->scaler_x = data->scaler_y/3 * 4;
+
+		if(data->scaler_x < data->target_x)
+		{
+			if(data->target_x%4)
+				data->scaler_x = (data->target_x + (4 - data->target_x%4));
+			else
+				data->scaler_x = data->target_x;
+			data->scaler_y = data->scaler_x/4 * 3;
+		}
+	}
+	
+	sc_hfactor = (data->source_x*256/data->scaler_x);
+	sc_vfactor = (data->source_y*256/data->scaler_y);
+
+	TDD_CIF_SetFreeScale(SET_CIF_SCALER_SRC_SIZE|SET_CIF_SCALER_DST_SIZE,
+				data->source_x, data->source_y, 0, 0, data->scaler_x, data->scaler_y, 0,0);
+	TDD_CIF_SetFreeScale(SET_CIF_SCALER_SRC_OFFSET,
+				0, 0, data->win_hor_ofst, data->win_ver_ofst, 0, 0, 0,0);
+	TDD_CIF_SetFreeScale(SET_CIF_SCALER_FACTOR, 0, 0, 0, 0, 0, 0,
+				sc_hfactor, sc_vfactor);
+
+	//Crop
+	crop_hor_ofst = (data->scaler_x - data->target_x)/2;
+	crop_ver_ofst = (data->scaler_y - data->target_y)/2;
+	TDD_CIF_SetImage(INPUT_IMG, data->scaler_x, data->scaler_y, 
+								crop_hor_ofst, (data->scaler_x - data->target_x - crop_hor_ofst), 
+								crop_ver_ofst, (data->scaler_y - data->target_y - crop_ver_ofst));
+
+	TDD_CIF_SetScalerCtrl(SET_CIF_SCALER_ENABLE);
+}
+
+void cif_scaler_calc(void)
+{
+	struct TCCxxxCIF *data = (struct TCCxxxCIF *) &hardware_data;
+	enum cifoper_mode mode = data->cif_cfg.oper_mode;
+	unsigned int off_x, off_y, width, height;
+
+	if(mode == OPER_PREVIEW
+		|| (mode == OPER_CAPTURE && data->cif_cfg.main_set.target_x < CAM_CAPCHG_WIDTH) )
+	{
+		off_x  = PRV_ZOFFX;
+		off_y  = PRV_ZOFFY;
+		width  = PRV_W;
+		height = PRV_H;
+	}
+	else
+	{
+		off_x  = CAP_ZOFFX;
+		off_y  = CAP_ZOFFY;
+		width  = CAP_W;
+		height = CAP_H;
+	}
+
+	data->cif_cfg.main_set.win_hor_ofst = off_x * data->cif_cfg.zoom_step;	
+	data->cif_cfg.main_set.win_ver_ofst = off_y * data->cif_cfg.zoom_step;	
+	data->cif_cfg.main_set.source_x 	= width - (off_x * data->cif_cfg.zoom_step)*2;		
+	data->cif_cfg.main_set.source_y 	= height - (off_y * data->cif_cfg.zoom_step)*2;		
+
+	TDD_CIF_SetSensorOutImgSize(width, height);	
+
+	cif_scaler_set(&data->cif_cfg.main_set);
+}
+
+void cif_dma_hw_reg(unsigned char frame_num)
+{	
+	struct TCCxxxCIF *data = (struct TCCxxxCIF *) &hardware_data;
+
+	data->cif_cfg.now_frame_num = frame_num;
+
+	TDD_CIF_SetBaseAddr(INPUT_IMG, (unsigned int)data->cif_cfg.preview_buf[frame_num].p_Y,
+									(unsigned int)data->cif_cfg.preview_buf[frame_num].p_Cb,
+									(unsigned int)data->cif_cfg.preview_buf[frame_num].p_Cr);
+	
+	TDD_CIF_SetBaseAddr_offset(INPUT_IMG, data->cif_cfg.main_set.target_x, data->cif_cfg.main_set.target_x/2);
+}
+
+void cif_preview_dma_set(void)
+{
+	struct TCCxxxCIF *data = (struct TCCxxxCIF *) &hardware_data;
+	unsigned char i;
+	dma_addr_t base_addr = data->cif_cfg.base_buf;
+	unsigned int y_offset;
+	unsigned int uv_offset = 0;
+	unsigned int total_off = 0;
+	
+	data->cif_cfg.now_frame_num = 0;	
+	y_offset = data->cif_cfg.main_set.target_x*data->cif_cfg.main_set.target_y;
+
+	if(data->cif_cfg.fmt == M420_ZERO)
+		uv_offset = (data->cif_cfg.main_set.target_x*data->cif_cfg.main_set.target_y)/2;
+	else
+		uv_offset = (data->cif_cfg.main_set.target_x*data->cif_cfg.main_set.target_y)/4;
+        
+	total_off = y_offset + uv_offset*2;
+  	total_off = PAGE_ALIGN(total_off);      
+	for(i = 0; i<data->cif_cfg.pp_num; i++)
+	{
+		data->cif_cfg.preview_buf[i].p_Y  = (unsigned int)PAGE_ALIGN( base_addr + total_off*i);
+		data->cif_cfg.preview_buf[i].p_Cb = (unsigned int)data->cif_cfg.preview_buf[i].p_Y + y_offset;
+		data->cif_cfg.preview_buf[i].p_Cr = (unsigned int)data->cif_cfg.preview_buf[i].p_Cb + uv_offset;
+	}	
+		
+}
+
+void cif_capture_dma_set(void *priv)
+{
+	struct TCCxxxCIF *data = (struct TCCxxxCIF *) &hardware_data;
+	//unsigned char i;
+	dma_addr_t base_addr = data->cif_cfg.base_buf;
+	unsigned int y_offset;
+	unsigned int uv_offset = 0;
+
+#ifdef JPEG_ENCODE_WITH_CAPTURE
+	if(gIsRolling)
+	{
+		y_offset = JPEG_Info.JpegCaptureBuffSize/2;
+
+		if(data->cif_cfg.fmt == M420_ZERO)
+		    uv_offset = JPEG_Info.JpegCaptureBuffSize/4;
+		else
+		    uv_offset = JPEG_Info.JpegCaptureBuffSize/4/2;
+	}
+	else
+#endif
+	{
+		y_offset = data->cif_cfg.main_set.target_x*data->cif_cfg.main_set.target_y;
+
+		if(data->cif_cfg.fmt == M420_ZERO)
+		    uv_offset = (data->cif_cfg.main_set.target_x*data->cif_cfg.main_set.target_y)/2;
+		else
+		    uv_offset = (data->cif_cfg.main_set.target_x*data->cif_cfg.main_set.target_y)/4;
+	} 
+
+	data->cif_cfg.capture_buf.p_Y  = (unsigned int)base_addr;
+	data->cif_cfg.capture_buf.p_Cb = (unsigned int)data->cif_cfg.capture_buf.p_Y + y_offset;
+	data->cif_cfg.capture_buf.p_Cr = (unsigned int)data->cif_cfg.capture_buf.p_Cb + uv_offset;	
+
+	TDD_CIF_SetBaseAddr(INPUT_IMG,  (unsigned int)data->cif_cfg.capture_buf.p_Y,
+									(unsigned int)data->cif_cfg.capture_buf.p_Cb,
+									(unsigned int)data->cif_cfg.capture_buf.p_Cr);
+
+	TDD_CIF_SetBaseAddr_offset(INPUT_IMG, data->cif_cfg.main_set.target_x, data->cif_cfg.main_set.target_x/2);
+
+#ifdef JPEG_ENCODE_WITH_CAPTURE
+	if(gIsRolling)
+	{
+		if(data->cif_cfg.fmt == M420_ZERO)
+		{
+			TDD_CIF_SetBaseAddr(IN_IMG_ROLLING,
+										((unsigned int)data->cif_cfg.capture_buf.p_Y+(JPEG_Info.JpegCaptureBuffSize/2)-4),
+										((unsigned int)data->cif_cfg.capture_buf.p_Cb+(JPEG_Info.JpegCaptureBuffSize/2/2)-4),
+										((unsigned int)data->cif_cfg.capture_buf.p_Cr+(JPEG_Info.JpegCaptureBuffSize/2/2)-4));
+		}
+		else
+		{
+			TDD_CIF_SetBaseAddr(IN_IMG_ROLLING,
+										((unsigned int)data->cif_cfg.capture_buf.p_Y+(JPEG_Info.JpegCaptureBuffSize/2)-4),
+										((unsigned int)data->cif_cfg.capture_buf.p_Cb+(JPEG_Info.JpegCaptureBuffSize/2/4)-4),
+										((unsigned int)data->cif_cfg.capture_buf.p_Cr+(JPEG_Info.JpegCaptureBuffSize/2/4)-4));
+		}
+	}
+#endif
+	
+}
+
+
+
+void cif_interrupt_enable(enum cifoper_mode mode)
+{
+	TDD_CIF_SetMaskIntStatus(SET_CIF_INT_ALL_MASK);
+
+	if(mode == OPER_PREVIEW)
+	{
+		TDD_CIF_SetMaskIntStatus(SET_CIF_INT_STORE_1FRM_NOT_MASK);
+	}
+	else
+	{
+#ifdef JPEG_ENCODE_WITH_CAPTURE
+		if(gIsRolling)
+		{
+			TDD_CIF_SetMaskIntStatus(SET_CIF_INT_VCNT_NOT_MASK);
+		}
+		else
+#endif
+		{
+			TDD_CIF_SetMaskIntStatus(SET_CIF_INT_ENC_STRT_NOT_MASK);
+			TDD_CIF_SetInterrupt(SET_CIF_UPDATE_WITHOUT_VSYNC);
+		}
+	}
+
+	TDD_CIF_SetInterrupt(SET_CIF_INT_ENABLE);
+}
+
+void cif_interrupt_disable(void)
+{
+	TDD_CIF_SetInterrupt(SET_CIF_INT_DISABLE);
+}
+
+void cif_global_reset(void)
+{
+	struct TCCxxxCIF *data = (struct TCCxxxCIF *) &hardware_data;
+
+	TDD_CIF_SetInterrupt(SET_CIF_INT_TYPE_HOLDUP); //should be '1'
+	TDD_CIF_SetInterrupt(SET_CIF_UPDATE_IN_VSYNC);
+	TDD_CIF_SetInfo(SET_CIF_ALL, SEPARATE, MSB_FIRST, MODE_YUV, FMT422, BAYER_RGB, MODE16, data->cif_cfg.order422, SWICH_BUS);
+
+	//DMA configure
+	TDD_CIF_SetTransfer(SET_CIF_TRANSFER_ALL, BURST8, LOCK_TR, BURST_TRANS);
+	TDD_CIF_SetSyncPol(data->cif_cfg.polarity_href, data->cif_cfg.polarity_vsync);
+
+	//Effect all clear
+	TDD_CIF_SetEffectMode(SET_CIF_CEM_NOR);
+
+	TDD_CIF_SetCtrl(SET_CIF_II_ALL, CIF_PWDN_DISABLE, CIF_BYPASS_SCALER_DISABLE,
+						data->cif_cfg.polarity_pclk, FRAME_0, data->cif_cfg.fmt, CIF_656CONVERT_DISABLE);
+}
+
+#ifdef JPEG_ENCODE_WITH_CAPTURE
+static irqreturn_t tccxxx_jpeg_handler(int irq, void *dev_id/*, struct pt_regs *reg*/)
+{  	
+	unsigned long lFlag, TempFlag;
+	struct TCCxxxCIF *data = (struct TCCxxxCIF *) &hardware_data;
+	struct tccxxx_cif_buffer *cif_buf;
+
+	lFlag = HwJP_INT_FLAG;
+
+	if (lFlag & HwJP_INT_FLAG_CODED_BUF_STAT)
+	{
+#ifdef JPEG_ENCODE_WITH_CAPTURE
+	data->cif_cfg.cap_status = CAPTURE_OVERFLOW;
+	#ifdef JPEG_TESTCODE
+		JPEG_BUS_Disable(JPEG_ENCODE_MODE); // temp!! NO-thumbnail!!
+		JPEG_INTERRUPT_Disable(JPEG_ENCODE_MODE);
+	#endif
+		wake_up_interruptible(&data->frame_wait);
+#endif // JPEG_ENCODE_WITH_CAPTURE
+		dprintk(KERN_ALERT "JPEG ENCODING BUFFER-ERROR! \r\n");
+
+	}
+	else if (lFlag & HwJP_INT_FLAG_DECODING_ERR)
+	{
+
+	}
+	else if (lFlag & HwJP_INT_FLAG_JOB_FINISHED)
+	{
+		//Save to memory
+		if (gJpegCodecMode == JPEG_ENCODE_MODE)
+		{
+			gJpegEncodeDone = 1;
+			data->cif_cfg.cap_status = CAPTURE_DONE;		
+
+#ifdef JPEG_ENCODE_WITH_CAPTURE
+	#ifdef JPEG_TESTCODE
+			tccxxx_jpeg_make_header(&(data->cif_cfg.jpg_info.jpg_len), &(data->cif_cfg.jpg_info.jpg_hdr_len));
+			JPEG_BUS_Disable(JPEG_ENCODE_MODE); // temp!! NO-thumbnail!!
+			JPEG_INTERRUPT_Disable(JPEG_ENCODE_MODE);
+	#endif
+			wake_up_interruptible(&data->frame_wait);
+#endif // JPEG_ENCODE_WITH_CAPTURE
+			
+			dprintk(KERN_ALERT "JPEG ENCODING DONE! \r\n");
+		}
+		else if (gJpegCodecMode == JPEG_DECODE_MODE)
+		{
+			gJpegDecodeDone = 1;
+			dprintk(KERN_ALERT "JPEG DECODING DONE \r\n");
+		}
+	}
+#ifdef TCC83XX
+	else if (lFlag & HwJP_INT_FLAG_YBUF_ROLLING)
+	{
+		BITSET(HwJP_INT_MASK, HwJP_INT_MASK_YBUF_ROLLING);
+	}
+#endif
+
+	TempFlag = HwJP_INT_ACK;
+
+	return IRQ_HANDLED;
+}
+
+static int
+tccxxx_jpeg_encode_method(void)
+{
+	struct TCCxxxCIF *data = (struct TCCxxxCIF *) &hardware_data;
+	unsigned int  ucReturnVal = FALSE;
+	unsigned int  temp_1, temp_2;
+
+	JPEG_Info.JpegCaptureBuffSize = CAPTURE_MEM;
+
+	if (JPEG_Info.JpegCaptureBuffSize < data->cif_cfg.main_set.target_x*data->cif_cfg.main_set.target_y*2)
+		ucReturnVal = TRUE;
+
+	if(ucReturnVal)
+	{
+		temp_1 = (JPEG_Info.JpegCaptureBuffSize/2)/data->cif_cfg.main_set.target_x;
+
+		if (temp_1%FRAME_LINE_CNT != 0)
+		{
+			temp_2 = temp_1/FRAME_LINE_CNT;
+			JPEG_Info.JpegCaptureBuffSize = (temp_2*FRAME_LINE_CNT)*data->cif_cfg.main_set.target_x*2;
+		}
+	}
+
+	return ucReturnVal;
+}
+
+static int
+tccxxx_jpeg_encode_init(enum jpeg_quantisation_val val)
+{
+	struct TCCxxxCIF *data = (struct TCCxxxCIF *) &hardware_data;
+
+	unsigned int uiOutputBufferSize, uiInputBufferSize;
+	void *BufferY, *BufferU, *BufferV;
+
+	gJpegCodecMode = JPEG_UNKNOWN_MODE;
+	JPEG_Exif_Header_Info_Init();
+
+	BufferY = (void*)data->cif_cfg.capture_buf.p_Y ;
+	BufferU = (void*)data->cif_cfg.capture_buf.p_Cb;
+	BufferV = (void*)data->cif_cfg.capture_buf.p_Cr;
+	
+	JPEG_BUS_EnableJPEG_ENCODE_MODE();
+	JPEG_SW_Reset(JPEG_ENCODE_MODE);
+	gJpegEncodeDone = 0;
+	
+	uiInputBufferSize = (JPEG_Info.JpegCaptureBuffSize/2)/data->cif_cfg.main_set.target_x;
+	uiOutputBufferSize = gJPEG_Buffer_Info.pBaseBitstreamDataSize/1024;
+
+	gJPEG_ENC_Info.is_rolling = gIsRolling;
+	gJPEG_ENC_Info.y_addr = (unsigned int)BufferY;
+	gJPEG_ENC_Info.u_addr = (unsigned int)BufferU;
+	gJPEG_ENC_Info.v_addr = (unsigned int)BufferV;
+	gJPEG_ENC_Info.ifrm_hsize = data->cif_cfg.main_set.target_x;
+	gJPEG_ENC_Info.ibuf_vsize = uiInputBufferSize;
+	gJPEG_ENC_Info.q_value = val;
+	gJPEG_ENC_Info.img_hsize = data->cif_cfg.main_set.target_x;
+	gJPEG_ENC_Info.img_vsize = data->cif_cfg.main_set.target_y;
+	gJPEG_ENC_Info.cbuf_addr = (unsigned int)gJPEG_Buffer_Info.pBaseBitstreamDataAddr;
+	gJPEG_ENC_Info.cbuf_size = uiOutputBufferSize;
+	gJPEG_ENC_Info.frame_cnt = FRAME_LINE_CNT;
+	gJPEG_ENC_Info.chroma = HwJP_CHROMA_422;
+
+#ifdef JPEG_TESTCODE
+	data->cif_cfg.jpg_info.jpg_buf_addr = jpeg_remapped_base_address;
+	data->cif_cfg.jpg_info.jpg_hdr_addr = jpeg_header_remapped_address;
+#endif	
+
+	JPEG_SET_Encode_Config(&gJPEG_ENC_Info);
+
+	JPEG_INTERRUPT_Enable(JPEG_ENCODE_MODE);
+
+	return 0;
+}
+
+int tccxxx_jpeg_make_header(unsigned int *uiBitStreamSize, unsigned int *uiHeaderSize)
+{
+	struct TCCxxxCIF *data = (struct TCCxxxCIF *) &hardware_data;
+	void *HeaderBuffer;
+
+	//while (!gJpegEncodeDone)
+
+	if (gIsExifThumbnailProcess)
+	{
+		gEncodeOption.ThumbnailInfo.pThumbnail_Buff = (void *)((uint32)jpeg_header_remapped_address + 2048);
+		gEncodeOption.ThumbnailInfo.thumbnail_image_size = JPEG_Encoded_Data_Size();
+	}
+	else
+	{
+		*uiBitStreamSize = JPEG_Encoded_Data_Size();
+
+		gEncodeOption.BitStreamSize = *uiBitStreamSize;
+		gEncodeOption.ThumbnailInfo.thumbnail_image_size = 0;
+		gEncodeOption.ImageWidth = data->cif_cfg.main_set.target_x;
+		gEncodeOption.ImageHeight = data->cif_cfg.main_set.target_y;
+		gEncodeOption.Q_FactorValue = JPEG_DEFAULT;
+	}
+
+	HeaderBuffer = jpeg_header_remapped_address;
+
+	*uiHeaderSize = TCCXXX_JPEG_Make_Header((uint32)HeaderBuffer, &gEncodeOption, &gJpegHeaderExifRsp);
+	*uiBitStreamSize = gEncodeOption.BitStreamSize;
+
+	gJpegEncodeDone = 0;
+	gIsExifThumbnailProcess = FALSE;
+
+	return 0;
+}
+#endif
+
+
+int tccxxx_cif_buffer_set(struct v4l2_requestbuffers *req)
+{
+	struct TCCxxxCIF *data = (struct TCCxxxCIF *) &hardware_data;
+	dma_addr_t base_addr = data->cif_cfg.base_buf;
+	unsigned int y_offset = data->cif_cfg.main_set.target_x*data->cif_cfg.main_set.target_y;
+	unsigned int uv_offset = 0;
+	unsigned int total_off = 0;
+	unsigned char i;
+	unsigned long total_req_buf_size=0;
+	unsigned char req_buf = req->count;
+	unsigned int buff_size;
+	
+	data->cif_cfg.now_frame_num = 0;
+
+	if (req->count > TCC_CAMERA_MAX_BUFNBRS) 
+		req->count = TCC_CAMERA_MAX_BUFNBRS;
+
+	if (req->count < 0) 
+		req->count = 2;
+
+	if(data->cif_cfg.fmt == M420_ZERO)
+		buff_size = PAGE_ALIGN(y_offset*2);
+	else
+		buff_size = PAGE_ALIGN(y_offset + y_offset/2);
+
+
+	data->buf->v4lbuf.length = buff_size;
+
+retry:
+	if(req_buf == 1)
+	{
+#if 0  // ZzaU :: Don't check Buffer in Rolling-Capture.
+		if (data->buf->v4lbuf.length > CAPTURE_MEM)
+		{
+			printk("reqbufs: count invalid\n");
+			return -1;
+		}
+#endif
+	}
+	else
+	{
+		if (data->buf->v4lbuf.length*req->count > PREVIEW_MEM) 
+		{
+			req->count--;
+			if (req->count <= 0) 
+			{
+				printk("reqbufs: count invalid\n");
+				return -1;
+			}
+			goto retry;
+		}
+	}
+
+	memset(data->static_buf,0x00,req->count * sizeof(struct tccxxx_cif_buffer));
+	
+	data->done_list.prev = data->done_list.next = &data->done_list;
+	data->list.prev 	 = data->list.next 		= &data->list;
+		
+	for (data->n_sbufs = 0; data->n_sbufs < req->count; (data->n_sbufs++)) 
+	{
+		struct tccxxx_cif_buffer *buf = &(data->static_buf[data->n_sbufs]);
+
+		INIT_LIST_HEAD(&buf->buf_list);
+
+		//buf->v4lbuf.length = PAGE_ALIGN(cam->pix_format.sizeimage);
+		buf->v4lbuf.length = buff_size;
+		
+		total_req_buf_size += buf->v4lbuf.length;
+		//dprintk(KERN_WARNING "<total size is 0x%x / 0x%x>\n", (unsigned int)(buf->v4lbuf.length), (unsigned int)(total_req_buf_size));	
+	  		
+		buf->mapcount = 0;
+		buf->cam = data;
+		buf->v4lbuf.index 	= data->n_sbufs;
+		buf->v4lbuf.type 	= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		buf->v4lbuf.field 	= V4L2_FIELD_NONE;
+		buf->v4lbuf.memory 	= V4L2_MEMORY_MMAP;
+		
+		/*
+		 * Offset: must be 32-bit even on a 64-bit system.	videobuf-dma-sg
+		 * just uses the length times the index, but the spec warns
+		 * against doing just that - vma merging problems.	So we
+		 * leave a gap between each pair of buffers.
+		 */
+		//buf->v4lbuf.m.offset = 2*index*buf->v4lbuf.length;			
+		
+	}	
+
+	//data->cif_cfg.pp_num = req->count;
+	data->cif_cfg.pp_num = data->n_sbufs;
+	req->count = data->cif_cfg.pp_num;
+
+
+	if(data->cif_cfg.fmt == M420_ZERO)
+		uv_offset = (data->cif_cfg.main_set.target_x*data->cif_cfg.main_set.target_y)/2;
+	else
+		uv_offset = (data->cif_cfg.main_set.target_x*data->cif_cfg.main_set.target_y)/4;
+        
+	total_off = y_offset + uv_offset*2;
+  	total_off = PAGE_ALIGN(total_off);        
+	for(i = 0; i<data->cif_cfg.pp_num; i++)
+	{
+		data->cif_cfg.preview_buf[i].p_Y  = (unsigned int)PAGE_ALIGN( base_addr + total_off*i);
+		data->cif_cfg.preview_buf[i].p_Cb = (unsigned int)data->cif_cfg.preview_buf[i].p_Y + y_offset;
+		data->cif_cfg.preview_buf[i].p_Cr = (unsigned int)data->cif_cfg.preview_buf[i].p_Cb + uv_offset;
+	}	
+
+	printk("\n reqbufs: success :: buffer count = %d \n",data->cif_cfg.pp_num);
+	return 0;	
+}
+
+int tccxxx_cif_cam_restart(struct v4l2_pix_format *pix, unsigned long xclk)
+{
+	struct TCCxxxCIF *data = (struct TCCxxxCIF *) &hardware_data;
+	struct tccxxx_cif_buffer *cif_buf;			
+
+	tccxxx_cif_stop_stream();
+
+	TDD_CIF_Reset();
+	sensor_configure(pix,xclk);
+	sensor_change_mode(OPER_PREVIEW);
+
+	while(!list_empty(&data->done_list)) 
+	{
+		cif_buf = list_entry(data->done_list.next, struct tccxxx_cif_buffer, buf_list);		
+		list_del(&cif_buf->buf_list);
+	
+		cif_buf->v4lbuf.flags &= ~V4L2_BUF_FLAG_DONE;	
+		cif_buf->v4lbuf.flags |= V4L2_BUF_FLAG_QUEUED;
+		
+		list_add_tail(&cif_buf->buf_list, &data->list);	
+	}
+
+	// Sensor setting Again!! 
+	sensor_set_current_control();
+
+	cif_dma_hw_reg(0);
+	data->stream_state = STREAM_ON;
+	cif_interrupt_enable(data->cif_cfg.oper_mode);
+
+	data->cif_cfg.esd_restart = OFF;
+	cif_timer_register(data, HZ);
+
+	return 0;
+}
+
+int tccxxx_cif_start_stream(void)
+{
+	struct TCCxxxCIF *data = (struct TCCxxxCIF *) &hardware_data;
+
+	data->cif_cfg.oper_mode = OPER_PREVIEW;
+
+	skip_frm = 1;
+	skipped_frm = 0;
+	
+	CIF_OpStop();
+	sensor_change_mode(OPER_PREVIEW);
+	
+	TDD_CIF_SetInterrupt(SET_CIF_UPDATE_IN_VSYNC);
+	cif_global_reset();
+
+	tccxxx_cif_set_effect(current_effect_mode);	
+	
+	cif_scaler_calc();
+	cif_preview_dma_set();
+	cif_dma_hw_reg(0);
+	
+	CIF_ONOFF(ON);
+
+	data->stream_state = STREAM_ON;
+		
+	cif_interrupt_enable(data->cif_cfg.oper_mode);
+
+	cif_timer_register(data, HZ);
+
+	while(skip_frm)
+	{
+		msleep(1);
+	}
+	sensor_adjust_autofocus();
+
+	dprintk("@---- %s (%d)\n", __FUNCTION__, __LINE__);	
+
+	return 0;
+}
+
+int tccxxx_cif_stop_stream(void)
+{	
+	struct TCCxxxCIF *data = (struct TCCxxxCIF *) &hardware_data;
+	//int i;
+
+	cif_timer_deregister();
+
+	cif_interrupt_disable();
+	//udelay(100);
+	
+	data->stream_state= STREAM_OFF;	
+
+	printk("\n\n SKIPPED FRAME = %d \n\n", skipped_frm);
+//wkjung
+/*	
+	mutex_lock(&data->lock);	
+
+	INIT_LIST_HEAD(&data->done_list);
+	INIT_LIST_HEAD(&data->list);
+
+	for(i=0; i<data->cif_cfg.pp_num;i++)
+	{
+		INIT_LIST_HEAD(&data->buf[i].buf_list);
+		data->buf[i].v4lbuf.flags &= ~V4L2_BUF_FLAG_QUEUED;
+		data->buf[i].v4lbuf.flags &= ~V4L2_BUF_FLAG_DONE;
+	}
+	mutex_unlock(&data->lock);	
+*/		
+
+	return 0;
+}
+
+void tccxxx_cif_set_overlay(void)
+{
+	struct TCCxxxCIF *data = (struct TCCxxxCIF *) &hardware_data;
+	cif_SuperImpose *SiData = (cif_SuperImpose *)&(data->cif_cfg.si_overlay);
+
+	unsigned int frame_width = data->cif_cfg.main_set.scaler_x;  // Scaler_out width
+	unsigned int frame_height = data->cif_cfg.main_set.scaler_y;  // Scaler_out width
+	unsigned int siFrame_hoffset_s 	= 0;
+	unsigned int siFrame_hoffset_e 		= 0;   
+	unsigned int siFrame_voffset_s 	= 0;
+	unsigned int siFrame_voffset_e 		= 0;
+	unsigned int si_buffer_addr 	= data->cif_buf.addr + SiData->buff_offset;
+
+	siFrame_hoffset_s = siFrame_hoffset_e = (frame_width - SiData->width)/2;
+	siFrame_voffset_s = siFrame_voffset_e = (frame_height - SiData->height)/2;
+
+	TDD_CIF_OverlayCtrl(SET_CIF_OVERLAY_DISABLE, OL_RGB_565);
+
+	if(SiData->buff_offset != 0)
+	{
+		TDD_CIF_SetImage(OVERLAY_IMG, frame_width, frame_height,
+						siFrame_hoffset_s, siFrame_hoffset_e,	siFrame_voffset_s, siFrame_voffset_e);
+		TDD_CIF_SetOverlay (SET_CIF_OVERLAY_ALL, 49, FULL_OVERLAY, OP_ALPHA, OP_ALPHA, ALPHA100, ALPHA100);
+		TDD_CIF_SetOverlayKey(SET_CIF_OVERLAYKEY_ALL, SiData->chromakey_info.key_y, 
+													  SiData->chromakey_info.key_u, 
+													  SiData->chromakey_info.key_v, 
+													  SiData->chromakey_info.mask_r, 
+													  SiData->chromakey_info.mask_g, 
+													  SiData->chromakey_info.mask_b);
+		
+		TDD_CIF_OverlayCtrl(SET_CIF_CHROMA_ENABLE|SET_CIF_OVERLAY_ENABLE|SET_CIF_COLOR_CONV_ENABLE|
+						SET_CIF_COLOR_MODE_RGB,	OL_RGB_565);
+		TDD_CIF_SetBaseAddr(OVERLAY_IMG, (unsigned int)si_buffer_addr, 0, 0);				
+	}
+}
+
+int tccxxx_cif_set_effect (u8 nCameraEffect)
+{
+	unsigned int uiSepiaU = 0x64;
+	unsigned int uiSepiaV = 0x8C;
+	unsigned int uiSKCoeff0 = 0x02;
+	unsigned int uiSKCoeff1 = 0x0;
+	unsigned int uiSKCoeff2 = 0xff;
+	unsigned int uiSkecthThreshold = 0x80;
+
+	if (nCameraEffect == TCC_EFFECT_NORMAL)
+		TDD_CIF_SetEffectMode(SET_CIF_CEM_NOR);
+	else if(nCameraEffect == TCC_EFFECT_GRAY)
+		TDD_CIF_SetEffectMode(SET_CIF_CEM_GRAY);
+	else if(nCameraEffect == TCC_EFFECT_NEGATIVE)
+		TDD_CIF_SetEffectMode(SET_CIF_CEM_NEGA);
+	else if(nCameraEffect == TCC_EFFECT_SKETCH)
+	{
+		uiSkecthThreshold = 0x89;
+		TDD_CIF_SetEffectMode(SET_CIF_CEM_SKT);
+		TDD_CIF_SetEffectHFilterCoeff(uiSKCoeff0, uiSKCoeff1, uiSKCoeff2);
+		TDD_CIF_SetEffectSketchTh(uiSkecthThreshold);
+	}
+	else if(nCameraEffect == TCC_EFFECT_SEPHIA)
+	{
+		uiSepiaU =  0x64;
+		uiSepiaV = 0x8C;
+		TDD_CIF_SetEffectMode(SET_CIF_CEM_SEPI);
+		TDD_CIF_SetEffectSepiaUV(uiSepiaU, uiSepiaV);
+	}
+	else if(nCameraEffect == TCC_EFFECT_GREEN)
+	{		
+		uiSepiaU =  100;
+		uiSepiaV = 80;
+		TDD_CIF_SetEffectMode(SET_CIF_CEM_SEPI);
+		TDD_CIF_SetEffectSepiaUV(uiSepiaU, uiSepiaV);
+
+	}
+	else if(nCameraEffect == TCC_EFFECT_AQUA)
+	{
+		uiSepiaU =  192;
+		uiSepiaV = 80;
+		TDD_CIF_SetEffectMode(SET_CIF_CEM_SEPI);
+		TDD_CIF_SetEffectSepiaUV(uiSepiaU, uiSepiaV);
+
+	}
+	current_effect_mode = (u8) nCameraEffect;
+
+	return 0;
+}
+
+int tccxxx_cif_capture(int quality)
+{
+	struct TCCxxxCIF *data = (struct TCCxxxCIF *) &hardware_data;
+	unsigned int ens_addr;
+	int skip_frame = 0;
+//	int ret = 0;
+
+
+	data->cif_cfg.oper_mode = OPER_CAPTURE;
+	
+	cif_interrupt_disable();
+
+	CIF_OpStop();
+	cif_global_reset();
+	tccxxx_cif_set_effect(current_effect_mode);
+
+	if(data->cif_cfg.main_set.target_x >= CAM_CAPCHG_WIDTH && !(data->cif_cfg.retry_cnt))
+		sensor_change_mode(OPER_CAPTURE);
+
+	cif_scaler_calc();
+
+#ifdef JPEG_ENCODE_WITH_CAPTURE
+	gIsRolling = tccxxx_jpeg_encode_method();
+#endif
+	cif_capture_dma_set(data);
+
+	//capture config
+	if(data->cif_cfg.retry_cnt)
+		skip_frame = 0;
+	else
+	{
+		skip_frame = 1;
+	}
+	
+#ifdef JPEG_ENCODE_WITH_CAPTURE
+	if(gIsRolling)
+	{
+		TDD_CIF_SetInterrupt(SET_CIF_UPDATE_WITHOUT_VSYNC);
+		TDD_CIF_SetCaptureCtrl(SET_CIF_SKIP_NUM|SET_CIF_VCNT_NUM, skip_frame, FRAME_LINE_CNT/16,
+								SET_CIF_EIT_ENC_INT|SET_CIF_RLV_ENABLE|SET_CIF_RLU_ENABLE|SET_CIF_RLY_ENABLE|
+								SET_CIF_CAP_ENABLE|SET_CIF_VEN_ENABLE);
+	}
+	else
+#endif
+	{
+		ens_addr = (unsigned int)data->cif_cfg.capture_buf.p_Y + 
+					(data->cif_cfg.main_set.target_x * (data->cif_cfg.main_set.target_y - 2));
+
+		if(data->cif_cfg.main_set.target_x < CAM_CAPCHG_WIDTH)
+			TDD_CIF_SetCaptureCtrl(SET_CIF_SKIP_NUM, skip_frame, 0,SET_CIF_EIT_ENC_INT|SET_CIF_CAP_ENABLE|SET_CIF_UES_ENABLE);
+		else
+			TDD_CIF_SetCaptureCtrl(SET_CIF_SKIP_NUM, skip_frame, 0,SET_CIF_EIT_ENC_INT|SET_CIF_CAP_ENABLE|SET_CIF_UES_ENABLE);
+		
+		TDD_CIF_SetBaseAddr(IN_ENC_START_ADDR, ens_addr, 0, 0);
+	}
+
+	cif_interrupt_enable(data->cif_cfg.oper_mode);
+
+#ifdef JPEG_ENCODE_WITH_CAPTURE
+	tccxxx_jpeg_encode_init(quality);
+#endif
+
+	if(data->cif_cfg.si_overlay.buff_offset != 0)
+		tccxxx_cif_set_overlay();
+
+	data->cif_cfg.cap_status = CAPTURE_NONE;
+	TDD_CIF_ONOFF(ON);
+
+	return 0;
+}
+		
+
+int tccxxx_cif_set_zoom(unsigned char arg)
+{
+	struct TCCxxxCIF *data = (struct TCCxxxCIF *) &hardware_data;
+
+	data->cif_cfg.zoom_step = arg;
+
+	if(data->stream_state != STREAM_OFF)
+		cif_scaler_calc();	
+
+	return 0;
+}
+
+int tccxxx_cif_set_resolution(unsigned int pixel_fmt, unsigned short width, unsigned short height)
+{
+	struct TCCxxxCIF *data = &hardware_data;
+
+	//if(data->cif_cfg.main_set.target_x == width 
+	//	&& data->cif_cfg.fmt == pixel_fmt)
+	//	return 0;
+
+	if(pixel_fmt == V4L2_PIX_FMT_YUYV)//YUV 422
+		data->cif_cfg.fmt = M420_ZERO;
+	else
+		data->cif_cfg.fmt = M420_ODD;
+
+	data->cif_cfg.main_set.target_x = width;
+	data->cif_cfg.main_set.target_y = height;
+
+	if(data->stream_state != STREAM_OFF)
+	{
+		tccxxx_cif_stop_stream();
+		tccxxx_cif_start_stream();
+	}
+
+	return 0;	
+}
+
+int tccxxx_cif_open(void)
+{
+	int ret;
+	struct TCCxxxCIF *data = (struct TCCxxxCIF *) &hardware_data;
+
+	data->done_list.next	= &data->done_list;
+	data->list.next		= &data->list;
+
+	if(!cam_irq)
+	{
+		if ((ret = request_irq(IRQ_CAM, cif_cam_isr, IRQF_DISABLED, "camera", NULL)) < 0) 
+		{
+			printk("FAILED to aquire irq\n");
+			return ret;
+		}
+		cam_irq = 1;
+	}
+	
+#if defined(JPEG_ENCODE_WITH_CAPTURE) && !defined(NLY_ENCODE_JPEG_IN_ROLLING_CAPTURE)
+	free_irq(IRQ_JPGE, NULL);
+	if ((ret = request_irq(IRQ_JPE, tccxxx_jpeg_handler, IRQF_DISABLED, "jpeg", NULL)) < 0) 
+	{
+		printk("FAILED to aquire irq\n");
+		return ret;
+	}
+#endif
+
+	return 0;
+}
+
+int tccxxx_cif_close(void)
+{
+	struct TCCxxxCIF *data = (struct TCCxxxCIF *) &hardware_data;
+    int i;
+
+/*
+	mutex_lock(&data->lock);	
+
+	INIT_LIST_HEAD(&data->done_list);
+	INIT_LIST_HEAD(&data->list);
+
+	for(i=0; i<data->cif_cfg.pp_num;i++)
+	{
+		INIT_LIST_HEAD(&data->buf[i].buf_list);
+		data->buf[i].v4lbuf.flags &= ~V4L2_BUF_FLAG_QUEUED;
+		data->buf[i].v4lbuf.flags &= ~V4L2_BUF_FLAG_DONE;
+	}
+	
+	mutex_unlock(&data->lock);	
+*/
+	cif_interrupt_disable();
+	cif_cleanup();
+
+	dprintk("reamp : [0x%x - 0x%x] -> [0x%x] \n",data->cif_buf.addr, data->cif_buf.bytes, data->cif_buf.area);		
+	iounmap(data->cif_buf.area);
+	
+	free_irq(IRQ_CAM, NULL);
+	cam_irq = 0;
+	
+#ifdef JPEG_ENCODE_WITH_CAPTURE
+	free_irq(IRQ_JPGE, NULL);
+#endif
+
+	cif_timer_deregister();
+
+	return 0;
+}
+
+
+/* Initialise the OMAP camera interface */
+int  tccxxx_cif_init(void)
+{
+	struct cif_dma_buffer *buf = &hardware_data.cif_buf;    
+
+	memset(&hardware_data,0x00,sizeof(struct TCCxxxCIF));
+	hardware_data.buf = hardware_data.static_buf;
+
+#ifdef JPEG_ENCODE_WITH_CAPTURE
+	buf->bytes = PAGE_ALIGN(CAPTURE_MEM+JPEG_MEM);
+	buf->addr = PA_VIDEO_BASE;
+	buf->area = ioremap_nocache(buf->addr,buf->bytes);
+
+	jpeg_remapped_base_address = (void *)ioremap_nocache(JPEG_PHY_ADDRESS, PAGE_ALIGN(JPEG_MEM-PAGE_SIZE));    //JPEG Buffer
+	jpeg_header_remapped_address = jpeg_remapped_base_address + JPEG_STREAM;
+
+	gJPEG_Buffer_Info.pBaseRawDataAddr = (void*)CAPTURE_PHY_ADDRESS;
+	gJPEG_Buffer_Info.pBaseRawDataSize = CAPTURE_MEM;
+	gJPEG_Buffer_Info.pBaseBitstreamDataAddr = (void*)JPEG_PHY_ADDRESS;
+	gJPEG_Buffer_Info.pBaseBitstreamDataSize = JPEG_STREAM;
+	gJPEG_Buffer_Info.pBaseHeaderDataAddr = (void*)(JPEG_PHY_ADDRESS + JPEG_STREAM);
+	gJPEG_Buffer_Info.pBaseHeaderDataSize = JPEG_HEADER;
+#else
+	buf->bytes = PAGE_ALIGN(PREVIEW_MEM);
+	buf->addr = PA_VIDEO_BASE;
+	buf->area = ioremap_nocache(buf->addr,buf->bytes);
+	dprintk("reamp : [0x%x - 0x%x] -> [0x%x] \n",buf->addr, buf->bytes, buf->area);		
+#endif
+
+	if (buf->area == NULL) 
+	{
+		printk(KERN_ERR CAM_NAME ": cannot remap buffer\n");
+		return ENODEV;
+	}
+  
+	/* Init the camera IF */
+	cif_data_init((void*)&hardware_data);
+	/* enable it. This is needed for sensor detection */
+	cif_enable((void*)&hardware_data);
+
+	init_waitqueue_head(&hardware_data.frame_wait);
+	spin_lock_init(&hardware_data.dev_lock);
+
+	INIT_LIST_HEAD(&hardware_data.list);
+	INIT_LIST_HEAD(&hardware_data.done_list);	
+	mutex_init(&hardware_data.lock);
+
+	return 0;
+}
+
Index: linux-2.6.29/drivers/media/video/tcccam/tcc_cam.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/tcccam/tcc_cam.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,367 @@
+/*
+ *  drivers/media/video/tcccam/tcc_cam.h
+ *
+ * Copyright (C) 2008 Telechips, Inc. 
+ * 
+ * This package is free software; you can redistribute it and/or modify 
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation. 
+ * 
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR 
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED 
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. 
+ */
+
+#include <media/v4l2-common.h>
+
+ 
+#ifndef TCCXX_CIF_H
+#define TCCXX_CIF_H
+
+//#define JPEG_ENCODE_WITH_CAPTURE
+#ifdef JPEG_ENCODE_WITH_CAPTURE
+#define JPEG_TESTCODE
+#else
+typedef struct {
+	unsigned int src;
+	int width;
+	int height;
+	unsigned int bitstream_size;
+	unsigned int thumb_size;
+	unsigned int header_size;
+}TCCXXX_JPEG_ENC_DATA;
+#endif
+
+#define DMA_ELEM_SIZE   4
+#define FIFO_TRIGGER_LVL (32)
+
+/* Maximum number of buffers */
+#define TCC_CAMERA_MAX_BUFNBRS 	8
+
+/*
+ * ---------------------------------------------------------------------------
+ *  tccxxx Camera Interface
+ * ---------------------------------------------------------------------------
+ */
+#ifndef	_LCDC_H_
+#define PAGE0						0
+#define PAGE1						1
+
+#define SET_LCD_ENABLE				0x00000001
+#define SET_LCD_DISABLE				0x00000002
+#define SET_CH0_ENABLE				0x00000004
+#define SET_CH0_DISABLE				0x00000008
+#define SET_CH1_ENABLE				0x00000010
+#define SET_CH1_DISABLE				0x00000020
+#define SET_CH2_ENABLE				0x00000040
+#define SET_CH2_DISABLE				0x00000080
+#define SET_TFT_ENABLE				0x00000100
+#define SET_TFT_DISABLE				0x00000200
+#define SET_TVOUT_ENABLE			0x00000400
+#define SET_TVOUT_DISABLE			0x00000800
+#define SET_STN_ENABLE				0x00001000
+#define SET_STN_DISABLE				0x00002000
+#define SET_NOTINTERLACE_ENABLE		0x00004000
+#define SET_NOTINTERLACE_DISABLE	0x00008000
+#define SET_DP2_ENABLE				0x00010000
+#define SET_DP2_DISABLE				0x00020000
+#define SET_RGB2YUV_ENABLE			0x00040000
+#define SET_RGB2YUV_DISABLE			0x00080000
+#define SET_CCIR656_ENABLE			0x00100000
+#define SET_CCIR656_DISABLE			0x00200000
+#define SET_CH0YUV2RGB_ENABLE		0x00400000
+#define SET_CH0YUV2RGB_DISABLE		0x00800000
+#define SET_CH1CHROMA_ENABLE		0x01000000
+#define SET_CH1CHROMA_DISABLE		0x02000000
+#define SET_CH2CHROMA_ENABLE		0x04000000
+#define SET_CH2CHROMA_DISABLE		0x08000000
+#define SET_CH1ALPHA_ENABLE			0x10000000
+#define SET_CH1ALPHA_DISABLE		0x20000000
+#define SET_CH2ALPHA_ENABLE			0x40000000
+#define SET_CH2ALPHA_DISABLE		0x80000000
+
+#define	LCD_CH	1
+#define	IMG_CH0	2
+#define	IMG_CH1	4
+#define	IMG_CH2	8
+
+
+#define SET_IMAGE_SIZE			0x00000001
+#define SET_IMAGE_POSITION		0x00000002
+#define SET_IMAGE_OFFSET		0x00000004
+#define SET_IMAGE_SCALE			0x00000008
+#define SET_IMAGE_FORMAT		0x00000010
+#define READ_IMAGE_POSITION		0x00000020
+#define SET_IMAGE_ALL			0x0000003F
+#define SET_LCD_POLARITY		0x00000040
+#define SET_LCD_MASK			0x00000080
+#define SET_LCD_ALL				0x000000C0
+
+#define	IMG_LIT_ENDIAN		((0x0)<<7)
+#define	IMG_BIG_ENDIAN		((0x1)<<7)
+#define	IMG_RGB				((0x0)<<4)
+#define	IMG_YUV420			((0x1)<<4)
+#define	IMG_YUV422			((0x3)<<4)
+#define	IMG_YUV422_DISP		((0x7)<<4)
+#define	IMG_BPP_1			((0x0)<<0)
+#define	IMG_BPP_2			((0x1)<<0)
+#define	IMG_BPP_4			((0x2)<<0)
+#define	IMG_BPP_332			((0x3)<<0)
+#define	IMG_BPP_444			((0x4)<<0)
+#define	IMG_BPP_565			((0x5)<<0)
+#define	IMG_BPP_555			((0x6)<<0)
+#define	IMG_BPP_888			((0x7)<<0)
+#endif
+
+
+enum cif_order422 {
+	CIF_YCBYCR = 0,
+	CIF_YCRYCB,
+	CIF_CBYCRY,
+	CIF_CRYCBY,
+};
+
+enum cifout_fmt {
+	CIF_YUV422 = 0,
+	CIF_YUV420_ODD,
+	CIF_YUV420_EVEN,
+};
+
+enum cifoper_mode {
+	OPER_PREVIEW = 0,
+	OPER_CAPTURE,
+};
+
+enum jpeg_resolution{
+	CAM_UXGA = 0,     // 1600 X 1200,
+	CAM_SXGA,         // 1280 X 1024, //1280 X 960
+	CAM_XGA,          // 1024 X 768, 
+	CAM_SVGA,         // 800 X 600,   
+	CAM_VGA,          // 640 X 480,   
+	CAM_QVGA,         // 320 X 240, 
+	CAM_QCIF,		  // 176 X 144,
+	CAM_MAX
+};
+
+enum tcc_effect_type{
+	TCC_EFFECT_NORMAL,
+	TCC_EFFECT_GRAY,                    
+	TCC_EFFECT_NEGATIVE,
+	TCC_EFFECT_SEPHIA,
+	TCC_EFFECT_AQUA,
+	TCC_EFFECT_GREEN,
+	TCC_EFFECT_SKETCH,
+	TCC_EFFECT_UNDEFINED 
+};
+
+typedef struct _ZOOM_DATA
+{
+	unsigned short XOffset;
+	unsigned short YOffset;
+	unsigned short Src_HSize;
+	unsigned short Src_VSize;    
+} ZOOM_DATA;
+
+typedef struct _FRAME_DATA
+{
+	unsigned short framex;
+	unsigned short framey;
+	unsigned short cap_x;
+	unsigned short cap_y;    
+} FRAME_DATA;
+
+typedef struct {
+    unsigned int            p_Y;  
+    unsigned int            p_Cb;
+    unsigned int            p_Cr;
+}img_buf_t;
+
+typedef struct {
+    unsigned short            source_x; 		/* CIF Input-Selection width/height */
+    unsigned short            source_y;
+    unsigned short            win_hor_ofst;	/* CIF Input-Selection Hori/Vert Offset (ex. For Zoom)*/
+    unsigned short            win_ver_ofst;		
+
+    unsigned short            scaler_x;		/* CIF Scaler out */
+    unsigned short            scaler_y;
+    unsigned short            target_x;		/* CIF Crop out :: real out */
+    unsigned short            target_y;
+}cif_main_set;
+
+typedef struct
+{
+	unsigned short 			chromakey;
+	
+	unsigned char			mask_r;
+	unsigned char			mask_g;
+	unsigned char			mask_b;
+	
+	unsigned char			key_y;
+	unsigned char			key_u;
+	unsigned char			key_v;
+	
+}si_chromakey_info;
+
+typedef struct
+{
+	unsigned short 			start_x;
+	unsigned short 			start_y;
+	unsigned short 			width;
+	unsigned short 			height;
+	
+	unsigned int 			buff_offset;
+
+	si_chromakey_info		chromakey_info;			
+}cif_SuperImpose;
+
+enum capture_status{
+	CAPTURE_DONE = 0,
+	CAPTURE_NO_INT,
+	CAPTURE_OVERFLOW,
+	CAPTURE_NONE
+};
+
+typedef struct
+{
+    unsigned int            *jpg_hdr_addr;
+    unsigned int            jpg_hdr_len;
+    unsigned int            *jpg_buf_addr;
+    unsigned int            jpg_len;
+}jpeg_info;
+
+typedef struct cif_c_t {
+	enum cif_order422      	order422;
+			
+	unsigned char           polarity_pclk;
+	unsigned char           polarity_vsync;
+	unsigned char           polarity_href;
+
+	enum cifoper_mode		oper_mode;
+	unsigned char 			zoom_step; // for capture!!
+	cif_main_set			main_set;
+
+		
+	/* 2 pingpong Frame memory */
+	dma_addr_t            	base_buf;
+	unsigned int            pp_totalsize;
+	unsigned char           pp_num;        /* used pingpong memory number */
+	img_buf_t               preview_buf[TCC_CAMERA_MAX_BUFNBRS];
+	//img_buf_t				rotate_buf[2];
+	img_buf_t				capture_buf;
+
+	cif_SuperImpose			si_overlay;
+
+	jpeg_info				jpg_info;
+	enum cifout_fmt         fmt;
+
+	volatile unsigned char	now_frame_num; // current buffer_index
+
+	volatile unsigned char			esd_restart;
+
+	//Retry Capture
+	volatile enum capture_status	cap_status;
+	volatile unsigned char			retry_cnt;
+} cif_cfg_t;
+
+/* NUM_CAMDMA_CHANNELS is the number of logical channels used for
+ * DMA data transfer.
+ */
+#define NUM_CAMDMA_CHANNELS 2
+/*
+ * info for buffer allocation
+ */
+struct cif_dma_buffer {
+	unsigned char *area;	/* virtual pointer */
+	dma_addr_t addr;	/* physical address */
+	size_t bytes;		/* buffer size in bytes */
+	void *private_data; /* private for allocator; don't touch */
+};
+
+#if 0
+/* buffer info */
+
+struct cif_buffer_info {
+	int state;			/* state of buffer */
+	unsigned long size; 	/* size of jpg frame */
+	struct timeval timestamp;	/* timestamp */
+	unsigned long sequence; 	/* sequence number */
+};
+
+#endif 
+
+enum tcc_cif_buffer_state {
+	TCC_CIF_BUF_UNUSED,  /* not used */
+	TCC_CIF_BUF_QUEUED,
+	TCC_CIF_BUF_USING,    /* currently grabbing / playing */
+	TCC_CIF_BUF_GRABBING,
+	TCC_CIF_BUF_DONE,     /* done */	
+	TCC_CIF_BUF_ERROR,
+};
+
+
+enum tcc_stream_state {
+	STREAM_OFF,
+	STREAM_INTERRUPT,
+	STREAM_ON,
+};
+
+
+/*
+ * Tracking of streaming I/O buffers.
+ */
+struct tccxxx_cif_buffer {
+	struct list_head buf_list;
+	struct v4l2_buffer v4lbuf;
+	enum tcc_cif_buffer_state state;	
+//	char *buffer;	/* Where it lives in kernel space */
+	int mapcount;
+	unsigned long vma_use_count;		
+	struct TCCxxxCIF *cam;	
+};
+
+struct TCCxxxCIF{
+	
+	cif_cfg_t cif_cfg;
+	/* frequncy (in Hz) of camera interface functional clock (ocp_clk) */
+	//unsigned long ocp_clk; 
+
+	struct timer_list cam_timer;
+
+	struct list_head list;
+	struct list_head done_list;
+	
+//	struct cif_buffer	buf[TCC_CAMERA_MAX_BUFNBRS]; 		
+	//wkjung 0412
+	struct tccxxx_cif_buffer static_buf[TCC_CAMERA_MAX_BUFNBRS]; 			
+	struct tccxxx_cif_buffer *buf; 			
+	struct cif_dma_buffer cif_buf;
+	unsigned int n_sbufs;		/* How many we have */	
+
+	wait_queue_head_t frame_wait;	/* Waiting on frame data */	
+	spinlock_t dev_lock;  /* Access to device */	
+	struct mutex	lock;	
+
+	enum tcc_stream_state stream_state;
+	
+	int new;
+};
+
+
+#define VIDIOC_USER_CIF_OVERLAY  		_IOWR ('V', BASE_VIDIOC_PRIVATE, 	cif_SuperImpose)
+#define VIDIOC_USER_JPEG_CAPTURE  		_IOWR ('V', BASE_VIDIOC_PRIVATE+1, 	int)
+#define VIDIOC_USER_GET_CAPTURE_INFO  	_IOWR ('V', BASE_VIDIOC_PRIVATE+2,  TCCXXX_JPEG_ENC_DATA)
+
+extern int	tccxxx_cif_buffer_set(struct v4l2_requestbuffers *req);
+extern int  tccxxx_cif_cam_restart(struct v4l2_pix_format *pix, unsigned long xclk);
+extern int  tccxxx_cif_start_stream(void);
+extern int  tccxxx_cif_stop_stream(void);
+extern void tccxxx_cif_set_overlay(void);
+extern int 	tccxxx_cif_set_effect (u8 nCameraEffect);
+extern int 	tccxxx_cif_capture(int quality);
+extern int 	tccxxx_cif_set_zoom(unsigned char arg);
+extern int 	tccxxx_cif_set_resolution(unsigned int pixel_fmt, unsigned short width, unsigned short height);
+extern int 	tccxxx_cif_open(void);
+extern int 	tccxxx_cif_close(void);
+extern int 	tccxxx_cif_init(void);
+
+#endif /* TCCXX_CIF_H */
Index: linux-2.6.29/drivers/media/video/tcccam/tcc_cam_i2c.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/tcccam/tcc_cam_i2c.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,478 @@
+/****************************************************************************
+ *   
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+****************************************************************************/
+
+#include <bsp.h>
+#include "tcc_cam_i2c.h"
+#include <asm/delay.h>
+
+
+#include "sensor_if.h"
+
+#define 		I2C_WR		0
+#define 		I2C_RD		1
+
+static char I2C_use_flag;
+
+//Functions
+static unsigned char i2c_read(unsigned int i2ctgt, unsigned char SlaveAddr, char addr, unsigned char *ptr, unsigned char bytes);
+static unsigned char i2c_write(unsigned int i2ctgt, unsigned char SlaveAddr, char addr, unsigned char *ptr, unsigned char bytes);
+void i2c_init(void);
+static int i2c_register(unsigned int i2ctgt);
+int	DDI_I2C_Initialize(void);
+
+
+typedef struct stI2C_Vector
+{
+	unsigned long int tgtaddr;	
+	unsigned long int port;
+}tI2C_Vector;
+
+static unsigned int	guiI2CTgt;
+
+static const tI2C_Vector I2C_VectorTable[I2C_MAX_VECTOR + 1][I2C_SIGNAL_BUS] =
+{
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	{{0xF0102000, Hw0}, {0xF0102000, Hw1}}, //CODEC
+	{{0xF0102000, Hw0}, {0xF0102000, Hw1}}, //TVOUT
+	{{0xF0102000, Hw8}, {0xF0102000, Hw9}}, //TOUCH
+	{{0xF0102000, Hw8}, {0xF0102000, Hw9}}, //CAMERA
+	{{0xF0102000, Hw0}, {0xF0102000, Hw1}}, //I2C_MAX_VECTOR
+#else
+	{{HwGPADAT_Addr, Hw0}, {HwGPADAT_Addr, Hw1}}, //CODEC
+	{{HwGPADAT_Addr, Hw0}, {HwGPADAT_Addr, Hw1}}, //TVOUT
+	{{HwGPADAT_Addr, Hw8}, {HwGPADAT_Addr, Hw9}}, //TOUCH
+	{{HwGPADAT_Addr, Hw0}, {HwGPADAT_Addr, Hw1}}, //CAMERA
+	{{HwGPADAT_Addr, Hw0}, {HwGPADAT_Addr, Hw1}}, //I2C_MAX_VECTOR
+#endif
+};
+static tI2C_Vector I2C_Vector[I2C_SIGNAL_BUS];
+
+static void delay760(unsigned int count)
+{
+	#define DELAYCNT	1
+	for(count=DELAYCNT;count>0;count--) {
+		udelay(4);
+	}
+	#undef	DELAYCNT
+}
+
+// start bit
+static void i2c_comm_s(void)
+{	
+	i2c_wr;
+	i2c_clk_hi;
+	i2c_data_hi;
+	delay760(i2c_Tbuf);
+		
+	i2c_wr;
+	i2c_data_lo;
+	delay760(i2c_Thold);
+	i2c_clk_lo;
+	delay760(i2c_Thold);
+}
+
+// data out
+static void i2c_out_byte(unsigned char *ptr)
+{	
+	unsigned char i, temp;
+
+	i2c_wr;
+	for(i=0;i<8;i++)
+	{
+		temp = *ptr << i;
+		temp &= 0x80;
+		if(temp){
+			i2c_data_hi;
+		}else{
+			i2c_data_lo;
+		}
+		delay760(i2c_Tsetup);
+		
+		i2c_clk_hi;
+		delay760(i2c_Thold);
+		
+		i2c_clk_lo;
+		delay760(i2c_Thold);
+	}
+}
+
+// get acknowledge
+static unsigned char i2c_get_ack(void)
+{	
+	unsigned char i=0;
+
+	i2c_rd;
+	
+	i2c_clk_hi;
+	delay760(i2c_Tcatch);
+
+	i = (unsigned char)((*(volatile unsigned long int *)I2C_Vector[I2C_DATA].tgtaddr) & (I2C_Vector[I2C_DATA].port)); 	   
+	delay760(i2c_Tcatch);
+	
+	i2c_clk_lo;
+	delay760(i2c_Thold);
+	
+	return i;
+}
+
+
+// Input Byte
+static void i2c_in_byte(unsigned char *ptr)
+{
+	unsigned int i, temp=0;
+	
+	i2c_rd;
+
+	for(i=0;i<8;i++)
+	{
+		i2c_clk_hi;
+		delay760(i2c_Tcatch);
+
+		temp = (unsigned int)(  ( (*(volatile unsigned long int *)(I2C_Vector[I2C_DATA].tgtaddr)) & (I2C_Vector[I2C_DATA].port))) ? 1 : 0;
+
+		if(i == 0) *ptr = temp;
+		else *ptr = (*ptr << 1) | temp;
+		delay760(i2c_Tcatch);
+		
+		i2c_clk_lo;
+		delay760(i2c_Thold);
+	}
+}
+
+// put acknowledge
+static void i2c_do_ack(unsigned char bit)
+{
+
+	i2c_wr;
+
+	if(bit){
+		i2c_data_hi;
+	}else{
+		i2c_data_lo;
+	}
+	delay760(i2c_Tsetup);
+		
+	i2c_clk_hi;
+	delay760(i2c_Thold);
+	
+	i2c_clk_lo;
+	delay760(i2c_Thold);
+}
+
+// stop bit	HwGDATA_A |= CODEC_SDIN_SET;
+static void i2c_comm_p(void)
+{
+	i2c_wr;
+	i2c_data_lo;
+	delay760(i2c_Tsetup);
+	
+	i2c_clk_hi;
+	delay760(i2c_Thold);
+	
+	i2c_data_hi;
+	delay760(i2c_Tbuf);
+}
+
+
+void i2c_init(void)
+{
+	// transfer rate setting... 8bit
+	I2C_use_flag = I2C_FREE;
+}
+
+static void TC_TimeDly(int ticks){
+	int ms;
+	while(ticks --){
+		ms = 100;
+		while(ms --);
+	}
+}
+
+static unsigned char i2c_write(unsigned int i2ctgt, unsigned char SlaveAddr, char subaddr, unsigned char *ptr, unsigned char bytes )
+{
+	unsigned char SA = SlaveAddr | I2C_WR ;
+	unsigned char i;
+
+	//RETAILMSG(TRUE, (TEXT("Wavedev:::i2c_write\r\n")));
+	
+	/* for prevent from access on same time */
+	while( I2C_use_flag == I2C_USED ) {
+		TC_TimeDly(1);
+	}
+	I2C_use_flag = I2C_USED;
+
+	i2c_register(i2ctgt);
+
+	i2c_wr;
+	i2c_clk_hi;
+	i2c_data_hi;
+	delay760(i2c_Tbuf);
+	
+	i2c_comm_s();
+	i2c_out_byte(&SA); // slave address | write
+
+	if(i2c_get_ack() != i2c_ack) 
+	{
+		i2c_comm_p();
+		I2C_use_flag = I2C_FREE;
+		return i2c_err;
+	}
+
+	if( subaddr != (char)I2C_SUBADDR_NOUSE )
+	{
+		i2c_out_byte((unsigned char*)&subaddr); // address
+
+		if(i2c_get_ack() != i2c_ack) 
+		{
+			i2c_comm_p();
+			I2C_use_flag = I2C_FREE;
+			return i2c_err;
+		}
+	}
+
+	for(i=0; i<bytes ; i++)
+	{		
+		i2c_out_byte(ptr);
+		
+		if(i2c_get_ack()) ;
+		else		  ;
+		
+		ptr++;
+	}
+	
+	i2c_comm_p();
+	
+	I2C_use_flag = I2C_FREE;
+	return i2c_ok;
+}
+
+static unsigned char i2c_read(unsigned int i2ctgt, unsigned char SlaveAddr, char subaddr, unsigned char *ptr, unsigned char bytes)
+{
+	unsigned char i;
+	unsigned char SA = SlaveAddr | I2C_WR ;
+
+	/* for prevent from access on same time */
+	while( I2C_use_flag == I2C_USED ) {
+		TC_TimeDly(1);
+	}
+	I2C_use_flag = I2C_USED;
+
+	i2c_register(i2ctgt);
+
+	if( subaddr != (char)I2C_SUBADDR_NOUSE )
+	{
+		i2c_wr;
+		i2c_clk_hi;
+		i2c_data_hi;
+		delay760(i2c_Tbuf);
+	
+		i2c_comm_s();
+		i2c_out_byte(&SA); // address | write
+
+		if(i2c_get_ack() != i2c_ack) 
+		{
+			i2c_comm_p();
+			I2C_use_flag = I2C_FREE;
+			return i2c_err;
+		}
+
+		i2c_out_byte((unsigned char*)&subaddr);
+		
+		if(i2c_get_ack() != i2c_ack) 
+		{
+			i2c_comm_p();
+			I2C_use_flag = I2C_FREE;
+			return i2c_err;
+		}
+	}
+
+	i2c_wr;
+	i2c_data_hi;
+	i2c_clk_hi;
+	delay760(i2c_Tbuf);
+
+	SA = SlaveAddr | I2C_RD ;	
+	i2c_comm_s();
+	i2c_out_byte(&SA); // Addr | Read
+	
+	if(i2c_get_ack() != i2c_ack) 
+	{
+		i2c_comm_p();
+		I2C_use_flag = I2C_FREE;
+		return i2c_err;
+	}
+	
+	for(i=0;i<bytes;i++)
+	{		
+		i2c_in_byte(ptr);
+
+		if(i < (bytes-1)) i2c_do_ack(i2c_ack);
+		else  i2c_do_ack(i2c_noack);
+		
+		ptr++;
+	}
+	
+	i2c_comm_p();
+
+	I2C_use_flag = I2C_FREE;
+	return i2c_ok;
+}
+
+static int i2c_register(unsigned int i2ctgt)
+{
+	guiI2CTgt = i2ctgt;
+
+	I2C_Vector[I2C_CLK] = I2C_VectorTable[i2ctgt][I2C_CLK];
+	I2C_Vector[I2C_DATA] = I2C_VectorTable[i2ctgt][I2C_DATA];
+
+	return 1;
+}
+
+
+
+#ifdef USING_HW_I2C
+static void OpenI2C(unsigned int i2c_clock)
+{
+	int iCnt;
+
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	unsigned int i2c_clk_input_freq, prescale;
+
+	//tca_ckc_setswreset(RB_I2CCONTROLLER, OFF);
+	//tca_ckc_setswreset(RB_I2CCONTROLLER, ON);
+
+	tca_ckc_setiobus(RB_I2CCONTROLLER, ENABLE);
+
+	BITCSET(HwGPIOA->GPFN1, HwPORTCFG_GPFN0_MASK, HwPORTCFG_GPFN0(1));  // A[8]		SCL1
+	BITCSET(HwGPIOA->GPFN1, HwPORTCFG_GPFN1_MASK, HwPORTCFG_GPFN1(1));  // A[9]		SDA1
+
+
+	/* I2C IO-bus enable */
+	tca_ckc_setiobus(RB_I2CCONTROLLER, ENABLE);
+
+	/* get I2C bus clock
+	 * bootloader set I2C bus clock
+	 */
+	i2c_clk_input_freq = tca_ckc_getperi(PERI_I2C);
+
+	prescale = ((i2c_clk_input_freq / 10) / (i2c_clock * 5)) - 1;
+	HwI2CMASTER1->PRES = prescale;
+	HwI2CMASTER1->CTRL = Hw7 | Hw6 | HwZERO;	// start enable, stop enable, 8bit mode
+	BITSET(HwI2CMASTER1->CMD, Hw0);			// clear pending interrupt
+
+	printk("i2c-1 SCK(%d) <-- input clk(%dKhz), prescale(%d)\n", i2c_clock, i2c_clk_input_freq, prescale);
+
+#else
+	
+	IO_CKC_EnableBUS_I2C();
+	BITCLR(HwPCK_I2C, Hw28);	// enable
+	IO_CKC_SetI2CClock(41000);		// 196.8Mhz / 48 = 4.1Mhz
+
+	BITSET(HwSWRESET, HwSWRESET_I2C_ON);
+	BITCLR(HwSWRESET, HwSWRESET_I2C_ON);
+
+	BITCSET(HwI2CMCH0_PRES, 0xFFFFFFFF, 0x0000003C);	// 4.1Mhz / 61 = 68.33Khz
+	BITSET(HwI2CMCH0_CTRL, HwI2CMCH0_CTRL_EN_ON);
+
+	for (iCnt=0;iCnt<10;iCnt++);
+
+	BITCLR(HwI2CMCH0_CTRL, HwI2CMCH0_CTRL_EN_ON);
+	BITCLR(HwPCK_I2C, Hw28);	// enable
+	IO_CKC_DisableBUS_I2C();
+#endif
+}
+
+
+static void CloseI2C(void)
+{
+/*
+	IIC_STOP();
+
+	BITCLR(HwI2CMCH0_CTRL, HwI2CMCH0_CTRL_IEN_ON);
+	BITCLR(HwI2CMCH0_CTRL, HwI2CMCH0_CTRL_EN_ON);
+	BITCLR(HwPCK_I2C, HwPCK_I2C_EN_EN);
+	IO_CKC_DisableBUS_I2C();
+	*/
+}
+#endif
+
+int	DDI_I2C_Initialize(void)
+{
+#ifdef USING_HW_I2C
+	OpenI2C(200); //200Khz
+#endif
+
+	return 0;
+}
+
+
+int	DDI_I2C_Terminate(void)
+{
+	//CloseI2C();
+	
+	return 0;
+}
+
+
+
+static int	DDI_I2C_Write(unsigned int uiFlag, unsigned int uiHbyte, unsigned int uiLbyte)
+{
+//	I2C_SW_WRITE_t	*I2C_SwWrite;
+	int iReturn = 0;
+	unsigned char ucSzDataBuff[2];//,  ucSize;
+	char  cSubAddr;
+	char bytes;
+        						
+	if(uiFlag == I2C_CAMERA)
+	{
+		cSubAddr = (char)uiHbyte;
+
+	#if defined(CONFIG_VIDEO_CAMERA_SENSOR_MT9D111)
+		ucSzDataBuff[0] =(unsigned char *)( (uiLbyte&0xff00)>>8);
+		ucSzDataBuff[1]= (unsigned char *)(uiLbyte&0x00ff);
+		bytes = 2;
+	#else
+		ucSzDataBuff[0] = (unsigned char)uiLbyte;
+		bytes = 1;
+	#endif
+
+		iReturn = i2c_write(uiFlag, (unsigned char)SENSOR_I2C_ADDR, cSubAddr, ucSzDataBuff, bytes);  
+	}
+	
+	return iReturn;
+}
+
+static int	DDI_I2C_Read(unsigned int uiFlag, unsigned int uiHbyte, unsigned int uiLbyte)
+{
+	
+	return 0;
+}
+
+//***********************************************************
+int CAMERA_SEND_CMD(unsigned char hb, unsigned short lb)
+{
+	int err=0;
+
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	BITCSET(HwGPIOA->GPFN1, HwPORTCFG_GPFN0_MASK, HwPORTCFG_GPFN0(0));  // A[8]		SCL1
+	BITCSET(HwGPIOA->GPFN1, HwPORTCFG_GPFN1_MASK, HwPORTCFG_GPFN1(0));  // A[9]		SDA1
+	err=	DDI_I2C_Write(I2C_CAMERA, hb, lb);
+	BITCSET(HwGPIOA->GPFN1, HwPORTCFG_GPFN0_MASK, HwPORTCFG_GPFN0(1));  // A[8]		SCL1
+	BITCSET(HwGPIOA->GPFN1, HwPORTCFG_GPFN1_MASK, HwPORTCFG_GPFN1(1));  // A[9]		SDA1
+#else
+	BITCSET(HwPORTCFG11, (0x0f<<4),HwZERO);
+	err=	DDI_I2C_Write(I2C_CAMERA, hb, lb);
+	BITCSET(HwPORTCFG11, (0x0f<<4),Hw0<<4);
+#endif
+
+	udelay(500);
+
+	return err;
+}
+
+/* end of file */
+
Index: linux-2.6.29/drivers/media/video/tcccam/tcc_cam_i2c.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/tcccam/tcc_cam_i2c.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,104 @@
+/****************************************************************************
+ *   TCC Version 0.6
+ *   Copyright (c) telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+****************************************************************************/
+
+#ifndef __TCC7901_I2C_H_char__
+#define __TCC7901_I2C_H_char__
+
+#if defined(CONFIG_ARCH_TCC92X)
+#include <mach/bsp.h>
+#elif defined(CONFIG_ARCH_TCC79X)
+#include <mach/tcc79x.h>
+#endif
+#include "sensor_if.h"
+
+#define	IO_CKC_EnableBUS_I2C()		(BITSET(HwBCLKCTR, HwBCLKCTR_I2C_ON))
+#define	IO_CKC_DisableBUS_I2C()		(BITCLR(HwBCLKCTR, HwBCLKCTR_I2C_ON))
+
+#define IO_CKC_Fxin 120000
+
+/************************************************************************
+ * I2C define
+ ***********************************************************************/
+#define		i2c_ack		0					// i2c acknowledgement
+#define		i2c_noack		1					// i2c no acknowledgement
+#define		i2c_err		0					// i2c error occurs
+#define		i2c_ok			1					// i2c error does not occurs
+
+
+// I2C-bus standard mode timing setting
+#define		i2c_Tbuf		400		//200
+#define		i2c_Tsetup		8		//4//8		// above min 250ns
+#define		i2c_Thold		200		//100		// the fm_Thold is a basic time as above min 5us
+#define		i2c_Tcatch		100		//50		// the half of the i2c_Thold
+
+#define 		I2C_SUBADDR_NOUSE 	-1
+
+// Message 
+#define I2C_FREE	0
+#define I2C_USED	1
+
+
+
+enum 
+{
+	I2C_CODEC,
+	I2C_TVOUT,
+	I2C_TOUCH,
+	I2C_CAMERA,
+	I2C_MAX_VECTOR
+} ;
+
+enum
+{
+	I2C_CLK,
+	I2C_DATA,
+	I2C_SIGNAL_BUS
+};
+
+#define		i2c_wr			(*(volatile unsigned long int *)(I2C_Vector[I2C_DATA].tgtaddr+0x04) |= (I2C_Vector[I2C_DATA].port));
+#define		i2c_rd			(*(volatile unsigned long int *)(I2C_Vector[I2C_DATA].tgtaddr+0x04) &= ~(I2C_Vector[I2C_DATA].port));
+#define		i2c_clk_hi		(*(volatile unsigned long int *)(I2C_Vector[I2C_CLK].tgtaddr) |= (I2C_Vector[I2C_CLK].port));
+#define		i2c_clk_lo		(*(volatile unsigned long int *)(I2C_Vector[I2C_CLK].tgtaddr) &= ~(I2C_Vector[I2C_CLK].port));	
+#define		i2c_data_hi		(*(volatile unsigned long int *)(I2C_Vector[I2C_DATA].tgtaddr) |= (I2C_Vector[I2C_DATA].port)); 	   
+#define		i2c_data_lo		(*(volatile unsigned long int *)(I2C_Vector[I2C_DATA].tgtaddr) &= ~(I2C_Vector[I2C_DATA].port)); 	 
+
+
+//**********************************************************************
+#define codec_slaveaddr	0x34	//WM8731 / TLV320 CODEC slave addr
+#define touch_slaveaddr	0x90	//TSC2003 A/D conveter slave addr
+
+
+typedef struct I2C_SW_READ_s
+{
+	unsigned int i2ctgt;
+	unsigned char SlaveAddr;
+	char subaddr;
+	unsigned char *ptr;
+	unsigned char bytes;
+	unsigned char i2c_return;
+} I2C_SW_READ_t;
+
+typedef struct I2C_SW_WRITE_s
+{
+	unsigned int i2ctgt;
+	unsigned char SlaveAddr;
+	char subaddr;
+	unsigned char *ptr;
+	unsigned char bytes;
+	unsigned char i2c_return;
+} I2C_SW_WRITE_t;
+
+
+//***********************************************************************
+extern void i2c_init(void);
+extern int	DDI_I2C_Initialize(void);
+extern int	DDI_I2C_Terminate(void);
+
+
+
+#endif /*__TCC7901_I2C_H_char__*/
+
Index: linux-2.6.29/drivers/media/video/tcccam/tcc_cam_inc.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/tcccam/tcc_cam_inc.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,17 @@
+/****************************************************************************
+ *	 TCC Version 0.6
+ *	 Copyright (c) telechips, Inc.
+ *	 ALL RIGHTS RESERVED
+ *
+****************************************************************************/
+#include <mach/memory.h>
+
+
+/* memory allocation */
+#define PMEM_ADSP_BASE		TCC_VPU_OFFSET
+
+#define PREVIEW_MEM			0x800000	// 8MB
+#define CAPTURE_MEM      	0x600000 	//0x600000 	//6144*1024
+#define JPEG_MEM      	 	0x200000 	//0x200000 	//2048*1024
+#define PA_VIDEO_BASE 	 	PMEM_ADSP_BASE
+
Index: linux-2.6.29/drivers/media/video/tcccam/tdd_cif.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/tcccam/tdd_cif.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,2881 @@
+/************************************************************************
+*    Telechips Multi Media Player
+*    ------------------------------------------------
+*
+*    FUNCTION    : CAMERA INTERFACE API
+*    MODEL        : DMP
+*    CPU NAME    : TCCXXX
+*    SOURCE        : tdd_cif.c
+*
+*    START DATE    : 2008. 4. 17.
+*    MODIFY DATE :
+*    DEVISION    : DEPT. SYSTEM 3-2 TEAM
+*                : TELECHIPS, INC.
+************************************************************************/
+#include <linux/delay.h>
+#include <asm/system.h>
+#include <mach/hardware.h>
+#include <asm/io.h>
+
+#include <bsp.h>
+
+#include "sensor_if.h"
+#include "cam.h"
+#include "cam_reg.h"
+#include "tdd_cif.h"
+
+#if defined(CONFIG_ARCH_TCC8900)
+#include <mach/tcc_pca953x.h>
+#endif
+
+
+#if defined(CONFIG_ARCH_TCC92X)
+#define CAM_PWR_ENABLE()		(HwGPIOD->GPEN |= Hw10);	(HwGPIOD->GPDAT |= Hw10);
+#define CAM_PWR_DISABLE()		(HwGPIOD->GPEN |= Hw10);	(HwGPIOD->GPDAT &= ~Hw10);
+#define CAM_PWRDN_ENABLE()		(HwGPIOF->GPEN |= Hw21);	(HwGPIOF->GPDAT |= Hw21);
+#define CAM_PWRDN_DISABLE()		(HwGPIOF->GPEN |= Hw21);	(HwGPIOF->GPDAT &= ~Hw21);
+#define CAM_RESET_HIGH()			(HwGPIOE->GPEN |= Hw2);		(HwGPIOE->GPDAT |= Hw2);
+#define CAM_RESET_LOW()			(HwGPIOE->GPEN |= Hw2);		(HwGPIOE->GPDAT &= ~Hw2);
+//#define CAM_MCLK_ENABLE()		BITSET(HwCIF->HwPCK_CAM, HwPCK_EN_EN);
+//#define CAM_MCLK_DISABLE()		BITCLR(HwCIF->HwPCK_CAM, HwPCK_EN_EN);
+#elif defined(CONFIG_ARCH_TCC8900)
+#define CAM_PWR_ENABLE()		TDD_CIF_PWRCtrl(1);
+#define CAM_PWR_DISABLE()		TDD_CIF_PWRCtrl(0);
+#define CAM_PWRDN_ENABLE()
+#define CAM_PWRDN_DISABLE()
+#define CAM_RESET_HIGH()		(HwGPIOE->GPEN |= Hw26);	(HwGPIOE->GPDAT |= Hw26);
+#define CAM_RESET_LOW()			(HwGPIOE->GPEN |= Hw26);	(HwGPIOE->GPDAT &= ~Hw26);
+//#define CAM_MCLK_ENABLE()		BITSET(HwCIF->HwPCK_CAM, HwPCK_EN_EN);
+//#define CAM_MCLK_DISABLE()		BITCLR(HwCIF->HwPCK_CAM, HwPCK_EN_EN);
+#elif defined(CONFIG_ARCH_TCC79X)
+#define CAM_PWR_ENABLE()
+#define CAM_PWR_DISABLE()
+ #define CAM_PWRDN_ENABLE()	(HwGPFEN |= Hw1); 	(HwGPFDAT |= Hw1);
+#define CAM_PWRDN_DISABLE()	(HwGPFEN |= Hw1); 	(HwGPFDAT &= ~Hw1);
+#define CAM_RESET_HIGH()		(HwGPEEN |= Hw9); 	(HwGPEDAT |= Hw9);
+#define CAM_RESET_LOW()		(HwGPEEN |= Hw9); 	(HwGPEDAT &= ~Hw9);
+//#define CAM_MCLK_ENABLE()		BITSET(HwPCK_CAM, HwPCK_EN_EN);
+//#define CAM_MCLK_DISABLE()		BITCLR(HwPCK_CAM, HwPCK_EN_EN);
+#endif
+
+#if defined(CONFIG_ARCH_TCC8900)
+void TDD_CIF_PWRCtrl(int pwrctrl_onoff)
+{
+	int state;
+	if (pwrctrl_onoff)
+		state = ON;
+	else
+		state = OFF;
+
+	tcc_pca953x_setup(PCA9539_U3_SLAVE_ADDR, Hw3, OUTPUT, state, SET_DIRECTION|SET_VALUE);
+}
+#endif
+
+void cif_delay(int ms)
+{
+#if 1 //ZzaU
+	unsigned int msec;
+
+	msec = ms / 10; //10msec unit
+
+	if(!msec)
+		msleep(1);
+	else
+		msleep(msec);
+#else
+	int totCnt, iCnt, temp = 0;
+
+	totCnt = ms*20000;
+	for(iCnt = 0; iCnt < totCnt; iCnt++)
+	{
+		temp++;
+	}
+#endif
+}
+
+void TDD_CIF_Reset(void)
+{
+	CAM_RESET_HIGH();
+	cif_delay(15);//msleep(1);
+	//CAM_RESET_LOW();
+	//cif_delay(15);//msleep(15);
+	//CAM_RESET_HIGH();
+	//cif_delay(15);//msleep(15);
+	//CAM_RESET_LOW();
+	//cif_delay(15);//msleep(15);
+	//CAM_RESET_HIGH();  
+	//cif_delay(15);//msleep(15);
+
+}
+
+void TDD_CIF_Initialize()
+{
+#if 0
+	//(CONFIG_ARCH_TCC92X)
+	//DMA transfer  ready   write    transfer..
+	BITCSET(HwDDI_CACHE->DDIC_CTRL, HwDDIC_CTRL_BW, 0x80000000);
+
+	//GPIO Functional setting!!
+	BITCSET(HwGPIOE->GPFN1, 0xFFFF0000, 0x11110000);	
+	HwGPIOE->GPFN2	= 0x11111111;
+
+	//PWDN/Reset/Power Normal GPIO setting!!
+	HwGPIOF->GPFN2 &= ~0x00F00000; // PWDN
+	HwGPIOE->GPFN0	&= ~0x00000F00; // Reset
+	HwGPIOD->GPFN1 &= ~0x00000F00; // Power Ctrl	
+
+	// Set Pull-Up/Down Control
+	BITSET( HwGPIOE->GPPD0, 0xAA000000 ); // D0~D3
+	BITSET( HwGPIOE->GPPD1, 0x000028AA ); // D4~D7, VS, HS	
+#endif
+
+	//(CONFIG_ARCH_TCC8900)
+
+	//DMA transfer  ready   write    transfer..
+	BITCSET(HwDDI_CACHE->DDIC_CTRL, HwDDIC_CTRL_BW, 0x80000000);
+
+#if 0
+	//This register doesn't exist.
+	//BITSET(HwBCLKCTR, HwBCLKCTR_CIC_ON|Hw30); //CAM and MailBox
+	BITSET(HwCKC->PCLK_CIFMC, Hw28);
+#endif
+
+	//CPD[0] - CPD[3]
+	BITCSET(HwGPIO->GPEFN1, 0xFFFF0000, Hw28|Hw24|Hw20|Hw16);
+	//CCKI, CVS, CHS, CCKO, CPD[7] - CPD[4]
+	BITCSET(HwGPIO->GPEFN2, 0xFFFFFFFF, Hw28|Hw24|Hw20|Hw16|Hw12|Hw8|Hw4|Hw0);
+	BITCLR(HwGPIO->GPEEN, 0x7FF000); // CPD Data bus as Input mode
+	BITSET(HwGPIO->GPEEN, 0x800000); // CCKO output mode
+
+	//PWDN/Reset/Power Normal GPIO setting!!
+	//Reset CAM_RST
+	BITCSET(HwGPIO->GPEFN3, (Hw12-Hw8), 0);
+	BITSET(HwGPIO->GPEEN, Hw26);
+
+	// Set Pull-Up/Down Control
+	BITCSET(HwGPIO->GPEPD0, 0xFF000000, 0xAA000000); // Camera Port D0~D3 Pull down
+	BITCSET(HwGPIO->GPEPD1, 0x00003FFF, 0x00002AAA); // Camera Port D4~D7, cvs,chs,cki Pull down
+
+#if 0
+	//Enable Scaler Clock divider enable register 
+	BITSET(HwCKC->PCLK_CIFSC, Hw28);
+	
+	//SWReset for DDIBUS(Camera interface)
+	BITSET(HwDDI_CONFIG->SWRESET, Hw0);
+	BITCLR(HwDDI_CONFIG->SWRESET, Hw0);
+#endif
+
+	CAM_PWR_ENABLE();
+	CAM_PWRDN_DISABLE();
+	cif_delay(10);
+	CAM_RESET_LOW();
+	cif_delay(10);
+
+#if defined(CONFIG_VIDEO_CAMERA_SENSOR_MT9P111)
+	cif_delay(20);
+	CIF_Open();
+	cif_delay(20);
+	
+//start standby!!
+	CAM_PWRDN_ENABLE();
+	cif_delay(20);
+
+	CIF_Close();
+	cif_delay(20);
+	CAM_PWRDN_DISABLE();
+	cif_delay(20);
+//end standby!!
+#else
+#if !defined(CONFIG_VIDEO_CAMERA_SENSOR_MT9D111) //Not apply for mt9d111!!
+	CAM_PWRDN_ENABLE();
+	cif_delay(5);
+#endif
+#endif
+
+	CIF_Open();
+	cif_delay(40);
+	
+	TDD_CIF_Reset();
+}
+
+void TDD_CIF_Termination(void)
+{
+	CIF_ONOFF(OFF);
+
+	CAM_RESET_LOW()
+	CAM_PWR_DISABLE();
+	CAM_PWRDN_DISABLE();
+
+	CIF_Close();   
+
+	msleep(5);    
+}
+
+void TDD_CIF_ONOFF(unsigned int uiOnOff)
+{
+	CIF_ONOFF(uiOnOff);
+}
+
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_setInfo
+//
+//	DESCRIPTION
+//    		set CIF register  : 	HwICPCR1
+//
+//	Parameters
+//    	
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+void TDD_CIF_SetInfo(unsigned int uiFlag, unsigned int uiBypass, unsigned int uiBypassBusSel,
+                        unsigned int uiColorPattern, unsigned int uiPatternFormat, unsigned int uiRGBMode,
+                        unsigned int uiRGBBitMode, unsigned int uiColorSequence, unsigned int uiBusOrder)
+{
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	// 1.    HwICPCR1_BP        Hw15         // Bypass 
+	if(uiFlag & SET_CIF_BYPASS_MODE)
+	{
+		BITCSET(HwCIF->ICPCR1, HwICPCR1_BP, (uiBypass << 15));
+	}
+	
+	// 2.   HwICPCR1_BBS_LSB8      Hw14         // When bypass 16bits mode, LSB 8bits are stored in first
+	if(uiFlag & SET_CIF_BYPASS_BUS)
+	{
+		BITCSET(HwCIF->ICPCR1, HwICPCR1_BBS_LSB8, (uiBypassBusSel << 14));
+	}
+	
+	// 3.   HwICPCR1_CP_RGB        Hw12         // RGB(555,565,bayer) color pattern
+	if(uiFlag & SET_CIF_COLOR_PATTERN)
+	{
+		BITCSET(HwCIF->ICPCR1, HwICPCR1_CP_RGB, (uiColorPattern << 12));
+	}
+	
+	// 4.
+	// HwICPCR1_PF_444        HwZERO       // 4:4:4 format
+	// HwICPCR1_PF_422        Hw10         // 4:2:2 format
+	// HwICPCR1_PF_420        Hw11         // 4:2:0 format or RGB(555,565,bayer) mode
+	if(uiFlag & SET_CIF_PATTERN_FORMAT)
+	{
+		BITCSET(HwCIF->ICPCR1, (HwICPCR1_PF_420|HwICPCR1_PF_422), (uiPatternFormat << 10));
+	}
+	
+	// 5.
+	// HwICPCR1_RGBM_BAYER      HwZERO       // Bayer RGB Mode
+	// HwICPCR1_RGBM_RGB555            Hw8          // RGB555 Mode
+	// HwICPCR1_RGBM_RGB565            Hw9          // RGB565 Mode
+	if(uiFlag & SET_CIF_RGB_MODE)
+	{
+		BITCSET(HwCIF->ICPCR1, (HwICPCR1_RGBM_RGB555|HwICPCR1_RGBM_RGB565), (uiRGBMode << 8));
+	}
+
+	// 6.
+	// HwICPCR1_RGBBM_16      HwZERO       // 16bit mode
+	// HwICPCR1_RGBBM_8DISYNC                  Hw6          // 8bit disable sync
+	// HwICPCR1_RGBBM_8      Hw7          // 8bit mode
+	if(uiFlag & SET_CIF_RGBBIT_MODE)
+	{
+		BITCSET(HwCIF->ICPCR1, (HwICPCR1_RGBBM_8DISYNC|HwICPCR1_RGBBM_8), (uiRGBBitMode << 6));
+	}
+	
+	// 7.  CS
+	// HwICPCR1_CS_RGBMG      HwZERO       // 555RGB:RGB(MG), 565RGB:RGB, 444/422/420:R/Cb/U first, Bayer RGB:BG->GR, CCIR656:YCbYCr
+	// HwICPCR1_CS_RGBLG      Hw4          // 555RGB:RGB(LG), 565RGB:RGB, 444/422/420:R/Cb/U first, Bayer RGB:GR->BG, CCIR656:YCrYCb
+	// HwICPCR1_CS_BGRMG      Hw5          // 555RGB:BGR(MG), 565RGB:BGR, 444/422/420:B/Cr/V first, Bayer RGB:RG->GB, CCIR656:CbYCrY
+	// HwICPCR1_CS_BGRLG      (Hw5|Hw4)    // 555RGB:BGR(LG), 565RGB:BGR, 444/422/420:B/Cr/V first, Bayer RGB:GB->RG, CCIR656:CrYCbY
+	if(uiFlag & SET_CIF_COLOR_SEQUENCE)
+	{
+		BITCSET(HwCIF->ICPCR1, HwICPCR1_CS_BGRLG, (uiColorSequence << 4));
+	}
+	
+	// 8.   HwICPCR1_BO_SW        Hw2          // Switch the MSB/LSB 8bit Bus
+	if(uiFlag & SET_CIF_BUS_ORDER)
+	{
+		BITCSET(HwCIF->ICPCR1, HwICPCR1_BO_SW, (uiBusOrder << 2));
+	}
+#else  // (CONFIG_ARCH_TCC79X)
+	// 1.    HwICPCR1_BP        Hw15         // Bypass 
+	if(uiFlag & SET_CIF_BYPASS_MODE)
+	{
+		BITCSET(HwICPCR1, HwICPCR1_BP, (uiBypass << 15));
+	}
+	
+	// 2.   HwICPCR1_BBS_LSB8      Hw14         // When bypass 16bits mode, LSB 8bits are stored in first
+	if(uiFlag & SET_CIF_BYPASS_BUS)
+	{
+		BITCSET(HwICPCR1, HwICPCR1_BBS_LSB8, (uiBypassBusSel << 14));
+	}
+	
+	// 3.   HwICPCR1_CP_RGB        Hw12         // RGB(555,565,bayer) color pattern
+	if(uiFlag & SET_CIF_COLOR_PATTERN)
+	{
+		BITCSET(HwICPCR1, HwICPCR1_CP_RGB, (uiColorPattern << 12));
+	}
+	
+	// 4.
+	// HwICPCR1_PF_444        HwZERO       // 4:4:4 format
+	// HwICPCR1_PF_422        Hw10         // 4:2:2 format
+	// HwICPCR1_PF_420        Hw11         // 4:2:0 format or RGB(555,565,bayer) mode
+	if(uiFlag & SET_CIF_PATTERN_FORMAT)
+	{
+		BITCSET(HwICPCR1, (HwICPCR1_PF_420|HwICPCR1_PF_422), (uiPatternFormat << 10));
+	}
+	
+	// 5.
+	// HwICPCR1_RGBM_BAYER      HwZERO       // Bayer RGB Mode
+	// HwICPCR1_RGBM_RGB555            Hw8          // RGB555 Mode
+	// HwICPCR1_RGBM_RGB565            Hw9          // RGB565 Mode
+	if(uiFlag & SET_CIF_RGB_MODE)
+	{
+		BITCSET(HwICPCR1, (HwICPCR1_RGBM_RGB555|HwICPCR1_RGBM_RGB565), (uiRGBMode << 8));
+	}
+	
+	// 6.
+	// HwICPCR1_RGBBM_16      HwZERO       // 16bit mode
+	// HwICPCR1_RGBBM_8DISYNC                  Hw6          // 8bit disable sync
+	// HwICPCR1_RGBBM_8      Hw7          // 8bit mode
+	if(uiFlag & SET_CIF_RGBBIT_MODE)
+	{
+		BITCSET(HwICPCR1, (HwICPCR1_RGBBM_8DISYNC|HwICPCR1_RGBBM_8), (uiRGBBitMode << 6));
+	}
+	
+	// 7.  CS
+	// HwICPCR1_CS_RGBMG      HwZERO       // 555RGB:RGB(MG), 565RGB:RGB, 444/422/420:R/Cb/U first, Bayer RGB:BG->GR, CCIR656:YCbYCr
+	// HwICPCR1_CS_RGBLG      Hw4          // 555RGB:RGB(LG), 565RGB:RGB, 444/422/420:R/Cb/U first, Bayer RGB:GR->BG, CCIR656:YCrYCb
+	// HwICPCR1_CS_BGRMG      Hw5          // 555RGB:BGR(MG), 565RGB:BGR, 444/422/420:B/Cr/V first, Bayer RGB:RG->GB, CCIR656:CbYCrY
+	// HwICPCR1_CS_BGRLG      (Hw5|Hw4)    // 555RGB:BGR(LG), 565RGB:BGR, 444/422/420:B/Cr/V first, Bayer RGB:GB->RG, CCIR656:CrYCbY
+	if(uiFlag & SET_CIF_COLOR_SEQUENCE)
+	{
+		BITCSET(HwICPCR1, HwICPCR1_CS_BGRLG, (uiColorSequence << 4));
+	}
+	
+	// 8.   HwICPCR1_BO_SW        Hw2          // Switch the MSB/LSB 8bit Bus
+	if(uiFlag & SET_CIF_BUS_ORDER)
+	{
+		BITCSET(HwICPCR1, HwICPCR1_BO_SW, (uiBusOrder << 2));
+	}
+
+#endif
+}
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_setCtrl
+//
+//	DESCRIPTION
+//    		set CIF register  : 	HwICPCR1
+//
+//	Parameters
+//    	
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+void TDD_CIF_SetCtrl(unsigned int uiFlag, unsigned int uiPWDN, unsigned int uiBypass_Scaler,
+						unsigned int uiPXCLK_POL, unsigned int uiSKPF, unsigned int uiM420_FC, unsigned int uiC656)
+{
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	// 1.  HwICPCR1_PWD      Power down mode in camera >> 0:Disable, 1:Power down mode , This power down mode is connected the PWDN of camera sensor  
+	if(uiFlag & SET_CIF_PWDN)
+	{
+		BITCSET(HwCIF->ICPCR1, HwICPCR1_PWD, (uiPWDN << 30));
+	}	
+
+	// 2.  HwICPCR1_BPS                            Hw23         // Bypass Scaler >> 0:Non, 1:Bypass    //BP_SCA
+	if(uiFlag & SET_CIF_BYPASS_SCALER)
+	{
+		BITCSET(HwCIF->ICPCR1, HwICPCR1_BPS, (uiBypass_Scaler << 23));
+	}
+	
+	// 3.  HwICPCR1_POL                            Hw21         // PXCLK Polarity >> 0:Positive edge, 1:Negative edge
+	if(uiFlag & SET_CIF_PXCLK_POL)
+	{
+		BITCSET(HwCIF->ICPCR1, HwICPCR1_POL, (uiPXCLK_POL << 21));
+	}
+	
+	// 4.  HwICPCR1_SKPF                                        // Skip Frame >> 0~7 #Frames skips   [20:18]
+	if(uiFlag & SET_CIF_SKPF)
+	{
+		BITCSET(HwCIF->ICPCR1, HwICPCR1_SKPF, (uiSKPF << 18));
+	}
+	
+	// 5.
+	//  HwICPCR1_M420_ZERO                      HwZERO        // Format Convert (YUV422->YUV420) , Not-Convert
+	//  HwICPCR1_M420_ODD                       Hw17             // converted in odd line skip   // 10
+	//  HwICPCR1_M420_EVEN                      (Hw17|Hw16)  // converted in even line skip  //11
+	if(uiFlag & SET_CIF_M42_FC)
+	{
+		BITCSET(HwCIF->ICPCR1, HwICPCR1_M420_EVEN, (uiM420_FC << 16));
+	}
+	
+	// 7.  #define HwICPCR1_C656                           Hw13         // Convert 656 format 0:Disable, 1:Enable  
+	if(uiFlag & SET_CIF_C656)
+	{
+		BITCSET(HwCIF->ICPCR1, HwICPCR1_C656, (uiC656 << 13)); // PCIF->ICPCR1
+	}
+#else //(CONFIG_ARCH_TCC79X)	
+	// 1.  HwICPCR1_PWD      Power down mode in camera >> 0:Disable, 1:Power down mode , This power down mode is connected the PWDN of camera sensor  
+	if(uiFlag & SET_CIF_PWDN)
+	{
+		BITCSET(HwICPCR1, HwICPCR1_PWD, (uiPWDN << 30));
+	}
+	
+	// 2.  HwICPCR1_BPS                            Hw23         // Bypass Scaler >> 0:Non, 1:Bypass    //BP_SCA
+	if(uiFlag & SET_CIF_BYPASS_SCALER)
+	{
+		BITCSET(HwICPCR1, HwICPCR1_BPS, (uiBypass_Scaler << 23));
+	}
+	
+	// 3.  HwICPCR1_POL                            Hw21         // PXCLK Polarity >> 0:Positive edge, 1:Negative edge
+	if(uiFlag & SET_CIF_PXCLK_POL)
+	{
+		BITCSET(HwICPCR1, HwICPCR1_POL, (uiPXCLK_POL << 21));
+	}
+	
+	// 4.  HwICPCR1_SKPF                                        // Skip Frame >> 0~7 #Frames skips   [20:18]
+	if(uiFlag & SET_CIF_SKPF)
+	{
+		BITCSET(HwICPCR1, HwICPCR1_SKPF, (uiSKPF << 18));
+	}
+	
+	// 5.
+	//  HwICPCR1_M420_ZERO                      HwZERO        // Format Convert (YUV422->YUV420) , Not-Convert
+	//  HwICPCR1_M420_ODD                       Hw17             // converted in odd line skip   // 10
+	//  HwICPCR1_M420_EVEN                      (Hw17|Hw16)  // converted in even line skip  //11
+	if(uiFlag & SET_CIF_M42_FC)
+	{
+	    BITCSET(HwICPCR1, HwICPCR1_M420_EVEN_SKIP, (uiM420_FC << 16));
+	}
+	
+	// 7.  #define HwICPCR1_C656                           Hw13         // Convert 656 format 0:Disable, 1:Enable  
+	if(uiFlag & SET_CIF_C656)
+	{
+			BITCSET(HwICPCR1, HwICPCR1_C656, (uiC656 << 13)); // PCIF->ICPCR1
+	}
+#endif
+}	
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_setTransfer
+//
+//	DESCRIPTION
+//			CIF transef mode setting
+//    		set CIF register  : 	HwCDCR1
+//
+//	Parameters
+//    	
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+void TDD_CIF_SetTransfer(unsigned int uiFlag, unsigned int uiBurst, unsigned int uiLock, unsigned int uiTransMode)
+{
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	//HwCDCR1_TM_INC        Hw3                    // INC Transfer
+	if(uiFlag & SET_CIF_TRANSFER_MODE)
+	{
+		BITCSET(HwCIF->CDCR1, HwCDCR1_TM_INC, (uiTransMode << 3));
+	}
+
+	// HwCDCR1_LOCK_ON        Hw2                    // Lock Transfer
+	if(uiFlag & SET_CIF_TRANSFER_LOCK)
+	{
+		BITCSET(HwCIF->CDCR1, HwCDCR1_LOCK_ON, (uiLock << 2));
+	}
+	
+	// HwCDCR1_BS_1    HwZERO      // The DMA transfers the image data as 1 word to memory
+	// HwCDCR1_BS_2    Hw0            // The DMA transfers the image data as 2 word to memory
+	// HwCDCR1_BS_4    Hw1            // The DMA transfers the image data as 4 word to memory
+	// HwCDCR1_BS_8    (Hw1|Hw0)  // The DMA transfers the image data as 8 word to memory (default)
+	if(uiFlag & SET_CIF_TRANSFER_BURST)
+	{
+		BITCSET(HwCIF->CDCR1, HwCDCR1_BS_8, uiBurst); // PCIF->CDCR1
+	}
+
+#else // (CONFIG_ARCH_TCC79X)
+	//HwCDCR1_TM_INC        Hw3                    // INC Transfer
+	if(uiFlag & SET_CIF_TRANSFER_MODE)
+	{
+		BITCSET(HwCDCR1, HwCDCR1_TM_INC, (uiTransMode << 3));
+	}
+	
+	// HwCDCR1_LOCK_ON        Hw2                    // Lock Transfer
+	if(uiFlag & SET_CIF_TRANSFER_LOCK)
+	{
+		BITCSET(HwCDCR1, HwCDCR1_LOCK_ON, (uiLock << 2));
+	}
+	
+	// HwCDCR1_BS_1    HwZERO      // The DMA transfers the image data as 1 word to memory
+	// HwCDCR1_BS_2    Hw0            // The DMA transfers the image data as 2 word to memory
+	// HwCDCR1_BS_4    Hw1            // The DMA transfers the image data as 4 word to memory
+	// HwCDCR1_BS_8    (Hw1|Hw0)  // The DMA transfers the image data as 8 word to memory (default)
+	if(uiFlag & SET_CIF_TRANSFER_BURST)
+	{
+		BITCSET(HwCDCR1, HwCDCR1_BS_8, uiBurst); // HwCIF->CDCR1
+	}
+#endif
+}
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_convertR2Y
+//
+//	DESCRIPTION
+//    		set CIF register  : 	HwCR2Y
+//
+//	Parameters
+//    	
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+void TDD_R2Y_Convert(unsigned int uiFlag,  unsigned int uiFMT, unsigned int uiEN)
+{
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	//HwCR2Y_FMT                                  (Hw4|Hw3|Hw2|Hw1)  // FMT[4:1]  0000 -> Input format 16bit 565RGB(RGB sequence)   750A CIF SPEC. 1-22
+	if(uiFlag & SET_CIF_CR2Y_FMT)
+	{
+		BITCSET(HwCIF->CR2Y, HwCR2Y_FMT, (uiFMT<<1));
+	}
+
+	//HwCR2Y_EN                                    Hw0          // R2Y Enable,   0:disable, 1:Enable
+	if(uiFlag & SET_CIF_CR2Y_EN)
+	{
+		BITCSET(HwCIF->CR2Y, HwCR2Y_EN, (uiEN)); // PCIF->CR2Y
+	}
+#else //(CONFIG_ARCH_TCC79X)
+	//HwCR2Y_FMT                                  (Hw4|Hw3|Hw2|Hw1)  // FMT[4:1]  0000 -> Input format 16bit 565RGB(RGB sequence)   750A CIF SPEC. 1-22
+	if(uiFlag & SET_CIF_CR2Y_FMT)
+	{
+	    BITCSET(HwCR2Y, HwCR2Y_555GAR_BGR8, (uiFMT<<1));
+	}
+	
+	//HwCR2Y_EN                                    Hw0          // R2Y Enable,   0:disable, 1:Enable
+	if(uiFlag & SET_CIF_CR2Y_EN)
+	{
+			BITCSET(HwCR2Y, HwCR2Y_EN, (uiEN)); // HwCIF->CR2Y
+	}
+
+#endif
+}
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_overlayCtrl
+//
+//	DESCRIPTION
+//    		set CIF register  : 	HwOCTRL1, HwOCTRL2
+//
+//	Parameters
+//    	
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+void TDD_CIF_OverlayCtrl(unsigned int uiFlag, unsigned int uiRgb)
+{
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	if(uiFlag & SET_CIF_ALPHA_ENABLE)
+	{
+		BITSET(HwCIF->OCTRL1, HwOCTRL1_AEN_EN);
+	}
+	
+	if(uiFlag & SET_CIF_ALPHA_DISABLE)
+	{
+		BITCLR(HwCIF->OCTRL1, HwOCTRL1_AEN_EN);
+	} 
+	if(uiFlag & SET_CIF_CHROMA_ENABLE)
+	{
+		BITSET(HwCIF->OCTRL1, HwOCTRL1_CEN_EN);
+	}
+	
+	if(uiFlag & SET_CIF_CHROMA_DISABLE)
+	{
+		BITCLR(HwCIF->OCTRL1, HwOCTRL1_CEN_EN);
+	}
+
+	if(uiFlag & SET_CIF_OVERLAY_ENABLE)
+	{    
+		BITSET(HwCIF->OCTRL1, HwOCTRL1_OE_EN);
+	}
+	
+	if(uiFlag & SET_CIF_OVERLAY_DISABLE)
+	{    
+		BITCLR(HwCIF->OCTRL1, HwOCTRL1_OE_EN);
+	}
+	
+	if(uiFlag & SET_CIF_COLOR_CONV_ENABLE)
+	{
+		BITSET(HwCIF->OCTRL2, HwOCTRL2_CONV);
+	}
+	
+	if(uiFlag & SET_CIF_COLOR_CONV_DISABLE)
+	{
+		BITCLR(HwCIF->OCTRL2, HwOCTRL2_CONV);
+	}
+	
+	if(uiFlag & SET_CIF_COLOR_MODE_RGB)
+	{
+		BITSET(HwCIF->OCTRL2, HwOCTRL2_MD);
+		BITCSET(HwCIF->OCTRL2, 0x00000006, (uiRgb << 1));        
+	}
+	
+	if(uiFlag & SET_CIF_COLOR_MODE_YUV)
+	{
+		BITCLR(HwCIF->OCTRL2, HwOCTRL2_MD);
+	}
+#else //(CONFIG_ARCH_TCC79X)	
+	if(uiFlag & SET_CIF_ALPHA_ENABLE)
+	{
+		BITSET(HwOCTRL1, HwOCTRL1_AEN_EN);
+	}
+	
+	if(uiFlag & SET_CIF_ALPHA_DISABLE)
+	{
+		BITCLR(HwOCTRL1, HwOCTRL1_AEN_EN);
+	} 
+	if(uiFlag & SET_CIF_CHROMA_ENABLE)
+	{
+		BITSET(HwOCTRL1, HwOCTRL1_CEN_EN);
+	}
+	
+	if(uiFlag & SET_CIF_CHROMA_DISABLE)
+	{
+		BITCLR(HwOCTRL1, HwOCTRL1_CEN_EN);
+	}
+	
+	if(uiFlag & SET_CIF_OVERLAY_ENABLE)
+	{    
+		BITSET(HwOCTRL1, HwOCTRL1_OE_EN);
+	}
+	
+	if(uiFlag & SET_CIF_OVERLAY_DISABLE)
+	{    
+		BITCLR(HwOCTRL1, HwOCTRL1_OE_EN);
+	}
+	
+	if(uiFlag & SET_CIF_COLOR_CONV_ENABLE)
+	{
+		BITSET(HwOCTRL2, HwOCTRL2_CONV);
+	}
+	
+	if(uiFlag & SET_CIF_COLOR_CONV_DISABLE)
+	{
+		BITCLR(HwOCTRL2, HwOCTRL2_CONV);
+	}
+	
+	if(uiFlag & SET_CIF_COLOR_MODE_RGB)
+	{
+		BITSET(HwOCTRL2, HwOCTRL2_MD);
+		BITCSET(HwOCTRL2, 0x00000006, (uiRgb << 1));        
+	}
+	
+	if(uiFlag & SET_CIF_COLOR_MODE_YUV)
+	{
+		BITCLR(HwOCTRL2, HwOCTRL2_MD);
+	}
+
+#endif
+}
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_overlaySet
+//
+//	DESCRIPTION
+//    		set CIF register  : 	HwOCTRL1
+//
+//	Parameters
+//    	
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+void TDD_CIF_SetOverlay(unsigned int uiFlag, unsigned int uiOverlayCNT, unsigned int uiOverlayMethod, 
+							 unsigned int uiXOR1, unsigned int uiXOR0, unsigned int uiAlpha1, unsigned int uiAlpha0)
+{
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	if(uiFlag & SET_CIF_OVERLAY_COUNT)
+	{
+		BITCSET(HwCIF->OCTRL1, HwOCTRL1_OCNT_MAX, (uiOverlayCNT << 24));
+	}
+
+		if(uiFlag & SET_CIF_OVERLAY_METHOD)
+	{
+		BITCSET(HwCIF->OCTRL1, HwOCTRL1_OM_BLOCK, (uiOverlayMethod << 16));
+	} 
+
+		if(uiFlag & SET_CIF_OVERLAY_XOR0)
+	{
+		BITCSET(HwCIF->OCTRL1, HwOCTRL1_XR0_100, (uiXOR0 << 9));
+	} 
+
+	if(uiFlag & SET_CIF_OVERLAY_XOR1)
+	{
+		BITCSET(HwCIF->OCTRL1, HwOCTRL1_XR1_100, (uiXOR1 << 10));
+	}	
+
+	if(uiFlag & SET_CIF_OVERLAY_ALPHA0)
+	{
+		BITCSET(HwCIF->OCTRL1, HwOCTRL1_AP0_100, (uiAlpha0 << 4));
+	}
+
+	if(uiFlag & SET_CIF_OVERLAY_ALPHA1)
+	{
+		BITCSET(HwCIF->OCTRL1, HwOCTRL1_AP1_100, (uiAlpha1 << 6));
+	} 
+#else //(CONFIG_ARCH_TCC79X)
+	if(uiFlag & SET_CIF_OVERLAY_COUNT)
+	{
+		BITCSET(HwOCTRL1, HwOCTRL1_OCNT_MAX, (uiOverlayCNT << 24));
+	}
+
+	if(uiFlag & SET_CIF_OVERLAY_METHOD)
+	{
+		BITCSET(HwOCTRL1, HwOCTRL1_OM_BLOCK, (uiOverlayMethod << 16));
+	} 
+
+	if(uiFlag & SET_CIF_OVERLAY_XOR0)
+	{
+		BITCSET(HwOCTRL1, HwOCTRL1_XR0_100, (uiXOR0 << 9));
+	} 
+
+	if(uiFlag & SET_CIF_OVERLAY_XOR1)
+	{
+		BITCSET(HwOCTRL1, HwOCTRL1_XR1_100, (uiXOR1 << 10));
+	} 
+
+	if(uiFlag & SET_CIF_OVERLAY_ALPHA0)
+	{
+		BITCSET(HwOCTRL1, HwOCTRL1_AP0_100, (uiAlpha0 << 4));
+	}
+
+	if(uiFlag & SET_CIF_OVERLAY_ALPHA1)
+	{
+		BITCSET(HwOCTRL1, HwOCTRL1_AP1_100, (uiAlpha1 << 6));
+	} 
+
+#endif
+}	
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_overlaySetKey
+//
+//	DESCRIPTION
+//    		set CIF register  : 	HwOCTRL3, HwOCTRL4
+//
+//	Parameters
+//    	
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+void TDD_CIF_SetOverlayKey(unsigned int uiFlag, unsigned int uiKEYR, unsigned int uiKEYG, unsigned int uiKEYB, 
+								 unsigned int uiMKEYR, unsigned int uiMKEYG, unsigned int uiMKEYB)
+{
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	if(uiFlag & SET_CIF_OVERLAY_KEY)
+	{
+		BITCSET(HwCIF->OCTRL3, (HwOCTRL3_KEYR_MAX|HwOCTRL3_KEYG_MAX|HwOCTRL3_KEYB_MAX), ((uiKEYR << 16)|(uiKEYG << 8)|uiKEYB));
+	} // HwCIF->OCTRL3
+
+	if(uiFlag & SET_CIF_OVERLAY_MASKKEY)
+	{
+		BITCSET(HwCIF->OCTRL4, (HwOCTRL4_MKEYR_MAX|HwOCTRL4_MKEYG_MAX|HwOCTRL4_MKEYB_MAX), ((uiMKEYR << 16)|(uiMKEYG << 8)|uiMKEYB));
+	} // HwCIF->OCTRL4
+#else //(CONFIG_ARCH_TCC79X)
+	if(uiFlag & SET_CIF_OVERLAY_KEY)
+	{
+		BITCSET(HwOCTRL3, (HwOCTRL3_KEYR_MAX|HwOCTRL3_KEYG_MAX|HwOCTRL3_KEYB_MAX), ((uiKEYR << 16)|(uiKEYG << 8)|uiKEYB));
+	} // HwCIF->OCTRL3
+
+	if(uiFlag & SET_CIF_OVERLAY_MASKKEY)
+	{
+		BITCSET(HwOCTRL4, (HwOCTRL4_MKEYR_MAX|HwOCTRL4_MKEYG_MAX|HwOCTRL4_MKEYB_MAX), ((uiMKEYR << 16)|(uiMKEYG << 8)|uiMKEYB));
+	} // HwCIF->OCTRL4
+#endif
+}
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_setSyncPol
+//
+//	DESCRIPTION
+//    		set CIF register  : 	H and V sync polarity
+//
+//	Parameters
+//    	
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+void TDD_CIF_SetSyncPol(unsigned int uiHPolarity, unsigned int uiVpolarity)
+{
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	BITCSET(HwCIF->ICPCR1, HwICPCR1_HSP_HIGH, (uiHPolarity << 1));
+	BITCSET(HwCIF->ICPCR1, HwICPCR1_VSP_HIGH, uiVpolarity); // HwCIF->ICPCR1
+#else
+	BITCSET(HwICPCR1, HwICPCR1_HSP_HIGH, (uiHPolarity << 1));
+	BITCSET(HwICPCR1, HwICPCR1_VSP_HIGH, uiVpolarity); // HwCIF->ICPCR1
+
+#endif
+}
+
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_setSyncPol
+//
+//	DESCRIPTION
+//    		set CIF register  : 	HwIIS, HwIIW1, HwIIW2, 
+// 							HwOIS, HwOIW1, HwOIW2
+//
+//	Parameters
+//                CIF_SETIMG (Camera I/F setting image)
+//                uiType                 : Input imge(INPUT_IMG), overlay image (OVER_IMG)
+//                uiHsize                : Horizontal size
+//                uiVSize                : vertical size
+//                uiHorWindowingStart    : start X position of windowing image
+//                uiHorWindowingEnd    : end X position of windowing image
+//                uiVerWindowingStart    : start Y position of windowing image
+//                uiVerWindowingEnd    : end Y position of windowing image
+//               BaseAddress0            : Y channel base address In Overlay, overlay image adress
+//               BaseAddress1            : U channel base address (don't use overlay image)
+//                BaseAddress2            : V channel base address (don't use overlay image)
+//
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+void    TDD_CIF_SetImage(unsigned int uiType, unsigned int uiHsize, unsigned int uiVsize,
+                              unsigned int uiHorWindowingStart, unsigned int uiHorWindowingEnd,
+                              unsigned int uiVerWindowingStart, unsigned int uiVerWindowingEnd)
+{
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	if (uiType & INPUT_IMG)
+	{
+		BITCSET(HwCIF->IIS, 0xFFFFFFFF, ((uiHsize << 16) | uiVsize));
+		BITCSET(HwCIF->IIW1, 0xFFFFFFFF, ((uiHorWindowingStart<< 16) | uiHorWindowingEnd));
+		BITCSET(HwCIF->IIW2, 0xFFFFFFFF, ((uiVerWindowingStart<< 16) | uiVerWindowingEnd));
+	}
+
+	if(uiType & OVERLAY_IMG)
+	{
+		BITCSET(HwCIF->OIS, 0xFFFFFFFF, ((uiHsize << 16) | uiVsize));
+		BITCSET(HwCIF->OIW1, 0xFFFFFFFF, ((uiHorWindowingStart<< 16) | uiHorWindowingEnd));
+		BITCSET(HwCIF->OIW2, 0xFFFFFFFF, ((uiVerWindowingStart<< 16) | uiVerWindowingEnd));
+	}	
+#else //(CONFIG_ARCH_TCC79X)
+	if (uiType & INPUT_IMG)
+	{
+		BITCSET(HwIIS, 0xFFFFFFFF, ((uiHsize << 16) | uiVsize));
+		BITCSET(HwIIW1, 0xFFFFFFFF, ((uiHorWindowingStart<< 16) | uiHorWindowingEnd));
+		BITCSET(HwIIW2, 0xFFFFFFFF, ((uiVerWindowingStart<< 16) | uiVerWindowingEnd));
+	}
+
+	if(uiType & OVERLAY_IMG)
+	{
+		BITCSET(HwOIS, 0xFFFFFFFF, ((uiHsize << 16) | uiVsize));
+		BITCSET(HwOIW1, 0xFFFFFFFF, ((uiHorWindowingStart<< 16) | uiHorWindowingEnd));
+		BITCSET(HwOIW2, 0xFFFFFFFF, ((uiVerWindowingStart<< 16) | uiVerWindowingEnd));
+	}
+#endif	
+}
+
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_setSensorOutImgSize
+//
+//	DESCRIPTION
+//    		set CIF register  : 	HwCEIS
+//
+//	Parameters
+//
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+void TDD_CIF_SetSensorOutImgSize(unsigned int uiHsize, unsigned int uiVsize)
+{
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	BITCSET(HwCEM->CEIS, HwCEIS_HSIZE, (uiHsize<<16));
+	BITCSET(HwCEM->CEIS, HwCEIS_VSIZE, (uiVsize));    // HwCEM->CEIS
+#else //(CONFIG_ARCH_TCC79X)
+	BITCSET(HwCEIS, HwCEIS_HSIZE, (uiHsize<<16));
+	BITCSET(HwCEIS, HwCEIS_VSIZE, (uiVsize));    // HwCEM->CEIS
+
+#endif
+}	
+
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_setBaseAddr
+//
+//	DESCRIPTION
+//    		set CIF register  : 	HwCDCR2, HwCDCR3, HwCDCR4
+//									HwCOBA
+//									HwCDCR5, 
+//									HwCDCR6, HwCDCR7, HwCDCR8
+//									HwCESA
+//	Parameters
+//
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+void TDD_CIF_SetBaseAddr (unsigned int uiType, unsigned int uiBaseAddr0, 
+                                                   unsigned int uiBaseAddr1, unsigned int uiBaseAddr2)
+{
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+
+	if (uiType & INPUT_IMG)
+	{
+		BITCSET(HwCIF->CDCR2, 0xFFFFFFFF, uiBaseAddr0);
+		BITCSET(HwCIF->CDCR3, 0xFFFFFFFF, uiBaseAddr1);
+		BITCSET(HwCIF->CDCR4, 0xFFFFFFFF, uiBaseAddr2);
+	}
+
+	if(uiType & OVERLAY_IMG)
+	{
+		BITCSET(HwCIF->COBA, 0xFFFFFFFF, uiBaseAddr0);
+	}
+
+	if (uiType & IN_IMG_ROLLING)
+	{
+		BITCSET(HwCIF->CDCR6, 0xFFFFFFFF, uiBaseAddr0);
+		BITCSET(HwCIF->CDCR7, 0xFFFFFFFF, uiBaseAddr1);
+		BITCSET(HwCIF->CDCR8, 0xFFFFFFFF, uiBaseAddr2);
+	}
+
+	if(uiType & IN_ENC_START_ADDR)
+	{
+		BITCSET(HwCIF->CESA, 0xFFFFFFFF, uiBaseAddr0);
+	}
+#else //(CONFIG_ARCH_TCC79X)
+
+	if (uiType & INPUT_IMG)
+	{
+		BITCSET(HwCDCR2, 0xFFFFFFFF, uiBaseAddr0);
+		BITCSET(HwCDCR3, 0xFFFFFFFF, uiBaseAddr1);
+		BITCSET(HwCDCR4, 0xFFFFFFFF, uiBaseAddr2);
+	}
+
+	if(uiType & OVERLAY_IMG)
+	{
+		BITCSET(HwCOBA, 0xFFFFFFFF, uiBaseAddr0);
+	}
+
+	if (uiType & IN_IMG_ROLLING)
+	{
+		BITCSET(HwCDCR5, 0xFFFFFFFF, uiBaseAddr0);
+		BITCSET(HwCDCR6, 0xFFFFFFFF, uiBaseAddr1);
+		BITCSET(HwCDCR7, 0xFFFFFFFF, uiBaseAddr2);
+	}
+
+	if(uiType & IN_ENC_START_ADDR)
+	{
+		BITCSET(HwCESA, 0xFFFFFFFF, uiBaseAddr0);
+	}
+#endif	
+}	
+
+
+void TDD_CIF_SetBaseAddr_offset(unsigned int uiType, unsigned int uiOFFSET_Y, unsigned int uiOFFSET_C)
+{
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	if (uiType & INPUT_IMG)
+	{
+		BITCSET(HwCIF->CDCR5, 0xFFFFFFFF, ((uiOFFSET_C << 16) | uiOFFSET_Y));
+	}
+
+	if(uiType & OVERLAY_IMG)
+	{
+		BITCSET(HwCIF->COBO, 0xFFFFFFFF, (uiOFFSET_Y));
+	}
+#endif
+}
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_setInterrupt
+//
+//	DESCRIPTION
+//    		set CIF register  : 	HwIEN, HwSEL, HwCIRQ
+//							HwIEN, HwIRQSEL, HwCIRQ
+//							HwCESA
+//
+//	Parameters
+//
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+void TDD_CIF_SetInterrupt(unsigned int uiFlag)
+{
+	// Interrupt Enable  0:interrupt disable, 1:interrupt enable    //Hw31
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	if(uiFlag & SET_CIF_INT_ENABLE)
+	{
+		BITSET(HwPIC->IEN0, HwINT0_CAM);    
+		BITSET(HwPIC->SEL0, HwINT0_CAM);
+		BITSET(HwCIF->CIRQ, HwCIRQ_IEN);    // Camera Interrupt enable
+	}  
+	if(uiFlag & SET_CIF_INT_DISABLE)
+	{
+		BITCLR(HwPIC->IEN0, HwINT0_CAM);    
+		BITCLR(HwPIC->SEL0, HwINT0_CAM);
+		BITCLR(HwCIF->CIRQ, HwCIRQ_IEN);    // Camera Interrupt enable
+	}  
+#else //(CONFIG_ARCH_TCC79X)
+	if(uiFlag & SET_CIF_INT_ENABLE)
+	{
+		BITSET(HwIEN, HwINT_CAM);    
+		BITSET(HwSEL, HwINT_CAM);
+		BITSET(HwCIRQ, HwCIRQ_IEN_EN);    // Camera Interrupt enable
+	}  
+	if(uiFlag & SET_CIF_INT_DISABLE)
+	{
+		BITCLR(HwIEN, HwINT_CAM);    
+		BITCLR(HwSEL, HwINT_CAM);
+		BITCLR(HwCIRQ, HwCIRQ_IEN_EN);    // Camera Interrupt enable
+	}  
+#endif
+	
+
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	// Update Register in VSYNC   0:Register is update without VSYNC , 1:When VSYNC is posedge, register is updated.  //Hw30
+	if(uiFlag & SET_CIF_UPDATE_IN_VSYNC)
+	{
+		BITSET(HwCIF->CIRQ, HwCIRQ_URV);
+	}	
+
+	if(uiFlag & SET_CIF_UPDATE_WITHOUT_VSYNC)
+	{
+		BITCLR(HwCIF->CIRQ, HwCIRQ_URV);
+	}
+		
+	// Interrupt Type  0:Pulse type, 1:Hold-up type when respond signal(ICR) is high  //Hw29
+	if(uiFlag & SET_CIF_INT_TYPE_HOLDUP)
+	{
+		BITSET(HwCIF->CIRQ, HwCIRQ_ITY);
+	}
+		
+	if(uiFlag & SET_CIF_INT_TYPE_PULSE)
+	{
+		BITCLR(HwCIF->CIRQ, HwCIRQ_ITY);
+	}
+		
+	// Interrupt Clear 0:.... , 1:Interrupt Clear (using ITY is Hold-up type)  //Hw28
+	if(uiFlag & SET_CIF_INT_HOLD_CLEAR)
+	{
+		BITSET(HwCIF->CIRQ, HwCIRQ_ICR);
+	}
+#else //(CONFIG_ARCH_TCC79X)
+	// Update Register in VSYNC   0:Register is update without VSYNC , 1:When VSYNC is posedge, register is updated.  //Hw30
+	if(uiFlag & SET_CIF_UPDATE_IN_VSYNC)
+	{
+		BITSET(HwCIRQ, HwCIRQ_URV);
+	}
+	
+	if(uiFlag & SET_CIF_UPDATE_WITHOUT_VSYNC)
+	{
+		BITCLR(HwCIRQ, HwCIRQ_URV);
+	}
+	
+	// Interrupt Type  0:Pulse type, 1:Hold-up type when respond signal(ICR) is high  //Hw29
+	if(uiFlag & SET_CIF_INT_TYPE_HOLDUP)
+	{
+		BITSET(HwCIRQ, HwCIRQ_ITY);
+	}
+	
+	if(uiFlag & SET_CIF_INT_TYPE_PULSE)
+	{
+		BITCLR(HwCIRQ, HwCIRQ_ITY);
+	}
+	
+	// Interrupt Clear 0:.... , 1:Interrupt Clear (using ITY is Hold-up type)  //Hw28
+	if(uiFlag & SET_CIF_INT_HOLD_CLEAR)
+	{
+		BITSET(HwCIRQ, HwCIRQ_ICR);
+	}
+#endif
+}	
+
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_setMaskIntStatus
+//
+//	DESCRIPTION
+// 			CIF interrupt status masking
+//    		set CIF register  : 	HwCIRQ
+//
+//	Parameters
+//
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+void TDD_CIF_SetMaskIntStatus(unsigned int uiFlag)
+{
+
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	// Hw29 should be written "1"!!
+	BITSET(HwCIF->CIRQ, HwCIRQ_ITY);
+
+	// Hw26           // Mask interrupt of VS negative edge,  0:Don't mask, 1:Mask
+	if(uiFlag & SET_CIF_INT_VS_NEGA_MASK)
+	{
+		BITSET(HwCIF->CIRQ, HwCIRQ_MVN);
+	}
+	
+	if(uiFlag & SET_CIF_INT_VS_NEGA_NOT_MASK)
+	{
+		BITCLR(HwCIF->CIRQ, HwCIRQ_MVN);
+	}
+	
+	// Hw25           // Mask interrupt of VS negative edge,  0:Don't mask, 1:Mask
+	if(uiFlag & SET_CIF_INT_VS_POSI_MASK)
+	{
+		BITSET(HwCIF->CIRQ, HwCIRQ_MVP);
+	}
+	
+	if(uiFlag & SET_CIF_INT_VS_POSI_NOT_MASK)
+	{
+		BITCLR(HwCIF->CIRQ, HwCIRQ_MVP);
+	}
+	
+	//        Hw24           // Mask interrupt of VCNT Interrupt,  0:Don't mask, 1:Mask
+	if(uiFlag & SET_CIF_INT_VCNT_MASK)
+	{
+		BITSET(HwCIF->CIRQ, HwCIRQ_MVIT);
+	}
+	
+	if(uiFlag & SET_CIF_INT_VCNT_NOT_MASK)
+	{
+		BITCLR(HwCIF->CIRQ, HwCIRQ_MVIT);
+	}
+	
+	//          Hw23           // Mask interrupt of Scaler Error,  0:Don't mask, 1:Mask
+	if(uiFlag & SET_CIF_INT_SCALER_ERR_MASK)
+	{
+		BITSET(HwCIF->CIRQ, HwCIRQ_MSE);
+	}
+	
+	if(uiFlag & SET_CIF_INT_SCALER_ERR_NOT_MASK)
+	{
+		BITCLR(HwCIF->CIRQ, HwCIRQ_MSE);
+	}
+	
+	//          Hw22           // Mask interrupt of Scaler finish,  0:Don't mask, 1:Mask
+	if(uiFlag & SET_CIF_INT_SCALER_FINISH_MASK)
+	{
+		BITSET(HwCIF->CIRQ, HwCIRQ_MSF);
+	}
+	
+	if(uiFlag & SET_CIF_INT_SCALER_FINISH_NOT_MASK)
+	{
+		BITCLR(HwCIF->CIRQ, HwCIRQ_MSF);
+	}
+	
+	//          Hw21           // Mask interrupt of Encoding start,  0:Don't mask, 1:Mask
+	if(uiFlag & SET_CIF_INT_ENC_STRT_MASK)
+	{
+		BITSET(HwCIF->CIRQ, HwCIRQ_MENS);
+	}
+	
+	if(uiFlag & SET_CIF_INT_ENC_STRT_NOT_MASK)
+	{
+		BITCLR(HwCIF->CIRQ, HwCIRQ_MENS);
+	}
+	
+	//          Hw20           // Mask interrupt of Rolling V address,  0:Don't mask, 1:Mask
+	if(uiFlag & SET_CIF_INT_ROLL_VADDR_MASK)
+	{
+		BITSET(HwCIF->CIRQ, HwCIRQ_MRLV);
+	}
+	
+	if(uiFlag & SET_CIF_INT_ROLL_VADDR_NOT_MASK)
+	{
+		BITCLR(HwCIF->CIRQ, HwCIRQ_MRLV);
+	}
+	
+	//          Hw19           // Mask interrupt of Rolling U address,  0:Don't mask, 1:Mask
+	if(uiFlag & SET_CIF_INT_ROLL_UADDR_MASK)
+	{
+		BITSET(HwCIF->CIRQ, HwCIRQ_MRLU);
+	}
+	
+	if(uiFlag & SET_CIF_INT_ROLL_UADDR_NOT_MASK)
+	{
+		BITCLR(HwCIF->CIRQ, HwCIRQ_MRLU);
+	}
+	
+	//          Hw18           // Mask interrupt of Rolling Y address,  0:Don't mask, 1:Mask
+	if(uiFlag & SET_CIF_INT_ROLL_YADDR_MASK)
+	{
+		BITSET(HwCIF->CIRQ, HwCIRQ_MRLY);
+	}
+	
+	if(uiFlag & SET_CIF_INT_ROLL_YADDR_NOT_MASK)
+	{
+		BITCLR(HwCIF->CIRQ, HwCIRQ_MRLY);
+	}
+	
+	//          Hw17           // Mask interrupt of Capture frame,  0:Don't mask, 1:Mask
+	if(uiFlag & SET_CIF_INT_CAPTURE_FRM_MASK)
+	{
+		BITSET(HwCIF->CIRQ, HwCIRQ_MSCF);
+	}
+	
+	if(uiFlag & SET_CIF_INT_CAPTURE_FRM_NOT_MASK)
+	{
+		BITCLR(HwCIF->CIRQ, HwCIRQ_MSCF);
+	}
+	
+	//          Hw16           // Mask interrupt of Stored one frame,  0:Don't mask, 1:Mask
+	if(uiFlag & SET_CIF_INT_STORE_1FRM_MASK)
+	{
+		BITSET(HwCIF->CIRQ, HwCIRQ_MSOF);
+	}
+	
+	if(uiFlag & SET_CIF_INT_STORE_1FRM_NOT_MASK)
+	{
+		BITCLR(HwCIF->CIRQ, HwCIRQ_MSOF);
+	}
+
+	if(uiFlag & SET_CIF_INT_ALL_MASK)
+	{
+		//BITCSET(HwCIRQ, 0x07FF0000, 0x7FF<<16);
+		BITSET(HwCIF->CIRQ, 0x7FF<<16);
+	}
+
+	if(uiFlag & SET_CIF_INT_ALL_CLEAR_MASK)
+	{
+		BITCLR(HwCIF->CIRQ, 0x5FF<<16);// Hw29 should be written "1"!!
+	} // HwCIF->CIRQ
+#else //(CONFIG_ARCH_TCC79X)
+	// Hw26           // Mask interrupt of VS negative edge,  0:Don't mask, 1:Mask
+	if(uiFlag & SET_CIF_INT_VS_NEGA_MASK)
+	{
+		BITSET(HwCIRQ, HwCIRQ_MVN);
+	}
+	
+	if(uiFlag & SET_CIF_INT_VS_NEGA_NOT_MASK)
+	{
+		BITCLR(HwCIRQ, HwCIRQ_MVN);
+	}
+	
+	// Hw25           // Mask interrupt of VS negative edge,  0:Don't mask, 1:Mask
+	if(uiFlag & SET_CIF_INT_VS_POSI_MASK)
+	{
+		BITSET(HwCIRQ, HwCIRQ_MVP);
+	}
+	
+	if(uiFlag & SET_CIF_INT_VS_POSI_NOT_MASK)
+	{
+		BITCLR(HwCIRQ, HwCIRQ_MVP);
+	}
+	
+	//        Hw24           // Mask interrupt of VCNT Interrupt,  0:Don't mask, 1:Mask
+	if(uiFlag & SET_CIF_INT_VCNT_MASK)
+	{
+		BITSET(HwCIRQ, HwCIRQ_MVIT);
+	}
+	
+	if(uiFlag & SET_CIF_INT_VCNT_NOT_MASK)
+	{
+		BITCLR(HwCIRQ, HwCIRQ_MVIT);
+	}
+	
+	//          Hw23           // Mask interrupt of Scaler Error,  0:Don't mask, 1:Mask
+	if(uiFlag & SET_CIF_INT_SCALER_ERR_MASK)
+	{
+		BITSET(HwCIRQ, HwCIRQ_MSE);
+	}
+	
+	if(uiFlag & SET_CIF_INT_SCALER_ERR_NOT_MASK)
+	{
+		BITCLR(HwCIRQ, HwCIRQ_MSE);
+	}
+	
+	//          Hw22           // Mask interrupt of Scaler finish,  0:Don't mask, 1:Mask
+	if(uiFlag & SET_CIF_INT_SCALER_FINISH_MASK)
+	{
+		BITSET(HwCIRQ, HwCIRQ_MSF);
+	}
+	
+	if(uiFlag & SET_CIF_INT_SCALER_FINISH_NOT_MASK)
+	{
+		BITCLR(HwCIRQ, HwCIRQ_MSF);
+	}
+	
+	//          Hw21           // Mask interrupt of Encoding start,  0:Don't mask, 1:Mask
+	if(uiFlag & SET_CIF_INT_ENC_STRT_MASK)
+	{
+		BITSET(HwCIRQ, HwCIRQ_MENS);
+	}
+	
+	if(uiFlag & SET_CIF_INT_ENC_STRT_NOT_MASK)
+	{
+		BITCLR(HwCIRQ, HwCIRQ_MENS);
+	}
+	
+	//          Hw20           // Mask interrupt of Rolling V address,  0:Don't mask, 1:Mask
+	if(uiFlag & SET_CIF_INT_ROLL_VADDR_MASK)
+	{
+		BITSET(HwCIRQ, HwCIRQ_MRLV);
+	}
+	
+	if(uiFlag & SET_CIF_INT_ROLL_VADDR_NOT_MASK)
+	{
+		BITCLR(HwCIRQ, HwCIRQ_MRLV);
+	}
+	
+	//          Hw19           // Mask interrupt of Rolling U address,  0:Don't mask, 1:Mask
+	if(uiFlag & SET_CIF_INT_ROLL_UADDR_MASK)
+	{
+		BITSET(HwCIRQ, HwCIRQ_MRLU);
+	}
+	
+	if(uiFlag & SET_CIF_INT_ROLL_UADDR_NOT_MASK)
+	{
+		BITCLR(HwCIRQ, HwCIRQ_MRLU);
+	}
+	
+	//          Hw18           // Mask interrupt of Rolling Y address,  0:Don't mask, 1:Mask
+	if(uiFlag & SET_CIF_INT_ROLL_YADDR_MASK)
+	{
+		BITSET(HwCIRQ, HwCIRQ_MRLY);
+	}
+	
+	if(uiFlag & SET_CIF_INT_ROLL_YADDR_NOT_MASK)
+	{
+		BITCLR(HwCIRQ, HwCIRQ_MRLY);
+	}
+	
+	//          Hw17           // Mask interrupt of Capture frame,  0:Don't mask, 1:Mask
+	if(uiFlag & SET_CIF_INT_CAPTURE_FRM_MASK)
+	{
+		BITSET(HwCIRQ, HwCIRQ_MSCF);
+	}
+	
+	if(uiFlag & SET_CIF_INT_CAPTURE_FRM_NOT_MASK)
+	{
+		BITCLR(HwCIRQ, HwCIRQ_MSCF);
+	}
+	
+	//          Hw16           // Mask interrupt of Stored one frame,  0:Don't mask, 1:Mask
+	if(uiFlag & SET_CIF_INT_STORE_1FRM_MASK)
+	{
+		BITSET(HwCIRQ, HwCIRQ_MSOF);
+	}
+	
+	if(uiFlag & SET_CIF_INT_STORE_1FRM_NOT_MASK)
+	{
+		BITCLR(HwCIRQ, HwCIRQ_MSOF);
+	}
+
+	if(uiFlag & SET_CIF_INT_ALL_MASK)
+	{
+		//BITCSET(HwCIRQ, 0x07FF0000, 0x7FF<<16);
+		BITSET(HwCIRQ, 0x7FF<<16);
+	}
+	
+	if(uiFlag & SET_CIF_INT_ALL_CLEAR_MASK)
+	{
+		BITCLR(HwCIRQ, 0x7FF<<16);
+	} // HwCIF->CIRQ
+
+#endif
+}
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_getIntStatus
+//
+//	DESCRIPTION
+//			get CIF status
+//    		get CIF register  : 	HwCIRQ
+//
+//	Parameters
+//
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+unsigned int TDD_CIF_GetIntStatus(unsigned int uiFlag)
+{
+    unsigned long uiRegStatus = 0;
+
+#if defined(CONFIG_ARCH_TCC79X)
+	//     status setting change status value  READ(GET)
+	if(uiFlag & GET_CIF_INT_VS_STATUS)
+	{
+		uiRegStatus = HwCIRQ & HwCIRQ_VSS;
+	}
+	
+	//#define  HwCIRQ_VN                                       Hw10            // VS positive, 0:-, 1:When VS is generated if Negative edge
+	if(uiFlag & GET_CIF_INT_NEGA_VS_GEN)
+	{
+		uiRegStatus = HwCIRQ & HwCIRQ_VN;  
+		//BITSET(HwCIRQ, HwCIRQ_VN);
+	}
+	
+	//#define  HwCIRQ_VP                                       Hw9            // VS positive, 0:-, 1:When VS is generated if positive edge
+	if(uiFlag & GET_CIF_INT_POSI_VS_GEN)
+	{
+		uiRegStatus = HwCIRQ & HwCIRQ_VP;  
+		//BITSET(HwCIRQ, HwCIRQ_VP);
+	}
+	
+	//#define  HwCIRQ_VIT                                      Hw8            // VCNT Interrupt, 0:-, 1:When VCNT is generated....
+	if(uiFlag & GET_CIF_INT_VCNT_GEN)
+	{
+		uiRegStatus = HwCIRQ & HwCIRQ_VIT;  
+		//BITSET(HwCIRQ, HwCIRQ_VIT);
+	}
+	
+	//#define  HwCIRQ_SE                                       Hw7            // Scaler Error, 0:-, 1:When Scale operation is not correct.
+	if(uiFlag & GET_CIF_INT_SCALER_ERR)
+	{
+		uiRegStatus = HwCIRQ & HwCIRQ_SE;  
+		//BITSET(HwCIRQ, HwCIRQ_SE);
+	}
+	
+	//#define  HwCIRQ_SF                                       Hw6            // Scaler Finish, 0:-, 1:When Scale operation is finished
+	if(uiFlag & GET_CIF_INT_SCALER_FINISH)
+	{
+		uiRegStatus = HwCIRQ & HwCIRQ_SF;  
+		//BITSET(HwCIRQ, HwCIRQ_SF);
+	}
+	
+	//#define  HwCIRQ_ENS                                      Hw5            // Encoding start status, 0:-, 1:When Y address is bigger than encoding start address, this bit is high
+	if(uiFlag & GET_CIF_INT_ENC_STRT)
+	{
+		uiRegStatus = HwCIRQ & HwCIRQ_ENS;  
+		//BITSET(HwCIRQ, HwCIRQ_ENS);
+	}
+	
+	//#define  HwCIRQ_ROLV                                     Hw4            // Rolling V address status, 0:-, 1:If V address is move to start address, this bit is high
+	if(uiFlag & GET_CIF_INT_ROLL_VADDR_STRT)
+	{
+		uiRegStatus = HwCIRQ & HwCIRQ_ROLV;
+		//BITSET(HwCIRQ, HwCIRQ_ROLV);
+	}
+	
+	//#define  HwCIRQ_ROLU                                     Hw3            // Rolling U address starus, 0:-, 1:If U address is move to start address, this bit is high 
+	if(uiFlag & GET_CIF_INT_ROLL_UADDR_STRT)
+	{
+		uiRegStatus = HwCIRQ & HwCIRQ_ROLU;  
+		//    BITSET(HwCIRQ, HwCIRQ_ROLU);
+	}
+	
+	//#define  HwCIRQ_ROLY                                     Hw2            // Rolling Y address starus, 0:-, 1:If Y address is move to start address, this bit is high 
+	if(uiFlag & GET_CIF_INT_ROLL_YADDR_STRT)
+	{
+		uiRegStatus = HwCIRQ & HwCIRQ_ROLY;  
+		//BITSET(HwCIRQ, HwCIRQ_ROLY);
+	}
+	
+	//#define  HwCIRQ_SCF                                      Hw1            // Stored captured frame,  0:-, 1:If Captured frame is stored, this bit is high
+	if(uiFlag & GET_CIF_INT_CAPTURE_FRM_STORE)
+	{
+		uiRegStatus = HwCIRQ & HwCIRQ_SCF;  
+		//BITSET(HwCIRQ, HwCIRQ_SCF);
+	}
+	
+	//#define  HwCIRQ_SOF                                      Hw0            // Stored One frame, 0-, 1:If one frame if stored, this bit is high.
+	if(uiFlag & GET_CIF_INT_ONEFRAME_STORE)
+	{
+		uiRegStatus = HwCIRQ & HwCIRQ_SOF;  // HwCIF->CIRQ
+		//BITSET(HwCIRQ, HwCIRQ_SOF);
+	}
+#else //(CONFIG_ARCH_TCC92X)	 || defined(CONFIG_ARCH_TCC8900)
+	//     status setting change status value  READ(GET)
+	if(uiFlag & GET_CIF_INT_VS_STATUS)
+	{
+		uiRegStatus = HwCIF->CIRQ & HwCIRQ_VSS;
+	}
+	
+	//#define  HwCIRQ_VN                                       Hw10            // VS positive, 0:-, 1:When VS is generated if Negative edge
+	if(uiFlag & GET_CIF_INT_NEGA_VS_GEN)
+	{
+		uiRegStatus = HwCIF->CIRQ & HwCIRQ_VN;  
+		//BITSET(HwCIRQ, HwCIRQ_VN);
+	}
+	
+	//#define  HwCIRQ_VP                                       Hw9            // VS positive, 0:-, 1:When VS is generated if positive edge
+	if(uiFlag & GET_CIF_INT_POSI_VS_GEN)
+	{
+		uiRegStatus = HwCIF->CIRQ & HwCIRQ_VP;  
+		//BITSET(HwCIRQ, HwCIRQ_VP);
+	}
+	
+	//#define  HwCIRQ_VIT                                      Hw8            // VCNT Interrupt, 0:-, 1:When VCNT is generated....
+	if(uiFlag & GET_CIF_INT_VCNT_GEN)
+	{
+		uiRegStatus = HwCIF->CIRQ & HwCIRQ_VIT;  
+		//BITSET(HwCIRQ, HwCIRQ_VIT);
+	}
+	
+	//#define  HwCIRQ_SE                                       Hw7            // Scaler Error, 0:-, 1:When Scale operation is not correct.
+	if(uiFlag & GET_CIF_INT_SCALER_ERR)
+	{
+		uiRegStatus = HwCIF->CIRQ & HwCIRQ_SE;  
+		//BITSET(HwCIRQ, HwCIRQ_SE);
+	}
+	
+	//#define  HwCIRQ_SF                                       Hw6            // Scaler Finish, 0:-, 1:When Scale operation is finished
+	if(uiFlag & GET_CIF_INT_SCALER_FINISH)
+	{
+		uiRegStatus = HwCIF->CIRQ & HwCIRQ_SF;  
+		//BITSET(HwCIRQ, HwCIRQ_SF);
+	}
+	
+	//#define  HwCIRQ_ENS                                      Hw5            // Encoding start status, 0:-, 1:When Y address is bigger than encoding start address, this bit is high
+	if(uiFlag & GET_CIF_INT_ENC_STRT)
+	{
+		uiRegStatus = HwCIF->CIRQ & HwCIRQ_ENS;  
+		//BITSET(HwCIRQ, HwCIRQ_ENS);
+	}
+	
+	//#define  HwCIRQ_ROLV                                     Hw4            // Rolling V address status, 0:-, 1:If V address is move to start address, this bit is high
+	if(uiFlag & GET_CIF_INT_ROLL_VADDR_STRT)
+	{
+		uiRegStatus = HwCIF->CIRQ & HwCIRQ_ROLV;
+		//BITSET(HwCIRQ, HwCIRQ_ROLV);
+	}
+	
+	//#define  HwCIRQ_ROLU                                     Hw3            // Rolling U address starus, 0:-, 1:If U address is move to start address, this bit is high 
+	if(uiFlag & GET_CIF_INT_ROLL_UADDR_STRT)
+	{
+		uiRegStatus = HwCIF->CIRQ & HwCIRQ_ROLU;  
+		//    BITSET(HwCIRQ, HwCIRQ_ROLU);
+	}
+	
+	//#define  HwCIRQ_ROLY                                     Hw2            // Rolling Y address starus, 0:-, 1:If Y address is move to start address, this bit is high 
+	if(uiFlag & GET_CIF_INT_ROLL_YADDR_STRT)
+	{
+		uiRegStatus = HwCIF->CIRQ & HwCIRQ_ROLY;  
+		//BITSET(HwCIRQ, HwCIRQ_ROLY);
+	}
+	
+	//#define  HwCIRQ_SCF                                      Hw1            // Stored captured frame,  0:-, 1:If Captured frame is stored, this bit is high
+	if(uiFlag & GET_CIF_INT_CAPTURE_FRM_STORE)
+	{
+		uiRegStatus = HwCIF->CIRQ & HwCIRQ_SCF;  
+		//BITSET(HwCIRQ, HwCIRQ_SCF);
+	}
+	
+	//#define  HwCIRQ_SOF                                      Hw0            // Stored One frame, 0-, 1:If one frame if stored, this bit is high.
+	if(uiFlag & GET_CIF_INT_ONEFRAME_STORE)
+	{
+		uiRegStatus = HwCIF->CIRQ & HwCIRQ_SOF;  // PCIF->CIRQ
+		//BITSET(HwCIRQ, HwCIRQ_SOF);
+	}
+#endif
+	
+    return (unsigned int)uiRegStatus;
+}
+
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_set656FormatConfig
+//
+//	DESCRIPTION
+//    		set CIF register  : 	Hw656FCR1, Hw656FCR2
+//
+//	Parameters
+//
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+void TDD_CIF_Set656FormatConfig(unsigned int uiType, unsigned int uiPsl, unsigned int uiFpv,
+										unsigned int uiSpv, unsigned int uiTpv, unsigned int uiHb, unsigned int uiVb)
+{
+#if defined(CONFIG_ARCH_TCC79X)
+	if(uiType & SET_CIF_656_PSL)
+	{
+		BITCSET(Hw656FCR1, 0x06000000, (uiPsl << 25));
+	}
+	
+	if(uiType & SET_CIF_656_FPV)
+	{
+		BITCSET(Hw656FCR1, 0x00FF0000, (uiFpv << 16));
+	}
+	
+	if(uiType & SET_CIF_656_SPV)
+	{
+		BITCSET(Hw656FCR1, 0x0000FF00, (uiSpv << 8));
+	}
+	
+	if(uiType & SET_CIF_656_TPV)
+	{
+		BITCSET(Hw656FCR1, 0x000000FF, uiTpv);
+	}
+	
+	if(uiType & SET_CIF_656_H_BLANK)
+	{
+		BITCSET(Hw656FCR2, 0x000001E0, (uiHb << 5));
+	}
+	
+	if(uiType & SET_CIF_656_V_BLANK)
+	{
+			BITCSET(Hw656FCR2, 0x0000000F, uiVb); // HwCIF->CCIR656FCR2
+	}
+#else //(CONFIG_ARCH_TCC92X)	 || defined(CONFIG_ARCH_TCC8900)
+	if(uiType & SET_CIF_656_PSL)
+	{
+		BITCSET(HwCIF->CCIR656FCR1, 0x06000000, (uiPsl << 25));
+	}
+		
+	if(uiType & SET_CIF_656_FPV)
+	{
+		BITCSET(HwCIF->CCIR656FCR1, 0x00FF0000, (uiFpv << 16));
+	}
+		
+	if(uiType & SET_CIF_656_SPV)
+	{
+		BITCSET(HwCIF->CCIR656FCR1, 0x0000FF00, (uiSpv << 8));
+	}
+		
+	if(uiType & SET_CIF_656_TPV)
+	{
+		BITCSET(HwCIF->CCIR656FCR1, 0x000000FF, uiTpv);
+	}
+		
+	if(uiType & SET_CIF_656_H_BLANK)
+	{
+		BITCSET(HwCIF->CCIR656FCR2, 0x000001E0, (uiHb << 5));
+	}
+
+	if(uiType & SET_CIF_656_V_BLANK)
+	{
+		BITCSET(HwCIF->CCIR656FCR2, 0x0000000F, uiVb); // PCIF->CCIR656FCR2
+	}
+#endif
+}
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_setFIFOStatusClear
+//
+//	DESCRIPTION
+//			clear FIFO Status
+//    		set CIF register  : 	HwFIFOSTATE
+//
+//	Parameters
+//
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+void TDD_CIF_SetFIFOStatusClear(void)
+{
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	BITSET(HwCIF->FIFOSTATE, HwFIFOSTATE_CLR); // HwCIF->FIFOSTATE
+#else //(CONFIG_ARCH_TCC92X)
+	BITSET(HwFIFOSTATE, HwFIFOSTATE_CLR); // HwCIF->FIFOSTATE
+#endif
+}
+
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_setFIFOStatusClear
+//
+//	DESCRIPTION
+//    		get CIF register  : 	HwFIFOSTATE
+//
+//	Parameters
+//
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+unsigned int TDD_CIF_GetFIFOStatus(unsigned int uiType)
+{
+    unsigned long uiRet = 0;
+
+#if defined(CONFIG_ARCH_TCC79X)
+	if(uiType & GET_CIF_OVERLAY_READ_ERR)
+	{
+		uiRet |= (HwFIFOSTATE & HwFIFOSTATE_REO);
+	}
+	
+	if(uiType & GET_CIF_VCH_READ_ERR)
+	{
+		uiRet |= (HwFIFOSTATE & HwFIFOSTATE_REV);
+	}
+	
+	if(uiType & GET_CIF_UCH_READ_ERR)
+	{
+		uiRet |= (HwFIFOSTATE & HwFIFOSTATE_REU);
+	}
+	
+	if(uiType & GET_CIF_YCH_READ_ERR)
+	{
+		uiRet |= (HwFIFOSTATE & HwFIFOSTATE_REY);
+	}
+	
+	if(uiType & GET_CIF_OVERLAY_WRITE_ERR)
+	{
+		uiRet |= (HwFIFOSTATE & HwFIFOSTATE_WEO);
+	}
+	
+	if(uiType & GET_CIF_VCH_WRITE_ERR)
+	{
+		uiRet |= (HwFIFOSTATE & HwFIFOSTATE_WEV);
+	}
+	
+	if(uiType & GET_CIF_UCH_WRITE_ERR)
+	{
+		uiRet |= (HwFIFOSTATE & HwFIFOSTATE_WEU);
+	}
+	
+	if(uiType & GET_CIF_YCH_WRITE_ERR)
+	{
+		uiRet |= (HwFIFOSTATE & HwFIFOSTATE_WEY);
+	}
+	
+	if(uiType & GET_CIF_OVERLAY_EMPTY_ERR)
+	{
+		uiRet |= (HwFIFOSTATE & HwFIFOSTATE_EO);
+	}
+	
+	if(uiType & GET_CIF_VCH_EMPTY_ERR)
+	{
+		uiRet |= (HwFIFOSTATE & HwFIFOSTATE_EV);
+	}
+	
+	if(uiType & GET_CIF_UCH_EMPTY_ERR)
+	{
+		uiRet |= (HwFIFOSTATE & HwFIFOSTATE_EU);
+	}
+	
+	if(uiType & GET_CIF_YCH_EMPTY_ERR)
+	{
+		uiRet |= (HwFIFOSTATE & HwFIFOSTATE_EY);
+	}
+	
+	if(uiType & GET_CIF_OVERLAY_FULL_ERR)
+	{
+		uiRet |= (HwFIFOSTATE & HwFIFOSTATE_FO);
+	}
+	
+	if(uiType & GET_CIF_VCH_FULL_ERR)
+	{
+		uiRet |= (HwFIFOSTATE & HwFIFOSTATE_FV);
+	}
+	
+	if(uiType & GET_CIF_UCH_FULL_ERR)
+	{
+		uiRet |= (HwFIFOSTATE & HwFIFOSTATE_FU);
+	}
+	
+	if(uiType & GET_CIF_YCH_FULL_ERR)
+	{
+			uiRet |= (HwFIFOSTATE & HwFIFOSTATE_FY); // HwCIF->FIFOSTATE
+	}
+#else //(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	if(uiType & GET_CIF_OVERLAY_READ_ERR)
+	{
+		uiRet |= (HwCIF->FIFOSTATE & HwFIFOSTATE_REO);
+	}
+	
+	if(uiType & GET_CIF_VCH_READ_ERR)
+	{
+		uiRet |= (HwCIF->FIFOSTATE & HwFIFOSTATE_REV);
+	}
+	
+	if(uiType & GET_CIF_UCH_READ_ERR)
+	{
+		uiRet |= (HwCIF->FIFOSTATE & HwFIFOSTATE_REU);
+	}
+	
+	if(uiType & GET_CIF_YCH_READ_ERR)
+	{
+		uiRet |= (HwCIF->FIFOSTATE & HwFIFOSTATE_REY);
+	}
+	
+	if(uiType & GET_CIF_OVERLAY_WRITE_ERR)
+	{
+		uiRet |= (HwCIF->FIFOSTATE & HwFIFOSTATE_WEO);
+	}
+	
+	if(uiType & GET_CIF_VCH_WRITE_ERR)
+	{
+		uiRet |= (HwCIF->FIFOSTATE & HwFIFOSTATE_WEV);
+	}
+	
+	if(uiType & GET_CIF_UCH_WRITE_ERR)
+	{
+		uiRet |= (HwCIF->FIFOSTATE & HwFIFOSTATE_WEU);
+	}
+	
+	if(uiType & GET_CIF_YCH_WRITE_ERR)
+	{
+		uiRet |= (HwCIF->FIFOSTATE & HwFIFOSTATE_WEY);
+	}
+	
+	if(uiType & GET_CIF_OVERLAY_EMPTY_ERR)
+	{
+		uiRet |= (HwCIF->FIFOSTATE & HwFIFOSTATE_EO);
+	}
+	
+	if(uiType & GET_CIF_VCH_EMPTY_ERR)
+	{
+		uiRet |= (HwCIF->FIFOSTATE & HwFIFOSTATE_EV);
+	}
+	
+	if(uiType & GET_CIF_UCH_EMPTY_ERR)
+	{
+		uiRet |= (HwCIF->FIFOSTATE & HwFIFOSTATE_EU);
+	}
+	
+	if(uiType & GET_CIF_YCH_EMPTY_ERR)
+	{
+		uiRet |= (HwCIF->FIFOSTATE & HwFIFOSTATE_EY);
+	}
+	
+	if(uiType & GET_CIF_OVERLAY_FULL_ERR)
+	{
+		uiRet |= (HwCIF->FIFOSTATE & HwFIFOSTATE_FO);
+	}
+	
+	if(uiType & GET_CIF_VCH_FULL_ERR)
+	{
+		uiRet |= (HwCIF->FIFOSTATE & HwFIFOSTATE_FV);
+	}
+	
+	if(uiType & GET_CIF_UCH_FULL_ERR)
+	{
+		uiRet |= (HwCIF->FIFOSTATE & HwFIFOSTATE_FU);
+	}
+	
+	if(uiType & GET_CIF_YCH_FULL_ERR)
+	{
+		uiRet |= (HwCIF->FIFOSTATE & HwFIFOSTATE_FY); // PCIF->FIFOSTATE
+	}
+#endif
+    return (unsigned int)uiRet;
+}
+
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_setCaptureCtrl
+//
+//	DESCRIPTION
+//			CIF Capture Control
+//    		set CIF register  : 	HwCCM1, HwCCM2
+//
+//	Parameters
+//
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+void TDD_CIF_SetCaptureCtrl(unsigned int uiType,  unsigned int uiSkipNum, unsigned int uiVCnt, unsigned int uiFlag)
+{
+#if defined(CONFIG_ARCH_TCC79X)
+	if(uiType & SET_CIF_SKIP_NUM)
+	{
+		BITCSET(HwCCM1, HwCCM1_SKIPNUM, (uiSkipNum << 4));
+	}
+	
+	if(uiType & SET_CIF_VCNT_NUM)
+	{
+		BITCSET(HwCCM2, HwCCM2_VCNT, (uiVCnt << 4));
+	}
+
+	if(uiFlag & SET_CIF_EIT_ENC_INT)
+	{
+		BITSET(HwCCM1, HwCCM1_EIT);
+	}
+	
+	if(uiFlag & SET_CIF_EIT_ALWAYS_1_PULSE)
+	{
+		BITCLR(HwCCM1, HwCCM1_EIT);
+	}
+	
+	if(uiFlag & SET_CIF_UES_ENABLE)
+	{
+		BITSET(HwCCM1, HwCCM1_UES);
+	}
+	
+	if(uiFlag & SET_CIF_UES_DISABLE)
+	{
+		BITCLR(HwCCM1, HwCCM1_UES);
+	}
+	
+	if(uiFlag & SET_CIF_RLV_ENABLE)
+	{
+		BITSET(HwCCM1, HwCCM1_RLV);
+	}
+	
+	if(uiFlag & SET_CIF_RLV_DISABLE)
+	{
+		BITCLR(HwCCM1, HwCCM1_RLV);
+	}
+	
+	if(uiFlag & SET_CIF_RLU_ENABLE)
+	{
+		BITSET(HwCCM1, HwCCM1_RLU);
+	}
+	
+	if(uiFlag & SET_CIF_RLU_DISABLE)
+	{
+		BITCLR(HwCCM1, HwCCM1_RLU);
+	}
+	
+	if(uiFlag & SET_CIF_RLY_ENABLE)
+	{
+		BITSET(HwCCM1, HwCCM1_RLY);
+	}
+	
+	if(uiFlag & SET_CIF_RLY_DISABLE)
+	{
+		BITCLR(HwCCM1, HwCCM1_RLY);
+	}
+	
+	if(uiFlag & SET_CIF_CAP_ENABLE)
+	{
+		BITSET(HwCCM1, HwCCM1_CAP);
+	}
+	
+	if(uiFlag & SET_CIF_CAP_DISABLE)
+	{
+		BITCLR(HwCCM1, HwCCM1_CAP);
+	}
+	
+	if(uiFlag & SET_CIF_VEN_ENABLE)
+	{
+		BITSET(HwCCM2, HwCCM2_VEN);
+	}
+	
+	if(uiFlag & SET_CIF_VEN_DISABLE)
+	{
+		BITCLR(HwCCM2, HwCCM2_VEN);
+	}
+#else //(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	if(uiType & SET_CIF_SKIP_NUM)
+	{
+		BITCSET(HwCIF->CCM1, HwCCM1_SKIPNUM, (uiSkipNum << 4));
+	}
+
+	if(uiType & SET_CIF_VCNT_NUM)
+	{
+		BITCSET(HwCIF->CCM2, HwCCM2_VCNT, (uiVCnt << 4));
+	}
+
+	if(uiFlag & SET_CIF_EIT_ENC_INT)
+	{
+		BITSET(HwCIF->CCM1, HwCCM1_EIT);
+	}
+	
+	if(uiFlag & SET_CIF_EIT_ALWAYS_1_PULSE)
+	{
+		BITCLR(HwCIF->CCM1, HwCCM1_EIT);
+	}
+	
+	if(uiFlag & SET_CIF_UES_ENABLE)
+	{
+		BITSET(HwCIF->CCM1, HwCCM1_UES);
+	}
+	
+	if(uiFlag & SET_CIF_UES_DISABLE)
+	{
+		BITCLR(HwCIF->CCM1, HwCCM1_UES);
+	}
+	
+	if(uiFlag & SET_CIF_RLV_ENABLE)
+	{
+		BITSET(HwCIF->CCM1, HwCCM1_RLV);
+	}
+	
+	if(uiFlag & SET_CIF_RLV_DISABLE)
+	{
+		BITCLR(HwCIF->CCM1, HwCCM1_RLV);
+	}
+	
+	if(uiFlag & SET_CIF_RLU_ENABLE)
+	{
+		BITSET(HwCIF->CCM1, HwCCM1_RLU);
+	}
+	
+	if(uiFlag & SET_CIF_RLU_DISABLE)
+	{
+		BITCLR(HwCIF->CCM1, HwCCM1_RLU);
+	}
+	
+	if(uiFlag & SET_CIF_RLY_ENABLE)
+	{
+		BITSET(HwCIF->CCM1, HwCCM1_RLY);
+	}
+	
+	if(uiFlag & SET_CIF_RLY_DISABLE)
+	{
+		BITCLR(HwCIF->CCM1, HwCCM1_RLY);
+	}
+	
+	if(uiFlag & SET_CIF_CAP_ENABLE)
+	{
+		BITSET(HwCIF->CCM1, HwCCM1_CAP);
+	}
+	
+	if(uiFlag & SET_CIF_CAP_DISABLE)
+	{
+		BITCLR(HwCIF->CCM1, HwCCM1_CAP); // PCIF->CCM1
+	}
+	
+	if(uiFlag & SET_CIF_VEN_ENABLE)
+	{
+		BITSET(HwCIF->CCM2, HwCCM2_VEN);
+	}
+	
+	if(uiFlag & SET_CIF_VEN_DISABLE)
+	{
+		BITCLR(HwCIF->CCM2, HwCCM2_VEN); // PCIF->CCM2
+	}
+#endif
+}
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_getCaptureStatus
+//
+//	DESCRIPTION
+//    		get CIF register  : 	HwCCM1
+//
+//	Parameters
+//
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+unsigned int TDD_CIF_GetCaptureStatus(unsigned int uiType)
+{
+  unsigned long uiCaptureStatus = 0;
+
+#if defined(CONFIG_ARCH_TCC79X)
+	//HwCCM1_ENCNUM                           0xF0000000              // Encode INT number (using CAP mode) [31:28], value area (0~15), Encode interrupt number
+	if(uiType & SET_CIF_CCM1_ENCNUM)
+	{
+		uiCaptureStatus = HwCCM1 & HwCCM1_ENCNUM;
+	}
+	
+	//HwCCM1_ROLNUMV                         0x0F000000               // Rolling number in V (using CAP mode) [27:24], value area (0~15), Rolling number
+	if(uiType & SET_CIF_CCM1_ROLNUMV)
+	{
+		uiCaptureStatus = HwCCM1 & HwCCM1_ROLNUMV;  
+	}
+	
+	//HwCCM1_ROLNUMU                         0x00F00000               // Rolling number in U (using CAP mode) [23:20], value area (0~15), Rolling number
+	if(uiType & SET_CIF_CCM1_ROLNUMU)
+	{
+		uiCaptureStatus = HwCCM1 & HwCCM1_ROLNUMU;  
+	}
+	
+	//HwCCM1_ROLNUMY                         0x000F0000               // Rolling number in Y (using CAP mode) [19:16], value area (0~15), Rolling number
+	if(uiType & SET_CIF_CCM1_ROLNUMY)
+	{
+		uiCaptureStatus = HwCCM1 & HwCCM1_ROLNUMY;  
+	}
+	
+	//HwCCM1_CB                                    Hw10          // Capture Busy,   0:-, 1:Capture busy
+	if(uiType & SET_CIF_CCM1_CB)
+	{
+		uiCaptureStatus = (HwCCM1 & HwCCM1_CB);  
+	} // HwCIF->CCM1
+#else //(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	//HwCCM1_ENCNUM                           0xF0000000              // Encode INT number (using CAP mode) [31:28], value area (0~15), Encode interrupt number
+	if(uiType & SET_CIF_CCM1_ENCNUM)
+	{
+		uiCaptureStatus = HwCIF->CCM1 & HwCCM1_ENCNUM;
+	}
+	
+	//HwCCM1_ROLNUMV                         0x0F000000               // Rolling number in V (using CAP mode) [27:24], value area (0~15), Rolling number
+	if(uiType & SET_CIF_CCM1_ROLNUMV)
+	{
+		uiCaptureStatus = HwCIF->CCM1 & HwCCM1_ROLNUMV;  
+	}
+	
+	//HwCCM1_ROLNUMU                         0x00F00000               // Rolling number in U (using CAP mode) [23:20], value area (0~15), Rolling number
+	if(uiType & SET_CIF_CCM1_ROLNUMU)
+	{
+		uiCaptureStatus = HwCIF->CCM1 & HwCCM1_ROLNUMU;  
+	}
+	
+	//HwCCM1_ROLNUMY                         0x000F0000               // Rolling number in Y (using CAP mode) [19:16], value area (0~15), Rolling number
+	if(uiType & SET_CIF_CCM1_ROLNUMY)
+	{
+		uiCaptureStatus = HwCIF->CCM1 & HwCCM1_ROLNUMY;  
+	}
+	
+	//HwCCM1_CB                                    Hw10          // Capture Busy,   0:-, 1:Capture busy
+	if(uiType & SET_CIF_CCM1_CB)
+	{
+		uiCaptureStatus = (HwCIF->CCM1 & HwCCM1_CB);  
+	} // HwCIF->CCM1
+#endif
+  return (unsigned int)uiCaptureStatus;	
+}
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_getCurAddr
+//
+//	DESCRIPTION
+//    		get CIF register  : 	HwCCYA, HwCCUA, HwCCVA
+//
+//	Parameters
+//
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+void TDD_CIF_GetCurAddr(volatile unsigned long *uiCurYAddr, volatile unsigned long *uiCurUAddr,
+								volatile unsigned long *uiCurVAddr)
+{
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	uiCurYAddr = (HwCIF->CCYA);
+	uiCurUAddr = (HwCIF->CCUA);
+	uiCurVAddr = (HwCIF->CCVA);	
+#else //(CONFIG_ARCH_TCC92X)
+	uiCurYAddr = (&HwCCYA);
+	uiCurUAddr = (&HwCCUA);
+	uiCurVAddr = (&HwCCVA);	
+#endif
+}
+
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_getCurLineCnt
+//
+//	DESCRIPTION
+//    		get CIF register  : 	HwCCLC
+//
+//	Parameters
+//
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+void TDD_CIF_GetCurLineCnt(volatile unsigned long *uiCurLineCount)
+{
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	uiCurLineCount = HwCIF->CCVA;
+#else //(CONFIG_ARCH_TCC92X)
+	uiCurLineCount = &HwCCLC;
+#endif
+}
+
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_setEffectMode
+//
+//	DESCRIPTION
+//			CIF effect setting
+//    		set CIF register  : 	HwCEM
+//
+//	Parameters
+//
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+void TDD_CIF_SetEffectMode(unsigned int uiFlag)
+{
+	unsigned int  uiValue = 1;
+	
+#if defined(CONFIG_ARCH_TCC79X)
+	BITCSET(HwCEM, 0xFFFFFFFF, 0x00000000);  //  0 	
+	
+	// HwCEM_UVS                                   Hw15   // UV Swap  0:u-v-u-v sequence, 1:v-u-v-u sequence
+	if(uiFlag & SET_CIF_CEM_UVS)
+	{
+		BITCSET(HwCEM, HwCEM_UVS, (uiValue<<15));   // (uiValue<<15)); only u-v-u-v sequence
+	}
+	
+	// HwCEM_VB                                    Hw14   // V Bias (V channel value offset),   0:disable, 1:Enable 
+	if(uiFlag & SET_CIF_CEM_VB)
+	{
+		BITCSET(HwCEM, HwCEM_VB, (uiValue<<14));
+	}
+	
+	// HwCEM_UB                                    Hw13   // U Bias (U channel value offset),   0:disable, 1:Enable
+	if(uiFlag & SET_CIF_CEM_UB)
+	{
+		BITCSET(HwCEM, HwCEM_UB, (uiValue<<13));
+	}
+	
+	// HwCEM_YB                                    Hw12   // Y Bias (Y channel value offset),   0:disable, 1:Enable
+	if(uiFlag & SET_CIF_CEM_YB)
+	{
+		BITCSET(HwCEM, HwCEM_YB, (uiValue<<12));
+	}
+	
+	// HwCEM_YCS                                   Hw11   // YC Swap  0:u-y-v-y sequence, 1:y-u-y-v sequence
+	if(uiFlag & SET_CIF_CEM_YCS)
+	{
+		BITCSET(HwCEM, HwCEM_YCS, (uiValue<<11));    // (uiValue<<11));  only y-u-y-v sequence  
+	}
+	
+	// HwCEM_IVY                                   Hw10   // Invert Y,   0:disable, 1:Enable 
+	if(uiFlag & SET_CIF_CEM_IVY)
+	{
+		BITCSET(HwCEM, HwCEM_IVY, (uiValue<<10));
+	}
+	
+	// HwCEM_STC                                   Hw9    // Strong C,   0:disable, 1:Enable 
+	if(uiFlag & SET_CIF_CEM_STC)
+	{
+		BITCSET(HwCEM, HwCEM_STC, (uiValue<<9));
+	}
+	
+	// HwCEM_YCL                                   Hw8    // Y Clamp (Y value clipping),   0:disable, 1:Enable 
+	if(uiFlag & SET_CIF_CEM_YCL)
+	{
+		BITCSET(HwCEM, HwCEM_YCL, (uiValue<<8));
+	}
+	
+	// HwCEM_CS                                    Hw7    // C Select (Color filter),   0:disable, 1:Enable(Color filter)  
+	if(uiFlag & SET_CIF_CEM_CS )
+	{
+		BITCSET(HwCEM, HwCEM_CS , (uiValue<<7));
+	}
+
+	// HwCEM_SKT                                   Hw6    // Sketch Enable,   0:disable, 1:Enable 
+	if(uiFlag & SET_CIF_CEM_SKT)
+	{
+		BITCSET(HwCEM, HwCEM_SKT, (uiValue<<6));
+	}
+	
+	// HwCEM_EMM                                   Hw5    // Emboss mode,   0:Positive emboss, 1:Negative emboss
+	if(uiFlag & SET_CIF_CEM_EMM)
+	{
+		BITCSET(HwCEM, HwCEM_EMM, (uiValue<<5));
+	}
+	
+	// HwCEM_EMB                                   Hw4    // Emboss,   0:disable, 1:Enable  
+	if(uiFlag & SET_CIF_CEM_EMB)
+	{
+		BITCSET(HwCEM, HwCEM_EMB, (uiValue<<4));
+	}
+	
+	// HwCEM_NEGA                                  Hw3    // Negative mode,   0:disable, 1:Enable
+	if(uiFlag & SET_CIF_CEM_NEGA)
+	{
+		BITCSET(HwCEM, HwCEM_NEGA, (uiValue<<3));
+	}
+	
+	// HwCEM_GRAY                                  Hw2    // Gray mode,   0:disable, 1:Enable 
+	if(uiFlag & SET_CIF_CEM_GRAY)
+	{
+		BITCSET(HwCEM, HwCEM_GRAY, (uiValue<<2));
+	}
+	
+	// HwCEM_SEPI                                  Hw1    // Sepia mode,   0:disable, 1:Enable    
+	if(uiFlag & SET_CIF_CEM_SEPI)
+	{
+		BITCSET(HwCEM, HwCEM_SEPI, (uiValue<<1));
+	}
+	
+	// HwCEM_NOR                                   Hw0    // Normal mode,   0:Effect mode, 1:Normal mode 
+	if(uiFlag & SET_CIF_CEM_NOR)
+	{
+		BITCSET(HwCEM, HwCEM_NOR, (uiValue));  //  0  normal  1
+	}
+	
+	//  ALL_CLEAR
+	if(uiFlag & SET_CIF_CEM_ALL_CLEAR)
+	{
+		BITCSET(HwCEM, 0xFFFFFFFF, 0x00000000);  //  0 
+	} // HwCEM->CEM
+#else //(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	BITCSET(HwCEM->CEM, 0xFFFFFFFF, 0x00000000);  //  0 	
+	
+	// HwCEM_UVS                                   Hw15   // UV Swap  0:u-v-u-v sequence, 1:v-u-v-u sequence
+	if(uiFlag & SET_CIF_CEM_UVS)
+	{
+		BITCSET(HwCEM->CEM, HwCEM_UVS, (uiValue<<15));   // (uiValue<<15)); only u-v-u-v sequence
+	}
+	
+	// HwCEM_VB                                    Hw14   // V Bias (V channel value offset),   0:disable, 1:Enable 
+	if(uiFlag & SET_CIF_CEM_VB)
+	{
+		BITCSET(HwCEM->CEM, HwCEM_VB, (uiValue<<14));
+	}
+	
+	// HwCEM_UB                                    Hw13   // U Bias (U channel value offset),   0:disable, 1:Enable
+	if(uiFlag & SET_CIF_CEM_UB)
+	{
+		BITCSET(HwCEM->CEM, HwCEM_UB, (uiValue<<13));
+	}
+	
+	// HwCEM_YB                                    Hw12   // Y Bias (Y channel value offset),   0:disable, 1:Enable
+	if(uiFlag & SET_CIF_CEM_YB)
+	{
+		BITCSET(HwCEM->CEM, HwCEM_YB, (uiValue<<12));
+	}
+	
+	// HwCEM_YCS                                   Hw11   // YC Swap  0:u-y-v-y sequence, 1:y-u-y-v sequence
+	if(uiFlag & SET_CIF_CEM_YCS)
+	{
+		BITCSET(HwCEM->CEM, HwCEM_YCS, (uiValue<<11));    // (uiValue<<11));  only y-u-y-v sequence  
+	}
+	
+	// HwCEM_IVY                                   Hw10   // Invert Y,   0:disable, 1:Enable 
+	if(uiFlag & SET_CIF_CEM_IVY)
+	{
+		BITCSET(HwCEM->CEM, HwCEM_IVY, (uiValue<<10));
+	}
+	
+	// HwCEM_STC                                   Hw9    // Strong C,   0:disable, 1:Enable 
+	if(uiFlag & SET_CIF_CEM_STC)
+	{
+		BITCSET(HwCEM->CEM, HwCEM_STC, (uiValue<<9));
+	}
+	
+	// HwCEM_YCL                                   Hw8    // Y Clamp (Y value clipping),   0:disable, 1:Enable 
+	if(uiFlag & SET_CIF_CEM_YCL)
+	{
+		BITCSET(HwCEM->CEM, HwCEM_YCL, (uiValue<<8));
+	}
+	
+	// HwCEM_CS                                    Hw7    // C Select (Color filter),   0:disable, 1:Enable(Color filter)  
+	if(uiFlag & SET_CIF_CEM_CS )
+	{
+		BITCSET(HwCEM->CEM, HwCEM_CS , (uiValue<<7));
+	}
+
+	// HwCEM_SKT                                   Hw6    // Sketch Enable,   0:disable, 1:Enable 
+	if(uiFlag & SET_CIF_CEM_SKT)
+	{
+		BITCSET(HwCEM->CEM, HwCEM_SKT, (uiValue<<6));
+	}
+	
+	// HwCEM_EMM                                   Hw5    // Emboss mode,   0:Positive emboss, 1:Negative emboss
+	if(uiFlag & SET_CIF_CEM_EMM)
+	{
+		BITCSET(HwCEM->CEM, HwCEM_EMM, (uiValue<<5));
+	}
+	
+	// HwCEM_EMB                                   Hw4    // Emboss,   0:disable, 1:Enable  
+	if(uiFlag & SET_CIF_CEM_EMB)
+	{
+		BITCSET(HwCEM->CEM, HwCEM_EMB, (uiValue<<4));
+	}
+	
+	// HwCEM_NEGA                                  Hw3    // Negative mode,   0:disable, 1:Enable
+	if(uiFlag & SET_CIF_CEM_NEGA)
+	{
+		BITCSET(HwCEM->CEM, HwCEM_NEGA, (uiValue<<3));
+	}
+	
+	// HwCEM_GRAY                                  Hw2    // Gray mode,   0:disable, 1:Enable 
+	if(uiFlag & SET_CIF_CEM_GRAY)
+	{
+		BITCSET(HwCEM->CEM, HwCEM_GRAY, (uiValue<<2));
+	}
+	
+	// HwCEM_SEPI                                  Hw1    // Sepia mode,   0:disable, 1:Enable    
+	if(uiFlag & SET_CIF_CEM_SEPI)
+	{
+		BITCSET(HwCEM->CEM, HwCEM_SEPI, (uiValue<<1));
+	}
+	
+	// HwCEM_NOR                                   Hw0    // Normal mode,   0:Effect mode, 1:Normal mode 
+	if(uiFlag & SET_CIF_CEM_NOR)
+	{
+		BITCSET(HwCEM->CEM, HwCEM_NOR, (uiValue));  //  0  normal  1
+	}
+
+	//  ALL_CLEAR
+	if(uiFlag & SET_CIF_CEM_ALL_CLEAR)
+	{
+		BITCSET(HwCEM->CEM, 0xFFFFFFFF, 0x00000000);  //  0 
+	} // HwCEM->CEM
+#endif
+}
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_setEffectSepiaUV
+//
+//	DESCRIPTION
+//			CIF effect setting
+//    		set CIF register  : 	HwCSUV
+//
+//	Parameters
+//
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+void TDD_CIF_SetEffectSepiaUV(unsigned int uiSepiaU, unsigned int uiSepiaV)
+{
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	BITCSET(HwCEM->CSUV, HwHwCSUV_SEPIA_U, (uiSepiaU<<8));
+	BITCSET(HwCEM->CSUV, HwHwCSUV_SEPIA_V, (uiSepiaV));    // HwCEM->CSUV
+#else //(CONFIG_ARCH_TCC92X)
+	BITCSET(HwCSUV, HwHwCSUV_SEPIA_U, (uiSepiaU<<8));
+	BITCSET(HwCSUV, HwHwCSUV_SEPIA_V, (uiSepiaV));    // HwCEM->CSUV
+#endif
+}
+
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_setEffectColorSelect
+//
+//	DESCRIPTION
+//			CIF effect setting
+//    		set CIF register  : 	HwCCS
+//
+//	Parameters
+//
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+void TDD_CIF_SetEffectColorSelect(unsigned int uiUStart, unsigned int uiUEnd, 
+										unsigned int uiVStart, unsigned int uiVEnd)
+{
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	BITCSET(HwCEM->CCS, HwCCS_USTART, (uiUStart<<24));
+	BITCSET(HwCEM->CCS, HwCCS_UEND, (uiUEnd<<16));
+	BITCSET(HwCEM->CCS, HwCCS_VSTART, (uiVStart<<8));
+	BITCSET(HwCEM->CCS, HwCCS_VEND, (uiVEnd)); // HwCEM->CCS
+#else //(CONFIG_ARCH_TCC92X)
+	BITCSET(HwCCS, HwCCS_USTART, (uiUStart<<24));
+	BITCSET(HwCCS, HwCCS_UEND, (uiUEnd<<16));
+	BITCSET(HwCCS, HwCCS_VSTART, (uiVStart<<8));
+	BITCSET(HwCCS, HwCCS_VEND, (uiVEnd)); // HwCEM->CCS
+#endif
+}
+
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_setEffectHFilterCoeff
+//
+//	DESCRIPTION
+//			CIF effect setting
+//    		set CIF register  : 	HwCHFC_COEF
+//
+//	Parameters
+//
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+void TDD_CIF_SetEffectHFilterCoeff(unsigned int uiCoeff0, unsigned int uiCoeff1, unsigned int uiCoeff2)
+{
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	BITCSET(HwCEM->CHFC, HwCHFC_COEF0, (uiCoeff0<<16));
+	BITCSET(HwCEM->CHFC, HwCHFC_COEF1, (uiCoeff1<<8));
+	BITCSET(HwCEM->CHFC, HwCHFC_COEF2, (uiCoeff2)); // HwCEM->CHFC
+#else //(CONFIG_ARCH_TCC92X)
+	BITCSET(HwCHFC, HwCHFC_COEF0, (uiCoeff0<<16));
+	BITCSET(HwCHFC, HwCHFC_COEF1, (uiCoeff1<<8));
+	BITCSET(HwCHFC, HwCHFC_COEF2, (uiCoeff2));
+#endif
+}
+
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_setEffectSketchTh
+//
+//	DESCRIPTION
+//			CIF effect setting
+//    		set CIF register  : 	HwCST
+//
+//	Parameters
+//
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+void TDD_CIF_SetEffectSketchTh(unsigned int uithreshold)
+{
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	BITCSET(HwCEM->CST, HwCST_THRESHOLD, (uithreshold)); // HwCEM->CST
+#else //(CONFIG_ARCH_TCC92X)
+	BITCSET(HwCST, HwCST_THRESHOLD, (uithreshold)); // HwCEM->CST
+#endif
+}
+
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_setEffectClampTh
+//
+//	DESCRIPTION
+//			CIF effect setting
+//    		set CIF register  : 	HwCCT
+//
+//	Parameters
+//
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+void TDD_CIF_SetEffectClampTh(unsigned int uithreshold)
+{
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	BITCSET(HwCEM->CCT, HwCCT_THRESHOLD, (uithreshold));         //HwCEM->CCT
+#else //(CONFIG_ARCH_TCC92X)
+	BITCSET(HwCCT, HwCCT_THRESHOLD, (uithreshold));         //HwCEM->CCT
+#endif
+}
+
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_setEffectBias
+//
+//	DESCRIPTION
+//			CIF effect setting
+//    		set CIF register  : 	HwCBR
+//
+//	Parameters
+//
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+void TDD_CIF_SetEffectBias(unsigned int uiYBias, unsigned int uiUBias, unsigned int uiVBias)
+{
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	BITCSET(HwCEM->CBR, HwCBR_YBIAS, (uiYBias<<16));
+	BITCSET(HwCEM->CBR, HwCBR_UBIAS, (uiUBias<<8));
+	BITCSET(HwCEM->CBR, HwCBR_VBIAS, (uiVBias));        //PEFFECT->CBR
+#else //(CONFIG_ARCH_TCC92X)
+	BITCSET(HwCBR, HwCBR_YBIAS, (uiYBias<<16));
+	BITCSET(HwCBR, HwCBR_UBIAS, (uiUBias<<8));
+	BITCSET(HwCBR, HwCBR_VBIAS, (uiVBias));        //PEFFECT->CBR
+#endif
+}
+
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_setInpathCtrl
+//
+//	DESCRIPTION
+//    		get CIF register  : 	HwCIC
+//
+//	Parameters
+//
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+void TDD_CIF_SetInpathCtrl(unsigned int uiType, unsigned int uiHWait,
+								unsigned int uiStrobeCycle, unsigned int uiInpathWait)
+{
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	if(uiType & SET_CIF_INPATH_H_WAIT)
+	{
+		BITCSET(HwCEM->INPATH_CTRL, HwCIC_H2H_WAIT, (uiHWait << 16));
+	}
+	
+	if(uiType & SET_CIF_INPATH_S_CYCLE)
+	{
+		BITCSET(HwCEM->INPATH_CTRL, HwCIC_STB_CYCLE, (uiStrobeCycle << 8));
+	}
+	
+	if(uiType & SET_CIF_INPATH_I_WAIT)
+	{
+		BITCSET(HwCEM->INPATH_CTRL, HwCIC_INP_WAIT, (uiInpathWait << 4));
+	}
+	
+	if(uiType & SET_CIF_INPATH_R_ENABLE)
+	{
+		BITSET(HwCEM->INPATH_CTRL, HwCIC_INPR);
+	}
+	
+	if(uiType & SET_CIF_INPATH_R_DISABLE)
+	{
+		BITCLR(HwCEM->INPATH_CTRL, HwCIC_INPR);
+	}
+	
+	if(uiType & SET_CIF_INPATH_FLUSH_ENABLE)
+	{
+		BITSET(HwCEM->INPATH_CTRL, HwCIC_FA);
+	}
+	
+	if(uiType & SET_CIF_INPATH_FLUSH_DISABLE)
+	{
+		BITCLR(HwCEM->INPATH_CTRL, HwCIC_FA);
+	}
+	
+	if(uiType & SET_CIF_INPATH_ENABLE)
+	{
+		BITSET(HwCEM->INPATH_CTRL, HwCIC_INE);
+	}
+	
+	if(uiType & SET_CIF_INPATH_DISABLE)
+	{
+		BITCLR(HwCEM->INPATH_CTRL, HwCIC_INE);
+	}
+	
+	if(uiType & SET_CIF_INPATH_MEM)
+	{
+		BITSET(HwCEM->INPATH_CTRL, HwCIC_INP);
+	}
+	
+	if(uiType & SET_CIF_INPATH_CAM)
+	{
+		BITCLR(HwCEM->INPATH_CTRL, HwCIC_INP);
+	}
+#else //(CONFIG_ARCH_TCC92X)
+	if(uiType & SET_CIF_INPATH_H_WAIT)
+	{
+		BITCSET(HwCIC, HwCIC_H2H_WAIT, (uiHWait << 16));
+	}
+	
+	if(uiType & SET_CIF_INPATH_S_CYCLE)
+	{
+		BITCSET(HwCIC, HwCIC_STB_CYCLE, (uiStrobeCycle << 8));
+	}
+	
+	if(uiType & SET_CIF_INPATH_I_WAIT)
+	{
+		BITCSET(HwCIC, HwCIC_INP_WAIT, (uiInpathWait << 4));
+	}
+	
+	if(uiType & SET_CIF_INPATH_R_ENABLE)
+	{
+		BITSET(HwCIC, HwCIC_INPR);
+	}
+	
+	if(uiType & SET_CIF_INPATH_R_DISABLE)
+	{
+		BITCLR(HwCIC, HwCIC_INPR);
+	}
+	
+	if(uiType & SET_CIF_INPATH_FLUSH_ENABLE)
+	{
+		BITSET(HwCIC, HwCIC_FA);
+	}
+	
+	if(uiType & SET_CIF_INPATH_FLUSH_DISABLE)
+	{
+		BITCLR(HwCIC, HwCIC_FA);
+	}
+	
+	if(uiType & SET_CIF_INPATH_ENABLE)
+	{
+		BITSET(HwCIC, HwCIC_INE);
+	}
+	
+	if(uiType & SET_CIF_INPATH_DISABLE)
+	{
+		BITCLR(HwCIC, HwCIC_INE);
+	}
+	
+	if(uiType & SET_CIF_INPATH_MEM)
+	{
+		BITSET(HwCIC, HwCIC_INP);
+	}
+	
+	if(uiType & SET_CIF_INPATH_CAM)
+	{
+		BITCLR(HwCIC, HwCIC_INP);
+	}
+
+#endif	
+}
+
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_setInpathAddr
+//
+//	DESCRIPTION
+//    		set CIF register  : 	HwCISA1,HwCISA2, HwCISA3
+//
+//	Parameters
+//
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+void TDD_CIF_SetInpathAddr(unsigned int uiSrcType, unsigned int uiSrcBase, unsigned int uiSrcBaseY, 
+								 unsigned int uiSrcBaseU, unsigned int uiSrcBaseV)
+{
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	BITCSET(HwCEM->CISA2, HwCISA2_SRC_TYPE_420SEPA, (uiSrcType<<28)); // HwCEM->CISA2
+	BITCSET(HwCEM->CISA1, HwCISA1_SRC_BASE, (uiSrcBase << 28));  // HwCEM->CISA1
+	//HwCISA1_SRC_BASE_Y         0x0FFFFFFF             // SRC_BASE_Y [27:0] Source base address in Y channel (27 down to 0 bit assign in bass address)
+	BITCSET(HwCEM->CISA1, HwCISA1_SRC_BASE_Y, (uiSrcBaseY)); // HwCEM->CISA1
+	//HwCISA2_SRC_BASE_U         0x0FFFFFFF              // SRC_BASE_U [27:0] Source base address in U channal (27 down to 0 bit assign in base address)
+	BITCSET(HwCEM->CISA2, HwCISA2_SRC_BASE_U, (uiSrcBaseU)); // HwCEM->CISA2
+	//HwCISA3_SRC_BASE_V           0x0FFFFFFF           // SRC_BASE_V [27:0] Source base address in V channal (27 down to 0 bit assign in base address)
+	BITCSET(HwCEM->CISA3, HwCISA3_SRC_BASE_V, (uiSrcBaseV)); // HwCEM->CISA3
+#else //(CONFIG_ARCH_TCC92X)
+	BITCSET(HwCISA2, HwCISA2_SRCTYPE_420SEP, (uiSrcType<<28));
+	BITCSET(HwCISA1, HwCISA1_SRC_BASE, (uiSrcBase << 28));  // HwCEM->CISA1
+	//HwCISA1_SRC_BASE_Y         0x0FFFFFFF             // SRC_BASE_Y [27:0] Source base address in Y channel (27 down to 0 bit assign in bass address)
+	BITCSET(HwCISA1, HwCISA1_SRC_BASE_Y, (uiSrcBaseY)); // HwCEM->CISA1
+	//HwCISA2_SRC_BASE_U         0x0FFFFFFF              // SRC_BASE_U [27:0] Source base address in U channal (27 down to 0 bit assign in base address)
+	BITCSET(HwCISA2, HwCISA2_SRC_BASE_U, (uiSrcBaseU)); // HwCEM->CISA2
+	//HwCISA3_SRC_BASE_V           0x0FFFFFFF           // SRC_BASE_V [27:0] Source base address in V channal (27 down to 0 bit assign in base address)
+	BITCSET(HwCISA3, HwCISA3_SRC_BASE_V, (uiSrcBaseV)); // HwCEM->CISA3
+#endif
+}
+
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_setInpathScale
+//
+//	DESCRIPTION
+//    		set CIF register  : 	HwCISS, HwCISO, HwCIDS, HwCIS
+//
+//	Parameters
+//
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+void TDD_CIF_SetInpathScale(unsigned int uiType, unsigned int uiSrcHSize, unsigned int uiSrcVSize, 
+								  unsigned int uiOffY, unsigned int uiOffC, unsigned int uiDstHSize,
+								  unsigned int uiDstVSize, unsigned int uiHScale, unsigned int uiVScale)
+{
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	if(uiType & SET_CIF_INPATH_SRC_SIZE)
+	{
+		BITCSET(HwCEM->CISS, HwCISS_SRC_HSIZE, (uiSrcHSize<<16)); // PEFFECT->CISS
+		BITCSET(HwCEM->CISS, HwCISS_SRC_VSIZE, (uiSrcVSize));    
+	}
+	
+	if(uiType & SET_CIF_INPATH_SRC_OFFSET)
+	{
+		BITCSET(HwCEM->CISO, HwCISO_SRC_OFFSET_Y, (uiOffY<<16)); //HwCEM->CISO
+		BITCSET(HwCEM->CISO, HwCISO_SRC_OFFSET_C, (uiOffC));    
+	}
+	
+	if(uiType & SET_CIF_INPATH_DST_SIZE)
+	{
+		BITCSET(HwCEM->CIDS, HwCIDS_DST_HSIZE, (uiDstHSize<<16)); // HwCEM->CIDS
+		BITCSET(HwCEM->CIDS, HwCIDS_DST_VSIZE, (uiDstVSize));    
+	}
+
+	if(uiType & SET_CIF_INPATH_SCALE)
+	{
+		BITCSET(HwCEM->CIS, HwCIS_HSCALE, (uiHScale<<16)); // HwCEM->CIS
+		BITCSET(HwCEM->CIS, HwCIS_VSCALE, (uiVScale));    
+	}
+#else //(CONFIG_ARCH_TCC92X)
+	if(uiType & SET_CIF_INPATH_SRC_SIZE)
+	{
+		BITCSET(HwCISS, HwCISS_SRC_HSIZE, (uiSrcHSize<<16)); // HwCEM->CISS
+		BITCSET(HwCISS, HwCISS_SRC_VSIZE, (uiSrcVSize));    
+	}
+	
+	if(uiType & SET_CIF_INPATH_SRC_OFFSET)
+	{
+		BITCSET(HwCISO, HwCISO_SRC_OFFSET_Y, (uiOffY<<16)); //HwCEM->CISO
+		BITCSET(HwCISO, HwCISO_SRC_OFFSET_C, (uiOffC));    
+	}
+	
+	if(uiType & SET_CIF_INPATH_DST_SIZE)
+	{
+		BITCSET(HwCIDS, HwCIDS_DST_HSIZE, (uiDstHSize<<16)); // HwCEM->CIDS
+		BITCSET(HwCIDS, HwCIDS_DST_VSIZE, (uiDstVSize));    
+	}
+	
+	if(uiType & SET_CIF_INPATH_SCALE)
+	{
+		BITCSET(HwCIS, HwCIS_HSCALE, (uiHScale<<16)); // HwCEM->CIS
+		BITCSET(HwCIS, HwCIS_VSCALE, (uiVScale));    
+	}
+#endif
+}
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_setDownScale
+//
+//	DESCRIPTION
+//    		set CIF register  : 	HwCDS
+//
+//	Parameters
+//
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+void TDD_CIF_SetDownScale(unsigned int uiScaleEnable, unsigned int uiXScale, unsigned int uiYScale)
+{
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	BITCSET(HwCIF->CDS, HwCDS_SEN_EN, uiScaleEnable); // HwCIF->CDS
+	BITCSET(HwCIF->CDS, HwCDS_SFH_8, (uiXScale << 4));
+	BITCSET(HwCIF->CDS, HwCDS_SFV_8, (uiYScale << 2));
+#else //(CONFIG_ARCH_TCC92X)
+	BITCSET(HwCDS, HwCDS_SEN_EN, uiScaleEnable); // HwCIF->CDS
+	BITCSET(HwCDS, HwCDS_SFH_8, (uiXScale << 4));
+	BITCSET(HwCDS, HwCDS_SFV_8, (uiYScale << 2));
+#endif
+}
+
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_setScalerCtrl
+//
+//	DESCRIPTION
+// 			CIF Scaler control
+//    		set CIF register  : 	HwSCC
+//
+//	Parameters
+//
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+void TDD_CIF_SetScalerCtrl(unsigned int uiEN)
+{
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	if(uiEN & SET_CIF_SCALER_ENABLE) // HwCSC->CSC
+	{
+		BITSET(HwCSC->CSC, HwSCC_EN); // PCIFSACLER    .
+	}
+
+	if(uiEN & SET_CIF_SCALER_DISABLE)
+	{
+		BITCLR(HwCSC->CSC, HwSCC_EN);
+	}
+#else //(CONFIG_ARCH_TCC92X)
+	if(uiEN & SET_CIF_SCALER_ENABLE) // HwCSC->CSC
+	{
+	        BITSET(HwCSC, HwCSC_EN);
+	}
+	
+	if(uiEN & SET_CIF_SCALER_DISABLE)
+	{
+	        BITCLR(HwCSC, HwCSC_EN);
+	}
+#endif
+}
+
+/*------------------------------------------------------------------------*/
+//	NAME : DEV_CIF_setFreeScale
+//
+//	DESCRIPTION
+//			CIF scaler setting
+//    		set CIF register  : 	HwSCSS, HwSCSO, HwSCDS, HwSCSF
+//
+//	Parameters
+//
+//	Returns
+//    	
+/* -----------------------------------------------------------------------*/
+void TDD_CIF_SetFreeScale(unsigned int uiType, unsigned int uiSrcHSize, unsigned int uiSrcVSize,
+								unsigned int uiOffH, unsigned int uiOffV, unsigned int uiDstHSize,
+								unsigned int uiDstVSize, unsigned int uiHFactor, unsigned int uiVFactor)
+{
+#if defined(CONFIG_ARCH_TCC92X) || defined(CONFIG_ARCH_TCC8900)
+	if(uiType & SET_CIF_SCALER_SRC_SIZE)
+	{
+		BITCSET(HwCSC->CSSS, HwSCSS_HSIZE, (uiSrcHSize<<16)); // HwCSC->CSSS
+		BITCSET(HwCSC->CSSS, HwSCSS_VSIZE, (uiSrcVSize));    
+	}
+	
+	if(uiType & SET_CIF_SCALER_SRC_OFFSET)
+	{
+		BITCSET(HwCSC->CSSO, HwSCSO_OFFSET_H, (uiOffH<<16)); // HwCSC->CSSO
+		BITCSET(HwCSC->CSSO, HwSCSO_OFFSET_V, (uiOffV));
+	}
+	
+	if(uiType & SET_CIF_SCALER_DST_SIZE)
+	{
+		BITCSET(HwCSC->CSDS, HwSCDS_HSIZE, (uiDstHSize<<16)); //  HwCSC->CSDS
+		BITCSET(HwCSC->CSDS, HwSCDS_VSIZE, (uiDstVSize));    
+	}
+	
+	if(uiType & SET_CIF_SCALER_FACTOR)
+	{
+		BITCSET(HwCSC->CSSF, HwSCSF_HSCALE, (uiHFactor<<16)); // HwCSC->CSSF
+		BITCSET(HwCSC->CSSF, HwSCSF_VSCALE, (uiVFactor));    
+	}
+#else //(CONFIG_ARCH_TCC92X)
+	if(uiType & SET_CIF_SCALER_SRC_SIZE)
+	{
+              BITCSET(HwCSSS, HwCSSS_HSIZE, (uiSrcHSize<<16));
+              BITCSET(HwCSSS, HwCSSS_VSIZE, (uiSrcVSize));    
+	}
+	
+	if(uiType & SET_CIF_SCALER_SRC_OFFSET)
+	{
+              BITCSET(HwCSSO, HwCSSO_OFFSET_H, (uiOffH<<16));
+              BITCSET(HwCSSO, HwCSSO_OFFSET_V, (uiOffV));
+	}
+	
+	if(uiType & SET_CIF_SCALER_DST_SIZE)
+	{
+              BITCSET(HwCSDS, HwCSDS_HSIZE, (uiDstHSize<<16));
+              BITCSET(HwCSDS, HwCSDS_VSIZE, (uiDstVSize));    
+	}
+	
+	if(uiType & SET_CIF_SCALER_FACTOR)
+	{
+              BITCSET(HwCSSF, HwCSSF_HSCALE, (uiHFactor<<16));
+              BITCSET(HwCSSF, HwCSSF_VSCALE, (uiVFactor));    
+	}
+#endif
+	
+}
+
+/* end of file */
+
Index: linux-2.6.29/drivers/media/video/tcccam/tdd_cif.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/tcccam/tdd_cif.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1 @@
+/*************************************************************************    Telechips Multi Media Player*    ------------------------------------------------**    FUNCTION    : CAMERA INTERFACE API*    MODEL        : DMP*    CPU NAME    : TCCXXX*    SOURCE        : tdd_cif.h**    START DATE    : 2008. 4. 17.*    MODIFY DATE :*    DEVISION    : DEPT. SYSTEM 3-2 TEAM*                : TELECHIPS, INC.************************************************************************/#ifndef _TDD_CIF_H_#define _TDD_CIF_H_extern void TDD_CIF_Initialize(void);extern void TDD_CIF_Reset(void);extern void TDD_CIF_ONOFF(unsigned int uiOnOff);extern void TDD_CIF_Termination(void);extern void TDD_CIF_Reset(void);/******************************************************************************    Function of    **    DDI_CIF_SetInfo**    Input    :     uiFlag*                uiBypass             : SEPARATE / NON_SEPARATE*                uiBypassBusSel    : FIRST_MSB / FIRST LSB (by 16bit mode)*                uiColorPattern        : YUV / RGB*                uiPatternFormat    : YUV444 / YUV422 / YUV420 or RGB mode*                uiRGBMode        : In RGB mode BAYER RGB, RGB565, RGB555 mode*                uiRGBBitMode        : Data bus bit 16bit mode, 8bit (enable sync), 8bit (disable sync)*                uiColorSequence    : Color sequence..*                uiBusOrder        : Swap the MSB/LSB data bus*                uiOverlayCNT        : Overlay Count*    Output    : *    Return    :     none**    Description :  Input Image Color/Pattern Configuration (ICPCR1)*****************************************************************************/extern void TDD_CIF_SetInfo(unsigned int uiFlag, unsigned int uiBypass, unsigned int uiBypassBusSel,								unsigned int uiColorPattern, unsigned int uiPatternFormat, unsigned int uiRGBMode,								unsigned int uiRGBBitMode, unsigned int uiColorSequence, unsigned int uiBusOrder);/******************************************************************************    Function of    **    DDI_CIF_SetTransfer**    Input    :    uiFlag*                uiTransMode        : BURST / INC*                uiBurst            : BurstSize*                uiLock            : Lock transfer*    Output    : *    Return    :     none**    Description : Camera I/F DMA transfer mode (CDCR1)*****************************************************************************/extern void TDD_CIF_SetTransfer(unsigned int uiFlag, unsigned int uiBurst, unsigned int uiLock,									 unsigned int uiTransMode);/******************************************************************************    Function of    **    DDI_CIF_SetOverlay**    Input    :     uiFlag*                uiOverlayCNT        : Overlay Count*                uiOverlayMethod    : Full / Block image*                uiXOR1            : XOR operation 1*                uiXOR0            : XOR operation 0*                uiAlpha1            : Alpha value in alpha 1 (0-25%, 1-50%, 2-75%, 3-100%)*                uiAlpha0            : Alpha value in alpha 0 (0-25%, 1-50%, 2-75%, 3-100%)*                *    Output    : *    Return    :     none**    Description :     Camera I/F Overlay control (OCTRL1)*****************************************************************************/extern void TDD_CIF_SetOverlay(unsigned int uiFlag, unsigned int uiOverlayCNT, unsigned int uiOverlayMethod,									unsigned int uiXOR1, unsigned int uiXOR0, unsigned int uiAlpha1, unsigned int uiAlpha0);/******************************************************************************    Function of    **    DDI_CIF_SetOverlayKey**    Input    :     uiFlag*                uiKEYR    :    Chroma-key value R(U)*                uiKEYG    :    Chroma-key value G(Y)*                uiKEYB    :    Chroma-key value B(V)*                uiMKEYR    :    Mask Chroma-key value R(U)*                uiMKEYG    :    Mask Chroma-key value G(Y)*                uiMKEYB    :    Mask Chroma-key value B(V)*    Output    : *    Return    :     none**    Description : Camera I/F Overlay key value control 2/3 (OCTRL2/OCTRL3)*****************************************************************************/extern void TDD_CIF_SetOverlayKey(unsigned int uiFlag, unsigned int uiKEYR, unsigned int uiKEYG, unsigned int uiKEYB,										unsigned int uiMKEYR, unsigned int uiMKEYG, unsigned int uiMKEYB);/******************************************************************************    Function of    **    DDI_CIF_SetSyncPol**    Input    :     uiHPolarity             : Horizontal polarity (active high/low)*                uiVPolarity            : Vertical polarity (active high/low)*    Output    : *    Return    :     none**    Description :  CIF_SYNC_POL (Camera I/F sync polarity)*                *****************************************************************************/extern void TDD_CIF_SetSyncPol(unsigned int uiHPolarity, unsigned int uiVpolarity);/******************************************************************************    Function of    **    DDI_CIF_SetImage**    Input    :    uiType                 : Input imge(INPUT_IMG), overlay image (OVERLAY_IMG)*                uiHsize                : Horizontal size*                uiVSize                : vertical size*                uiHorWindowingStart    : start X position of windowing image*                uiHorWindowingEnd    : end X position of windowing image*                uiVerWindowingStart    : start Y position of windowing image*                uiVerWindowingEnd    : end Y position of windowing image*                BaseAddress0            : Y channel base address In Overlay, overlay image adress*                BaseAddress1            : U channel base address (don't use overlay image)*                BaseAddress2            : V channel base address (don't use overlay image)*    Output    : *    Return    :     none**    Description : CIF_SETIMG (Camera I/F setting image)*                *****************************************************************************/extern void TDD_CIF_SetImage(unsigned int uiType, unsigned int uiHsize, unsigned int uiVsize,								  unsigned int uiHorWindowingStart, unsigned int uiHorWindowingEnd,								  unsigned int uiVerWindowingStart, unsigned int uiVerWindowingEnd);/******************************************************************************    Function of    **    DDI_CIF_SetScale**    Input    :     uiScaleEnable    :    Scale enable*                uiXScale        :    Horizontal scale factor*                uiYScale        :    Vertical scale factor*    Output    : *    Return    :     none**    Description :     Camera I/F Down scaler (CDS)*****************************************************************************/extern void TDD_CIF_SetDownScale(unsigned int uiScaleEnable, unsigned int uiXScale, unsigned int uiYScale);/******************************************************************************    Function of    **    DDI_CIF_SetBaseAddr**    Input    :     uiType        :    IN IMAGE                /    OVERLAY IMAGE*                uiBaseAddr0    :    Input image Y(G)        /    Overlay image base address*                uiBaseAddr1    :    Input image U(R)        /    none*                uiBaseAddr2    :    Input image V(B)        /    none*    Output    : *    Return    :     none**    Description    :  IN IMAGE - Camera I/F DMA Configuration (CDCR2/CDCR3/CDCR4)*                   OVERLAY IMAGE - Camera I/F Overlay base address set (COBA)*****************************************************************************/extern void TDD_CIF_SetBaseAddr(unsigned int uiType, unsigned int uiBaseAddr0,										unsigned int uiBaseAddr1, unsigned int uiBaseAddr2);extern void TDD_CIF_SetBaseAddr_offset(unsigned int uiType, unsigned int uiOFFSET_Y, unsigned int uiOFFSET_C);/******************************************************************************    Function of    **    DDI_CIF_OverlayCtrl**    Input    :     uiFlag (Alpha/Chromakey/Overlay)*                uiAlphaEnable (Enable/Disable)*                uiChromakeyEnable (Enable/Disable)*                uiOverlayEnable (Enable/Disable)*    Output    : *    Return    :     none**    Description    : Camera I/F Alpha/Chromakey/Overlay enable/disable*****************************************************************************/extern void TDD_CIF_OverlayCtrl(unsigned int uiFlag, unsigned int uiRgb);extern void TDD_CIF_SetInterrupt(unsigned int uiFlag);extern unsigned int TDD_CIF_GetIntStatus(unsigned int uiFlag);extern void TDD_CIF_SetCaptureCtrl(unsigned int uiType,  unsigned int uiSkipNum,										 unsigned int uiVCnt, unsigned int uiFlag);extern void TDD_CIF_SetCtrl(unsigned int uiFlag, unsigned int uiPWDN, unsigned int uiBypass_Scaler,								unsigned int uiPXCLK_POL, unsigned int uiSKPF, unsigned int uiM420_FC,								unsigned int uiC656);extern void TDD_CIF_SetMaskIntStatus(unsigned int uiFlag);extern void TDD_CIF_SetSensorOutImgSize(unsigned int uiHsize, unsigned int uiVsize);extern void TDD_CIF_SetScalerCtrl(unsigned int uiEN);extern void TDD_CIF_SetFreeScale(unsigned int uiType, unsigned int uiSrcHSize, unsigned int uiSrcVSize,										unsigned int uiOffH, unsigned int uiOffV, unsigned int uiDstHSize,										unsigned int uiDstVSize, unsigned int uiHFactor, unsigned int uiVFactor);extern void TDD_CIF_SetEffectMode(unsigned int uiFlag);extern void TDD_CIF_SetEffectSepiaUV(unsigned int uiSepiaU, unsigned int uiSepiaV);extern void TDD_CIF_SetEffectColorSelect(unsigned int uiUStart, unsigned int uiUEnd, 												unsigned int uiVStart, unsigned int uiVEnd);extern void TDD_CIF_SetEffectHFilterCoeff(unsigned int uiCoeff0, unsigned int uiCoeff1, unsigned int uiCoeff2);extern void TDD_CIF_SetEffectSketchTh(unsigned int uithreshold);extern void TDD_CIF_SetEffectClampTh(unsigned int uithreshold);extern void TDD_CIF_SetEffectBias(unsigned int uiYBias, unsigned int uiUBias, unsigned int uiVBias);#endif  //  _TDD_CIF_H_
\ No newline at end of file
Index: linux-2.6.29/drivers/mmc/core/sdio_cis.c
===================================================================
--- linux-2.6.29.orig/drivers/mmc/core/sdio_cis.c	2010-04-07 12:29:34.000000000 -0400
+++ linux-2.6.29/drivers/mmc/core/sdio_cis.c	2010-04-07 12:29:36.000000000 -0400
@@ -220,7 +220,9 @@
 			break;
 
 		/* 0xff means we're done */
-		if (tpl_code == 0xff)
+		//if (tpl_code == 0xff)
+        /* Realtek 8123 */
+		if (tpl_code == 0xff || tpl_code==0x00)
 			break;
 
 		ret = mmc_io_rw_direct(card, 0, 0, ptr++, 0, &tpl_link);
Index: linux-2.6.29/drivers/mmc/host/Kconfig
===================================================================
--- linux-2.6.29.orig/drivers/mmc/host/Kconfig	2010-04-07 12:29:34.000000000 -0400
+++ linux-2.6.29/drivers/mmc/host/Kconfig	2010-04-07 12:29:36.000000000 -0400
@@ -212,3 +212,23 @@
 	help
 	  This provides support for the SD/MMC cell found in TC6393XB,
 	  T7L66XB and also ipaq ASIC3
+
+config MMC_TCC_SDHC
+	bool "Telechips SD/MMC Host Controller Driver"	
+	help
+	  This selects the Telechips Multimedia card Interface.
+	  If you have an TCC board with a Multimedia Card slot,
+	  say Y here.
+
+config MMC_TCC_SDHC_CORE0
+	bool "Enabling a TCC SDHC Core 0"
+	depends on MMC_TCC_SDHC
+	help
+	  This selects the TCC SDHC Core 0.
+
+config MMC_TCC_SDHC_CORE1
+	bool "Enabling a TCC SDHC Core 1"
+	depends on MMC_TCC_SDHC
+	help
+	  This selects the TCC SDHC Core 1.
+
Index: linux-2.6.29/drivers/mmc/host/Makefile
===================================================================
--- linux-2.6.29.orig/drivers/mmc/host/Makefile	2010-04-07 12:29:34.000000000 -0400
+++ linux-2.6.29/drivers/mmc/host/Makefile	2010-04-07 12:29:36.000000000 -0400
@@ -27,4 +27,5 @@
 obj-$(CONFIG_MMC_S3C)   	+= s3cmci.o
 obj-$(CONFIG_MMC_SDRICOH_CS)	+= sdricoh_cs.o
 obj-$(CONFIG_MMC_TMIO)		+= tmio_mmc.o
+obj-$(CONFIG_MMC_TCC_SDHC)	+= tcc_sdhc.o
 
Index: linux-2.6.29/drivers/mmc/host/tcc_sdhc.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/mmc/host/tcc_sdhc.c	2010-04-07 13:00:43.000000000 -0400
@@ -0,0 +1,1294 @@
+/*
+ * linux/drivers/mmc/host/tcc_sdhc.c  
+ *
+ * Author:  <linux@telechips.com>
+ * Created: June 10, 2008
+ * Description: SD/MMC Host Driver for Telechips Boards.
+ *
+ * Copyright (C) 2008-2009 Telechips 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/timer.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/card.h>
+#include <linux/clk.h>
+
+#include <linux/pci.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/scatterlist.h>
+#include <asm/mach-types.h>
+
+#include <linux/tcc_ll.h>
+#include <linux/tcc_pwm.h>
+
+#include <bsp.h>
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+#include <mach/tca_ckc.h>
+#include <mach/tcc_pca953x.h>
+#include "tcc_sdhc.h"
+
+/*
+ * Controller registers
+ */
+#define TCCSDHC_DMA_ADDRESS 		0x00
+#define TCCSDHC_BLOCK_SIZE			0x04
+
+#define TCCSDHC_MAKE_BLKSZ(dma, blksz) (((dma & 0x7) << 12) | (blksz & 0xFFF))
+
+#define TCCSDHC_BLOCK_COUNT 		0x06
+#define TCCSDHC_ARGUMENT			0x08
+//#define TCCSDHC_TRANSFER_MODE		0x0C
+//#define TCCSDHC_COMMAND 			0x0E
+#define TCCSDHC_TMODE_COM			0x0C
+
+#define TCCSDHC_MAKE_CMD(c, f) (((c & 0xff) << 8) | (f & 0xff))
+
+#define TCCSDHC_RESPONSE10			0x10
+#define TCCSDHC_RESPONSE32			0x14
+#define TCCSDHC_RESPONSE54			0x18
+#define TCCSDHC_RESPONSE76			0x1c
+#define TCCSDHC_BUFFER				0x20
+#define TCCSDHC_PRESENT_STATE		0x24
+#define TCCSDHC_HOST_CONTROL		0x28
+//#define TCCSDHC_POWER_CONTROL		0x29
+//#define TCCSDHC_BLOCK_GAP_CONTROL	0x2A
+//#define TCCSDHC_WAKE_UP_CONTROL 	0x2B
+#define TCCSDHC_CLOCK_CONTROL		0x2C
+#define TCCSDHC_TIMEOUT_CONTROL 	0x2E
+//#define TCCSDHC_SOFTWARE_RESET	0x2F
+#define TCCSDHC_INT_STATUS			0x30
+#define TCCSDHC_INT_ENABLE			0x34
+#define TCCSDHC_SIGNAL_ENABLE		0x38
+#define TCCSDHC_ACMD12_ERR			0x3C
+
+#undef	DEBUG
+//#define DEBUG
+#ifdef	DEBUG
+#define SD_DEBUG(x...)	printk(x)
+#define SD_ERROR(x...)	printk(x)
+#else
+#define SD_DEBUG(x...)
+#define SD_ERROR(x...)
+#endif
+
+#define DRIVER_NAME			"tcc-sdhc"
+#define DRIVER_NAME_CORE0	"tcc-sdhc0"
+#define DRIVER_NAME_CORE1	"tcc-sdhc1"
+#define DETECT_TIMEOUT		(HZ/2)
+#define SDMMC_FIFO_CNT		1024
+#define SDMMC_TIMEOUT_TICKS	(1000*HZ/1000)	/* 1000ms */
+
+volatile PSDCHCTRL_T pSDCHCTRL = (volatile PSDCHCTRL_T)SDCHCTRL_BASE;
+volatile PSDHOST_T pSDMMC_SLOT0 = (volatile PSDHOST_T)SDCORE0SLOT0_BASE;
+volatile PSDHOST_T pSDMMC_SLOT1 = (volatile PSDHOST_T)SDCORE1SLOT2_BASE;
+
+
+struct tcc_mmc_host {
+    int	initialized;
+    int	suspended;
+    struct mmc_request *mrq;
+    struct mmc_command *cmd;
+    struct mmc_data *data;
+    int data_early:1;				/* Data finished before cmd */
+    
+    struct mmc_host *mmc;
+    struct device *dev;
+    unsigned char id;				/* 16xx chips have 2 MMC blocks */
+    unsigned long peri_clk;
+    struct clk *iclk;
+    struct clk *fclk;
+    struct resource	*res;
+    void __iomem *base;
+	u32 iobase;
+    int	irq;
+    unsigned char bus_mode;
+    unsigned char hw_bus_mode;
+
+	char slot_desc[16]; 			/* Name for reservations */
+	
+    unsigned int sg_len;
+    int	sg_idx;
+    u16 *buffer;
+    u32	buffer_bytes_left;
+    u32	total_bytes_left;
+
+    struct scatterlist *cur_sg;		/* We're working on this */
+    int	num_sg;						/* Entries left */
+    int	offset;						/* Offset into current sg */
+    int	remain;						/* Bytes left in current */
+
+    short wp_pin;
+
+    short card_inserted;			/* to mark the card is inserted or not */
+
+    struct tasklet_struct finish_tasklet;
+
+    spinlock_t lock;				/* Mutex */   
+
+    int flags;						/* Host attributes */
+#define TCC_MMC_USE_DMA		(1<<0)	/* Host is DMA capable */
+#define TCC_MMC_REQ_USE_DMA	(1<<1)	/* Use DMA for this req. */
+
+    struct timer_list detect_timer;
+    struct timer_list timer;
+};
+
+static bool bChanged = 0;
+static stpwrinfo pwrinfo = {PWR_STATUS_ON};
+
+static void tcc_mmc_start_command(struct tcc_mmc_host *host, struct mmc_command *cmd);
+static void tcc_mmc_tasklet_finish(unsigned long param);
+static void init_mmc_host(struct tcc_mmc_host *host);
+static void deinit_mmc_host(struct tcc_mmc_host *host);
+
+static int tcc_sw_reset(struct tcc_mmc_host *host, uint8_t rst_bits)
+{
+	int timeout = 100;
+
+	tcc_writew(rst_bits<<8 | tcc_readw(host->iobase+TCCSDHC_TIMEOUT_CONTROL), host->iobase+TCCSDHC_TIMEOUT_CONTROL);
+	
+	while (--timeout) {
+		if (!(tcc_readw(host->iobase+TCCSDHC_TIMEOUT_CONTROL)& rst_bits<<8)){
+			break;
+		}
+		/* Must be mdelay not msleep, as called from interrupt context */
+		mdelay(1);
+	}
+	if (!timeout) {
+		SD_DEBUG("timed out waiting for reset\n");
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+int tcc_mmc_card_inserted(struct tcc_mmc_host *host)
+{
+	int ret = -1;
+	if(host->id == 0) {
+		ret = (HwGPIOA->GPDAT & Hw6) ? 0 : 1;
+	} else if(host->id == 1) {	
+		ret = (HwGPIOA->GPDAT & Hw10) ? 0 : 1;		
+	}
+	return ret;
+}
+
+/*
+ * Card insert/remove timer handler
+ */
+static void tcc_mmc_poll_event(unsigned long data)
+{
+	struct tcc_mmc_host *host = (struct tcc_mmc_host *) data;	
+
+	if (!tcc_mmc_card_inserted(host)) {
+		/* card removed */
+		if (host->card_inserted == 1) {
+			host->card_inserted = 0;
+			bChanged = 1;
+			SD_DEBUG("SD card removed\n");
+		}
+	} else if (host->card_inserted == 0) {
+		host->card_inserted = 1;
+		bChanged = 1;
+		SD_DEBUG("SD card inserted");
+	}
+
+	if (host && bChanged) {       
+		mmc_detect_change(host->mmc, msecs_to_jiffies(500));
+		bChanged = 0;
+	}
+
+	mod_timer(&host->detect_timer, jiffies + DETECT_TIMEOUT);
+}
+
+static void tcc_mmc_clock_onoff(struct tcc_mmc_host *host, unsigned char onoff)
+{
+	u16 temp_val;
+
+	if (onoff == 1) {
+		BITSET(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_SD);
+
+		temp_val = tcc_readw(host->iobase+TCCSDHC_CLOCK_CONTROL);
+		tcc_writew(temp_val|HwSDCLKSEL_SCK_EN, host->iobase+TCCSDHC_CLOCK_CONTROL);
+	} else if (onoff == 0) {
+		temp_val = tcc_readw(host->iobase+TCCSDHC_CLOCK_CONTROL);
+		tcc_writew(temp_val&~HwSDCLKSEL_SCK_EN, host->iobase+TCCSDHC_CLOCK_CONTROL);
+
+		//FIXME: need to be revised for power saving. currently bus clock is always running.
+		if ((pSDMMC_SLOT0->CLK & HwSDCLKSEL_SCK_EN) == 0  &&(pSDMMC_SLOT1->CLK & HwSDCLKSEL_SCK_EN) == 0) {
+			//HwBCLKCTR &= ~HwBCLKCTR_SD_ON;
+		}
+	}
+}
+
+static void tcc_mmc_finish_data(struct tcc_mmc_host *host)
+{
+	struct mmc_data *data;
+	u16 blocks;
+
+	BUG_ON(!host->data);
+
+	data = host->data;
+	host->data = NULL;
+
+	if (host->flags & TCC_MMC_REQ_USE_DMA) {
+		pci_unmap_sg(NULL, data->sg, data->sg_len,
+				(data->flags & MMC_DATA_READ)?PCI_DMA_FROMDEVICE:PCI_DMA_TODEVICE);
+	}
+
+	/*
+	 * Controller doesn't count down when in single block mode.
+	 */
+	if (data->blocks == 1) {
+		blocks = (data->error == 0) ? 0 : 1;
+	} else {
+		blocks = tcc_readw(host->iobase+TCCSDHC_BLOCK_COUNT);
+	}
+	data->bytes_xfered = data->blksz * (data->blocks - blocks);
+
+	if (!data->error && blocks) {
+		printk(KERN_ERR "%s: Controller signalled completion even "
+				"though there were blocks left.\n",
+				mmc_hostname(host->mmc));
+		data->error = -EIO;
+	}
+#if 0  //It must be enabled. When It doesn't sends STOP command
+	if (data->stop) {
+		/*
+		 * The controller needs a reset of internal state machines
+		 * upon error conditions.
+		 */
+		if (data->error) {
+			tcc_sw_reset(host, HwSD_SRESET_RSTCMD);
+			tcc_sw_reset(host, HwSD_SRESET_RSTDAT);           
+		}
+		tcc_mmc_start_command(host, data->stop);
+	} else {
+		tasklet_schedule(&host->finish_tasklet);
+	}
+#endif	
+	tasklet_schedule(&host->finish_tasklet);
+}
+
+//FIXME: Not yet implemented...
+static void tcc_transfer_pio(struct tcc_mmc_host *host)
+{
+	BUG_ON(!host->data);
+	printk("\nenter %s  ", __func__);
+}
+
+static void tcc_mmc_start_command(struct tcc_mmc_host *host, struct mmc_command *cmd)
+{
+	u32 resptype;
+	u32 cmdtype;
+	u32 mask;
+	unsigned long timeout;    
+	int cmd_reg = 0x00000000;
+	unsigned int uiIntStatusEn;
+
+	/* Wait max 10 ms */
+	timeout = 10;    
+
+	cmdtype = 0;
+
+	mask = HwSD_STATE_NOCMD;
+	if ((cmd->data != NULL) || (cmd->flags & MMC_RSP_BUSY)) {
+		mask |= HwSD_STATE_NODAT;
+	}
+
+	/* We shouldn't wait for data inihibit for stop commands, even
+	   though they might use busy signaling */
+	if (host->mrq->data && (cmd == host->mrq->data->stop)) {
+		mask &= ~HwSD_STATE_NODAT;
+	}
+
+	while (tcc_readl(host->iobase+TCCSDHC_PRESENT_STATE) & mask) {
+		if (timeout == 0) {
+			printk(KERN_ERR "%s: Controller never released "
+					"inhibit bit(s).\n", mmc_hostname(host->mmc));
+			cmd->error = -EIO;
+			tasklet_schedule(&host->finish_tasklet);
+			return;
+		}
+		timeout--;
+		mdelay(1);
+	}
+
+	mod_timer(&host->timer, jiffies + 10 * HZ);
+
+	host->cmd = cmd;    
+
+	switch (mmc_resp_type(cmd)) {
+		case MMC_RSP_NONE:
+			resptype = 0;
+			break;
+		case MMC_RSP_R1:
+			resptype = 2;
+			break;
+		case MMC_RSP_R1B:
+			resptype = 3;
+			break;
+		case MMC_RSP_R2:
+			resptype = 1;
+			break;
+		default:
+			resptype = 2;
+			break;
+	}
+
+	uiIntStatusEn = tcc_readl(host->iobase+TCCSDHC_INT_ENABLE);
+
+	uiIntStatusEn |= HwSDINT_EN_TDONE | HwSDINT_EN_CDONE;
+
+	if (cmd->data) {
+		host->data = cmd->data;
+		host->data_early = 0;
+
+		cmd_reg |= HwSD_COM_TRANS_DATSEL | HwSD_COM_TRANS_DIR;
+
+		if (cmd->data->blocks > 1) {
+			cmd_reg |= HwSD_COM_TRANS_MS | HwSD_COM_TRANS_BCNTEN;
+			if(cmd->opcode !=SD_IO_RW_EXTENDED) {
+				cmd_reg |= HwSD_COM_TRANS_ACMD12;  // It is related STOP command
+			}
+		}
+
+		if (cmd->data->flags & MMC_DATA_WRITE)
+			cmd_reg &= ~HwSD_COM_TRANS_DIR;
+
+		if (host->flags & TCC_MMC_USE_DMA)
+			host->flags |= TCC_MMC_REQ_USE_DMA;
+
+		if (host->flags & TCC_MMC_REQ_USE_DMA)
+			cmd_reg |= HwSD_COM_TRANS_DMAEN;        
+
+		if (host->flags & TCC_MMC_REQ_USE_DMA) {
+			int count;
+			count = pci_map_sg(NULL, cmd->data->sg, cmd->data->sg_len,
+					(cmd->data->flags & MMC_DATA_READ)?PCI_DMA_FROMDEVICE:PCI_DMA_TODEVICE);
+			BUG_ON(count != 1);
+
+			tcc_writel(sg_dma_address(cmd->data->sg), host->iobase+TCCSDHC_DMA_ADDRESS);		  
+
+		} else {
+			host->cur_sg = cmd->data->sg;
+			host->num_sg = cmd->data->sg_len;
+			host->offset = 0;
+			host->remain = host->cur_sg->length;
+		}
+	}    
+
+	if (((cmd->opcode==SD_IO_RW_DIRECT)&& ((cmd->arg & (0x03<<28)) ==0)  
+				&& ((cmd->arg&(0x1ff<<9)) ==(SDIO_CCCR_ABORT<<9)) &&(cmd->arg&0x07)) 
+			|| (cmd->opcode==MMC_STOP_TRANSMISSION)) {
+		/* Use R5b For CMD52, Function 0, I/O Abort 
+		 * Need to be revised for handling CMD12       
+		 */
+		cmdtype = HwSD_COM_TRANS_ABORT;
+	}
+
+	if (cmd->flags & MMC_RSP_CRC)
+		cmd_reg |= HwSD_COM_TRANS_CRCHK;
+
+	if (cmd->flags & MMC_RSP_OPCODE)
+		cmd_reg |= HwSD_COM_TRANS_CICHK;
+
+	cmd_reg |= (cmd->opcode << 24) |cmdtype| (resptype << 16);
+
+	tcc_mmc_clock_onoff(host, 1);
+
+	if (tcc_readl(host->iobase+TCCSDHC_INT_STATUS) & HwSDINT_STATUS_ERR) {
+		tcc_writew(tcc_readw(host->iobase+TCCSDHC_TIMEOUT_CONTROL)|(HwSD_SRESET_RSTCMD<<8), host->iobase+TCCSDHC_TIMEOUT_CONTROL);
+		while (tcc_readw(host->iobase+TCCSDHC_TIMEOUT_CONTROL) & HwSD_SRESET_RSTCMD<<8);
+			msleep(1);
+	}
+	
+	tcc_writel(tcc_readl(host->iobase+TCCSDHC_INT_STATUS),host->iobase+TCCSDHC_INT_STATUS);
+
+	if (cmd->data) {
+		tcc_writew((0x07<<12) | cmd->data->blksz, host->iobase+TCCSDHC_BLOCK_SIZE);
+		tcc_writew(cmd->data->blocks , host->iobase+TCCSDHC_BLOCK_COUNT);
+	} else {
+		tcc_writel(0, host->iobase+TCCSDHC_DMA_ADDRESS);	
+		tcc_writew(0, host->iobase+TCCSDHC_BLOCK_SIZE);
+		tcc_writew(0, host->iobase+TCCSDHC_BLOCK_COUNT);
+	}
+
+	tcc_writel(cmd->arg, host->iobase+TCCSDHC_ARGUMENT);
+
+	/* Enable transfer interrupt sources */
+	tcc_writel(uiIntStatusEn, host->iobase+TCCSDHC_INT_ENABLE);
+	tcc_writel(cmd_reg, host->iobase +TCCSDHC_TMODE_COM);
+
+	SD_DEBUG("%s: opcode=%d, arg=%x\n", __func__, cmd->opcode, cmd->arg);
+	//SD_DEBUG("data:%x,blksz:%d,blk:%d,flags:%x\n\n", data, data->blksz, data->blocks, data->flags);		
+}
+
+static void tcc_mmc_finish_command(struct tcc_mmc_host *host)
+{
+	BUG_ON(host->cmd == NULL);
+
+	if (host->cmd->flags & MMC_RSP_PRESENT) {
+		if (host->cmd->flags & MMC_RSP_136) {
+			host->cmd->resp[0] = tcc_readl(host->iobase+TCCSDHC_RESPONSE76);
+			host->cmd->resp[1] = tcc_readl(host->iobase+TCCSDHC_RESPONSE54);
+			host->cmd->resp[2] = tcc_readl(host->iobase+TCCSDHC_RESPONSE32);
+			host->cmd->resp[3] = tcc_readl(host->iobase+TCCSDHC_RESPONSE10);
+
+			SD_DEBUG("%s: R2: resp[0]=0x%08x, resp[1]=0x%08x, resp[2]=0x%08x, resp[3]=0x%08x\n",
+					__func__, host->cmd->resp[0], host->cmd->resp[1], host->cmd->resp[2], host->cmd->resp[3]);
+
+			host->cmd->resp[0] = (host->cmd->resp[0] << 8) | ((host->cmd->resp[1] & 0xFF000000) >> 24);
+			host->cmd->resp[1] = (host->cmd->resp[1] << 8) | ((host->cmd->resp[2] & 0xFF000000) >> 24);
+			host->cmd->resp[2] = (host->cmd->resp[2] << 8) | ((host->cmd->resp[3] & 0xFF000000) >> 24);
+			host->cmd->resp[3] <<= 8;                
+
+		} else {
+			host->cmd->resp[0] = tcc_readl(host->iobase+TCCSDHC_RESPONSE10);
+			
+			SD_DEBUG("%s: R1: resp[0]=0x%08x\n",  __func__, host->cmd->resp[0]);
+		}
+	}
+
+	host->cmd->error = 0;
+
+	if (host->data && host->data_early)
+		tcc_mmc_finish_data(host);
+
+	if (!host->cmd->data)
+		tasklet_schedule(&host->finish_tasklet);
+
+	host->cmd = NULL;
+}
+
+static void tcc_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	struct tcc_mmc_host *host = mmc_priv(mmc);
+	unsigned long flags;
+
+	spin_lock_irqsave(&host->lock, flags);
+
+	BUG_ON(host->mrq != NULL);
+
+	host->mrq = mrq;
+
+	if(!host->card_inserted) {
+		host->mrq->cmd->error = -ENOMEDIUM;
+		tasklet_schedule(&host->finish_tasklet);
+	} else {
+		tcc_mmc_start_command(host, mrq->cmd);        
+	}
+
+	mmiowb();
+	spin_unlock_irqrestore(&mmc->lock, flags);
+}
+
+/* High speed mode threshold (Hz).
+ * 
+ * Although high speed mode should be suitable for all speeds not all
+ * controller/card combinations are capable of meeting the higher
+ * tolerances for (e.g.) clock rise/fall times.  Therefore, default
+ * mode is used where possible for improved compatibility. */
+ 
+#define SDIO_CLOCK_FREQ_HIGH_SPD 25000000
+
+static void tcc_hw_set_high_speed(struct mmc_host *mmc, int hs)
+{
+	struct tcc_mmc_host *host = mmc_priv(mmc);
+	unsigned long flags;
+	u8 host_ctrl = 0;
+
+	spin_lock_irqsave(&mmc->lock, flags);
+
+	host_ctrl= tcc_readw(host->iobase+TCCSDHC_HOST_CONTROL);
+	host_ctrl &= ~HwSD_POWER_HS;
+	
+	if (hs) {
+		host_ctrl |= HwSD_POWER_HS;
+	}
+	
+	tcc_writew(host_ctrl, host->iobase+TCCSDHC_HOST_CONTROL);
+
+	spin_unlock_irqrestore(&mmc->lock, flags);
+}
+
+static void tcc_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	unsigned long flags;    
+	unsigned uBCLKCTR;
+	struct tcc_mmc_host *host = mmc_priv(mmc);
+	uint32_t temp_reg;    
+
+	long dwMaxClockRate = host->peri_clk;
+	int i = 0; /* 2^i is the divisor value */
+	u32 clk_div=0;
+
+	spin_lock_irqsave(&host->lock, flags);
+
+	uBCLKCTR = HwIOBUSCFG->HCLKEN0;
+	HwIOBUSCFG->HCLKEN0 |= HwIOBUSCFG_SD;
+
+	if (ios->clock != 0) {
+		tcc_hw_set_high_speed(mmc, ios->clock >SDIO_CLOCK_FREQ_HIGH_SPD);
+		/* shift MaxClockRate until we find the closest frequency <= target */
+		while ((ios->clock < dwMaxClockRate) && (i < 8)) {
+			dwMaxClockRate = dwMaxClockRate >> 1;
+			i++;
+		}
+
+		if (i != 0) {
+			//printk("\nclock value = %d\n", i);                 
+			clk_div = 1<<(i-1);
+			temp_reg = tcc_readl(host->iobase+TCCSDHC_CLOCK_CONTROL);
+			tcc_writew(temp_reg & ~HwSDCLKSEL_SCK_EN, host->iobase+TCCSDHC_CLOCK_CONTROL);
+
+			udelay(10);
+
+			tcc_writew((clk_div << 8)|HwSDCLKSEL_INCLK_EN, host->iobase+TCCSDHC_CLOCK_CONTROL);
+
+			while ((tcc_readl(host->iobase+TCCSDHC_CLOCK_CONTROL) & HwSDCLKSEL_INCLK_STABLE) == 0);
+			temp_reg = tcc_readl(host->iobase+TCCSDHC_CLOCK_CONTROL);
+			tcc_writew(temp_reg|(HwSDCLKSEL_SCK_EN|HwSDCLKSEL_INCLK_EN), host->iobase+TCCSDHC_CLOCK_CONTROL);			 
+		}
+	}
+
+	switch (ios->power_mode) {
+		case MMC_POWER_OFF:
+			//printk("-----------------------MMC_POWER_OFF\n");
+			if (pwrinfo.status == PWR_STATUS_OFF) {
+				deinit_mmc_host(host);
+			}
+			break;
+		case MMC_POWER_UP:
+			//printk("-----------------------MMC_POWER_UP\n");
+			init_mmc_host(host);
+			break;
+		case MMC_POWER_ON:
+			//printk("-----------------------MMC_POWER_ON\n");
+			break;
+	}
+
+	switch (ios->bus_width) {
+		case MMC_BUS_WIDTH_1:
+			//printk("\n/***********1 bit mode***************/ \n"); 
+			if (host->id == 0) {
+				pSDMMC_SLOT0->CONTL &= ~(HwSD_POWER_SD4 | HwSD_POWER_SD8);
+				pSDMMC_SLOT0->CONTL |= HwSD_POWER_POW|(HwSD_POWER_VOL33);;
+
+				pSDMMC_SLOT0->CONTH &=~Hw19;                
+			} else if (host->id == 1) {
+				pSDMMC_SLOT1->CONTL &= ~(HwSD_POWER_SD4 | HwSD_POWER_SD8);
+				pSDMMC_SLOT1->CONTL |= HwSD_POWER_POW|(HwSD_POWER_VOL33);;
+
+				pSDMMC_SLOT1->CONTH &=~Hw19;							
+			}
+			break;
+		case MMC_BUS_WIDTH_4:
+			//printk("\n/***********4 bit mode***************/\n "); 
+			if (host->id == 0) {
+				pSDMMC_SLOT0->CONTL &= ~HwSD_POWER_SD8;
+				pSDMMC_SLOT0->CONTL |= HwSD_POWER_POW|(HwSD_POWER_VOL33)|HwSD_POWER_SD4;
+				pSDMMC_SLOT0->CONTH |=Hw19;
+			} else if (host->id == 1) {	
+				pSDMMC_SLOT1->CONTL &= ~HwSD_POWER_SD8;
+				pSDMMC_SLOT1->CONTL |= HwSD_POWER_POW|(HwSD_POWER_VOL33)|HwSD_POWER_SD4;
+				pSDMMC_SLOT1->CONTH |=Hw19;	
+			}
+			break;
+	}
+
+	host->bus_mode = ios->bus_mode;
+
+	//need to add resetting a controller?
+
+	HwIOBUSCFG->HCLKEN0 = uBCLKCTR;
+	mmiowb();	 
+	spin_unlock_irqrestore(&host->lock, flags);
+}
+
+static int tcc_mmc_get_ro(struct mmc_host *mmc)
+{
+	struct tcc_mmc_host *host = mmc_priv(mmc);
+	unsigned long flags;    
+	uint32_t reg=0;    
+
+	spin_lock_irqsave(&host->lock, flags);
+
+	reg = tcc_readl(host->iobase + TCCSDHC_PRESENT_STATE);
+
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	return !(reg & HwSD_STATE_SDWP);
+}
+
+static void tcc_sdio_hw_enable_int(struct mmc_host *mmc, uint32_t sigs)
+{
+	struct tcc_mmc_host *host = mmc_priv(mmc);
+	unsigned long flags;
+	uint32_t stat_en;
+
+	spin_lock_irqsave(&host->lock, flags);
+
+	stat_en=tcc_readl(host->iobase+TCCSDHC_INT_ENABLE);	
+	tcc_writel( stat_en | sigs, host->iobase+TCCSDHC_INT_ENABLE);
+
+	spin_unlock_irqrestore(&host->lock, flags);
+}
+
+static void tcc_sdio_hw_disable_int(struct mmc_host *mmc, uint32_t sigs)
+{
+	struct tcc_mmc_host *host = mmc_priv(mmc);
+	unsigned long flags;
+	uint32_t stat_en;    
+
+	spin_lock_irqsave(&host->lock, flags);
+
+	stat_en=tcc_readl(host->iobase+TCCSDHC_INT_ENABLE);
+	tcc_writel(stat_en & ~sigs, host->iobase+TCCSDHC_INT_ENABLE);
+
+	spin_unlock_irqrestore(&host->lock, flags);
+}
+
+static void tcc_sdio_enable_card_int(struct mmc_host *mmc)
+{
+	tcc_sdio_hw_enable_int(mmc, HwSDINT_EN_CDINT);
+}
+
+static void tcc_sdio_disable_card_int(struct mmc_host *mmc)
+{
+	tcc_sdio_hw_disable_int(mmc, HwSDINT_EN_CDINT);
+}
+
+/*
+ * Interrupt handling
+ */
+static void tcc_mmc_cmd_irq(struct tcc_mmc_host *host, u32 intmask)
+{
+	BUG_ON(intmask == 0);
+
+	if (!host->cmd) {
+		printk(KERN_ERR "%s: Got command interrupt 0x%08x even "
+				"though no command operation was in progress.\n",
+				mmc_hostname(host->mmc), (unsigned)intmask);
+		return;
+	}
+
+	if (intmask & HwSDINT_STATUS_CMDTIME) {
+		host->cmd->error = -ETIMEDOUT;
+	} else if (intmask & (HwSDINT_STATUS_CMDCRC | HwSDINT_STATUS_CMDEND | HwSDINT_STATUS_CINDEX)) {
+		host->cmd->error = -EILSEQ;
+	}
+
+	if (host->cmd->error) {
+		tasklet_schedule(&host->finish_tasklet);
+	} else if (intmask & HwSDINT_STATUS_CDONE) {
+		tcc_mmc_finish_command(host);
+	}
+}
+
+static void tcc_mmc_data_irq(struct tcc_mmc_host *host, u32 intmask)
+{
+	BUG_ON(intmask == 0);
+
+	if (!host->data) {
+		/*
+		 * A data end interrupt is sent together with the response
+		 * for the stop command.
+		 */
+		if (intmask & HwSDINT_STATUS_TDONE)
+			return;
+
+		printk(KERN_ERR "%s: Got data interrupt 0x%08x even "
+				"though no data operation was in progress.\n",
+				mmc_hostname(host->mmc), (unsigned)intmask);
+		return;
+	}
+
+	if (intmask & HwSDINT_STATUS_DATTIME) {
+		host->data->error = -ETIMEDOUT;
+	} else if (intmask & (HwSDINT_STATUS_DATCRC | HwSDINT_STATUS_DATEND)) {
+		host->data->error = -EILSEQ;
+	}
+
+	if (host->data->error) {
+		tcc_mmc_finish_data(host);
+	} else {
+		if (intmask & (HwSDINT_STATUS_RDRDY | HwSDINT_STATUS_WRRDY)) {
+			printk(" \n %x \n ", intmask);
+			tcc_transfer_pio(host);
+		}
+
+		/*
+		 * We currently don't do anything fancy with DMA
+		 * boundaries, but as we can't disable the feature
+		 * we need to at least restart the transfer.
+		 */
+		if (intmask & HwSDINT_STATUS_DMA){
+			tcc_writel(tcc_readl(host->iobase+TCCSDHC_DMA_ADDRESS), host->iobase+TCCSDHC_DMA_ADDRESS);			
+		}			
+
+		if (intmask & HwSDINT_STATUS_TDONE) {
+			if (host->cmd) {
+				/*
+				 * Data managed to finish before the
+				 * command completed. Make sure we do
+				 * things in the proper order.
+				 */
+				host->data_early = 1;
+			} else {
+				tcc_mmc_finish_data(host);
+			}
+		}
+	}
+}
+
+static irqreturn_t tcc_mmc_interrupt_handler(int irq, void *dev_id)
+{
+	unsigned int IntStatus;
+	irqreturn_t result;    
+	int cardint = 0;    
+	struct tcc_mmc_host *host = (struct tcc_mmc_host *) dev_id;
+
+	spin_lock(&host->lock);
+
+	IntStatus = tcc_readl(host->iobase+TCCSDHC_INT_STATUS);
+
+	if (IntStatus == 0) {
+		result=IRQ_NONE;
+	}
+
+	if (IntStatus & HwSDINT_CMD_MASK) {
+		tcc_writel(IntStatus & HwSDINT_CMD_MASK,host->iobase+TCCSDHC_INT_STATUS);		
+		tcc_mmc_cmd_irq(host, IntStatus & HwSDINT_CMD_MASK);
+	}
+
+	if (IntStatus & HwSDINT_DATA_MASK) {
+		tcc_writel(IntStatus & HwSDINT_DATA_MASK,host->iobase+TCCSDHC_INT_STATUS);		
+		tcc_mmc_data_irq(host, IntStatus & HwSDINT_DATA_MASK);
+	}
+
+	IntStatus &= ~(HwSDINT_CMD_MASK |HwSDINT_DATA_MASK);
+	IntStatus &= ~HwSDINT_STATUS_ERR;
+
+	if(IntStatus & HwSDINT_STATUS_CDINT) {
+		cardint =1;
+	}
+
+	IntStatus &= ~ HwSDINT_STATUS_CDINT;
+
+	if (IntStatus) {
+		SD_DEBUG(KERN_ERR "%s: Unexpected interrupt 0x%08x.\n",   mmc_hostname(host->mmc), IntStatus);    
+		tcc_writel(IntStatus, host->iobase+TCCSDHC_INT_STATUS);		
+	}
+
+	result=IRQ_HANDLED;    
+
+	mmiowb();
+
+//out:
+	spin_unlock(&host->lock);    
+
+	if (cardint) {
+		mmc_signal_sdio_irq(host->mmc);
+	}        
+
+	return result;
+}
+
+static void tcc_enable_sdio_irq(struct mmc_host *mmc, int enable)
+{
+	if (enable) {
+		tcc_sdio_enable_card_int(mmc);
+	} else {
+		tcc_sdio_disable_card_int(mmc);
+	}
+}
+
+static struct mmc_host_ops tcc_mmc_ops = {
+	.request		 = tcc_mmc_request,
+	.set_ios		 = tcc_mmc_set_ios,
+	.get_ro			 = tcc_mmc_get_ro,
+	.enable_sdio_irq = tcc_enable_sdio_irq,	
+};
+
+/*
+ * Tasklets
+ */
+static void tcc_mmc_tasklet_finish(unsigned long param)
+{
+	struct tcc_mmc_host *host;
+	unsigned long flags;
+	struct mmc_request *mrq;
+
+	host = (struct tcc_mmc_host *)param;
+
+	spin_lock_irqsave(&host->lock, flags);
+
+	del_timer(&host->timer);
+
+	mrq = host->mrq;
+
+	/*
+	 * The controller needs a reset of internal state machines
+	 * upon error conditions.
+	 */
+	if (mrq->cmd->error ||
+			(mrq->data && (mrq->data->error ||
+						   (mrq->data->stop && mrq->data->stop->error)))) {
+
+		/* Spec says we should do both at the same time, but Ricoh
+		   controllers do not like that. */
+		tcc_sw_reset(host, HwSD_SRESET_RSTCMD);
+		tcc_sw_reset(host, HwSD_SRESET_RSTDAT);                        
+	}
+
+	host->mrq = NULL;
+	host->cmd = NULL;
+	host->data = NULL;
+
+	mmiowb();
+
+	spin_unlock_irqrestore(&host->lock, flags);
+	mmc_request_done(host->mmc, mrq);
+}
+
+static void tcc_mmc_timeout_timer(unsigned long data)
+{
+	struct tcc_mmc_host *host;
+	unsigned long flags;
+
+	host = (struct tcc_mmc_host*)data;
+
+	spin_lock_irqsave(&host->lock, flags);
+
+	if (host->mrq) {
+		printk(KERN_ERR "%s: Timeout waiting for hardware "
+				"interrupt.\n", mmc_hostname(host->mmc));
+
+		if (host->data) {
+			host->data->error = -ETIMEDOUT;
+			tcc_mmc_finish_data(host);
+		} else {
+			if (host->cmd)
+				host->cmd->error = -ETIMEDOUT;
+			else
+				host->mrq->cmd->error = -ETIMEDOUT;
+
+			tasklet_schedule(&host->finish_tasklet);
+		}
+	}    
+	mmiowb();
+	spin_unlock_irqrestore(&host->lock, flags);
+}
+
+static void init_mmc_host(struct tcc_mmc_host *host)
+{
+	if (host->id == 0) {
+		/* power */
+		tcc_pca953x_setup(PCA9539_U3_SLAVE_ADDR, SD0_ON, OUTPUT, ON, SET_DIRECTION|SET_VALUE);
+
+		/* iobus */
+		//tca_ckc_set_iobus_swreset(RB_SDMMCCONTROLLER, OFF);
+		tca_ckc_set_iobus_swreset(RB_SDMMCCONTROLLER, ON);
+		tca_ckc_setiobus(RB_SDMMCCONTROLLER, ENABLE);
+
+		/* clock */
+		tca_ckc_setperi(PERI_SDMMC0, ENABLE, 480000, PCDIRECTPLL3);
+		host->peri_clk = tca_ckc_getperi(PERI_SDMMC0) * 100;
+		SD_DEBUG("tcc-sdhc%d: clock %lu\n", host->id, host->peri_clk);	
+
+		/* slot0 port2 */
+		BITCSET(pSDCHCTRL->SDPORTCTRL, HwSD_PORTCTRL_SLOT0_MASK, HwSD_PORTCTRL_SLOT0(2));
+		pSDMMC_SLOT0->STSEN = 0x03ff00ff;
+		pSDMMC_SLOT0->INTEN = 0x03ff01ff;
+
+		BITCSET(pSDMMC_SLOT0->TIME, 0x00FF, 0x0E);
+
+		BITCSET(HwGPIOE->GPFN1, Hw32-Hw16, Hw29|Hw25|Hw21|Hw17);	/* GPIOE[15:12] - SD0_D[0:3] */
+		BITCSET(HwGPIOE->GPFN2, Hw24-Hw16, Hw21|Hw17);				/* GPIOE[21:20] - SD0_CMD, SD0_CLK */
+		BITCSET(HwGPIOE->GPCD0, 0xFF000000, 0x55000000);			/* driver strength */
+		BITCSET(HwGPIOE->GPCD1, 0x00000F00, 0x00000500);
+
+		BITCLR(HwGPIOA->GPFN0, Hw28-Hw24);							/* GPIOA[6] - SD_CD (Card Detect) */
+		BITCLR(HwGPIOA->GPEN, Hw6);								/* input mode */
+		HwGPIOA->GPDAT &= ~Hw6;
+
+		pSDMMC_SLOT0->CONTL &= ~(HwSD_POWER_SD4 | HwSD_POWER_SD8);
+		pSDMMC_SLOT0->CONTL |= HwSD_POWER_POW;
+
+	} else if (host->id == 1) {
+		/* power */
+		tcc_pca953x_setup(PCA9539_U3_SLAVE_ADDR, SD1_ON, OUTPUT, ON, SET_DIRECTION|SET_VALUE);
+
+		/* iobus */
+		//tca_ckc_set_iobus_swreset(RB_SDMMCCONTROLLER, OFF);
+		tca_ckc_set_iobus_swreset(RB_SDMMCCONTROLLER, ON);
+		tca_ckc_setiobus(RB_SDMMCCONTROLLER, ENABLE);
+
+		/* clock */
+		tca_ckc_setperi(PERI_SDMMC1, ENABLE, 480000, PCDIRECTPLL3);
+		host->peri_clk = tca_ckc_getperi(PERI_SDMMC1) * 100;
+		SD_DEBUG("tcc-sdhc%d: clock %lu\n", host->id, host->peri_clk);	
+
+		/* slot2 port5 */
+		BITCSET(pSDCHCTRL->SDPORTCTRL, HwSD_PORTCTRL_SLOT2_MASK, HwSD_PORTCTRL_SLOT2(5));
+		pSDMMC_SLOT1->STSEN = 0x03ff00ff;
+		pSDMMC_SLOT1->INTEN = 0x03ff01ff;
+
+		BITCSET(pSDMMC_SLOT1->TIME, 0x00FF, 0x0E);
+
+		BITCSET(HwGPIOB->GPFN0, Hw16-Hw0, HwPORTCFG_GPFN3(2)|HwPORTCFG_GPFN2(2)
+										|HwPORTCFG_GPFN1(2)|HwPORTCFG_GPFN0(2));	/* GPIOB[3:0] - SD1_D[0:3] */
+		BITCSET(HwGPIOB->GPFN1, Hw24-Hw16, HwPORTCFG_GPFN5(2)|HwPORTCFG_GPFN4(2));	/* GPIOB[14:12] - SD1_CMD, SD1_CLK, SD1_WP */
+		BITCSET(HwGPIOB->GPCD0, 0x0F0000FF, 0x3F0000FF);							/* driver strength */
+
+		BITCLR(HwGPIOA->GPFN1, Hw12-Hw8);											/* GPIOA[10] - SD_CD (Card Detect) */
+		BITCLR(HwGPIOA->GPEN, Hw10);												/* input mode */
+		HwGPIOA->GPDAT &= ~Hw10;
+
+		pSDMMC_SLOT1->CONTL &= ~(HwSD_POWER_SD4 | HwSD_POWER_SD8);
+		pSDMMC_SLOT1->CONTL |= HwSD_POWER_POW;
+	}
+}
+
+static void deinit_mmc_host(struct tcc_mmc_host *host)
+{
+	if (host->id == 0) {
+		/* clock */
+		tca_ckc_setperi(PERI_SDMMC0, DISABLE, 480000, PCDIRECTPLL3);
+
+		/* iobus */
+		tca_ckc_set_iobus_swreset(RB_SDMMCCONTROLLER, OFF);
+		tca_ckc_setiobus(RB_SDMMCCONTROLLER, DISABLE);
+
+		/* power */
+		tcc_pca953x_setup(PCA9539_U3_SLAVE_ADDR, SD0_ON, OUTPUT, LOW, SET_DIRECTION|SET_VALUE);
+
+		/* slot0 port2 - GPIO mode */
+		BITCLR(HwGPIOE->GPFN1, Hw32-Hw16);	/* GPIOE[15:12] */
+		BITCLR(HwGPIOE->GPFN2, Hw24-Hw16);	/* GPIOE[21:20] */
+		BITCLR(HwGPIOA->GPFN0, Hw28-Hw24);	/* GPIOA[6]     */
+		/* output mode */
+		BITSET(HwGPIOE->GPEN, Hw21|Hw20|Hw15|Hw14|Hw13|Hw12);
+		BITSET(HwGPIOA->GPEN, Hw6);
+
+		/* SD Bus Power */
+		BITCLR(pSDMMC_SLOT0->CONTL, HwSD_POWER_POW);
+
+	} else if (host->id == 1) {
+		//TODO:
+	}
+}
+
+/*
+ * SDHC Power on/off control
+ */
+static int sdhc_pwr_ctl(void *h_private, int cmd, void *p_out)
+{
+	struct platform_device *pdev = (struct platform_device *)h_private;
+	struct tcc_mmc_host *host = platform_get_drvdata(pdev);
+
+	switch (cmd) {
+	case PWR_CMD_OFF:
+		//printk("PWR_CMD_OFF command ==> [%d]\n", cmd);
+		if (pwrinfo.status == PWR_STATUS_OFF) {
+			return 0;
+		}
+		pwrinfo.status = PWR_STATUS_OFF;
+		if (host) {
+			if (mmc_suspend_host(host->mmc, PMSG_SUSPEND) == 0) {
+				host->suspended = 1;
+			} else {
+				return -EIO;
+			}
+		}
+		break;
+	case PWR_CMD_ON:
+		//printk("PWR_CMD_ON command ==> [%d]\n", cmd);
+		if (pwrinfo.status == PWR_STATUS_ON) {
+			return 0;
+		}
+		pwrinfo.status = PWR_STATUS_ON;
+		if (host) {
+			if (mmc_resume_host(host->mmc) == 0) {
+				host->suspended = 0;
+			} else {
+				return -EIO;
+			}
+		}
+		break;
+	case PWR_CMD_GETSTATUS:
+		//printk("PWR_CMD_GETSTATUS command ==> [%d], status:[%d]\n", cmd, pwrinfo.status);
+		memcpy(p_out, &pwrinfo, sizeof(stpwrinfo));
+		break;
+	default:
+		//printk("unknown pwr command !!! ==> [%d]\n", cmd);
+		return -EINVAL;
+		break;
+	}
+
+    return 0;
+}
+
+static int __init tcc_mmc_probe(struct platform_device *pdev)
+{
+	struct mmc_host *mmc;
+	struct tcc_mmc_host *host = NULL;
+	volatile PPIC pPIC = (volatile PPIC)tcc_p2v(HwPIC_BASE);
+	int ret = 0;
+
+	mmc = mmc_alloc_host(sizeof(struct tcc_mmc_host), &pdev->dev);
+	if (!mmc)
+		return -ENOMEM;
+
+	host = mmc_priv(mmc);
+	host->mmc = mmc;
+	host->id = pdev->id;
+
+	init_mmc_host(host);
+
+	host->res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	host->irq = platform_get_irq(pdev, 0);
+	host->iobase = host->res->start;
+	host->flags = TCC_MMC_USE_DMA;
+
+	mmc->caps |= MMC_CAP_SDIO_IRQ|MMC_CAP_4_BIT_DATA;
+	mmc->ops = &tcc_mmc_ops;
+	mmc->f_min = 100000;
+	mmc->f_max = 48000000;
+	mmc->ocr_avail = MMC_VDD_32_33|MMC_VDD_33_34;
+
+	/*
+	 * Maximum number of segments. Hardware cannot do scatter lists.
+	 */
+	if (host->flags & TCC_MMC_USE_DMA) {
+		mmc->max_hw_segs = 1;
+	} else {
+		mmc->max_hw_segs = 16;
+	}
+	mmc->max_phys_segs = 16;
+
+	/*
+	 * Maximum number of sectors in one transfer. Limited by DMA boundary
+	 * size (512KiB).
+	 */
+	mmc->max_req_size = 524288;
+
+	/*
+	 * Maximum segment size. Could be one segment with the maximum number
+	 * of bytes.
+	 */
+	mmc->max_seg_size = mmc->max_req_size;
+
+	/*
+	 * Maximum block size. This varies from controller to controller and
+	 * is specified in the capabilities register.
+	 */
+	//	mmc->max_blk_size = (caps & SDHCI_MAX_BLOCK_MASK) >> SDHCI_MAX_BLOCK_SHIFT;
+	//	if (mmc->max_blk_size >= 3) {
+	//		printk(KERN_WARNING "%s: Invalid maximum block size, assuming 512\n",
+	//			host->slot_descr);
+	mmc->max_blk_size = 512;
+	//	} else
+	//		mmc->max_blk_size = 512 << mmc->max_blk_size;
+
+	/*
+	 * Maximum block count.
+	 */
+	mmc->max_blk_count = 65535;
+
+	host->dev = &pdev->dev;
+	platform_set_drvdata(pdev, host);
+
+	/* configuration the SD card insertion detection */
+	init_timer(&host->detect_timer);
+	host->detect_timer.function = tcc_mmc_poll_event;
+	host->detect_timer.data = (unsigned long) host;
+	host->detect_timer.expires = jiffies + DETECT_TIMEOUT;
+
+	mmc_add_host(mmc);
+
+	spin_lock_init(&host->lock);
+
+	add_timer(&host->detect_timer);
+
+	/*
+	 * Init tasklets.
+	 */
+	tasklet_init(&host->finish_tasklet,tcc_mmc_tasklet_finish, (unsigned long)host);
+
+	setup_timer(&host->timer, tcc_mmc_timeout_timer, (unsigned long)host);
+
+	pPIC->SEL1		|= HwINT1_SD0 << host->id;
+	pPIC->INTMSK1	|= HwINT1_SD0 << host->id;
+	pPIC->MODE1 	|= HwINT1_SD0 << host->id;	// Level trigger
+
+	snprintf(host->slot_desc, 16, "tcc-sdhc%d", host->id);
+	ret = request_irq(host->irq, tcc_mmc_interrupt_handler, IRQF_DISABLED, host->slot_desc, host);
+	if (ret)
+		goto error;
+
+	/* initialize the card-insert status */
+	if (tcc_mmc_card_inserted(host)) {
+		host->card_inserted = 1;
+	} else {
+		host->card_inserted = 0;
+	}
+
+	/* add power control functions */
+	insert_pwm_node(DEVICE_SDHC, sdhc_pwr_ctl, pdev);
+	
+	printk("%s%d: init\n", DRIVER_NAME, host->id);
+	return ret;
+
+error:
+	printk("%s%d: failed\n", DRIVER_NAME, host->id);
+	return ret;   
+}
+
+static int tcc_mmc_remove(struct platform_device *pdev)
+{
+	struct mmc_host *mmc = platform_get_drvdata(pdev);
+
+	platform_set_drvdata(pdev, NULL);
+
+	if (mmc) {
+		struct tcc_mmc_host *host = mmc_priv(mmc);
+
+		mmc_remove_host(mmc);
+		del_timer(&host->timer);
+		del_timer_sync(&host->timer);        
+		mmc_free_host(mmc);
+
+		tasklet_kill(&host->finish_tasklet);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int tcc_mmc_suspend(struct platform_device *pdev, pm_message_t mesg)
+{
+	int ret = 0;
+
+	struct tcc_mmc_host *host = platform_get_drvdata(pdev);
+
+	if (host && host->suspended)
+		return 0;
+
+	if (host) {
+		ret = mmc_suspend_host(host->mmc, mesg);
+		if (ret == 0)
+			host->suspended = 1;
+	}
+
+	return ret;
+}
+
+static int tcc_mmc_resume(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	struct tcc_mmc_host *host = platform_get_drvdata(pdev);
+
+	if (host && !host->suspended)
+		return 0;
+
+	if (host) {
+		ret = mmc_resume_host(host->mmc);
+		if (ret == 0)
+			host->suspended = 0;
+	}
+
+	return ret;
+}
+#else
+#define tcc_mmc_suspend	NULL
+#define tcc_mmc_resume	NULL
+#endif
+
+
+#if defined(CONFIG_MMC_TCC_SDHC_CORE0)
+static struct platform_driver tcc_mmc_core0_driver = {
+	.probe		= tcc_mmc_probe,
+	.remove		= tcc_mmc_remove,
+	.suspend	= tcc_mmc_suspend,
+	.resume		= tcc_mmc_resume,
+	.driver		= {
+		.name	= DRIVER_NAME_CORE0,
+	},
+};
+#endif
+#if defined(CONFIG_MMC_TCC_SDHC_CORE1)
+static struct platform_driver tcc_mmc_core1_driver = {
+	.probe		= tcc_mmc_probe,
+	.remove 	= tcc_mmc_remove,
+	.suspend	= tcc_mmc_suspend,
+	.resume 	= tcc_mmc_resume,
+	.driver 	= {
+		.name	= DRIVER_NAME_CORE1,
+	},
+};
+#endif
+
+static int __init tcc_mmc_init(void)
+{
+	int ret = -1;
+#if defined(CONFIG_MMC_TCC_SDHC_CORE0)
+	ret = platform_driver_register(&tcc_mmc_core0_driver);
+#endif
+#if defined(CONFIG_MMC_TCC_SDHC_CORE1)
+	ret = platform_driver_register(&tcc_mmc_core1_driver);	
+#endif
+	return ret;
+}
+
+static void __exit tcc_mmc_exit(void)
+{
+#if defined(CONFIG_MMC_TCC_SDHC_CORE0)
+	platform_driver_unregister(&tcc_mmc_core0_driver);
+#endif
+#if defined(CONFIG_MMC_TCC_SDHC_CORE1)
+	platform_driver_unregister(&tcc_mmc_core1_driver);
+#endif
+
+	/* remove power control functions */
+	remove_pwm_node(DEVICE_OTG);
+}
+
+module_init(tcc_mmc_init);
+module_exit(tcc_mmc_exit);
+
+MODULE_DESCRIPTION("Telechips SD/MMC Card driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS(DRIVER_NAME);
+MODULE_AUTHOR("Telechips Inc. linux@telechips.com");
Index: linux-2.6.29/drivers/mmc/host/tcc_sdhc.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/mmc/host/tcc_sdhc.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,224 @@
+#ifndef __TCC_SDHC_H__
+#define __TCC_SDHC_H__
+
+
+/*******************************************************************************
+*	 5. SD/SDIO/MMC/CE-ATA Host Controller Register Define   (Base Addr = 0xF0590000)
+********************************************************************************/
+//Core 0 Slot 0
+#define SDCORE0SLOT0_BASE         0xF05A0000
+//Core 0 Slot 1
+#define SDCORE0SLOT1_BASE         0xF05A0100
+//Core 1 Slot 2
+#define SDCORE1SLOT2_BASE         0xF05A0200
+//Core 1 Slot 3
+#define SDCORE1SLOT3_BASE         0xF05A0300
+// Channel Control Register
+#define SDCHCTRL_BASE             0xF05A0800 // R/W 0x0000 SD/MMC port control register
+
+#define HwSD_COM_TRANS_ABORT	Hw23+Hw22
+#define HwSD_COM_TRANS_DATSEL	Hw21		// data present select
+#define HwSD_COM_TRANS_CICHK	Hw20		// command index check enable
+#define HwSD_COM_TRANS_CRCHK	Hw19		// command CRC check enable
+#define HwSD_COM_TRANS_SPI		Hw7 		// SPI mode
+#define HwSD_COM_TRANS_ATACMD	Hw6 		// cmd completion enable for CE-ATA
+#define HwSD_COM_TRANS_MS		Hw5 		// multi/single block select
+#define HwSD_COM_TRANS_DIR		Hw4 		// data transfer direction select
+#define HwSD_COM_TRANS_ACMD12	Hw2 		// auto CMD12 enable
+#define HwSD_COM_TRANS_BCNTEN	Hw1 		// block count enable
+#define HwSD_COM_TRANS_DMAEN	Hw0 		// DMA Enable
+
+
+#define HwSDCLKSEL_DIV_256		0x80
+#define HwSDCLKSEL_DIV_128		0x40
+#define HwSDCLKSEL_DIV_64		0x20
+#define HwSDCLKSEL_DIV_32		0x10
+#define HwSDCLKSEL_DIV_16		0x08
+#define HwSDCLKSEL_DIV_8		0x04
+#define HwSDCLKSEL_DIV_4		0x02
+#define HwSDCLKSEL_DIV_2		0x01
+#define HwSDCLKSEL_DIV_0		0x00
+#define HwSDCLKSEL_SCK_EN		Hw2
+#define HwSDCLKSEL_INCLK_STABLE Hw1
+#define HwSDCLKSEL_INCLK_EN 	Hw0
+
+#define HwSD_POWER_POW			Hw8 		// SD bus power
+#define HwSD_POWER_SD8			Hw5 		// SD 8-bit mode
+#define HwSD_POWER_HS			Hw2 		// high speed enable
+#define HwSD_POWER_SD4			Hw1 		// data transfer width
+#define HwSD_POWER_VOL33		Hw11+Hw10+Hw9
+
+
+#define HwSD_SRESET_RSTALL		Hw0 	// software reset for All
+#define HwSD_SRESET_RSTCMD		Hw1 	// software reset for CMD line
+#define HwSD_SRESET_RSTDAT		Hw2 	// software reset for DAT line
+
+
+// Port Control
+#define HwSD_PORTCTRL_CD(X) 		(Hw30 << (X))								// Card Detection for SLOT X. (X = 0 or 1)
+#define HwSD_PORTCTRL_WP(X) 		(Hw27 << (X))								// Write Protect for SLOT X. (X = 0 or 1)
+#define HwSD_PORTCTRL_SLOT3(X)		((X) * Hw12)								// Port Select for SLOT 3 (X = 0 ~ 7)
+#define HwSD_PORTCTRL_SLOT3_MASK	HwSD_PORTCTRL_SLOT3(15)
+#define HwSD_PORTCTRL_SLOT2(X)		((X) * Hw8) 								// Port Select for SLOT 2 (X = 0 ~ 7)
+#define HwSD_PORTCTRL_SLOT2_MASK	HwSD_PORTCTRL_SLOT2(15)
+#define HwSD_PORTCTRL_SLOT1(X)		((X) * Hw4) 								// Port Select for SLOT 1 (X = 0 ~ 7)
+#define HwSD_PORTCTRL_SLOT1_MASK	HwSD_PORTCTRL_SLOT1(15)
+#define HwSD_PORTCTRL_SLOT0(X)		((X) * Hw0) 								// Port Select for SLOT 0 (X = 0 ~ 7)
+#define HwSD_PORTCTRL_SLOT0_MASK	HwSD_PORTCTRL_SLOT0(15)
+
+#define HwSD_STATE_SDWP 		Hw19
+#define HwSD_STATE_NODAT		Hw1 		// data inhibit
+#define HwSD_STATE_NOCMD		Hw0 		// command inhibit
+
+#define HwSDINT_STATUS_DATEND	Hw22		// data end bit error
+#define HwSDINT_STATUS_DATCRC	Hw21		// data crc error
+#define HwSDINT_STATUS_DATTIME	Hw20		// data timeout error
+#define HwSDINT_STATUS_CINDEX	Hw19		// command index error
+#define HwSDINT_STATUS_CMDEND	Hw18		// command command end bit error
+#define HwSDINT_STATUS_CMDCRC	Hw17		// command crc error
+#define HwSDINT_STATUS_CMDTIME	Hw16		// command timeout error
+#define HwSDINT_STATUS_ERR		Hw15		// error interrupt
+#define HwSDINT_STATUS_CDINT	Hw8 		// card interrupt
+#define HwSDINT_STATUS_CDOUT	Hw7 		// card removal
+#define HwSDINT_STATUS_CDIN 	Hw6 		// card insertion
+#define HwSDINT_STATUS_RDRDY	Hw5 		// buffer read ready
+#define HwSDINT_STATUS_WRRDY	Hw4 		// buffer write ready
+#define HwSDINT_STATUS_DMA		Hw3 		// DMA interrupt
+#define HwSDINT_STATUS_BLKGAP	Hw2 		// block gap event
+#define HwSDINT_STATUS_TDONE	Hw1 		// transfer complete
+#define HwSDINT_STATUS_CDONE	Hw0 		// command complete
+
+#define HwSDINT_EN_ADMA 		Hw25		// ADMA error signal enable
+#define HwSDINT_EN_ACMD12		Hw24		// auto CMD12 error signal enable
+#define HwSDINT_EN_CLIMIT		Hw23		// current limit error signal enable
+#define HwSDINT_EN_DATEND		Hw22		// data end bit error signal enable
+#define HwSDINT_EN_DATCRC		Hw21		// data crc error signal enable
+#define HwSDINT_EN_DATTIME		Hw20		// data timeout error signal enable
+#define HwSDINT_EN_CINDEX		Hw19		// command index error signal enable
+#define HwSDINT_EN_CMDEND		Hw18		// command end bit error signal enable
+#define HwSDINT_EN_CMDCRC		Hw17		// command crc error signal enable
+#define HwSDINT_EN_CMDTIME		Hw16		// command timeout error signal enable
+#define HwSDINT_EN_CDINT		Hw8 		// card interrupt signal enable
+#define HwSDINT_EN_CDOUT		Hw7 		// card removal signal enable
+#define HwSDINT_EN_CDIN 		Hw6 		// card insertion signal enable
+#define HwSDINT_EN_RDRDY		Hw5 		// buffer read ready signal enable
+#define HwSDINT_EN_WRRDY		Hw4 		// buffer write ready signal enable
+#define HwSDINT_EN_DMA			Hw3 		// DMA interrupt signal enable
+#define HwSDINT_EN_BLKGAP		Hw2 		// block gap event signal enable
+#define HwSDINT_EN_TDONE		Hw1 		// transfer complete signal enable
+#define HwSDINT_EN_CDONE		Hw0 		// command complete signal enable
+
+
+#define  HwSDINT_NORMAL_MASK	0x00007FFF
+#define  HwSDINT_ERROR_MASK 0xFFFF8000
+
+#define  HwSDINT_CMD_MASK	(HwSDINT_EN_CDONE | HwSDINT_EN_CMDTIME | \
+		HwSDINT_EN_CMDCRC | HwSDINT_EN_CMDEND | HwSDINT_EN_CINDEX)
+		
+#define  HwSDINT_DATA_MASK	(HwSDINT_EN_TDONE | HwSDINT_EN_DMA | \
+		HwSDINT_EN_RDRDY | HwSDINT_EN_WRRDY | \
+		HwSDINT_EN_DATTIME | HwSDINT_EN_DATCRC | \
+		HwSDINT_EN_DATEND)
+
+
+typedef struct _SDHOST_T{
+	volatile unsigned int	 	SDMA;                       // 0x000 R/W 0x0000 SDMA System Address
+//	volatile unsigned short     NOTDEFINE0;                 // 0x002
+	volatile unsigned short 	BSIZE;                      // 0x004 R/W 0x0000 Block Size
+	volatile unsigned short 	BCNT;                       // 0x006 R/W 0x0000 Block Count
+	volatile unsigned int 		ARG;                        // 0x008 R/W 0x0000 Argument
+//	volatile unsigned short     NOTDEFINE1;                 // 0x00A
+
+/////	
+//	volatile unsigned short 	TMODE;                      // 0x00C R/W 0x0000 Transfer Mode
+//	volatile unsigned short 	CMD;                        // 0x00E R/W 0x0000 Command
+	volatile unsigned int		CTMODE;						// 0x00C R/W Command and Transfer Mode
+/////	
+
+////	
+//	volatile unsigned short 	RESP0;                      // 0x010 R 0x0000 Response0
+//	volatile unsigned short 	RESP1;                      // 0x012 R 0x0000 Response1
+	volatile unsigned int	 	RESP1_0;					// 0x010  R  	Response0,1	
+///
+
+/////
+//	volatile unsigned short 	RESP2;                      // 0x014 R 0x0000 Response2
+//	volatile unsigned short 	RESP3;                      // 0x016 R 0x0000 Response3
+	volatile unsigned int		RESP3_2;					// 0x014  R 	Response2,3
+/////
+
+//////	
+//	volatile unsigned short 	RESP4;                      // 0x018 R 0x0000 Response4
+//	volatile unsigned short 	RESP5;                      // 0x01A R 0x0000 Response5
+	volatile unsigned int		RESP5_4;					// 0x018  R 	Response4,5
+/////
+
+//////
+//	volatile unsigned short 	RESP6;                      // 0x01C R 0x0000 Response6
+//	volatile unsigned short 	RESP7;                      // 0x01E R 0x0000 Response7
+	volatile unsigned int		RESP7_6;					// 0x01C  R 	Response6,7
+//////
+	
+	volatile unsigned short 	DATAL;                      // 0x020 R/W - Buffer Data Port(Low)
+	volatile unsigned short 	DATAH;                      // 0x022 R/W - Buffer Data Port(High)
+////
+//	volatile unsigned short 	STATEL;                     // 0x024 R 0x0000 Present State(Low)
+//	volatile unsigned short 	STATEH;                     // 0x026 R 0x0000 Present State(High)
+	volatile unsigned int 		STATE; 						// 0x024  R  	Present State	
+////
+
+	volatile unsigned short 	CONTL;                      // 0x028 R/W 0x0000 Power Control / Host Control
+	volatile unsigned short 	CONTH;                      // 0x02A R/W 0x0000 Wakeup Control / Block Gap Control
+	volatile unsigned short 	CLK;                        // 0x02C R/W 0x0000 Clock Control
+//////	
+	volatile unsigned short 	TIME;                       // 0x02E R/W 0x0000 Software Reset / Timeout Control
+//	volatile unsigned char	 	TIME;						// 0x02E  R/W	Software Reset / Timeout Control
+//	volatile unsigned char	 	RESET;						// 0x02F  R/W	Software Reset / Timeout Control
+//////	
+
+/////////////
+///	volatile unsigned short 	STSL;                       // 0x030 R 0x0000 Normal Interrupt Status(Low)
+///	volatile unsigned short 	STSH;                       // 0x032 R 0x0000 Normal Interrupt Status(High)
+	volatile unsigned int		STS;						// 0x030  R 	Normal Interrupt Status
+/////////////
+	
+//////	
+//	volatile unsigned short 	STSENL;                     // 0x034 R/W 0x0000 Normal Interrupt Status Enable(Low)
+//	volatile unsigned short 	STSENH;                     // 0x036 R/W 0x0000 Normal Interrupt Status Enable(High)
+	volatile unsigned int	 	STSEN; 						// 0x034  R/W	Normal Interrupt Status Enable	
+/////
+/////
+//	volatile unsigned short 	INTENL;                     // 0x038 R/W 0x0000 Normal Interrupt Signal Enable(Low)
+//	volatile unsigned short 	INTENH;                     // 0x03A R/W 0x0000 Normal Interrupt Signal Enable(High)
+	volatile unsigned int	 	INTEN; 						// 0x038  R/W	Normal Interrupt Signal Enable	
+/////	
+	volatile unsigned short 	CMD12ERR;                   // 0x03C R 0x0000 Auto CMD12 Error Status
+	volatile unsigned short     NOTDEFINE2;                 // 0x03E
+	volatile unsigned short 	CAPL;                       // 0x040 R 0x30B0 Capabilities(Low)
+	volatile unsigned short 	CAPH;                       // 0x042 R 0x69EF Capabilities(High)
+	volatile unsigned short     NOTDEFINE3[2];              // 0x044, 0x046
+	volatile unsigned short 	CURL;                       // 0x048 R 0x0001 Maximum Current Capabilities(Low)
+	volatile unsigned short 	CURH;                       // 0x04A R 0x0000 Maximum Current Capabilities(High)
+	volatile unsigned short     NOTDEFINE4[2];              // 0x04C, 0x04E
+	volatile unsigned short 	FORCEL;                     // 0x050 W 0x0000 Force event for AutoCmd12 Error
+	volatile unsigned short 	FORCEH;                     // 0x052 W 0x0000 Force event for Error Interrupt Status
+	volatile unsigned short 	AUDIO_DMAERR;               // 0x054 R/W 0x0000 AUDIO DMA Error Status
+	volatile unsigned short     NOTDEFINE5;                 // 0x056
+	volatile unsigned short 	ADDR0;                      // 0x058 R/W 0x0000 AUDIO DMA Address[15:0]
+	volatile unsigned short 	ADDR1;                      // 0x05A R/W 0x0000 AUDIO DMA Address[31:16]
+	volatile unsigned short 	ADDR2;                      // 0x05C R/W 0x0000 AUDIO DMA Address[47:32]
+	volatile unsigned short 	ADDR3;                      // 0x05E R/W 0x0000 AUDIO DMA Address[63:48]
+	volatile unsigned short     NOTDEFINE6[78];             // 0x060~0x0FA
+	volatile unsigned short 	SLOT;                       // 0x0FC R 0x0000 Slot Interrupt Status
+	volatile unsigned short 	VERSION;                    // 0x0FE R 0x0002 Host Controller Version    
+}SDHOST_T, *PSDHOST_T;
+
+typedef struct _SDCHCTRL_T{
+	volatile unsigned int	SDPORTCTRL;                          //  0x00 R/W 0x0000 SD/MMC port control register
+	volatile unsigned int	SDPORTDLY0;                          //  0x04 R/W 0x0000 SD/MMC output delay control register
+	volatile unsigned int	SDPORTDLY1;                          //  0x08 R/W 0x0000 SD/MMC output delay control register
+	volatile unsigned int	SDPORTDLY2;                          //  0x0C R/W 0x0000 SD/MMC output delay control register
+	volatile unsigned int	SDPORTDLY3;                          //  0x10 R/W 0x0000 SD/MMC output delay control register    
+}SDCHCTRL_T, *PSDCHCTRL_T;
+
+#endif /*__TCC_SDHC_H__*/
Index: linux-2.6.29/drivers/rtc/Kconfig
===================================================================
--- linux-2.6.29.orig/drivers/rtc/Kconfig	2010-04-07 12:29:33.000000000 -0400
+++ linux-2.6.29/drivers/rtc/Kconfig	2010-04-07 12:29:36.000000000 -0400
@@ -517,6 +517,15 @@
 
 comment "on-CPU RTC drivers"
 
+config RTC_DRV_TCC
+    tristate "Telechips RTC"
+    depends on ARCH_TCC
+    help
+        RTC (Realtime Clock) driver for the clock inbuilt into the
+        Telechips TCC SoCs.
+        This driver can also be build as a module. If so, the module
+        will be called rtc-tcc.
+
 config RTC_DRV_OMAP
 	tristate "TI OMAP1"
 	depends on ARCH_OMAP15XX || ARCH_OMAP16XX || ARCH_OMAP730
Index: linux-2.6.29/drivers/rtc/Makefile
===================================================================
--- linux-2.6.29.orig/drivers/rtc/Makefile	2010-04-07 12:29:33.000000000 -0400
+++ linux-2.6.29/drivers/rtc/Makefile	2010-04-07 12:29:36.000000000 -0400
@@ -17,6 +17,11 @@
 
 # Keep the list ordered.
 
+ifeq ($(CONFIG_ARCH_TCC),y)
+$(shell ln -fsn $(CONFIG_TCC_STRING) $(srctree)/drivers/rtc/tcc) 
+endif
+obj-$(CONFIG_RTC_DRV_TCC)+= rtc-tcc.o  tcc/tca_rtc.o tcc/tca_alarm.o
+
 obj-$(CONFIG_RTC_DRV_AT32AP700X)+= rtc-at32ap700x.o
 obj-$(CONFIG_RTC_DRV_AT91RM9200)+= rtc-at91rm9200.o
 obj-$(CONFIG_RTC_DRV_AT91SAM9)	+= rtc-at91sam9.o
Index: linux-2.6.29/drivers/rtc/rtc-tcc.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/rtc/rtc-tcc.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,476 @@
+/*
+ * linux/drivers/serial/tcc-rtc.c
+ *
+ * Author: <linux@telechips.com>
+ * Created: Feb 10, 2009
+ * Description: RTC driver for Telechips TCC Series
+ *
+ * Copyright (C) 2009 Telechips 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see the file COPYING, or write
+ * to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/rtc.h>
+#include <linux/bcd.h>
+#include <linux/clk.h>
+#include <linux/log2.h>
+
+#include <mach/hardware.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/delay.h>
+#include <asm/mach/time.h>
+
+#include <bsp.h>
+#include "tcc/tca_alarm.h"
+
+
+//#define pr_debug printk
+#define DRV_NAME "tcc-rtc"
+
+#define RTCCON      0x00
+#define INTCON      0x04
+#define RTCALM      0x08
+#define ALMSEC      0x0C
+#define ALMMIN      0x10
+#define ALMHOUR     0x14
+#define ALMDATE     0x18
+#define ALMDAY      0x1C
+#define ALMMON      0x20
+#define ALMYEAR     0x24
+#define BCDSEC      0x28
+#define BCDMIN      0x2C
+#define BCDHOUR     0x30
+#define BCDDATE     0x34
+#define BCDDAY      0x38
+#define BCDMON      0x3C
+#define BCDYEAR     0x40
+#define RTCIM       0x44
+#define RTCPEND     0x48
+
+#if 0
+#pragma pack(push, 4)
+struct tcc_rtc_regs {
+    volatile unsigned long RTCCON, INTCON, RTCALM,
+             ALMSEC, ALMMIN, ALMHOUR, ALMDATE, ALMDAY, ALMMON, ALMYEAR,
+             BCDSEC, BCDMIN, BCDHOUR, BCDDATE, BCDDAY, BCDMON, BCDYEAR, 
+             RTCIM, RTCPEND;
+};
+#pragma pack(pop)
+
+volatile struct tcc_rtc_regs *rtc_regs;
+#endif
+
+static void __iomem *rtc_base;
+static int tcc_rtc_alarmno = NO_IRQ;
+
+
+/* IRQ Handlers */
+
+static irqreturn_t tcc_rtc_alarmirq(int irq, void *id)
+{
+    //printk("[IRQ OK]\n");
+
+    tca_alarm_setint((unsigned int)rtc_base);
+
+	rtc_update_irq(id, 1, RTC_AF | RTC_IRQF);
+
+	return IRQ_HANDLED;
+}
+
+/* Update control registers */
+static void tcc_rtc_setaie(int to)
+{
+	unsigned int tmp;
+
+	pr_debug("%s: aie=%d\n", __func__, to);
+
+    tcc_writel( tcc_readl(rtc_base + RTCCON) | Hw1, rtc_base + RTCCON);
+    tcc_writel( tcc_readl(rtc_base + INTCON) | Hw0, rtc_base + INTCON);
+
+	tmp = tcc_readl(rtc_base + RTCALM) & ~Hw7;
+
+	if (to)
+		tmp |= Hw7;
+
+	tcc_writel(tmp, rtc_base + RTCALM);
+
+    //tcc_writel( tcc_readl(rtc_base + INTCON) & ~Hw0, rtc_base + INTCON);
+    tcc_writel( tcc_readl(rtc_base + RTCCON) & ~Hw1, rtc_base + RTCCON);
+}
+
+
+/* Time read/write */
+static int tcc_rtc_gettime(struct device *dev, struct rtc_time *rtc_tm)
+{
+    rtctime pTime;
+
+
+    local_irq_disable();
+    tca_rtc_gettime((unsigned int)rtc_base, &pTime);
+
+    rtc_tm->tm_sec  = pTime.wSecond;
+    rtc_tm->tm_min  = pTime.wMinute;
+    rtc_tm->tm_hour = pTime.wHour;
+    rtc_tm->tm_mday = pTime.wDay;
+    rtc_tm->tm_mon  = pTime.wMonth - 1;
+    rtc_tm->tm_year = pTime.wYear - 1900;
+
+    pr_debug("read time %02d.%02d.%02d %02d/%02d/%02d\n",
+         rtc_tm->tm_year, rtc_tm->tm_mon, rtc_tm->tm_mday,
+         rtc_tm->tm_hour, rtc_tm->tm_min, rtc_tm->tm_sec);
+
+    local_irq_enable();
+
+	return 0;
+}
+
+static int tcc_rtc_settime(struct device *dev, struct rtc_time *tm)
+{
+    rtctime pTime;
+
+	pr_debug("set time %02d.%02d.%02d %02d/%02d/%02d\n",
+		 tm->tm_year, tm->tm_mon, tm->tm_mday,
+		 tm->tm_hour, tm->tm_min, tm->tm_sec);
+
+    local_irq_disable();
+
+    pTime.wSecond       = tm->tm_sec;
+    pTime.wMinute       = tm->tm_min;
+    pTime.wHour         = tm->tm_hour;
+    pTime.wDay          = tm->tm_mday;
+    pTime.wMonth        = tm->tm_mon + 1;
+    pTime.wYear         = tm->tm_year + 1900;
+
+    tca_rtc_settime((unsigned int)rtc_base, &pTime);
+
+    local_irq_enable();
+
+	return 0;
+}
+
+static int tcc_rtc_getalarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	struct rtc_time *alm_tm = &alrm->time;
+	unsigned int alm_en, alm_pnd;
+
+    rtctime pTime;
+
+    pr_debug("%s\n", __func__);
+
+    local_irq_disable();
+
+    tcc_writel( tcc_readl(rtc_base + RTCCON) | Hw1, rtc_base + RTCCON);
+    tcc_writel( tcc_readl(rtc_base + INTCON) | Hw0, rtc_base + INTCON);
+
+	alm_en = tcc_readl(rtc_base + RTCALM);
+	alm_pnd = tcc_readl(rtc_base + RTCPEND);
+
+	alrm->enabled = (alm_en & Hw7) ? 1 : 0;
+	alrm->pending = (alm_pnd & Hw0) ? 1 : 0;
+
+    pr_debug(" alrm->enabled = %d, alm_en = %d\n", alrm->enabled, alm_en);
+
+    tcc_writel( tcc_readl(rtc_base + INTCON) & ~Hw0, rtc_base + INTCON);
+    tcc_writel( tcc_readl(rtc_base + RTCCON) & ~Hw1, rtc_base + RTCCON);
+
+    tca_alarm_gettime((unsigned int)rtc_base, &pTime);
+
+    alm_tm->tm_sec  = pTime.wSecond;
+    alm_tm->tm_min  = pTime.wMinute;
+    alm_tm->tm_hour = pTime.wHour;
+    alm_tm->tm_mday = pTime.wDay ;
+    alm_tm->tm_mon  = pTime.wMonth - 1;
+    alm_tm->tm_year = pTime.wYear - 1900;
+
+	pr_debug("read alarm %02x %02x.%02x.%02x %02x/%02x/%02x\n",
+		 alm_en,
+		 alm_tm->tm_year, alm_tm->tm_mon, alm_tm->tm_mday,
+		 alm_tm->tm_hour, alm_tm->tm_min, alm_tm->tm_sec);
+
+    local_irq_enable();
+
+	return 0;
+}
+
+static int tcc_rtc_setalarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+    rtctime pTime;
+	struct rtc_time *tm = &alrm->time;
+    pr_debug("%s\n", __func__);
+
+    local_irq_disable();
+
+    alrm->enabled = 1;
+
+    pTime.wSecond   = tm->tm_sec;
+    pTime.wMinute   = tm->tm_min;
+    pTime.wHour     = tm->tm_hour;
+    pTime.wDay      = tm->tm_mday;
+    pTime.wMonth    = tm->tm_mon + 1;
+    pTime.wYear     = tm->tm_year + 1900;
+
+	pr_debug("set alarm %02d.%02d.%02d %02d/%02d/%02d\n",
+		 pTime.wSecond, pTime.wMinute, pTime.wHour,
+         pTime.wDay, pTime.wMonth, pTime.wYear);
+
+    tca_alarm_settime((unsigned int)rtc_base, &pTime);
+
+    //tcc_writel( tcc_readl(rtc_base + RTCCON) & ~Hw0, rtc_base + RTCCON);
+    tcc_writel( tcc_readl(rtc_base + RTCCON) | Hw1, rtc_base + RTCCON);
+    tcc_writel( tcc_readl(rtc_base + INTCON) | Hw0, rtc_base + INTCON);
+    //tcc_writel( tcc_readl(rtc_base + INTCON) & ~Hw15, rtc_base + INTCON);
+	
+	if (alrm->enabled) {
+	    tcc_writel(tcc_readl(rtc_base + RTCALM)| Hw7, rtc_base + RTCALM);
+		enable_irq_wake(tcc_rtc_alarmno);
+    } else {
+	    tcc_writel(tcc_readl(rtc_base + RTCALM)& ~Hw7, rtc_base + RTCALM);
+		disable_irq_wake(tcc_rtc_alarmno);
+    }
+
+    tcc_writel( tcc_readl(rtc_base + INTCON) & ~Hw0, rtc_base + INTCON);
+    tcc_writel( tcc_readl(rtc_base + RTCCON) & ~Hw1, rtc_base + RTCCON);
+
+    local_irq_enable();
+
+	return 0;
+}
+
+static int tcc_rtc_proc(struct device *dev, struct seq_file *seq)
+{
+	return 0;
+}
+
+
+static int tcc_rtc_ioctl(struct device *dev,
+             unsigned int cmd, unsigned long arg)
+{
+    unsigned int ret = -ENOIOCTLCMD;
+
+    switch (cmd) {
+    case RTC_AIE_OFF:
+        tcc_rtc_setaie(0);
+        ret = 0;
+        break;
+    case RTC_AIE_ON:
+		tcc_rtc_setaie(1);
+        ret = 0;
+        break;
+    case RTC_PIE_OFF:
+        break;
+    case RTC_PIE_ON:
+        break;
+    case RTC_IRQP_READ:
+        break;
+    case RTC_IRQP_SET:
+        break;
+    case RTC_UIE_ON:
+        break;
+    case RTC_UIE_OFF:
+        break;
+        ret = -EINVAL;
+    }
+
+    return ret;
+}
+
+
+static const struct rtc_class_ops tcc_rtcops = {
+	.read_time	= tcc_rtc_gettime,
+	.set_time	= tcc_rtc_settime,
+	.read_alarm	= tcc_rtc_getalarm,
+	.set_alarm	= tcc_rtc_setalarm,
+	.proc	        = tcc_rtc_proc,
+    .ioctl      = tcc_rtc_ioctl,
+};
+
+#if 0
+static void tcc_rtc_enable(struct platform_device *pdev, int en)
+{
+	if (rtc_base == NULL)
+		return;
+
+
+    tca_alarm_setint((unsigned int)rtc_base);
+}
+#endif
+
+static int tcc_rtc_remove(struct platform_device *dev)
+{
+	struct rtc_device *rtc = platform_get_drvdata(dev);
+
+	platform_set_drvdata(dev, NULL);
+	rtc_device_unregister(rtc);
+
+	tcc_rtc_setaie(0);
+
+    free_irq(tcc_rtc_alarmno, rtc);
+
+	return 0;
+}
+
+
+static int tcc_rtc_probe(struct platform_device *pdev)
+{
+	struct rtc_device *rtc;
+	int ret;
+    volatile PIOBUSCFG pIOBUSCFG = (volatile PIOBUSCFG)tcc_p2v(HwIOBUSCFG_BASE);
+    int valid_time = 1;
+
+
+    // BUS Enable
+    pIOBUSCFG->HCLKEN0 |= Hw26;
+
+	rtc_base = (void __iomem *)tcc_p2v(HwRTC_BASE);
+
+	if (rtc_base == NULL) {
+        printk("failed ioremap()\n"); 
+        return -ENOMEM;
+	}
+
+    
+    // SW Reset
+    if(valid_time)
+    {
+        pIOBUSCFG->HRSTEN0 &= ~Hw26;
+        pIOBUSCFG->HRSTEN0 |= Hw26;
+        // tcc_rtc_init((unsigned int)rtc_base);
+        // RTC Initialization 
+        tcc_writel( Hw1, rtc_base + RTCCON);
+        tcc_writel( Hw0, rtc_base + INTCON);
+        tcc_writel( tcc_readl(rtc_base + RTCCON) | Hw0, rtc_base + RTCCON);
+        tcc_writel( tcc_readl(rtc_base + RTCCON) & ~Hw15, rtc_base + RTCCON);
+        tcc_writel( tcc_readl(rtc_base + RTCCON) & ~(Hw13 | Hw12 | Hw10 | Hw9 | Hw8), rtc_base + INTCON);
+        tcc_writel( tcc_readl(rtc_base + INTCON) | Hw12, rtc_base + INTCON);
+        tcc_writel( tcc_readl(rtc_base + RTCCON) | Hw15, rtc_base + RTCCON);
+
+        tcc_writel( tcc_readl(rtc_base + RTCCON) & ~Hw0, rtc_base + RTCCON);
+        tcc_writel( tcc_readl(rtc_base + RTCIM) & ~(Hw3 | Hw0), rtc_base + RTCIM);
+        tcc_writel( tcc_readl(rtc_base + RTCIM) | Hw2, rtc_base + RTCIM);
+
+        tcc_writel( tcc_readl(rtc_base + RTCALM) & ~(Hw7 - Hw0), rtc_base + RTCALM);
+        tcc_writel( tcc_readl(rtc_base + INTCON) & ~Hw0, rtc_base + INTCON);
+        tcc_writel( tcc_readl(rtc_base + RTCCON) & ~Hw1, rtc_base + RTCCON);
+
+    }else {
+        // ADD  PMWKUP RTC Normal mode}
+    }
+
+	//tcc_rtc_enable(pdev, 1);
+    //tca_alarm_setint((unsigned int)rtc_base);
+
+	/* find the IRQs */
+	tcc_rtc_alarmno = platform_get_irq(pdev, 0);
+    pr_debug("tcc_rtc: alarm irq %d\n", tcc_rtc_alarmno);
+
+	if (tcc_rtc_alarmno < 0) {
+		dev_err(&pdev->dev, "no irq for alarm\n");
+		return -ENOENT;
+	}
+
+	/* register RTC and exit */
+	rtc = rtc_device_register(pdev->name, &pdev->dev, &tcc_rtcops, THIS_MODULE);
+
+	if (IS_ERR(rtc)) {
+		dev_err(&pdev->dev, "cannot attach rtc\n");
+		ret = PTR_ERR(rtc);
+		goto err_nortc;
+	}
+
+	platform_set_drvdata(pdev, rtc);
+
+
+    if(request_irq(tcc_rtc_alarmno, tcc_rtc_alarmirq, 
+                   IRQF_DISABLED, DRV_NAME, rtc))
+    {
+        printk("%s: RTC timer interrupt IRQ%d already claimed\n",
+                 pdev->name, tcc_rtc_alarmno);
+        return 0;
+    }
+
+    //tca_alarm_setpmwkup((unsigned int)rtc_base, (unsigned int)pPIC);
+	//device_init_wakeup(&pdev->dev, 1);
+
+	return 0;
+
+ err_nortc:
+	//tcc_rtc_enable(pdev, 0);
+    rtc_device_unregister(rtc);
+    return ret;
+
+}
+
+#ifdef CONFIG_PM
+
+/* RTC Power management control */
+
+static int tcc_rtc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+    if (device_may_wakeup(&pdev->dev))
+        enable_irq_wake(tcc_rtc_alarmno);
+	return 0;
+}
+
+static int tcc_rtc_resume(struct platform_device *pdev)
+{
+    if (device_may_wakeup(&pdev->dev))
+        disable_irq_wake(tcc_rtc_alarmno);
+	return 0;
+}
+#else
+#define tcc_rtc_suspend NULL
+#define tcc_rtc_resume  NULL
+#endif
+
+static struct platform_driver tcc_rtc_driver = {
+	.probe		= tcc_rtc_probe,
+	.remove		= tcc_rtc_remove,
+	.suspend	= tcc_rtc_suspend,
+	.resume		= tcc_rtc_resume,
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static char __initdata banner[] = "TCC RTC, (c) 2009, Telechips \n";
+
+static int __init tcc_rtc_init(void)
+{
+	printk(banner);
+	return platform_driver_register(&tcc_rtc_driver);
+}
+
+static void __exit tcc_rtc_exit(void)
+{
+	platform_driver_unregister(&tcc_rtc_driver);
+}
+
+module_init(tcc_rtc_init);
+module_exit(tcc_rtc_exit);
+
+MODULE_AUTHOR("linux <linux@telechips.com>");
+MODULE_DESCRIPTION("Telechips RTC Driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.29/drivers/rtc/tcc
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/rtc/tcc	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1 @@
+tcc8900
\ No newline at end of file
Index: linux-2.6.29/drivers/rtc/tcc8900/tca_alarm.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/rtc/tcc8900/tca_alarm.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,303 @@
+
+/****************************************************************************
+ *   FileName    : tca_alarm.C
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+
+/*****************************************************************************
+*
+* Header Files Include
+*
+******************************************************************************/
+#include "tca_alarm.h"
+
+/*****************************************************************************
+*
+* Defines
+*
+******************************************************************************/
+#define WINCE_ONLY
+
+
+/*****************************************************************************
+*
+* structures
+*
+******************************************************************************/
+
+
+/*****************************************************************************
+*
+* Variables
+*
+******************************************************************************/
+
+
+
+/*****************************************************************************
+*
+* Functions
+*
+******************************************************************************/
+
+/*****************************************************************************
+* Function Name : tca_rtcgettime()
+******************************************************************************/
+VOLATILE void tca_alarm_gettime(unsigned int devbaseaddresss, rtctime *pTime)
+{
+	unsigned uCON;
+	
+	PRTC	pRTC = (PRTC)devbaseaddresss;
+
+	BITSET(pRTC->RTCCON, Hw1);	// RTC Register write enabled
+	BITSET(pRTC->INTCON, Hw0);	// Interrupt Block Write Enable
+
+	pTime->wSecond			= pRTC->ALMSEC;
+	pTime->wMinute			= pRTC->ALMMIN;
+	pTime->wHour			= pRTC->ALMHOUR;
+	pTime->wDayOfWeek 		= pRTC->ALMDAY;
+	pTime->wDay				= pRTC->ALMDATE;
+	pTime->wMonth			= pRTC->ALMMON;
+	pTime->wYear			= pRTC->ALMYEAR;
+	uCON = pRTC->RTCALM;
+	
+	BITCLR(pRTC->INTCON, Hw0);	// Interrupt Block Write Disable
+	BITCLR(pRTC->RTCCON, Hw1);	// RTC Register write Disable
+
+	/* Second */
+	if (ISZERO(uCON, Hw0))
+		pTime->wSecond	= (unsigned char) 0;
+	else
+		pTime->wSecond	= FROM_BCD( pTime->wSecond );
+
+	/* Minute */
+	if (ISZERO(uCON, Hw1))
+		pTime->wMinute	= (unsigned char) 0;
+	else
+		pTime->wMinute	= FROM_BCD( pTime->wMinute );
+
+	/* Hour */
+	if (ISZERO(uCON, Hw2))
+		pTime->wHour	= (unsigned char) 0;
+	else
+		pTime->wHour	= FROM_BCD( pTime->wHour );
+
+	/* date */
+	if (ISZERO(uCON, Hw3))
+		pTime->wDay	= (unsigned char) 0;
+	else
+		pTime->wDay	= FROM_BCD( pTime->wDay );
+
+	/* month */
+	if (ISZERO(uCON, Hw5))
+		pTime->wMonth	= (unsigned char) 0;
+	else
+		pTime->wMonth	= FROM_BCD( pTime->wMonth );
+
+	/* year */
+	if (ISZERO(uCON, Hw6))
+		pTime->wYear	= (unsigned short) 0;
+	else
+		pTime->wYear	= FROM_BCD( pTime->wYear );
+
+	/* weekdays */
+	if (ISZERO(uCON, Hw4))
+		pTime->wDayOfWeek		= 1;
+	else
+		pTime->wDayOfWeek = FROM_BCD( pTime->wDayOfWeek );
+
+	pRTC->RTCALM  = uCON;
+
+}
+
+/*****************************************************************************
+* Function Name : tca_rtcsettime()
+******************************************************************************/
+VOLATILE void tca_alarm_settime(unsigned int devbaseaddresss, rtctime *pTime)
+{
+	unsigned	uCON;
+	PRTC	pRTC = (PRTC)devbaseaddresss;
+
+	BITSET(pRTC->RTCCON, Hw1);	// RTC Register write enabled
+	BITSET(pRTC->INTCON, Hw0);	// Interrupt Block Write Enable
+
+	uCON	= 0xEF; // Not wDayOfWeek
+	/* Second */
+	if ( pTime->wSecond > 59 )
+		BITCLR(uCON, Hw0);//HwRTCALM_SECEN_EN
+	else
+		pRTC->ALMSEC	= TO_BCD( pTime->wSecond );
+
+	/* Minute */
+	if ( pTime->wMinute > 59 )
+		BITCLR(uCON, Hw1);//HwRTCALM_MINEN_EN
+	else
+		pRTC->ALMMIN	= TO_BCD( pTime->wMinute );
+
+	/* Hour */
+	if ( pTime->wHour > 23 )
+		BITCLR(uCON, Hw2);//HwRTCALM_HOUREN_EN
+	else
+		pRTC->ALMHOUR	= TO_BCD( pTime->wHour );
+
+	/* Date */
+	if ( pTime->wDay > 31 || pTime->wDay < 1 )
+		BITCLR(uCON, Hw3);//HwRTCALM_DATEEN_EN
+	else
+		pRTC->ALMDATE	= TO_BCD( pTime->wDay );
+
+	/* month */
+	if (pTime->wMonth > 12 || pTime->wMonth < 1)
+		BITCLR(uCON, Hw5);//HwRTCALM_MONEN_EN
+	else
+		pRTC->ALMMON	= TO_BCD( pTime->wMonth );
+
+	/* year */
+	if (pTime->wYear > 2099 || pTime->wYear < 1900)
+		BITCLR(uCON, Hw6);//HwRTCALM_YEAREN_EN
+	else
+		pRTC->ALMYEAR	= TO_BCD( pTime->wYear );
+
+	/* Day */
+	if ( pTime->wDayOfWeek > 6)
+		BITCLR(uCON, Hw4);//HwRTCALM_DAYEN_EN
+	else
+		pRTC->ALMDAY	= pTime->wDayOfWeek+1;
+
+	// Enable ALARM
+	pRTC->RTCALM	= uCON;
+
+	BITCLR(pRTC->RTCIM,Hw3|Hw1|Hw0);	// Normal Mode,PMWKUP Active low, Disable alarm interrupt mode
+	BITSET(pRTC->RTCIM,Hw1|Hw0);	////Suports on the edge alarm interrupt
+		
+	BITSET(pRTC->RTCSTR,Hw6);
+	pRTC->RTCPEND	= 0;
+	//BITSET(pRTC->RTCSTR,Hw5|Hw4);
+	
+	//BITCLR(pRTC->INTCON,Hw0);	// Normal Mode,PMWKUP Active low, Disable alarm interrupt mode
+	BITCSET(pRTC->RTCCON, Hw1, Hw6);	// Enable Alarm Interrupt
+}
+
+/************************************************************************************************
+* FUNCTION		:  tca_alarm_setint
+*
+* DESCRIPTION	: 
+*
+************************************************************************************************/
+VOLATILE void tca_alarm_setint(unsigned int devbaseaddresss)
+{
+	volatile rtctime lpTime;
+
+
+	//Set Alarm
+    tca_rtc_gettime(devbaseaddresss, (rtctime *)&lpTime);
+
+#if defined(WINCE_ONLY)
+	if(lpTime.wSecond < 57){
+		lpTime.wSecond += 3;
+	}
+	else{
+		if(lpTime.wMinute < 59){
+			lpTime.wMinute += 1;
+			lpTime.wSecond = 0;
+		}
+		else{
+			if(lpTime.wHour < 23){
+				lpTime.wHour += 1;
+				lpTime.wMinute = 0;
+				lpTime.wSecond = 0;
+			}
+			else{
+				lpTime.wHour = 0;
+				lpTime.wMinute = 0;
+				lpTime.wSecond = 0;
+			}
+		}
+	}
+	
+#else
+	if(lpTime.wSecond < 55)
+		lpTime.wSecond += 5;
+#endif
+
+	tca_alarm_settime(devbaseaddresss, (rtctime *)&lpTime);
+	
+	
+	
+}
+
+/************************************************************************************************
+* FUNCTION		:  tca_alarm_setpmwkup
+*
+* DESCRIPTION	: 
+*
+************************************************************************************************/
+VOLATILE void tca_alarm_setpmwkup(unsigned int rtcbaseaddresss,unsigned int vicbaseaddresss)
+{
+	volatile rtctime lpTime;
+
+	PRTC	pRTC = (PRTC)rtcbaseaddresss;
+	PPIC    pPIC = (PPIC)vicbaseaddresss;
+
+	//Set Alarm
+    tca_rtc_gettime(rtcbaseaddresss, (rtctime *)&lpTime);
+	
+
+#if defined(WINCE_ONLY)
+	
+	if(lpTime.wSecond < 57){
+		lpTime.wSecond += 3;
+	}
+	else{
+		if(lpTime.wMinute < 59){
+			lpTime.wMinute += 1;
+			lpTime.wSecond = 0;
+		}
+		else{
+			if(lpTime.wHour < 23){
+				lpTime.wHour += 1;
+				lpTime.wMinute = 0;
+				lpTime.wSecond = 0;
+			}
+	else{
+				lpTime.wHour = 0;
+				lpTime.wMinute = 0;
+		lpTime.wSecond = 0;
+	}
+		}
+	}
+	
+#else
+	if(lpTime.wSecond < 55)
+		lpTime.wSecond += 5;
+#endif
+
+	tca_alarm_settime(rtcbaseaddresss, (rtctime *)&lpTime);
+
+	pPIC->CLR1 		= 	Hw11;
+	pPIC->MSTS1 	|= 	Hw11;
+	pPIC->SEL1		|= 	Hw11;
+
+	BITSET(pRTC->RTCCON, Hw1);// Enable RTCEN
+	BITSET(pRTC->INTCON, Hw0);// Enable INTWREN
+	BITCLR(pRTC->RTCIM, 0xf);
+	BITSET(pRTC->RTCIM, Hw0|Hw2|Hw3);	 // Enable ALMINT_EDGE_EN, Enable PMWKUP_ACTIVE_HIGH, Enable PWDN_POWERDOWN_MODE
+	BITSET(pRTC->RTCCON, Hw1 | Hw7);
+	
+	//PMWKUP Disable Start
+		//pRTC->RTCCON = 0;
+		//BITSET(pRTC->RTCCON, Hw1);
+		//BITSET(pRTC->INTCON, Hw0);
+		//pRTC->RTCIM = 0;
+		//BITSET(pRTC->RTCIM, Hw0);
+	//PMWKUP Disable End
+}
+
+
+
Index: linux-2.6.29/drivers/rtc/tcc8900/tca_alarm.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/rtc/tcc8900/tca_alarm.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,71 @@
+
+/****************************************************************************
+ *   FileName    : tca_alarm.h
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+
+/*****************************************************************************
+*
+* Defines
+*
+******************************************************************************/
+#ifndef __TCA_ALARAM_H__
+#define __TCA_ALARAM_H__
+
+#include <bsp.h>
+#include "tca_rtc.h"
+
+/*****************************************************************************
+*
+* Enum
+*
+******************************************************************************/
+
+
+/*****************************************************************************
+*
+* Type Defines
+*
+******************************************************************************/
+
+/*****************************************************************************
+*
+* Structures
+*
+******************************************************************************/
+
+
+/*****************************************************************************
+*
+* External Variables
+*
+******************************************************************************/
+
+/*****************************************************************************
+*
+* External Functions
+*
+******************************************************************************/
+#ifdef __cplusplus
+extern 
+"C" { 
+#endif
+#include <bsp.h>
+
+VOLATILE void tca_alarm_gettime(unsigned int devbaseaddresss, rtctime *pTime);
+VOLATILE void tca_alarm_settime(unsigned int devbaseaddresss,rtctime *pTime);
+VOLATILE void tca_alarm_setint(unsigned int devbaseaddresss);
+VOLATILE void tca_alarm_setpmwkup(unsigned int rtcbaseaddresss,unsigned int vicbaseaddresss);
+
+#ifdef __cplusplus
+ } 
+#endif
+
+#endif //__TCA_ALARAM_H__
+
Index: linux-2.6.29/drivers/rtc/tcc8900/tca_rtc.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/rtc/tcc8900/tca_rtc.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,187 @@
+
+/****************************************************************************
+ *   FileName    : tca_rtc.C
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+
+
+/*****************************************************************************
+*
+* Header Files Include
+*
+******************************************************************************/
+#include "tca_rtc.h"
+
+/*****************************************************************************
+*
+* Defines
+*
+******************************************************************************/
+
+/*****************************************************************************
+*
+* structures
+*
+******************************************************************************/
+
+
+/*****************************************************************************
+*
+* Variables
+*
+******************************************************************************/
+
+
+
+/*****************************************************************************
+*
+* Functions
+*
+******************************************************************************/
+
+
+/*****************************************************************************
+* Function Name : tca_rtcgettime()
+******************************************************************************/
+VOLATILE void tca_rtc_gettime(unsigned int devbaseaddresss,rtctime *pTime)
+{
+	
+	unsigned int data;
+	unsigned short seconds;
+
+	PRTC	pRTC = (PRTC)devbaseaddresss;
+	
+   // Enable RTC control.
+  	BITCLR(pRTC->RTCCON, Hw4); // RTC Register write enabled
+    BITSET(pRTC->RTCCON, Hw1); // RTC Register write enabled
+	BITSET(pRTC->INTCON, Hw0); // Interrupt Block Write Enable  
+
+    do {
+			data = (pRTC->BCDSEC & 0x7f);
+			seconds = FROM_BCD(data);
+
+			data = (pRTC->BCDYEAR & 0xFFFF);
+			pTime->wYear = FROM_BCD(data); // Start from 1980
+
+			data = (pRTC->BCDMON & 0x1f);
+			pTime->wMonth = FROM_BCD(data);
+
+			data = (pRTC->BCDDATE & 0x3f);
+			pTime->wDay = FROM_BCD(data);
+
+			data = (pRTC->BCDDAY & 0x07);
+			pTime->wDayOfWeek = FROM_BCD(data);
+
+			data = (pRTC->BCDHOUR & 0x3f);
+			pTime->wHour = FROM_BCD(data);
+
+			data = (pRTC->BCDMIN & 0x7f);
+			pTime->wMinute = FROM_BCD(data);
+
+			data = (pRTC->BCDSEC & 0x7f);
+			pTime->wSecond = FROM_BCD(data);
+
+			pTime->wMilliseconds = 0;
+    } while (pTime->wSecond != seconds); 
+
+	//BITCLR(pRTC->INTCON, Hw0);
+	BITCLR(pRTC->RTCCON, Hw1);
+}
+
+/*****************************************************************************
+* Function Name : tca_rtcsettime()
+******************************************************************************/
+VOLATILE void tca_rtc_settime(unsigned int devbaseaddresss, rtctime *pTime)
+{
+	PRTC	pRTC = (PRTC)devbaseaddresss;
+     // Enable RTC control.
+    BITSET(pRTC->RTCCON, Hw0);	//RTC Start Halt
+    BITSET(pRTC->RTCCON, Hw4);	//RTC Clock Count Reset
+	BITCLR(pRTC->RTCCON, Hw4);	//RTC Clock Count No Reset
+	BITSET(pRTC->RTCCON, Hw4);	 //RTC Clock Count Reset
+	BITSET(pRTC->RTCCON, Hw1);	//RTC Write Enable
+	BITSET(pRTC->INTCON, Hw0);
+	BITCLR(pRTC->INTCON, Hw15); //RTC Clock Count No Reset
+
+	pRTC->BCDSEC	=	TO_BCD(pTime->wSecond);
+	pRTC->BCDMIN	=	TO_BCD(pTime->wMinute);
+	pRTC->BCDHOUR	=	TO_BCD(pTime->wHour);
+	pRTC->BCDDAY	=	TO_BCD(pTime->wDayOfWeek);
+	pRTC->BCDDATE	=	TO_BCD(pTime->wDay);
+	pRTC->BCDMON	=	TO_BCD(pTime->wMonth);
+	pRTC->BCDYEAR	=	TO_BCD(pTime->wYear);
+
+    // Disable RTC control.
+	BITSET(pRTC->INTCON, Hw0); //RTC Protection Enable
+	BITCLR(pRTC->RTCCON, Hw1);	//RTC Write Disable
+    BITCLR(pRTC->RTCCON, Hw0);	//RTC Start Run
+}
+
+/*****************************************************************************
+* Function Name : tca_rtcsettime()
+******************************************************************************/
+volatile unsigned int tca_rtc_checkvalidtime(unsigned int devbaseaddresss)
+{
+
+	unsigned	IsNeedMending;
+	rtctime		pTimeTest;
+
+	tca_rtc_gettime(devbaseaddresss, &pTimeTest);
+
+	//-------------------------------------------
+	// Conversion to Dec and Check validity
+	//-------------------------------------------
+	IsNeedMending = 0;
+
+	/* Second */
+	if (pTimeTest.wSecond > 59)
+	{
+		IsNeedMending	= 1;
+	}
+
+	/* Minute */
+	if ( pTimeTest.wMinute > 59 )
+	{
+		IsNeedMending	= 1;
+	}
+
+	/* Hour */
+	if ( pTimeTest.wHour > 23 )
+	{
+		IsNeedMending	= 1;
+	}
+
+	/* Date */ // 1~31
+	if ( ( pTimeTest.wDay < 1 ) || ( pTimeTest.wDay > 31 ) )
+	{
+		IsNeedMending	= 1;
+	}
+
+	/* Day */ // Sunday ~ Saturday
+	if ( pTimeTest.wDayOfWeek > 6 )
+	{
+		IsNeedMending	= 1;
+	}
+
+	/* Month */
+	if ( ( pTimeTest.wMonth < 1 ) || ( pTimeTest.wMonth > 12 ) )
+	{
+		IsNeedMending	= 1;
+	}
+
+	/* Year */
+	if ( pTimeTest.wYear < 1980 || pTimeTest.wYear > 2100)
+	{
+		IsNeedMending	= 1;
+	}
+
+	return	IsNeedMending;
+
+}
+
Index: linux-2.6.29/drivers/rtc/tcc8900/tca_rtc.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/rtc/tcc8900/tca_rtc.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,76 @@
+
+/****************************************************************************
+ *   FileName    : tca_rtc.h
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+/*****************************************************************************
+*
+* Defines
+*
+******************************************************************************/
+
+
+/*****************************************************************************
+*
+* Enum
+*
+******************************************************************************/
+#ifndef __TCA_RTC_H__
+#define __TCA_RTC_H__
+
+#include "bsp.h"
+
+
+/*****************************************************************************
+*
+* Type Defines
+*
+******************************************************************************/
+#define FROM_BCD(n)     ((((n) >> 4) * 10) + ((n) & 0xf))
+#define TO_BCD(n)       ((((n) / 10) << 4) | ((n) % 10))
+#define RTC_YEAR_DATUM  1980
+
+
+/*****************************************************************************
+*
+* Structures
+*
+******************************************************************************/
+
+
+/*****************************************************************************
+*
+* External Variables
+*
+******************************************************************************/
+
+
+/*****************************************************************************
+*
+* External Functions
+*
+******************************************************************************/
+#ifdef __cplusplus
+extern 
+"C" { 
+#endif
+
+#include <bsp.h>
+
+VOLATILE void tca_rtc_gettime(unsigned int devbaseaddresss,rtctime *pTime);
+VOLATILE void tca_rtc_settime(unsigned int devbaseaddresss,rtctime *pTime);
+volatile unsigned int	tca_rtc_checkvalidtime(unsigned int devbaseaddresss);
+
+#ifdef __cplusplus
+ } 
+#endif
+
+
+#endif //__TCA_RTC_H__
+
Index: linux-2.6.29/drivers/serial/Kconfig
===================================================================
--- linux-2.6.29.orig/drivers/serial/Kconfig	2010-04-07 12:29:33.000000000 -0400
+++ linux-2.6.29/drivers/serial/Kconfig	2010-04-07 12:29:36.000000000 -0400
@@ -496,6 +496,40 @@
 	help
 	  Serial port support for the Samsung S3C2400 SoC
 
+config SERIAL_TCC
+	tristate "Telechips TCC Serial port support"
+	depends on ARM && ARCH_TCC
+	select SERIAL_CORE
+	help
+	  Support for the on-chip UARTs on the Telechips TCC series CPUs,
+	  providing /dev/ttySAC0, 1.
+
+config SERIAL_TCC_CONSOLE
+	bool "Support for console on TCC serial port"
+	depends on ARM && ARCH_TCC
+	depends on SERIAL_TCC
+	select SERIAL_CORE_CONSOLE
+	help
+	  Allow selection of the TCC on-board serial ports for use as
+	  an virtual console.
+
+	  Even if you say Y here, the currently visible virtual console
+	  (/dev/ttyx) will still be used as the system console by default, but
+	  you can alter that using a kernel command line option such as
+	  "console=ttySACx". (Try "man bootparam" or see the documentation of
+	  your boot loader about how to pass options to the kernel at
+	  boot time.)
+
+config SERIAL_TCC_DMA
+	bool "Support for DMA mode"
+	depends on ARM && ARCH_TCC
+	depends on SERIAL_TCC
+	help
+	  This driver works under DMA mode. If this option is selected, the
+	  TCC simple dma driver is also enabled.
+
+
+
 config SERIAL_S3C2410
 	tristate "Samsung S3C2410 Serial port support"
 	depends on SERIAL_SAMSUNG && CPU_S3C2410
Index: linux-2.6.29/drivers/serial/Makefile
===================================================================
--- linux-2.6.29.orig/drivers/serial/Makefile	2010-04-07 12:29:33.000000000 -0400
+++ linux-2.6.29/drivers/serial/Makefile	2010-04-07 12:29:36.000000000 -0400
@@ -14,6 +14,13 @@
 obj-$(CONFIG_SERIAL_SUNSU) += sunsu.o
 obj-$(CONFIG_SERIAL_SUNSAB) += sunsab.o
 
+
+ifeq ($(CONFIG_ARCH_TCC),y)
+$(shell ln -fsn $(CONFIG_TCC_STRING) $(srctree)/drivers/serial/tcc) 
+endif
+obj-$(CONFIG_SERIAL_TCC) += tcc_serial.o tcc/tca_serial.o
+#obj-$(CONFIG_SERIAL_TCC) += tcc_serial.o
+
 obj-$(CONFIG_SERIAL_8250) += 8250.o
 obj-$(CONFIG_SERIAL_8250_PNP) += 8250_pnp.o
 obj-$(CONFIG_SERIAL_8250_GSC) += 8250_gsc.o
Index: linux-2.6.29/drivers/serial/tcc
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/serial/tcc	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1 @@
+tcc8900
\ No newline at end of file
Index: linux-2.6.29/drivers/serial/tcc8900/tca_serial.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/serial/tcc8900/tca_serial.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,450 @@
+
+/****************************************************************************
+ *   FileName    : tca_tccserial.c
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+
+/*****************************************************************************
+*
+* Include
+*
+******************************************************************************/
+
+#include <bsp.h>
+#include "../tcc_serial.h"
+
+
+/*****************************************************************************
+*
+* Defines
+*
+******************************************************************************/
+
+
+/*****************************************************************************
+* Function Name : tca_serial_portinit(int nCh, int nPort, unsigned long* pvGpioAddr, unsigned long* pvPortMuxAddr)
+******************************************************************************
+* Desription    : tca_serial_portinit
+* Parameter     : int nCh, int nPort, unsigned long* pvGpioAddr, unsigned long* pvPortMuxAddr
+* Return        : None
+******************************************************************************/
+void	tca_serial_portinit(int nCh, int nPort, unsigned long* pvGpioAddr, unsigned long* pvPortMuxAddr)
+{
+
+	PGPIO pGpio = (PGPIO)pvGpioAddr;
+	PUARTPORTMUX pPortmux = (PUARTPORTMUX)pvPortMuxAddr;
+	
+	
+	// ch5 cannot use DMA (spec.)
+	// each value of CHSEL shuld be different
+	/*
+	if(nPort == 5){ //change ch
+		BITCSET(pPortmux->CHSEL, 0x7 <<(4*nCh), nPort << (4*nCh));
+		BITCSET(pPortmux->CHSEL, 0x7 <<(4*5), nCh << (4*5));
+	}
+	*/	
+
+
+	BITCSET(pPortmux->CHSEL, 0x7 <<(4*0), 0 << (4*0));  //portmuxinit
+	BITCSET(pPortmux->CHSEL, 0x7 <<(4*1), 1 << (4*1));  //portmuxinit
+	BITCSET(pPortmux->CHSEL, 0x7 <<(4*2), 2 << (4*2));  //portmuxinit
+	BITCSET(pPortmux->CHSEL, 0x7 <<(4*3), 5 << (4*3));  //portmuxinit
+	BITCSET(pPortmux->CHSEL, 0x7 <<(4*4), 4 << (4*4));  //portmuxinit
+	BITCSET(pPortmux->CHSEL, 0x7 <<(4*5), 3 << (4*5));  //portmuxinit
+	
+	switch(nPort){//do port set
+	case 0:
+		BITCSET(pGpio->GPEFN0, Hw4-Hw0, Hw0);
+		BITCSET(pGpio->GPEFN0, Hw8-Hw4, Hw4);
+		break;
+	case 1:
+		BITCSET(pGpio->GPEFN0, Hw24-Hw20, Hw20);
+		BITCSET(pGpio->GPEFN0, Hw20-Hw16, Hw16);
+		break;
+	case 2:
+		BITCSET(pGpio->GPEFN1, Hw4-Hw0, Hw0);
+		BITCSET(pGpio->GPEFN1, Hw8-Hw4, Hw4);
+		break;
+	case 3:
+		BITCSET(pGpio->GPDFN1, Hw28-Hw24, Hw24);
+		BITCSET(pGpio->GPDFN1, Hw24-Hw20, Hw20);
+		break;
+	case 4:
+		BITCSET(pGpio->GPDFN2, Hw8-Hw4, Hw4);
+		BITCSET(pGpio->GPDFN2, Hw12-Hw8, Hw8);
+		break;
+	case 5:
+		BITCSET(pGpio->GPDFN2, Hw8-Hw4, Hw4);
+		BITCSET(pGpio->GPDFN2, Hw12-Hw8, Hw8);
+		break;
+	}
+	
+}
+
+
+void tca_serial_gpio_setting(int nCh, int nPort, unsigned long* pvGpioAddr, unsigned long* pvPortMuxAddr)
+{
+
+	PGPIO pGpio = (PGPIO)pvGpioAddr;
+	PUARTPORTMUX pPortmux = (PUARTPORTMUX)pvPortMuxAddr;
+	
+	switch(nPort){//do port set
+	case 0:
+		BITCSET(pGpio->GPEFN0, Hw4-Hw0, Hw0);
+		BITCSET(pGpio->GPEFN0, Hw8-Hw4, Hw4);
+		break;
+	case 1:
+		BITCSET(pGpio->GPEFN0, Hw24-Hw20, Hw20);
+		BITCSET(pGpio->GPEFN0, Hw20-Hw16, Hw16);
+		break;
+	case 2:
+		BITCSET(pGpio->GPEFN1, Hw4-Hw0, Hw0);
+		BITCSET(pGpio->GPEFN1, Hw8-Hw4, Hw4);
+		break;
+	case 3:
+		BITCSET(pGpio->GPDFN1, Hw28-Hw24, Hw24);
+		BITCSET(pGpio->GPDFN1, Hw24-Hw20, Hw20);
+		break;
+	case 4:
+		BITCSET(pGpio->GPDFN2, Hw8-Hw4, Hw4);
+		BITCSET(pGpio->GPDFN2, Hw12-Hw8, Hw8);
+		break;
+	case 5:
+		BITCSET(pGpio->GPDFN2, Hw8-Hw4, Hw4);
+		BITCSET(pGpio->GPDFN2, Hw12-Hw8, Hw8);
+		break;
+	}
+}
+
+
+void	tca_serial_gpio_default(int nCh, int nPort, unsigned long* pvGpioAddr, unsigned long* pvPortMuxAddr)
+{
+
+	PGPIO pGpio = (PGPIO)pvGpioAddr;
+	PUARTPORTMUX pPortmux = (PUARTPORTMUX)pvPortMuxAddr;
+	
+	switch(nPort){//do port set
+	case 0:
+		BITCLR(pGpio->GPEFN0, Hw4-Hw0);
+		BITCLR(pGpio->GPEFN0, Hw8-Hw4);
+
+		BITCLR(pGpio->GPEEN, Hw4-Hw0);
+		BITCLR(pGpio->GPEDAT, Hw4-Hw0);
+
+		break;
+	case 1:
+		BITCLR(pGpio->GPEFN0, Hw24-Hw20);
+		BITCLR(pGpio->GPEFN0, Hw20-Hw16);
+		
+		BITCLR(pGpio->GPEEN, Hw8-Hw4);
+		BITCLR(pGpio->GPEDAT, Hw8-Hw4);
+		break;
+	case 2:
+		BITCLR(pGpio->GPEFN1, Hw4-Hw0);
+		BITCLR(pGpio->GPEFN1, Hw8-Hw4);
+
+		BITCLR(pGpio->GPEEN, Hw12-Hw7);
+		BITCLR(pGpio->GPEDAT, Hw12-Hw7);
+		break;
+	case 3:
+		BITCLR(pGpio->GPDFN1, Hw28-Hw24);
+		BITCLR(pGpio->GPDFN1, Hw24-Hw20);
+
+		BITCLR(pGpio->GPDEN, Hw17-Hw13);
+		BITCLR(pGpio->GPDDAT, Hw17-Hw13);
+		break;
+	case 4:
+		BITCLR(pGpio->GPDFN2, Hw8-Hw4);
+		BITCLR(pGpio->GPDFN2, Hw12-Hw8);
+
+		BITCLR(pGpio->GPDEN, Hw17-Hw13);
+		BITCLR(pGpio->GPDDAT, Hw17-Hw13);
+		
+		break;
+	case 5:
+		BITCLR(pGpio->GPDFN2, Hw8-Hw4);
+		BITCLR(pGpio->GPDFN2, Hw12-Hw8);
+
+		BITCLR(pGpio->GPDEN, Hw21-Hw17);
+		BITCLR(pGpio->GPDDAT, Hw21-Hw1);
+		break;
+	}
+	
+}
+
+
+
+/*****************************************************************************
+* Function Name : tca_serial_dmaclrinterrupt(unsigned nDmanum, unsigned long* pVirtualDmaAddr)
+******************************************************************************
+* Desription    : tca_serial_dmaclrinterrupt
+* Parameter     : unsigned nDmanum, unsigned long* pVirtualDmaAddr
+* Return        : success(SUCCESS) 
+******************************************************************************/
+unsigned int tca_serial_dmaclrinterrupt(unsigned nDmanum, unsigned long* pVirtualDmaAddr)
+{
+	PGDMACTRL pDMA = (PGDMACTRL)pVirtualDmaAddr;
+	switch(	nDmanum ){
+	case 0:
+		pDMA->CHCTRL0 |= Hw3; 
+		break;
+	case 1:
+		pDMA->CHCTRL1 |= Hw3; 
+		break;
+	case 2:
+		pDMA->CHCTRL2 |= Hw3; 
+		break;
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+/*****************************************************************************
+* Function Name : tca_dma_dmacurrentaddress(int m_DmaNumber, unsigned long* pVirtualDmaAddr)
+******************************************************************************
+* Desription    : tca_dma_dmacurrentaddress
+* Parameter     : int m_DmaNumber, unsigned long* pVirtualDmaAddr
+* Return        : 
+******************************************************************************/
+int tca_dma_dmacurrentaddress(int m_DmaNumber, unsigned long* pVirtualDmaAddr)
+{
+	PGDMACTRL pDMA = (PGDMACTRL)pVirtualDmaAddr;
+	switch(m_DmaNumber)
+	{
+	case 0:
+		return  (pDMA->C_DADR0);
+	case 1:
+		return  (pDMA->C_DADR1);
+	case 2:
+		return  (pDMA->C_DADR2);
+	default:
+		return 0;
+	}
+}
+/*****************************************************************************
+* Function Name : tca_dma_dmadeststartaddress(int m_DmaNumber, unsigned long* pVirtualDmaAddr)
+******************************************************************************
+* Desription    : tca_dma_dmadeststartaddress
+* Parameter     : int m_DmaNumber, unsigned long* pVirtualDmaAddr
+* Return        : 
+******************************************************************************/
+int     tca_dma_dmadeststartaddress(int m_DmaNumber, unsigned long* pVirtualDmaAddr)
+{
+	PGDMACTRL pDMA = (PGDMACTRL)pVirtualDmaAddr;
+	switch(m_DmaNumber){
+	case 0:
+		return  (pDMA->ST_DADR0);
+	case 1:
+		return  (pDMA->ST_DADR1);
+	case 2:
+		return  (pDMA->ST_DADR2);
+	default:
+		return 0;
+	}
+	return 0;
+}
+/*****************************************************************************
+* Function Name : tca_dma_clrien(int m_DmaNumber, unsigned long* pVirtualDmaAddr)
+******************************************************************************
+* Desription    : tca_dma_clrien
+* Parameter     : int m_DmaNumber, unsigned long* pVirtualDmaAddr
+* Return        : 
+******************************************************************************/
+int     tca_dma_clrien(int m_DmaNumber, unsigned long* pVirtualDmaAddr)
+{
+	PGDMACTRL pDMA = (PGDMACTRL)pVirtualDmaAddr;
+	switch(m_DmaNumber){
+	case 0:
+		 pDMA->CHCTRL0 &= Hw2; 
+		break;
+	case 1:
+		 pDMA->CHCTRL1 &= Hw2; 
+		break;
+	case 2:
+		 pDMA->CHCTRL2 &= Hw2; 
+		break;
+	default:
+		return 0;
+	}
+	return 0;
+}
+/*****************************************************************************
+* Function Name : tca_dma_setien(int m_DmaNumber, unsigned long* pVirtualDmaAddr)
+******************************************************************************
+* Desription    : tca_dma_setien
+* Parameter     : int m_DmaNumber, unsigned long* pVirtualDmaAddr
+* Return        : 
+******************************************************************************/
+int     tca_dma_setien(int m_DmaNumber, unsigned long* pVirtualDmaAddr)
+{
+	PGDMACTRL pDMA = (PGDMACTRL)pVirtualDmaAddr;
+	switch(m_DmaNumber){
+	case 0:
+		 pDMA->CHCTRL0 |= Hw2; 
+		break;
+	case 1:
+		 pDMA->CHCTRL1 |= Hw2; 
+		break;
+	case 2:
+		 pDMA->CHCTRL2 |= Hw2; 
+		break;
+	default:
+		return 0;
+	}
+	return 0;
+}
+/*****************************************************************************
+* Function Name : tca_dma_ctrl(int m_DmaNumber, unsigned long* pVirtualDmaAddr)
+******************************************************************************
+* Desription    : tca_dma_ctrl
+* Parameter     : int m_DmaNumber, unsigned long* pVirtualDmaAddr
+* Return        : 
+******************************************************************************/
+int    tca_dma_ctrl(int m_DmaNumber, unsigned long* pVirtualDmaAddr)
+{
+	PGDMACTRL pDMA = (PGDMACTRL)pVirtualDmaAddr;
+
+	switch(m_DmaNumber){
+	case 0:
+		return  (pDMA->CHCTRL0);
+	case 1:
+		return  (pDMA->CHCTRL1);
+	case 2:
+		return  (pDMA->CHCTRL2);
+	default:
+		return 0;
+	}
+	
+}
+
+
+/*****************************************************************************
+* Function Name : tca_dma_setconfig(
+	iunsigned uCH,
+	void *pSRT, 
+	unsigned uSPARAM,
+	void *pDST, 
+	unsigned uDPARAM,
+	unsigned	uCHCTRL,
+	unsigned uSize,
+	unsigned channel,
+	unsigned mode,
+	unsigned long* pVirtualDmaAddr
+)
+******************************************************************************
+* Desription    : tca_dma_setconfig
+* Parameter     : 
+* Return        : 
+******************************************************************************/
+void tca_dma_setconfig(
+    unsigned uCH,
+	void* pSRT, 
+	unsigned uSPARAM,
+	void* pDST, 
+	unsigned uDPARAM,
+	unsigned	uCHCTRL,
+	unsigned uSize,
+	unsigned channel,
+	unsigned mode,
+	unsigned long* pVirtualDmaAddr
+)
+{
+	PGDMACTRL pDMA = (PGDMACTRL)pVirtualDmaAddr;
+
+
+	switch( uCH )   {
+	case 0:
+		if (uSize){
+        	// Set Source Address & Source Parameter (mask + increment)
+			 pDMA->ST_SADR0 = (int)pSRT;
+			 pDMA->SPARAM0 = uSPARAM;
+        	
+			 // Set Dest Address & Dest Parameter (mask + increment)
+			 pDMA->ST_DADR0 = (int)pDST;
+			 pDMA->DPARAM0 = uDPARAM;
+			 pDMA->RPTCTRL0 &= ~Hw31;
+			 
+
+			 pDMA->EXTREQ0 = tca_uart_channelselect(channel, mode);
+			 pDMA->HCOUNT0 = uSize;
+		}
+
+		 pDMA->CHCTRL0 = uCHCTRL;
+		 pDMA->CHCTRL0 |= Hw0;
+		break;
+	case 1:
+		if (uSize){
+		// Set Source Address & Source Parameter (mask + increment)
+			 pDMA->ST_SADR1 = (int)pSRT;
+			 pDMA->SPARAM1 = uSPARAM;
+
+        	// Set Dest Address & Dest Parameter (mask + increment)
+			 pDMA->ST_DADR1 = (int)pDST;
+			 pDMA->DPARAM1 = uDPARAM;
+			 pDMA->RPTCTRL1 &= ~Hw31;
+			 
+			 pDMA->EXTREQ1 = tca_uart_channelselect(channel, mode);
+			// now one HOP is 1*8/8 bytes, HwHCOUNT determine how many HOPS will fire a interrupt
+			 pDMA->HCOUNT1 = uSize;//((uSize)>>0x01)>>0x03;
+        	}
+
+		 pDMA->CHCTRL1 = uCHCTRL;
+		 pDMA->CHCTRL1 |= Hw0;
+        break;
+	case 2:
+		if (uSize){
+		// Set Source Address & Source Parameter (mask + increment)
+			 pDMA->ST_SADR2 = (int)pSRT;
+			 pDMA->SPARAM2 = uSPARAM;
+
+        	// Set Dest Address & Dest Parameter (mask + increment)
+			 pDMA->ST_DADR2 = (int)pDST;
+			 pDMA->DPARAM2 = uDPARAM;
+			 pDMA->RPTCTRL2 &= ~Hw31;
+			 
+			 pDMA->EXTREQ2 = tca_uart_channelselect(channel, mode);
+			// now one HOP is 1*8/8 bytes, HwHCOUNT determine how many HOPS will fire a interrupt
+			 pDMA->HCOUNT2 = uSize;//((uSize)>>0x01)>>0x03;
+        	}
+
+		 pDMA->CHCTRL2 = uCHCTRL;
+		 pDMA->CHCTRL2 |= Hw0;
+        break;
+	}
+}
+
+/*****************************************************************************
+* Function Name : tca_uart_channelselectint channel, int mode)
+******************************************************************************
+* Desription    : tca_serial_portinit
+* Parameter     : int channel, int mode
+* Return        : 
+******************************************************************************/
+int tca_uart_channelselect(int channel, int mode)
+{
+	
+	switch(channel){
+	case 0:
+		return (mode?HwEXTREQ_UART0_RX:HwEXTREQ_UART0_TX);
+		break;
+	case 1:
+		return (mode?HwEXTREQ_UART1_RX:HwEXTREQ_UART1_TX);
+		break;
+	case 2:
+		return (mode?HwEXTREQ_UART2_RX:HwEXTREQ_UART2_TX);
+		break;
+	case 3:
+		return (mode?HwEXTREQ_UART3_RX:HwEXTREQ_UART3_TX);
+	default :
+		break;
+	
+	}
+	return 0;
+}
\ No newline at end of file
Index: linux-2.6.29/drivers/serial/tcc8900/tca_serial.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/serial/tcc8900/tca_serial.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,52 @@
+
+/****************************************************************************
+ *   FileName    : tca_tccserial.h
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/*****************************************************************************
+*
+* Defines
+*
+******************************************************************************/
+
+	
+/*****************************************************************************
+*
+* APIs
+*
+******************************************************************************/
+
+	
+int	tca_uart_channelselect(int channel, int mode);
+void tca_serial_gpio_setting(int nCh, int nPort, unsigned long* pvGpioAddr, unsigned long* pvPortMuxAddr);
+void tca_serial_gpio_default(int nCh, int nPort, unsigned long* pvGpioAddr, unsigned long* pvPortMuxAddr);
+void tca_serial_portinit(int nCh, int nPort, unsigned long* pvGpioAddr, unsigned long* pvPortMuxAddr);
+
+int	tca_dma_ctrl(int m_DmaNumber, unsigned long* pVirtualDmaAddr);
+int	tca_dma_dmacurrentaddress(int m_DmaNumber, unsigned long* pVirtualDmaAddr);
+int tca_dma_dmadeststartaddress(int m_DmaNumber,unsigned long* pVirtualDmaAddr);
+int tca_dma_clrien(int m_DmaNumber, unsigned long* pVirtualDmaAddr);
+int tca_dma_setien(int m_DmaNumber, unsigned long* pVirtualDmaAddr);
+unsigned int tca_serial_dmaclrinterrupt(unsigned nDmanum, unsigned long* pVirtualDmaAddr);
+void tca_dma_setconfig( unsigned uCH,	void* pSRT, 	
+					   unsigned uSPARAM,	void* pDST, 	
+					   unsigned uDPARAM,	unsigned	uCHCTRL,	
+					   unsigned uSize,	unsigned channel,	
+					   unsigned mode, unsigned long* pVirtualDmaAddr);
+
+
+#ifdef __cplusplus
+}
+#endif
Index: linux-2.6.29/drivers/serial/tcc_serial.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/serial/tcc_serial.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,1694 @@
+/*
+ * linux/drivers/serial/tcc_serial.c
+ *
+ * Based on: drivers/serial/s3c2410.c and driver/serial/bfin_5xx.c
+ * Author:  <linux@telechips.com>
+ * Created: June 10, 2008
+ * Description: Driver for onboard UARTs on the Telechips TCC Series
+ *
+ * Copyright (C) 2008-2009 Telechips 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see the file COPYING, or write
+ * to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/sysrq.h>
+#include <linux/console.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/serial_reg.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+
+#if CONFIG_MACH_TCC8900
+#include <bsp.h>
+#include <mach/tcc_pca953x.h>
+#include "tcc/tca_serial.h"
+#include "tcc_serial.h"
+#define DRV_NAME "tcc8900-uart"
+#define CONSOLE_PORT 0
+#define UART1           1
+#define	CONSOLE_BASE	*(volatile unsigned long *)0xF0532000
+#endif
+
+#define BAUDRATE  115200
+
+#if defined(CONFIG_SERIAL_TCC_DMA)
+#define CONFIG_SERIAL_TCC_DMA_TX
+#define CONFIG_SERIAL_TCC_DMA_RX
+#endif
+
+#ifdef CONFIG_SERIAL_TCC_DMA_TX
+#include <linux/dma-mapping.h>
+
+#define DMA_PORT	    UART1   // UART1 
+#define DMA_TX_CH_NUM   0   // GDMA1-0
+#define DMA_TX_INT	    INT_DMA1_CH0
+#define DMA_BUF_SIZE    FIFOSIZE
+#define DMA_TX_MODE     0
+//#define HwGDMA_BASE     HwGDMA0_BASE  // GDMA1
+#define HwGDMA_BASE     HwGDMA1_BASE  // GDMA1
+//#define HwGDMA_BASE     HwGDMA2_BASE  // GDMA1
+//#define HwGDMA_BASE     HwGDMA3_BASE  // GDMA1
+#endif
+
+#ifdef CONFIG_SERIAL_TCC_DMA_RX
+#define DMA_CH_NUM_RX   1   // GDMA1-1
+#define DMA_RX_MODE     1
+#define TIME_STEP       1//(1*HZ)      
+#define DMA_RX_BUF_SIZE 0x1000     
+#include <linux/time.h>  
+#include <linux/timer.h> 
+#include <linux/delay.h>   
+
+void *dma_rx_buffer, *dma_rx_buffer_physical;
+struct timer_list  *timer;
+static int rx_dma_tail=0;
+void *kerneltimer_timeover(void *arg );
+static int timer_state=0;
+static DECLARE_WORK(work_queue, kerneltimer_timeover);
+static unsigned long start_value;
+#endif
+
+#define TIMEOUT     jiffies_to_msecs(1000)
+
+#define UART_IER_ELSI   UART_IER_RLSI 
+
+/* UARTx_LCR Masks                                              */
+#define WLS(x)      (((x)-5) & 0x03)    /* Word Length Select */
+#define STB         0x04                /* Stop Bits            */
+#define PEN         0x08                /* Parity Enable        */
+#define EPS         0x10                /* Even Parity Select   */
+#define SP          0x20                /* Stick Parity         */
+#define SB          0x40                /* Set Break            */
+#define DLAB        0x80                /* Divisor Latch Access */
+
+/* UARTx_MCR Mask                                       */
+#define AFE         0x20    /* Auto Flow Control Enable */
+#define LOOP        0x10    /* Loopback Mode Enable     */
+#define RTS         0x02    /* Request To Sent          */
+
+/* UARTx_LSR Masks                                      */
+#define DR          0x01    /* Data Ready               */
+#define OE          0x02    /* Overrun Error            */
+#define PE          0x04    /* Parity Error             */
+#define FE          0x08    /* Framing Error            */
+#define BI          0x10    /* Break Interrupt          */
+#define THRE        0x20    /* THR Empty                */
+#define TEMT        0x40    /* TSR and UART_THR Empty   */
+
+/* UARTx_IER Masks */
+#define ERXI    0x01
+#define ETXI    0x02
+#define ELSI    0x04
+
+#define OFFSET_THR    0x00	/* Transmit Holding register            */
+#define OFFSET_RBR    0x00	/* Receive Buffer register              */
+#define OFFSET_DLL    0x00	/* Divisor Latch (Low-Byte)             */
+#define OFFSET_IER    0x04	/* Interrupt Enable Register            */
+#define OFFSET_DLM    0x04	/* Divisor Latch (High-Byte)            */
+#define OFFSET_IIR    0x08	/* Interrupt Identification Register    */
+#define OFFSET_FCR    0x08	/* FIFO Control Register                */
+#define OFFSET_LCR    0x0C	/* Line Control Register                */
+#define OFFSET_MCR    0x10	/* Modem Control Register               */
+#define OFFSET_LSR    0x14	/* Line Status Register                 */
+#define OFFSET_MSR    0x18	/* Modem Status Register                */
+#define OFFSET_SCR    0x1C	/* SCR Scratch Register                 */
+#define OFFSET_AFT    0x20	/* AFC Trigger Level Register           */
+#define OFFSET_UCR    0x24	/* UART Control Register                */
+
+#define portaddr(port, reg) ((port)->membase + (reg))
+
+#define rd_regb(port, reg) (__raw_readb(portaddr(port, reg)))
+#define rd_regl(port, reg) (__raw_readl(portaddr(port, reg)))
+
+#define wr_regl(port, reg, val) \
+    do { __raw_writel(val, portaddr(port, reg)); } while(0)
+#define wr_regb(port, reg, val) \
+    do { __raw_writeb(val, portaddr(port, reg)); } while(0)
+
+
+
+/* structures */
+
+struct tcc_uart_clksrc {
+	const char	    *name;
+	unsigned int	divisor;
+	unsigned int	min_baud;
+	unsigned int	max_baud;
+};
+
+struct tcc_uart_info {
+	char			*name;
+	unsigned int	type;
+	unsigned int	fifosize;
+};
+
+struct tcc_reg_info {
+	unsigned long	bDLL;
+	unsigned long	bIER;
+	unsigned long	bDLM;
+	unsigned long	bLCR;
+	unsigned long	bMCR;
+	unsigned long	bSCR;
+	unsigned long	bFCR;
+	unsigned long	bMSR;
+	unsigned long	bAFT;
+	unsigned long	bUCR;
+};
+
+#ifdef CONFIG_SERIAL_TCC_DMA_TX
+typedef struct _tcc_dma_buf_t {
+    char *addr;
+    dma_addr_t dma_addr;
+    int  buf_size; // total size of DMA
+} tcc_dma_buf_t;
+#endif
+
+struct tcc_uart_port {
+	unsigned char			rx_claimed;
+	unsigned char			tx_claimed;
+
+	struct tcc_uart_info	*info;
+	struct tcc_uart_clksrc	*clksrc;
+	struct clk				*clk;
+	struct clk				*baudclk;
+	struct uart_port		port;
+    wait_queue_head_t wait_q;
+    int    fifosize;
+    char *name;
+#ifdef CONFIG_SERIAL_TCC_DMA_TX
+    wait_queue_head_t wait_dma_q;
+	tcc_dma_buf_t	dma_tx_buffer;
+#endif
+	struct tcc_reg_info		reg;	// for suspend/resume
+};
+
+/* configuration defines */
+
+#if 0
+//#define dbg(x...) printk(KERN_DEBUG "tcc uart: ");
+#define dbg printk
+#else /* no debug */
+#define dbg(x...) do {} while(0)
+#endif
+
+/* UART name and device definitions */
+
+#define TCC_SERIAL_NAME	"ttySAC"
+#define TCC_SERIAL_MAJOR	204
+#define TCC_SERIAL_MINOR	64
+
+/* conversion functions */
+
+#define tcc_dev_to_port(__dev) (struct uart_port *)dev_get_drvdata(__dev)
+
+/* Number of serial ports */
+#define NR_PORTS (6)
+
+#define FIFOSIZE (16) /* defend on FCR */
+
+#define tx_enabled(port)	((port)->unused[0])
+#define rx_enabled(port)	((port)->unused[1])
+#define port_used(port)		((port)->unused1)
+
+static void tcc_serial_console_putchar(struct uart_port *port, int ch);
+extern void tcc_serial_uart_putchar(struct uart_port *port, int ch);
+
+int tcc_serial_init_ports(struct tcc_uart_port *ourport, struct tcc_uart_info *info, struct platform_device *pdev);
+
+static struct uart_ops tcc_serial_ops;
+
+static struct tcc_uart_port tcc_serial_ports[NR_PORTS] = {
+	[0] = {
+		.port = {
+			.lock		= __SPIN_LOCK_UNLOCKED(tcc_uart_port[0].port.lock),
+			.iotype		= UPIO_MEM,
+			.irq		= INT_UART0,
+			.uartclk	= 0,
+			.fifosize	= FIFOSIZE,
+			.ops		= &tcc_serial_ops,
+			.flags		= UPF_BOOT_AUTOCONF,
+			.line		= 0,
+		},
+        .name = "uart0"
+	},
+	[1] = {
+		.port = {
+			.lock		= __SPIN_LOCK_UNLOCKED(tcc_uart_port[1].port.lock),
+			.iotype		= UPIO_MEM,
+			.uartclk	= 0,
+			.irq		= INT_UART1,
+			.fifosize	= FIFOSIZE,
+			.ops		= &tcc_serial_ops,
+			.flags		= UPF_BOOT_AUTOCONF,
+			.line		= 1,
+		},
+        .name = "uart1"
+	},
+#if defined(_EXTRAUART_)
+	[2] = {
+		.port = {
+			.lock		= __SPIN_LOCK_UNLOCKED(tcc_uart_port[2].port.lock),
+			.iotype		= UPIO_MEM,
+			.irq		= INT_UART2,
+			.uartclk	= 0,
+			.fifosize	= FIFOSIZE,
+			.ops		= &tcc_serial_ops,
+			.flags		= UPF_BOOT_AUTOCONF,
+			.line		= 2,
+		},
+        .name = "uart2"
+	},
+	[3] = {
+		.port = {
+			.lock		= __SPIN_LOCK_UNLOCKED(tcc_uart_port[3].port.lock),
+			.iotype		= UPIO_MEM,
+			.irq		= INT_UART3,
+			.uartclk	= 0,
+			.fifosize	= FIFOSIZE,
+			.ops		= &tcc_serial_ops,
+			.flags		= UPF_BOOT_AUTOCONF,
+			.line		= 3,
+		},
+        .name = "uart3"
+	},
+	[4] = {
+		.port = {
+			.lock		= __SPIN_LOCK_UNLOCKED(tcc_uart_port[4].port.lock),
+			.iotype		= UPIO_MEM,
+			.irq		= INT_UART4,
+			.uartclk	= 0,
+			.fifosize	= FIFOSIZE,
+			.ops		= &tcc_serial_ops,
+			.flags		= UPF_BOOT_AUTOCONF,
+			.line		= 4,
+		},
+        .name = "uart4"
+	},
+	[5] = {
+		.port = {
+			.lock		= __SPIN_LOCK_UNLOCKED(tcc_uart_port[5].port.lock),
+			.iotype		= UPIO_MEM,
+			.irq		= INT_UART5,
+			.uartclk	= 0,
+			.fifosize	= FIFOSIZE,
+			.ops		= &tcc_serial_ops,
+			.flags		= UPF_BOOT_AUTOCONF,
+			.line		= 5,
+		},
+        .name = "uart5"
+	},
+#endif
+
+};
+
+#ifdef CONFIG_SERIAL_TCC_DMA_RX
+
+void kerneltimer_registertimer(struct timer_list* ptimer, unsigned long timeover,struct uart_port *port )
+{
+     init_timer( ptimer );
+     ptimer->expires  = get_jiffies_64() + timeover;
+     ptimer->data     = (unsigned long)port;
+     ptimer->function = (void *)kerneltimer_timeover;
+     add_timer( ptimer);
+}
+
+void my_uart_rx_process(unsigned long arg)
+{
+    volatile int current_tail,current_head, i, rts_state;
+    struct uart_port *port;
+    unsigned int ch = 0;
+    unsigned uerstat = 0, flag;
+    struct tty_struct *tty;
+    unsigned char *buffer;
+
+    volatile PGDMACTRL pDMA = (volatile PGDMACTRL)tcc_p2v(HwGDMA_BASE);
+    int cur_addr = tca_dma_dmacurrentaddress(DMA_CH_NUM_RX, (unsigned long *)pDMA);
+
+    port = (struct uart_port *)arg;
+    buffer = (unsigned char *)dma_rx_buffer;
+    current_tail = rx_dma_tail & (DMA_RX_BUF_SIZE-1);
+    current_head = cur_addr & (DMA_RX_BUF_SIZE-1);
+
+    if (current_head != current_tail) {
+      if (current_head > current_tail) rts_state = current_head - current_tail;
+      else rts_state = DMA_RX_BUF_SIZE - current_tail - current_head;
+      if (rts_state > 2048) {
+        printk("RTS ON[0x%x : 0x%x]\n", cur_addr, current_tail);
+        wr_regl(port, OFFSET_MCR, rd_regl(port, OFFSET_MCR) & ~Hw1);
+      }
+
+      spin_lock(port->lock);
+      tty = port->info->port.tty;
+
+      flag = TTY_NORMAL;
+      port->icount.rx++;
+
+      if (uerstat & UART_LSR_BI) {
+          port->icount.brk++;
+          goto out;
+      }
+
+      if (uerstat & UART_LSR_FE)
+          port->icount.frame++;
+      if (uerstat & UART_LSR_OE)
+          port->icount.overrun++;
+
+      uerstat &= port->read_status_mask;
+
+      if (uerstat & UART_LSR_BI)
+          flag = TTY_BREAK;
+      else if (uerstat & UART_LSR_PE)
+          flag = TTY_PARITY;
+      else if (uerstat & ( UART_LSR_FE | UART_LSR_OE))
+          flag = TTY_FRAME;
+
+      if (current_head < current_tail) current_head += (DMA_RX_BUF_SIZE);
+      for(i=current_tail;i<current_head;i++) {
+          if (timer_state == 0) break;
+          if (i >= DMA_RX_BUF_SIZE)
+            ch = buffer[i-DMA_RX_BUF_SIZE];
+          else
+            ch = buffer[i];
+
+          if (uart_handle_sysrq_char(port, ch))
+              goto out;
+          /* put the received char into UART buffer */
+          uart_insert_char(port, uerstat, UART_LSR_OE, ch, flag);
+          tty_flip_buffer_push(tty);
+          rx_dma_tail++;
+      }
+
+      if (rts_state > 2048) {
+        printk("RTS OFF\n");
+        wr_regl(port, OFFSET_MCR, rd_regl(port, OFFSET_MCR) | Hw1);
+      }
+out:
+    spin_unlock(port->lock);
+    }
+}
+
+void *kerneltimer_timeover(void *arg )
+{
+    volatile PGDMACTRL pDMA = (volatile PGDMACTRL)tcc_p2v(HwGDMA_BASE);
+    int cur_addr = tca_dma_dmacurrentaddress(DMA_CH_NUM_RX, (unsigned long *)pDMA);
+
+    if (start_value == cur_addr) {
+    if (start_value == 0x20000000) my_uart_rx_process((unsigned long)arg);
+  } else {
+    if (start_value != 0x20000000) {
+        rx_dma_tail = (int) dma_rx_buffer_physical;
+        start_value = 0x20000000;
+    }
+
+    my_uart_rx_process((unsigned long)arg);
+  }
+
+  if (timer_state == 1)
+    kerneltimer_registertimer( timer, TIME_STEP,arg );
+
+  return 0;
+}
+
+int kerneltimer_init(struct uart_port *port)
+{
+    timer= kmalloc( sizeof( struct timer_list ), GFP_KERNEL );
+    if( timer== NULL ) return -ENOMEM;
+    memset( timer, 0, sizeof( struct timer_list) );
+    kerneltimer_registertimer( timer,TIME_STEP,port );
+
+    return 0;
+}
+#endif
+
+static inline struct tcc_uart_port *to_ourport(struct uart_port *port)
+{
+	return container_of(port, struct tcc_uart_port, port);
+}
+
+/* translate a port to the device name */
+
+static inline const char *tcc_serial_portname(struct uart_port *port)
+{
+	return to_platform_device(port->dev)->name;
+}
+
+
+static void tcc_serial_stop_tx(struct uart_port *port)
+{
+    while(!(rd_regl(port, OFFSET_LSR)) & TEMT)
+        continue;
+
+    if(tx_enabled(port)){
+        disable_irq(port->irq);
+#ifdef CONFIG_SERIAL_TCC_DMA_TX
+       // disable_irq(DMA_TX_INT);
+#endif
+        tx_enabled(port) = 0;
+    }
+}
+
+static int get_writable_fifo_size(struct uart_port *port)
+{
+    unsigned int ier; 
+
+#ifdef CONFIG_SERIAL_TCC_DMA_TX
+	struct circ_buf *xmit = &port->info->xmit;
+    int tmp;
+#endif
+    ier = rd_regl(port, OFFSET_IER);
+
+    wr_regl(port, OFFSET_IER, ier | Hw1);
+
+#ifdef CONFIG_SERIAL_TCC_DMA_TX
+    if (interruptible_sleep_on_timeout(&(tcc_serial_ports[port->line].wait_q), TIMEOUT) != 0) {
+        if(port->line== DMA_PORT) {
+            int f_size = 0;
+            tmp = xmit->head - xmit->tail;
+            f_size = ((tmp > 0) ? tmp : UART_XMIT_SIZE + tmp);
+            if (f_size > FIFOSIZE) {
+                f_size = FIFOSIZE;
+            }
+            return f_size;
+        } else {
+            return FIFOSIZE;
+        }
+    }
+
+    if(port->line== DMA_PORT) {
+        tmp = xmit->head - xmit->tail;
+        return ((tmp > 0) ? tmp : UART_XMIT_SIZE + tmp);
+    } else if (interruptible_sleep_on_timeout(&(tcc_serial_ports[port->line].wait_q), TIMEOUT) != 0) {
+        return FIFOSIZE;
+    }
+#else
+
+
+    if (interruptible_sleep_on_timeout(&(tcc_serial_ports[port->line].wait_q), TIMEOUT) != 0) {
+        return FIFOSIZE;
+    }
+#endif
+    return 0;
+}
+
+static void update_fifo_size(struct uart_port *port)
+{
+#ifdef CONFIG_SERIAL_TCC_DMA_TX
+    if(port->line == DMA_PORT)
+        tcc_serial_ports[port->line].fifosize = get_writable_fifo_size(port);
+    else if (tcc_serial_ports[port->line].fifosize <= 0) 
+        tcc_serial_ports[port->line].fifosize = get_writable_fifo_size(port);
+#else 
+ 
+    if (tcc_serial_ports[port->line].fifosize <= 0) {
+        tcc_serial_ports[port->line].fifosize = get_writable_fifo_size(port);
+    }
+#endif
+}
+
+static void tcc_serial_start_tx(struct uart_port *port)
+{
+	struct circ_buf *xmit = &port->info->xmit;
+	unsigned long flags;
+#ifdef CONFIG_SERIAL_TCC_DMA_TX
+    struct tcc_uart_port *ourport;
+    volatile PGDMACTRL pDMA = (volatile PGDMACTRL)tcc_p2v(HwGDMA_BASE);
+#endif
+
+    if(!tx_enabled(port)) {
+        enable_irq(port->irq);
+#ifdef CONFIG_SERIAL_TCC_DMA_TX
+       // enable_irq(DMA_TX_INT);
+#endif
+        tx_enabled(port) = 1;
+    }
+
+	local_irq_save(flags);
+	if (port->x_char) {
+        update_fifo_size(port);
+        if (tcc_serial_ports[port->line].fifosize > 0) {
+
+            tcc_serial_uart_putchar(port, port->x_char);
+            port->icount.tx++;
+            port->x_char = 0;
+            tcc_serial_ports[port->line].fifosize--;
+        }
+	}
+
+     if (uart_circ_empty(xmit) || uart_tx_stopped(port)) {
+         tcc_serial_stop_tx(port);
+         goto out;
+     }
+	
+     while(!(uart_circ_empty(xmit))) {
+        update_fifo_size(port);
+
+        if (tcc_serial_ports[port->line].fifosize > 0) {
+#ifdef CONFIG_SERIAL_TCC_DMA_TX
+            if(port->line==DMA_PORT)
+            {
+                ourport = &tcc_serial_ports[port->line];
+
+                 if(tcc_serial_ports[DMA_PORT].fifosize > 0)
+                 {
+                     wr_regl(port, OFFSET_UCR, rd_regl(port, OFFSET_UCR) & ~Hw0);
+                     memcpy(tcc_serial_ports[DMA_PORT].dma_tx_buffer.addr, (xmit->buf+xmit->tail),tcc_serial_ports[DMA_PORT].fifosize );
+
+                     //DMA Setting
+                     tca_dma_setconfig(DMA_TX_CH_NUM,
+                                       (void *)tcc_serial_ports[DMA_PORT].dma_tx_buffer.dma_addr, 	
+                                       0x1, /* src Param */
+                                       portaddr(port, 0x0), 
+                                       0x0, /* dest Param */
+                                       HwCHCTRL_SYNC_EN        |
+                                       HwCHCTRL_TYPE_SL        |
+                                       HwCHCTRL_BSIZE_1        |
+                                       HwCHCTRL_WSIZE_8        |
+                                       HwCHCTRL_IEN_ON         |
+                                       HwCHCTRL_FLAG           ,
+                                       tcc_serial_ports[DMA_PORT].fifosize	,
+                                       DMA_PORT, 
+                                       DMA_TX_MODE, /* mode */
+                                       (unsigned long *)pDMA);
+ 
+                     wr_regl(port, OFFSET_UCR, rd_regl(port, OFFSET_UCR) |Hw0);
+                     interruptible_sleep_on_timeout(&(tcc_serial_ports[port->line].wait_dma_q), TIMEOUT);
+
+                     xmit->tail = (xmit->tail + tcc_serial_ports[DMA_PORT].fifosize) & (UART_XMIT_SIZE - 1);
+                     
+                     port->icount.tx+= tcc_serial_ports[port->line].fifosize;
+                     //tcc_serial_ports[port->line].fifosize-=tcc_serial_ports[DMA_PORT].fifosize;
+                     tcc_serial_ports[port->line].fifosize = 0;
+                 }
+
+             } else {
+                 tcc_serial_uart_putchar(port, xmit->buf[xmit->tail]);
+                 xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+                 port->icount.tx++;
+                 tcc_serial_ports[port->line].fifosize--;
+             }
+#else
+         tcc_serial_uart_putchar(port, xmit->buf[xmit->tail]);
+         xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+         port->icount.tx++;
+         tcc_serial_ports[port->line].fifosize--;
+
+#endif
+         }// if (tcc_serial_ports[port->line].fifosize > 0) 
+     }// while(!(uart_circ_empty(xmit))) 
+
+    if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+        uart_write_wakeup(port);
+
+out:
+	local_irq_restore(flags);
+}
+
+
+static void tcc_serial_stop_rx(struct uart_port *port)
+{
+	dbg("%s\n", __func__);
+    if (rx_enabled(port)) {
+        disable_irq(port->irq);
+#ifdef CONFIG_SERIAL_TCC_DMA_TX
+       // disable_irq(DMA_TX_INT);
+#endif
+        rx_enabled(port) = 0;
+    }
+
+}
+
+static void tcc_serial_enable_ms(struct uart_port *port)
+{
+	dbg("%s\n", __func__);
+}
+
+static inline struct tcc_uart_info *tcc_port_to_info(struct uart_port *port)
+{
+	return to_ourport(port)->info;
+}
+
+#ifdef CONFIG_SERIAL_TCC_DMA_TX
+static irqreturn_t tcc_serial_interrupt_dma(int irq, void *id)
+{
+	struct uart_port *port = id;
+    volatile PGDMACTRL pDMA = (volatile PGDMACTRL)tcc_p2v(HwGDMA_BASE);
+
+    spin_lock(port->lock);
+    if (port->line == DMA_PORT) {
+        /* XXX */
+        //tca_dma_clrien(DMA_TX_CH_NUM, (unsigned long *)pDMA);
+        //tca_serial_dmaclrinterrupt(DMA_TX_CH_NUM, (unsigned long *)pDMA);
+        wake_up(&(tcc_serial_ports[port->line].wait_dma_q));
+        tca_dma_clrien(DMA_TX_CH_NUM, (unsigned long *)pDMA);
+        tca_serial_dmaclrinterrupt(DMA_TX_CH_NUM, (unsigned long *)pDMA);
+    }
+    spin_unlock(port->lock);
+	return IRQ_HANDLED;
+}
+#endif
+
+
+static irqreturn_t tcc_serial_interrupt(int irq, void *id)
+{
+	unsigned int ch = 0;
+	struct uart_port *port = id;
+	unsigned uerstat, flag;
+	struct tty_struct *tty = port->info->port.tty;
+    int rx_flag = 0;
+    unsigned int iir_data = 0;
+    unsigned int t_ier;
+    
+    uerstat = 0;
+	
+    spin_lock(port->lock);
+
+    iir_data = rd_regl(port, OFFSET_IIR);
+    iir_data = (iir_data & 0x0E) >> 1;
+    if (iir_data & 0x02 || iir_data & 0x06) {
+        ch = rd_regb(port, OFFSET_RBR);
+        rx_flag = 1;
+    } else if (iir_data & 0x01) {
+        t_ier = rd_regl(port, OFFSET_IER);
+        wr_regl(port, OFFSET_IER, (t_ier & ~Hw1));
+
+        wake_up(&(tcc_serial_ports[port->line].wait_q));
+    }
+
+
+#ifdef CONFIG_SERIAL_TCC_DMA_RX
+    if(port->line != DMA_PORT) {
+ #endif
+
+    if (rx_flag) {
+        flag = TTY_NORMAL;
+        port->icount.rx++;
+
+        if (uerstat & UART_LSR_BI) {
+            dbg("break!\n");
+            port->icount.brk++;
+            goto out;
+        }
+
+        if (uerstat & UART_LSR_FE)
+            port->icount.frame++;
+        if (uerstat & UART_LSR_OE)
+            port->icount.overrun++;
+
+        uerstat &= port->read_status_mask;
+
+        if (uerstat & UART_LSR_BI)
+            flag = TTY_BREAK;
+        else if (uerstat & UART_LSR_PE)
+            flag = TTY_PARITY;
+        else if (uerstat & ( UART_LSR_FE | UART_LSR_OE))
+            flag = TTY_FRAME;
+
+        if (uart_handle_sysrq_char(port, ch))
+            goto out;
+        /* put the received char into UART buffer */
+        uart_insert_char(port, uerstat, UART_LSR_OE, ch, flag);
+
+        tty_flip_buffer_push(tty);
+    }
+
+#ifdef CONFIG_SERIAL_TCC_DMA_RX
+    }
+#endif
+
+
+out:
+    spin_unlock(port->lock);
+	return IRQ_HANDLED;
+}
+
+static unsigned int tcc_serial_tx_empty(struct uart_port *port)
+{
+	unsigned short lsr;
+
+	lsr = rd_regl(port, OFFSET_LSR);
+	if (lsr & TEMT)
+		return TIOCSER_TEMT;
+	else
+		return 0;
+
+}
+
+static unsigned int tcc_serial_get_mctrl(struct uart_port *port)
+{
+	dbg("%s\n", __func__);
+    return TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;
+}
+
+static void tcc_serial_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	dbg("%s\n", __func__);
+	/* todo - possibly remove AFC and do manual CTS */
+}
+
+static void tcc_serial_break_ctl(struct uart_port *port, int break_state)
+{
+	dbg("%s\n", __func__);
+}
+
+static void tcc_serial_shutdown(struct uart_port *port)
+{
+
+#ifdef CONFIG_SERIAL_TCC_DMA_RX
+    if(port->line == DMA_PORT)
+    {
+      timer_state=0;
+      mdelay(1);
+      kfree(timer);
+    }
+#endif
+
+    wr_regl(port, OFFSET_IER, 0x0);
+    free_irq(port->irq, port);
+#ifdef CONFIG_SERIAL_TCC_DMA_TX
+	if(port->line == DMA_PORT)
+    	free_irq(DMA_TX_INT, port);
+#endif
+	port_used(port) = 0;	// for suspend/resume
+}
+
+int pwr_ioctl_uart(int onoff, struct uart_port *port )
+{
+	static int flag=1;
+
+    volatile PGPIO pGPIO = (volatile PGPIO)tcc_p2v(HwGPIO_BASE);
+    volatile PPIC tPIC = (volatile PPIC)tcc_p2v(HwPIC_BASE);
+
+    if (onoff) // ON 
+    {
+        tx_enabled(port) = 1;
+        rx_enabled(port) = 1;
+        port_used(port) = 1;	// for suspend/resume
+
+        if(port->line == UART1){
+            tcc_pca953x_setup(PCA9539_U3_SLAVE_ADDR, BT_ON, OUTPUT, HIGH, SET_DIRECTION|SET_VALUE);
+            dbg("tcc_uart: BT power %s\n", (tcc_pca953x_setup(PCA9539_U3_SLAVE_ADDR, 0, OUTPUT, 0, GET_VALUE)&BT_ON)?"ON":"OFF");
+        }
+
+        tca_ckc_setiobus(port->line + RB_UARTCONTROLLER0 , 1);
+        tca_ckc_setperi(port->line + PERI_UART0,ENABLE,520000,PCDIRECTPLL2);
+
+        if(port->line == 0) {
+            pGPIO->GPEEN    |= (Hw1|Hw0);
+            pGPIO->GPEFN0   |= (Hw4|Hw0); // UTXD0, URXD0
+
+        } else if(port->line == 1) {
+            pGPIO->GPEEN    |= (Hw4|Hw5|Hw6|Hw7);
+            BITCLR(pGPIO->GPEFN0, Hw31-Hw16);
+            pGPIO->GPEFN0   |= (Hw28|Hw24|Hw20|Hw16); // UTXD1, URXD1, 
+        }
+
+        tPIC->INTMSK1   |= Hw15;
+
+		flag = 1;
+    } 
+    else  // OFF
+    {
+		if (!flag)
+			return 0;
+
+        tx_enabled(port) = 0;
+        rx_enabled(port) = 0;
+        port_used(port) = 0;	// for suspend/resume
+ 
+        if(port->line == UART1){
+            tcc_pca953x_setup(PCA9539_U3_SLAVE_ADDR, BT_ON, OUTPUT, LOW, SET_DIRECTION|SET_VALUE);
+            dbg("tcc_uart: BT power %s\n", (tcc_pca953x_setup(PCA9539_U3_SLAVE_ADDR, 0, OUTPUT, 0, GET_VALUE)&BT_ON)?"ON":"OFF");
+        }
+
+        if(port->line == 0) {
+            pGPIO->GPEEN    &= ~(Hw1|Hw0);
+            BITCLR(pGPIO->GPEFN0, Hw8-Hw0);
+            BITCLR(pGPIO->GPEDAT, Hw4-Hw0);
+        } else if(port->line == 1) {
+            pGPIO->GPEEN    &= ~(Hw4|Hw5|Hw6|Hw7);
+            BITCLR(pGPIO->GPEFN0, Hw31-Hw16);
+            BITCLR(pGPIO->GPEDAT, Hw8-Hw4);
+        }
+
+        tPIC->INTMSK1   &= ~Hw15;
+
+		flag = 0;
+    }
+
+	return 0;
+}
+
+static stpwrinfo pwrinfo = {PWR_STATUS_ON};
+
+static int uart_pwr_ctl(void *h_private, int cmd, void *p_out)
+{
+    switch (cmd) {
+    case PWR_CMD_OFF:
+        dbg("PWR_CMD_OFF command ==> [%d]\n", cmd);
+        pwr_ioctl_uart(0, h_private);
+        pwrinfo.status = PWR_STATUS_OFF;
+        break;
+    case PWR_CMD_ON:
+        dbg("PWR_CMD_ON command ==> [%d]\n", cmd);
+        pwr_ioctl_uart(1, h_private);
+        pwrinfo.status = PWR_STATUS_ON;
+        break;
+    case PWR_CMD_GETSTATUS:
+        dbg("PWR_CMD_GETSTATUS command ==> [%d], status:[%d]\n", cmd, pwrinfo.status);
+        memcpy(p_out, &pwrinfo, sizeof(stpwrinfo));
+        break;
+//  case PWR_CMD_MAX:
+//      dbg ("PWR_CMD_MAX command ==> [%d]\n", cmd);
+//      break;
+    default:
+        printk("unknown pwr command !!! ==> [%d]\n", cmd);
+        break;
+    }
+    return 0;
+}
+
+
+/* while application opening the console device, this function will invoked
+ * This function will initialize the interrupt handling 
+ */
+static int tcc_serial_startup(struct uart_port *port)
+{
+	int retval=0;
+	unsigned int lcr;
+	
+    volatile PPIC tPIC = (volatile PPIC)tcc_p2v(HwPIC_BASE);
+    volatile PGPIO pGPIO = (volatile PGPIO)tcc_p2v(HwGPIO_BASE);
+#ifdef CONFIG_SERIAL_TCC_DMA_RX
+    volatile PGDMACTRL pDMA = (volatile PGDMACTRL)tcc_p2v(HwGDMA_BASE);
+#endif
+    
+    if(port->line == UART1){
+        tcc_pca953x_setup(PCA9539_U3_SLAVE_ADDR, BT_ON, OUTPUT, HIGH, SET_DIRECTION|SET_VALUE);
+        dbg("tcc_uart: BT power %s\n", (tcc_pca953x_setup(PCA9539_U3_SLAVE_ADDR, 0, OUTPUT, 0, GET_VALUE)&BT_ON)?"ON":"OFF");
+    }
+
+
+    tx_enabled(port) = 1;
+    rx_enabled(port) = 1;
+	port_used(port) = 1;	// for suspend/resume
+
+    tca_ckc_setiobus(port->line + RB_UARTCONTROLLER0 , 1);
+    tca_ckc_setperi(port->line + PERI_UART0,ENABLE,520000,PCDIRECTPLL2);
+
+#if 0
+    tca_serial_portinit(0, port->line, &pGPIO, &pPORTMUX);
+#else
+    if(port->line == 0) {
+        pGPIO->GPEEN    |= (Hw1|Hw0);
+        pGPIO->GPEFN0   |= (Hw4|Hw0); // UTXD0, URXD0
+
+    } else if(port->line == 1) {
+        pGPIO->GPEEN    |= (Hw4|Hw5|Hw6|Hw7);
+		BITCLR(pGPIO->GPEFN0, Hw31-Hw16);
+        pGPIO->GPEFN0   |= (Hw28|Hw24|Hw20|Hw16); // UTXD1, URXD1, 
+    }
+#endif
+
+
+    wr_regl(port, OFFSET_IER, 0x0);
+    
+    lcr = rd_regl(port, OFFSET_LCR);
+    wr_regl(port, OFFSET_LCR, (lcr | Hw7));
+    
+    wr_regl(port, OFFSET_FCR, 0x07);
+    tcc_serial_ports[port->line].fifosize = FIFOSIZE;
+    tcc_serial_ports[port->line].reg.bFCR = 0x07;		// for resume restore
+
+    wr_regl(port, OFFSET_LCR, (lcr & (~Hw7)));
+
+    rd_regl(port, OFFSET_IIR);
+    
+    retval = request_irq(port->irq, tcc_serial_interrupt, IRQF_SHARED, tcc_serial_ports[port->line].name , port);
+    dbg("request serial irq:%d,retval:%d\n", port->irq, retval);
+
+#ifdef CONFIG_SERIAL_TCC_DMA_TX
+    if(port->line == DMA_PORT)
+    	retval = request_irq(DMA_TX_INT, tcc_serial_interrupt_dma, IRQF_SHARED, "uart1_dma" , port);
+    dbg("request serial dma irq:%d,retval:%d\n", DMA_TX_INT, retval);
+    //pDMA->CHCTRL0 |= Hw2;
+#endif
+
+#ifdef CONFIG_SERIAL_TCC_DMA_RX
+{
+    int cur_addr = tca_dma_dmacurrentaddress(DMA_CH_NUM_RX, (unsigned long *)pDMA);
+
+    if(port->line == DMA_PORT) {
+
+      printk("rx_dma_tail : %x\n",rx_dma_tail);
+
+      wr_regl(port, OFFSET_MCR, rd_regl(port, OFFSET_MCR) | Hw5);
+      wr_regl(port, OFFSET_MCR, rd_regl(port, OFFSET_MCR) | Hw1);
+      wr_regl(port, OFFSET_AFT, 0x00000021);
+        // Set Source Address & Source Parameter (mask + increment)
+
+        wr_regl(port, OFFSET_UCR, rd_regl(port, OFFSET_UCR) & ~Hw1);
+
+        tca_dma_setconfig(DMA_CH_NUM_RX,
+                          portaddr(port, 0x0), 
+                          0x0, /* src Param */
+                          dma_rx_buffer_physical,
+                          0x1, /* dest Param */
+                          //HwCHCTRL_CONT_C         |
+                          HwCHCTRL_SYNC_EN        |
+                          HwCHCTRL_TYPE_SL        |
+                          HwCHCTRL_BSIZE_1        |
+                          HwCHCTRL_WSIZE_8        |
+                       //   HwCHCTRL_IEN_ON         |
+                          HwCHCTRL_REP_EN         |
+                          HwCHCTRL_FLAG           ,
+                          DMA_RX_BUF_SIZE ,
+                          DMA_PORT, 
+                          DMA_RX_MODE, /* mode */
+                          (unsigned long *)pDMA);
+
+      wr_regl(port, OFFSET_UCR, rd_regl(port, OFFSET_UCR) |Hw1);
+
+      start_value = cur_addr;
+      if (cur_addr != 0x20000000)
+        rx_dma_tail = cur_addr;   			
+      else
+        rx_dma_tail = (int) dma_rx_buffer_physical;
+      timer_state=1;
+      kerneltimer_init(port);
+    }
+}
+#endif
+
+	
+    //wr_regl(port, OFFSET_IER, ERXI);
+    wr_regl(port, OFFSET_IER, ERXI | ETXI);
+#ifdef CONFIG_SERIAL_TCC_DMA_RX
+    if(port->line == DMA_PORT) {
+      printk("line %d IER tx Only\n", port->line);
+      wr_regl(port, OFFSET_IER, ETXI);
+    }
+#endif
+
+    //tca_serial_intrdone();
+    tPIC->INTMSK1   |= Hw15;
+
+	return retval;
+}
+
+/* power power management control */
+
+static void tcc_serial_pm(struct uart_port *port, unsigned int level, unsigned int old)
+{
+}
+
+
+static inline int tcc_serial_setsource(struct uart_port *port, struct tcc_uart_clksrc *c)
+{
+	return 0;
+}
+
+static void tcc_serial_set_termios(struct uart_port *port,
+				       struct ktermios *termios,
+				       struct ktermios *old)
+{
+	unsigned long flags;
+	unsigned int baud, quot;
+	unsigned int ulcon;
+	//unsigned int umcon;
+	unsigned int umcon, lsr;
+    int uart_clk = 0;
+
+	/*
+	 * We don't support modem control lines.
+	 */
+	termios->c_cflag &= ~(HUPCL | CMSPAR);
+	termios->c_cflag |= CLOCAL;
+
+	/*
+	 * Ask the core to calculate the divisor for us.
+	 */
+
+	baud = uart_get_baud_rate(port, termios, old, 0, 3500000);
+    uart_clk = (unsigned int)tca_ckc_getperi(port->line + PERI_UART0);
+	quot = (uart_clk*100)/(16*baud); 
+
+    /*
+     * set byte size
+     */
+	switch (termios->c_cflag & CSIZE) {
+	case CS5:
+		dbg("config: 5bits/char\n");
+		ulcon = 0;
+		break;
+	case CS6:
+		dbg("config: 6bits/char\n");
+		ulcon = 1;
+		break;
+	case CS7:
+		dbg("config: 7bits/char\n");
+		ulcon = 2;
+		break;
+	case CS8:
+	default:
+		dbg("config: 8bits/char\n");
+		ulcon = 3;
+		break;
+	}
+
+	/* preserve original lcon IR settings */
+	
+	if (termios->c_cflag & CSTOPB)
+		ulcon |= (1<<2); /* HwUART_LCR_STB_ONE */
+
+	umcon = (termios->c_cflag & CRTSCTS) ? (Hw5|Hw1) : 0; /* HwUART_MCR_RTS_ON */
+
+	if (termios->c_cflag & PARENB) {
+		if (termios->c_cflag & PARODD)
+			ulcon |= ((0<<4)|(1<<3));
+		else
+			ulcon |= ((1<<4)|(1<<3));
+	} else {
+		ulcon |= (0<<3);
+	}
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	do {
+		lsr = rd_regl(port, OFFSET_LSR);
+	} while (!(lsr & TEMT));
+
+	dbg("setting ulcon to %08x, brddiv to %d\n", ulcon, quot);
+
+    wr_regl(port, OFFSET_MCR, umcon);
+    wr_regl(port, OFFSET_LCR, (ulcon | (1<<7)));
+    if(quot > 0xFF) {
+        wr_regl(port, OFFSET_DLL, 0x00FF);
+        wr_regl(port, OFFSET_DLM, quot >> 8);
+    }else if (quot > 0) {
+        wr_regl(port, OFFSET_DLL, quot);
+        wr_regl(port, OFFSET_DLM, 0x0);
+    }
+    wr_regl(port, OFFSET_LCR, (ulcon & (~(1<<7))));
+
+	/*
+	 * Update the per-port timeout.
+	 */
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+	/*
+	 * Which character status flags are we interested in?
+	 */
+	port->read_status_mask = 0;
+	if (termios->c_iflag & INPCK)
+		port->read_status_mask |= 0;
+
+	/*
+	 * Which character status flags should we ignore?
+	 */
+	port->ignore_status_mask = 0;
+	if (termios->c_iflag & IGNPAR)
+		port->ignore_status_mask |= 0;
+	if (termios->c_iflag & IGNBRK && termios->c_iflag & IGNPAR)
+		port->ignore_status_mask |= 0;
+
+	/*
+	 * Ignore all characters if CREAD is not set.
+	 */
+	if ((termios->c_cflag & CREAD) == 0)
+		port->ignore_status_mask |= 0;
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static const char *tcc_serial_type(struct uart_port *port)
+{
+    return tcc_serial_ports[port->line].name;
+}
+
+#define MAP_SIZE (0x100)
+
+static void tcc_serial_release_port(struct uart_port *port)
+{
+    /* TODO */
+	//release_mem_region(port->mapbase, MAP_SIZE);
+}
+
+static int tcc_serial_request_port(struct uart_port *port)
+{
+    return 0;
+    /*
+	return request_mem_region(port->mapbase, MAP_SIZE, "tcc7901") ? 0 : -EBUSY;
+    */
+}
+
+static void tcc_serial_config_port(struct uart_port *port, int flags)
+{
+	if (flags & UART_CONFIG_TYPE && tcc_serial_request_port(port) == 0)
+        port->type = PORT_TCC;
+}
+
+/*
+ * verify the new serial_struct (for TIOCSSERIAL).
+ */
+static int
+tcc_serial_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	struct tcc_uart_info *info = tcc_port_to_info(port);
+
+	if (ser->type != PORT_UNKNOWN && ser->type != info->type)
+		return -EINVAL;
+	return 0;
+}
+
+
+#ifdef CONFIG_SERIAL_TCC_CONSOLE
+
+static struct console tcc_serial_console;
+
+#define TCC_SERIAL_CONSOLE &tcc_serial_console
+#else
+#define TCC_SERIAL_CONSOLE NULL
+#endif
+
+static struct uart_ops tcc_serial_ops = {
+	.pm				= tcc_serial_pm,
+	.tx_empty		= tcc_serial_tx_empty,
+	.get_mctrl		= tcc_serial_get_mctrl,
+	.set_mctrl		= tcc_serial_set_mctrl,
+	.stop_tx		= tcc_serial_stop_tx,
+	.start_tx		= tcc_serial_start_tx,
+	.stop_rx		= tcc_serial_stop_rx,
+	.enable_ms		= tcc_serial_enable_ms,
+	.break_ctl		= tcc_serial_break_ctl,
+	.startup		= tcc_serial_startup,
+	.shutdown		= tcc_serial_shutdown,
+	.set_termios	= tcc_serial_set_termios,
+	.type			= tcc_serial_type,
+	.release_port	= tcc_serial_release_port,
+	.request_port	= tcc_serial_request_port,
+	.config_port	= tcc_serial_config_port,
+	.verify_port	= tcc_serial_verify_port,
+};
+
+
+static struct uart_driver tcc_uart_drv = {
+	.owner		= THIS_MODULE,
+	.dev_name	= "tcc-uart",
+	.nr		    = NR_PORTS,
+	.cons		= TCC_SERIAL_CONSOLE,
+	.driver_name    = TCC_SERIAL_NAME,
+	.major		= TCC_SERIAL_MAJOR,
+	.minor		= TCC_SERIAL_MINOR,
+};
+
+
+/*  initialise  serial port information */
+/* cpu specific variations on the serial port support */
+
+#if 0
+static int tcc_serial_getsource(struct uart_port *port,
+				    struct tcc_uart_clksrc *clk)
+{
+	return 0;
+}
+#endif
+
+static struct tcc_uart_info tcc_uart_inf = {
+	.name		    = "Telechips UART",
+	.type	    	= PORT_TCC,
+	.fifosize   	= FIFOSIZE,
+};
+
+#ifdef CONFIG_SERIAL_TCC_DMA_TX
+static void *tcc_free_dma_buf(tcc_dma_buf_t *dma_buf)
+{
+	dbg("%s\n", __func__);
+    if (dma_buf) {
+        if (dma_buf->dma_addr != 0) {
+            dma_free_writecombine(0, dma_buf->buf_size, dma_buf->addr, dma_buf->dma_addr);
+        }
+        memset(dma_buf, 0, sizeof(tcc_dma_buf_t));
+    }
+    return NULL;
+}
+
+static void *tcc_malloc_dma_buf(tcc_dma_buf_t *dma_buf, int buf_size)
+{
+
+
+	dbg("%s\n", __func__);
+    if (dma_buf) {
+        tcc_free_dma_buf(dma_buf);
+        dma_buf->buf_size = buf_size;
+        dma_buf->addr = dma_alloc_writecombine(0, dma_buf->buf_size, &dma_buf->dma_addr, GFP_KERNEL);
+        dbg("Malloc DMA buffer @0x%X(Phy=0x%X), size:%d\n",
+               (unsigned int)dma_buf->addr,
+               (unsigned int)dma_buf->dma_addr,
+               dma_buf->buf_size);
+        return dma_buf->addr;
+    }
+    return NULL;
+}
+#endif
+
+
+static int probe_index = 0;
+
+static int tcc_uart_probe(struct platform_device *dev, struct tcc_uart_info *info)
+{
+	int ret;
+    struct tcc_uart_port *ourport;
+
+    volatile PPIC pPIC = (volatile PPIC)tcc_p2v(HwPIC_BASE);
+#ifdef CONFIG_SERIAL_TCC_DMA_TX
+    volatile PGDMACTRL pDMA = (volatile PGDMACTRL)tcc_p2v(HwGDMA_BASE);
+#endif
+	
+	dbg("%s\n", __func__);
+    
+    //tca_serial_intrinit();
+    pPIC->SEL1      |= Hw15;
+    pPIC->INTMSK1   |= Hw15;
+    pPIC->MODE1     |= Hw15;    // Level trigger
+
+    ourport = &tcc_serial_ports[probe_index];
+
+    probe_index++;
+
+    //insert_pwm_node(DEVICE_UART, uart_pwr_ctl, &ourport->port);
+
+    ret = tcc_serial_init_ports(ourport, info, dev);
+    init_waitqueue_head(&(ourport->wait_q));
+
+#ifdef CONFIG_SERIAL_TCC_DMA_TX
+    init_waitqueue_head(&(ourport->wait_dma_q));
+#endif
+
+    if (ret < 0){
+        dbg("tcc_serial_init_ports failure\n");
+        goto probe_err;
+    }
+
+    ret = uart_add_one_port(&tcc_uart_drv, &ourport->port);
+
+    if (ret){
+        dbg("uart_add_one_port failure\n");
+        return ret;
+    }
+
+    platform_set_drvdata(dev, &ourport->port);
+
+#ifdef CONFIG_SERIAL_TCC_DMA_TX
+    if((&ourport->port)->line == DMA_PORT) {
+        if (!tcc_malloc_dma_buf(&(tcc_serial_ports[DMA_PORT].dma_tx_buffer), DMA_BUF_SIZE)) {
+            dbg("Unable to attach UART TX DMA 1 channel\n");
+                ret = -ENOMEM;
+            goto probe_err;
+            }
+    }
+    tca_dma_setien(DMA_TX_CH_NUM, (unsigned long *)pDMA);
+#endif
+
+#ifdef CONFIG_SERIAL_TCC_DMA_RX
+    if((&ourport->port)->line == DMA_PORT)
+    {
+        dma_rx_buffer = dma_alloc_writecombine(0, DMA_RX_BUF_SIZE, &dma_rx_buffer_physical, GFP_KERNEL);
+        if (dma_rx_buffer == 0) {
+            dbg("Unable to attach UART RX DMA 5 channel\n");
+                return -ENOMEM;
+        }
+        rx_dma_tail = (int) dma_rx_buffer_physical;
+    }
+#endif
+
+	return ret;
+
+probe_err:
+    dbg("probe_err\n");
+	return ret;
+}
+
+
+static int tcc_serial_remove(struct platform_device *dev)
+{
+	struct uart_port *port = tcc_dev_to_port(&dev->dev);
+#ifdef CONFIG_SERIAL_TCC_DMA_RX
+    volatile PGDMACTRL pDMA = (volatile PGDMACTRL)tcc_p2v(HwGDMA_BASE);
+#endif
+ 
+    if(port->line == UART1){
+        tcc_pca953x_setup(PCA9539_U3_SLAVE_ADDR, BT_ON, OUTPUT, LOW, SET_DIRECTION|SET_VALUE);
+        dbg("tcc_uart: BT power %s\n", (tcc_pca953x_setup(PCA9539_U3_SLAVE_ADDR, 0, OUTPUT, 0, GET_VALUE)&BT_ON)?"ON":"OFF");
+    }
+
+
+	if (port)
+		uart_remove_one_port(&tcc_uart_drv, port);
+
+#ifdef CONFIG_SERIAL_TCC_DMA_TX
+    if(port->line == DMA_PORT)
+        tcc_free_dma_buf(&(tcc_serial_ports[DMA_PORT].dma_tx_buffer));
+#endif
+
+#ifdef CONFIG_SERIAL_TCC_DMA_RX
+    if(port->line == DMA_PORT)
+    {
+        dma_free_writecombine(0,DMA_RX_BUF_SIZE,dma_rx_buffer,dma_rx_buffer_physical);
+        wr_regl(port, OFFSET_UCR, rd_regl(port, OFFSET_UCR) & ~Hw1);
+        pDMA->CHCTRL1 &= Hw0;
+    }
+#endif
+
+
+	return 0;
+}
+
+/* UART power management code */
+
+#ifdef CONFIG_PM
+/*-------------------------------------------------
+ * TODO: handling DMA_PORT suspend/resume (TCC79X)
+ *       DMA stop and start ...
+ *-------------------------------------------------*/
+static int tcc_serial_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct uart_port *port = tcc_dev_to_port(&dev->dev);
+	struct tcc_reg_info *reg = &tcc_serial_ports[port->line].reg;
+
+	if (port && port_used(port)) {
+		port->suspended = 1;
+
+		// disable interrupt
+		wr_regl(port, OFFSET_IER, (rd_regl(port, OFFSET_IER) & (~UART_IER_ELSI)));
+
+		reg->bLCR = rd_regl(port, OFFSET_LCR);
+
+		// DLAB = 0
+		wr_regl(port, OFFSET_LCR, (reg->bLCR & (~Hw7)));
+		reg->bIER = rd_regl(port, OFFSET_IER);
+
+		// DLAB = 1
+		wr_regl(port, OFFSET_LCR, (reg->bLCR | Hw7));
+//		reg->bFCR = 0x07;						// set in tcc_serial_startup()			
+		reg->bDLL = rd_regl(port, OFFSET_DLL);
+		reg->bDLM = rd_regl(port, OFFSET_DLM);
+
+		reg->bMCR = rd_regl(port, OFFSET_MCR);
+		reg->bAFT = rd_regl(port, OFFSET_AFT);
+		reg->bUCR = rd_regl(port, OFFSET_UCR);
+	}
+	
+	return 0;
+}
+
+static int tcc_serial_resume(struct platform_device *dev)
+{
+	struct uart_port *port = tcc_dev_to_port(&dev->dev);
+	struct tcc_reg_info *reg = &tcc_serial_ports[port->line].reg;
+
+	if (port && port_used(port)) {
+		if (port->suspended) {
+			// DLAB = 0
+			wr_regl(port, OFFSET_LCR, (reg->bLCR & (~Hw7)));
+			wr_regl(port, OFFSET_IER, reg->bIER);
+
+			// DLAB = 1
+			wr_regl(port, OFFSET_LCR, (reg->bLCR | Hw7));
+			wr_regl(port, OFFSET_FCR, reg->bFCR);
+			wr_regl(port, OFFSET_DLL, reg->bDLL);
+			wr_regl(port, OFFSET_DLM, reg->bDLM);
+
+			wr_regl(port, OFFSET_MCR, reg->bMCR);
+			wr_regl(port, OFFSET_AFT, reg->bAFT);
+			wr_regl(port, OFFSET_UCR, reg->bUCR);
+
+			port->suspended = 0;
+			// DLAB = 0
+			wr_regl(port, OFFSET_LCR, (reg->bLCR & (~Hw7)));
+			wr_regl(port, OFFSET_IER, (rd_regl(port, OFFSET_IER) | UART_IER_ELSI));
+
+			wr_regl(port, OFFSET_LCR, reg->bLCR);
+		}
+	}
+	
+	return 0;
+}
+
+#else
+#define tcc_serial_suspend NULL
+#define tcc_serial_resume  NULL
+#endif
+
+static int tcc_serial_probe(struct platform_device *dev)
+{
+	return tcc_uart_probe(dev, &tcc_uart_inf);
+}
+
+static struct platform_driver tcc_serial_drv = {
+	.probe		= tcc_serial_probe,
+	.remove		= tcc_serial_remove,
+	.suspend	= tcc_serial_suspend,
+	.resume		= tcc_serial_resume,
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int tcc_serial_init(struct platform_driver *drv,
+			       struct tcc_uart_info *info)
+{
+	dbg("%s(%p,%p)\n", __func__, drv, info);
+
+	return platform_driver_register(drv);
+}
+
+static inline void tcc_serial_exit(void)
+{
+    //remove_pwm_node(DEVICE_UART);
+	platform_driver_unregister(&tcc_serial_drv);
+}
+
+
+/* module initialisation code */
+
+static int __init tcc_serial_modinit(void)
+{
+	int ret;
+	
+	ret = uart_register_driver(&tcc_uart_drv);
+	if (ret < 0) {
+		dbg(KERN_ERR "failed to register UART driver\n");
+		return -1;
+	}
+	//printk("Serial driver %s registered.\n", tcc_uart_drv.driver_name);
+	
+	tcc_serial_init(&tcc_serial_drv, &tcc_uart_inf);
+
+	return 0;
+}
+
+static void __exit tcc_serial_modexit(void)
+{
+	tcc_serial_exit();
+
+	uart_unregister_driver(&tcc_uart_drv);
+}
+
+
+module_init(tcc_serial_modinit);
+module_exit(tcc_serial_modexit);
+
+/************************************************************
+ *
+ * The following is Console driver 
+ *
+ ************************************************************/
+
+#ifdef CONFIG_SERIAL_TCC_CONSOLE
+
+static struct uart_port *cons_uart;
+
+static void tcc_serial_console_putchar(struct uart_port *port, int ch)
+{
+	while (!(rd_regl(port, OFFSET_LSR) & THRE))
+		barrier();
+
+    wr_regb(port, OFFSET_THR, ch);
+
+}
+
+void tcc_serial_uart_putchar(struct uart_port *port, int ch)
+{
+	while (!(rd_regl(port, OFFSET_LSR) & THRE))
+		barrier();
+
+    wr_regb(port, OFFSET_THR, ch);
+}
+
+
+static void tcc_console_write(struct console *co, const char *s,
+			     unsigned int count)
+{
+	struct uart_port *port;
+	unsigned int t_ier, b_ier; 
+
+	port = &tcc_serial_ports[co->index].port;
+
+    t_ier = rd_regl(port, OFFSET_IER);
+    b_ier = t_ier;
+
+    wr_regl(port, OFFSET_IER, t_ier & ~ETXI);
+    uart_console_write(cons_uart, s, count, tcc_serial_console_putchar);
+    wr_regl(port, OFFSET_IER, b_ier);
+}
+
+static void __init
+tcc_serial_get_options(struct uart_port *port, int *baud,
+			   int *parity, int *bits)
+{
+}
+
+
+/* tcc_serial_init_ports
+ * initialise the serial ports from the machine provided initialisation data.
+ */
+int tcc_serial_init_ports(struct tcc_uart_port *ourport,
+					struct tcc_uart_info *info,
+					struct platform_device *pdev)
+{
+	struct uart_port *port = &ourport->port;
+    struct resource *res;
+    int ret;
+
+	dbg("tcc_serial_init_ports: initialising ports...\n");
+	
+	port->iotype	= UPIO_MEM;
+	port->flags     = UPF_BOOT_AUTOCONF;
+	port->ops	    = &tcc_serial_ops;
+	port->fifosize  = FIFOSIZE;
+	port->line	    = pdev->id;
+	port->dev	    = &pdev->dev;
+	port->type      = PORT_TCC;
+
+    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		printk(KERN_ERR "failed to find memory resource for uart\n");
+		return -EINVAL;
+	}
+
+	//port->mapbase	= pdev->resource[0].start;
+	port->mapbase	= res->start;
+	//port->membase	= ioremap_nocache(port->mapbase, MAP_SIZE);
+	port->membase	= (unsigned char __iomem *)port->mapbase;
+    port->irq       = platform_get_irq(pdev, 0);
+
+    ret = (int)port->line;
+
+	return ret;
+}
+
+static int __init
+tcc_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	int baud = BAUDRATE;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	dbg("tcc_serial_console_setup: co=%p (%d), %s\n", co, co->index, options);
+
+	/* is this a valid port */
+
+	if (co->index == -1 || co->index >= NR_PORTS)
+		co->index = CONSOLE_PORT;
+
+	port = &tcc_serial_ports[co->index].port;
+
+	/* is the port configured? */
+
+	if (port->mapbase == 0x0) {
+        port->mapbase = (resource_size_t)&(CONSOLE_BASE);
+        port->membase = (unsigned char __iomem *)port->mapbase;
+		co->index = CONSOLE_PORT;
+		port = &tcc_serial_ports[co->index].port;
+	}
+    
+	cons_uart = port;
+
+	if (options) {
+        dbg("uart_parse_options\n");
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+    } else {
+        dbg("tcc_serial_get_options\n");
+		tcc_serial_get_options(port, &baud, &parity, &bits);
+    }
+	
+	dbg("tcc_serial_console_setup: port=%p (%d)\n", port, co->index);
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+/* tcc_console_init
+ *
+ * initialise the console from one of the uart drivers
+*/
+
+static struct console tcc_serial_console =
+{
+	.name		= TCC_SERIAL_NAME,
+	.device		= uart_console_device,
+	.flags		= CON_PRINTBUFFER | CON_ENABLED,
+	.index		= -1,
+	.write		= tcc_console_write,
+	.setup		= tcc_console_setup,
+};
+
+static int tcc_console_init(void)
+{
+	struct tcc_uart_info *info;
+	
+	dbg("%s\n", __func__);
+	
+	info = &tcc_uart_inf;
+	
+	tcc_serial_console.data = &tcc_uart_drv;
+	register_console(&tcc_serial_console);
+	
+	return 0;
+}
+
+console_initcall(tcc_console_init);
+
+#endif /* CONFIG_SERIAL_TCC_CONSOLE */
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("linux <linux@telechips.com>");
+MODULE_DESCRIPTION("Telechips TCC Serial port driver");
+
Index: linux-2.6.29/drivers/serial/tcc_serial.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/serial/tcc_serial.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,75 @@
+/*
+tcc for UART
+*/
+#ifndef	__DEFINES_H__
+#define	__DEFINES_H__
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*****************************************************************************
+*
+* Defines
+*
+******************************************************************************/
+
+
+//UART
+#define	HwUART_IER_EMSI_EN				Hw3								// Enable Modem status interrupt
+#define	HwUART_IER_EMSI_DIS				~Hw3							// Disable Modem status interrupt
+#define	HwUART_IER_ELSI_EN				Hw2								// Enable receiver line status interrupt
+#define	HwUART_IER_ELSI_DIS				~Hw2							// Disable receiver line status interrupt
+#define	HwUART_IER_ETXI_EN				Hw1								// Enable transmitter holding register empty interrupt
+#define	HwUART_IER_ETXI_DIS				~Hw1							// Disable transmitter holding register empty interrupt
+#define	HwUART_IER_ERXI_EN				Hw0								// Enable received data available interrupt
+#define	HwUART_IER_ERXI_DIS				~Hw0							// Disable received data available interrupt
+#define	HwUART_IIR_STF					Hw27							// 1:TX is done (SmartCard TX done flag)
+#define	HwUART_IIR_IPF					Hw0								// 1:Interrupt has not generated, 0:Interrupt pending
+
+#define	HwEXTREQ_UART1_RX						Hw30							// Connected Hardware = UART Channel 1 Receiver
+#define	HwEXTREQ_UART1_TX						Hw29							// Connected Hardware = UART Channel 1 Tranceiver
+#define	HwEXTREQ_UART0_RX						Hw27							// Connected Hardware = UART Channel 0 Receiver
+#define	HwEXTREQ_UART0_TX						Hw26							// Connected Hardware = UART Channel 0 Tranceiver
+#define	HwEXTREQ_UART3_RX						Hw11							// Connected Hardware = UART Channel 3 Receiver
+#define	HwEXTREQ_UART3_TX						Hw10							// Connected Hardware = UART Channel 3 Tranceiver
+#define	HwEXTREQ_UART2_RX						Hw9								// Connected Hardware = UART Channel 2 Receiver
+#define	HwEXTREQ_UART2_TX						Hw8								// Connected Hardware = UART Channel 2 Tranceiver
+
+//DMA
+#define	HwCHCTRL_SYNC_EN						Hw13							// Synchronize Hardware Request
+#define	HwCHCTRL_TYPE_SL						(Hw9+Hw8)						// SINGLE transfer with level-triggered detection
+#define	HwCHCTRL_BSIZE_1						HwZERO							// 1 Burst transfer consists of 1 read or write cycle
+#define	HwCHCTRL_WSIZE_8						HwZERO							// Each cycle read or write 8bit data
+#define	HwCHCTRL_IEN_ON						Hw2								// At the same time the FLAG goes to 1, DMA interrupt request is generated
+#define	HwCHCTRL_FLAG							Hw3								// W : Clears FLAG to 0, R : Represents that all hop of transfer are fulfilled
+#define	HwCHCTRL_CONT_C						Hw15							// DMA transfer begins from C_SADR / C_DADR address. It must be used after the former transfer has been executed, so that C_SADR and C_DADR contain a meaningful vlaue
+#define	HwCHCTRL_REP_EN						Hw1								// The DMA channel remains enabled. When another DMA request has occurred, the DMA channel start transfer data again with the same manner(type,address,increment,mask) as the latest transfer of that channel
+
+/*****************************************************************************
+*
+* APIs
+*
+******************************************************************************/
+
+void tcc_serial_iobusonoff(int nCh, int nPort, int bOn);
+void tcc_serial_portinit(int nCh, int nPort, unsigned long* pvGpioAddr, unsigned long* pvPortMuxAddr);
+void tcc_serial_portdeinit(int nCh);
+int	tcc_dma_ctrl(int m_DmaNumber, unsigned long* pVirtualDmaAddr);
+int	tcc_dma_dmacurrentaddress(int m_DmaNumber, unsigned long* pVirtualDmaAddr);
+int tcc_dma_dmadeststartaddress(int m_DmaNumber,unsigned long* pVirtualDmaAddr);
+int tcc_dma_clrien(int m_DmaNumber, unsigned long* pVirtualDmaAddr);
+int tcc_dma_setien(int m_DmaNumber, unsigned long* pVirtualDmaAddr);
+unsigned int tcc_serial_dmaclrinterrupt(unsigned nDmanum, unsigned long* pVirtualDmaAddr);
+void tcc_dma_setconfig( unsigned uCH,	void* pSRT, 	
+					   unsigned uSPARAM,	void* pDST, 	
+					   unsigned uDPARAM,	unsigned	uCHCTRL,	
+					   unsigned uSize,	unsigned channel,	
+					   unsigned mode, unsigned long* pVirtualDmaAddr);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
Index: linux-2.6.29/drivers/spi/Kconfig
===================================================================
--- linux-2.6.29.orig/drivers/spi/Kconfig	2010-04-07 12:29:33.000000000 -0400
+++ linux-2.6.29/drivers/spi/Kconfig	2010-04-07 12:29:36.000000000 -0400
@@ -220,6 +220,20 @@
 	  See the "OPB Serial Peripheral Interface (SPI) (v1.00e)"
 	  Product Specification document (DS464) for hardware details.
 
+comment "Telechips GPSB (General Purpose Serial Bus) Controller Drivers"
+
+config SPI_TCC_MASTER
+	tristate "Telechips SPI Master controller"
+	depends on SPI_MASTER && ARCH_TCC
+	help
+	  This is SPI master mode driver.
+
+config TSIF_TCC_SLAVE
+	tristate "Telechips SPI Slave (TSIF) controller"
+	depends on ARCH_TCC
+	help
+	  This is SPI slave mode driver for TSIF (Transport Stream Interface) modules.
+
 #
 # Add new SPI master controllers in alphabetical order above this line
 #
Index: linux-2.6.29/drivers/spi/Makefile
===================================================================
--- linux-2.6.29.orig/drivers/spi/Makefile	2010-04-07 12:29:33.000000000 -0400
+++ linux-2.6.29/drivers/spi/Makefile	2010-04-07 12:29:36.000000000 -0400
@@ -32,6 +32,15 @@
 obj-$(CONFIG_SPI_SH_SCI)		+= spi_sh_sci.o
 # 	... add above this line ...
 
+# Telechips SPI controller
+ifeq ($(CONFIG_ARCH_TCC),y)
+$(shell ln -fsn $(CONFIG_TCC_STRING)/ $(srctree)/drivers/spi/tcc)
+endif
+
+obj-y							+= tcc/tca_spi_hwset.o
+obj-$(CONFIG_SPI_TCC_MASTER)	+= tcc_spi.o
+obj-$(CONFIG_TSIF_TCC_SLAVE)	+= tcc_tsif.o
+
 # SPI protocol drivers (device/link on bus)
 obj-$(CONFIG_SPI_SPIDEV)	+= spidev.o
 obj-$(CONFIG_SPI_TLE62X0)	+= tle62x0.o
Index: linux-2.6.29/drivers/spi/spi.c
===================================================================
--- linux-2.6.29.orig/drivers/spi/spi.c	2010-04-07 12:29:33.000000000 -0400
+++ linux-2.6.29/drivers/spi/spi.c	2010-04-07 12:29:36.000000000 -0400
@@ -261,6 +261,8 @@
 		goto done;
 	}
 
+/* spidev_open() called setup() */
+#if 0
 	/* Drivers may modify this initial i/o setup, but will
 	 * normally rely on the device being setup.  Devices
 	 * using SPI_CS_HIGH can't coexist well otherwise...
@@ -271,6 +273,7 @@
 				"setup", dev_name(&spi->dev), status);
 		goto done;
 	}
+#endif
 
 	/* Device may be bound to an active driver when this returns */
 	status = device_add(&spi->dev);
Index: linux-2.6.29/drivers/spi/spidev.c
===================================================================
--- linux-2.6.29.orig/drivers/spi/spidev.c	2010-04-07 12:29:33.000000000 -0400
+++ linux-2.6.29/drivers/spi/spidev.c	2010-04-07 12:29:36.000000000 -0400
@@ -482,6 +482,22 @@
 		}
 	}
 	if (status == 0) {
+		/* Telechips spi hw open/close */
+		if (spidev->users == 0) {
+			if (spi_tcc_open(spi_dev_get(spidev->spi))) {
+				status = -EIO;
+				dev_dbg(&spidev->spi->dev, "open(spi_tcc_open)/EIO\n");
+				goto exit;
+			}
+			
+			/* This code was moved from spi_add_device() */
+			status = spi_setup(spidev->spi);
+			if (status < 0) {
+				dev_dbg(&spidev->spi->dev, "open(spi_setup)/EIO\n");
+				goto exit;
+			}
+		}
+		
 		if (!spidev->buffer) {
 			spidev->buffer = kmalloc(bufsiz, GFP_KERNEL);
 			if (!spidev->buffer) {
@@ -497,6 +513,7 @@
 	} else
 		pr_debug("spidev: nothing for minor %d\n", iminor(inode));
 
+exit:
 	mutex_unlock(&device_list_lock);
 	unlock_kernel();
 	return status;
@@ -516,6 +533,9 @@
 	if (!spidev->users) {
 		int		dofree;
 
+		/* Telechips spi hw open/close */
+		spi_tcc_close(spi_dev_get(spidev->spi));
+		
 		kfree(spidev->buffer);
 		spidev->buffer = NULL;
 
Index: linux-2.6.29/drivers/spi/tcc8900/tca_spi_hwset.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/spi/tcc8900/tca_spi_hwset.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,328 @@
+
+/****************************************************************************
+ *   FileName    :  tca_spi_hwset.c
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+
+#if defined(_LINUX_)
+#include <linux/module.h>
+#include <mach/io.h>
+#else
+#include <stdlib.h>
+#include "tcc_gpio.h"
+#endif
+
+#include <bsp.h>
+#include "tca_spi_hwset.h"
+
+
+static int tca_spi_isenabledma(struct tca_spi_handle *h)
+{
+    return (h->regs->DMACTR & Hw0) ? 1 : 0;
+}
+
+static int tca_spi_dmastop(struct tca_spi_handle *h)
+{
+    BITCLR(h->regs->DMACTR, Hw31 | Hw30); /* disable DMA Transmit & Receive */
+    BITSET(h->regs->DMAICR, Hw29| Hw28);
+    BITCLR(h->regs->DMACTR, Hw0); /* DMA disable */
+	return 0;
+}
+
+static int tca_spi_dmastart(struct tca_spi_handle *h)
+{
+    BITSET(h->regs->DMACTR, Hw31 | Hw30); /* enable DMA Transmit & Receive */
+    BITCLR(h->regs->DMACTR, Hw17 | Hw16 | Hw15 | Hw14); /* set Multiple address mode */
+
+    BITCLR(h->regs->DMAICR, Hw16); /* disable DMA Packet Interrupt */
+    BITSET(h->regs->DMAICR, Hw17); /* enable DMA Done Interrupt */
+    BITCLR(h->regs->DMAICR, Hw20); /* set rx interrupt */
+
+    BITSET(h->regs->DMACTR, Hw0); /* DMA enable */
+	return 0;
+}
+
+static int tca_spi_dmastart_slave(struct tca_spi_handle *h)
+{
+    //BITSET(h->regs->DMACTR, Hw31 | Hw30); /* enable DMA Transmit & Receive */
+    BITSET(h->regs->DMACTR, Hw30); /* enable DMA Transmit */
+    BITCLR(h->regs->DMACTR, Hw17 | Hw16 | Hw15 | Hw14); /* set Multiple address mode */
+
+    BITSET(h->regs->DMAICR, Hw16); /* enable DMA Packet Interrupt */
+    //BITSET(h->regs->DMAICR, Hw17); /* enable DMA Done Interrupt */
+    BITCLR(h->regs->DMAICR, Hw20); /* set rx interrupt */
+
+    //h->regs->DMAICR = h->regs->DMAICR | (256 & 0x1FFF);
+    BITSET(h->regs->DMAICR, Hw16); /* enable DMA Packet Interrupt */
+
+	if (h->dma_mode == 0) {
+		BITCSET(h->regs->DMACTR, Hw5|Hw4, Hw29);	/* Normal mode & Continuous mode*/
+	} else {
+		BITSET(h->regs->DMACTR, Hw4);				/* MPEG2-TS mode */
+	}
+
+    BITSET(h->regs->DMACTR, Hw0); /* DMA enable */
+	return 0;
+}
+
+static void tca_spi_clearfifopacket(struct tca_spi_handle *h)
+{
+    /* clear tx/rx FIFO & Packet counter  */
+    BITSET(h->regs->MODE, Hw15 | Hw14);
+    BITSET(h->regs->DMACTR, Hw2);
+    BITCLR(h->regs->DMACTR, Hw2);
+    BITCLR(h->regs->MODE, Hw15 | Hw14);
+}
+
+static void tca_spi_setpacketcnt(struct tca_spi_handle *h, int size)
+{
+    /* set packet count & size */
+    h->regs->PACKET = (size & 0x1FFF);
+}
+
+static void tca_spi_setpacketcnt_slave(struct tca_spi_handle *h, int size)
+{
+    unsigned int packet_cnt = (h->dma_total_packet_cnt & 0x1FFF) - 1;
+    unsigned int packet_size = (MPEG_PACKET_SIZE & 0x1FFF);
+    unsigned int intr_packet_cnt = (h->dma_intr_packet_cnt & 0x1FFF) - 1;
+
+    if (packet_size != size) {
+        size = packet_size;
+    }
+
+    h->regs->PACKET = (packet_cnt << 16) | packet_size;
+    BITCSET(h->regs->DMAICR, 0x1FFF, intr_packet_cnt);
+}
+
+static void tca_spi_setbitwidth(struct tca_spi_handle *h, int width)
+{
+    int width_value = (width - 1) & 0x1F;
+
+    /* set bit width */
+    BITCLR(h->regs->MODE, Hw12 | Hw11 | Hw10 | Hw9 | Hw8);
+    h->regs->MODE |= (width_value << 8);
+    if (width_value & Hw4) {
+        BITCLR(h->regs->DMACTR, Hw28);
+    } else {
+        BITSET(h->regs->DMACTR, Hw28);
+    }
+}
+
+static void tca_spi_setdmaaddr(struct tca_spi_handle *h)
+{
+    /* set dma txbase/rxbase & request DMA tx/rx */
+    h->regs->TXBASE = h->tx_dma.dma_addr;
+    h->regs->RXBASE = h->rx_dma.dma_addr;
+
+    h->regs->INTEN = h->tx_dma.dma_addr ? (h->regs->INTEN | Hw31) : (h->regs->INTEN & ~Hw31);
+    h->regs->INTEN = h->rx_dma.dma_addr ? (h->regs->INTEN | Hw30) : (h->regs->INTEN & ~Hw30);
+}
+
+static void tca_spi_setdmaaddr_slave(struct tca_spi_handle *h)
+{
+    /* set dma txbase/rxbase & request DMA tx/rx */
+    h->regs->RXBASE = h->rx_dma.dma_addr;
+    h->regs->INTEN = h->rx_dma.dma_addr ? (h->regs->INTEN | Hw30) : (h->regs->INTEN & ~Hw30);
+}
+
+static void tca_spi_hwinit(struct tca_spi_handle *h)
+{
+    /* init => set SPI mode, set Master mode ... */
+    memset((void *)(h->regs), 0, sizeof(struct tca_spi_regs));
+
+    h->set_bit_width(h, 32);
+
+    /* [SCK] Tx: risiing edge, Rx: falling edge & enable Operation */
+    BITSET((h->regs)->MODE, Hw17 | Hw18 | Hw3);
+
+    h->set_dma_addr(h);
+    h->clear_fifo_packet(h);
+}
+
+static void tca_spi_hwinit_slave(struct tca_spi_handle *h)
+{
+    /* init => set SPI mode, set Master mode ... */
+    memset((void *)(h->regs), 0, sizeof(struct tca_spi_regs));
+
+    h->set_bit_width(h, 32);
+
+    /* [SCK] Tx: risiing edge, Rx: falling edge & enable Operation */
+    BITSET((h->regs)->MODE, Hw17 | Hw18 | Hw3);
+    BITSET((h->regs)->MODE, Hw2 | Hw5);
+
+    h->set_dma_addr(h);
+    h->clear_fifo_packet(h);
+}
+
+static void tca_spi_set_mpegtspidmode(struct tca_spi_handle *h, int is_set)
+{
+    if (is_set) {
+        BITSET(h->regs->DMACTR, Hw19 | Hw18);
+    } else {
+        BITCLR(h->regs->DMACTR, Hw19 | Hw18);
+    }
+}
+
+
+/******************************
+ * return value
+ *
+ * ret == 0: success
+ * ret > 0 or ret < 0: fail
+ ******************************/
+int tca_spi_init(tca_spi_handle_t *h,
+                 volatile struct tca_spi_regs *regs,
+                 int irq,
+                 dma_alloc_f tea_dma_alloc,
+                 dma_free_f tea_dma_free,
+                 int dma_size,
+                 int id,
+                 int is_slave)
+{
+    int ret = -1;
+
+#if defined(_LINUX_)
+	volatile PPIC pic_regs = (volatile PPIC)tcc_p2v(HwPIC_BASE);
+	volatile PGPIO gpio_regs = (volatile PGPIO)tcc_p2v(HwGPIO_BASE);
+	volatile PGPSBPORTCFG gpsb_pcf_regs = (volatile PGPSBPORTCFG)tcc_p2v(HwGPSBPORTCFG_BASE);
+#else
+	PPIC pic_regs = (PPIC)tcc_allocbaseaddress((unsigned int)&HwPIC_BASE);
+	PGPIO gpio_regs = (PGPIO)tcc_allocbaseaddress((unsigned int)&HwGPIO_BASE);
+	PGPSBPORTCFG gpsb_pcf_regs = (PGPSBPORTCFG)tcc_allocbaseaddress((unsigned int)&HwGPSBPORTCFG_BASE);
+#endif
+
+    if (h) { memset(h, 0, sizeof(tca_spi_handle_t)); }
+    if (regs) {
+        h->regs = regs;
+        h->irq = irq;
+        h->id = id;
+		h->is_slave = is_slave;
+		h->gpio_set = 0x1234;
+
+        h->dma_stop = tca_spi_dmastop;
+        h->dma_start = is_slave ? tca_spi_dmastart_slave : tca_spi_dmastart;
+        h->clear_fifo_packet = tca_spi_clearfifopacket;
+        h->set_packet_cnt = is_slave ? tca_spi_setpacketcnt_slave : tca_spi_setpacketcnt;
+        h->set_bit_width = tca_spi_setbitwidth;
+        h->set_dma_addr = is_slave ? tca_spi_setdmaaddr_slave : tca_spi_setdmaaddr;
+        h->hw_init = is_slave ? tca_spi_hwinit_slave : tca_spi_hwinit;
+        h->is_enable_dma = tca_spi_isenabledma;
+        h->set_mpegts_pidmode = tca_spi_set_mpegtspidmode;
+
+        h->tea_dma_alloc = tea_dma_alloc;
+        h->tea_dma_free = tea_dma_free;
+
+        h->dma_total_size = dma_size;
+		h->dma_mode = 1;	/* default MPEG2-TS DMA mode */
+
+        /* interrupt init */
+		BITSET(pic_regs->MODE1, HwINT1_GPSB);	// level-trigger
+		BITCLR(pic_regs->POL1, HwINT1_GPSB);	// active-high
+
+		/* clear gpsb port config except used port (ch0, ch1) */
+		//BITSET(gpsb_pcf_regs->PCFG0, Hw32-Hw16);	// GPS use ch2
+		BITSET(gpsb_pcf_regs->PCFG1, Hw16-Hw0);
+
+        if (h->id == 0) {
+#if 1
+			/* GPIO_C[31:29] - port 10(0xA) - TSIF only */
+			BITCSET(gpio_regs->GPCFN3, Hw32-Hw20, Hw29|Hw25|Hw21);
+			BITCSET(gpsb_pcf_regs->PCFG0, Hw8-Hw0, 0xA);
+#else
+            /* port config (SPI0 == DXB0, GPIO_D[8:5]) --- TODO:GPIO_C[31:29]*/
+            BITCSET(gpio_regs->GPDFN0, Hw32-Hw20, Hw29|Hw25|Hw21);		// GPIOD[7:5]
+			if (is_slave) {
+            	BITCLR(gpio_regs->GPDFN1, Hw4-Hw0);						// for TSIF (GPIOD[8] is reset pin)
+			} else {
+				BITCSET(gpio_regs->GPDFN1, Hw4-Hw0, Hw1);				// for Master (GPIOD[8] is SDO1)
+			}
+            /* GPSB port config (channel 0 port mapping == 11) */
+            BITCSET(gpsb_pcf_regs->PCFG0, Hw8-Hw0, 0xB);
+#endif
+        } else {
+        	/* port config (SPI1 == DXB1) */
+        	if (is_slave) {
+				BITCSET(gpio_regs->GPEFN1, Hw12-Hw0, Hw9|Hw5|Hw1);		// for TSIF (GPIOE[10:8])
+        	} else {
+				BITCSET(gpio_regs->GPEFN1, Hw16-Hw0, Hw13|Hw9|Hw5|Hw1);	// for Master (GPIOE[11:8])
+        	}
+            /* GPSB port config (channel 1 port mapping == 4) */
+			BITCSET(gpsb_pcf_regs->PCFG0, Hw16-Hw8, 0x400);
+        }
+
+        if (h->tea_dma_alloc) {
+			if (h->tea_dma_alloc(&(h->rx_dma), dma_size) == 0) {
+                if (is_slave) {
+                    ret = 0;
+                } else if (h->tea_dma_alloc(&(h->tx_dma), dma_size) == 0 && h->tea_dma_alloc(&(h->tx_dma_1), dma_size) == 0) {
+                    ret = 0;
+                }
+            }
+        } else {
+        	/* Already, tsif has rx_dma buf */
+        	ret = 0;
+        }
+
+        if (ret) { tca_spi_clean(h); }
+    }
+	
+    return ret;
+}
+
+void tca_spi_clean(tca_spi_handle_t *h)
+{
+    if (h) {
+        if (h->tea_dma_free) {
+			h->tea_dma_free(&(h->tx_dma));
+			h->tea_dma_free(&(h->rx_dma));
+			h->tea_dma_free(&(h->tx_dma_1));
+		}
+        memset(h, 0, sizeof(tca_spi_handle_t));
+
+		/* release GPIO */
+		if (h->gpio_set == 0x1234) {
+			#if defined(_LINUX_)
+			volatile PGPIO gpio_regs = (volatile PGPIO)tcc_p2v(HwGPIO_BASE);
+			#else
+			PGPIO gpio_regs = (PGPIO)tcc_allocbaseaddress((unsigned int)&HwGPIO_BASE);
+			#endif
+
+			if (h->id == 0) {
+#if 1
+				/* GPIO_C[31:29] set "GPIO output low" */
+				BITCLR(gpio_regs->GPCFN3, Hw32-Hw20);
+				BITSET(gpio_regs->GPCEN, Hw31|Hw30|Hw29);
+				BITCLR(gpio_regs->GPCDAT, Hw31|Hw30|Hw29);			
+#else
+	            /* port config (SPI0 == DXB0, GPIO_D[8:5]) */
+	            BITCLR(gpio_regs->GPDFN0, Hw32-Hw20);	// GPIOD[7:5]
+	            BITCLR(gpio_regs->GPDFN1, Hw4-Hw0);		// GPIOD[8]
+				BITSET(gpio_regs->GPDEN, Hw8|Hw7|Hw6|Hw5);
+				BITCLR(gpio_regs->GPDDAT, Hw8|Hw7|Hw6|Hw5);
+#endif
+	        } else {
+	        	/* port config (SPI1 == DXB1) */
+	        	if (h->is_slave) {
+					BITCLR(gpio_regs->GPEFN1, Hw12-Hw0);	// for TSIF (GPIOE[10:8])
+					BITSET(gpio_regs->GPEEN, Hw10|Hw9|Hw8);
+					BITCLR(gpio_regs->GPEDAT, Hw10|Hw9|Hw8);
+	        	} else {
+					BITCLR(gpio_regs->GPEFN1, Hw16-Hw0);	// for Master (GPIOE[11:8])
+					BITSET(gpio_regs->GPEEN, Hw11|Hw10|Hw9|Hw8);
+					BITCLR(gpio_regs->GPEDAT, Hw11|Hw10|Hw9|Hw8);
+	        	}
+	        }
+		}
+    }
+}
+
+#if defined(_LINUX_)
+EXPORT_SYMBOL(tca_spi_init);
+EXPORT_SYMBOL(tca_spi_clean);
+#endif
Index: linux-2.6.29/drivers/spi/tcc8900/tca_spi_hwset.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/spi/tcc8900/tca_spi_hwset.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,116 @@
+/****************************************************************************
+ *   FileName    : tca_spi_hwset.h
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+#ifndef __TCA_SPI_HWSET_H__
+#define __TCA_SPI_HWSET_H__
+
+#if !defined(_LINUX_)
+#define TSIF_DTCM_DMA_MEM_SIZE  0x1600
+#define TSIF_RX_BUFFER_BASE_VA  (0x8A000000 + 0x200)
+#define TSIF_RX_BUFFER_BASE_PA  (0xA0000000 + 0x200) 
+#endif
+
+#define MPEG_PACKET_SIZE 188
+#define WAIT_TIME_FOR_DMA_DONE (1000 * 8)
+
+#pragma pack(push, 4)
+struct tca_spi_regs {
+    volatile unsigned long PORT, STAT, INTEN, MODE, CTRL, EVTCTRL, CCV, 
+		DUMMY,
+        TXBASE, RXBASE, PACKET, DMACTR, DMASTR, DMAICR;
+};
+#pragma pack(pop)
+
+struct tea_dma_buf {
+    void *v_addr;
+    unsigned int dma_addr;
+    int buf_size; // total size of DMA
+};
+
+typedef struct tca_spi_handle tca_spi_handle_t;
+typedef int (*dma_alloc_f)(struct tea_dma_buf *tdma, unsigned int size);
+typedef void (*dma_free_f)(struct tea_dma_buf *tdma);
+
+struct tca_spi_handle {
+    volatile struct tca_spi_regs *regs;
+    struct tea_dma_buf tx_dma, rx_dma;
+	struct tea_dma_buf tx_dma_1;
+	int flag;
+    int irq;
+    void *private_data;
+    int id;
+	int is_slave;
+	int gpio_set;
+
+    int (*is_enable_dma)(tca_spi_handle_t *h);
+    int (*dma_stop)(tca_spi_handle_t *h);
+    int (*dma_start)(tca_spi_handle_t *h);
+    void (*clear_fifo_packet)(tca_spi_handle_t *h);
+    void (*set_packet_cnt)(tca_spi_handle_t *h, int cnt);
+    void (*set_bit_width)(tca_spi_handle_t *h, int width);
+    void (*set_dma_addr)(tca_spi_handle_t *h);
+    void (*hw_init)(tca_spi_handle_t *h);
+    void (*set_mpegts_pidmode)(tca_spi_handle_t *h, int is_set);
+
+    dma_alloc_f tea_dma_alloc; // tea function.
+    dma_free_f tea_dma_free; // tea function.
+
+	int clk;	// Mhz
+	
+    /* add for slave */
+    unsigned int dma_total_packet_cnt, dma_intr_packet_cnt;
+    int q_pos, cur_q_pos;
+    int dma_total_size;
+	int dma_mode;
+};
+
+
+#define tca_spi_setCPOL(R, S) \
+    do {\
+        if (S) BITSET((R)->MODE, Hw16);\
+        else BITCLR((R)->MODE, Hw16);\
+    } while (0)
+
+#define tca_spi_setCPHA(R, S) \
+    do {\
+        if (S) BITSET((R)->MODE, Hw18 | Hw17);\
+        else BITCLR((R)->MODE, Hw18 | Hw17);\
+    } while (0)
+
+#define tca_spi_setCS_HIGH(R, S) \
+    do {\
+        if (S) BITSET((R)->MODE, Hw20 | Hw19);\
+        else BITCLR((R)->MODE, Hw20 | Hw19);\
+    } while (0)
+#define tca_spi_setLSB_FIRST(R, S) \
+    do {\
+        if (S) BITSET((R)->MODE, Hw7);\
+        else BITCLR((R)->MODE, Hw7);\
+    } while (0) 
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern int tca_spi_init(tca_spi_handle_t *h,
+                        volatile struct tca_spi_regs *regs,
+                        int irq,
+                        dma_alloc_f tea_dma_alloc,
+                        dma_free_f tea_dma_free,
+                        int dma_size,
+                        int id,
+                        int is_slave);
+
+extern void tca_spi_clean(tca_spi_handle_t *h);
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*__TCA_SPI_HWSET_H__*/
Index: linux-2.6.29/drivers/spi/tcc_spi.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/spi/tcc_spi.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,590 @@
+/*
+ * linux/drivers/spi/tcc_spi.c
+ *
+ * Author:  <linux@telechips.com>
+ * Created: 1st April, 2009
+ * Description: Driver for Telechips SPI Controllers
+ *              SPI master mode
+ *
+ * Copyright (c) Telechips, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/compile.h>
+
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_bitbang.h>
+
+#include <asm/io.h>
+#include <asm/dma.h>
+
+#include <bsp.h>
+#include "tcc/tca_spi_hwset.h"
+
+
+#define SPI_DMA_SIZE 2048
+
+struct tcc_peri_id_table {
+    unsigned int bus_id;
+    unsigned int clk_id;
+};
+
+struct tcc_peri_id_table sa_peri_id_table[] = {
+    { RB_GPSBCONTROLLER0, PERI_GPSB0 },
+    { RB_GPSBCONTROLLER1, PERI_GPSB1 },
+//	{ RB_GPSBCONTROLLER2, PERI_GPSB2 },
+//	{ RB_GPSBCONTROLLER3, PERI_GPSB3 },
+//	{ RB_GPSBCONTROLLER4, PERI_GPSB4 },
+//	{ RB_GPSBCONTROLLER5, PERI_GPSB5 },
+};
+
+struct tca_spi_pri_handle {
+    struct platform_device *pdev;
+    int rx_len, rx_cnt;
+    int tx_len, tx_cnt;
+    struct {
+        int xfer_pos;
+        int value;
+    } done;
+
+    unsigned char stopping;
+    wait_queue_head_t wait_q;
+    struct list_head queue;
+    struct spi_message *current_message;
+    spinlock_t lock;
+};
+
+static void tea_free_dma_linux(struct tea_dma_buf *tdma)
+{
+    if (tdma) {
+        if (tdma->v_addr != 0) {
+            dma_free_writecombine(0, tdma->buf_size, tdma->v_addr, tdma->dma_addr);
+        }
+        memset(tdma, 0, sizeof(struct tea_dma_buf));
+    }
+}
+
+static int tea_alloc_dma_linux(struct tea_dma_buf *tdma, unsigned int size)
+{
+    int ret = -1;
+    if (tdma) {
+        tea_free_dma_linux(tdma);
+        tdma->buf_size = size;
+        tdma->v_addr = dma_alloc_writecombine(0, tdma->buf_size, &tdma->dma_addr, GFP_KERNEL);
+        //printk("tcc_spi: alloc DMA buffer @0x%X(Phy=0x%X), size:%d\n",
+        //       (unsigned int)tdma->v_addr,
+        //       (unsigned int)tdma->dma_addr,
+        //       tdma->buf_size);
+        ret = tdma->v_addr ? 0 : 1;
+    }
+    return ret;
+}
+
+static int tcc_spi_start_rxtx(struct spi_master *master, unsigned int flen)
+{
+    struct tca_spi_handle *tspi = spi_master_get_devdata(master);
+    struct tca_spi_pri_handle *tpri = (struct tca_spi_pri_handle *)tspi->private_data;
+
+    tpri->done.value = -EIO;
+    //mutex_lock(&(tpri->pm_mutex));
+
+    if ((flen > 0) && (flen <= tspi->rx_dma.buf_size)) {
+        tpri->rx_len = flen;
+        tpri->tx_len = flen;
+        tpri->rx_cnt = 0;
+        tpri->tx_cnt = 0;
+
+        tspi->clear_fifo_packet(tspi);
+        tspi->set_packet_cnt(tspi, flen);
+        tspi->dma_start(tspi);
+
+        if (wait_event_interruptible_timeout((tpri->wait_q),
+                                             (tpri->rx_cnt == tpri->rx_len),
+                                             msecs_to_jiffies(WAIT_TIME_FOR_DMA_DONE)) == 0) {
+            printk("[%s] wait_event timeout  (%dms) !!!\n",
+                   __func__, WAIT_TIME_FOR_DMA_DONE);
+        } else {
+            if (tpri->rx_cnt == tpri->rx_len) {
+                tpri->done.value = 0;
+            }
+        }
+    }
+
+    tpri->current_message = NULL;
+    //mutex_unlock(&(tpri->pm_mutex));
+
+    return tpri->done.value;
+}
+
+static void tcc_spi_next_message(struct spi_master *master)
+{
+    struct tca_spi_handle *tspi = NULL;
+    struct spi_message *msg = NULL;
+    struct spi_device *spi = NULL;
+    struct spi_transfer *xfer = NULL;
+    unsigned int flen = 0;
+    unsigned int copy_len = 0, total_len = 0;
+    struct tca_spi_pri_handle *tpri = NULL;
+    unsigned int bit_width = 0;
+
+    tspi = spi_master_get_devdata(master);
+    tpri = (struct tca_spi_pri_handle *)tspi->private_data;
+
+    BUG_ON(tpri->current_message);
+
+    msg = list_entry(tpri->queue.next, struct spi_message, queue);
+    list_del_init(&(msg->queue));
+    tpri->current_message = msg;
+
+    spi = msg->spi;
+
+    list_for_each_entry(xfer, &(msg->transfers), transfer_list) {
+        tpri->done.xfer_pos = 0;
+        tpri->done.value = 0;
+        total_len = xfer->len;
+        do {
+            copy_len = (total_len > tspi->rx_dma.buf_size) ? tspi->rx_dma.buf_size : total_len;
+			
+            if (copy_len & 0x3) {
+                copy_len %= 4;
+                bit_width = tspi->regs->MODE;
+                bit_width = ((bit_width >> 8) & 0x1F) + 1;
+                tspi->set_bit_width(tspi, 8);
+            }
+
+            if (xfer->tx_buf) {
+				if (tspi->flag) {
+					tspi->regs->TXBASE = tspi->tx_dma.dma_addr;
+					memcpy(tspi->tx_dma.v_addr, xfer->tx_buf + tpri->done.xfer_pos, copy_len);
+					tspi->flag = 0;
+				} else {
+					tspi->regs->TXBASE = tspi->tx_dma_1.dma_addr;
+					memcpy(tspi->tx_dma_1.v_addr, xfer->tx_buf + tpri->done.xfer_pos, copy_len);
+					tspi->flag = 1;
+				}
+            }
+
+            if (tcc_spi_start_rxtx(master, copy_len)) {
+                tspi->clear_fifo_packet(tspi);
+                goto lb_return;
+            }
+
+            if (xfer->rx_buf) {
+                memcpy(xfer->rx_buf + tpri->done.xfer_pos, tspi->rx_dma.v_addr, copy_len);
+            }
+
+            if (bit_width) {
+                tspi->set_bit_width(tspi, bit_width);
+                bit_width = 0;
+            }
+
+            total_len -= copy_len;
+            tpri->done.xfer_pos += copy_len;
+        } while (total_len);
+        flen += xfer->len;
+    }
+
+lb_return:
+    msg->status = tpri->done.value;
+    if (msg->status == 0) {
+        msg->actual_length = flen;
+    }
+    msg->complete(msg->context);
+
+    if (list_empty(&(tpri->queue)) || tpri->stopping) {
+        ;
+    } else {
+        tcc_spi_next_message(master);
+    }
+}
+
+static irqreturn_t tcc_spi_isr(int irq, void *dev_id)
+{
+    struct spi_master *master = dev_id;
+    struct tca_spi_handle *tspi = spi_master_get_devdata(master);
+    //unsigned long flags = 0;
+    unsigned long dma_done_reg = 0;
+    struct tca_spi_pri_handle *tpri = (struct tca_spi_pri_handle *)tspi->private_data;
+
+    //local_save_flags(flags);
+    //local_irq_disable();
+
+    dma_done_reg = tspi->regs->DMAICR;
+
+    if (dma_done_reg & Hw29) {
+        tspi->dma_stop(tspi);
+        tpri->tx_cnt = tpri->tx_len;
+        tpri->rx_cnt = tpri->rx_len;
+        wake_up(&(tpri->wait_q));
+    }
+
+    //local_irq_restore(flags);
+    return IRQ_HANDLED;
+}
+
+#define MODEBITS (SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LSB_FIRST)
+static int tcc_spi_setup(struct spi_device *spi)
+{
+    struct tca_spi_handle *tspi = NULL;
+    unsigned int bits = spi->bits_per_word;
+    struct tca_spi_pri_handle *tpri = NULL;
+    //unsigned int mode = 0;
+
+    tspi = spi_master_get_devdata(spi->master);
+    tpri = (struct tca_spi_pri_handle *)tspi->private_data;
+
+    if (tpri->stopping)
+        return -ESHUTDOWN;
+    if (spi->chip_select > spi->master->num_chipselect) {
+        dev_dbg(&spi->dev,
+                "setup: invalid chipselect %u (%u defined)\n",
+                spi->chip_select, spi->master->num_chipselect);
+        return -EINVAL;
+    }
+
+    if (bits == 0)
+        bits = 8;
+    if (bits != 8 && bits != 16 && bits != 32) {
+        dev_dbg(&spi->dev, "setup: invalid bits_per_word %u\n", bits);
+        return -EINVAL;
+    }
+    tspi->set_bit_width(tspi, bits);
+
+    if (spi->mode & ~MODEBITS) {
+        dev_dbg(&spi->dev, "setup: unsupported mode bits %x\n",
+                spi->mode & ~MODEBITS);
+        return -EINVAL;
+    }
+
+    //mode = tspi->regs->MODE;
+    tca_spi_setCPOL(tspi->regs, (spi->mode & SPI_CPOL));
+    tca_spi_setCPHA(tspi->regs, (spi->mode & SPI_CPHA));
+    tca_spi_setCS_HIGH(tspi->regs, (spi->mode & SPI_CS_HIGH));
+    tca_spi_setLSB_FIRST(tspi->regs, (spi->mode & SPI_LSB_FIRST));
+    //tspi->regs->MODE = mode;
+
+    return 0;
+}
+
+static int tcc_spi_transfer(struct spi_device *spi, struct spi_message *msg)
+{
+    struct tca_spi_handle *tspi = NULL;
+    //unsigned long flags = 0;
+    struct tca_spi_pri_handle *tpri = NULL;
+	
+    tspi = (struct tca_spi_handle *)spi_master_get_devdata(spi->master);
+    tpri = (struct tca_spi_pri_handle *)tspi->private_data;
+
+    if (unlikely(list_empty(&(msg->transfers)))) {
+        return -EINVAL;
+    }
+
+    if (tpri->stopping) {
+        return -ESHUTDOWN;
+    }
+
+    msg->status = -EINPROGRESS;
+    msg->actual_length = 0;
+
+    //spin_lock_irqsave(&(tpri->lock), flags);
+    list_add_tail(&(msg->queue), &(tpri->queue));
+    if (!tpri->current_message) {
+        tcc_spi_next_message(spi->master);
+    }
+    //spin_unlock_irqrestore(&(tpri->lock), flags);
+    return 0;
+}
+
+static void tcc_spi_cleanup(struct spi_device *spi)
+{
+    if (!spi->controller_state)
+        return;
+    dev_dbg(&spi->dev, "tcc_spi_cleanup\n");
+}
+
+static void tcc_spi_close(struct spi_device *spi)
+{
+	struct tca_spi_handle *tspi = NULL;
+	struct tca_spi_pri_handle *tpri = NULL;
+	struct spi_message *msg = NULL;
+
+	tspi = spi_master_get_devdata(spi->master);
+
+	tpri = (struct tca_spi_pri_handle *)tspi->private_data;
+	spin_lock_irq(&(tpri->lock));
+    tpri->stopping = 1;
+    spin_unlock_irq(&tpri->lock);
+    list_for_each_entry(msg, &(tpri->queue), queue) {
+        msg->status = -ESHUTDOWN;
+        msg->complete(msg->context);
+    }
+	if (tpri) { kfree(tpri); }
+	
+	free_irq(tspi->irq, spi->master);
+
+	tca_spi_clean(tspi);
+	tca_ckc_setiobus(sa_peri_id_table[tspi->id].bus_id, DISABLE);
+	tca_ckc_setperi(sa_peri_id_table[tspi->id].clk_id, DISABLE, 40000, PCDIRECTPLL2);
+}
+
+static int tcc_spi_open(struct spi_device *spi)
+{
+	int ret = 0;
+	struct spi_master *master = NULL;
+	struct platform_device *pdev = NULL;
+	struct tca_spi_handle *tspi = NULL;
+	struct tca_spi_pri_handle *tpri = NULL;
+
+	master = spi->master;
+	tspi = spi_master_get_devdata(spi->master);
+
+	tpri = (struct tca_spi_pri_handle *)kmalloc(sizeof(struct tca_spi_pri_handle), GFP_KERNEL);
+    if (tpri == NULL) {
+        return -ENOMEM;
+    }
+    memset(tpri, 0, sizeof(struct tca_spi_pri_handle));
+
+	/* iobus reset */
+	tca_ckc_set_iobus_swreset(sa_peri_id_table[master->bus_num].bus_id, OFF);
+	tca_ckc_set_iobus_swreset(sa_peri_id_table[master->bus_num].bus_id, ON);
+
+	tca_ckc_setiobus(sa_peri_id_table[master->bus_num].bus_id, ENABLE);
+	tca_ckc_setperi(sa_peri_id_table[master->bus_num].clk_id, ENABLE, 40000, PCDIRECTPLL2);
+
+	if (tca_spi_init(tspi,
+					(volatile struct tca_spi_regs *)master->tcc_reg_base,
+					master->tcc_irq_no,
+					tea_alloc_dma_linux,
+					tea_free_dma_linux,
+					SPI_DMA_SIZE,
+					master->bus_num,
+					0)) {
+		goto err;
+	}
+
+	tspi->private_data = (void *)tpri;
+    tpri->pdev = pdev;
+
+	spin_lock_init(&(tpri->lock));
+    INIT_LIST_HEAD(&(tpri->queue));
+
+	tspi->clear_fifo_packet(tspi);
+	tspi->dma_stop(tspi);
+	init_waitqueue_head(&(tpri->wait_q));
+
+	tspi->hw_init(tspi);
+
+	ret = request_irq(tspi->irq, tcc_spi_isr, IRQF_SHARED, master->dev.parent->bus_id, master);
+	if (ret) { goto err; }
+
+	return 0;
+
+err:
+	printk("%s: error!!!\n", __func__);
+	tca_spi_clean(tspi);
+	tca_ckc_setiobus(sa_peri_id_table[pdev->id].bus_id, DISABLE);
+	tca_ckc_setperi(sa_peri_id_table[pdev->id].bus_id, DISABLE, 40000, PCDIRECTPLL2);
+	if (tpri) { kfree(tpri); }
+	return ret;
+}
+
+static int __init tcc_spi_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	int irq = -1;
+    struct resource *regs = NULL;
+    struct spi_master *master = NULL;
+    //struct tca_spi_handle *tspi = NULL;
+    //struct tca_spi_pri_handle *tpri = NULL;
+
+    printk("tcc-spi: spi%d probe\n", pdev->id);
+
+    regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    if (!regs) {
+        return -ENXIO;
+    }
+    irq = platform_get_irq(pdev, 0);
+    if (irq < 0) {
+        return -ENXIO;
+    }
+
+    master = spi_alloc_master(&(pdev->dev), sizeof(struct tca_spi_handle));
+    if (!master) {
+        ret = -ENOMEM;
+        goto LB_ret_put;
+    }
+
+    //tpri = (struct tca_spi_pri_handle *)kmalloc(sizeof(struct tca_spi_pri_handle), GFP_KERNEL);
+    //if (tpri == NULL) {
+    //    ret = -ENOMEM;
+    //    goto LB_ret_put;
+    //}
+    //memset(tpri, 0, sizeof(struct tca_spi_pri_handle));
+
+	/* iobus reset */
+	//tca_ckc_set_iobus_swreset(sa_peri_id_table[pdev->id].bus_id, OFF);
+	//tca_ckc_set_iobus_swreset(sa_peri_id_table[pdev->id].bus_id, ON);
+	//
+	//tca_ckc_setiobus(sa_peri_id_table[pdev->id].bus_id, ENABLE);
+	//tca_ckc_setperi(sa_peri_id_table[pdev->id].clk_id, ENABLE, 40000, PCDIRECTPLL2);
+
+    master->bus_num = pdev->id;
+    master->num_chipselect = 1;
+    master->setup = tcc_spi_setup;
+    master->transfer = tcc_spi_transfer;
+    master->cleanup = tcc_spi_cleanup;
+	master->tcc_open = tcc_spi_open;
+	master->tcc_close = tcc_spi_close;
+	master->tcc_irq_no = irq;
+	master->tcc_reg_base = regs->start;
+    platform_set_drvdata(pdev, master);
+
+    //tspi = spi_master_get_devdata(master);
+    //if (tca_spi_init(tspi,
+    //                 (volatile struct tca_spi_regs *)regs->start,
+    //                 irq,
+    //                 tea_alloc_dma_linux,
+    //                 tea_free_dma_linux,
+    //                 SPI_DMA_SIZE,
+    //                 pdev->id,
+    //                 0)) {
+    //    goto LB_ret_put;
+    //}
+
+    //tspi->private_data = (void *)tpri;
+    //tpri->pdev = pdev;
+
+    //spin_lock_init(&(tpri->lock));
+    //INIT_LIST_HEAD(&(tpri->queue));
+
+    //tspi->clear_fifo_packet(tspi);
+    //tspi->dma_stop(tspi);
+    //init_waitqueue_head(&(tpri->wait_q));
+
+    ret = spi_register_master(master);
+    if (ret) { goto LB_ret_free; }
+    
+    //tspi->hw_init(tspi);
+
+    //ret = request_irq(tspi->irq, tcc_spi_isr, IRQF_SHARED, pdev->dev.bus_id, master);
+    //if (ret) { goto LB_ret_free; }
+
+    return 0;
+
+LB_ret_free:
+    //tca_spi_clean(tspi);
+
+LB_ret_put:
+    spi_master_put(master);
+    //if (tpri) { kfree(tpri); }
+
+    return ret;
+}
+
+static int tcc_spi_remove(struct platform_device *pdev)
+{
+    struct spi_master *master = platform_get_drvdata(pdev);
+    //struct tca_spi_handle *tspi = NULL;
+    //struct spi_message *msg = NULL;
+    //struct tca_spi_pri_handle *tpri = NULL;
+
+    //tspi = spi_master_get_devdata(master);
+	
+    //tpri = (struct tca_spi_pri_handle *)tspi->private_data;
+    //spin_lock_irq(&(tpri->lock));
+    //tpri->stopping = 1;
+    //spin_unlock_irq(&tpri->lock);
+    //list_for_each_entry(msg, &(tpri->queue), queue) {
+    //    msg->status = -ESHUTDOWN;
+    //    msg->complete(msg->context);
+    //}
+
+    //free_irq(tspi->irq, master);
+    //if (tspi->private_data) { kfree(tspi->private_data); }
+    //tca_spi_clean(tspi);
+
+    spi_unregister_master(master);
+	
+    //tca_ckc_setiobus(sa_peri_id_table[pdev->id].bus_id, DISABLE);
+	//tca_ckc_setperi(sa_peri_id_table[pdev->id].clk_id, DISABLE, 40000, PCDIRECTPLL2);
+
+    return 0;
+}
+
+#ifdef CONFIG_PM
+static int tcc_spi_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct spi_master *master = platform_get_drvdata(pdev);
+	struct tca_spi_handle *tspi = spi_master_get_devdata(master);
+
+    if (tspi) {
+        (void)(state);
+    }
+	return 0;
+}
+
+static int tcc_spi_resume(struct platform_device *pdev)
+{
+	struct spi_master *master = platform_get_drvdata(pdev);
+	struct tca_spi_handle *tspi = spi_master_get_devdata(master);
+	volatile PGPSBPORTCFG gpsb_pcf_regs = (volatile PGPSBPORTCFG)tcc_p2v(HwGPSBPORTCFG_BASE);
+
+    if (tspi) {
+        tspi->clear_fifo_packet(tspi);
+
+		//if (tspi->is_enable_dma(tspi)) {
+		//	tspi->dma_stop(tspi);
+		//	tspi->dma_start(tspi);
+		//}
+		if (tspi->id == 0) {
+			BITCSET(gpsb_pcf_regs->PCFG0, Hw8-Hw0, 0xB);
+		} else {
+			BITCSET(gpsb_pcf_regs->PCFG0, Hw16-Hw8, 0x400);
+		}
+    }
+
+	return 0;
+}
+#else
+#define	tcc_spi_suspend	NULL
+#define	tcc_spi_resume	NULL
+#endif
+
+static struct platform_driver tcc_spidrv = {
+	.remove		= tcc_spi_remove,
+	.suspend	= tcc_spi_suspend,
+	.resume		= tcc_spi_resume,
+    .driver		= {
+        .name	= "tcc-spi",
+        .owner	= THIS_MODULE,
+    },
+};
+
+static int __init tcc_spi_init(void)
+{
+    return platform_driver_probe(&tcc_spidrv, tcc_spi_probe);
+}
+
+static void __exit tcc_spi_exit(void)
+{
+    platform_driver_unregister(&tcc_spidrv);
+}
+module_init(tcc_spi_init);
+module_exit(tcc_spi_exit);
+
+MODULE_AUTHOR("Telechips Inc. SYS4-3 linux@telechips.com");
+MODULE_DESCRIPTION("Telechips SPI Driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.29/drivers/spi/tcc_tsif.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/spi/tcc_tsif.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,535 @@
+/*
+ * linux/drivers/spi/tcc_tsif.c
+ *
+ * Author:  <linux@telechips.com>
+ * Created: 1st April, 2009
+ * Description: Driver for Telechips SPI (GPSB) Controllers
+ *              SPI slave mode for DXB TSIF (Transport Stream Interface) modules
+ *
+ * Copyright (c) Telechips, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/dma-mapping.h>
+#include <linux/poll.h>
+#include <linux/spi/spi.h>
+
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+
+#include <bsp.h>
+#include <mach/tcc_pca953x.h>
+#include <linux/spi/tcc_tsif.h>
+#include "tcc/tca_spi_hwset.h"
+
+
+#define SPI_DMA_SIZE 0x100000
+
+struct tca_spi_pri_handle {
+    wait_queue_head_t wait_q;
+    struct mutex mutex;
+    int open_cnt;
+};
+
+static tca_spi_handle_t tsif_handle;
+static struct tca_spi_pri_handle tsif_pri;
+
+
+static int __init tsif_drv_probe(struct platform_device *dev)
+{
+    platform_set_drvdata(dev, &tsif_handle);
+    return 0;
+}
+
+static int tsif_drv_suspend(struct platform_device *dev, pm_message_t state)
+{
+	return 0;
+}
+
+static int tsif_drv_resume(struct platform_device *dev)
+{
+	tca_spi_handle_t *p_tsif = platform_get_drvdata(dev);
+	volatile PGPSBPORTCFG gpsb_pcf_regs = (volatile PGPSBPORTCFG)tcc_p2v(HwGPSBPORTCFG_BASE);
+
+	if (p_tsif) {
+		if (p_tsif->id == 0) {
+			BITCSET(gpsb_pcf_regs->PCFG0, Hw8-Hw0, 0xB);
+		} else {
+			BITCSET(gpsb_pcf_regs->PCFG0, Hw16-Hw8, 0x400);
+		}
+		if (p_tsif->is_enable_dma(p_tsif)) {
+			p_tsif->dma_stop(p_tsif);
+			p_tsif->dma_start(p_tsif);
+		}
+	}
+	return 0;
+}
+
+static struct platform_driver tsif_platform_driver = {
+	.driver = {
+		.name	= "tcc-tsif",
+		.owner	= THIS_MODULE,
+	},
+	.suspend = tsif_drv_suspend,
+	.resume  = tsif_drv_resume,
+};
+
+
+static int tcc_dxb_power(unsigned long flag)
+{
+	if (flag == 1) {
+		/* GPIO_EXPAND DXB_ON Power-on */
+		tcc_pca953x_setup(PCA9539_U3_SLAVE_ADDR, DXB_ON, OUTPUT, HIGH, SET_DIRECTION|SET_VALUE);
+	} else if (flag == 0) {
+		/* GPIO_EXPAND DXB_ON Power-off */
+		tcc_pca953x_setup(PCA9539_U3_SLAVE_ADDR, DXB_ON, OUTPUT, LOW, SET_DIRECTION|SET_VALUE);
+	} else {
+		return -EINVAL;
+	}
+	printk("tcc_tsif: DXB power %s\n", (tcc_pca953x_setup(PCA9539_U3_SLAVE_ADDR, 0, OUTPUT, 0, GET_VALUE)&DXB_ON)?"ON":"OFF");
+	return 0;
+}
+
+static void tea_free_dma_linux(struct tea_dma_buf *tdma)
+{
+    if (tdma) {
+        if (tdma->v_addr != 0) {
+            dma_free_writecombine(0, tdma->buf_size, tdma->v_addr, tdma->dma_addr);
+        }
+        memset(tdma, 0, sizeof(struct tea_dma_buf));
+    }
+}
+
+static int tea_alloc_dma_linux(struct tea_dma_buf *tdma, unsigned int size)
+{
+    int ret = -1;
+    if (tdma) {
+        tea_free_dma_linux(tdma);
+        tdma->buf_size = size;
+        tdma->v_addr = dma_alloc_writecombine(0, tdma->buf_size, &tdma->dma_addr, GFP_KERNEL);
+        printk("tcc_tsif: alloc DMA buffer @0x%X(Phy=0x%X), size:%d\n",
+               (unsigned int)tdma->v_addr,
+               (unsigned int)tdma->dma_addr,
+               tdma->buf_size);
+        ret = tdma->v_addr ? 0 : 1;
+    }
+    return ret;
+}
+
+static irqreturn_t tcc_tsif_dma_handler(int irq, void *dev_id)
+{
+    struct tca_spi_handle *tspi = (struct tca_spi_handle *)dev_id;
+    struct tca_spi_pri_handle *tpri = (struct tca_spi_pri_handle *)tspi->private_data;
+    unsigned long dma_done_reg = 0;
+
+    dma_done_reg = tspi->regs->DMAICR;
+    if (dma_done_reg & (Hw28 | Hw29)) {
+        BITSET(tspi->regs->DMAICR, Hw29 | Hw28);
+        if (tpri->open_cnt > 0) {
+            tspi->cur_q_pos = (int)(tspi->regs->DMASTR >> 17);
+            wake_up(&(tpri->wait_q));
+        }
+    }
+    return IRQ_HANDLED;
+}
+
+static int tsif_get_readable_cnt(tca_spi_handle_t *H)
+{
+    if (H) {
+        int dma_pos = H->cur_q_pos;
+        int q_pos = H->q_pos;
+        int readable_cnt = 0;
+
+        if (dma_pos > q_pos) {
+            readable_cnt = dma_pos - q_pos;
+        } else if (dma_pos < q_pos) {
+            readable_cnt = H->dma_total_packet_cnt - q_pos;
+            readable_cnt += dma_pos;
+        } 
+        return readable_cnt;
+    }
+    return 0;
+}
+
+static ssize_t tcc_tsif_read(struct file *filp, char *buf, size_t len, loff_t *ppos)
+{
+    int readable_cnt = 0, copy_cnt = 0;
+    int copy_byte = 0;
+
+    readable_cnt = tsif_get_readable_cnt(&tsif_handle);
+    if (readable_cnt > 0) {
+        copy_byte = readable_cnt * TSIF_PACKET_SIZE;
+        if (copy_byte > len) {
+            copy_byte = len;
+        }
+
+        copy_byte -= copy_byte % TSIF_PACKET_SIZE;
+        copy_cnt = copy_byte / TSIF_PACKET_SIZE;
+        copy_cnt -= copy_cnt % tsif_handle.dma_intr_packet_cnt;
+        copy_byte = copy_cnt * TSIF_PACKET_SIZE;
+
+        if (copy_cnt >= tsif_handle.dma_intr_packet_cnt) {
+            int offset = tsif_handle.q_pos * TSIF_PACKET_SIZE;
+            if (copy_cnt > tsif_handle.dma_total_packet_cnt - tsif_handle.q_pos) {
+                int first_copy_byte = (tsif_handle.dma_total_packet_cnt - tsif_handle.q_pos) * TSIF_PACKET_SIZE;
+                int first_copy_cnt = first_copy_byte / TSIF_PACKET_SIZE;
+                int second_copy_byte = (copy_cnt - first_copy_cnt) * TSIF_PACKET_SIZE;
+
+                if (copy_to_user(buf, tsif_handle.rx_dma.v_addr + offset, first_copy_byte)) {
+                    return -EFAULT;
+                }
+                if (copy_to_user(buf + first_copy_byte, tsif_handle.rx_dma.v_addr, second_copy_byte)) {
+                    return -EFAULT;
+                }
+
+                tsif_handle.q_pos = copy_cnt - first_copy_cnt;
+            } else {
+                if (copy_to_user(buf, tsif_handle.rx_dma.v_addr + offset, copy_byte)) {
+                    return -EFAULT;
+                }
+
+                tsif_handle.q_pos += copy_cnt;
+                if (tsif_handle.q_pos >= tsif_handle.dma_total_packet_cnt) {
+                    tsif_handle.q_pos = 0;
+                }
+            }
+            return copy_byte;
+        }
+    }
+    return 0;
+}
+
+static ssize_t tcc_tsif_write(struct file *filp, const char *buf, size_t len, loff_t *ppos)
+{
+    return 0;
+}
+
+static unsigned int tcc_tsif_poll(struct file *filp, struct poll_table_struct *wait)
+{
+    if (tsif_get_readable_cnt(&tsif_handle) >= tsif_handle.dma_intr_packet_cnt) {
+		return  (POLLIN | POLLRDNORM);
+    }
+
+    poll_wait(filp, &(tsif_pri.wait_q), wait);
+    if (tsif_get_readable_cnt(&tsif_handle) >= tsif_handle.dma_intr_packet_cnt) {
+		return  (POLLIN | POLLRDNORM);
+    }
+    return 0;
+}
+
+static int tcc_tsif_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    int ret = 0;
+    switch (cmd) {
+    case IOCTL_TSIF_DMA_START:
+        {
+            struct tcc_tsif_param param;
+            if (copy_from_user(&param, (void *)arg, sizeof(struct tcc_tsif_param))) {
+                printk("cannot copy from user tcc_tsif_param in IOCTL_TSIF_DMA_START !!! \n");
+                return -EFAULT;
+            }
+
+            if (((TSIF_PACKET_SIZE * param.ts_total_packet_cnt) > tsif_handle.dma_total_size)
+                || (param.ts_total_packet_cnt <= 0)) {
+                printk("so big ts_total_packet_cnt !!! \n");
+                return -EFAULT;
+            }
+
+            tsif_handle.dma_stop(&tsif_handle);
+
+            tca_spi_setCPHA(tsif_handle.regs, param.mode & SPI_CPHA);
+            tca_spi_setCPOL(tsif_handle.regs, param.mode & SPI_CPOL);
+            tca_spi_setCS_HIGH(tsif_handle.regs, param.mode & SPI_CS_HIGH);
+            tca_spi_setLSB_FIRST(tsif_handle.regs, param.mode & SPI_LSB_FIRST);
+
+			tsif_handle.dma_mode = param.dma_mode;
+			if (tsif_handle.dma_mode == 0) {
+				tsif_handle.set_mpegts_pidmode(&tsif_handle, 0);
+			}
+
+            tsif_handle.dma_total_packet_cnt = param.ts_total_packet_cnt;
+            tsif_handle.dma_intr_packet_cnt = param.ts_intr_packet_cnt;
+
+            tsif_handle.clear_fifo_packet(&tsif_handle);
+            tsif_handle.q_pos = tsif_handle.cur_q_pos = 0;
+
+            tsif_handle.set_packet_cnt(&tsif_handle, MPEG_PACKET_SIZE);
+            printk("interrupt packet count [%u]\n", tsif_handle.dma_intr_packet_cnt);
+            tsif_handle.dma_start(&tsif_handle);
+        }
+        break;
+		
+    case IOCTL_TSIF_DMA_STOP:
+            tsif_handle.dma_stop(&tsif_handle);
+        break;
+		
+    case IOCTL_TSIF_GET_MAX_DMA_SIZE:
+        {
+            struct tcc_tsif_param param;
+
+            param.ts_total_packet_cnt = tsif_handle.dma_total_size / TSIF_PACKET_SIZE;
+            param.ts_intr_packet_cnt = 1;
+
+            if (copy_to_user((void *)arg, (void *)&param, sizeof(struct tcc_tsif_param))) {
+                printk("cannot copy to user tcc_tsif_param in IOCTL_TSIF_GET_MAX_DMA_SIZE !!! \n");
+                return -EFAULT;
+            }
+        }
+        break;
+		
+    case IOCTL_TSIF_SET_PID:
+        {
+            struct tcc_tsif_pid_param param;
+            if (copy_from_user(&param, (void *)arg, sizeof(struct tcc_tsif_pid_param))) {
+                printk("cannot copy from user tcc_tsif_pid_param in IOCTL_TSIF_SET_PID !!! \n");
+                return -EFAULT;
+            }
+
+            if (param.valid_data_cnt <= PID_MATCH_TABLE_MAX_CNT) {
+                int i = 0;
+                for (i = 0; i < PID_MATCH_TABLE_MAX_CNT; i++) {
+                    HwGPSB_PIDT(i) = 0;
+                }
+                if (param.valid_data_cnt > 0) {
+                    for (i = 0; i < param.valid_data_cnt; i++) {
+                        HwGPSB_PIDT(i) = (param.pid_data)[i] & 0x1FFFFFFF;
+                        BITSET(HwGPSB_PIDT(i), (TSIF_SPI_NUM == 0) ? HwGPSB_PIDT_CH0 : HwGPSB_PIDT_CH1);
+                    }
+                    tsif_handle.set_mpegts_pidmode(&tsif_handle, 1);
+                } else {
+                    tsif_handle.set_mpegts_pidmode(&tsif_handle, 0);
+                }
+            } else {
+                printk("tsif: PID TABLE is so big !!! (0x%X)\n", cmd);
+                ret = -EINVAL;
+            }
+        }
+        break;
+		
+	case IOCTL_TSIF_DXB_POWER:
+		{
+			unsigned long flag;
+			if (copy_from_user((void *)&flag, (const void *)arg, sizeof(flag))) {
+				return -EFAULT;
+			}
+			if (tcc_dxb_power(flag)) {
+				return -EINVAL;
+			}
+		}
+		break;
+		
+    default:
+        printk("tsif: unrecognized ioctl (0x%X)\n", cmd);
+        ret = -EINVAL;
+        break;
+    }
+    return ret;
+}
+
+static int tcc_tsif_init(int tsif_num)
+{
+	int ret = 0;
+    volatile struct tca_spi_regs *reg_addr = NULL;
+
+	//printk("%s: spi%d open\n", __func__, tsif_num);
+    reg_addr = (volatile struct tca_spi_regs *)((TSIF_SPI_NUM == 0)
+												? &(HwGPSBCH0_BASE) : &(HwGPSBCH1_BASE));
+
+    memset(&tsif_handle, 0, sizeof(tca_spi_handle_t));
+    //memset(&tsif_pri, 0, sizeof(struct tca_spi_pri_handle));
+
+	/* GPIO_EXPAND DXB Power-on */
+	//tcc_dxb_power(1);
+
+	// reset
+	tca_ckc_set_iobus_swreset(tsif_num == 0 ? RB_GPSBCONTROLLER0 : RB_GPSBCONTROLLER1, OFF);
+	tca_ckc_set_iobus_swreset(tsif_num == 0 ? RB_GPSBCONTROLLER0 : RB_GPSBCONTROLLER1, ON);
+
+    tca_ckc_setiobus(tsif_num == 0 ? RB_GPSBCONTROLLER0 : RB_GPSBCONTROLLER1, ENABLE);
+
+	if (tca_spi_init(&tsif_handle,
+                     reg_addr,
+                     (TSIF_SPI_NUM == 0) ? INT_GPSB0_DMA : INT_GPSB1_DMA,
+                     tea_alloc_dma_linux,
+                     tea_free_dma_linux,
+                     SPI_DMA_SIZE,
+                     TSIF_SPI_NUM,
+                     1)) {
+        printk("%s: tca_spi_init error !!!!!\n", __func__);
+		ret = -EBUSY;
+		goto err_spi;
+    }
+
+	tsif_handle.private_data = (void *)&tsif_pri;
+    tsif_handle.clear_fifo_packet(&tsif_handle);
+    tsif_handle.dma_stop(&tsif_handle);
+
+    //init_waitqueue_head(&(tsif_pri.wait_q));
+    //mutex_init(&(tsif_pri.mutex));
+
+    tsif_handle.dma_total_packet_cnt = tsif_handle.dma_total_size / TSIF_PACKET_SIZE;
+    tsif_handle.dma_intr_packet_cnt = 1;
+
+    tsif_handle.hw_init(&tsif_handle);
+	
+    ret = request_irq(tsif_handle.irq, tcc_tsif_dma_handler, IRQF_SHARED, TSIF_DEV_NAME, &tsif_handle);
+	if (ret) { 
+		goto err_irq; 
+	}
+
+    tsif_handle.set_packet_cnt(&tsif_handle, MPEG_PACKET_SIZE);
+
+	return 0;
+
+err_irq:
+	free_irq(tsif_handle.irq, &tsif_handle);
+	
+err_spi:
+	tca_spi_clean(&tsif_handle);
+	tca_ckc_setiobus(tsif_num == 0 ? RB_GPSBCONTROLLER0 : RB_GPSBCONTROLLER1, DISABLE);
+	/* GPIO_EXPAND DXB Power-off */
+	//tcc_dxb_power(0);
+	
+	return ret;
+}
+
+static void tcc_tsif_deinit(int tsif_num)
+{
+	free_irq(tsif_handle.irq, &tsif_handle);
+    tca_spi_clean(&tsif_handle);
+    tca_ckc_setiobus(tsif_num == 0 ? RB_GPSBCONTROLLER0 : RB_GPSBCONTROLLER1, DISABLE);
+	/* GPIO_EXPAND DXB Power-off */
+	//tcc_dxb_power(0);
+}
+
+static int tcc_tsif_open(struct inode *inode, struct file *filp)
+{
+    int ret = 0;
+    mutex_lock(&(tsif_pri.mutex));
+    if (tsif_pri.open_cnt == 0) {
+        tsif_pri.open_cnt++;
+		ret = tcc_tsif_init(TSIF_SPI_NUM);
+		if (ret == 0) {
+			tsif_handle.set_mpegts_pidmode(&tsif_handle, 0);
+		}
+    } else {
+        ret = -EBUSY;
+    }
+    mutex_unlock(&(tsif_pri.mutex));    
+    return ret;
+}
+
+static int tcc_tsif_release(struct inode *inode, struct file *filp)
+{
+    mutex_lock(&(tsif_pri.mutex));
+    tsif_handle.dma_stop(&tsif_handle);
+    if (tsif_pri.open_cnt > 0) {
+        tsif_pri.open_cnt--;
+		tcc_tsif_deinit(TSIF_SPI_NUM);
+    }
+    mutex_unlock(&(tsif_pri.mutex));
+    return 0;
+}
+
+struct file_operations tcc_tsif_fops =
+{
+    .owner      = THIS_MODULE,
+    .read       = tcc_tsif_read,
+    .write      = tcc_tsif_write,
+    .ioctl      = tcc_tsif_ioctl,
+    .open       = tcc_tsif_open,
+    .release    = tcc_tsif_release,
+    .poll       = tcc_tsif_poll,
+};
+
+static int __init tsif_init(void)
+{
+    int ret;
+	//volatile struct tca_spi_regs *reg_addr = NULL;
+
+	printk("%s: spi%d init\n", TSIF_DEV_NAME, TSIF_SPI_NUM);
+	//reg_addr = (volatile struct tca_spi_regs *)((TSIF_SPI_NUM == 0)
+	//                                            ? &(HwGPSBCH0_BASE) : &(HwGPSBCH1_BASE));
+
+	//memset(&tsif_handle, 0, sizeof(tca_spi_handle_t));
+	memset(&tsif_pri, 0, sizeof(struct tca_spi_pri_handle));
+	ret = register_chrdev(TSIF_DEV_MAJOR, TSIF_DEV_NAME, &tcc_tsif_fops);
+	if (ret < 0) {
+		printk("[%s:%d] register_chrdev error !!!!!\n", __func__, __LINE__); 
+		return ret;
+	}
+
+	///* GPIO_EXPAND DXB Power-on */
+	////tcc_dxb_power(1);
+
+	// reset
+	//tca_ckc_set_iobus_swreset(TSIF_SPI_NUM == 0 ? RB_GPSBCONTROLLER0 : RB_GPSBCONTROLLER1, OFF);
+	//tca_ckc_set_iobus_swreset(TSIF_SPI_NUM == 0 ? RB_GPSBCONTROLLER0 : RB_GPSBCONTROLLER1, ON);
+
+	//tca_ckc_setiobus(TSIF_SPI_NUM == 0 ? RB_GPSBCONTROLLER0 : RB_GPSBCONTROLLER1, ENABLE);
+
+    //if (tca_spi_init(&tsif_handle,
+    //                 reg_addr,
+    //                 (TSIF_SPI_NUM == 0) ? INT_GPSB0_DMA : INT_GPSB1_DMA,
+    //                 tea_alloc_dma_linux,
+    //                 tea_free_dma_linux,
+    //                 SPI_DMA_SIZE,
+    //                 TSIF_SPI_NUM,
+    //                 1)) {
+    //    printk("[%s:%d] tca_spi_init error !!!!!\n", __func__, __LINE__); 
+    //    return -EINVAL;
+    //}
+
+    //tsif_handle.private_data = (void *)&tsif_pri;
+    //tsif_handle.clear_fifo_packet(&tsif_handle);
+    //tsif_handle.dma_stop(&tsif_handle);
+
+    init_waitqueue_head(&(tsif_pri.wait_q));
+    mutex_init(&(tsif_pri.mutex));
+
+    //tsif_handle.dma_total_packet_cnt = tsif_handle.dma_total_size / TSIF_PACKET_SIZE;
+    //tsif_handle.dma_intr_packet_cnt = 1;
+
+    //tsif_handle.hw_init(&tsif_handle);
+    //ret = request_irq(tsif_handle.irq, tcc_tsif_dma_handler, IRQF_SHARED, "tsif", &tsif_handle);
+
+    //tsif_handle.set_packet_cnt(&tsif_handle, MPEG_PACKET_SIZE);
+
+    ret = platform_driver_probe(&tsif_platform_driver, tsif_drv_probe);
+    return ret;
+}
+
+static void __exit tsif_exit(void)
+{
+	//printk("tcc-tsif: exit.\n");
+
+    //free_irq(tsif_handle.irq, &tsif_handle);
+    //tca_spi_clean(&tsif_handle);
+    //tca_ckc_setiobus(TSIF_SPI_NUM == 0 ? RB_GPSBCONTROLLER0 : RB_GPSBCONTROLLER1, DISABLE);
+	///* GPIO_EXPAND DXB Power-off */
+	////tcc_dxb_power(0);
+
+    unregister_chrdev(TSIF_DEV_MAJOR, TSIF_DEV_NAME);
+    platform_driver_unregister(&tsif_platform_driver);
+}
+module_init(tsif_init);
+module_exit(tsif_exit);
+
+MODULE_AUTHOR("Telechips Inc. SYS4-3 linux@telechips.com");
+MODULE_DESCRIPTION("Telechips TSIF driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.29/drivers/usb/Kconfig
===================================================================
--- linux-2.6.29.orig/drivers/usb/Kconfig	2010-04-07 12:29:34.000000000 -0400
+++ linux-2.6.29/drivers/usb/Kconfig	2010-04-07 12:29:36.000000000 -0400
@@ -28,6 +28,7 @@
 config USB_ARCH_HAS_OHCI
 	boolean
 	# ARM:
+	default y if ARCH_TCC	# Telechips OHCI
 	default y if SA1111
 	default y if ARCH_OMAP
 	default y if ARCH_LH7A404
@@ -100,6 +101,8 @@
 
 source "drivers/usb/wusbcore/Kconfig"
 
+source "drivers/usb/dwc_otg/Kconfig"
+
 source "drivers/usb/host/Kconfig"
 
 source "drivers/usb/musb/Kconfig"
Index: linux-2.6.29/drivers/usb/Makefile
===================================================================
--- linux-2.6.29.orig/drivers/usb/Makefile	2010-04-07 12:29:34.000000000 -0400
+++ linux-2.6.29/drivers/usb/Makefile	2010-04-07 12:29:36.000000000 -0400
@@ -39,3 +39,5 @@
 
 obj-$(CONFIG_USB_ATM)		+= atm/
 obj-$(CONFIG_USB_SPEEDTOUCH)	+= atm/
+
+obj-$(CONFIG_TCC_DWC_OTG)	+= dwc_otg/		# Telechips USB OTG
Index: linux-2.6.29/drivers/usb/core/otg_whitelist.h
===================================================================
--- linux-2.6.29.orig/drivers/usb/core/otg_whitelist.h	2010-04-07 12:29:34.000000000 -0400
+++ linux-2.6.29/drivers/usb/core/otg_whitelist.h	2010-04-07 12:29:36.000000000 -0400
@@ -21,6 +21,7 @@
 /* hubs are optional in OTG, but very handy ... */
 { USB_DEVICE_INFO(USB_CLASS_HUB, 0, 0), },
 { USB_DEVICE_INFO(USB_CLASS_HUB, 0, 1), },
+{ USB_DEVICE_INFO(USB_CLASS_HUB, 0, 2), },
 
 #ifdef	CONFIG_USB_PRINTER		/* ignoring nonstatic linkage! */
 /* FIXME actually, printers are NOT supposed to use device classes;
Index: linux-2.6.29/drivers/usb/core/quirks.c
===================================================================
--- linux-2.6.29.orig/drivers/usb/core/quirks.c	2010-04-07 12:29:34.000000000 -0400
+++ linux-2.6.29/drivers/usb/core/quirks.c	2010-04-07 12:29:36.000000000 -0400
@@ -101,7 +101,7 @@
 
 	/* By default, disable autosuspend for all non-hubs */
 #ifdef	CONFIG_USB_SUSPEND
-	if (udev->descriptor.bDeviceClass != USB_CLASS_HUB)
+	//if (udev->descriptor.bDeviceClass != USB_CLASS_HUB)	//AlenOh
 		udev->autosuspend_disabled = 1;
 #endif
 
Index: linux-2.6.29/drivers/usb/dwc_otg/Kconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/usb/dwc_otg/Kconfig	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,49 @@
+#
+# Synopsys DWC OTG Controller Drivers
+#       for Telechips System-on-Chips
+#
+
+comment "Telechips DWC OTG Controller Drivers"
+	depends on ARCH_TCC
+
+config TCC_DWC_OTG
+	tristate "Telechips DWC OTG support"
+	help
+	  Telechips USB OTG Controller driver. 
+	  Synopsys DesignWare Hi-Speed USB On-The-Go (OTG) Core used on the Telechips SoC.
+	select USB_OTG
+	  
+choice
+	prompt "Telechips DWC OTG mode"
+	depends on TCC_DWC_OTG
+	default TCC_DWC_OTG_DUAL_ROLE
+	help
+	  Select Telechips DWC OTG mode, 
+	  OTG Dual-role or OTG Host only or OTG Device only mode.
+
+config TCC_DWC_OTG_DUAL_ROLE
+	bool "OTG Dual-role mode"
+	select USB_GADGET
+	help
+	  Telechips DWC OTG Dual-role mode driver.	
+
+config TCC_DWC_OTG_DEVICE_ONLY
+	bool "OTG Device only mode"
+	select USB_GADGET
+	help
+	  Telechips DWC OTG Device _only_ mode driver.
+
+config TCC_DWC_OTG_HOST_ONLY
+	bool "OTG Host only mode"
+	help
+	  Telechips DWC OTG Host _only_ mode driver.
+
+endchoice
+
+config TCC_DWC_OTG_DEBUG
+	depends on TCC_DWC_OTG
+	bool "Enable debugging messages"
+	default n
+	help
+	  This enables Telechips DWC OTG debugging.
+ 
Index: linux-2.6.29/drivers/usb/dwc_otg/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/usb/dwc_otg/Makefile	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,37 @@
+#
+# Synopsys DWC OTG Controller Drivers
+#       for Telechips System-on-Chips
+#
+
+obj-$(CONFIG_TCC_DWC_OTG) += tcc_dwc_otg.o
+
+tcc_dwc_otg-objs	:= dwc_otg_driver.o
+tcc_dwc_otg-objs	+= dwc_otg_cil.o dwc_otg_cil_intr.o
+tcc_dwc_otg-objs	+= dwc_otg_pcd.o dwc_otg_pcd_intr.o
+tcc_dwc_otg-objs	+= dwc_otg_hcd.o dwc_otg_hcd_intr.o dwc_otg_hcd_queue.o
+tcc_dwc_otg-objs	+= tcc_usb_phy.o
+
+#dwc_otg-objs	+= dwc_otg_attr.o
+#EXTRA_CFLAGS	+= -D_USE_ATTR_
+
+# 
+# OTG Mode
+#
+ifeq ($(CONFIG_TCC_DWC_OTG_DUAL_ROLE),y)
+	EXTRA_CFLAGS += -DDWC_DUAL_ROLE
+endif
+ifeq ($(CONFIG_TCC_DWC_OTG_DEVICE_ONLY),y)
+	EXTRA_CFLAGS += -DDWC_DEVICE_ONLY
+endif
+ifeq ($(CONFIG_TCC_DWC_OTG_HOST_ONLY),y)
+	EXTRA_CFLAGS += -DDWC_HOST_ONLY
+endif
+
+#
+# Debugging
+#
+ifeq ($(CONFIG_TCC_DWC_OTG_DEBUG),y)
+	EXTRA_CFLAGS += -DDEBUG -DLINUX
+	EXTRA_CFLAGS += -DDWC_HS_ELECT_TST
+endif
+
Index: linux-2.6.29/drivers/usb/dwc_otg/dwc_otg_attr.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/usb/dwc_otg/dwc_otg_attr.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,792 @@
+/* ==========================================================================
+ * $File: //dwh/usb_iip/dev/software/otg_ipmate/linux/drivers/dwc_otg_attr.c $
+ * $Revision: #5 $
+ * $Date: 2005/09/15 $
+ * $Change: 537387 $
+ *
+ * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
+ * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto. You are permitted to use and
+ * redistribute this Software in source and binary forms, with or without
+ * modification, provided that redistributions of source code must retain this
+ * notice. You may not view, use, disclose, copy or distribute this file or
+ * any information contained herein except pursuant to this license grant from
+ * Synopsys. If you do not agree with this notice, including the disclaimer
+ * below, then you are not authorized to use the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================== */
+
+/** @file
+ *
+ * The diagnostic interface will provide access to the controller for
+ * bringing up the hardware and testing.  The Linux driver attributes
+ * feature will be used to provide the Linux Diagnostic
+ * Interface. These attributes are accessed through sysfs.
+ */
+
+/** @page "Linux Module Attributes"
+ *
+ * The Linux module attributes feature is used to provide the Linux
+ * Diagnostic Interface.  These attributes are accessed through sysfs.
+ * The diagnostic interface will provide access to the controller for
+ * bringing up the hardware and testing.
+
+
+ The following table shows the attributes.
+ <table>
+ <tr>
+ <td><b> Name</b></td>
+ <td><b> Description</b></td>
+ <td><b> Access</b></td>
+ </tr>
+
+ <tr>
+ <td> mode </td>
+ <td> Returns the current mode: 0 for device mode, 1 for host mode</td>
+ <td> Read</td>
+ </tr>
+
+ <tr>
+ <td> hnpcapable </td>
+ <td> Gets or sets the "HNP-capable" bit in the Core USB Configuraton Register.
+ Read returns the current value.</td>
+ <td> Read/Write</td>
+ </tr>
+
+ <tr>
+ <td> srpcapable </td>
+ <td> Gets or sets the "SRP-capable" bit in the Core USB Configuraton Register.
+ Read returns the current value.</td>
+ <td> Read/Write</td>
+ </tr>
+
+ <tr>
+ <td> hnp </td>
+ <td> Initiates the Host Negotiation Protocol.  Read returns the status.</td>
+ <td> Read/Write</td>
+ </tr>
+
+ <tr>
+ <td> srp </td>
+ <td> Initiates the Session Request Protocol.  Read returns the status.</td>
+ <td> Read/Write</td>
+ </tr>
+
+ <tr>
+ <td> buspower </td>
+ <td> Gets or sets the Power State of the bus (0 - Off or 1 - On)</td>
+ <td> Read/Write</td>
+ </tr>
+
+ <tr>
+ <td> bussuspend </td>
+ <td> Suspends the USB bus.</td>
+ <td> Read/Write</td>
+ </tr>
+
+ <tr>
+ <td> busconnected </td>
+ <td> Gets the connection status of the bus</td>
+ <td> Read</td>
+ </tr>
+
+ <tr>
+ <td> gotgctl </td>
+ <td> Gets or sets the Core Control Status Register.</td>
+ <td> Read/Write</td>
+ </tr>
+
+ <tr>
+ <td> gusbcfg </td>
+ <td> Gets or sets the Core USB Configuration Register</td>
+ <td> Read/Write</td>
+ </tr>
+
+ <tr>
+ <td> grxfsiz </td>
+ <td> Gets or sets the Receive FIFO Size Register</td>
+ <td> Read/Write</td>
+ </tr>
+
+ <tr>
+ <td> gnptxfsiz </td>
+ <td> Gets or sets the non-periodic Transmit Size Register</td>
+ <td> Read/Write</td>
+ </tr>
+
+ <tr>
+ <td> gpvndctl </td>
+ <td> Gets or sets the PHY Vendor Control Register</td>
+ <td> Read/Write</td>
+ </tr>
+
+ <tr>
+ <td> ggpio </td>
+ <td> Gets the value in the lower 16-bits of the General Purpose IO Register
+ or sets the upper 16 bits.</td>
+ <td> Read/Write</td>
+ </tr>
+
+ <tr>
+ <td> guid </td>
+ <td> Gets or sets the value of the User ID Register</td>
+ <td> Read/Write</td>
+ </tr>
+
+ <tr>
+ <td> gsnpsid </td>
+ <td> Gets the value of the Synopsys ID Regester</td>
+ <td> Read</td>
+ </tr>
+
+ <tr>
+ <td> devspeed </td>
+ <td> Gets or sets the device speed setting in the DCFG register</td>
+ <td> Read/Write</td>
+ </tr>
+
+ <tr>
+ <td> enumspeed </td>
+ <td> Gets the device enumeration Speed.</td>
+ <td> Read</td>
+ </tr>
+
+ <tr>
+ <td> hptxfsiz </td>
+ <td> Gets the value of the Host Periodic Transmit FIFO</td>
+ <td> Read</td>
+ </tr>
+
+ <tr>
+ <td> hprt0 </td>
+ <td> Gets or sets the value in the Host Port Control and Status Register</td>
+ <td> Read/Write</td>
+ </tr>
+
+ <tr>
+ <td> regoffset </td>
+ <td> Sets the register offset for the next Register Access</td>
+ <td> Read/Write</td>
+ </tr>
+
+ <tr>
+ <td> regvalue </td>
+ <td> Gets or sets the value of the register at the offset in the regoffset attribute.</td>
+ <td> Read/Write</td>
+ </tr>
+
+ <tr>
+ <td> remote_wakeup </td>
+ <td> On read, shows the status of Remote Wakeup. On write, initiates a remote
+ wakeup of the host. When bit 0 is 1 and Remote Wakeup is enabled, the Remote
+ Wakeup signalling bit in the Device Control Register is set for 1
+ milli-second.</td>
+ <td> Read/Write</td>
+ </tr>
+
+ <tr>
+ <td> regdump </td>
+ <td> Dumps the contents of core registers.</td>
+ <td> Read</td>
+ </tr>
+
+ <tr>
+ <td> hcddump </td>
+ <td> Dumps the current HCD state.</td>
+ <td> Read</td>
+ </tr>
+
+ <tr>
+ <td> hcd_frrem </td>
+ <td> Shows the average value of the Frame Remaining
+ field in the Host Frame Number/Frame Remaining register when an SOF interrupt
+ occurs. This can be used to determine the average interrupt latency. Also
+ shows the average Frame Remaining value for start_transfer and the "a" and
+ "b" sample points. The "a" and "b" sample points may be used during debugging
+ bto determine how long it takes to execute a section of the HCD code.</td>
+ <td> Read</td>
+ </tr>
+
+ <tr>
+ <td> rd_reg_test </td>
+ <td> Displays the time required to read the GNPTXFSIZ register many times
+ (the output shows the number of times the register is read).
+ <td> Read</td>
+ </tr>
+
+ <tr>
+ <td> wr_reg_test </td>
+ <td> Displays the time required to write the GNPTXFSIZ register many times
+ (the output shows the number of times the register is written).
+ <td> Read</td>
+ </tr>
+
+ </table>
+
+ Example usage:
+ To get the current mode:
+ cat /sys/devices/lm0/mode
+
+ To power down the USB:
+ echo 0 > /sys/devices/lm0/buspower
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/stat.h>  /* permission constants */
+
+#include <asm/sizes.h>
+#include <asm/io.h>
+#include <asm/arch/lm.h>
+#include <asm/sizes.h>
+
+#include "dwc_otg_plat.h"
+#include "dwc_otg_attr.h"
+#include "dwc_otg_driver.h"
+#include "dwc_otg_pcd.h"
+#include "dwc_otg_hcd.h"
+
+/*
+ * MACROs for defining sysfs attribute
+ */
+#define DWC_OTG_DEVICE_ATTR_BITFIELD_SHOW(_otg_attr_name_,_addr_,_mask_,_shift_,_string_) \
+static ssize_t _otg_attr_name_##_show (struct device *_dev, char *buf) \
+{ \
+        dwc_otg_device_t *otg_dev = dev_get_otgdata(_dev);\
+	uint32_t val; \
+	val = dwc_read_reg32 (_addr_); \
+	val = (val & (_mask_)) >> _shift_; \
+	return sprintf (buf, "%s = 0x%x\n", _string_, val); \
+}
+#define DWC_OTG_DEVICE_ATTR_BITFIELD_STORE(_otg_attr_name_,_addr_,_mask_,_shift_,_string_) \
+static ssize_t _otg_attr_name_##_store (struct device *_dev, const char *buf, size_t count) \
+{ \
+        dwc_otg_device_t *otg_dev = dev_get_otgdata(_dev);\
+	uint32_t set = simple_strtoul(buf, NULL, 16); \
+	uint32_t clear = set; \
+	clear = ((~clear) << _shift_) & _mask_; \
+	set = (set << _shift_) & _mask_; \
+	dev_dbg(_dev, "Storing Address=0x%08x Set=0x%08x Clear=0x%08x\n", (uint32_t)_addr_, set, clear); \
+	dwc_modify_reg32(_addr_, clear, set); \
+	return count; \
+}
+
+#define DWC_OTG_DEVICE_ATTR_BITFIELD_RW(_otg_attr_name_,_addr_,_mask_,_shift_,_string_) \
+DWC_OTG_DEVICE_ATTR_BITFIELD_SHOW(_otg_attr_name_,_addr_,_mask_,_shift_,_string_) \
+DWC_OTG_DEVICE_ATTR_BITFIELD_STORE(_otg_attr_name_,_addr_,_mask_,_shift_,_string_) \
+DEVICE_ATTR(_otg_attr_name_,0644,_otg_attr_name_##_show,_otg_attr_name_##_store);
+
+#define DWC_OTG_DEVICE_ATTR_BITFIELD_RO(_otg_attr_name_,_addr_,_mask_,_shift_,_string_) \
+DWC_OTG_DEVICE_ATTR_BITFIELD_SHOW(_otg_attr_name_,_addr_,_mask_,_shift_,_string_) \
+DEVICE_ATTR(_otg_attr_name_,0444,_otg_attr_name_##_show,NULL);
+
+/*
+ * MACROs for defining sysfs attribute for 32-bit registers
+ */
+#define DWC_OTG_DEVICE_ATTR_REG_SHOW(_otg_attr_name_,_addr_,_string_) \
+static ssize_t _otg_attr_name_##_show (struct device *_dev, char *buf) \
+{ \
+        dwc_otg_device_t *otg_dev = dev_get_otgdata(_dev);\
+	uint32_t val; \
+	val = dwc_read_reg32 (_addr_); \
+	return sprintf (buf, "%s = 0x%08x\n", _string_, val); \
+}
+#define DWC_OTG_DEVICE_ATTR_REG_STORE(_otg_attr_name_,_addr_,_string_) \
+static ssize_t _otg_attr_name_##_store (struct device *_dev, const char *buf, size_t count) \
+{ \
+        dwc_otg_device_t *otg_dev = dev_get_otgdata(_dev);\
+	uint32_t val = simple_strtoul(buf, NULL, 16); \
+	dev_dbg(_dev, "Storing Address=0x%08x Val=0x%08x\n", (uint32_t)_addr_, val); \
+	dwc_write_reg32(_addr_, val); \
+	return count; \
+}
+
+#define DWC_OTG_DEVICE_ATTR_REG32_RW(_otg_attr_name_,_addr_,_string_) \
+DWC_OTG_DEVICE_ATTR_REG_SHOW(_otg_attr_name_,_addr_,_string_) \
+DWC_OTG_DEVICE_ATTR_REG_STORE(_otg_attr_name_,_addr_,_string_) \
+DEVICE_ATTR(_otg_attr_name_,0644,_otg_attr_name_##_show,_otg_attr_name_##_store);
+
+#define DWC_OTG_DEVICE_ATTR_REG32_RO(_otg_attr_name_,_addr_,_string_) \
+DWC_OTG_DEVICE_ATTR_REG_SHOW(_otg_attr_name_,_addr_,_string_) \
+DEVICE_ATTR(_otg_attr_name_,0444,_otg_attr_name_##_show,NULL);
+
+
+/** @name Functions for Show/Store of Attributes */
+/**@{*/
+
+/**
+ * Show the register offset of the Register Access.
+ */
+static ssize_t regoffset_show( struct device *_dev, char *buf)
+{
+	dwc_otg_device_t *otg_dev = dev_get_otgdata(_dev);
+	return snprintf(buf, sizeof("0xFFFFFFFF\n")+1,"0x%08x\n", otg_dev->reg_offset);
+}
+
+/**
+ * Set the register offset for the next Register Access 	Read/Write
+ */
+static ssize_t regoffset_store( struct device *_dev, const char *buf,
+                                size_t count )
+{
+	dwc_otg_device_t *otg_dev = dev_get_otgdata(_dev);
+	uint32_t offset = simple_strtoul(buf, NULL, 16);
+	//dev_dbg(_dev, "Offset=0x%08x\n", offset);
+	if (offset < SZ_256K ) {
+		otg_dev->reg_offset = offset;
+	}
+	else {
+		dev_err( _dev, "invalid offset\n" );
+	}
+
+	return count;
+}
+DEVICE_ATTR(regoffset, S_IRUGO|S_IWUSR, regoffset_show, regoffset_store);
+
+
+/**
+ * Show the value of the register at the offset in the reg_offset
+ * attribute.
+ */
+static ssize_t regvalue_show( struct device *_dev, char *buf)
+{
+	dwc_otg_device_t *otg_dev = dev_get_otgdata(_dev);
+	uint32_t val;
+	volatile uint32_t *addr;
+
+	if (otg_dev->reg_offset != 0xFFFFFFFF &&
+	        0 != otg_dev->base) {
+		/* Calculate the address */
+		addr = (uint32_t*)(otg_dev->reg_offset +
+		                   (uint8_t*)otg_dev->base);
+		//dev_dbg(_dev, "@0x%08x\n", (unsigned)addr);
+		val = dwc_read_reg32( addr );
+		return snprintf(buf, sizeof("Reg@0xFFFFFFFF = 0xFFFFFFFF\n")+1,
+		                "Reg@0x%06x = 0x%08x\n",
+		                otg_dev->reg_offset, val);
+	}
+	else {
+		dev_err(_dev, "Invalid offset (0x%0x)\n",
+		        otg_dev->reg_offset);
+		return sprintf(buf, "invalid offset\n" );
+	}
+}
+
+/**
+ * Store the value in the register at the offset in the reg_offset
+ * attribute.
+ *
+ */
+static ssize_t regvalue_store( struct device *_dev, const char *buf,
+                               size_t count )
+{
+	dwc_otg_device_t *otg_dev = dev_get_otgdata(_dev);
+	volatile uint32_t * addr;
+	uint32_t val = simple_strtoul(buf, NULL, 16);
+	//dev_dbg(_dev, "Offset=0x%08x Val=0x%08x\n", otg_dev->reg_offset, val);
+	if (otg_dev->reg_offset != 0xFFFFFFFF && 0 != otg_dev->base) {
+		/* Calculate the address */
+		addr = (uint32_t*)(otg_dev->reg_offset +
+		                   (uint8_t*)otg_dev->base);
+		//dev_dbg(_dev, "@0x%08x\n", (unsigned)addr);
+		dwc_write_reg32( addr, val );
+	}
+	else {
+		dev_err(_dev, "Invalid Register Offset (0x%08x)\n",
+		        otg_dev->reg_offset);
+	}
+	return count;
+}
+DEVICE_ATTR(regvalue,  S_IRUGO|S_IWUSR, regvalue_show, regvalue_store);
+
+/*
+ * Attributes
+ */
+DWC_OTG_DEVICE_ATTR_BITFIELD_RO(mode,&(otg_dev->core_if->core_global_regs->gotgctl),(1<<20),20,"Mode");
+DWC_OTG_DEVICE_ATTR_BITFIELD_RW(hnpcapable,&(otg_dev->core_if->core_global_regs->gusbcfg),(1<<9),9,"Mode");
+DWC_OTG_DEVICE_ATTR_BITFIELD_RW(srpcapable,&(otg_dev->core_if->core_global_regs->gusbcfg),(1<<8),8,"Mode");
+
+//DWC_OTG_DEVICE_ATTR_BITFIELD_RW(buspower,&(otg_dev->core_if->core_global_regs->gotgctl),(1<<8),8,"Mode");
+//DWC_OTG_DEVICE_ATTR_BITFIELD_RW(bussuspend,&(otg_dev->core_if->core_global_regs->gotgctl),(1<<8),8,"Mode");
+DWC_OTG_DEVICE_ATTR_BITFIELD_RO(busconnected,otg_dev->core_if->host_if->hprt0,0x01,0,"Bus Connected");
+
+DWC_OTG_DEVICE_ATTR_REG32_RW(gotgctl,&(otg_dev->core_if->core_global_regs->gotgctl),"GOTGCTL");
+DWC_OTG_DEVICE_ATTR_REG32_RW(gusbcfg,&(otg_dev->core_if->core_global_regs->gusbcfg),"GUSBCFG");
+DWC_OTG_DEVICE_ATTR_REG32_RW(grxfsiz,&(otg_dev->core_if->core_global_regs->grxfsiz),"GRXFSIZ");
+DWC_OTG_DEVICE_ATTR_REG32_RW(gnptxfsiz,&(otg_dev->core_if->core_global_regs->gnptxfsiz),"GNPTXFSIZ");
+DWC_OTG_DEVICE_ATTR_REG32_RW(gpvndctl,&(otg_dev->core_if->core_global_regs->gpvndctl),"GPVNDCTL");
+DWC_OTG_DEVICE_ATTR_REG32_RW(ggpio,&(otg_dev->core_if->core_global_regs->ggpio),"GGPIO");
+DWC_OTG_DEVICE_ATTR_REG32_RW(guid,&(otg_dev->core_if->core_global_regs->guid),"GUID");
+DWC_OTG_DEVICE_ATTR_REG32_RO(gsnpsid,&(otg_dev->core_if->core_global_regs->gsnpsid),"GSNPSID");
+DWC_OTG_DEVICE_ATTR_BITFIELD_RW(devspeed,&(otg_dev->core_if->dev_if->dev_global_regs->dcfg),0x3,0,"Device Speed");
+DWC_OTG_DEVICE_ATTR_BITFIELD_RO(enumspeed,&(otg_dev->core_if->dev_if->dev_global_regs->dsts),0x6,1,"Device Enumeration Speed");
+
+DWC_OTG_DEVICE_ATTR_REG32_RO(hptxfsiz,&(otg_dev->core_if->core_global_regs->hptxfsiz),"HPTXFSIZ");
+DWC_OTG_DEVICE_ATTR_REG32_RW(hprt0,otg_dev->core_if->host_if->hprt0,"HPRT0");
+
+
+/**
+ * @todo Add code to initiate the HNP.
+ */
+/**
+ * Show the HNP status bit
+ */
+static ssize_t hnp_show( struct device *_dev, char *buf)
+{
+	dwc_otg_device_t *otg_dev = dev_get_otgdata(_dev);
+	gotgctl_data_t val;
+	val.d32 = dwc_read_reg32 (&(otg_dev->core_if->core_global_regs->gotgctl));
+	return sprintf (buf, "HstNegScs = 0x%x\n", val.b.hstnegscs);
+}
+
+/**
+ * Set the HNP Request bit
+ */
+static ssize_t hnp_store( struct device *_dev, const char *buf,
+                          size_t count )
+{
+	dwc_otg_device_t *otg_dev = dev_get_otgdata(_dev);
+	uint32_t in = simple_strtoul(buf, NULL, 16);
+	uint32_t *addr = (uint32_t *)&(otg_dev->core_if->core_global_regs->gotgctl);
+	gotgctl_data_t mem;
+	mem.d32 = dwc_read_reg32(addr);
+	mem.b.hnpreq = in;
+	dev_dbg(_dev, "Storing Address=0x%08x Data=0x%08x\n", (uint32_t)addr, mem.d32);
+	dwc_write_reg32(addr, mem.d32);
+	return count;
+}
+DEVICE_ATTR(hnp, 0644, hnp_show, hnp_store);
+
+/**
+ * @todo Add code to initiate the SRP.
+ */
+/**
+ * Show the SRP status bit
+ */
+static ssize_t srp_show( struct device *_dev, char *buf)
+{
+#ifndef DWC_HOST_ONLY
+	dwc_otg_device_t *otg_dev = dev_get_otgdata(_dev);
+	gotgctl_data_t val;
+	val.d32 = dwc_read_reg32 (&(otg_dev->core_if->core_global_regs->gotgctl));
+	return sprintf (buf, "SesReqScs = 0x%x\n", val.b.sesreqscs);
+#else
+	return sprintf(buf, "Host Only Mode!\n");
+#endif
+}
+
+
+
+/**
+ * Set the SRP Request bit
+ */
+static ssize_t srp_store( struct device *_dev, const char *buf,
+                          size_t count )
+{
+#ifndef DWC_HOST_ONLY
+	dwc_otg_device_t *otg_dev = dev_get_otgdata(_dev);
+	dwc_otg_pcd_initiate_srp(otg_dev->pcd);
+#endif
+	return count;
+}
+DEVICE_ATTR(srp, 0644, srp_show, srp_store);
+
+/**
+ * @todo Need to do more for power on/off?
+ */
+/**
+ * Show the Bus Power status
+ */
+static ssize_t buspower_show( struct device *_dev, char *buf)
+{
+	dwc_otg_device_t *otg_dev = dev_get_otgdata(_dev);
+	hprt0_data_t val;
+	val.d32 = dwc_read_reg32 (otg_dev->core_if->host_if->hprt0);
+	return sprintf (buf, "Bus Power = 0x%x\n", val.b.prtpwr);
+}
+
+
+/**
+ * Set the Bus Power status
+ */
+static ssize_t buspower_store( struct device *_dev, const char *buf,
+                               size_t count )
+{
+	dwc_otg_device_t *otg_dev = dev_get_otgdata(_dev);
+	uint32_t on = simple_strtoul(buf, NULL, 16);
+	uint32_t *addr = (uint32_t *)otg_dev->core_if->host_if->hprt0;
+	hprt0_data_t mem;
+
+	mem.d32 = dwc_read_reg32(addr);
+	mem.b.prtpwr = on;
+
+	//dev_dbg(_dev, "Storing Address=0x%08x Data=0x%08x\n", (uint32_t)addr, mem.d32);
+	dwc_write_reg32(addr, mem.d32);
+
+	return count;
+}
+DEVICE_ATTR(buspower, 0644, buspower_show, buspower_store);
+
+/**
+ * @todo Need to do more for suspend?
+ */
+/**
+ * Show the Bus Suspend status
+ */
+static ssize_t bussuspend_show( struct device *_dev, char *buf)
+{
+	dwc_otg_device_t *otg_dev = dev_get_otgdata(_dev);
+	hprt0_data_t val;
+	val.d32 = dwc_read_reg32 (otg_dev->core_if->host_if->hprt0);
+	return sprintf (buf, "Bus Suspend = 0x%x\n", val.b.prtsusp);
+}
+
+/**
+ * Set the Bus Suspend status
+ */
+static ssize_t bussuspend_store( struct device *_dev, const char *buf,
+                                 size_t count )
+{
+	dwc_otg_device_t *otg_dev = dev_get_otgdata(_dev);
+	uint32_t in = simple_strtoul(buf, NULL, 16);
+	uint32_t *addr = (uint32_t *)otg_dev->core_if->host_if->hprt0;
+	hprt0_data_t mem;
+	mem.d32 = dwc_read_reg32(addr);
+	mem.b.prtsusp = in;
+	dev_dbg(_dev, "Storing Address=0x%08x Data=0x%08x\n", (uint32_t)addr, mem.d32);
+	dwc_write_reg32(addr, mem.d32);
+	return count;
+}
+DEVICE_ATTR(bussuspend, 0644, bussuspend_show, bussuspend_store);
+
+/**
+ * Show the status of Remote Wakeup.
+ */
+static ssize_t remote_wakeup_show( struct device *_dev, char *buf)
+{
+#ifndef DWC_HOST_ONLY
+	dwc_otg_device_t *otg_dev = dev_get_otgdata(_dev);
+	dctl_data_t val;
+	val.d32 =
+	    dwc_read_reg32( &otg_dev->core_if->dev_if->dev_global_regs->dctl);
+	return sprintf( buf, "Remote Wakeup = %d Enabled = %d\n",
+	                val.b.rmtwkupsig, otg_dev->pcd->remote_wakeup_enable);
+#else
+	return sprintf(buf, "Host Only Mode!\n");
+#endif
+}
+/**
+ * Initiate a remote wakeup of the host.  The Device control register
+ * Remote Wakeup Signal bit is written if the PCD Remote wakeup enable
+ * flag is set.
+ *
+ */
+static ssize_t remote_wakeup_store( struct device *_dev, const char *buf,
+                                    size_t count )
+{
+#ifndef DWC_HOST_ONLY
+	uint32_t val = simple_strtoul(buf, NULL, 16);
+	dwc_otg_device_t *otg_dev = dev_get_otgdata(_dev);
+	if (val&1) {
+		dwc_otg_pcd_remote_wakeup(otg_dev->pcd, 1);
+	}
+	else {
+		dwc_otg_pcd_remote_wakeup(otg_dev->pcd, 0);
+	}
+#endif
+	return count;
+}
+DEVICE_ATTR(remote_wakeup,  S_IRUGO|S_IWUSR, remote_wakeup_show,
+            remote_wakeup_store);
+
+/**
+ * Dump global registers and either host or device registers (depending on the
+ * current mode of the core).
+ */
+static ssize_t regdump_show( struct device *_dev, char *buf)
+{
+	dwc_otg_device_t *otg_dev = dev_get_otgdata(_dev);
+
+	dwc_otg_dump_global_registers( otg_dev->core_if);
+	if (dwc_otg_is_host_mode(otg_dev->core_if)) {
+		dwc_otg_dump_host_registers( otg_dev->core_if);
+	} else {
+		dwc_otg_dump_dev_registers( otg_dev->core_if);
+	}
+	return sprintf( buf, "Register Dump\n" );
+}
+
+DEVICE_ATTR(regdump, S_IRUGO|S_IWUSR, regdump_show, 0);
+
+/**
+ * Dump the current hcd state.
+ */
+static ssize_t hcddump_show( struct device *_dev, char *buf)
+{
+#ifndef DWC_DEVICE_ONLY
+	dwc_otg_device_t *otg_dev = dev_get_otgdata(_dev);
+	dwc_otg_hcd_dump_state(otg_dev->hcd);
+#endif
+	return sprintf( buf, "HCD Dump\n" );
+}
+
+DEVICE_ATTR(hcddump, S_IRUGO|S_IWUSR, hcddump_show, 0);
+
+/**
+ * Dump the average frame remaining at SOF. This can be used to
+ * determine average interrupt latency. Frame remaining is also shown for
+ * start transfer and two additional sample points.
+ */
+static ssize_t hcd_frrem_show( struct device *_dev, char *buf)
+{
+#ifndef DWC_DEVICE_ONLY
+	dwc_otg_device_t *otg_dev = dev_get_otgdata(_dev);
+	dwc_otg_hcd_dump_frrem(otg_dev->hcd);
+#endif
+	return sprintf( buf, "HCD Dump Frame Remaining\n" );
+}
+
+DEVICE_ATTR(hcd_frrem, S_IRUGO|S_IWUSR, hcd_frrem_show, 0);
+
+/**
+ * Displays the time required to read the GNPTXFSIZ register many times (the
+ * output shows the number of times the register is read).
+ */
+#define RW_REG_COUNT 10000000
+#define MSEC_PER_JIFFIE 1000/HZ
+static ssize_t rd_reg_test_show( struct device *_dev, char *buf)
+{
+	int i;
+	int time;
+	int start_jiffies;
+	dwc_otg_device_t *otg_dev = dev_get_otgdata(_dev);
+
+	printk("HZ %d, MSEC_PER_JIFFIE %d, loops_per_jiffy %lu\n",
+	       HZ, MSEC_PER_JIFFIE, loops_per_jiffy);
+	start_jiffies = jiffies;
+	for (i = 0; i < RW_REG_COUNT; i++) {
+		dwc_read_reg32(&otg_dev->core_if->core_global_regs->gnptxfsiz);
+	}
+	time = jiffies - start_jiffies;
+	return sprintf( buf, "Time to read GNPTXFSIZ reg %d times: %d msecs (%d jiffies)\n",
+	                RW_REG_COUNT, time * MSEC_PER_JIFFIE, time );
+}
+
+DEVICE_ATTR(rd_reg_test, S_IRUGO|S_IWUSR, rd_reg_test_show, 0);
+
+/**
+ * Displays the time required to write the GNPTXFSIZ register many times (the
+ * output shows the number of times the register is written).
+ */
+static ssize_t wr_reg_test_show( struct device *_dev, char *buf)
+{
+	int i;
+	int time;
+	int start_jiffies;
+	dwc_otg_device_t *otg_dev = dev_get_otgdata(_dev);
+	uint32_t reg_val;
+
+	printk("HZ %d, MSEC_PER_JIFFIE %d, loops_per_jiffy %lu\n",
+	       HZ, MSEC_PER_JIFFIE, loops_per_jiffy);
+	reg_val = dwc_read_reg32(&otg_dev->core_if->core_global_regs->gnptxfsiz);
+	start_jiffies = jiffies;
+	for (i = 0; i < RW_REG_COUNT; i++) {
+		dwc_write_reg32(&otg_dev->core_if->core_global_regs->gnptxfsiz, reg_val);
+	}
+	time = jiffies - start_jiffies;
+	return sprintf( buf, "Time to write GNPTXFSIZ reg %d times: %d msecs (%d jiffies)\n",
+	                RW_REG_COUNT, time * MSEC_PER_JIFFIE, time);
+}
+
+DEVICE_ATTR(wr_reg_test, S_IRUGO|S_IWUSR, wr_reg_test_show, 0);
+/**@}*/
+
+/**
+ * Create the device files
+ */
+void dwc_otg_attr_create (struct lm_device *lmdev)
+{
+	device_create_file(&lmdev->dev, &dev_attr_regoffset);
+	device_create_file(&lmdev->dev, &dev_attr_regvalue);
+	device_create_file(&lmdev->dev, &dev_attr_mode);
+	device_create_file(&lmdev->dev, &dev_attr_hnpcapable);
+	device_create_file(&lmdev->dev, &dev_attr_srpcapable);
+	device_create_file(&lmdev->dev, &dev_attr_hnp);
+	device_create_file(&lmdev->dev, &dev_attr_srp);
+	device_create_file(&lmdev->dev, &dev_attr_buspower);
+	device_create_file(&lmdev->dev, &dev_attr_bussuspend);
+	device_create_file(&lmdev->dev, &dev_attr_busconnected);
+	device_create_file(&lmdev->dev, &dev_attr_gotgctl);
+	device_create_file(&lmdev->dev, &dev_attr_gusbcfg);
+	device_create_file(&lmdev->dev, &dev_attr_grxfsiz);
+	device_create_file(&lmdev->dev, &dev_attr_gnptxfsiz);
+	device_create_file(&lmdev->dev, &dev_attr_gpvndctl);
+	device_create_file(&lmdev->dev, &dev_attr_ggpio);
+	device_create_file(&lmdev->dev, &dev_attr_guid);
+	device_create_file(&lmdev->dev, &dev_attr_gsnpsid);
+	device_create_file(&lmdev->dev, &dev_attr_devspeed);
+	device_create_file(&lmdev->dev, &dev_attr_enumspeed);
+	device_create_file(&lmdev->dev, &dev_attr_hptxfsiz);
+	device_create_file(&lmdev->dev, &dev_attr_hprt0);
+	device_create_file(&lmdev->dev, &dev_attr_remote_wakeup);
+	device_create_file(&lmdev->dev, &dev_attr_regdump);
+	device_create_file(&lmdev->dev, &dev_attr_hcddump);
+	device_create_file(&lmdev->dev, &dev_attr_hcd_frrem);
+	device_create_file(&lmdev->dev, &dev_attr_rd_reg_test);
+	device_create_file(&lmdev->dev, &dev_attr_wr_reg_test);
+}
+
+/**
+ * Remove the device files
+ */
+void dwc_otg_attr_remove (struct lm_device *lmdev)
+{
+	device_remove_file(&lmdev->dev, &dev_attr_regoffset);
+	device_remove_file(&lmdev->dev, &dev_attr_regvalue);
+	device_remove_file(&lmdev->dev, &dev_attr_mode);
+	device_remove_file(&lmdev->dev, &dev_attr_hnpcapable);
+	device_remove_file(&lmdev->dev, &dev_attr_srpcapable);
+	device_remove_file(&lmdev->dev, &dev_attr_hnp);
+	device_remove_file(&lmdev->dev, &dev_attr_srp);
+	device_remove_file(&lmdev->dev, &dev_attr_buspower);
+	device_remove_file(&lmdev->dev, &dev_attr_bussuspend);
+	device_remove_file(&lmdev->dev, &dev_attr_busconnected);
+	device_remove_file(&lmdev->dev, &dev_attr_gotgctl);
+	device_remove_file(&lmdev->dev, &dev_attr_gusbcfg);
+	device_remove_file(&lmdev->dev, &dev_attr_grxfsiz);
+	device_remove_file(&lmdev->dev, &dev_attr_gnptxfsiz);
+	device_remove_file(&lmdev->dev, &dev_attr_gpvndctl);
+	device_remove_file(&lmdev->dev, &dev_attr_ggpio);
+	device_remove_file(&lmdev->dev, &dev_attr_guid);
+	device_remove_file(&lmdev->dev, &dev_attr_gsnpsid);
+	device_remove_file(&lmdev->dev, &dev_attr_devspeed);
+	device_remove_file(&lmdev->dev, &dev_attr_enumspeed);
+	device_remove_file(&lmdev->dev, &dev_attr_hptxfsiz);
+	device_remove_file(&lmdev->dev, &dev_attr_hprt0);
+	device_remove_file(&lmdev->dev, &dev_attr_remote_wakeup);
+	device_remove_file(&lmdev->dev, &dev_attr_regdump);
+	device_remove_file(&lmdev->dev, &dev_attr_hcddump);
+	device_remove_file(&lmdev->dev, &dev_attr_hcd_frrem);
+	device_remove_file(&lmdev->dev, &dev_attr_rd_reg_test);
+	device_remove_file(&lmdev->dev, &dev_attr_wr_reg_test);
+}
Index: linux-2.6.29/drivers/usb/dwc_otg/dwc_otg_attr.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/usb/dwc_otg/dwc_otg_attr.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,67 @@
+/* ==========================================================================
+ * $File: //dwh/usb_iip/dev/software/otg_ipmate/linux/drivers/dwc_otg_attr.h $
+ * $Revision: #1 $
+ * $Date: 2005/07/07 $
+ * $Change: 510275 $
+ *
+ * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
+ * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto. You are permitted to use and
+ * redistribute this Software in source and binary forms, with or without
+ * modification, provided that redistributions of source code must retain this
+ * notice. You may not view, use, disclose, copy or distribute this file or
+ * any information contained herein except pursuant to this license grant from
+ * Synopsys. If you do not agree with this notice, including the disclaimer
+ * below, then you are not authorized to use the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================== */
+
+#if !defined(__DWC_OTG_ATTR_H__)
+#define __DWC_OTG_ATTR_H__
+
+/** @file
+ * This file contains the interface to the Linux device attributes.
+ */
+extern struct device_attribute dev_attr_regoffset;
+extern struct device_attribute dev_attr_regvalue;
+
+extern struct device_attribute dev_attr_mode;
+extern struct device_attribute dev_attr_hnpcapable;
+extern struct device_attribute dev_attr_srpcapable;
+extern struct device_attribute dev_attr_hnp;
+extern struct device_attribute dev_attr_srp;
+extern struct device_attribute dev_attr_buspower;
+extern struct device_attribute dev_attr_bussuspend;
+extern struct device_attribute dev_attr_busconnected;
+extern struct device_attribute dev_attr_gotgctl;
+extern struct device_attribute dev_attr_gusbcfg;
+extern struct device_attribute dev_attr_grxfsiz;
+extern struct device_attribute dev_attr_gnptxfsiz;
+extern struct device_attribute dev_attr_gpvndctl;
+extern struct device_attribute dev_attr_ggpio;
+extern struct device_attribute dev_attr_guid;
+extern struct device_attribute dev_attr_gsnpsid;
+extern struct device_attribute dev_attr_devspeed;
+extern struct device_attribute dev_attr_enumspeed;
+extern struct device_attribute dev_attr_hptxfsiz;
+extern struct device_attribute dev_attr_hprt0;
+
+void dwc_otg_attr_create (struct lm_device *lmdev);
+void dwc_otg_attr_remove (struct lm_device *lmdev);
+
+#endif
Index: linux-2.6.29/drivers/usb/dwc_otg/dwc_otg_cil.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/usb/dwc_otg/dwc_otg_cil.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,3384 @@
+/* ==========================================================================
+ * $File: //dwh/usb_iip/dev/software/otg_ipmate/linux/drivers/dwc_otg_cil.c $
+ * $Revision: #24 $
+ * $Date: 2007/02/07 $
+ * $Change: 791271 $
+ *
+ * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
+ * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto. You are permitted to use and
+ * redistribute this Software in source and binary forms, with or without
+ * modification, provided that redistributions of source code must retain this
+ * notice. You may not view, use, disclose, copy or distribute this file or
+ * any information contained herein except pursuant to this license grant from
+ * Synopsys. If you do not agree with this notice, including the disclaimer
+ * below, then you are not authorized to use the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================== */
+
+/** @file
+ *
+ * The Core Interface Layer provides basic services for accessing and
+ * managing the DWC_otg hardware. These services are used by both the
+ * Host Controller Driver and the Peripheral Controller Driver.
+ *
+ * The CIL manages the memory map for the core so that the HCD and PCD
+ * don't have to do this separately. It also handles basic tasks like
+ * reading/writing the registers and data FIFOs in the controller.
+ * Some of the data access functions provide encapsulation of several
+ * operations required to perform a task, such as writing multiple
+ * registers to start a transfer. Finally, the CIL performs basic
+ * services that are not specific to either the host or device modes
+ * of operation. These services include management of the OTG Host
+ * Negotiation Protocol (HNP) and Session Request Protocol (SRP). A
+ * Diagnostic API is also provided to allow testing of the controller
+ * hardware.
+ *
+ * The Core Interface Layer has the following requirements:
+ * - Provides basic controller operations.
+ * - Minimal use of OS services.
+ * - The OS services used will be abstracted by using inline functions
+ *	 or macros.
+ *
+ */
+#include <asm/unaligned.h>
+#ifdef DEBUG
+#include <linux/jiffies.h>
+#endif
+
+#include "dwc_otg_plat.h"
+#include "dwc_otg_regs.h"
+#include "dwc_otg_cil.h"
+
+#include "tcc_usb_phy.h"
+#include "tcc_usb_def.h"
+
+/* For Signature */
+#define DWC_OTG_CIL_SIGNATURE			'D','W','C','_','O','T','G','_','C','I','L','_'
+#define DWC_OTG_CIL_VERSION				'V','2','.','0','0','3'
+static const unsigned char DWC_OTG_CIL_C_Version[] =
+    {SIGBYAHONG, DWC_OTG_CIL_SIGNATURE, SIGN_OS ,SIGN_CHIPSET, DWC_OTG_CIL_VERSION, 0};
+
+
+const unsigned char* dwc_otg_cil_get_version(void)
+{
+	return DWC_OTG_CIL_C_Version;
+}
+
+#define USE_PERIODIC_EP 1
+
+/**
+ * This function is called to initialize the DWC_otg CSR data
+ * structures.	The register addresses in the device and host
+ * structures are initialized from the base address supplied by the
+ * caller.	The calling function must make the OS calls to get the
+ * base address of the DWC_otg controller registers.  The core_params
+ * argument holds the parameters that specify how the core should be
+ * configured.
+ *
+ * @param[in] _reg_base_addr Base address of DWC_otg core registers
+ * @param[in] _core_params Pointer to the core configuration parameters
+ *
+ */
+dwc_otg_core_if_t *dwc_otg_cil_init(const uint32_t *_reg_base_addr,
+                                    dwc_otg_core_params_t *_core_params)
+{
+	dwc_otg_core_if_t *core_if = 0;
+	dwc_otg_dev_if_t *dev_if = 0;
+	dwc_otg_host_if_t *host_if = 0;
+	uint8_t *reg_base = (uint8_t *)_reg_base_addr;
+	int i = 0;
+
+	DWC_DEBUGPL(DBG_CILV, "%s(%p,%p)\n", __func__, _reg_base_addr, _core_params);
+
+	core_if = kmalloc( sizeof(dwc_otg_core_if_t), GFP_KERNEL);
+
+	if (core_if == 0) \
+	{
+		DWC_DEBUGPL(DBG_CIL, "Allocation of dwc_otg_core_if_t failed\n");
+		return 0;
+	}
+
+	memset(core_if, 0, sizeof(dwc_otg_core_if_t));
+
+	core_if->core_params = _core_params;
+	core_if->core_global_regs = (dwc_otg_core_global_regs_t *)reg_base;
+
+	/*
+	 * Allocate the Device Mode structures.
+	 */
+	dev_if = kmalloc( sizeof(dwc_otg_dev_if_t), GFP_KERNEL);
+
+	if (dev_if == 0)
+	{
+		DWC_DEBUGPL(DBG_CIL, "Allocation of dwc_otg_dev_if_t failed\n");
+		kfree( core_if );
+		return 0;
+	}
+
+	dev_if->dev_global_regs =
+	    (dwc_otg_device_global_regs_t *)(reg_base + DWC_DEV_GLOBAL_REG_OFFSET);
+
+	for (i=0; i<MAX_EPS_CHANNELS; i++)
+	{
+		dev_if->in_ep_regs[i] = (dwc_otg_dev_in_ep_regs_t *)
+		                        (reg_base + DWC_DEV_IN_EP_REG_OFFSET +
+		                         (i * DWC_EP_REG_OFFSET));
+
+		dev_if->out_ep_regs[i] = (dwc_otg_dev_out_ep_regs_t *)
+		                         (reg_base + DWC_DEV_OUT_EP_REG_OFFSET +
+		                          (i * DWC_EP_REG_OFFSET));
+		DWC_DEBUGPL(DBG_CILV, "in_ep_regs[%d]->diepctl=%p\n",
+		            i, &dev_if->in_ep_regs[i]->diepctl);
+		DWC_DEBUGPL(DBG_CILV, "out_ep_regs[%d]->doepctl=%p\n",
+		            i, &dev_if->out_ep_regs[i]->doepctl);
+	}
+
+	dev_if->speed = 0; // unknown
+
+	core_if->dev_if = dev_if;
+
+	/*
+	 * Allocate the Host Mode structures.
+	 */
+	host_if = kmalloc( sizeof(dwc_otg_host_if_t), GFP_KERNEL);
+
+	if (host_if == 0)
+	{
+		DWC_DEBUGPL(DBG_CIL, "Allocation of dwc_otg_host_if_t failed\n");
+		kfree( dev_if );
+		kfree( core_if );
+		return 0;
+	}
+
+	host_if->host_global_regs = (dwc_otg_host_global_regs_t *)
+	                            (reg_base + DWC_OTG_HOST_GLOBAL_REG_OFFSET);
+
+	host_if->hprt0 = (uint32_t*)(reg_base + DWC_OTG_HOST_PORT_REGS_OFFSET);
+
+	for (i=0; i<MAX_EPS_CHANNELS; i++)
+	{
+		host_if->hc_regs[i] = (dwc_otg_hc_regs_t *)
+		                      (reg_base + DWC_OTG_HOST_CHAN_REGS_OFFSET +
+		                       (i * DWC_OTG_CHAN_REGS_OFFSET));
+		DWC_DEBUGPL(DBG_CILV, "hc_reg[%d]->hcchar=%p\n",
+		            i, &host_if->hc_regs[i]->hcchar);
+	}
+
+	host_if->num_host_channels = MAX_EPS_CHANNELS;
+	core_if->host_if = host_if;
+
+	for (i=0; i<MAX_EPS_CHANNELS; i++)
+	{
+		core_if->data_fifo[i] =
+		    (uint32_t *)(reg_base + DWC_OTG_DATA_FIFO_OFFSET +
+		                 (i * DWC_OTG_DATA_FIFO_SIZE));
+		DWC_DEBUGPL(DBG_CILV, "data_fifo[%d]=0x%08x\n",
+		            i, (unsigned)core_if->data_fifo[i]);
+	}
+
+	core_if->pcgcctl = (uint32_t*)(reg_base + DWC_OTG_PCGCCTL_OFFSET);
+
+	/*
+	 * Store the contents of the hardware configuration registers here for
+	 * easy access later.
+	 */
+	core_if->hwcfg1.d32 = dwc_read_reg32(&core_if->core_global_regs->ghwcfg1);
+	core_if->hwcfg2.d32 = dwc_read_reg32(&core_if->core_global_regs->ghwcfg2);
+	core_if->hwcfg3.d32 = dwc_read_reg32(&core_if->core_global_regs->ghwcfg3);
+	core_if->hwcfg4.d32 = dwc_read_reg32(&core_if->core_global_regs->ghwcfg4);
+
+	DWC_DEBUGPL(DBG_CILV,"hwcfg1=%08x\n",core_if->hwcfg1.d32);
+	DWC_DEBUGPL(DBG_CILV,"hwcfg2=%08x\n",core_if->hwcfg2.d32);
+	DWC_DEBUGPL(DBG_CILV,"hwcfg3=%08x\n",core_if->hwcfg3.d32);
+	DWC_DEBUGPL(DBG_CILV,"hwcfg4=%08x\n",core_if->hwcfg4.d32);
+
+	DWC_DEBUGPL(DBG_CILV,"op_mode=%0x\n",core_if->hwcfg2.b.op_mode);
+	DWC_DEBUGPL(DBG_CILV,"arch=%0x\n",core_if->hwcfg2.b.architecture);
+	DWC_DEBUGPL(DBG_CILV,"num_dev_ep=%d\n",core_if->hwcfg2.b.num_dev_ep);
+	DWC_DEBUGPL(DBG_CILV,"num_host_chan=%d\n",core_if->hwcfg2.b.num_host_chan);
+	DWC_DEBUGPL(DBG_CILV,"nonperio_tx_q_depth=0x%0x\n",core_if->hwcfg2.b.nonperio_tx_q_depth);
+	DWC_DEBUGPL(DBG_CILV,"host_perio_tx_q_depth=0x%0x\n",core_if->hwcfg2.b.host_perio_tx_q_depth);
+	DWC_DEBUGPL(DBG_CILV,"dev_token_q_depth=0x%0x\n",core_if->hwcfg2.b.dev_token_q_depth);
+
+	DWC_DEBUGPL(DBG_CILV,"Total FIFO SZ=4160\n");//, core_if->hwcfg3.b.dfifo_depth);
+	DWC_DEBUGPL(DBG_CILV,"xfer_size_cntr_width=%0x\n", core_if->hwcfg3.b.xfer_size_cntr_width);
+
+	/*
+	 * Set the SRP sucess bit for FS-I2c
+	 */
+	core_if->srp_success = 0;
+	core_if->srp_timer_started = 0;
+
+	return core_if;
+}
+
+/**
+ * This function frees the structures allocated by dwc_otg_cil_init().
+ *
+ * @param[in] _core_if The core interface pointer returned from
+ * dwc_otg_cil_init().
+ *
+ */
+void dwc_otg_cil_remove( dwc_otg_core_if_t *_core_if )
+{
+	/* Disable all interrupts */
+	dwc_modify_reg32( &_core_if->core_global_regs->gahbcfg, 1, 0);
+	dwc_write_reg32( &_core_if->core_global_regs->gintmsk, 0);
+
+	if ( _core_if->dev_if ) {
+		kfree( _core_if->dev_if );
+	}
+	if ( _core_if->host_if ) {
+		kfree( _core_if->host_if );
+	}
+	kfree( _core_if );
+}
+
+/**
+ * This function enables the controller's Global Interrupt in the AHB Config
+ * register.
+ *
+ * @param[in] _core_if Programming view of DWC_otg controller.
+ */
+extern void dwc_otg_enable_global_interrupts( dwc_otg_core_if_t *_core_if )
+{
+	gahbcfg_data_t ahbcfg = { .d32 = 0};
+	ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
+	dwc_modify_reg32(&_core_if->core_global_regs->gahbcfg, 0, ahbcfg.d32);
+}
+
+/**
+ * This function disables the controller's Global Interrupt in the AHB Config
+ * register.
+ *
+ * @param[in] _core_if Programming view of DWC_otg controller.
+ */
+extern void dwc_otg_disable_global_interrupts( dwc_otg_core_if_t *_core_if )
+{
+	gahbcfg_data_t ahbcfg = { .d32 = 0};
+	ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
+	dwc_modify_reg32(&_core_if->core_global_regs->gahbcfg, ahbcfg.d32, 0);
+}
+
+/**
+ * This function initializes the commmon interrupts, used in both
+ * device and host modes.
+ *
+ * @param[in] _core_if Programming view of the DWC_otg controller
+ *
+ */
+static void dwc_otg_enable_common_interrupts(dwc_otg_core_if_t *_core_if)
+{
+	dwc_otg_core_global_regs_t *global_regs =
+	    _core_if->core_global_regs;
+	gintmsk_data_t intr_mask = { .d32 = 0};
+
+	/* Clear any pending OTG Interrupts */
+	dwc_write_reg32( &global_regs->gotgint, 0xFFFFFFFF);
+
+	/* Clear any pending interrupts */
+	dwc_write_reg32( &global_regs->gintsts, 0xFFFFFFFF);
+
+	/*
+	 * Enable the interrupts in the GINTMSK.
+	 */
+	intr_mask.b.modemismatch = 1;
+	intr_mask.b.otgintr = 1;
+
+	if (!_core_if->dma_enable)
+	{
+		intr_mask.b.rxstsqlvl = 1;
+	}
+
+	intr_mask.b.conidstschng = 1;
+	intr_mask.b.wkupintr = 1;
+	intr_mask.b.disconnect = 1;
+	intr_mask.b.usbsuspend = 1;
+	intr_mask.b.sessreqintr = 1;
+	dwc_write_reg32( &global_regs->gintmsk, intr_mask.d32);
+}
+
+/**
+ * Initializes the FSLSPClkSel field of the HCFG register depending on the PHY
+ * type.
+ */
+static void init_fslspclksel(dwc_otg_core_if_t *_core_if)
+{
+	uint32_t	val;
+	hcfg_data_t		hcfg;
+
+	if (((_core_if->hwcfg2.b.hs_phy_type == 2) &&
+	        (_core_if->hwcfg2.b.fs_phy_type == 1) &&
+	        (_core_if->core_params->ulpi_fs_ls)) ||
+	        (_core_if->core_params->phy_type == DWC_PHY_TYPE_PARAM_FS))
+	{
+		/* Full speed PHY */
+		val = DWC_HCFG_48_MHZ;
+	}
+	else
+	{
+		/* High speed PHY running at full speed or high speed */
+		val = DWC_HCFG_30_60_MHZ;
+	}
+
+	DWC_DEBUGPL(DBG_CIL, "Initializing HCFG.FSLSPClkSel to 0x%1x\n", val);
+	hcfg.d32 = dwc_read_reg32(&_core_if->host_if->host_global_regs->hcfg);
+	hcfg.b.fslspclksel = val;
+	dwc_write_reg32(&_core_if->host_if->host_global_regs->hcfg, hcfg.d32);
+}
+
+/**
+ * Initializes the DevSpd field of the DCFG register depending on the PHY type
+ * and the enumeration speed of the device.
+ */
+static void init_devspd(dwc_otg_core_if_t *_core_if)
+{
+	uint32_t	val;
+	dcfg_data_t		dcfg;
+
+	if (((_core_if->hwcfg2.b.hs_phy_type == 2) &&
+	        (_core_if->hwcfg2.b.fs_phy_type == 1) &&
+	        (_core_if->core_params->ulpi_fs_ls)) ||
+	        (_core_if->core_params->phy_type == DWC_PHY_TYPE_PARAM_FS))
+	{
+		/* Full speed PHY */
+		val = 0x3;
+	}
+	else if (_core_if->core_params->speed == DWC_SPEED_PARAM_FULL)
+	{
+		/* High speed PHY running at full speed */
+		val = 0x1;
+	}
+	else
+	{
+		/* High speed PHY running at high speed */
+		val = 0x0;
+	}
+
+	DWC_DEBUGPL(DBG_CIL, "Initializing DCFG.DevSpd to 0x%1x\n", val);
+
+	dcfg.d32 = dwc_read_reg32(&_core_if->dev_if->dev_global_regs->dcfg);
+	dcfg.b.devspd = val;
+	dwc_write_reg32(&_core_if->dev_if->dev_global_regs->dcfg, dcfg.d32);
+}
+
+/**
+ * This function calculates the number of IN EPS
+ * using GHWCFG1 and GHWCFG2 registers values
+ *
+ * @param _pcd the pcd structure.
+ */
+static uint32_t calc_num_in_eps(dwc_otg_core_if_t *_core_if)
+{
+	uint32_t num_in_eps = 0;
+	uint32_t num_eps = _core_if->hwcfg2.b.num_dev_ep;
+	uint32_t hwcfg1 = _core_if->hwcfg1.d32 >> 3;
+	uint32_t num_tx_fifos = _core_if->hwcfg4.b.num_in_eps;
+	int i;
+
+
+	for (i = 0; i < num_eps; ++i)
+	{
+		if (!(hwcfg1 & 0x1))
+			num_in_eps++;
+
+		hwcfg1 >>= 2;
+	}
+
+	if (_core_if->hwcfg4.b.ded_fifo_en)
+	{
+		num_in_eps = (num_in_eps > num_tx_fifos) ? num_tx_fifos : num_in_eps;
+	}
+
+	return num_in_eps;
+}
+
+
+/**
+ * This function calculates the number of OUT EPS
+ * using GHWCFG1 and GHWCFG2 registers values
+ *
+ * @param _pcd the pcd structure.
+ */
+static uint32_t calc_num_out_eps(dwc_otg_core_if_t *_core_if)
+{
+	uint32_t num_out_eps = 0;
+	uint32_t num_eps = _core_if->hwcfg2.b.num_dev_ep;
+	uint32_t hwcfg1 = _core_if->hwcfg1.d32 >> 2;
+	int i;
+
+	for (i = 0; i < num_eps; ++i)
+	{
+		if (!(hwcfg1 & 0x2))
+			num_out_eps++;
+
+		hwcfg1 >>= 2;
+	}
+	return num_out_eps;
+}
+/**
+ * This function initializes the DWC_otg controller registers and
+ * prepares the core for device mode or host mode operation.
+ *
+ * @param _core_if Programming view of the DWC_otg controller
+ *
+ */
+void dwc_otg_core_init(dwc_otg_core_if_t *_core_if)
+{
+	int i = 0;
+	dwc_otg_core_global_regs_t *global_regs =
+	    _core_if->core_global_regs;
+	dwc_otg_dev_if_t *dev_if = _core_if->dev_if;
+	gahbcfg_data_t ahbcfg = { .d32 = 0};
+	gusbcfg_data_t usbcfg = { .d32 = 0 };
+	gi2cctl_data_t i2cctl = {.d32 = 0};
+
+	//AlenOh for core reset halt test DWC_DEBUGPL(DBG_CILV, "dwc_otg_core_init(%p)\n",_core_if);
+
+	/* Common Initialization */
+
+	usbcfg.d32 = dwc_read_reg32(&global_regs->gusbcfg);
+
+	/* Program the ULPI External VBUS bit if needed */
+	usbcfg.b.ulpi_ext_vbus_drv = 0;
+	//(_core_if->core_params->phy_ulpi_ext_vbus == DWC_PHY_ULPI_EXTERNAL_VBUS) ? 1 : 0;
+
+	/* Set external TS Dline pulsing */
+	usbcfg.b.term_sel_dl_pulse = (_core_if->core_params->ts_dline == 1) ? 1 : 0;
+	//AlenOh for core reset halt test DWC_DEBUGPL(DBG_CILV, "term_sel_dl_pulse=%d\n",usbcfg.b.term_sel_dl_pulse);
+	dwc_write_reg32 (&global_regs->gusbcfg, usbcfg.d32);
+
+	/* Reset the Controller */
+	dwc_otg_core_reset( _core_if );
+
+	//AlenOh
+	_core_if->vbus_state = 0;
+	schedule_work(&_core_if->vbus_work);
+
+	/* Initialize parameters from Hardware configuration registers. */
+	dev_if->num_in_eps = calc_num_in_eps(_core_if);
+	dev_if->num_out_eps = calc_num_out_eps(_core_if);
+
+
+	DWC_DEBUGPL(DBG_CIL, "num_dev_perio_in_ep=%d\n",_core_if->hwcfg4.b.num_dev_perio_in_ep);
+
+	for (i=0; i < _core_if->hwcfg4.b.num_dev_perio_in_ep; i++)
+	{
+		dev_if->perio_tx_fifo_size[i] =
+		    dwc_read_reg32( &global_regs->dptxfsiz_dieptxf[i]) >> 16;
+		DWC_DEBUGPL(DBG_CIL, "Periodic Tx FIFO SZ #%d=0x%0x\n",
+		            i, dev_if->perio_tx_fifo_size[i]);
+	}
+
+	for (i=0; i < _core_if->hwcfg4.b.num_in_eps; i++)
+	{
+		dev_if->tx_fifo_size[i] =
+		    dwc_read_reg32( &global_regs->dptxfsiz_dieptxf[i]) >> 16;
+		DWC_DEBUGPL(DBG_CIL, "Tx FIFO SZ #%d=0x%0x\n",
+		            i, dev_if->tx_fifo_size[i]);
+	}
+
+	_core_if->total_fifo_size = 4160;//_core_if->hwcfg3.b.dfifo_depth;
+	_core_if->rx_fifo_size =
+	    dwc_read_reg32( &global_regs->grxfsiz);
+	_core_if->nperio_tx_fifo_size =
+	    dwc_read_reg32( &global_regs->gnptxfsiz) >> 16;
+
+	DWC_DEBUGPL(DBG_CIL, "Total FIFO SZ=%d\n", _core_if->total_fifo_size);
+	DWC_DEBUGPL(DBG_CIL, "Rx FIFO SZ=%d\n", _core_if->rx_fifo_size);
+	DWC_DEBUGPL(DBG_CIL, "NP Tx FIFO SZ=%d\n", _core_if->nperio_tx_fifo_size);
+
+	/* This programming sequence needs to happen in FS mode before any other
+	 * programming occurs */
+	if ((_core_if->core_params->speed == DWC_SPEED_PARAM_FULL) &&
+	        (_core_if->core_params->phy_type == DWC_PHY_TYPE_PARAM_FS))
+	{
+		/* If FS mode with FS PHY */
+		DWC_DEBUGPL(DBG_CIL, "FS mode with FS PHY\n");
+
+		/* core_init() is now called on every switch so only call the
+		 * following for the first time through. */
+		if (!_core_if->phy_init_done)
+		{
+			_core_if->phy_init_done = 1;
+			DWC_DEBUGPL(DBG_CIL, "FS_PHY detected\n");
+			usbcfg.d32 = dwc_read_reg32(&global_regs->gusbcfg);
+			usbcfg.b.physel = 1;
+			dwc_write_reg32 (&global_regs->gusbcfg, usbcfg.d32);
+
+			/* Reset after a PHY select */
+			dwc_otg_core_reset( _core_if );
+		}
+
+		/* Program DCFG.DevSpd or HCFG.FSLSPclkSel to 48Mhz in FS.	Also
+		 * do this on HNP Dev/Host mode switches (done in dev_init and
+		 * host_init). */
+		if (dwc_otg_is_host_mode(_core_if))
+		{
+			init_fslspclksel(_core_if);
+		}
+		else
+		{
+			init_devspd(_core_if);
+		}
+
+		if (_core_if->core_params->i2c_enable)
+		{
+			DWC_DEBUGPL(DBG_CIL, "FS_PHY Enabling I2c\n");
+			/* Program GUSBCFG.OtgUtmifsSel to I2C */
+			usbcfg.d32 = dwc_read_reg32(&global_regs->gusbcfg);
+			usbcfg.b.otgutmifssel = 1;
+			dwc_write_reg32 (&global_regs->gusbcfg, usbcfg.d32);
+
+			/* Program GI2CCTL.I2CEn */
+			i2cctl.d32 = dwc_read_reg32(&global_regs->gi2cctl);
+			i2cctl.b.i2cdevaddr = 1;
+			i2cctl.b.i2cen = 0;
+			dwc_write_reg32 (&global_regs->gi2cctl, i2cctl.d32);
+			i2cctl.b.i2cen = 1;
+			dwc_write_reg32 (&global_regs->gi2cctl, i2cctl.d32);
+		}
+
+	} /* endif speed == DWC_SPEED_PARAM_FULL */
+
+	else
+	{
+		/* High speed PHY. */
+		DWC_DEBUGPL(DBG_CIL, "High speed PHY\n");
+		if (!_core_if->phy_init_done)
+		{
+			_core_if->phy_init_done = 1;
+			/* HS PHY parameters.  These parameters are preserved
+			 * during soft reset so only program the first time.  Do
+			 * a soft reset immediately after setting phyif.  */
+			if (_core_if->core_params->phy_type == DWC_PHY_TYPE_PARAM_ULPI)
+			{
+				/* ULPI interface */
+				DWC_DEBUGPL(DBG_CIL, "ULPI interface\n");
+				usbcfg.b.ulpi_utmi_sel = 1;
+				usbcfg.b.phyif = 0;
+				usbcfg.b.ddrsel = _core_if->core_params->phy_ulpi_ddr;
+			}
+			else
+			{
+				/* UTMI+ interface */
+				DWC_DEBUGPL(DBG_CIL, "UTMI+ interface\n");
+				usbcfg.b.ulpi_utmi_sel = 0;
+				if (_core_if->core_params->phy_utmi_width == 16) {
+					usbcfg.b.phyif = 1;
+				}
+				else
+				{
+					usbcfg.b.phyif = 0;
+				}
+			}
+
+			dwc_write_reg32( &global_regs->gusbcfg, usbcfg.d32);
+
+			/* Reset after setting the PHY parameters */
+			dwc_otg_core_reset( _core_if );
+		}
+	}
+
+	//if ((_core_if->hwcfg2.b.hs_phy_type == 2) &&
+	//	(_core_if->hwcfg2.b.fs_phy_type == 1) &&
+	//	(_core_if->core_params->ulpi_fs_ls))
+	//{
+	//	DWC_DEBUGPL(DBG_CIL, "Setting ULPI FSLS\n");
+	//	usbcfg.d32 = dwc_read_reg32(&global_regs->gusbcfg);
+	//	usbcfg.b.ulpi_fsls = 1;
+	//	usbcfg.b.ulpi_clk_sus_m = 1;
+	//	dwc_write_reg32(&global_regs->gusbcfg, usbcfg.d32);
+	//}
+	//else
+	{
+		usbcfg.d32 = dwc_read_reg32(&global_regs->gusbcfg);
+		usbcfg.b.ulpi_fsls = 0;
+		usbcfg.b.ulpi_clk_sus_m = 0;
+		dwc_write_reg32(&global_regs->gusbcfg, usbcfg.d32);
+	}
+
+	/* Program the GAHBCFG Register.*/
+	//switch (_core_if->hwcfg2.b.architecture)
+	//{
+	//
+	//case DWC_SLAVE_ONLY_ARCH:
+	//	DWC_DEBUGPL(DBG_CIL, "Slave Only Mode\n");
+	//	ahbcfg.b.nptxfemplvl_txfemplvl = DWC_GAHBCFG_TXFEMPTYLVL_HALFEMPTY;
+	//	ahbcfg.b.ptxfemplvl = DWC_GAHBCFG_TXFEMPTYLVL_HALFEMPTY;
+	//_core_if->dma_enable = 0;
+	//	break;
+	//
+	//case DWC_EXT_DMA_ARCH:
+	//	DWC_DEBUGPL(DBG_CIL, "External DMA Mode\n");
+	//	ahbcfg.b.hburstlen = _core_if->core_params->dma_burst_size;
+	//_core_if->dma_enable = (_core_if->core_params->dma_enable != 0);
+	//	break;
+	//
+	//case DWC_INT_DMA_ARCH:
+	DWC_DEBUGPL(DBG_CIL, "Internal DMA Mode\n");
+//		ahbcfg.b.hburstlen = DWC_GAHBCFG_INT_DMA_BURST_INCR;
+//		_core_if->dma_enable = (_core_if->core_params->dma_enable != 0);
+
+	if (_core_if->core_params->dma_enable)
+	{
+		ahbcfg.b.dmaenable = 1;
+		ahbcfg.b.hburstlen = DWC_GAHBCFG_INT_DMA_BURST_INCR16;//0; //It increases EP IN transaction speed - AlenOh
+		_core_if->dma_enable = 1;
+		DWC_PRINT("Internal DMA Mode...\n");
+	}
+	else
+	{
+		ahbcfg.b.dmaenable = 0;
+		ahbcfg.b.hburstlen = 0;
+
+		//AlenOh
+		ahbcfg.b.nptxfemplvl_txfemplvl = DWC_GAHBCFG_TXFEMPTYLVL_EMPTY;
+		ahbcfg.b.ptxfemplvl = DWC_GAHBCFG_TXFEMPTYLVL_EMPTY;
+
+		_core_if->dma_enable = 0;
+		DWC_PRINT("Slave Mode...\n");
+	}
+	//	break;
+	//
+	//}
+
+	ahbcfg.b.dmaenable = _core_if->dma_enable;
+	dwc_write_reg32(&global_regs->gahbcfg, ahbcfg.d32);
+
+	_core_if->en_multiple_tx_fifo = _core_if->hwcfg4.b.ded_fifo_en;
+
+
+	/*
+	 * Program the GUSBCFG register.
+	 */
+	usbcfg.d32 = dwc_read_reg32( &global_regs->gusbcfg );
+
+	//switch (_core_if->hwcfg2.b.op_mode)
+	//{
+	//case DWC_MODE_HNP_SRP_CAPABLE:
+	usbcfg.b.hnpcap = (_core_if->core_params->otg_cap ==
+	                   DWC_OTG_CAP_PARAM_HNP_SRP_CAPABLE);
+	usbcfg.b.srpcap = (_core_if->core_params->otg_cap !=
+	                   DWC_OTG_CAP_PARAM_NO_HNP_SRP_CAPABLE);
+	//	break;
+	//
+	//case DWC_MODE_SRP_ONLY_CAPABLE:
+	//	usbcfg.b.hnpcap = 0;
+	//	usbcfg.b.srpcap = (_core_if->core_params->otg_cap !=
+	//	   DWC_OTG_CAP_PARAM_NO_HNP_SRP_CAPABLE);
+	//	break;
+	//
+	//case DWC_MODE_NO_HNP_SRP_CAPABLE:
+	//	usbcfg.b.hnpcap = 0;
+	//	usbcfg.b.srpcap = 0;
+	//	break;
+	//
+	//case DWC_MODE_SRP_CAPABLE_DEVICE:
+	//	usbcfg.b.hnpcap = 0;
+	//	usbcfg.b.srpcap = (_core_if->core_params->otg_cap !=
+	//	DWC_OTG_CAP_PARAM_NO_HNP_SRP_CAPABLE);
+	//	break;
+	//
+	//case DWC_MODE_NO_SRP_CAPABLE_DEVICE:
+	//	usbcfg.b.hnpcap = 0;
+	//	usbcfg.b.srpcap = 0;
+	//	break;
+	//
+	//case DWC_MODE_SRP_CAPABLE_HOST:
+	//	usbcfg.b.hnpcap = 0;
+	//	usbcfg.b.srpcap = (_core_if->core_params->otg_cap !=
+	//	DWC_OTG_CAP_PARAM_NO_HNP_SRP_CAPABLE);
+	//	break;
+	//
+	//case DWC_MODE_NO_SRP_CAPABLE_HOST:
+	//	usbcfg.b.hnpcap = 0;
+	//	usbcfg.b.srpcap = 0;
+	//	break;
+	//}
+
+	dwc_write_reg32( &global_regs->gusbcfg, usbcfg.d32);
+
+	/* Enable common interrupts */
+	dwc_otg_enable_common_interrupts( _core_if );
+
+	/* Do device or host intialization based on mode during PCD
+	 * and HCD initialization  */
+	if (dwc_otg_is_host_mode( _core_if ))
+	{
+		DWC_DEBUGPL(DBG_ANY, "Host Mode\n" );
+		_core_if->op_state = A_HOST;
+	}
+	else
+	{
+		DWC_DEBUGPL(DBG_ANY, "Device Mode\n" );
+		_core_if->op_state = B_PERIPHERAL;
+#ifdef DWC_DEVICE_ONLY
+		dwc_otg_core_dev_init( _core_if );
+#endif
+	}
+}
+
+
+/**
+ * This function enables the Device mode interrupts.
+ *
+ * @param _core_if Programming view of DWC_otg controller
+ */
+void dwc_otg_enable_device_interrupts(dwc_otg_core_if_t *_core_if)
+{
+	gintmsk_data_t intr_mask = { .d32 = 0};
+	dwc_otg_core_global_regs_t *global_regs =
+	    _core_if->core_global_regs;
+
+	DWC_DEBUGPL(DBG_CIL, "%s()\n", __func__);
+
+	/* Disable all interrupts. */
+	dwc_write_reg32( &global_regs->gintmsk, 0);
+
+	/* Clear any pending interrupts */
+	dwc_write_reg32( &global_regs->gintsts, 0xFFFFFFFF);
+
+	/* Enable the common interrupts */
+	dwc_otg_enable_common_interrupts( _core_if );
+
+	/* Enable interrupts */
+	intr_mask.b.usbreset = 1;
+	intr_mask.b.enumdone = 1;
+	intr_mask.b.inepintr = 1;
+	intr_mask.b.outepintr = 1;
+	intr_mask.b.erlysuspend = 1;
+
+	//if(_core_if->en_multiple_tx_fifo == 0)
+	//{
+	//	intr_mask.b.epmismatch = 1;
+	//}
+
+	/** @todo NGS: Should this be a module parameter? */
+#ifdef USE_PERIODIC_EP
+	intr_mask.b.isooutdrop = 1;
+	intr_mask.b.eopframe = 1;
+	intr_mask.b.incomplisoin = 1;
+	intr_mask.b.incomplisoout = 1;
+#endif
+
+	dwc_modify_reg32( &global_regs->gintmsk, intr_mask.d32, intr_mask.d32);
+
+	DWC_DEBUGPL(DBG_CIL, "%s() gintmsk=%0x\n", __func__,
+	            dwc_read_reg32( &global_regs->gintmsk));
+}
+
+/**
+ * This function initializes the DWC_otg controller registers for
+ * device mode.
+ *
+ * @param _core_if Programming view of DWC_otg controller
+ *
+ */
+void dwc_otg_core_dev_init(dwc_otg_core_if_t *_core_if)
+{
+	int i;
+	dwc_otg_core_global_regs_t *global_regs =
+	    _core_if->core_global_regs;
+	dwc_otg_dev_if_t *dev_if = _core_if->dev_if;
+	dwc_otg_core_params_t *params = _core_if->core_params;
+	dcfg_data_t dcfg = {.d32 = 0};
+	grstctl_t resetctl = { .d32=0 };
+	uint32_t rx_fifo_size;
+	fifosize_data_t nptxfifosize;
+	fifosize_data_t txfifosize;
+	dthrctl_data_t dthrctl;
+
+	/* Restart the Phy Clock */
+	dwc_write_reg32(_core_if->pcgcctl, 0);
+
+	/* Device configuration register */
+	init_devspd(_core_if);
+	dcfg.d32 = dwc_read_reg32( &dev_if->dev_global_regs->dcfg);
+	dcfg.b.perfrint = DWC_DCFG_FRAME_INTERVAL_80;
+	dwc_write_reg32( &dev_if->dev_global_regs->dcfg, dcfg.d32 );
+
+	/* Configure data FIFO sizes */
+	if ( _core_if->hwcfg2.b.dynamic_fifo && params->enable_dynamic_fifo )
+	{
+		DWC_DEBUGPL(DBG_CIL, "Total FIFO Size=%d\n", _core_if->total_fifo_size);
+		DWC_DEBUGPL(DBG_CIL, "Rx FIFO Size=%d\n", params->dev_rx_fifo_size);
+		DWC_DEBUGPL(DBG_CIL, "NP Tx FIFO Size=%d\n", params->dev_nperio_tx_fifo_size);
+
+		/* Rx FIFO */
+		DWC_DEBUGPL(DBG_CIL, "initial grxfsiz=%08x\n",
+		            dwc_read_reg32(&global_regs->grxfsiz));
+
+		rx_fifo_size = params->dev_rx_fifo_size;
+		dwc_write_reg32( &global_regs->grxfsiz, rx_fifo_size );
+
+		DWC_DEBUGPL(DBG_CIL, "new grxfsiz=%08x\n",
+		            dwc_read_reg32(&global_regs->grxfsiz));
+
+		/** Set Periodic Tx FIFO Mask all bits 0 */
+		_core_if->p_tx_msk = 0;
+
+		/** Set Tx FIFO Mask all bits 0 */
+		_core_if->tx_msk = 0;
+
+		//if(_core_if->en_multiple_tx_fifo == 0)
+		//{
+		//	fifosize_data_t ptxfifosize;
+		//	/* Non-periodic Tx FIFO */
+		//	DWC_DEBUGPL(DBG_CIL, "initial gnptxfsiz=%08x\n",
+		//				   dwc_read_reg32(&global_regs->gnptxfsiz));
+		//
+		//	nptxfifosize.b.depth  = params->dev_nperio_tx_fifo_size;
+		//	nptxfifosize.b.startaddr = params->dev_rx_fifo_size;
+		//
+		//	dwc_write_reg32( &global_regs->gnptxfsiz, nptxfifosize.d32 );
+		//
+		//	DWC_DEBUGPL(DBG_CIL, "new gnptxfsiz=%08x\n",
+		//				   dwc_read_reg32(&global_regs->gnptxfsiz));
+		//
+		//	/**@todo NGS: Fix Periodic FIFO Sizing! */
+		//	/*
+		//	 * Periodic Tx FIFOs These FIFOs are numbered from 1 to 15.
+		//	 * Indexes of the FIFO size module parameters in the
+		//	 * dev_perio_tx_fifo_size array and the FIFO size registers in
+		//	 * the dptxfsiz array run from 0 to 14.
+		//	 */
+		//	/** @todo Finish debug of this */
+		//	ptxfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
+		//	for (i=0; i < _core_if->hwcfg4.b.num_dev_perio_in_ep; i++)
+		//	{
+		//		ptxfifosize.b.depth = params->dev_perio_tx_fifo_size[i];
+		//		DWC_DEBUGPL(DBG_CIL, "initial dptxfsiz_dieptxf[%d]=%08x\n", i,
+		//					dwc_read_reg32(&global_regs->dptxfsiz_dieptxf[i]));
+		//		dwc_write_reg32( &global_regs->dptxfsiz_dieptxf[i],
+		//						 ptxfifosize.d32 );
+		//		DWC_DEBUGPL(DBG_CIL, "new dptxfsiz_dieptxf[%d]=%08x\n", i,
+		//					dwc_read_reg32(&global_regs->dptxfsiz_dieptxf[i]));
+		//		ptxfifosize.b.startaddr += ptxfifosize.b.depth;
+		//	}
+		//}
+		//else
+		{
+			DWC_DEBUGPL(DBG_CIL, "multiple tx fifo\n");
+			/*
+			 * Tx FIFOs These FIFOs are numbered from 1 to 15.
+			 * Indexes of the FIFO size module parameters in the
+			 * dev_tx_fifo_size array and the FIFO size registers in
+			 * the dptxfsiz_dieptxf array run from 0 to 14.
+			 */
+
+
+			/* Non-periodic Tx FIFO */
+			DWC_DEBUGPL(DBG_CIL, "initial gnptxfsiz=%08x\n",
+			            dwc_read_reg32(&global_regs->gnptxfsiz));
+
+			nptxfifosize.b.depth  = params->dev_nperio_tx_fifo_size;
+			nptxfifosize.b.startaddr = params->dev_rx_fifo_size;
+
+			dwc_write_reg32( &global_regs->gnptxfsiz, nptxfifosize.d32 );
+
+			DWC_DEBUGPL(DBG_CIL, "new gnptxfsiz=%08x\n",
+			            dwc_read_reg32(&global_regs->gnptxfsiz));
+
+			txfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
+
+			for (i=1; i < 9/*AlenOh _core_if->hwcfg4.b.num_dev_perio_in_ep*/; i++)
+			{
+				txfifosize.b.depth = params->dev_tx_fifo_size[i];
+
+				DWC_DEBUGPL(DBG_CIL, "initial dptxfsiz_dieptxf[%d]=%08x\n", i,
+				            dwc_read_reg32(&global_regs->dptxfsiz_dieptxf[i-1]));
+
+				dwc_write_reg32( &global_regs->dptxfsiz_dieptxf[i-1],
+				                 txfifosize.d32 );
+
+				DWC_DEBUGPL(DBG_CIL, "new dptxfsiz_dieptxf[%d]=%08x\n", i,
+				            dwc_read_reg32(&global_regs->dptxfsiz_dieptxf[i-1]));
+
+				txfifosize.b.startaddr += txfifosize.b.depth;
+			}
+
+			if (txfifosize.b.startaddr>params->data_fifo_size)
+			{
+				printk("usb:serious error:fifo overflow error! (fifo size %d/%d)\n",txfifosize.b.startaddr,params->data_fifo_size);
+				while (1);
+			}
+		}
+	}
+	/* Flush the FIFOs */
+	dwc_otg_flush_tx_fifo(_core_if, 0x10); /* all Tx FIFOs */
+	dwc_otg_flush_rx_fifo(_core_if);
+
+	/* Flush the Learning Queue. */
+	resetctl.b.intknqflsh = 1;
+	dwc_write_reg32( &_core_if->core_global_regs->grstctl, resetctl.d32);
+
+	/* Clear all pending Device Interrupts */
+	dwc_write_reg32( &dev_if->dev_global_regs->diepmsk, 0 );
+	dwc_write_reg32( &dev_if->dev_global_regs->doepmsk, 0 );
+	dwc_write_reg32( &dev_if->dev_global_regs->daint, 0xFFFFFFFF );
+	dwc_write_reg32( &dev_if->dev_global_regs->daintmsk, 0 );
+
+	for (i=0; i <= dev_if->num_in_eps; i++)
+	{
+		depctl_data_t depctl;
+		depctl.d32 = dwc_read_reg32(&dev_if->in_ep_regs[i]->diepctl);
+		if (depctl.b.epena)
+		{
+			depctl.d32 = 0;
+			depctl.b.epdis = 1;
+			depctl.b.snak = 1;
+		}
+		else
+		{
+			depctl.d32 = 0;
+		}
+
+		dwc_write_reg32( &dev_if->in_ep_regs[i]->diepctl, depctl.d32);
+
+
+		dwc_write_reg32( &dev_if->in_ep_regs[i]->dieptsiz, 0);
+		dwc_write_reg32( &dev_if->in_ep_regs[i]->diepdma, 0);
+		dwc_write_reg32( &dev_if->in_ep_regs[i]->diepint, 0xFF);
+	}
+
+	for (i=0; i <= dev_if->num_out_eps; i++)
+	{
+		depctl_data_t depctl;
+		depctl.d32 = dwc_read_reg32(&dev_if->out_ep_regs[i]->doepctl);
+		if (depctl.b.epena)
+		{
+			depctl.d32 = 0;
+			depctl.b.epdis = 1;
+			depctl.b.snak = 1;
+		}
+		else
+		{
+			depctl.d32 = 0;
+		}
+
+		dwc_write_reg32( &dev_if->out_ep_regs[i]->doepctl, depctl.d32);
+
+		dwc_write_reg32( &dev_if->out_ep_regs[i]->doeptsiz, 0);
+		dwc_write_reg32( &dev_if->out_ep_regs[i]->doepdma, 0);
+		dwc_write_reg32( &dev_if->out_ep_regs[i]->doepint, 0xFF);
+	}
+
+	if (_core_if->en_multiple_tx_fifo && _core_if->dma_enable)
+	{
+		dev_if->non_iso_tx_thr_en = _core_if->core_params->thr_ctl & 0x1;
+		dev_if->iso_tx_thr_en = (_core_if->core_params->thr_ctl >> 1) & 0x1;
+		dev_if->rx_thr_en = (_core_if->core_params->thr_ctl >> 2) & 0x1;
+
+		dev_if->rx_thr_length = _core_if->core_params->rx_thr_length;
+		dev_if->tx_thr_length = _core_if->core_params->tx_thr_length;
+
+
+		dthrctl.d32 = 0;
+		dthrctl.b.non_iso_thr_en = dev_if->non_iso_tx_thr_en;
+		dthrctl.b.iso_thr_en = dev_if->iso_tx_thr_en;
+		dthrctl.b.tx_thr_len = dev_if->tx_thr_length;
+		dthrctl.b.rx_thr_en = dev_if->rx_thr_en;
+		dthrctl.b.rx_thr_len = dev_if->rx_thr_length;
+
+		dwc_write_reg32( &dev_if->dev_global_regs->dtknqr3_dthrctl, dthrctl.d32);
+
+		DWC_DEBUGPL(DBG_CIL, "Non ISO Tx Thr - %d\nISO Tx Thr - %d\nRx Thr - %d\nTx Thr Len - %d\nRx Thr Len - %d\n",
+		            dthrctl.b.non_iso_thr_en, dthrctl.b.iso_thr_en, dthrctl.b.rx_thr_en, dthrctl.b.tx_thr_len, dthrctl.b.rx_thr_len);
+
+	}
+
+	dwc_otg_enable_device_interrupts( _core_if );
+
+	//AlenOh
+	//{
+	//	diepmsk_data_t msk = {.d32 = 0};
+	//	msk.b.txfifoundrn = 1;
+	//	dwc_modify_reg32(&dev_if->dev_global_regs->diepmsk, msk.d32, msk.d32);
+	//}
+
+
+}
+
+/**
+ * This function enables the Host mode interrupts.
+ *
+ * @param _core_if Programming view of DWC_otg controller
+ */
+void dwc_otg_enable_host_interrupts(dwc_otg_core_if_t *_core_if)
+{
+	dwc_otg_core_global_regs_t *global_regs = _core_if->core_global_regs;
+	gintmsk_data_t intr_mask = {.d32 = 0};
+
+	DWC_DEBUGPL(DBG_CIL, "%s()\n", __func__);
+
+	/* Disable all interrupts. */
+	dwc_write_reg32(&global_regs->gintmsk, 0);
+
+	/* Clear any pending interrupts. */
+	dwc_write_reg32(&global_regs->gintsts, 0xFFFFFFFF);
+
+	/* Enable the common interrupts */
+	dwc_otg_enable_common_interrupts(_core_if);
+
+	/*
+	 * Enable host mode interrupts without disturbing common
+	 * interrupts.
+	 */
+	intr_mask.b.sofintr = 1;
+	intr_mask.b.portintr = 1;
+	intr_mask.b.hcintr = 1;
+
+	dwc_modify_reg32(&global_regs->gintmsk, intr_mask.d32, intr_mask.d32);
+}
+
+/**
+ * This function disables the Host Mode interrupts.
+ *
+ * @param _core_if Programming view of DWC_otg controller
+ */
+void dwc_otg_disable_host_interrupts(dwc_otg_core_if_t *_core_if)
+{
+	dwc_otg_core_global_regs_t *global_regs =
+	    _core_if->core_global_regs;
+	gintmsk_data_t intr_mask = {.d32 = 0};
+
+	DWC_DEBUGPL(DBG_CILV, "%s()\n", __func__);
+
+	/*
+	 * Disable host mode interrupts without disturbing common
+	 * interrupts.
+	 */
+	intr_mask.b.sofintr = 1;
+	intr_mask.b.portintr = 1;
+	intr_mask.b.hcintr = 1;
+	intr_mask.b.ptxfempty = 1;
+	intr_mask.b.nptxfempty = 1;
+
+	dwc_modify_reg32(&global_regs->gintmsk, intr_mask.d32, 0);
+}
+
+/**
+ * This function initializes the DWC_otg controller registers for
+ * host mode.
+ *
+ * This function flushes the Tx and Rx FIFOs and it flushes any entries in the
+ * request queues. Host channels are reset to ensure that they are ready for
+ * performing transfers.
+ *
+ * @param _core_if Programming view of DWC_otg controller
+ *
+ */
+void dwc_otg_core_host_init(dwc_otg_core_if_t *_core_if)
+{
+	dwc_otg_core_global_regs_t *global_regs = _core_if->core_global_regs;
+	dwc_otg_host_if_t	*host_if = _core_if->host_if;
+	dwc_otg_core_params_t	*params = _core_if->core_params;
+	hprt0_data_t		hprt0 = {.d32 = 0};
+	fifosize_data_t		nptxfifosize;
+	fifosize_data_t		ptxfifosize;
+	int			i;
+	hcchar_data_t		hcchar;
+	hcfg_data_t		hcfg;
+	dwc_otg_hc_regs_t	*hc_regs;
+	int			num_channels;
+	gotgctl_data_t	gotgctl = {.d32 = 0};
+
+	DWC_DEBUGPL(DBG_CILV,"%s(%p)\n", __func__, _core_if);
+
+	/* Restart the Phy Clock */
+	dwc_write_reg32(_core_if->pcgcctl, 0);
+
+	/* Initialize Host Configuration Register */
+	init_fslspclksel(_core_if);
+	if (_core_if->core_params->speed == DWC_SPEED_PARAM_FULL)
+	{
+		hcfg.d32 = dwc_read_reg32(&host_if->host_global_regs->hcfg);
+		hcfg.b.fslssupp = 1;
+		dwc_write_reg32(&host_if->host_global_regs->hcfg, hcfg.d32);
+	}
+
+	/* Configure data FIFO sizes */
+	if (_core_if->hwcfg2.b.dynamic_fifo && params->enable_dynamic_fifo)
+	{
+		DWC_DEBUGPL(DBG_CIL,"Total FIFO Size=%d\n", _core_if->total_fifo_size);
+		DWC_DEBUGPL(DBG_CIL,"Rx FIFO Size=%d\n", params->host_rx_fifo_size);
+		DWC_DEBUGPL(DBG_CIL,"NP Tx FIFO Size=%d\n", params->host_nperio_tx_fifo_size);
+		DWC_DEBUGPL(DBG_CIL,"P Tx FIFO Size=%d\n", params->host_perio_tx_fifo_size);
+
+		/* Rx FIFO */
+		DWC_DEBUGPL(DBG_CIL,"initial grxfsiz=%08x\n", dwc_read_reg32(&global_regs->grxfsiz));
+		dwc_write_reg32(&global_regs->grxfsiz, params->host_rx_fifo_size);
+		DWC_DEBUGPL(DBG_CIL,"new grxfsiz=%08x\n", dwc_read_reg32(&global_regs->grxfsiz));
+
+		/* Non-periodic Tx FIFO */
+		DWC_DEBUGPL(DBG_CIL,"initial gnptxfsiz=%08x\n", dwc_read_reg32(&global_regs->gnptxfsiz));
+		nptxfifosize.b.depth  = params->host_nperio_tx_fifo_size;
+		nptxfifosize.b.startaddr = params->host_rx_fifo_size;
+		dwc_write_reg32(&global_regs->gnptxfsiz, nptxfifosize.d32);
+		DWC_DEBUGPL(DBG_CIL,"new gnptxfsiz=%08x\n", dwc_read_reg32(&global_regs->gnptxfsiz));
+
+		/* Periodic Tx FIFO */
+		DWC_DEBUGPL(DBG_CIL,"initial hptxfsiz=%08x\n", dwc_read_reg32(&global_regs->hptxfsiz));
+		ptxfifosize.b.depth	 = params->host_perio_tx_fifo_size;
+		ptxfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
+		dwc_write_reg32(&global_regs->hptxfsiz, ptxfifosize.d32);
+		DWC_DEBUGPL(DBG_CIL,"new hptxfsiz=%08x\n", dwc_read_reg32(&global_regs->hptxfsiz));
+	}
+
+	/* Clear Host Set HNP Enable in the OTG Control Register */
+	gotgctl.b.hstsethnpen = 1;
+	dwc_modify_reg32( &global_regs->gotgctl, gotgctl.d32, 0);
+
+	/* Make sure the FIFOs are flushed. */
+	dwc_otg_flush_tx_fifo(_core_if, 0x10 /* all Tx FIFOs */);
+	dwc_otg_flush_rx_fifo(_core_if);
+
+	/* Flush out any leftover queued requests. */
+	num_channels = _core_if->core_params->host_channels;
+	for (i = 0; i < num_channels; i++)
+	{
+		hc_regs = _core_if->host_if->hc_regs[i];
+		hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+		hcchar.b.chen = 0;
+		hcchar.b.chdis = 1;
+		hcchar.b.epdir = 0;
+		dwc_write_reg32(&hc_regs->hcchar, hcchar.d32);
+	}
+
+	/* Halt all channels to put them into a known state. */
+	for (i = 0; i < num_channels; i++)
+	{
+		int count = 0;
+		hc_regs = _core_if->host_if->hc_regs[i];
+		hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+		hcchar.b.chen = 1;
+		hcchar.b.chdis = 1;
+		hcchar.b.epdir = 0;
+		dwc_write_reg32(&hc_regs->hcchar, hcchar.d32);
+		DWC_DEBUGPL(DBG_HCDV, "%s: Halt channel %d\n", __func__, i);
+		do
+		{
+			hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+			if (++count > 1000)
+			{
+				DWC_ERROR("%s: Unable to clear halt on channel %d\n",
+				          __func__, i);
+				break;
+			}
+		}
+		while (hcchar.b.chen);
+	}
+
+	/* Turn on the vbus power. */
+	DWC_PRINT("Init: Port Power? op_state=%d\n", _core_if->op_state);
+	if (_core_if->op_state == A_HOST)
+	{
+		hprt0.d32 = dwc_otg_read_hprt0(_core_if);
+		DWC_PRINT("Init: Power Port (%d)\n", hprt0.b.prtpwr);
+		if (hprt0.b.prtpwr == 0 )
+		{
+			_core_if->vbus_state = 1;
+			schedule_work(&_core_if->vbus_work);
+		}
+	}
+
+	dwc_otg_enable_host_interrupts( _core_if );
+}
+
+/**
+ * Prepares a host channel for transferring packets to/from a specific
+ * endpoint. The HCCHARn register is set up with the characteristics specified
+ * in _hc. Host channel interrupts that may need to be serviced while this
+ * transfer is in progress are enabled.
+ *
+ * @param _core_if Programming view of DWC_otg controller
+ * @param _hc Information needed to initialize the host channel
+ */
+void dwc_otg_hc_init(dwc_otg_core_if_t *_core_if, dwc_hc_t *_hc)
+{
+	uint32_t intr_enable;
+	hcintmsk_data_t hc_intr_mask;
+	gintmsk_data_t gintmsk = {.d32 = 0};
+	hcchar_data_t hcchar;
+	hcsplt_data_t hcsplt;
+
+	uint8_t hc_num = _hc->hc_num;
+	dwc_otg_host_if_t *host_if = _core_if->host_if;
+	dwc_otg_hc_regs_t *hc_regs = host_if->hc_regs[hc_num];
+
+	/* Clear old interrupt conditions for this host channel. */
+	hc_intr_mask.d32 = 0xFFFFFFFF;
+	hc_intr_mask.b.reserved = 0;
+	dwc_write_reg32(&hc_regs->hcint, hc_intr_mask.d32);
+
+	/* Enable channel interrupts required for this transfer. */
+	hc_intr_mask.d32 = 0;
+	hc_intr_mask.b.chhltd = 1;
+	if (_core_if->dma_enable)
+	{
+		hc_intr_mask.b.ahberr = 1;
+		if (_hc->error_state && !_hc->do_split &&
+		        _hc->ep_type != DWC_OTG_EP_TYPE_ISOC)
+		{
+			hc_intr_mask.b.ack = 1;
+			if (_hc->ep_is_in)
+			{
+				hc_intr_mask.b.datatglerr = 1;
+				if (_hc->ep_type != DWC_OTG_EP_TYPE_INTR)
+				{
+					hc_intr_mask.b.nak = 1;
+				}
+			}
+		}
+	}
+	else
+	{
+		switch (_hc->ep_type)
+		{
+		case DWC_OTG_EP_TYPE_CONTROL:
+		case DWC_OTG_EP_TYPE_BULK:
+			hc_intr_mask.b.xfercompl = 1;
+			hc_intr_mask.b.stall = 1;
+			hc_intr_mask.b.xacterr = 1;
+			hc_intr_mask.b.datatglerr = 1;
+			if (_hc->ep_is_in)
+			{
+				hc_intr_mask.b.bblerr = 1;
+			}
+			else
+			{
+				hc_intr_mask.b.nak = 1;
+				hc_intr_mask.b.nyet = 1;
+				if (_hc->do_ping)
+				{
+					hc_intr_mask.b.ack = 1;
+				}
+			}
+
+			if (_hc->do_split)
+			{
+				hc_intr_mask.b.nak = 1;
+				if (_hc->complete_split)
+				{
+					hc_intr_mask.b.nyet = 1;
+				}
+				else
+				{
+					hc_intr_mask.b.ack = 1;
+				}
+			}
+
+			if (_hc->error_state)
+			{
+				hc_intr_mask.b.ack = 1;
+			}
+			break;
+		case DWC_OTG_EP_TYPE_INTR:
+			hc_intr_mask.b.xfercompl = 1;
+			hc_intr_mask.b.nak = 1;
+			hc_intr_mask.b.stall = 1;
+			hc_intr_mask.b.xacterr = 1;
+			hc_intr_mask.b.datatglerr = 1;
+			hc_intr_mask.b.frmovrun = 1;
+
+			if (_hc->ep_is_in)
+			{
+				hc_intr_mask.b.bblerr = 1;
+			}
+			if (_hc->error_state)
+			{
+				hc_intr_mask.b.ack = 1;
+			}
+			if (_hc->do_split)
+			{
+				if (_hc->complete_split)
+				{
+					hc_intr_mask.b.nyet = 1;
+				}
+				else
+				{
+					hc_intr_mask.b.ack = 1;
+				}
+			}
+			break;
+		case DWC_OTG_EP_TYPE_ISOC:
+			hc_intr_mask.b.xfercompl = 1;
+			hc_intr_mask.b.frmovrun = 1;
+			hc_intr_mask.b.ack = 1;
+
+			if (_hc->ep_is_in)
+			{
+				hc_intr_mask.b.xacterr = 1;
+				hc_intr_mask.b.bblerr = 1;
+			}
+			break;
+		}
+	}
+	dwc_write_reg32(&hc_regs->hcintmsk, hc_intr_mask.d32);
+
+	/* Enable the top level host channel interrupt. */
+	intr_enable = (1 << hc_num);
+	dwc_modify_reg32(&host_if->host_global_regs->haintmsk, 0, intr_enable);
+
+	/* Make sure host channel interrupts are enabled. */
+	gintmsk.b.hcintr = 1;
+	dwc_modify_reg32(&_core_if->core_global_regs->gintmsk, 0, gintmsk.d32);
+
+	/*
+	 * Program the HCCHARn register with the endpoint characteristics for
+	 * the current transfer.
+	 */
+	hcchar.d32 = 0;
+	hcchar.b.devaddr = _hc->dev_addr;
+	hcchar.b.epnum = _hc->ep_num;
+	hcchar.b.epdir = _hc->ep_is_in;
+	hcchar.b.lspddev = (_hc->speed == DWC_OTG_EP_SPEED_LOW);
+	hcchar.b.eptype = _hc->ep_type;
+	hcchar.b.mps = _hc->max_packet;
+
+	dwc_write_reg32(&host_if->hc_regs[hc_num]->hcchar, hcchar.d32);
+
+	DWC_DEBUGPL(DBG_HCDV, "%s: Channel %d\n", __func__, _hc->hc_num);
+	DWC_DEBUGPL(DBG_HCDV, "	 Dev Addr: %d\n", hcchar.b.devaddr);
+	DWC_DEBUGPL(DBG_HCDV, "	 Ep Num: %d\n", hcchar.b.epnum);
+	DWC_DEBUGPL(DBG_HCDV, "	 Is In: %d\n", hcchar.b.epdir);
+	DWC_DEBUGPL(DBG_HCDV, "	 Is Low Speed: %d\n", hcchar.b.lspddev);
+	DWC_DEBUGPL(DBG_HCDV, "	 Ep Type: %d\n", hcchar.b.eptype);
+	DWC_DEBUGPL(DBG_HCDV, "	 Max Pkt: %d\n", hcchar.b.mps);
+	DWC_DEBUGPL(DBG_HCDV, "	 Multi Cnt: %d\n", hcchar.b.multicnt);
+
+	/*
+	 * Program the HCSPLIT register for SPLITs
+	 */
+	hcsplt.d32 = 0;
+	if (_hc->do_split)
+	{
+		DWC_DEBUGPL(DBG_HCDV, "Programming HC %d with split --> %s\n", _hc->hc_num,
+		            _hc->complete_split ? "CSPLIT" : "SSPLIT");
+		hcsplt.b.compsplt = _hc->complete_split;
+		hcsplt.b.xactpos = _hc->xact_pos;
+		hcsplt.b.hubaddr = _hc->hub_addr;
+		hcsplt.b.prtaddr = _hc->port_addr;
+		DWC_DEBUGPL(DBG_HCDV, "	  comp split %d\n", _hc->complete_split);
+		DWC_DEBUGPL(DBG_HCDV, "	  xact pos %d\n", _hc->xact_pos);
+		DWC_DEBUGPL(DBG_HCDV, "	  hub addr %d\n", _hc->hub_addr);
+		DWC_DEBUGPL(DBG_HCDV, "	  port addr %d\n", _hc->port_addr);
+		DWC_DEBUGPL(DBG_HCDV, "	  is_in %d\n", _hc->ep_is_in);
+		DWC_DEBUGPL(DBG_HCDV, "	  Max Pkt: %d\n", hcchar.b.mps);
+		DWC_DEBUGPL(DBG_HCDV, "	  xferlen: %d\n", _hc->xfer_len);
+	}
+	dwc_write_reg32(&host_if->hc_regs[hc_num]->hcsplt, hcsplt.d32);
+
+}
+
+/**
+ * Attempts to halt a host channel. This function should only be called in
+ * Slave mode or to abort a transfer in either Slave mode or DMA mode. Under
+ * normal circumstances in DMA mode, the controller halts the channel when the
+ * transfer is complete or a condition occurs that requires application
+ * intervention.
+ *
+ * In slave mode, checks for a free request queue entry, then sets the Channel
+ * Enable and Channel Disable bits of the Host Channel Characteristics
+ * register of the specified channel to intiate the halt. If there is no free
+ * request queue entry, sets only the Channel Disable bit of the HCCHARn
+ * register to flush requests for this channel. In the latter case, sets a
+ * flag to indicate that the host channel needs to be halted when a request
+ * queue slot is open.
+ *
+ * In DMA mode, always sets the Channel Enable and Channel Disable bits of the
+ * HCCHARn register. The controller ensures there is space in the request
+ * queue before submitting the halt request.
+ *
+ * Some time may elapse before the core flushes any posted requests for this
+ * host channel and halts. The Channel Halted interrupt handler completes the
+ * deactivation of the host channel.
+ *
+ * @param _core_if Controller register interface.
+ * @param _hc Host channel to halt.
+ * @param _halt_status Reason for halting the channel.
+ */
+void dwc_otg_hc_halt(dwc_otg_core_if_t *_core_if,
+                     dwc_hc_t *_hc,
+                     dwc_otg_halt_status_e _halt_status)
+{
+	gnptxsts_data_t			nptxsts;
+	hptxsts_data_t			hptxsts;
+	hcchar_data_t			hcchar;
+	dwc_otg_hc_regs_t		*hc_regs;
+	dwc_otg_core_global_regs_t	*global_regs;
+	dwc_otg_host_global_regs_t	*host_global_regs;
+
+	hc_regs = _core_if->host_if->hc_regs[_hc->hc_num];
+	global_regs = _core_if->core_global_regs;
+	host_global_regs = _core_if->host_if->host_global_regs;
+
+	WARN_ON(_halt_status == DWC_OTG_HC_XFER_NO_HALT_STATUS);
+
+	if (_halt_status == DWC_OTG_HC_XFER_URB_DEQUEUE ||
+	        _halt_status == DWC_OTG_HC_XFER_AHB_ERR)
+	{
+		/*
+		 * Disable all channel interrupts except Ch Halted. The QTD
+		 * and QH state associated with this transfer has been cleared
+		 * (in the case of URB_DEQUEUE), so the channel needs to be
+		 * shut down carefully to prevent crashes.
+		 */
+		hcintmsk_data_t hcintmsk;
+		hcintmsk.d32 = 0;
+		hcintmsk.b.chhltd = 1;
+		dwc_write_reg32(&hc_regs->hcintmsk, hcintmsk.d32);
+
+		/*
+		 * Make sure no other interrupts besides halt are currently
+		 * pending. Handling another interrupt could cause a crash due
+		 * to the QTD and QH state.
+		 */
+		dwc_write_reg32(&hc_regs->hcint, ~hcintmsk.d32);
+
+		/*
+		 * Make sure the halt status is set to URB_DEQUEUE or AHB_ERR
+		 * even if the channel was already halted for some other
+		 * reason.
+		 */
+		_hc->halt_status = _halt_status;
+
+		hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+		if (hcchar.b.chen == 0)
+		{
+			/*
+			 * The channel is either already halted or it hasn't
+			 * started yet. In DMA mode, the transfer may halt if
+			 * it finishes normally or a condition occurs that
+			 * requires driver intervention. Don't want to halt
+			 * the channel again. In either Slave or DMA mode,
+			 * it's possible that the transfer has been assigned
+			 * to a channel, but not started yet when an URB is
+			 * dequeued. Don't want to halt a channel that hasn't
+			 * started yet.
+			 */
+			return;
+		}
+	}
+
+	if (_hc->halt_pending)
+	{
+		/*
+		 * A halt has already been issued for this channel. This might
+		 * happen when a transfer is aborted by a higher level in
+		 * the stack.
+		 */
+#ifdef DEBUG
+		DWC_PRINT("*** %s: Channel %d, _hc->halt_pending already set ***\n",
+		          __func__, _hc->hc_num);
+
+		/*		dwc_otg_dump_global_registers(_core_if); */
+		/*		dwc_otg_dump_host_registers(_core_if); */
+#endif
+		return;
+	}
+
+	hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+	hcchar.b.chen = 1;
+	hcchar.b.chdis = 1;
+
+	if (!_core_if->dma_enable)
+	{
+		/* Check for space in the request queue to issue the halt. */
+		if (_hc->ep_type == DWC_OTG_EP_TYPE_CONTROL ||
+		        _hc->ep_type == DWC_OTG_EP_TYPE_BULK)
+		{
+			nptxsts.d32 = dwc_read_reg32(&global_regs->gnptxsts);
+			if (nptxsts.b.nptxqspcavail == 0)
+			{
+				hcchar.b.chen = 0;
+			}
+		}
+		else
+		{
+			hptxsts.d32 = dwc_read_reg32(&host_global_regs->hptxsts);
+			if ((hptxsts.b.ptxqspcavail == 0) || (_core_if->queuing_high_bandwidth))
+			{
+				hcchar.b.chen = 0;
+			}
+		}
+	}
+
+	dwc_write_reg32(&hc_regs->hcchar, hcchar.d32);
+
+	_hc->halt_status = _halt_status;
+
+	if (hcchar.b.chen)
+	{
+		_hc->halt_pending = 1;
+		_hc->halt_on_queue = 0;
+	}
+	else
+	{
+		_hc->halt_on_queue = 1;
+	}
+
+	DWC_DEBUGPL(DBG_HCDV, "%s: Channel %d\n", __func__, _hc->hc_num);
+	DWC_DEBUGPL(DBG_HCDV, "	 hcchar: 0x%08x\n", hcchar.d32);
+	DWC_DEBUGPL(DBG_HCDV, "	 halt_pending: %d\n", _hc->halt_pending);
+	DWC_DEBUGPL(DBG_HCDV, "	 halt_on_queue: %d\n", _hc->halt_on_queue);
+	DWC_DEBUGPL(DBG_HCDV, "	 halt_status: %d\n", _hc->halt_status);
+
+	return;
+}
+
+/**
+ * Clears the transfer state for a host channel. This function is normally
+ * called after a transfer is done and the host channel is being released.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ * @param _hc Identifies the host channel to clean up.
+ */
+void dwc_otg_hc_cleanup(dwc_otg_core_if_t *_core_if, dwc_hc_t *_hc)
+{
+	dwc_otg_hc_regs_t *hc_regs;
+
+	_hc->xfer_started = 0;
+
+	/*
+	 * Clear channel interrupt enables and any unhandled channel interrupt
+	 * conditions.
+	 */
+	hc_regs = _core_if->host_if->hc_regs[_hc->hc_num];
+	dwc_write_reg32(&hc_regs->hcintmsk, 0);
+	dwc_write_reg32(&hc_regs->hcint, 0xFFFFFFFF);
+
+#ifdef DEBUG
+	del_timer(&_core_if->hc_xfer_timer[_hc->hc_num]);
+	{
+		hcchar_data_t hcchar;
+		hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+		if (hcchar.b.chdis)
+		{
+			DWC_WARN("%s: chdis set, channel %d, hcchar 0x%08x\n",
+			         __func__, _hc->hc_num, hcchar.d32);
+		}
+	}
+#endif
+}
+
+/**
+ * Sets the channel property that indicates in which frame a periodic transfer
+ * should occur. This is always set to the _next_ frame. This function has no
+ * effect on non-periodic transfers.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ * @param _hc Identifies the host channel to set up and its properties.
+ * @param _hcchar Current value of the HCCHAR register for the specified host
+ * channel.
+ */
+static inline void hc_set_even_odd_frame(dwc_otg_core_if_t *_core_if,
+        dwc_hc_t *_hc,
+        hcchar_data_t *_hcchar)
+{
+	if (_hc->ep_type == DWC_OTG_EP_TYPE_INTR ||
+	        _hc->ep_type == DWC_OTG_EP_TYPE_ISOC)
+	{
+		hfnum_data_t	hfnum;
+		hfnum.d32 = dwc_read_reg32(&_core_if->host_if->host_global_regs->hfnum);
+
+		/* 1 if _next_ frame is odd, 0 if it's even */
+		_hcchar->b.oddfrm = (hfnum.b.frnum & 0x1) ? 0 : 1;
+#ifdef DEBUG
+		if (_hc->ep_type == DWC_OTG_EP_TYPE_INTR && _hc->do_split && !_hc->complete_split)
+		{
+			switch (hfnum.b.frnum & 0x7)
+			{
+			case 7:
+				_core_if->hfnum_7_samples++;
+				_core_if->hfnum_7_frrem_accum += hfnum.b.frrem;
+				break;
+			case 0:
+				_core_if->hfnum_0_samples++;
+				_core_if->hfnum_0_frrem_accum += hfnum.b.frrem;
+				break;
+			default:
+				_core_if->hfnum_other_samples++;
+				_core_if->hfnum_other_frrem_accum += hfnum.b.frrem;
+				break;
+			}
+		}
+#endif
+	}
+}
+
+#ifdef DEBUG
+static void hc_xfer_timeout(unsigned long _ptr)
+{
+	hc_xfer_info_t *xfer_info = (hc_xfer_info_t *)_ptr;
+	int hc_num = xfer_info->hc->hc_num;
+	DWC_WARN("%s: timeout on channel %d\n", __func__, hc_num);
+	DWC_WARN("	start_hcchar_val 0x%08x\n", xfer_info->core_if->start_hcchar_val[hc_num]);
+}
+#endif
+
+/*
+ * This function does the setup for a data transfer for a host channel and
+ * starts the transfer. May be called in either Slave mode or DMA mode. In
+ * Slave mode, the caller must ensure that there is sufficient space in the
+ * request queue and Tx Data FIFO.
+ *
+ * For an OUT transfer in Slave mode, it loads a data packet into the
+ * appropriate FIFO. If necessary, additional data packets will be loaded in
+ * the Host ISR.
+ *
+ * For an IN transfer in Slave mode, a data packet is requested. The data
+ * packets are unloaded from the Rx FIFO in the Host ISR. If necessary,
+ * additional data packets are requested in the Host ISR.
+ *
+ * For a PING transfer in Slave mode, the Do Ping bit is set in the HCTSIZ
+ * register along with a packet count of 1 and the channel is enabled. This
+ * causes a single PING transaction to occur. Other fields in HCTSIZ are
+ * simply set to 0 since no data transfer occurs in this case.
+ *
+ * For a PING transfer in DMA mode, the HCTSIZ register is initialized with
+ * all the information required to perform the subsequent data transfer. In
+ * addition, the Do Ping bit is set in the HCTSIZ register. In this case, the
+ * controller performs the entire PING protocol, then starts the data
+ * transfer.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ * @param _hc Information needed to initialize the host channel. The xfer_len
+ * value may be reduced to accommodate the max widths of the XferSize and
+ * PktCnt fields in the HCTSIZn register. The multi_count value may be changed
+ * to reflect the final xfer_len value.
+ */
+void dwc_otg_hc_start_transfer(dwc_otg_core_if_t *_core_if, dwc_hc_t *_hc)
+{
+	hcchar_data_t hcchar;
+	hctsiz_data_t hctsiz;
+	uint16_t num_packets;
+	uint32_t max_hc_xfer_size = _core_if->core_params->max_transfer_size;
+	uint16_t max_hc_pkt_count = _core_if->core_params->max_packet_count;
+	dwc_otg_hc_regs_t *hc_regs = _core_if->host_if->hc_regs[_hc->hc_num];
+
+	hctsiz.d32 = 0;
+
+	if (_hc->do_ping)
+	{
+		if (!_core_if->dma_enable)
+		{
+			dwc_otg_hc_do_ping(_core_if, _hc);
+			_hc->xfer_started = 1;
+			return;
+		}
+		else
+		{
+			hctsiz.b.dopng = 1;
+		}
+	}
+
+	if (_hc->do_split)
+	{
+		num_packets = 1;
+
+		if (_hc->complete_split && !_hc->ep_is_in)
+		{
+			/* For CSPLIT OUT Transfer, set the size to 0 so the
+			 * core doesn't expect any data written to the FIFO */
+			_hc->xfer_len = 0;
+		}
+		else if (_hc->ep_is_in || (_hc->xfer_len > _hc->max_packet))
+		{
+			_hc->xfer_len = _hc->max_packet;
+		}
+		else if (!_hc->ep_is_in && (_hc->xfer_len > 188))
+		{
+			_hc->xfer_len = 188;
+		}
+
+		hctsiz.b.xfersize = _hc->xfer_len;
+	}
+	else
+	{
+		/*
+		 * Ensure that the transfer length and packet count will fit
+		 * in the widths allocated for them in the HCTSIZn register.
+		 */
+		if (_hc->ep_type == DWC_OTG_EP_TYPE_INTR ||
+		        _hc->ep_type == DWC_OTG_EP_TYPE_ISOC)
+		{
+			/*
+			 * Make sure the transfer size is no larger than one
+			 * (micro)frame's worth of data. (A check was done
+			 * when the periodic transfer was accepted to ensure
+			 * that a (micro)frame's worth of data can be
+			 * programmed into a channel.)
+			 */
+			uint32_t max_periodic_len = _hc->multi_count * _hc->max_packet;
+			if (_hc->xfer_len > max_periodic_len)
+			{
+				_hc->xfer_len = max_periodic_len;
+			}
+			else
+			{
+			}
+		}
+		else if (_hc->xfer_len > max_hc_xfer_size)
+		{
+			/* Make sure that xfer_len is a multiple of max packet size. */
+			_hc->xfer_len = max_hc_xfer_size - _hc->max_packet + 1;
+		}
+
+		if (_hc->xfer_len > 0)
+		{
+//			if ((_hc->ep_type == DWC_OTG_EP_TYPE_CONTROL) && _hc->xfer_len == _hc->max_packet)
+
+			num_packets = (_hc->xfer_len + _hc->max_packet - 1) / _hc->max_packet;
+
+			if (num_packets > max_hc_pkt_count)
+			{
+				num_packets = max_hc_pkt_count;
+				_hc->xfer_len = num_packets * _hc->max_packet;
+			}
+		}
+		else
+		{
+			/* Need 1 packet for transfer length of 0. */
+			num_packets = 1;
+		}
+
+		if (_hc->ep_is_in)
+		{
+			/* Always program an integral # of max packets for IN transfers. */
+			_hc->xfer_len = num_packets * _hc->max_packet;
+		}
+
+		if (_hc->ep_type == DWC_OTG_EP_TYPE_INTR ||
+		        _hc->ep_type == DWC_OTG_EP_TYPE_ISOC)
+		{
+			/*
+			 * Make sure that the multi_count field matches the
+			 * actual transfer length.
+			 */
+			_hc->multi_count = num_packets;
+		}
+
+		if (_hc->ep_type == DWC_OTG_EP_TYPE_ISOC)
+		{
+			/* Set up the initial PID for the transfer. */
+			if (_hc->speed == DWC_OTG_EP_SPEED_HIGH)
+			{
+				if (_hc->ep_is_in)
+				{
+					if (_hc->multi_count == 1)
+					{
+						_hc->data_pid_start = DWC_OTG_HC_PID_DATA0;
+					}
+					else if (_hc->multi_count == 2)
+					{
+						_hc->data_pid_start = DWC_OTG_HC_PID_DATA1;
+					}
+					else
+					{
+						_hc->data_pid_start = DWC_OTG_HC_PID_DATA2;
+					}
+				}
+				else
+				{
+					if (_hc->multi_count == 1)
+					{
+						_hc->data_pid_start = DWC_OTG_HC_PID_DATA0;
+					}
+					else
+					{
+						_hc->data_pid_start = DWC_OTG_HC_PID_MDATA;
+					}
+				}
+			}
+			else
+			{
+				_hc->data_pid_start = DWC_OTG_HC_PID_DATA0;
+			}
+		}
+
+		hctsiz.b.xfersize = _hc->xfer_len;
+	}
+
+	_hc->start_pkt_count = num_packets;
+	hctsiz.b.pktcnt = num_packets;
+	hctsiz.b.pid = _hc->data_pid_start;
+	dwc_write_reg32(&hc_regs->hctsiz, hctsiz.d32);
+
+	DWC_DEBUGPL(DBG_HCDV, "%s: Channel %d\n", __func__, _hc->hc_num);
+	DWC_DEBUGPL(DBG_HCDV, "	 Xfer Size: %d\n", hctsiz.b.xfersize);
+	DWC_DEBUGPL(DBG_HCDV, "	 Num Pkts: %d\n", hctsiz.b.pktcnt);
+	DWC_DEBUGPL(DBG_HCDV, "	 Start PID: %d\n", hctsiz.b.pid);
+
+	if (_core_if->dma_enable)
+	{
+		dwc_write_reg32(&hc_regs->hcdma, (uint32_t)_hc->xfer_buff);
+	}
+
+	/* Start the split */
+	if (_hc->do_split)
+	{
+		hcsplt_data_t hcsplt;
+		hcsplt.d32 = dwc_read_reg32 (&hc_regs->hcsplt);
+		hcsplt.b.spltena = 1;
+		dwc_write_reg32(&hc_regs->hcsplt, hcsplt.d32);
+	}
+
+	hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+	hcchar.b.multicnt = _hc->multi_count;
+	hc_set_even_odd_frame(_core_if, _hc, &hcchar);
+#ifdef DEBUG
+	_core_if->start_hcchar_val[_hc->hc_num] = hcchar.d32;
+	if (hcchar.b.chdis)
+	{
+		DWC_WARN("%s: chdis set, channel %d, hcchar 0x%08x\n",
+		         __func__, _hc->hc_num, hcchar.d32);
+	}
+#endif
+
+	/* Set host channel enable after all other setup is complete. */
+	hcchar.b.chen = 1;
+	hcchar.b.chdis = 0;
+	dwc_write_reg32(&hc_regs->hcchar, hcchar.d32);
+
+	_hc->xfer_started = 1;
+	_hc->requests++;
+
+	if (!_core_if->dma_enable &&
+	        !_hc->ep_is_in && _hc->xfer_len > 0)
+	{
+		/* Load OUT packet into the appropriate Tx FIFO. */
+		dwc_otg_hc_write_packet(_core_if, _hc);
+	}
+
+#ifdef DEBUG
+	/* Start a timer for this transfer. */
+	_core_if->hc_xfer_timer[_hc->hc_num].function = hc_xfer_timeout;
+	_core_if->hc_xfer_info[_hc->hc_num].core_if = _core_if;
+	_core_if->hc_xfer_info[_hc->hc_num].hc = _hc;
+	_core_if->hc_xfer_timer[_hc->hc_num].data = (unsigned long)(&_core_if->hc_xfer_info[_hc->hc_num]);
+	_core_if->hc_xfer_timer[_hc->hc_num].expires = jiffies + (HZ*10);
+	add_timer(&_core_if->hc_xfer_timer[_hc->hc_num]);
+#endif
+}
+
+/**
+ * This function continues a data transfer that was started by previous call
+ * to <code>dwc_otg_hc_start_transfer</code>. The caller must ensure there is
+ * sufficient space in the request queue and Tx Data FIFO. This function
+ * should only be called in Slave mode. In DMA mode, the controller acts
+ * autonomously to complete transfers programmed to a host channel.
+ *
+ * For an OUT transfer, a new data packet is loaded into the appropriate FIFO
+ * if there is any data remaining to be queued. For an IN transfer, another
+ * data packet is always requested. For the SETUP phase of a control transfer,
+ * this function does nothing.
+ *
+ * @return 1 if a new request is queued, 0 if no more requests are required
+ * for this transfer.
+ */
+int dwc_otg_hc_continue_transfer(dwc_otg_core_if_t *_core_if, dwc_hc_t *_hc)
+{
+	DWC_DEBUGPL(DBG_HCDV, "%s: Channel %d\n", __func__, _hc->hc_num);
+
+	if (_hc->do_split) {
+		/* SPLITs always queue just once per channel */
+		return 0;
+	}
+	else if (_hc->data_pid_start == DWC_OTG_HC_PID_SETUP)
+	{
+		/* SETUPs are queued only once since they can't be NAKed. */
+		return 0;
+	}
+	else if (_hc->ep_is_in)
+	{
+		/*
+		 * Always queue another request for other IN transfers. If
+		 * back-to-back INs are issued and NAKs are received for both,
+		 * the driver may still be processing the first NAK when the
+		 * second NAK is received. When the interrupt handler clears
+		 * the NAK interrupt for the first NAK, the second NAK will
+		 * not be seen. So we can't depend on the NAK interrupt
+		 * handler to requeue a NAKed request. Instead, IN requests
+		 * are issued each time this function is called. When the
+		 * transfer completes, the extra requests for the channel will
+		 * be flushed.
+		 */
+		hcchar_data_t hcchar;
+		dwc_otg_hc_regs_t *hc_regs = _core_if->host_if->hc_regs[_hc->hc_num];
+
+		hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+		hc_set_even_odd_frame(_core_if, _hc, &hcchar);
+		hcchar.b.chen = 1;
+		hcchar.b.chdis = 0;
+		DWC_DEBUGPL(DBG_HCDV, "	 IN xfer: hcchar = 0x%08x\n", hcchar.d32);
+		dwc_write_reg32(&hc_regs->hcchar, hcchar.d32);
+		_hc->requests++;
+		return 1;
+	}
+	else
+	{
+		/* OUT transfers. */
+		if (_hc->xfer_count < _hc->xfer_len)
+		{
+			if (_hc->ep_type == DWC_OTG_EP_TYPE_INTR ||
+			        _hc->ep_type == DWC_OTG_EP_TYPE_ISOC)
+			{
+				hcchar_data_t hcchar;
+				dwc_otg_hc_regs_t *hc_regs;
+				hc_regs = _core_if->host_if->hc_regs[_hc->hc_num];
+				hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+				hc_set_even_odd_frame(_core_if, _hc, &hcchar);
+			}
+
+			/* Load OUT packet into the appropriate Tx FIFO. */
+			dwc_otg_hc_write_packet(_core_if, _hc);
+			_hc->requests++;
+			return 1;
+		}
+		else
+		{
+			return 0;
+		}
+	}
+}
+
+/**
+ * Starts a PING transfer. This function should only be called in Slave mode.
+ * The Do Ping bit is set in the HCTSIZ register, then the channel is enabled.
+ */
+void dwc_otg_hc_do_ping(dwc_otg_core_if_t *_core_if, dwc_hc_t *_hc)
+{
+	hcchar_data_t hcchar;
+	hctsiz_data_t hctsiz;
+	dwc_otg_hc_regs_t *hc_regs = _core_if->host_if->hc_regs[_hc->hc_num];
+
+	DWC_DEBUGPL(DBG_HCDV, "%s: Channel %d\n", __func__, _hc->hc_num);
+
+	hctsiz.d32 = 0;
+	hctsiz.b.dopng = 1;
+	hctsiz.b.pktcnt = 1;
+	dwc_write_reg32(&hc_regs->hctsiz, hctsiz.d32);
+
+	hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+	hcchar.b.chen = 1;
+	hcchar.b.chdis = 0;
+	dwc_write_reg32(&hc_regs->hcchar, hcchar.d32);
+}
+
+/*
+ * This function writes a packet into the Tx FIFO associated with the Host
+ * Channel. For a channel associated with a non-periodic EP, the non-periodic
+ * Tx FIFO is written. For a channel associated with a periodic EP, the
+ * periodic Tx FIFO is written. This function should only be called in Slave
+ * mode.
+ *
+ * Upon return the xfer_buff and xfer_count fields in _hc are incremented by
+ * then number of bytes written to the Tx FIFO.
+ */
+void dwc_otg_hc_write_packet(dwc_otg_core_if_t *_core_if, dwc_hc_t *_hc)
+{
+	uint32_t i;
+	uint32_t remaining_count;
+	uint32_t byte_count;
+	uint32_t dword_count;
+
+	uint32_t *data_buff = (uint32_t *)(_hc->xfer_buff);
+	uint32_t *data_fifo = _core_if->data_fifo[_hc->hc_num];
+
+	remaining_count = _hc->xfer_len - _hc->xfer_count;
+	if (remaining_count > _hc->max_packet)
+	{
+		byte_count = _hc->max_packet;
+	}
+	else
+	{
+		byte_count = remaining_count;
+	}
+
+	dword_count = (byte_count + 3) / 4;
+
+	if ((((unsigned long)data_buff) & 0x3) == 0)
+	{
+		/* xfer_buff is DWORD aligned. */
+		for (i = 0; i < dword_count; i++, data_buff++)
+		{
+			dwc_write_reg32(data_fifo, *data_buff);
+		}
+	}
+	else
+	{
+		/* xfer_buff is not DWORD aligned. */
+		for (i = 0; i < dword_count; i++, data_buff++)
+		{
+			dwc_write_reg32(data_fifo, get_unaligned(data_buff));
+		}
+	}
+
+	_hc->xfer_count += byte_count;
+	_hc->xfer_buff += byte_count;
+}
+
+/**
+ * Gets the current USB frame number. This is the frame number from the last
+ * SOF packet.
+ */
+uint32_t dwc_otg_get_frame_number(dwc_otg_core_if_t *_core_if)
+{
+	dsts_data_t dsts;
+	dsts.d32 = dwc_read_reg32(&_core_if->dev_if->dev_global_regs->dsts);
+
+	/* read current frame/microfreme number from DSTS register */
+	return dsts.b.soffn;
+}
+
+/**
+ * This function reads a setup packet from the Rx FIFO into the destination
+ * buffer.	This function is called from the Rx Status Queue Level (RxStsQLvl)
+ * Interrupt routine when a SETUP packet has been received in Slave mode.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ * @param _dest Destination buffer for packet data.
+ */
+void dwc_otg_read_setup_packet(dwc_otg_core_if_t *_core_if, uint32_t *_dest)
+{
+	/* Get the 8 bytes of a setup transaction data */
+
+	/* Pop 2 DWORDS off the receive data FIFO into memory */
+	_dest[0] = dwc_read_reg32(_core_if->data_fifo[0]);
+	_dest[1] = dwc_read_reg32(_core_if->data_fifo[0]);
+}
+
+
+/**
+ * This function enables EP0 OUT to receive SETUP packets and configures EP0
+ * IN for transmitting packets.	 It is normally called when the
+ * "Enumeration Done" interrupt occurs.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ * @param _ep The EP0 data.
+ */
+void dwc_otg_ep0_activate(dwc_otg_core_if_t *_core_if, dwc_ep_t *_ep)
+{
+	dwc_otg_dev_if_t *dev_if = _core_if->dev_if;
+	dsts_data_t dsts;
+	depctl_data_t diepctl;
+	depctl_data_t doepctl;
+	dctl_data_t dctl ={.d32=0};
+
+	/* Read the Device Status and Endpoint 0 Control registers */
+	dsts.d32 = dwc_read_reg32(&dev_if->dev_global_regs->dsts);
+	diepctl.d32 = dwc_read_reg32(&dev_if->in_ep_regs[0]->diepctl);
+	doepctl.d32 = dwc_read_reg32(&dev_if->out_ep_regs[0]->doepctl);
+
+	/* Set the MPS of the IN EP based on the enumeration speed */
+	switch (dsts.b.enumspd)
+	{
+	case DWC_DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ:
+	case DWC_DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ:
+	case DWC_DSTS_ENUMSPD_FS_PHY_48MHZ:
+		diepctl.b.mps = DWC_DEP0CTL_MPS_64;
+		break;
+	case DWC_DSTS_ENUMSPD_LS_PHY_6MHZ:
+		diepctl.b.mps = DWC_DEP0CTL_MPS_8;
+		break;
+	}
+
+	dwc_write_reg32(&dev_if->in_ep_regs[0]->diepctl, diepctl.d32);
+
+	/* Enable OUT EP for receive */
+	doepctl.b.epena = 1;
+	dwc_write_reg32(&dev_if->out_ep_regs[0]->doepctl, doepctl.d32);
+
+#ifdef VERBOSE
+	DWC_DEBUGPL(DBG_PCDV,"doepctl0=%0x\n",
+	            dwc_read_reg32(&dev_if->out_ep_regs[0]->doepctl));
+	DWC_DEBUGPL(DBG_PCDV,"diepctl0=%0x\n",
+	            dwc_read_reg32(&dev_if->in_ep_regs[0]->diepctl));
+#endif
+	dctl.b.cgnpinnak = 1;
+	dwc_modify_reg32(&dev_if->dev_global_regs->dctl, dctl.d32, dctl.d32);
+	DWC_DEBUGPL(DBG_PCDV,"dctl=%0x\n",
+	            dwc_read_reg32(&dev_if->dev_global_regs->dctl));
+}
+
+/**
+ * This function activates an EP.  The Device EP control register for
+ * the EP is configured as defined in the ep structure.	 Note: This
+ * function is not used for EP0.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ * @param _ep The EP to activate.
+ */
+void dwc_otg_ep_activate(dwc_otg_core_if_t *_core_if, dwc_ep_t *_ep)
+{
+	dwc_otg_dev_if_t *dev_if = _core_if->dev_if;
+	depctl_data_t depctl;
+	volatile uint32_t *addr;
+	daint_data_t daintmsk = {.d32=0};
+
+	DWC_DEBUGPL(DBG_PCDV, "%s() EP%d-%s\n", __func__, _ep->num,
+	            (_ep->is_in?"IN":"OUT"));
+
+	/* Read DEPCTLn register */
+	if (_ep->is_in == 1)
+	{
+		addr = &dev_if->in_ep_regs[_ep->num]->diepctl;
+		daintmsk.ep.in = 1<<_ep->num;
+	}
+	else
+	{
+		addr = &dev_if->out_ep_regs[_ep->num]->doepctl;
+		daintmsk.ep.out = 1<<_ep->num;
+	}
+
+	/* If the EP is already active don't change the EP Control
+	 * register. */
+	depctl.d32 = dwc_read_reg32(addr);
+	if (!depctl.b.usbactep)
+	{
+		depctl.b.mps = _ep->maxpacket;
+		depctl.b.eptype = _ep->type;
+		depctl.b.txfnum = _ep->tx_fifo_num;
+
+		if (_ep->type == DWC_OTG_EP_TYPE_ISOC)
+		{
+			depctl.b.setd0pid = 1; // ???
+		}
+		else
+		{
+			depctl.b.setd0pid = 1;
+		}
+		depctl.b.usbactep = 1;
+
+		dwc_write_reg32(addr, depctl.d32);
+		DWC_DEBUGPL(DBG_PCDV,"DEPCTL=%08x\n", dwc_read_reg32(addr));
+	}
+
+
+	/* Enable the Interrupt for this EP */
+	dwc_modify_reg32(&dev_if->dev_global_regs->daintmsk,
+	                 0, daintmsk.d32);
+
+	DWC_DEBUGPL(DBG_PCDV,"DAINTMSK=%0x\n",
+	            dwc_read_reg32(&dev_if->dev_global_regs->daintmsk));
+
+	_ep->stall_clear_flag = 0;
+	return;
+}
+
+/**
+ * This function deactivates an EP.	 This is done by clearing the USB Active
+ * EP bit in the Device EP control register.  Note: This function is not used
+ * for EP0. EP0 cannot be deactivated.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ * @param _ep The EP to deactivate.
+ */
+void dwc_otg_ep_deactivate(dwc_otg_core_if_t *_core_if, dwc_ep_t *_ep)
+{
+	depctl_data_t depctl ={.d32 = 0};
+	volatile uint32_t *addr;
+	daint_data_t daintmsk = {.d32=0};
+
+	/* Read DEPCTLn register */
+	if (_ep->is_in == 1)
+	{
+		addr = &_core_if->dev_if->in_ep_regs[_ep->num]->diepctl;
+		daintmsk.ep.in = 1<<_ep->num;
+	}
+	else
+	{
+		addr = &_core_if->dev_if->out_ep_regs[_ep->num]->doepctl;
+		daintmsk.ep.out = 1<<_ep->num;
+	}
+
+	depctl.b.usbactep = 0;
+	dwc_write_reg32(addr, depctl.d32);
+
+	/* Disable the Interrupt for this EP */
+	dwc_modify_reg32(&_core_if->dev_if->dev_global_regs->daintmsk,
+	                 daintmsk.d32, 0);
+
+	return;
+}
+
+/**
+ * This function does the setup for a data transfer for an EP and
+ * starts the transfer.	 For an IN transfer, the packets will be
+ * loaded into the appropriate Tx FIFO in the ISR. For OUT transfers,
+ * the packets are unloaded from the Rx FIFO in the ISR.  the ISR.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ * @param _ep The EP to start the transfer on.
+ */
+
+void dwc_otg_ep_start_transfer(dwc_otg_core_if_t *_core_if, dwc_ep_t *_ep)
+{
+	/** @todo Refactor this funciton to check the transfer size
+	 * count value does not execed the number bits in the Transfer
+	 * count register. */
+	depctl_data_t depctl;
+	deptsiz_data_t deptsiz;
+
+#ifdef CHECK_PACKET_COUNTER_WIDTH
+	const uint32_t MAX_XFER_SIZE =
+	    _core_if->core_params->max_transfer_size;
+	const uint32_t MAX_PKT_COUNT =
+	    _core_if->core_params->max_packet_count;
+	uint32_t num_packets;
+	uint32_t transfer_len;
+	dwc_otg_dev_out_ep_regs_t *out_regs =
+	    _core_if->dev_if->out_ep_regs[_ep->num];
+	dwc_otg_dev_in_ep_regs_t *in_regs =
+	    _core_if->dev_if->in_ep_regs[_ep->num];
+	gnptxsts_data_t txstatus;
+
+	int lvl = SET_DEBUG_LEVEL(DBG_PCD);
+
+	DWC_DEBUGPL(DBG_PCD, "ep%d-%s xfer_len=%d xfer_cnt=%d "
+	            "xfer_buff=%p start_xfer_buff=%p\n",
+	            _ep->num, (_ep->is_in?"IN":"OUT"), _ep->xfer_len,
+	            _ep->xfer_count, _ep->xfer_buff, _ep->start_xfer_buff);
+
+	transfer_len = _ep->xfer_len - _ep->xfer_count;
+	if (transfer_len > MAX_XFER_SIZE)
+	{
+		transfer_len = MAX_XFER_SIZE;
+	}
+	if (transfer_len == 0)
+	{
+		num_packets = 1;
+		/* OUT EP to recieve Zero-length packet set transfer
+		 * size to maxpacket size. */
+		if (!_ep->is_in)
+		{
+			transfer_len = _ep->maxpacket;
+		}
+	}
+	else
+	{
+		num_packets =
+		    (transfer_len + _ep->maxpacket - 1) / _ep->maxpacket;
+		if (num_packets > MAX_PKT_COUNT)
+		{
+			num_packets = MAX_PKT_COUNT;
+		}
+	}
+	DWC_DEBUGPL(DBG_PCD, "transfer_len=%d #pckt=%d\n", transfer_len,
+	            num_packets);
+
+	deptsiz.b.xfersize = transfer_len;
+	deptsiz.b.pktcnt = num_packets;
+
+	/* IN endpoint */
+	if (_ep->is_in == 1)
+	{
+		depctl.d32 = dwc_read_reg32(&in_regs->diepctl);
+	}
+	/* OUT endpoint */
+	else
+	{
+		depctl.d32 = dwc_read_reg32(&out_regs->doepctl);
+	}
+
+	/* EP enable, IN data in FIFO */
+	depctl.b.cnak = 1;
+	depctl.b.epena = 1;
+	/* IN endpoint */
+	if (_ep->is_in == 1)
+	{
+		//txstatus.d32 = dwc_read_reg32(&_core_if->core_global_regs->gnptxsts);
+
+		//if (txstatus.b.nptxqspcavail == 0)
+		//{
+		//	DWC_DEBUGPL(DBG_ANY, "TX Queue Full (0x%0x)\n",
+		//		txstatus.d32);
+		//	return;
+		//}
+
+		dwc_write_reg32(&in_regs->dieptsiz, deptsiz.d32);
+		dwc_write_reg32(&in_regs->diepctl, depctl.d32);
+
+		/**
+		 * Enable the Non-Periodic Tx FIFO empty interrupt, the
+		 * data will be written into the fifo by the ISR.
+		 */
+		if (_core_if->dma_enable)
+		{
+			dwc_write_reg32 (&in_regs->diepdma, (uint32_t)_ep->xfer_buff);
+		}
+		else
+		{
+			//if(_core_if->en_multiple_tx_fifo == 0)
+			//{
+			//	gintmsk_data_t intr_mask = { .d32 = 0};
+			//	intr_mask.b.nptxfempty = 1;
+			//
+			//	dwc_modify_reg32( &_core_if->core_global_regs->gintsts,
+			//					  intr_mask.d32, 0);
+			//
+			//	dwc_modify_reg32( &_core_if->core_global_regs->gintmsk,
+			//					  intr_mask.d32, intr_mask.d32);
+			//}
+			//else
+			{
+				/* Enable the Tx FIFO Empty Interrupt for this EP */
+				if (_ep->xfer_len > 0 && _ep->type != DWC_OTG_EP_TYPE_ISOC)
+				{
+					uint32_t fifoemptymsk = 0;
+					fifoemptymsk = (0x1 << _ep->num);
+					dwc_modify_reg32(&_core_if->dev_if->dev_global_regs->dtknqr4_fifoemptymsk,
+					                 0, fifoemptymsk);
+				}
+			}
+		}
+	}
+	else
+	{
+		/* OUT endpoint */
+		dwc_write_reg32(&out_regs->doeptsiz, deptsiz.d32);
+		dwc_write_reg32(&out_regs->doepctl, depctl.d32);
+		if (_core_if->dma_enable)
+		{
+			dwc_write_reg32 (&out_regs->doepdma,
+			                 (uint32_t)_ep->xfer_buff);
+		}
+	}
+	DWC_DEBUGPL(DBG_PCD, "DOEPCTL=%08x DOEPTSIZ=%08x\n",
+	            dwc_read_reg32(&out_regs->doepctl),
+	            dwc_read_reg32(&out_regs->doeptsiz));
+	DWC_DEBUGPL(DBG_PCD, "DAINTMSK=%08x GINTMSK=%08x\n",
+	            dwc_read_reg32(&_core_if->dev_if->dev_global_regs->daintmsk),
+	            dwc_read_reg32(&_core_if->core_global_regs->gintmsk));
+
+	SET_DEBUG_LEVEL(lvl);
+#endif
+
+	DWC_DEBUGPL((DBG_PCDV | DBG_CILV), "%s()\n", __func__);
+
+	DWC_DEBUGPL(DBG_PCD, "ep%d-%s xfer_len=%d xfer_cnt=%d "
+	            "xfer_buff=%p start_xfer_buff=%p\n",
+	            _ep->num, (_ep->is_in?"IN":"OUT"), _ep->xfer_len,
+	            _ep->xfer_count, _ep->xfer_buff, _ep->start_xfer_buff);
+
+	/* IN endpoint */
+	if (_ep->is_in == 1)
+	{
+		dwc_otg_dev_in_ep_regs_t *in_regs =
+		    _core_if->dev_if->in_ep_regs[_ep->num];
+
+		//gnptxsts_data_t gtxstatus;
+
+		if ( !_core_if->dma_enable && (_ep->type != DWC_OTG_EP_TYPE_ISOC)) {
+			//gtxstatus.d32 =
+			//	dwc_read_reg32(&_core_if->core_global_regs->gnptxsts);
+
+			//if(_core_if->en_multiple_tx_fifo == 0 && gtxstatus.b.nptxqspcavail == 0)
+			//{
+//#ifdef DEBUG
+			//	DWC_PRINT("TX Queue Full (0x%0x)\n", gtxstatus.d32);
+//#endif
+			//	return;
+			//}
+		}
+		depctl.d32 = dwc_read_reg32(&(in_regs->diepctl));
+		deptsiz.d32 = dwc_read_reg32(&(in_regs->dieptsiz));
+
+		/* Zero Length Packet? */
+		if (_ep->xfer_len == 0)
+		{
+			deptsiz.b.xfersize = 0;
+			deptsiz.b.pktcnt = 1;
+		}
+		else
+		{
+			/* Program the transfer size and packet count
+			 *	as follows: xfersize = N * maxpacket +
+			 *	short_packet pktcnt = N + (short_packet
+			 *	exist ? 1 : 0)
+			 */
+			deptsiz.b.xfersize = _ep->xfer_len;
+			deptsiz.b.pktcnt =
+			    (_ep->xfer_len - 1 + _ep->maxpacket) /
+			    _ep->maxpacket;
+		}
+		if (_ep->type == DWC_OTG_EP_TYPE_ISOC) {
+			deptsiz.b.mc = deptsiz.b.pktcnt;
+		}
+
+		dwc_write_reg32(&in_regs->dieptsiz, deptsiz.d32);
+
+		/* Write the DMA register */
+		if (_core_if->dma_enable)
+		{
+			dwc_write_reg32 (&(in_regs->diepdma),
+			                 (uint32_t)_ep->dma_addr);
+		}
+		else
+		{
+			if (_ep->type != DWC_OTG_EP_TYPE_ISOC)
+			{
+				/**
+				 * Enable the Non-Periodic Tx FIFO empty interrupt,
+				 * or the Tx FIFO epmty interrupt in dedicated Tx FIFO mode,
+				 * the data will be written into the fifo by the ISR.
+				 */
+				//if(_core_if->en_multiple_tx_fifo == 0)
+				//{
+				//	intr_mask.b.nptxfempty = 1;
+				//	dwc_modify_reg32( &_core_if->core_global_regs->gintsts,
+				//		intr_mask.d32, 0);
+				//	dwc_modify_reg32( &_core_if->core_global_regs->gintmsk,
+				//		intr_mask.d32, intr_mask.d32);
+				//}
+				//else
+				{
+					/* Enable the Tx FIFO Empty Interrupt for this EP */
+					if (_ep->xfer_len > 0)
+					{
+						uint32_t fifoemptymsk = 0;
+						fifoemptymsk = 1 << _ep->num;
+						dwc_modify_reg32(&_core_if->dev_if->dev_global_regs->dtknqr4_fifoemptymsk,
+						                 0, fifoemptymsk);
+					}
+				}
+			}
+		}
+		if (_ep->type == DWC_OTG_EP_TYPE_ISOC) {
+			depctl.b.setd1pid = 1;
+		}
+
+		/* EP enable, IN data in FIFO */
+		depctl.b.cnak = 1;
+		depctl.b.epena = 1;
+//		dwc_write_reg32(&in_regs->diepctl, depctl.d32);
+		dwc_modify_reg32(&in_regs->diepctl,depctl.d32,depctl.d32);
+		depctl.d32 = dwc_read_reg32 (&_core_if->dev_if->in_ep_regs[0]->diepctl);
+		//depctl.b.nextep = _ep->num;
+		//dwc_write_reg32 (&_core_if->dev_if->in_ep_regs[0]->diepctl, depctl.d32);
+
+		// Added by Sheeja S on 10th Sep 07 for ISO IN Slave mode.
+		if (!_core_if->dma_enable && (_ep->type == DWC_OTG_EP_TYPE_ISOC) ) {
+			while (_ep->xfer_count != _ep->xfer_len) {
+				dwc_otg_ep_write_packet (_core_if, _ep, 0);
+			}
+		}
+#if 1
+		DWC_DEBUGPL(DBG_PCD, "DIEPCTL=%08x DIEPTSIZ=%08x\n",
+		            dwc_read_reg32(&in_regs->diepctl),
+		            dwc_read_reg32(&in_regs->dieptsiz));
+		DWC_DEBUGPL(DBG_PCD, "DAINTMSK=%08x GINTMSK=%08x\n",
+		            dwc_read_reg32(&_core_if->dev_if->dev_global_regs->daintmsk),
+		            dwc_read_reg32(&_core_if->core_global_regs->gintmsk));
+#endif
+	}
+	else
+	{
+		/* OUT endpoint */
+		dwc_otg_dev_out_ep_regs_t *out_regs =
+		    _core_if->dev_if->out_ep_regs[_ep->num];
+
+		depctl.d32 = dwc_read_reg32(&(out_regs->doepctl));
+		deptsiz.d32 = dwc_read_reg32(&(out_regs->doeptsiz));
+
+		/* Program the transfer size and packet count as follows:
+		 *
+		 *	pktcnt = N
+		 *	xfersize = N * maxpacket
+		 */
+		if (_ep->xfer_len == 0)
+		{
+			/* Zero Length Packet */
+			deptsiz.b.xfersize = _ep->maxpacket;
+			deptsiz.b.pktcnt = 1;
+		}
+		else
+		{
+			deptsiz.b.pktcnt =
+			    (_ep->xfer_len + (_ep->maxpacket - 1)) /
+			    _ep->maxpacket;
+			deptsiz.b.xfersize = deptsiz.b.pktcnt * _ep->maxpacket;
+		}
+
+		if (_ep->type == DWC_OTG_EP_TYPE_ISOC) {
+			deptsiz.b.mc = deptsiz.b.pktcnt;
+		}
+
+		dwc_write_reg32(&out_regs->doeptsiz, deptsiz.d32);
+
+		DWC_DEBUGPL(DBG_PCDV, "ep%d xfersize=%d pktcnt=%d\n",
+		            _ep->num,
+		            deptsiz.b.xfersize, deptsiz.b.pktcnt);
+
+		if (_core_if->dma_enable)
+		{
+			dwc_write_reg32 (&(out_regs->doepdma),
+			                 (uint32_t)_ep->dma_addr);
+		}
+
+		if (_ep->type == DWC_OTG_EP_TYPE_ISOC)
+		{
+			/** @todo NGS: dpid is read-only. Use setd0pid
+			 * or setd1pid. */
+			if (_ep->even_odd_frame)
+			{
+				depctl.b.setd1pid = 1;
+			}
+			else
+			{
+				depctl.b.setd0pid = 1;
+			}
+			depctl.b.setd1pid = 1;
+		}
+
+		/* EP enable */
+		depctl.b.cnak = 1;
+		depctl.b.epena = 1;
+
+		dwc_write_reg32(&out_regs->doepctl, depctl.d32);
+
+		DWC_DEBUGPL(DBG_PCD, "DOEPCTL=%08x DOEPTSIZ=%08x\n",
+		            dwc_read_reg32(&out_regs->doepctl),
+		            dwc_read_reg32(&out_regs->doeptsiz));
+		DWC_DEBUGPL(DBG_PCD, "DAINTMSK=%08x GINTMSK=%08x\n",
+		            dwc_read_reg32(&_core_if->dev_if->dev_global_regs->daintmsk),
+		            dwc_read_reg32(&_core_if->core_global_regs->gintmsk));
+	}
+}
+
+
+/**
+ * This function does the setup for a data transfer for EP0 and starts
+ * the transfer.  For an IN transfer, the packets will be loaded into
+ * the appropriate Tx FIFO in the ISR. For OUT transfers, the packets are
+ * unloaded from the Rx FIFO in the ISR.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ * @param _ep The EP0 data.
+ */
+void dwc_otg_ep0_start_transfer(dwc_otg_core_if_t *_core_if, dwc_ep_t *_ep)
+{
+	depctl_data_t depctl;
+	deptsiz0_data_t deptsiz;
+
+	DWC_DEBUGPL(DBG_PCD, "ep%d-%s xfer_len=%d xfer_cnt=%d "
+	            "xfer_buff=%p start_xfer_buff=%p total_len=%d\n",
+	            _ep->num, (_ep->is_in?"IN":"OUT"), _ep->xfer_len,
+	            _ep->xfer_count, _ep->xfer_buff, _ep->start_xfer_buff,
+	            _ep->total_len);
+	_ep->total_len = _ep->xfer_len;
+
+	/* IN endpoint */
+	if (_ep->is_in == 1)
+	{
+		dwc_otg_dev_in_ep_regs_t *in_regs =
+		    _core_if->dev_if->in_ep_regs[0];
+
+		//gnptxsts_data_t gtxstatus;
+
+		//gtxstatus.d32 =
+		//	dwc_read_reg32(&_core_if->core_global_regs->gnptxsts);
+
+		//if( !_core_if->dma_enable && _core_if->en_multiple_tx_fifo == 0 && gtxstatus.b.nptxqspcavail == 0)
+		//{
+//#ifdef DEBUG
+		//	deptsiz.d32 = dwc_read_reg32(&in_regs->dieptsiz);
+		//	DWC_DEBUGPL(DBG_PCD,"DIEPCTL0=%0x\n",
+		//		dwc_read_reg32(&in_regs->diepctl));
+		//	DWC_DEBUGPL(DBG_PCD, "DIEPTSIZ0=%0x (sz=%d, pcnt=%d)\n",
+		//		deptsiz.d32,
+		//		deptsiz.b.xfersize, deptsiz.b.pktcnt);
+		//	DWC_PRINT("TX Queue or FIFO Full (0x%0x)\n",
+		//		  gtxstatus.d32);
+//#endif
+		//	return;
+		//}
+
+
+		depctl.d32 = dwc_read_reg32(&in_regs->diepctl);
+		deptsiz.d32 = dwc_read_reg32(&in_regs->dieptsiz);
+
+		/* Zero Length Packet? */
+		if (_ep->xfer_len == 0)
+		{
+			deptsiz.b.xfersize = 0;
+			deptsiz.b.pktcnt = 1;
+		}
+		else
+		{
+			/* Program the transfer size and packet count
+			 *	as follows: xfersize = N * maxpacket +
+			 *	short_packet pktcnt = N + (short_packet
+			 *	exist ? 1 : 0)
+			 */
+			if (_ep->xfer_len > _ep->maxpacket)
+			{
+				_ep->xfer_len = _ep->maxpacket;
+				deptsiz.b.xfersize = _ep->maxpacket;
+			}
+			else
+			{
+				deptsiz.b.xfersize = _ep->xfer_len;
+			}
+			deptsiz.b.pktcnt = 1;
+		}
+		dwc_write_reg32(&in_regs->dieptsiz, deptsiz.d32);
+		DWC_DEBUGPL(DBG_PCDV, "IN len=%d  xfersize=%d pktcnt=%d [%08x]\n",
+		            _ep->xfer_len,
+		            deptsiz.b.xfersize, deptsiz.b.pktcnt, deptsiz.d32);
+
+		/* Write the DMA register */
+		if (_core_if->dma_enable)
+		{
+			dwc_write_reg32 (&(in_regs->diepdma),
+			                 (uint32_t)_ep->dma_addr);
+		}
+
+		/* EP enable, IN data in FIFO */
+		depctl.b.cnak = 1;
+		depctl.b.epena = 1;
+		dwc_write_reg32(&in_regs->diepctl, depctl.d32);
+
+		/**
+		 * Enable the Non-Periodic Tx FIFO empty interrupt, the
+		 * data will be written into the fifo by the ISR.
+		 */
+		if (!_core_if->dma_enable)
+		{
+			//if(_core_if->en_multiple_tx_fifo == 0)
+			//{
+			//	gintmsk_data_t intr_mask = { .d32 = 0};
+			//	intr_mask.b.nptxfempty = 1;
+			//	dwc_modify_reg32( &_core_if->core_global_regs->gintsts,
+			//		intr_mask.d32, 0);
+			//	dwc_modify_reg32( &_core_if->core_global_regs->gintmsk,
+			//		intr_mask.d32, intr_mask.d32);
+			//}
+			//else
+			{
+				/* Enable the Tx FIFO Empty Interrupt for this EP */
+				if (_ep->xfer_len > 0)
+				{
+					uint32_t fifoemptymsk = 0;
+					fifoemptymsk |= 1 << _ep->num;
+					dwc_modify_reg32(&_core_if->dev_if->dev_global_regs->dtknqr4_fifoemptymsk,
+					                 0, fifoemptymsk);
+				}
+			}
+		}
+	}
+	else
+	{
+		/* OUT endpoint */
+		dwc_otg_dev_out_ep_regs_t *out_regs =
+		    _core_if->dev_if->out_ep_regs[_ep->num];
+
+		depctl.d32 = dwc_read_reg32(&out_regs->doepctl);
+		deptsiz.d32 = dwc_read_reg32(&out_regs->doeptsiz);
+
+		/* Program the transfer size and packet count as follows:
+		 *	xfersize = N * (maxpacket + 4 - (maxpacket % 4))
+		 *	pktcnt = N											*/
+		if (_ep->xfer_len == 0)
+		{
+			/* Zero Length Packet */
+			deptsiz.b.xfersize = _ep->maxpacket;
+			deptsiz.b.pktcnt = 1;
+		}
+		else
+		{
+			deptsiz.b.pktcnt =
+			    (_ep->xfer_len + (_ep->maxpacket - 1)) /
+			    _ep->maxpacket;
+			deptsiz.b.xfersize = deptsiz.b.pktcnt * _ep->maxpacket;
+		}
+
+		dwc_write_reg32(&out_regs->doeptsiz, deptsiz.d32);
+		DWC_DEBUGPL(DBG_PCDV, "len=%d  xfersize=%d pktcnt=%d\n",
+		            _ep->xfer_len,
+		            deptsiz.b.xfersize, deptsiz.b.pktcnt);
+
+		if (_core_if->dma_enable)
+		{
+			dwc_write_reg32 (&(out_regs->doepdma),
+			                 (uint32_t)_ep->dma_addr);
+		}
+
+		/* EP enable */
+		depctl.b.cnak = 1;
+		depctl.b.epena = 1;
+		dwc_write_reg32 (&(out_regs->doepctl), depctl.d32);
+	}
+}
+
+/**
+ * This function continues control IN transfers started by
+ * dwc_otg_ep0_start_transfer, when the transfer does not fit in a
+ * single packet.  NOTE: The DIEPCTL0/DOEPCTL0 registers only have one
+ * bit for the packet count.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ * @param _ep The EP0 data.
+ */
+void dwc_otg_ep0_continue_transfer(dwc_otg_core_if_t *_core_if, dwc_ep_t *_ep)
+{
+	depctl_data_t depctl;
+	deptsiz0_data_t deptsiz;
+	//gintmsk_data_t intr_mask = { .d32 = 0};
+	if (_ep->is_in == 1)
+	{
+		dwc_otg_dev_in_ep_regs_t *in_regs =
+		    _core_if->dev_if->in_ep_regs[0];
+		//gnptxsts_data_t tx_status = {.d32 = 0};
+
+		//tx_status.d32 = dwc_read_reg32( &_core_if->core_global_regs->gnptxsts );
+		/** @todo Should there be check for room in the Tx
+		 * Status Queue.  If not remove the code above this comment. */
+
+		depctl.d32 = dwc_read_reg32(&in_regs->diepctl);
+		deptsiz.d32 = dwc_read_reg32(&in_regs->dieptsiz);
+
+		/* Program the transfer size and packet count
+		 *	as follows: xfersize = N * maxpacket +
+		 *	short_packet pktcnt = N + (short_packet
+		 *	exist ? 1 : 0)
+		 */
+		deptsiz.b.xfersize = (_ep->total_len - _ep->xfer_count) > _ep->maxpacket ? _ep->maxpacket :
+		                     (_ep->total_len - _ep->xfer_count);
+		deptsiz.b.pktcnt = 1;
+		_ep->xfer_len += deptsiz.b.xfersize;
+
+		dwc_write_reg32(&in_regs->dieptsiz, deptsiz.d32);
+		DWC_DEBUGPL(DBG_PCDV, "IN len=%d  xfersize=%d pktcnt=%d [%08x] xfer_count %d\n",
+		            _ep->xfer_len,
+		            deptsiz.b.xfersize, deptsiz.b.pktcnt, deptsiz.d32,_ep->xfer_count);
+
+		/* Write the DMA register */
+		if (_core_if->hwcfg2.b.architecture == DWC_INT_DMA_ARCH)
+		{
+			_ep->dma_addr += _ep->maxpacket;
+			dwc_write_reg32 (&(in_regs->diepdma),
+			                 (uint32_t)_ep->dma_addr);
+		}
+
+		/* EP enable, IN data in FIFO */
+		depctl.b.cnak = 1;
+		depctl.b.epena = 1;
+		dwc_write_reg32(&in_regs->diepctl, depctl.d32);
+
+		/**
+		 * Enable the Non-Periodic Tx FIFO empty interrupt, the
+		 * data will be written into the fifo by the ISR.
+		 */
+		//if (!_core_if->dma_enable && _core_if->en_multiple_tx_fifo==0)
+		//{
+		//	/* First clear it from GINTSTS */
+		//	intr_mask.b.nptxfempty = 1;
+		//	dwc_write_reg32( &_core_if->core_global_regs->gintsts,
+		//		intr_mask.d32 );
+		//
+		//	dwc_modify_reg32( &_core_if->core_global_regs->gintmsk,
+		//		intr_mask.d32, intr_mask.d32);
+		//}
+	}
+}
+
+#ifdef DEBUG
+void dump_msg(const u8 *buf, unsigned int length)
+{
+	unsigned int	start, num, i;
+	char		line[52], *p;
+
+	if (length >= 512)
+		return;
+	start = 0;
+	while (length > 0)
+	{
+		num = min(length, 16u);
+		p = line;
+		for (i = 0; i < num; ++i)
+		{
+			if (i == 8)
+				*p++ = ' ';
+			sprintf(p, " %02x", buf[i]);
+			p += 3;
+		}
+		*p = 0;
+		DWC_PRINT( "%6x: %s\n", start, line);
+		buf += num;
+		start += num;
+		length -= num;
+	}
+}
+#else
+static inline void dump_msg(const u8 *buf, unsigned int length)
+{
+}
+#endif
+
+/**
+ * This function writes a packet into the Tx FIFO associated with the
+ * EP.	For non-periodic EPs the non-periodic Tx FIFO is written.  For
+ * periodic EPs the periodic Tx FIFO associated with the EP is written
+ * with all packets for the next micro-frame.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ * @param _ep The EP to write packet for.
+ * @param _dma Indicates if DMA is being used.
+ */
+void dwc_otg_ep_write_packet(dwc_otg_core_if_t *_core_if, dwc_ep_t *_ep, int _dma)
+{
+	/**
+	 * The buffer is padded to DWORD on a per packet basis in
+	 * slave/dma mode if the MPS is not DWORD aligned.	The last
+	 * packet, if short, is also padded to a multiple of DWORD.
+	 *
+	 * ep->xfer_buff always starts DWORD aligned in memory and is a
+	 * multiple of DWORD in length
+	 *
+	 * ep->xfer_len can be any number of bytes
+	 *
+	 * ep->xfer_count is a multiple of ep->maxpacket until the last
+	 *	packet
+	 *
+	 * FIFO access is DWORD */
+
+	uint32_t i;
+	uint32_t byte_count;
+	uint32_t dword_count;
+	uint32_t *fifo;
+	uint32_t *data_buff = (uint32_t *)_ep->xfer_buff;
+
+	//DWC_DEBUGPL((DBG_PCDV | DBG_CILV), "%s(%p,%p)\n", __func__, _core_if, _ep);
+	if (_ep->xfer_count >= _ep->xfer_len) {
+		DWC_WARN("%s() No data for EP%d!!!\n", __func__, _ep->num);
+		return;
+	}
+
+	/* Find the byte length of the packet either short packet or MPS */
+	if ((_ep->xfer_len - _ep->xfer_count) < _ep->maxpacket)
+	{
+		byte_count = _ep->xfer_len - _ep->xfer_count;
+	}
+	else
+	{
+		byte_count = _ep->maxpacket;
+	}
+
+	/* Find the DWORD length, padded by extra bytes as neccessary if MPS
+	 * is not a multiple of DWORD */
+	dword_count =  (byte_count + 3) / 4;
+
+#ifdef VERBOSE
+	dump_msg(_ep->xfer_buff, byte_count);
+#endif
+
+	/**@todo NGS Where are the Periodic Tx FIFO addresses
+	 * intialized?	What should this be? */
+
+	fifo = _core_if->data_fifo[_ep->num];
+
+
+	DWC_DEBUGPL((DBG_PCDV|DBG_CILV), "fifo=%p buff=%p *p=%08x bc=%d\n",
+	            fifo, data_buff, *data_buff, byte_count);
+
+	if (!_dma)
+	{
+		for (i=0; i<dword_count; i++, data_buff++)
+		{
+			dwc_write_reg32( fifo, *data_buff );
+		}
+	}
+
+	_ep->xfer_count += byte_count;
+	_ep->xfer_buff += byte_count;
+}
+
+/**
+ * Set the EP STALL.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ * @param _ep The EP to set the stall on.
+ */
+void dwc_otg_ep_set_stall(dwc_otg_core_if_t *_core_if, dwc_ep_t *_ep)
+{
+	depctl_data_t depctl;
+	volatile uint32_t *depctl_addr;
+
+	DWC_DEBUGPL(DBG_PCD, "%s ep%d-%s\n", __func__, _ep->num,
+	            (_ep->is_in?"IN":"OUT"));
+
+	if (_ep->is_in == 1)
+	{
+		depctl_addr = &(_core_if->dev_if->in_ep_regs[_ep->num]->diepctl);
+		depctl.d32 = dwc_read_reg32(depctl_addr);
+
+		/* set the disable and stall bits */
+		if (depctl.b.epena)
+		{
+			depctl.b.epdis = 1;
+		}
+		depctl.b.stall = 1;
+		dwc_write_reg32(depctl_addr, depctl.d32);
+	}
+	else
+	{
+		depctl_addr = &(_core_if->dev_if->out_ep_regs[_ep->num]->doepctl);
+		depctl.d32 = dwc_read_reg32(depctl_addr);
+
+		/* set the stall bit */
+		depctl.b.stall = 1;
+		dwc_write_reg32(depctl_addr, depctl.d32);
+	}
+
+	DWC_DEBUGPL(DBG_PCD,"DEPCTL=%0x\n",dwc_read_reg32(depctl_addr));
+
+	return;
+}
+
+/**
+ * Clear the EP STALL.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ * @param _ep The EP to clear stall from.
+ */
+void dwc_otg_ep_clear_stall(dwc_otg_core_if_t *_core_if, dwc_ep_t *_ep)
+{
+	depctl_data_t depctl;
+	volatile uint32_t *depctl_addr;
+
+	DWC_DEBUGPL(DBG_PCD, "%s ep%d-%s\n", __func__, _ep->num,
+	            (_ep->is_in?"IN":"OUT"));
+
+	if (_ep->is_in == 1)
+	{
+		depctl_addr = &(_core_if->dev_if->in_ep_regs[_ep->num]->diepctl);
+	}
+	else
+	{
+		depctl_addr = &(_core_if->dev_if->out_ep_regs[_ep->num]->doepctl);
+	}
+
+	depctl.d32 = dwc_read_reg32(depctl_addr);
+
+	/* clear the stall bits */
+	depctl.b.stall = 0;
+
+	/*
+	 * USB Spec 9.4.5: For endpoints using data toggle, regardless
+	 * of whether an endpoint has the Halt feature set, a
+	 * ClearFeature(ENDPOINT_HALT) request always results in the
+	 * data toggle being reinitialized to DATA0.
+	 */
+	if (_ep->type == DWC_OTG_EP_TYPE_INTR ||
+	        _ep->type == DWC_OTG_EP_TYPE_BULK)
+	{
+		depctl.b.setd0pid = 1; /* DATA0 */
+	}
+
+	dwc_write_reg32(depctl_addr, depctl.d32);
+	DWC_DEBUGPL(DBG_PCD,"DEPCTL=%0x\n",dwc_read_reg32(depctl_addr));
+	return;
+}
+
+/**
+ * This function reads a packet from the Rx FIFO into the destination
+ * buffer.	To read SETUP data use dwc_otg_read_setup_packet.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ * @param _dest	  Destination buffer for the packet.
+ * @param _bytes  Number of bytes to copy to the destination.
+ */
+void dwc_otg_read_packet(dwc_otg_core_if_t *_core_if,
+                         uint8_t *_dest,
+                         uint16_t _bytes)
+{
+	int i;
+	int word_count = (_bytes + 3) / 4;
+
+	volatile uint32_t *fifo = _core_if->data_fifo[0];
+	uint32_t *data_buff = (uint32_t *)_dest;
+
+	/**
+	 * @todo Account for the case where _dest is not dword aligned. This
+	 * requires reading data from the FIFO into a uint32_t temp buffer,
+	 * then moving it into the data buffer.
+	 */
+
+	DWC_DEBUGPL((DBG_PCDV | DBG_CILV), "%s(%p,%p,%d)\n", __func__,
+	            _core_if, _dest, _bytes);
+
+	for (i=0; i<word_count; i++, data_buff++) \
+	{
+		*data_buff = dwc_read_reg32(fifo);
+	}
+
+	return;
+}
+
+
+
+/**
+ * This functions reads the device registers and prints them
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ */
+void dwc_otg_dump_dev_registers(dwc_otg_core_if_t *_core_if)
+{
+	int i;
+	volatile uint32_t *addr;
+
+	DWC_PRINT("Device Global Registers\n");
+	addr=&_core_if->dev_if->dev_global_regs->dcfg;
+	DWC_PRINT("DCFG		 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	addr=&_core_if->dev_if->dev_global_regs->dctl;
+	DWC_PRINT("DCTL		 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	addr=&_core_if->dev_if->dev_global_regs->dsts;
+	DWC_PRINT("DSTS		 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	addr=&_core_if->dev_if->dev_global_regs->diepmsk;
+	DWC_PRINT("DIEPMSK	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	addr=&_core_if->dev_if->dev_global_regs->doepmsk;
+	DWC_PRINT("DOEPMSK	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	addr=&_core_if->dev_if->dev_global_regs->daint;
+	DWC_PRINT("DAINT	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	addr=&_core_if->dev_if->dev_global_regs->dtknqr1;
+	DWC_PRINT("DTKNQR1	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	if (_core_if->hwcfg2.b.dev_token_q_depth > 6)
+	{
+		addr=&_core_if->dev_if->dev_global_regs->dtknqr2;
+		DWC_PRINT("DTKNQR2	 @0x%08X : 0x%08X\n",
+		          (uint32_t)addr,dwc_read_reg32(addr));
+	}
+
+	addr=&_core_if->dev_if->dev_global_regs->dvbusdis;
+	DWC_PRINT("DVBUSID	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+
+	addr=&_core_if->dev_if->dev_global_regs->dvbuspulse;
+	DWC_PRINT("DVBUSPULSE	@0x%08X : 0x%08X\n",
+	          (uint32_t)addr,dwc_read_reg32(addr));
+
+	if (_core_if->hwcfg2.b.dev_token_q_depth > 14)
+	{
+		addr=&_core_if->dev_if->dev_global_regs->dtknqr3_dthrctl;
+		DWC_PRINT("DTKNQR3	 @0x%08X : 0x%08X\n",
+		          (uint32_t)addr, dwc_read_reg32(addr));
+	}
+
+	if (_core_if->hwcfg2.b.dev_token_q_depth > 22)
+	{
+		addr=&_core_if->dev_if->dev_global_regs->dtknqr4_fifoemptymsk;
+		DWC_PRINT("DTKNQR4	 @0x%08X : 0x%08X\n",
+		          (uint32_t)addr, dwc_read_reg32(addr));
+	}
+
+	for (i=0; i<= _core_if->dev_if->num_in_eps; i++)
+	{
+		DWC_PRINT("Device IN EP %d Registers\n", i);
+		addr=&_core_if->dev_if->in_ep_regs[i]->diepctl;
+		DWC_PRINT("DIEPCTL	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+		addr=&_core_if->dev_if->in_ep_regs[i]->diepint;
+		DWC_PRINT("DIEPINT	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+		addr=&_core_if->dev_if->in_ep_regs[i]->dieptsiz;
+		DWC_PRINT("DIETSIZ	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+		addr=&_core_if->dev_if->in_ep_regs[i]->diepdma;
+		DWC_PRINT("DIEPDMA	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+		addr=&_core_if->dev_if->in_ep_regs[i]->dtxfsts;
+		DWC_PRINT("DTXFSTS	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	}
+
+
+	for (i=0; i<= _core_if->dev_if->num_out_eps; i++)
+	{
+		DWC_PRINT("Device OUT EP %d Registers\n", i);
+		addr=&_core_if->dev_if->out_ep_regs[i]->doepctl;
+		DWC_PRINT("DOEPCTL	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+		addr=&_core_if->dev_if->out_ep_regs[i]->doepfn;
+		DWC_PRINT("DOEPFN	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+		addr=&_core_if->dev_if->out_ep_regs[i]->doepint;
+		DWC_PRINT("DOEPINT	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+		addr=&_core_if->dev_if->out_ep_regs[i]->doeptsiz;
+		DWC_PRINT("DOETSIZ	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+		addr=&_core_if->dev_if->out_ep_regs[i]->doepdma;
+		DWC_PRINT("DOEPDMA	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+
+	}
+	return;
+}
+
+/**
+ * This function reads the host registers and prints them
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ */
+void dwc_otg_dump_host_registers(dwc_otg_core_if_t *_core_if)
+{
+	int i;
+	volatile uint32_t *addr;
+
+	DWC_PRINT("Host Global Registers\n");
+	addr=&_core_if->host_if->host_global_regs->hcfg;
+	DWC_PRINT("HCFG		 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	addr=&_core_if->host_if->host_global_regs->hfir;
+	DWC_PRINT("HFIR		 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	addr=&_core_if->host_if->host_global_regs->hfnum;
+	DWC_PRINT("HFNUM	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	addr=&_core_if->host_if->host_global_regs->hptxsts;
+	DWC_PRINT("HPTXSTS	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	addr=&_core_if->host_if->host_global_regs->haint;
+	DWC_PRINT("HAINT	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	addr=&_core_if->host_if->host_global_regs->haintmsk;
+	DWC_PRINT("HAINTMSK	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	addr=_core_if->host_if->hprt0;
+	DWC_PRINT("HPRT0	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+
+	for (i=0; i<_core_if->core_params->host_channels; i++)
+	{
+		DWC_PRINT("Host Channel %d Specific Registers\n", i);
+		addr=&_core_if->host_if->hc_regs[i]->hcchar;
+		DWC_PRINT("HCCHAR	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+		addr=&_core_if->host_if->hc_regs[i]->hcsplt;
+		DWC_PRINT("HCSPLT	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+		addr=&_core_if->host_if->hc_regs[i]->hcint;
+		DWC_PRINT("HCINT	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+		addr=&_core_if->host_if->hc_regs[i]->hcintmsk;
+		DWC_PRINT("HCINTMSK	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+		addr=&_core_if->host_if->hc_regs[i]->hctsiz;
+		DWC_PRINT("HCTSIZ	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+		addr=&_core_if->host_if->hc_regs[i]->hcdma;
+		DWC_PRINT("HCDMA	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+
+	}
+	return;
+}
+
+/**
+ * This function reads the core global registers and prints them
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ */
+void dwc_otg_dump_global_registers(dwc_otg_core_if_t *_core_if)
+{
+	int i;
+	volatile uint32_t *addr;
+
+	DWC_PRINT("Core Global Registers\n");
+	addr=&_core_if->core_global_regs->gotgctl;
+	DWC_PRINT("GOTGCTL	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	addr=&_core_if->core_global_regs->gotgint;
+	DWC_PRINT("GOTGINT	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	addr=&_core_if->core_global_regs->gahbcfg;
+	DWC_PRINT("GAHBCFG	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	addr=&_core_if->core_global_regs->gusbcfg;
+	DWC_PRINT("GUSBCFG	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	addr=&_core_if->core_global_regs->grstctl;
+	DWC_PRINT("GRSTCTL	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	addr=&_core_if->core_global_regs->gintsts;
+	DWC_PRINT("GINTSTS	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	addr=&_core_if->core_global_regs->gintmsk;
+	DWC_PRINT("GINTMSK	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	addr=&_core_if->core_global_regs->grxstsr;
+	DWC_PRINT("GRXSTSR	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	//addr=&_core_if->core_global_regs->grxstsp;
+	//DWC_PRINT("GRXSTSP   @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	addr=&_core_if->core_global_regs->grxfsiz;
+	DWC_PRINT("GRXFSIZ	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	addr=&_core_if->core_global_regs->gnptxfsiz;
+	DWC_PRINT("GNPTXFSIZ @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	addr=&_core_if->core_global_regs->gnptxsts;
+	DWC_PRINT("GNPTXSTS	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	addr=&_core_if->core_global_regs->gi2cctl;
+	DWC_PRINT("GI2CCTL	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	addr=&_core_if->core_global_regs->gpvndctl;
+	DWC_PRINT("GPVNDCTL	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	addr=&_core_if->core_global_regs->ggpio;
+	DWC_PRINT("GGPIO	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	addr=&_core_if->core_global_regs->guid;
+	DWC_PRINT("GUID		 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	addr=&_core_if->core_global_regs->gsnpsid;
+	DWC_PRINT("GSNPSID	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	addr=&_core_if->core_global_regs->ghwcfg1;
+	DWC_PRINT("GHWCFG1	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	addr=&_core_if->core_global_regs->ghwcfg2;
+	DWC_PRINT("GHWCFG2	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	addr=&_core_if->core_global_regs->ghwcfg3;
+	DWC_PRINT("GHWCFG3	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	addr=&_core_if->core_global_regs->ghwcfg4;
+	DWC_PRINT("GHWCFG4	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+	addr=&_core_if->core_global_regs->hptxfsiz;
+	DWC_PRINT("HPTXFSIZ	 @0x%08X : 0x%08X\n",(uint32_t)addr,dwc_read_reg32(addr));
+
+	for (i=0; i<_core_if->hwcfg4.b.num_dev_perio_in_ep; i++)
+	{
+		addr=&_core_if->core_global_regs->dptxfsiz_dieptxf[i];
+		DWC_PRINT("DPTXFSIZ[%d] @0x%08X : 0x%08X\n",i,(uint32_t)addr,dwc_read_reg32(addr));
+	}
+}
+
+/**
+ * Flush a Tx FIFO.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ * @param _num Tx FIFO to flush.
+ */
+extern void dwc_otg_flush_tx_fifo( dwc_otg_core_if_t *_core_if,
+                                   const int _num )
+{
+	dwc_otg_core_global_regs_t *global_regs = _core_if->core_global_regs;
+	volatile grstctl_t greset = { .d32 = 0};
+	int count = 0;
+
+	DWC_DEBUGPL((DBG_CIL|DBG_PCDV), "Flush Tx FIFO %d\n", _num);
+
+	greset.b.txfflsh = 1;
+	greset.b.txfnum = _num;
+	dwc_write_reg32( &global_regs->grstctl, greset.d32 );
+
+	do
+	{
+		greset.d32 = dwc_read_reg32( &global_regs->grstctl);
+		if (++count > 10000)
+		{
+			DWC_WARN("%s() HANG! GRSTCTL=%0x GNPTXSTS=0x%08x\n",
+			         __func__, greset.d32,
+			         dwc_read_reg32( &global_regs->gnptxsts));
+			break;
+		}
+	}
+	while (greset.b.txfflsh == 1);
+
+	/* Wait for 3 PHY Clocks*/
+	UDELAY(1);
+}
+
+/**
+ * Flush Rx FIFO.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ */
+extern void dwc_otg_flush_rx_fifo( dwc_otg_core_if_t *_core_if )
+{
+	dwc_otg_core_global_regs_t *global_regs = _core_if->core_global_regs;
+	volatile grstctl_t greset = { .d32 = 0};
+	int count = 0;
+
+	DWC_DEBUGPL((DBG_CIL|DBG_PCDV), "%s\n", __func__);
+	/*
+	 *
+	 */
+	greset.b.rxfflsh = 1;
+	dwc_write_reg32( &global_regs->grstctl, greset.d32 );
+
+	do
+	{
+		greset.d32 = dwc_read_reg32( &global_regs->grstctl);
+		if (++count > 10000)
+		{
+			DWC_WARN("%s() HANG! GRSTCTL=%0x\n", __func__,
+			         greset.d32);
+			break;
+		}
+	}
+	while (greset.b.rxfflsh == 1);
+
+	/* Wait for 3 PHY Clocks*/
+	UDELAY(1);
+}
+
+/**
+ * Do core a soft reset of the core.  Be careful with this because it
+ * resets all the internal state machines of the core.
+ */
+void dwc_otg_core_reset(dwc_otg_core_if_t *_core_if)
+{
+	dwc_otg_core_global_regs_t *global_regs = _core_if->core_global_regs;
+	volatile grstctl_t greset = { .d32 = 0};
+	int count = 0;
+
+	DWC_DEBUGPL(DBG_CILV, "%s\n", __func__);
+	/* Wait for AHB master IDLE state. */
+	do
+	{
+		UDELAY(10);
+		greset.d32 = dwc_read_reg32( &global_regs->grstctl);
+		if (++count > 100000)
+		{
+			DWC_WARN("%s() HANG! AHB Idle GRSTCTL=%0x\n", __func__,
+			         greset.d32);
+			return;
+		}
+	}
+	while (greset.b.ahbidle == 0);
+
+	/* Core Soft Reset */
+	count = 0;
+	greset.b.csftrst = 1;
+	dwc_write_reg32( &global_regs->grstctl, greset.d32 );
+	do
+	{
+		greset.d32 = dwc_read_reg32( &global_regs->grstctl);
+		if (++count > 10000)
+		{
+			DWC_WARN("%s() HANG! Soft Reset GRSTCTL=%0x\n", __func__,
+			         greset.d32);
+			break;
+		}
+	}
+	while (greset.b.csftrst == 1);
+
+	/* Wait for 3 PHY Clocks*/
+	//DWC_PRINT("100ms\n");
+	MDELAY(100);
+}
+
+
+
+/**
+ * Register HCD callbacks.	The callbacks are used to start and stop
+ * the HCD for interrupt processing.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ * @param _cb the HCD callback structure.
+ * @param _p pointer to be passed to callback function (usb_hcd*).
+ */
+extern void dwc_otg_cil_register_hcd_callbacks( dwc_otg_core_if_t *_core_if,
+        dwc_otg_cil_callbacks_t *_cb,
+        void *_p)
+{
+	_core_if->hcd_cb = _cb;
+	_cb->p = _p;
+}
+
+/**
+ * Register PCD callbacks.	The callbacks are used to start and stop
+ * the PCD for interrupt processing.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ * @param _cb the PCD callback structure.
+ * @param _p pointer to be passed to callback function (pcd*).
+ */
+extern void dwc_otg_cil_register_pcd_callbacks( dwc_otg_core_if_t *_core_if,
+        dwc_otg_cil_callbacks_t *_cb,
+        void *_p)
+{
+	_core_if->pcd_cb = _cb;
+	_cb->p = _p;
+}
+
Index: linux-2.6.29/drivers/usb/dwc_otg/dwc_otg_cil.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/usb/dwc_otg/dwc_otg_cil.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,894 @@
+/* ==========================================================================
+ * $File: //dwh/usb_iip/dev/software/otg_ipmate/linux/drivers/dwc_otg_cil.h $
+ * $Revision: #12 $
+ * $Date: 2007/02/08 $
+ * $Change: 792294 $
+ *
+ * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
+ * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto. You are permitted to use and
+ * redistribute this Software in source and binary forms, with or without
+ * modification, provided that redistributions of source code must retain this
+ * notice. You may not view, use, disclose, copy or distribute this file or
+ * any information contained herein except pursuant to this license grant from
+ * Synopsys. If you do not agree with this notice, including the disclaimer
+ * below, then you are not authorized to use the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================== */
+
+#if !defined(__DWC_CIL_H__)
+#define __DWC_CIL_H__
+
+#include "dwc_otg_plat.h"
+#include "dwc_otg_regs.h"
+#include <linux/workqueue.h>
+#ifdef DEBUG
+#include "linux/timer.h"
+#endif
+
+/**
+ * @file
+ * This file contains the interface to the Core Interface Layer.
+ */
+
+/**
+ * The <code>dwc_ep</code> structure represents the state of a single
+ * endpoint when acting in device mode. It contains the data items
+ * needed for an endpoint to be activated and transfer packets.
+ */
+typedef struct dwc_ep
+{
+	/** EP number used for register address lookup */
+	uint8_t	 num;
+	/** EP direction 0 = OUT */
+	unsigned is_in : 1;
+	/** EP active. */
+	unsigned active : 1;
+
+	/** Periodic Tx FIFO # for IN EPs For INTR EP set to 0 to use non-periodic Tx FIFO
+		If dedicated Tx FIFOs are enabled for all IN Eps - Tx FIFO # FOR IN EPs*/
+	unsigned tx_fifo_num : 4;
+	/** EP type: 0 - Control, 1 - ISOC,	 2 - BULK,	3 - INTR */
+	unsigned type : 2;
+#define DWC_OTG_EP_TYPE_CONTROL	   0
+#define DWC_OTG_EP_TYPE_ISOC	   1
+#define DWC_OTG_EP_TYPE_BULK	   2
+#define DWC_OTG_EP_TYPE_INTR	   3
+
+	/** DATA start PID for INTR and BULK EP */
+	unsigned data_pid_start : 1;
+	/** Frame (even/odd) for ISOC EP */
+	unsigned even_odd_frame : 1;
+	/** Max Packet bytes */
+	unsigned maxpacket : 11;
+
+	/** @name Transfer state */
+	/** @{ */
+
+	/**
+	 * Pointer to the beginning of the transfer buffer -- do not modify
+	 * during transfer.
+	 */
+
+	uint32_t dma_addr;
+
+	uint8_t *start_xfer_buff;
+	/** pointer to the transfer buffer */
+	uint8_t *xfer_buff;
+	/** Number of bytes to transfer */
+	unsigned xfer_len : 19;
+	/** Number of bytes transferred. */
+	unsigned xfer_count : 19;
+	/** Sent ZLP */
+	unsigned sent_zlp : 1;
+	/** Total len for control transfer */
+	unsigned total_len : 19;
+
+	/** stall clear flag */
+	unsigned stall_clear_flag : 1;
+	/** @} */
+} dwc_ep_t;
+
+/*
+ * Reasons for halting a host channel.
+ */
+typedef enum dwc_otg_halt_status
+{
+	DWC_OTG_HC_XFER_NO_HALT_STATUS,
+	DWC_OTG_HC_XFER_COMPLETE,
+	DWC_OTG_HC_XFER_URB_COMPLETE,
+	DWC_OTG_HC_XFER_ACK,
+	DWC_OTG_HC_XFER_NAK,
+	DWC_OTG_HC_XFER_NYET,
+	DWC_OTG_HC_XFER_STALL,
+	DWC_OTG_HC_XFER_XACT_ERR,
+	DWC_OTG_HC_XFER_FRAME_OVERRUN,
+	DWC_OTG_HC_XFER_BABBLE_ERR,
+	DWC_OTG_HC_XFER_DATA_TOGGLE_ERR,
+	DWC_OTG_HC_XFER_AHB_ERR,
+	DWC_OTG_HC_XFER_PERIODIC_INCOMPLETE,
+	DWC_OTG_HC_XFER_URB_DEQUEUE
+} dwc_otg_halt_status_e;
+
+/**
+ * Host channel descriptor. This structure represents the state of a single
+ * host channel when acting in host mode. It contains the data items needed to
+ * transfer packets to an endpoint via a host channel.
+ */
+typedef struct dwc_hc
+{
+	/** Host channel number used for register address lookup */
+	uint8_t	 hc_num;
+
+	/** Device to access */
+	unsigned dev_addr : 7;
+
+	/** EP to access */
+	unsigned ep_num : 4;
+
+	/** EP direction. 0: OUT, 1: IN */
+	unsigned ep_is_in : 1;
+
+	/**
+	 * EP speed.
+	 * One of the following values:
+	 *	- DWC_OTG_EP_SPEED_LOW
+	 *	- DWC_OTG_EP_SPEED_FULL
+	 *	- DWC_OTG_EP_SPEED_HIGH
+	 */
+	unsigned speed : 2;
+#define DWC_OTG_EP_SPEED_LOW	0
+#define DWC_OTG_EP_SPEED_FULL	1
+#define DWC_OTG_EP_SPEED_HIGH	2
+
+	/**
+	 * Endpoint type.
+	 * One of the following values:
+	 *	- DWC_OTG_EP_TYPE_CONTROL: 0
+	 *	- DWC_OTG_EP_TYPE_ISOC: 1
+	 *	- DWC_OTG_EP_TYPE_BULK: 2
+	 *	- DWC_OTG_EP_TYPE_INTR: 3
+	 */
+	unsigned ep_type : 2;
+
+	/** Max packet size in bytes */
+	unsigned max_packet : 11;
+
+	/**
+	 * PID for initial transaction.
+	 * 0: DATA0,<br>
+	 * 1: DATA2,<br>
+	 * 2: DATA1,<br>
+	 * 3: MDATA (non-Control EP),
+	 *	  SETUP (Control EP)
+	 */
+	unsigned data_pid_start : 2;
+#define DWC_OTG_HC_PID_DATA0 0
+#define DWC_OTG_HC_PID_DATA2 1
+#define DWC_OTG_HC_PID_DATA1 2
+#define DWC_OTG_HC_PID_MDATA 3
+#define DWC_OTG_HC_PID_SETUP 3
+
+	/** Number of periodic transactions per (micro)frame */
+	unsigned multi_count: 2;
+
+	/** @name Transfer State */
+	/** @{ */
+
+	/** Pointer to the current transfer buffer position. */
+	uint8_t *xfer_buff;
+	/** Total number of bytes to transfer. */
+	uint32_t xfer_len;
+	/** Number of bytes transferred so far. */
+	uint32_t xfer_count;
+	/** Packet count at start of transfer.*/
+	uint16_t start_pkt_count;
+
+	/**
+	 * Flag to indicate whether the transfer has been started. Set to 1 if
+	 * it has been started, 0 otherwise.
+	 */
+	uint8_t xfer_started;
+
+	/**
+	 * Set to 1 to indicate that a PING request should be issued on this
+	 * channel. If 0, process normally.
+	 */
+	uint8_t do_ping;
+
+	/**
+	 * Set to 1 to indicate that the error count for this transaction is
+	 * non-zero. Set to 0 if the error count is 0.
+	 */
+	uint8_t error_state;
+
+	/**
+	 * Set to 1 to indicate that this channel should be halted the next
+	 * time a request is queued for the channel. This is necessary in
+	 * slave mode if no request queue space is available when an attempt
+	 * is made to halt the channel.
+	 */
+	uint8_t halt_on_queue;
+
+	/**
+	 * Set to 1 if the host channel has been halted, but the core is not
+	 * finished flushing queued requests. Otherwise 0.
+	 */
+	uint8_t halt_pending;
+
+	/**
+	 * Reason for halting the host channel.
+	 */
+	dwc_otg_halt_status_e	halt_status;
+
+	/*
+	 * Split settings for the host channel
+	 */
+	uint8_t do_split;		   /**< Enable split for the channel */
+	uint8_t complete_split;	   /**< Enable complete split */
+	uint8_t hub_addr;		   /**< Address of high speed hub */
+
+	uint8_t port_addr;		   /**< Port of the low/full speed device */
+	/** Split transaction position
+	 * One of the following values:
+	 *	  - DWC_HCSPLIT_XACTPOS_MID
+	 *	  - DWC_HCSPLIT_XACTPOS_BEGIN
+	 *	  - DWC_HCSPLIT_XACTPOS_END
+	 *	  - DWC_HCSPLIT_XACTPOS_ALL */
+	uint8_t xact_pos;
+
+	/** Set when the host channel does a short read. */
+	uint8_t short_read;
+
+	/**
+	 * Number of requests issued for this channel since it was assigned to
+	 * the current transfer (not counting PINGs).
+	 */
+	uint8_t requests;
+
+	/**
+	 * Queue Head for the transfer being processed by this channel.
+	 */
+	struct dwc_otg_qh *qh;
+
+	/** @} */
+
+	/** Entry in list of host channels. */
+	struct list_head	hc_list_entry;
+} dwc_hc_t;
+
+/**
+ * The following parameters may be specified when starting the module. These
+ * parameters define how the DWC_otg controller should be configured.
+ * Parameter values are passed to the CIL initialization function
+ * dwc_otg_cil_init.
+ */
+typedef struct dwc_otg_core_params
+{
+	int32_t opt;
+#define dwc_param_opt_default 1
+
+	/**
+	 * Specifies the OTG capabilities. The driver will automatically
+	 * detect the value for this parameter if none is specified.
+	 * 0 - HNP and SRP capable (default)
+	 * 1 - SRP Only capable
+	 * 2 - No HNP/SRP capable
+	 */
+	int32_t otg_cap;
+#define DWC_OTG_CAP_PARAM_HNP_SRP_CAPABLE 0
+#define DWC_OTG_CAP_PARAM_SRP_ONLY_CAPABLE 1
+#define DWC_OTG_CAP_PARAM_NO_HNP_SRP_CAPABLE 2
+#define dwc_param_otg_cap_default DWC_OTG_CAP_PARAM_HNP_SRP_CAPABLE
+
+	/**
+	 * Specifies whether to use slave or DMA mode for accessing the data
+	 * FIFOs. The driver will automatically detect the value for this
+	 * parameter if none is specified.
+	 * 0 - Slave
+	 * 1 - DMA (default, if available)
+	 */
+	int32_t dma_enable;
+#define dwc_param_dma_enable_default 1
+
+	/** The DMA Burst size (applicable only for External DMA
+	 * Mode). 1, 4, 8 16, 32, 64, 128, 256 (default 32)
+	 */
+	int32_t dma_burst_size;	 /* Translate this to GAHBCFG values */
+#define dwc_param_dma_burst_size_default 32
+
+	/**
+	 * Specifies the maximum speed of operation in host and device mode.
+	 * The actual speed depends on the speed of the attached device and
+	 * the value of phy_type. The actual speed depends on the speed of the
+	 * attached device.
+	 * 0 - High Speed (default)
+	 * 1 - Full Speed
+	 */
+	int32_t speed;
+#define dwc_param_speed_default 0
+#define DWC_SPEED_PARAM_HIGH 0
+#define DWC_SPEED_PARAM_FULL 1
+
+	/** Specifies whether low power mode is supported when attached
+	 *	to a Full Speed or Low Speed device in host mode.
+	 * 0 - Don't support low power mode (default)
+	 * 1 - Support low power mode
+	 */
+	int32_t host_support_fs_ls_low_power;
+#define dwc_param_host_support_fs_ls_low_power_default 0
+
+	/** Specifies the PHY clock rate in low power mode when connected to a
+	 * Low Speed device in host mode. This parameter is applicable only if
+	 * HOST_SUPPORT_FS_LS_LOW_POWER is enabled.	 If PHY_TYPE is set to FS
+	 * then defaults to 6 MHZ otherwise 48 MHZ.
+	 *
+	 * 0 - 48 MHz
+	 * 1 - 6 MHz
+	 */
+	int32_t host_ls_low_power_phy_clk;
+#define dwc_param_host_ls_low_power_phy_clk_default 0
+#define DWC_HOST_LS_LOW_POWER_PHY_CLK_PARAM_48MHZ 0
+#define DWC_HOST_LS_LOW_POWER_PHY_CLK_PARAM_6MHZ 1
+
+	/**
+	 * 0 - Use cC FIFO size parameters
+	 * 1 - Allow dynamic FIFO sizing (default)
+	 */
+	int32_t enable_dynamic_fifo;
+#define dwc_param_enable_dynamic_fifo_default 1
+
+	/** Total number of 4-byte words in the data FIFO memory. This
+	 * memory includes the Rx FIFO, non-periodic Tx FIFO, and periodic
+	 * Tx FIFOs.
+	 * 32 to 32768
+	 * AlenOh:Note: The total FIFO memory depth in the TCC configuration is 4160.
+	 */
+	int32_t data_fifo_size;
+#define dwc_param_data_fifo_size_default 4160
+
+	/** Number of 4-byte words in the Rx FIFO in device mode when dynamic
+	 * FIFO sizing is enabled.
+	 * 16 to 32768 (default 1064)
+	 */
+	int32_t dev_rx_fifo_size;
+#define dwc_param_dev_rx_fifo_size_default 1064
+
+	/** Number of 4-byte words in the non-periodic Tx FIFO in device mode
+	 * when dynamic FIFO sizing is enabled.
+	 * 16 to 32768 (default 1024)
+	 */
+	int32_t dev_nperio_tx_fifo_size;
+#define dwc_param_dev_nperio_tx_fifo_size_default (64/4) //1024 //AlenOh
+
+	/** Number of 4-byte words in each of the periodic Tx FIFOs in device
+	 * mode when dynamic FIFO sizing is enabled.
+	 * 4 to 768 (default 256)
+	 */
+	uint32_t dev_perio_tx_fifo_size[MAX_PERIO_FIFOS];
+#define dwc_param_dev_perio_tx_fifo_size_default 256
+
+	/** Number of 4-byte words in the Rx FIFO in host mode when dynamic
+	 * FIFO sizing is enabled.
+	 * 16 to 32768 (default 1024)
+	 */
+	int32_t host_rx_fifo_size;
+#define dwc_param_host_rx_fifo_size_default 1024
+
+	/** Number of 4-byte words in the non-periodic Tx FIFO in host mode
+	* when Dynamic FIFO sizing is enabled in the core.
+	* 16 to 32768 (default 1024)
+	*/
+	int32_t host_nperio_tx_fifo_size;
+#define dwc_param_host_nperio_tx_fifo_size_default 1024
+
+	/** Number of 4-byte words in the host periodic Tx FIFO when dynamic
+	 * FIFO sizing is enabled.
+	 * 16 to 32768 (default 1024)
+	 */
+	int32_t host_perio_tx_fifo_size;
+#define dwc_param_host_perio_tx_fifo_size_default 1024
+
+	/** The maximum transfer size supported in bytes.
+	 * 2047 to 65,535  (default 65,535)
+	 */
+	int32_t max_transfer_size;
+#define dwc_param_max_transfer_size_default 65535
+
+	/** The maximum number of packets in a transfer.
+	 * 15 to 511  (default 511)
+	 */
+	int32_t max_packet_count;
+#define dwc_param_max_packet_count_default 511
+
+	/** The number of host channel registers to use.
+	 * 1 to 16 (default 12)
+	 * Note: The FPGA configuration supports a maximum of 12 host channels.
+	 */
+	int32_t host_channels;
+#define dwc_param_host_channels_default 12
+
+	/** The number of endpoints in addition to EP0 available for device
+	 * mode operations.
+	 * 1 to 15 (default 6 IN and OUT)
+	 * Note: The FPGA configuration supports a maximum of 6 IN and OUT
+	 * endpoints in addition to EP0.
+	 */
+	int32_t dev_endpoints;
+#define dwc_param_dev_endpoints_default 6
+
+	/**
+	 * Specifies the type of PHY interface to use. By default, the driver
+	 * will automatically detect the phy_type.
+	 *
+	 * 0 - Full Speed PHY
+	 * 1 - UTMI+ (default)
+	 * 2 - ULPI
+	 */
+	int32_t phy_type;
+#define DWC_PHY_TYPE_PARAM_FS 0
+#define DWC_PHY_TYPE_PARAM_UTMI 1
+#define DWC_PHY_TYPE_PARAM_ULPI 2
+#define dwc_param_phy_type_default DWC_PHY_TYPE_PARAM_UTMI
+
+	/**
+	 * Specifies the UTMI+ Data Width.	This parameter is
+	 * applicable for a PHY_TYPE of UTMI+ or ULPI. (For a ULPI
+	 * PHY_TYPE, this parameter indicates the data width between
+	 * the MAC and the ULPI Wrapper.) Also, this parameter is
+	 * applicable only if the OTG_HSPHY_WIDTH cC parameter was set
+	 * to "8 and 16 bits", meaning that the core has been
+	 * configured to work at either data path width.
+	 *
+	 * 8 or 16 bits (default 16)
+	 */
+	int32_t phy_utmi_width;
+#define dwc_param_phy_utmi_width_default 16
+
+	/**
+	 * Specifies whether the ULPI operates at double or single
+	 * data rate. This parameter is only applicable if PHY_TYPE is
+	 * ULPI.
+	 *
+	 * 0 - single data rate ULPI interface with 8 bit wide data
+	 * bus (default)
+	 * 1 - double data rate ULPI interface with 4 bit wide data
+	 * bus
+	 */
+	int32_t phy_ulpi_ddr;
+#define dwc_param_phy_ulpi_ddr_default 0
+
+	/**
+	 * Specifies whether to use the internal or external supply to
+	 * drive the vbus with a ULPI phy.
+	 */
+	int32_t phy_ulpi_ext_vbus;
+#define DWC_PHY_ULPI_INTERNAL_VBUS 0
+#define DWC_PHY_ULPI_EXTERNAL_VBUS 1
+#define dwc_param_phy_ulpi_ext_vbus_default DWC_PHY_ULPI_INTERNAL_VBUS
+
+	/**
+	 * Specifies whether to use the I2Cinterface for full speed PHY. This
+	 * parameter is only applicable if PHY_TYPE is FS.
+	 * 0 - No (default)
+	 * 1 - Yes
+	 */
+	int32_t i2c_enable;
+#define dwc_param_i2c_enable_default 0
+
+	int32_t ulpi_fs_ls;
+#define dwc_param_ulpi_fs_ls_default 0
+
+	int32_t ts_dline;
+#define dwc_param_ts_dline_default 0
+
+	/**
+	 * Specifies whether dedicated transmit FIFOs are
+	 * enabled for non periodic IN endpoints in device mode
+	 * 0 - No
+	 * 1 - Yes
+	 */
+	int32_t en_multiple_tx_fifo;
+#define dwc_param_en_multiple_tx_fifo_default 1
+
+	/** Number of 4-byte words in each of the Tx FIFOs in device
+	 * mode when dynamic FIFO sizing is enabled.
+	 * 4 to 768 (default 256)
+	 */
+	uint32_t dev_tx_fifo_size[MAX_TX_FIFOS];
+#define dwc_param_dev_tx_fifo_size_default 256
+
+	/** Thresholding enable flag-
+	 * bit 0 - enable non-ISO Tx thresholding
+	 * bit 1 - enable ISO Tx thresholding
+	 * bit 2 - enable Rx thresholding
+	 */
+	uint32_t thr_ctl;
+#define dwc_param_thr_ctl_default 0
+
+	/** Thresholding length for Tx
+	 *	FIFOs in 32 bit DWORDs
+	 */
+	uint32_t tx_thr_length;
+#define dwc_param_tx_thr_length_default 64
+
+	/** Thresholding length for Rx
+	 *	FIFOs in 32 bit DWORDs
+	 */
+	uint32_t rx_thr_length;
+#define dwc_param_rx_thr_length_default 64
+
+} dwc_otg_core_params_t;
+
+#ifdef DEBUG
+struct dwc_otg_core_if;
+typedef struct hc_xfer_info
+{
+	struct dwc_otg_core_if	*core_if;
+	dwc_hc_t		*hc;
+} hc_xfer_info_t;
+#endif
+
+/**
+ * The <code>dwc_otg_core_if</code> structure contains information needed to manage
+ * the DWC_otg controller acting in either host or device mode. It
+ * represents the programming view of the controller as a whole.
+ */
+typedef struct dwc_otg_core_if
+{
+	/** Parameters that define how the core should be configured.*/
+	dwc_otg_core_params_t	   *core_params;
+
+	/** Core Global registers starting at offset 000h. */
+	dwc_otg_core_global_regs_t *core_global_regs;
+
+	/** Device-specific information */
+	dwc_otg_dev_if_t		   *dev_if;
+	/** Host-specific information */
+	dwc_otg_host_if_t		   *host_if;
+
+	/*
+	 * Set to 1 if the core PHY interface bits in USBCFG have been
+	 * initialized.
+	 */
+	uint8_t phy_init_done;
+
+	/*
+	 * SRP Success flag, set by srp success interrupt in FS I2C mode
+	 */
+	uint8_t srp_success;
+	uint8_t srp_timer_started;
+
+	/* Common configuration information */
+	/** Power and Clock Gating Control Register */
+	volatile uint32_t *pcgcctl;
+#define DWC_OTG_PCGCCTL_OFFSET 0xE00
+
+	/** Push/pop addresses for endpoints or host channels.*/
+	uint32_t *data_fifo[MAX_EPS_CHANNELS];
+#define DWC_OTG_DATA_FIFO_OFFSET 0x1000
+#define DWC_OTG_DATA_FIFO_SIZE 0x1000
+
+	/** Total RAM for FIFOs (Bytes) */
+	uint16_t total_fifo_size;
+	/** Size of Rx FIFO (Bytes) */
+	uint16_t rx_fifo_size;
+	/** Size of Non-periodic Tx FIFO (Bytes) */
+	uint16_t nperio_tx_fifo_size;
+
+
+	/** 1 if DMA is enabled, 0 otherwise. */
+	uint8_t dma_enable;
+
+	/** 1 if dedicated Tx FIFOs are enabled, 0 otherwise. */
+	uint8_t en_multiple_tx_fifo;
+
+	/** Set to 1 if multiple packets of a high-bandwidth transfer is in
+	 * process of being queued */
+	uint8_t queuing_high_bandwidth;
+
+	/** Hardware Configuration -- stored here for convenience.*/
+	hwcfg1_data_t hwcfg1;
+	hwcfg2_data_t hwcfg2;
+	hwcfg3_data_t hwcfg3;
+	hwcfg4_data_t hwcfg4;
+
+	/** The operational State, during transations
+	 * (a_host>>a_peripherial and b_device=>b_host) this may not
+	 * match the core but allows the software to determine
+	 * transitions.
+	 */
+	uint8_t op_state;
+
+	/**
+	 * Set to 1 if the HCD needs to be restarted on a session request
+	 * interrupt. This is required if no connector ID status change has
+	 * occurred since the HCD was last disconnected.
+	 */
+	uint8_t restart_hcd_on_session_req;
+
+	/** HCD callbacks */
+	/** A-Device is a_host */
+#define A_HOST		(1)
+	/** A-Device is a_suspend */
+#define A_SUSPEND	(2)
+	/** A-Device is a_peripherial */
+#define A_PERIPHERAL	(3)
+	/** B-Device is operating as a Peripheral. */
+#define B_PERIPHERAL	(4)
+	/** B-Device is operating as a Host. */
+#define B_HOST		(5)
+
+	/** HCD callbacks */
+	struct dwc_otg_cil_callbacks *hcd_cb;
+	/** PCD callbacks */
+	struct dwc_otg_cil_callbacks *pcd_cb;
+
+	/** Device mode Periodic Tx FIFO Mask */
+	uint32_t p_tx_msk;
+	/** Device mode Periodic Tx FIFO Mask */
+	uint32_t tx_msk;
+
+#ifdef DEBUG
+	uint32_t		start_hcchar_val[MAX_EPS_CHANNELS];
+
+	hc_xfer_info_t		hc_xfer_info[MAX_EPS_CHANNELS];
+	struct timer_list	hc_xfer_timer[MAX_EPS_CHANNELS];
+
+	uint32_t		hfnum_7_samples;
+	uint64_t		hfnum_7_frrem_accum;
+	uint32_t		hfnum_0_samples;
+	uint64_t		hfnum_0_frrem_accum;
+	uint32_t		hfnum_other_samples;
+	uint64_t		hfnum_other_frrem_accum;
+#endif
+
+	struct work_struct vbus_work;
+	uint8_t vbus_state;
+} dwc_otg_core_if_t;
+
+/*
+ * The following functions support initialization of the CIL driver component
+ * and the DWC_otg controller.
+ */
+extern dwc_otg_core_if_t *dwc_otg_cil_init(const uint32_t *_reg_base_addr,
+        dwc_otg_core_params_t *_core_params);
+extern void dwc_otg_cil_remove(dwc_otg_core_if_t *_core_if);
+extern void dwc_otg_core_init(dwc_otg_core_if_t *_core_if);
+extern void dwc_otg_core_host_init(dwc_otg_core_if_t *_core_if);
+extern void dwc_otg_core_dev_init(dwc_otg_core_if_t *_core_if);
+extern void dwc_otg_enable_global_interrupts( dwc_otg_core_if_t *_core_if );
+extern void dwc_otg_disable_global_interrupts( dwc_otg_core_if_t *_core_if );
+
+/** @name Device CIL Functions
+ * The following functions support managing the DWC_otg controller in device
+ * mode.
+ */
+/**@{*/
+extern void dwc_otg_wakeup(dwc_otg_core_if_t *_core_if);
+extern void dwc_otg_read_setup_packet (dwc_otg_core_if_t *_core_if, uint32_t *_dest);
+extern uint32_t dwc_otg_get_frame_number(dwc_otg_core_if_t *_core_if);
+extern void dwc_otg_ep0_activate(dwc_otg_core_if_t *_core_if, dwc_ep_t *_ep);
+extern void dwc_otg_ep_activate(dwc_otg_core_if_t *_core_if, dwc_ep_t *_ep);
+extern void dwc_otg_ep_deactivate(dwc_otg_core_if_t *_core_if, dwc_ep_t *_ep);
+extern void dwc_otg_ep_start_transfer(dwc_otg_core_if_t *_core_if, dwc_ep_t *_ep);
+extern void dwc_otg_ep0_start_transfer(dwc_otg_core_if_t *_core_if, dwc_ep_t *_ep);
+extern void dwc_otg_ep0_continue_transfer(dwc_otg_core_if_t *_core_if, dwc_ep_t *_ep);
+extern void dwc_otg_ep_write_packet(dwc_otg_core_if_t *_core_if, dwc_ep_t *_ep, int _dma);
+extern void dwc_otg_ep_set_stall(dwc_otg_core_if_t *_core_if, dwc_ep_t *_ep);
+extern void dwc_otg_ep_clear_stall(dwc_otg_core_if_t *_core_if, dwc_ep_t *_ep);
+extern void dwc_otg_enable_device_interrupts(dwc_otg_core_if_t *_core_if);
+extern void dwc_otg_dump_dev_registers(dwc_otg_core_if_t *_core_if);
+/**@}*/
+
+/** @name Host CIL Functions
+ * The following functions support managing the DWC_otg controller in host
+ * mode.
+ */
+/**@{*/
+extern void dwc_otg_hc_init(dwc_otg_core_if_t *_core_if, dwc_hc_t *_hc);
+extern void dwc_otg_hc_halt(dwc_otg_core_if_t *_core_if,
+                            dwc_hc_t *_hc,
+                            dwc_otg_halt_status_e _halt_status);
+extern void dwc_otg_hc_cleanup(dwc_otg_core_if_t *_core_if, dwc_hc_t *_hc);
+extern void dwc_otg_hc_start_transfer(dwc_otg_core_if_t *_core_if, dwc_hc_t *_hc);
+extern int dwc_otg_hc_continue_transfer(dwc_otg_core_if_t *_core_if, dwc_hc_t *_hc);
+extern void dwc_otg_hc_do_ping(dwc_otg_core_if_t *_core_if, dwc_hc_t *_hc);
+extern void dwc_otg_hc_write_packet(dwc_otg_core_if_t *_core_if, dwc_hc_t *_hc);
+extern void dwc_otg_enable_host_interrupts(dwc_otg_core_if_t *_core_if);
+extern void dwc_otg_disable_host_interrupts(dwc_otg_core_if_t *_core_if);
+
+/**
+ * This function Reads HPRT0 in preparation to modify.	It keeps the
+ * WC bits 0 so that if they are read as 1, they won't clear when you
+ * write it back
+ */
+static inline uint32_t dwc_otg_read_hprt0(dwc_otg_core_if_t *_core_if)
+{
+	hprt0_data_t hprt0;
+	hprt0.d32 = dwc_read_reg32(_core_if->host_if->hprt0);
+	hprt0.b.prtena = 0;
+	hprt0.b.prtconndet = 0;
+	hprt0.b.prtenchng = 0;
+	hprt0.b.prtovrcurrchng = 0;
+	return hprt0.d32;
+}
+
+extern void dwc_otg_dump_host_registers(dwc_otg_core_if_t *_core_if);
+/**@}*/
+
+/** @name Common CIL Functions
+ * The following functions support managing the DWC_otg controller in either
+ * device or host mode.
+ */
+/**@{*/
+
+extern void dwc_otg_read_packet(dwc_otg_core_if_t *core_if,
+                                uint8_t *dest,
+                                uint16_t bytes);
+
+extern void dwc_otg_dump_global_registers(dwc_otg_core_if_t *_core_if);
+
+extern void dwc_otg_flush_tx_fifo( dwc_otg_core_if_t *_core_if,
+                                   const int _num );
+extern void dwc_otg_flush_rx_fifo( dwc_otg_core_if_t *_core_if );
+extern void dwc_otg_core_reset( dwc_otg_core_if_t *_core_if );
+
+/**
+ * This function returns the Core Interrupt register.
+ */
+static inline uint32_t dwc_otg_read_core_intr(dwc_otg_core_if_t *_core_if)
+{
+	return (dwc_read_reg32(&_core_if->core_global_regs->gintsts) &
+	        dwc_read_reg32(&_core_if->core_global_regs->gintmsk));
+}
+
+/**
+ * This function returns the OTG Interrupt register.
+ */
+static inline uint32_t dwc_otg_read_otg_intr (dwc_otg_core_if_t *_core_if)
+{
+	return (dwc_read_reg32 (&_core_if->core_global_regs->gotgint));
+}
+
+/**
+ * This function reads the Device All Endpoints Interrupt register and
+ * returns the IN endpoint interrupt bits.
+ */
+static inline uint32_t dwc_otg_read_dev_all_in_ep_intr(dwc_otg_core_if_t *_core_if)
+{
+	uint32_t v;
+	v = dwc_read_reg32(&_core_if->dev_if->dev_global_regs->daint) &
+	    dwc_read_reg32(&_core_if->dev_if->dev_global_regs->daintmsk);
+	return (v & 0xffff);
+
+}
+
+/**
+ * This function reads the Device All Endpoints Interrupt register and
+ * returns the OUT endpoint interrupt bits.
+ */
+static inline uint32_t dwc_otg_read_dev_all_out_ep_intr(dwc_otg_core_if_t *_core_if)
+{
+	uint32_t v;
+	v = dwc_read_reg32(&_core_if->dev_if->dev_global_regs->daint) &
+	    dwc_read_reg32(&_core_if->dev_if->dev_global_regs->daintmsk);
+	return ((v & 0xffff0000) >> 16);
+}
+
+/**
+ * This function returns the Device IN EP Interrupt register
+ */
+static inline uint32_t dwc_otg_read_dev_in_ep_intr(dwc_otg_core_if_t *_core_if,
+        dwc_ep_t *_ep)
+{
+	dwc_otg_dev_if_t *dev_if = _core_if->dev_if;
+	uint32_t v, msk, emp;
+	msk = dwc_read_reg32(&dev_if->dev_global_regs->diepmsk);
+	emp = dwc_read_reg32(&dev_if->dev_global_regs->dtknqr4_fifoemptymsk);
+	msk |= ((emp >> _ep->num) & 0x1) << 7;
+	v = dwc_read_reg32(&dev_if->in_ep_regs[_ep->num]->diepint) & msk;
+	/*
+		dwc_otg_dev_if_t *dev_if = _core_if->dev_if;
+		uint32_t v;
+		v = dwc_read_reg32(&dev_if->in_ep_regs[_ep->num]->diepint) &
+				dwc_read_reg32(&dev_if->dev_global_regs->diepmsk);
+	*/
+	return v;
+}
+/**
+ * This function returns the Device OUT EP Interrupt register
+ */
+static inline uint32_t dwc_otg_read_dev_out_ep_intr(dwc_otg_core_if_t *_core_if,
+        dwc_ep_t *_ep)
+{
+	dwc_otg_dev_if_t *dev_if = _core_if->dev_if;
+	uint32_t v;
+	v = dwc_read_reg32( &dev_if->out_ep_regs[_ep->num]->doepint) &
+	    dwc_read_reg32(&dev_if->dev_global_regs->doepmsk);
+	return v;
+}
+
+/**
+ * This function returns the Host All Channel Interrupt register
+ */
+static inline uint32_t dwc_otg_read_host_all_channels_intr (dwc_otg_core_if_t *_core_if)
+{
+	return (dwc_read_reg32 (&_core_if->host_if->host_global_regs->haint));
+}
+
+static inline uint32_t dwc_otg_read_host_channel_intr (dwc_otg_core_if_t *_core_if, dwc_hc_t *_hc)
+{
+	return (dwc_read_reg32 (&_core_if->host_if->hc_regs[_hc->hc_num]->hcint));
+}
+
+
+/**
+ * This function returns the mode of the operation, host or device.
+ *
+ * @return 0 - Device Mode, 1 - Host Mode
+ */
+static inline uint32_t dwc_otg_mode(dwc_otg_core_if_t *_core_if)
+{
+	return (dwc_read_reg32( &_core_if->core_global_regs->gintsts ) & 0x1);
+}
+
+static inline uint8_t dwc_otg_is_device_mode(dwc_otg_core_if_t *_core_if)
+{
+	return (dwc_otg_mode(_core_if) != DWC_HOST_MODE);
+}
+static inline uint8_t dwc_otg_is_host_mode(dwc_otg_core_if_t *_core_if)
+{
+	return (dwc_otg_mode(_core_if) == DWC_HOST_MODE);
+}
+
+extern int32_t dwc_otg_handle_common_intr( dwc_otg_core_if_t *_core_if );
+
+
+/**@}*/
+
+/**
+ * DWC_otg CIL callback structure.	This structure allows the HCD and
+ * PCD to register functions used for starting and stopping the PCD
+ * and HCD for role change on for a DRD.
+ */
+typedef struct dwc_otg_cil_callbacks
+{
+	/** Start function for role change */
+	int (*start) (void *_p);
+	/** Stop Function for role change */
+	int (*stop) (void *_p);
+	/** Disconnect Function for role change */
+	int (*disconnect) (void *_p);
+	/** Resume/Remote wakeup Function */
+	int (*resume_wakeup) (void *_p);
+	/** Suspend function */
+	int (*suspend) (void *_p);
+	/** Session Start (SRP) */
+	int (*session_start) (void *_p);
+	/** Pointer passed to start() and stop() */
+	void *p;
+} dwc_otg_cil_callbacks_t;
+
+extern void dwc_otg_cil_register_pcd_callbacks( dwc_otg_core_if_t *_core_if,
+        dwc_otg_cil_callbacks_t *_cb,
+        void *_p);
+extern void dwc_otg_cil_register_hcd_callbacks( dwc_otg_core_if_t *_core_if,
+        dwc_otg_cil_callbacks_t *_cb,
+        void *_p);
+#endif
Index: linux-2.6.29/drivers/usb/dwc_otg/dwc_otg_cil_intr.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/usb/dwc_otg/dwc_otg_cil_intr.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,725 @@
+/* ==========================================================================
+ * $File: //dwh/usb_iip/dev/software/otg_ipmate/linux/drivers/dwc_otg_cil_intr.c $
+ * $Revision: #7 $
+ * $Date: 2005/11/02 $
+ * $Change: 553126 $
+ *
+ * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
+ * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto. You are permitted to use and
+ * redistribute this Software in source and binary forms, with or without
+ * modification, provided that redistributions of source code must retain this
+ * notice. You may not view, use, disclose, copy or distribute this file or
+ * any information contained herein except pursuant to this license grant from
+ * Synopsys. If you do not agree with this notice, including the disclaimer
+ * below, then you are not authorized to use the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================== */
+
+/** @file
+ *
+ * The Core Interface Layer provides basic services for accessing and
+ * managing the DWC_otg hardware. These services are used by both the
+ * Host Controller Driver and the Peripheral Controller Driver.
+ *
+ * This file contains the Common Interrupt handlers.
+ */
+#include "dwc_otg_plat.h"
+#include "dwc_otg_regs.h"
+#include "dwc_otg_cil.h"
+#include "tcc_usb_def.h"
+#include "tcc_usb_phy.h"
+
+/* For Signature */
+#define DWC_OTG_CIL_INTR_SIGNATURE			'D','W','C','_','O','T','G','_','C','I','L','_','I','N','T','R','_'
+#define DWC_OTG_CIL_INTR_VERSION			'V','2','.','0','0','2'
+static const unsigned char DWC_OTG_CIL_INTR_C_Version[] =
+    {SIGBYAHONG, DWC_OTG_CIL_INTR_SIGNATURE, SIGN_OS ,SIGN_CHIPSET, DWC_OTG_CIL_INTR_VERSION, 0};
+
+const unsigned char* dwc_otg_cil_intr_get_version(void)
+{
+	return DWC_OTG_CIL_INTR_C_Version;
+}
+
+#ifdef DEBUG
+inline const char *op_state_str( dwc_otg_core_if_t *_core_if )
+{
+	return (_core_if->op_state==A_HOST?"a_host":
+	        (_core_if->op_state==A_SUSPEND?"a_suspend":
+	         (_core_if->op_state==A_PERIPHERAL?"a_peripheral":
+	          (_core_if->op_state==B_PERIPHERAL?"b_peripheral":
+	           (_core_if->op_state==B_HOST?"b_host":
+	            "unknown")))));
+}
+#endif
+
+/** This function will log a debug message
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ */
+int32_t dwc_otg_handle_mode_mismatch_intr (dwc_otg_core_if_t *_core_if)
+{
+	gintsts_data_t gintsts;
+	DWC_WARN("Mode Mismatch Interrupt: currently in %s mode\n",
+	         dwc_otg_mode(_core_if) ? "Host" : "Device");
+
+	/* Clear interrupt */
+	gintsts.d32 = 0;
+	gintsts.b.modemismatch = 1;
+	dwc_write_reg32 (&_core_if->core_global_regs->gintsts, gintsts.d32);
+	return 1;
+}
+
+/** Start the HCD.  Helper function for using the HCD callbacks.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ */
+static inline void hcd_start( dwc_otg_core_if_t *_core_if )
+{
+	if (_core_if->hcd_cb && _core_if->hcd_cb->start) {
+		_core_if->hcd_cb->start( _core_if->hcd_cb->p );
+	}
+}
+/** Stop the HCD.  Helper function for using the HCD callbacks.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ */
+static inline void hcd_stop( dwc_otg_core_if_t *_core_if )
+{
+	if (_core_if->hcd_cb && _core_if->hcd_cb->stop) {
+		_core_if->hcd_cb->stop( _core_if->hcd_cb->p );
+	}
+}
+/** Disconnect the HCD.  Helper function for using the HCD callbacks.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ */
+static inline void hcd_disconnect( dwc_otg_core_if_t *_core_if )
+{
+	if (_core_if->hcd_cb && _core_if->hcd_cb->disconnect) {
+		_core_if->hcd_cb->disconnect( _core_if->hcd_cb->p );
+	}
+}
+/** Inform the HCD the a New Session has begun.  Helper function for
+ * using the HCD callbacks.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ */
+static inline void hcd_session_start( dwc_otg_core_if_t *_core_if )
+{
+	if (_core_if->hcd_cb && _core_if->hcd_cb->session_start) {
+		_core_if->hcd_cb->session_start( _core_if->hcd_cb->p );
+	}
+}
+
+/** Start the PCD.  Helper function for using the PCD callbacks.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ */
+static inline void pcd_start( dwc_otg_core_if_t *_core_if )
+{
+	if (_core_if->pcd_cb && _core_if->pcd_cb->start ) {
+		_core_if->pcd_cb->start( _core_if->pcd_cb->p );
+	}
+}
+/** Stop the PCD.  Helper function for using the PCD callbacks.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ */
+static inline void pcd_stop( dwc_otg_core_if_t *_core_if )
+{
+	if (_core_if->pcd_cb && _core_if->pcd_cb->stop ) {
+		_core_if->pcd_cb->stop( _core_if->pcd_cb->p );
+	}
+}
+/** Suspend the PCD.  Helper function for using the PCD callbacks.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ */
+static inline void pcd_suspend( dwc_otg_core_if_t *_core_if )
+{
+	if (_core_if->pcd_cb && _core_if->pcd_cb->suspend ) {
+		_core_if->pcd_cb->suspend( _core_if->pcd_cb->p );
+	}
+}
+/** Resume the PCD.  Helper function for using the PCD callbacks.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ */
+static inline void pcd_resume( dwc_otg_core_if_t *_core_if )
+{
+	if (_core_if->pcd_cb && _core_if->pcd_cb->resume_wakeup ) {
+		_core_if->pcd_cb->resume_wakeup( _core_if->pcd_cb->p );
+	}
+}
+
+/**
+ * This function handles the OTG Interrupts. It reads the OTG
+ * Interrupt Register (GOTGINT) to determine what interrupt has
+ * occurred.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ */
+int32_t dwc_otg_handle_otg_intr(dwc_otg_core_if_t *_core_if)
+{
+	dwc_otg_core_global_regs_t *global_regs = _core_if->core_global_regs;
+	gotgint_data_t gotgint;
+	gotgctl_data_t gotgctl;
+	gintmsk_data_t gintmsk;
+
+	gotgint.d32 = dwc_read_reg32( &global_regs->gotgint);
+	gotgctl.d32 = dwc_read_reg32( &global_regs->gotgctl);
+	DWC_DEBUGPL(DBG_CIL, "++OTG Interrupt gotgint=%0x [%s]\n", gotgint.d32,
+	            op_state_str(_core_if));
+	//DWC_DEBUGPL(DBG_CIL, "gotgctl=%08x\n", gotgctl.d32 );
+
+	if (gotgint.b.sesenddet) {
+		DWC_DEBUGPL(DBG_ANY, " ++OTG Interrupt: "
+		            "Session End Detected++ (%s)\n",
+		            op_state_str(_core_if));
+		gotgctl.d32 = dwc_read_reg32( &global_regs->gotgctl);
+
+		if (_core_if->op_state == B_HOST) {
+			pcd_start( _core_if );
+			_core_if->op_state = B_PERIPHERAL;
+		} else {
+			/* If not B_HOST and Device HNP still set. HNP
+			* Did not succeed!*/
+			if (gotgctl.b.devhnpen) {
+				DWC_DEBUGPL(DBG_ANY, "Session End Detected\n");
+				DWC_ERROR( "Device Not Connected/Responding!\n" );
+			}
+
+			/* If Session End Detected the B-Cable has
+			* been disconnected. */
+			/* Reset PCD and Gadget driver to a
+			* clean state. */
+			pcd_stop(_core_if);
+
+			////////////////////////////////////////////////////////////////////
+			//AlenOh's comment
+			// pcd_stop() can't perpectly adjusts OTG LINK.
+			// It causes next USB connection failure.
+			// OTG LINK RESET can perpectly adjusts itself.
+			// For SRP, USBPHY should stay in reset state during OTG LINK RESET
+			USBPHY_SetMode(USBPHY_MODE_RESET);
+			dwc_otg_core_init(_core_if);
+			dwc_otg_enable_global_interrupts(_core_if);
+			pcd_start( _core_if );
+			USBPHY_SetMode(USBPHY_MODE_DEVICE);
+			////////////////////////////////////////////////////////////////////
+		}
+		gotgctl.d32 = 0;
+		gotgctl.b.devhnpen = 1;
+		dwc_modify_reg32( &global_regs->gotgctl, gotgctl.d32, 0);
+		//printk("Session End Detected\n");
+	}
+	if (gotgint.b.sesreqsucstschng) {
+		DWC_DEBUGPL(DBG_ANY, " ++OTG Interrupt: "
+		            "Session Reqeust Success Status Change++\n");
+		gotgctl.d32 = dwc_read_reg32( &global_regs->gotgctl);
+		if (gotgctl.b.sesreqscs) {
+			if ((_core_if->core_params->phy_type == DWC_PHY_TYPE_PARAM_FS) &&
+			        (_core_if->core_params->i2c_enable)) {
+				_core_if->srp_success = 1;
+			}
+			else {
+				pcd_resume( _core_if );
+				/* Clear Session Request */
+				gotgctl.d32 = 0;
+				gotgctl.b.sesreq = 1;
+				dwc_modify_reg32( &global_regs->gotgctl,
+				                  gotgctl.d32, 0);
+			}
+		}
+	}
+	if (gotgint.b.hstnegsucstschng) {
+		/* Print statements during the HNP interrupt handling
+		* can cause it to fail.*/
+		gotgctl.d32 = dwc_read_reg32(&global_regs->gotgctl);
+		if (gotgctl.b.hstnegscs) {
+			if (dwc_otg_is_host_mode(_core_if) ) {
+				_core_if->op_state = B_HOST;
+				/*
+				* Need to disable SOF interrupt immediately.
+				* When switching from device to host, the PCD
+				* interrupt handler won't handle the
+				* interrupt if host mode is already set. The
+				* HCD interrupt handler won't get called if
+				* the HCD state is HALT. This means that the
+				* interrupt does not get handled and Linux
+				* complains loudly.
+				*/
+				gintmsk.d32 = 0;
+				gintmsk.b.sofintr = 1;
+				dwc_modify_reg32(&global_regs->gintmsk,
+				                 gintmsk.d32, 0);
+				pcd_stop(_core_if);
+				/*
+				* Initialize the Core for Host mode.
+				*/
+				hcd_start( _core_if );
+				_core_if->op_state = B_HOST;
+			}
+		} else {
+			gotgctl.d32 = 0;
+			gotgctl.b.hnpreq = 1;
+			gotgctl.b.devhnpen = 1;
+			dwc_modify_reg32( &global_regs->gotgctl,
+			                  gotgctl.d32, 0);
+			DWC_DEBUGPL( DBG_ANY, "HNP Failed\n");
+			DWC_ERROR( "Device Not Connected/Responding\n" );
+		}
+	}
+	if (gotgint.b.hstnegdet) {
+		/* The disconnect interrupt is set at the same time as
+		* Host Negotiation Detected.  During the mode
+		* switch all interrupts are cleared so the disconnect
+		* interrupt handler will not get executed.
+		*/
+		DWC_DEBUGPL(DBG_ANY, " ++OTG Interrupt: "
+		            "Host Negotiation Detected++ (%s)\n",
+		            (dwc_otg_is_host_mode(_core_if)?"Host":"Device"));
+		if (dwc_otg_is_device_mode(_core_if)) {
+			DWC_DEBUGPL(DBG_ANY, "a_suspend->a_peripheral (%d)\n",_core_if->op_state);
+			hcd_disconnect( _core_if );
+			pcd_start( _core_if );
+			_core_if->op_state = A_PERIPHERAL;
+		} else {
+			/*
+			* Need to disable SOF interrupt immediately. When
+			* switching from device to host, the PCD interrupt
+			* handler won't handle the interrupt if host mode is
+			* already set. The HCD interrupt handler won't get
+			* called if the HCD state is HALT. This means that
+			* the interrupt does not get handled and Linux
+			* complains loudly.
+			*/
+			gintmsk.d32 = 0;
+			gintmsk.b.sofintr = 1;
+			dwc_modify_reg32(&global_regs->gintmsk,
+			                 gintmsk.d32, 0);
+			pcd_stop( _core_if );
+			hcd_start( _core_if );
+			_core_if->op_state = A_HOST;
+		}
+	}
+	if (gotgint.b.adevtoutchng) {
+		DWC_DEBUGPL(DBG_ANY, " ++OTG Interrupt: "
+		            "A-Device Timeout Change++\n");
+	}
+	if (gotgint.b.debdone) {
+		DWC_DEBUGPL(DBG_ANY, " ++OTG Interrupt: "
+		            "Debounce Done++\n");
+	}
+
+	/* Clear GOTGINT */
+	dwc_write_reg32 (&_core_if->core_global_regs->gotgint, gotgint.d32);
+
+	return 1;
+}
+
+/**
+ * This function handles the Connector ID Status Change Interrupt.  It
+ * reads the OTG Interrupt Register (GOTCTL) to determine whether this
+ * is a Device to Host Mode transition or a Host Mode to Device
+ * Transition.
+ *
+ * This only occurs when the cable is connected/removed from the PHY
+ * connector.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ */
+int32_t dwc_otg_handle_conn_id_status_change_intr(dwc_otg_core_if_t *_core_if)
+{
+	uint32_t count = 0;
+
+	gintsts_data_t gintsts = { .d32 = 0 };
+	gintmsk_data_t gintmsk = { .d32 = 0 };
+	gotgctl_data_t gotgctl = { .d32 = 0 };
+
+	/*
+	 * Need to disable SOF interrupt immediately. If switching from device
+	 * to host, the PCD interrupt handler won't handle the interrupt if
+	 * host mode is already set. The HCD interrupt handler won't get
+	 * called if the HCD state is HALT. This means that the interrupt does
+	 * not get handled and Linux complains loudly.
+	 */
+	gintmsk.b.sofintr = 1;
+	dwc_modify_reg32(&_core_if->core_global_regs->gintmsk, gintmsk.d32, 0);
+
+	DWC_DEBUGPL(DBG_CIL, " ++Connector ID Status Change Interrupt++  (%s)\n",
+	            (dwc_otg_is_host_mode(_core_if)?"Host":"Device"));
+	gotgctl.d32 = dwc_read_reg32(&_core_if->core_global_regs->gotgctl);
+	DWC_DEBUGPL(DBG_CIL, "gotgctl=%0x\n", gotgctl.d32);
+	DWC_DEBUGPL(DBG_CIL, "gotgctl.b.conidsts=%d\n", gotgctl.b.conidsts);
+
+	/* B-Device connector (Device Mode) */
+	if (gotgctl.b.conidsts) {
+		/* Wait for switch to device mode. */
+		while (!dwc_otg_is_device_mode(_core_if) ) {
+			DWC_PRINT("Waiting for Peripheral Mode, Mode=%s\n",
+			          (dwc_otg_is_host_mode(_core_if)?"Host":"Peripheral"));
+			MDELAY(100);
+			if (++count > 10000) *(uint32_t*)NULL=0;
+		}
+		printk("ID change ISR : Device\n");
+		_core_if->op_state = B_PERIPHERAL;
+		dwc_otg_core_init(_core_if);
+		dwc_otg_enable_global_interrupts(_core_if);
+		pcd_start( _core_if );
+	} else {
+		/* A-Device connector (Host Mode) */
+		while (!dwc_otg_is_host_mode(_core_if) ) {
+			DWC_PRINT("Waiting for Host Mode, Mode=%s\n",
+			          (dwc_otg_is_host_mode(_core_if)?"Host":"Peripheral"));
+			MDELAY(100);
+			if (++count > 10000) *(uint32_t*)NULL=0;
+		}
+		printk("ID change ISR : Host\n");
+		_core_if->op_state = A_HOST;
+		/*
+		 * Initialize the Core for Host mode.
+		 */
+		dwc_otg_core_init(_core_if);
+		dwc_otg_enable_global_interrupts(_core_if);
+		hcd_start( _core_if );
+	}
+
+	/* Set flag and clear interrupt */
+	gintsts.b.conidstschng = 1;
+	dwc_write_reg32 (&_core_if->core_global_regs->gintsts, gintsts.d32);
+
+	return 1;
+}
+
+/**
+ * This interrupt indicates that a device is initiating the Session
+ * Request Protocol to request the host to turn on bus power so a new
+ * session can begin. The handler responds by turning on bus power. If
+ * the DWC_otg controller is in low power mode, the handler brings the
+ * controller out of low power mode before turning on bus power.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ */
+int32_t dwc_otg_handle_session_req_intr( dwc_otg_core_if_t *_core_if )
+{
+	gintsts_data_t gintsts;
+#ifndef DWC_HOST_ONLY
+
+	DWC_DEBUGPL(DBG_ANY, "++Session Request Interrupt++\n");
+
+	if (dwc_otg_is_device_mode(_core_if) ) {
+		DWC_PRINT("SRP: Device mode\n");
+	} else {
+		/* Turn on the port power bit. */
+		_core_if->vbus_state = 1;
+		schedule_work(&_core_if->vbus_work);
+		DWC_PRINT("SRP: Host mode\n");
+
+		/* Start the Connection timer. So a message can be displayed
+		* if connect does not occur within 10 seconds. */
+		hcd_session_start( _core_if );
+	}
+#endif
+
+	/* Clear interrupt */
+	gintsts.d32 = 0;
+	gintsts.b.sessreqintr = 1;
+	dwc_write_reg32 (&_core_if->core_global_regs->gintsts, gintsts.d32);
+
+	return 1;
+}
+
+/**
+ * This interrupt indicates that the DWC_otg controller has detected a
+ * resume or remote wakeup sequence. If the DWC_otg controller is in
+ * low power mode, the handler must brings the controller out of low
+ * power mode. The controller automatically begins resume
+ * signaling. The handler schedules a time to stop resume signaling.
+ */
+int32_t dwc_otg_handle_wakeup_detected_intr( dwc_otg_core_if_t *_core_if )
+{
+	gintsts_data_t gintsts;
+
+	DWC_DEBUGPL(DBG_ANY, "++Resume and Remote Wakeup Detected Interrupt++\n");
+
+	if (dwc_otg_is_device_mode(_core_if) ) {
+		dctl_data_t dctl = {.d32=0};
+		DWC_DEBUGPL(DBG_PCD, "DSTS=0x%0x\n",
+		            dwc_read_reg32( &_core_if->dev_if->dev_global_regs->dsts));
+#ifdef PARTIAL_POWER_DOWN
+		if (_core_if->hwcfg4.b.power_optimiz) {
+			pcgcctl_data_t power = {.d32=0};
+
+			power.d32 = dwc_read_reg32( _core_if->pcgcctl );
+			DWC_DEBUGPL(DBG_CIL, "PCGCCTL=%0x\n", power.d32);
+
+			power.b.stoppclk = 0;
+			dwc_write_reg32( _core_if->pcgcctl, power.d32);
+
+			power.b.pwrclmp = 0;
+			dwc_write_reg32( _core_if->pcgcctl, power.d32);
+
+			power.b.rstpdwnmodule = 0;
+			dwc_write_reg32( _core_if->pcgcctl, power.d32);
+		}
+#endif
+		/* Clear the Remote Wakeup Signalling */
+		dctl.b.rmtwkupsig = 1;
+		dwc_modify_reg32( &_core_if->dev_if->dev_global_regs->dctl,
+		                  dctl.d32, 0 );
+
+		if (_core_if->pcd_cb && _core_if->pcd_cb->resume_wakeup) {
+			_core_if->pcd_cb->resume_wakeup( _core_if->pcd_cb->p );
+		}
+
+	} else {
+		/*
+		* Clear the Resume after 70ms. (Need 20 ms minimum. Use 70 ms
+		* so that OPT tests pass with all PHYs).
+		*/
+		hprt0_data_t hprt0 = {.d32=0};
+		pcgcctl_data_t pcgcctl = {.d32=0};
+		/* Restart the Phy Clock */
+		pcgcctl.b.stoppclk = 1;
+		dwc_modify_reg32(_core_if->pcgcctl, pcgcctl.d32, 0);
+		UDELAY(10);
+
+		/* Now wait for 70 ms. */
+		hprt0.d32 = dwc_otg_read_hprt0( _core_if );
+		DWC_DEBUGPL(DBG_ANY,"Resume: HPRT0=%0x\n", hprt0.d32);
+		MDELAY(70);
+		hprt0.b.prtres = 0; /* Resume */
+		dwc_write_reg32(_core_if->host_if->hprt0, hprt0.d32);
+		DWC_DEBUGPL(DBG_ANY,"Clear Resume: HPRT0=%0x\n", dwc_read_reg32(_core_if->host_if->hprt0));
+	}
+
+	/* Clear interrupt */
+	gintsts.d32 = 0;
+	gintsts.b.wkupintr = 1;
+	dwc_write_reg32 (&_core_if->core_global_regs->gintsts, gintsts.d32);
+
+	return 1;
+}
+
+/**
+ * This interrupt indicates that a device has been disconnected from
+ * the root port.
+ */
+int32_t dwc_otg_handle_disconnect_intr( dwc_otg_core_if_t *_core_if)
+{
+	gintsts_data_t gintsts;
+
+	DWC_DEBUGPL(DBG_ANY, "++Disconnect Detected Interrupt++ (%s) %s\n",
+	            (dwc_otg_is_host_mode(_core_if)?"Host":"Device"),
+	            op_state_str(_core_if));
+
+	/** @todo Consolidate this if statement. */
+#ifndef DWC_HOST_ONLY
+	if (_core_if->op_state == B_HOST) {
+		/* If in device mode Disconnect and stop the HCD, then
+		 * start the PCD. */
+		hcd_disconnect( _core_if );
+		pcd_start( _core_if );
+		_core_if->op_state = B_PERIPHERAL;
+	} else if (dwc_otg_is_device_mode(_core_if)) {
+		gotgctl_data_t gotgctl = { .d32 = 0 };
+		gotgctl.d32 = dwc_read_reg32(&_core_if->core_global_regs->gotgctl);
+		if (gotgctl.b.hstsethnpen==1) {
+			/* Do nothing, if HNP in process the OTG
+			 * interrupt "Host Negotiation Detected"
+			 * interrupt will do the mode switch.
+			 */
+		} else if (gotgctl.b.devhnpen == 0) {
+			/* If in device mode Disconnect and stop the HCD, then
+			 * start the PCD. */
+			hcd_disconnect( _core_if );
+			pcd_start( _core_if );
+			_core_if->op_state = B_PERIPHERAL;
+		} else {
+			DWC_DEBUGPL(DBG_ANY,"!a_peripheral && !devhnpen\n");
+		}
+	} else {
+		if (_core_if->op_state == A_HOST) {
+			/* A-Cable still connected but device disconnected. */
+			hcd_disconnect( _core_if );
+		}
+	}
+#endif
+
+	gintsts.d32 = 0;
+	gintsts.b.disconnect = 1;
+	dwc_write_reg32 (&_core_if->core_global_regs->gintsts, gintsts.d32);
+	return 1;
+}
+/**
+ * This interrupt indicates that SUSPEND state has been detected on
+ * the USB.
+ *
+ * For HNP the USB Suspend interrupt signals the change from
+ * "a_peripheral" to "a_host".
+ *
+ * When power management is enabled the core will be put in low power
+ * mode.
+ */
+int32_t dwc_otg_handle_usb_suspend_intr(dwc_otg_core_if_t *_core_if )
+{
+	dsts_data_t dsts;
+	gintsts_data_t gintsts;
+
+	DWC_DEBUGPL(DBG_ANY,"USB SUSPEND\n");
+
+	if (dwc_otg_is_device_mode( _core_if ) ) {
+		/* Check the Device status register to determine if the Suspend
+		* state is active. */
+		dsts.d32 = dwc_read_reg32( &_core_if->dev_if->dev_global_regs->dsts);
+		DWC_DEBUGPL(DBG_PCD, "DSTS=0x%0x\n", dsts.d32);
+		DWC_DEBUGPL(DBG_PCD, "DSTS.Suspend Status=%d "
+		            "HWCFG4.power Optimize=%d\n",
+		            dsts.b.suspsts, _core_if->hwcfg4.b.power_optimiz);
+
+#ifdef PARTIAL_POWER_DOWN
+		/** @todo Add a module parameter for power management. */
+
+		if (dsts.b.suspsts && _core_if->hwcfg4.b.power_optimiz) {
+			pcgcctl_data_t power = {.d32=0};
+			DWC_DEBUGPL(DBG_CIL, "suspend\n");
+
+			power.b.pwrclmp = 1;
+			dwc_write_reg32( _core_if->pcgcctl, power.d32);
+
+			power.b.rstpdwnmodule = 1;
+			dwc_modify_reg32( _core_if->pcgcctl, 0, power.d32);
+
+			power.b.stoppclk = 1;
+			dwc_modify_reg32( _core_if->pcgcctl, 0, power.d32);
+
+		} else {
+			DWC_DEBUGPL(DBG_ANY,"disconnect?\n");
+		}
+#endif
+		/* PCD callback for suspend. */
+		pcd_suspend(_core_if);
+	} else {
+		if (_core_if->op_state == A_PERIPHERAL) {
+			DWC_DEBUGPL(DBG_ANY,"a_peripheral->a_host\n");
+			/* Clear the a_peripheral flag, back to a_host. */
+			pcd_stop( _core_if );
+			hcd_start( _core_if );
+			_core_if->op_state = A_HOST;
+		}
+	}
+
+	/* Clear interrupt */
+	gintsts.d32 = 0;
+	gintsts.b.usbsuspend = 1;
+	dwc_write_reg32( &_core_if->core_global_regs->gintsts, gintsts.d32);
+
+	return 1;
+}
+
+
+/**
+ * This function returns the Core Interrupt register.
+ */
+static inline uint32_t dwc_otg_read_common_intr(dwc_otg_core_if_t *_core_if)
+{
+	gintsts_data_t gintsts;
+	gintmsk_data_t gintmsk;
+	gintmsk_data_t gintmsk_common = {.d32=0};
+	gintmsk_common.b.wkupintr = 1;
+	gintmsk_common.b.sessreqintr = 1;
+	gintmsk_common.b.conidstschng = 1;
+	gintmsk_common.b.otgintr = 1;
+	gintmsk_common.b.modemismatch = 1;
+	gintmsk_common.b.disconnect = 1;
+	gintmsk_common.b.usbsuspend = 1;
+	/** @todo: The port interrupt occurs while in device
+	 * mode. Added code to CIL to clear the interrupt for now!
+	 */
+	gintmsk_common.b.portintr = 1;
+
+	gintsts.d32 = dwc_read_reg32(&_core_if->core_global_regs->gintsts);
+	gintmsk.d32 = dwc_read_reg32(&_core_if->core_global_regs->gintmsk);
+#ifdef DEBUG
+	/* if any common interrupts set */
+	if (gintsts.d32 & gintmsk_common.d32) {
+		DWC_DEBUGPL(DBG_ANY, "gintsts=%08x  gintmsk=%08x\n",
+		            gintsts.d32, gintmsk.d32);
+	}
+#endif
+
+	return ((gintsts.d32 & gintmsk.d32 ) & gintmsk_common.d32);
+
+}
+
+/**
+ * Common interrupt handler.
+ *
+ * The common interrupts are those that occur in both Host and Device mode.
+ * This handler handles the following interrupts:
+ * - Mode Mismatch Interrupt
+ * - Disconnect Interrupt
+ * - OTG Interrupt
+ * - Connector ID Status Change Interrupt
+ * - Session Request Interrupt.
+ * - Resume / Remote Wakeup Detected Interrupt.
+ *
+ */
+extern int32_t dwc_otg_handle_common_intr( dwc_otg_core_if_t *_core_if )
+{
+	int retval = 0;
+	gintsts_data_t gintsts;
+
+	gintsts.d32 = dwc_otg_read_common_intr(_core_if);
+
+	if (gintsts.b.modemismatch) {
+		retval |= dwc_otg_handle_mode_mismatch_intr( _core_if );
+	}
+	if (gintsts.b.otgintr) {
+		retval |= dwc_otg_handle_otg_intr( _core_if );
+	}
+	if (gintsts.b.conidstschng) {
+		retval |= dwc_otg_handle_conn_id_status_change_intr( _core_if );
+	}
+	if (gintsts.b.disconnect) {
+		retval |= dwc_otg_handle_disconnect_intr( _core_if );
+	}
+	if (gintsts.b.sessreqintr) {
+		retval |= dwc_otg_handle_session_req_intr( _core_if );
+	}
+	if (gintsts.b.wkupintr) {
+		retval |= dwc_otg_handle_wakeup_detected_intr( _core_if );
+	}
+	if (gintsts.b.usbsuspend) {
+		retval |= dwc_otg_handle_usb_suspend_intr( _core_if );
+	}
+	if (gintsts.b.portintr && dwc_otg_is_device_mode(_core_if)) {
+		/* The port interrupt occurs while in device mode with HPRT0
+		 * Port Enable/Disable.
+		 */
+		gintsts.d32 = 0;
+		gintsts.b.portintr = 1;
+		dwc_write_reg32(&_core_if->core_global_regs->gintsts,
+		                gintsts.d32);
+		retval |= 1;
+
+	}
+	return retval;
+}
Index: linux-2.6.29/drivers/usb/dwc_otg/dwc_otg_driver.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/usb/dwc_otg/dwc_otg_driver.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,1582 @@
+/* ==========================================================================
+ * $File: //dwh/usb_iip/dev/software/otg_ipmate/linux/drivers/dwc_otg_driver.c $
+ * $Revision: #12 $
+ * $Date: 2007/02/07 $
+ * $Change: 791271 $
+ *
+ * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
+ * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto. You are permitted to use and
+ * redistribute this Software in source and binary forms, with or without
+ * modification, provided that redistributions of source code must retain this
+ * notice. You may not view, use, disclose, copy or distribute this file or
+ * any information contained herein except pursuant to this license grant from
+ * Synopsys. If you do not agree with this notice, including the disclaimer
+ * below, then you are not authorized to use the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================== */
+
+/** @file
+ * The dwc_otg_driver module provides the initialization and cleanup entry
+ * points for the DWC_otg driver. This module will be dynamically installed
+ * after Linux is booted using the insmod command. When the module is
+ * installed, the dwc_otg_driver_init function is called. When the module is
+ * removed (using rmmod), the dwc_otg_driver_cleanup function is called.
+ *
+ * This module also defines a data structure for the dwc_otg_driver, which is
+ * used in conjunction with the standard ARM lm_device structure. These
+ * structures allow the OTG driver to comply with the standard Linux driver
+ * model in which devices and drivers are registered with a bus driver. This
+ * has the benefit that Linux can expose attributes of the driver and device
+ * in its special sysfs file system. Users can then read or write files in
+ * this file system to perform diagnostics on the driver components or the
+ * device.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/stat.h>	 /* permission constants */
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/kthread.h>
+
+#include <asm/io.h>
+#include <asm/sizes.h>
+
+//#include <mach/bsp.h>
+
+#ifdef _USE_ATTR_
+#include <asm/arch/lm.h>
+#include "dwc_otg_attr.h"
+#endif
+
+#include "dwc_otg_plat.h"
+#include "dwc_otg_driver.h"
+#include "dwc_otg_cil.h"
+#include "dwc_otg_pcd.h"
+#include "dwc_otg_hcd.h"
+
+#include "tcc_usb_phy.h"
+#include "tcc_usb_def.h"
+
+#include <mach/tcc_pca953x.h>
+#include <linux/tcc_pwm.h>
+#include <linux/tcc_ll.h>
+
+#define DWC_DRIVER_VERSION	"2.60a 22-NOV-2006"
+#define DWC_DRIVER_DESC		"HS OTG USB Controller driver"
+
+static const char dwc_driver_name[] = "dwc_otg";
+
+/* For Signature */
+#define DWC_OTG_DRIVER_SIGNATURE			'D','W','C','_','O','T','G','_','D','R','I','V','E','R','_'
+#define DWC_OTG_DRIVER_VERSION				'V','2','.','0','0','2'
+static const unsigned char DWC_OTG_DRIVER_C_Version[] =
+    {SIGBYAHONG, DWC_OTG_DRIVER_SIGNATURE, SIGN_OS ,SIGN_CHIPSET, DWC_OTG_DRIVER_VERSION, 0};
+
+/*-------------------------------------------------------------------------*/
+/* Encapsulate the module parameter settings */
+
+static dwc_otg_core_params_t dwc_otg_module_params = {
+	.opt = -1,
+	.otg_cap = -1,
+	.dma_enable = -1,
+	.dma_burst_size = -1,
+	.speed = -1,
+	.host_support_fs_ls_low_power = -1,
+	.host_ls_low_power_phy_clk = -1,
+	.enable_dynamic_fifo = -1,
+	.data_fifo_size = -1,
+	.dev_rx_fifo_size = -1,
+	.dev_nperio_tx_fifo_size = -1,
+	.dev_perio_tx_fifo_size =
+	{	/* dev_perio_tx_fifo_size_1 */
+		-1,
+		-1,
+		-1,
+		-1,
+		-1,
+		-1,
+		-1,
+		-1,
+		-1,
+		-1,
+		-1,
+		-1,
+		-1,
+		-1,
+		-1
+	},	/* 15 */
+	.host_rx_fifo_size = -1,
+	.host_nperio_tx_fifo_size = -1,
+	.host_perio_tx_fifo_size = -1,
+	.max_transfer_size = -1,
+	.max_packet_count = -1,
+	.host_channels = -1,
+	.dev_endpoints = -1,
+	.phy_type = -1,
+	.phy_utmi_width = -1,
+	.phy_ulpi_ddr = -1,
+	.phy_ulpi_ext_vbus = -1,
+	.i2c_enable = -1,
+	.ulpi_fs_ls = -1,
+	.ts_dline = -1,
+	.en_multiple_tx_fifo = -1,
+	.dev_tx_fifo_size = 
+	{	/* dev_tx_fifo_size */
+		-1,
+		-1,
+		-1,
+		-1,
+		-1,
+		-1,
+		-1,
+		-1,
+		-1,
+		-1,
+		-1,
+		-1,
+		-1,
+		-1,
+		-1
+	},	/* 15 */
+	.thr_ctl = -1,
+	.tx_thr_length = -1,
+	.rx_thr_length = -1,
+};
+
+#ifndef DWC_HOST_ONLY
+extern const unsigned char* dwc_otg_cil_get_version(void);
+extern const unsigned char* dwc_otg_cil_intr_get_version(void);
+extern const unsigned char* dwc_otg_pcd_get_version(void);
+extern const unsigned char* dwc_otg_pcd_intr_get_version(void);
+#endif
+static const char off_string[] = "off";
+static const char on_string[] = "on";
+static ssize_t show_hvbus(struct device_driver *_drv, char *_buf)
+{
+	return sprintf(_buf, "%s\n", "on");
+}
+static ssize_t set_hvbus(struct device_driver *_drv, const char *_buf,
+                         size_t _count)
+{
+	int rc = 0;
+	int len = _count;
+	char *cp = memchr(_buf, '\n', _count);
+	if (cp)
+		len = cp - _buf;
+
+	if (len == sizeof off_string - 1 && strncmp(_buf, off_string, len) == 0)
+	{
+		//gotgctl_data_t  gotgctl;
+		//gotgctl.d32 = dwc_read_reg32( &g_dwc_otg_device->core_if->core_global_regs->gotgctl);
+		//printk("hstsethnpen=%d\n",gotgctl.b.hstsethnpen);
+		TCC_DVBUS_Control(0);
+	}
+	else if (len == sizeof on_string - 1 && strncmp(_buf, on_string, len) == 0)
+		TCC_DVBUS_Control(1);
+	else
+		rc = -EINVAL;
+
+	return (rc < 0 ? rc : _count);
+}
+static DRIVER_ATTR(hvbus, S_IRUGO|S_IWUSR, show_hvbus, set_hvbus);
+
+/**
+ * This function shows the Driver Version.
+ */
+static ssize_t version_show(struct device_driver *dev, char *buf)
+{
+#ifdef DWC_HOST_ONLY
+	return snprintf(buf, sizeof(DWC_DRIVER_VERSION)+2,"%s\n",
+	                DWC_DRIVER_VERSION);
+#else
+	return snprintf(buf, PAGE_SIZE,"%s\n\t%s\n\t%s\n\t%s\n\t%s\n\t%s\n\t%s\n"
+	                ,DWC_DRIVER_VERSION
+	                ,DWC_OTG_DRIVER_C_Version
+	                ,dwc_otg_cil_get_version()
+	                ,dwc_otg_cil_intr_get_version()
+	                ,dwc_otg_pcd_get_version()
+	                ,dwc_otg_pcd_intr_get_version()
+	                ,USBPHY_GetVersion());
+#endif
+}
+static DRIVER_ATTR(version, S_IRUGO, version_show, NULL);
+
+/**
+ * Global Debug Level Mask.
+ */
+uint32_t g_dbg_lvl = DBG_HCD | DBG_HCDV | DBG_CILV | DBG_CIL;
+
+/**
+ * This function shows the driver Debug Level.
+ */
+static ssize_t dbg_level_show(struct device_driver *_drv, char *_buf)
+{
+	return sprintf(_buf, "0x%0x\n", g_dbg_lvl);
+}
+/**
+ * This function stores the driver Debug Level.
+ */
+static ssize_t dbg_level_store(struct device_driver *_drv, const char *_buf,
+                               size_t _count)
+{
+	g_dbg_lvl = simple_strtoul(_buf, NULL, 16);
+	return _count;
+}
+static DRIVER_ATTR(debuglevel, S_IRUGO|S_IWUSR, dbg_level_show, dbg_level_store);
+
+
+static void tcc_usb_link_reset(void)
+{
+	BITCLR(HwIOBUSCFG->HRSTEN0, HwIOBUSCFG_USB);
+	{
+		volatile unsigned int t=1000;
+		while (t-->0);
+	}
+	BITSET(HwIOBUSCFG->HRSTEN0, HwIOBUSCFG_USB);
+}
+
+//static void show_system_info(void)
+//{
+//	unsigned int cpu;
+//	unsigned int bus;
+//	unsigned int io_bus;
+//	cpu = tca_ckc_getcpu() / 10000;
+//	bus = tca_ckc_getbus() / 10000;
+//	io_bus = tca_ckc_getfbusctrl(CLKCTRL4) / 10000;
+//	printk("CPU:%d, BUS:%d, IOBUS:%d\n", cpu, bus, io_bus);
+//}
+
+static void tcc_set_vbus(dwc_otg_core_if_t *_core_if)
+{
+	hprt0_data_t hprt0;
+
+	TCC_DVBUS_Control((int)_core_if->vbus_state);
+	// wait the voltage to be stable
+
+	msleep_interruptible(100);
+
+	/* Control the port power bit. */
+	hprt0.d32 = dwc_otg_read_hprt0( _core_if );
+	hprt0.b.prtpwr = (unsigned)_core_if->vbus_state;
+	dwc_write_reg32(_core_if->host_if->hprt0, hprt0.d32);
+}
+
+static void tcc_vbus_work(struct work_struct *work)
+{
+	dwc_otg_core_if_t *core_if = container_of(work, dwc_otg_core_if_t, vbus_work);
+	tcc_set_vbus(core_if);
+}
+
+/**
+ * This function shows the file_storage gadget attach/detach status
+ */
+static ssize_t fsg_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	dwc_otg_device_t *dwc_otg_device = dev_get_otgdata(dev);
+	return sprintf(buf, "%d\n", dwc_otg_device->flagDeviceAttach);
+}
+static DEVICE_ATTR(fsg, S_IRUGO, fsg_show, NULL);
+
+#define DWC_SET_MODE
+#ifdef DWC_SET_MODE
+static ssize_t read_mode(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	dwc_otg_device_t *dwc_otg_device = dev_get_otgdata(dev);
+	return sprintf(buf, "%d\n", dwc_otg_device->flagMode);
+}
+static ssize_t set_mode(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	dwc_otg_device_t *dwc_otg_device = dev_get_otgdata(dev);
+	unsigned long mode;
+	mode = simple_strtoul(buf, (char **)NULL, 10);
+	dwc_otg_device->flagMode = (uint8_t)mode;
+	return count;
+}
+static DEVICE_ATTR(setmode, S_IRUSR|S_IWUSR, read_mode, set_mode);
+
+static int is_ID(uint8_t mode)
+{
+	int ret;
+	if (mode == 0) {
+		ret = 0;
+	} else if (mode == 1) {
+		ret = 1;
+	} else {
+		ret = (HwGPIO->GPADAT & Hw13);
+	}
+	return ret;
+}
+#endif
+
+/*
+ * OTG Power on/off control
+ * TODO: Handling DWC_HOST_ONLY/DWC_DEVICE_ONLY, 
+ *       this code only control DWC_DUAL_ROLE.
+ */
+static stpwrinfo pwrinfo = {PWR_STATUS_ON};
+static int otg_pwr_ctl(void *h_private, int cmd, void *p_out)
+{
+	dwc_otg_device_t *dwc_otg_device = (dwc_otg_device_t *)h_private;
+
+	switch (cmd) {
+	case PWR_CMD_OFF:
+		//printk("PWR_CMD_OFF command ==> [%d]\n", cmd);
+		if (pwrinfo.status == PWR_STATUS_OFF) {
+			return 0;
+		}
+		pwrinfo.status = PWR_STATUS_OFF;
+
+		dwc_otg_device->flagMode_backup = dwc_otg_device->flagMode;
+		
+		dwc_otg_device->flagMode = 1;
+		/* wait for change mode */
+		while (dwc_otg_device->flagID == 0) {
+			msleep_interruptible(200);
+		}
+		msleep_interruptible(200);
+
+		USBPHY_Off();
+
+		/* PWR_GP1 off.
+		 * Warning: OHCI can not work
+		 */
+		//tcc_pca953x_setup(PCA9538_U4_SLAVE_ADDR, PWR_GP1, OUTPUT, LOW, SET_DIRECTION|SET_VALUE);
+
+		break;
+	case PWR_CMD_ON:
+		//printk("PWR_CMD_ON command ==> [%d]\n", cmd);
+		if (pwrinfo.status == PWR_STATUS_ON) {
+			return 0;
+		}
+		pwrinfo.status = PWR_STATUS_ON;
+
+		USBPHY_On();
+
+		dwc_otg_device->flagMode = 1;
+		/* wait for change mode */
+		while (dwc_otg_device->flagID == 0) {
+			msleep_interruptible(200);
+		}
+		msleep_interruptible(200);
+
+		dwc_otg_device->flagMode = dwc_otg_device->flagMode_backup;
+
+		break;
+	case PWR_CMD_GETSTATUS:
+		//printk("PWR_CMD_GETSTATUS command ==> [%d], status:[%d]\n", cmd, pwrinfo.status);
+		memcpy(p_out, &pwrinfo, sizeof(stpwrinfo));
+		break;
+	default:
+		//printk("unknown pwr command !!! ==> [%d]\n", cmd);
+		return -EINVAL;
+		break;
+	}
+
+    return 0;
+}
+
+static int tcc_usb_thread(void* _dwc_otg_device)
+{
+	dwc_otg_device_t *dwc_otg_device = _dwc_otg_device;
+
+	DWC_DEBUGPL(DBG_ANY, "%s starts...\n", __func__);
+
+#if defined(DWC_HOST_ONLY)
+#define IsID()			( 0 )
+#elif defined(DWC_DEVICE_ONLY)
+#define IsID()			( 1 )
+#else
+	//*********************************
+	//		GPIO_A13 for ID pin
+	//*********************************
+	// Port Configuration : GPIO_A13 -> GPIO
+	BITCSET(HwGPIO->GPAFN1, (0xF/*mask*/)<<20, (0/*GPIO*/)<<20);
+	// Direction : input mode
+	BITCLR(HwGPIO->GPAEN ,Hw13);
+	// Pull UP/DOWN : pull-up only
+	BITCSET(HwGPIO->GPAPD0, 0x3/*mask*/<<26, 0x1/*pull-up only*/<<26);
+	
+#if defined(DWC_SET_MODE)
+#define IsID()			is_ID(dwc_otg_device->flagMode)
+#else
+#define IsID()			( HwGPIO->GPADAT & Hw13 )
+#endif
+
+#endif
+
+	//**********************************
+	//		EINT0 -> USB_VBON
+	//**********************************
+	BITCSET(HwGPIO->EINTSEL0, (Hw6-Hw0), 62);
+	dwc_otg_device->flagDeviceVBUS = 0;
+#define IsUSBDET()		( HwPIC->STS0 & (1<<INT_EI0) )
+
+	dwc_otg_device->flagID = -1;
+	dwc_otg_device->flagDeviceAttach = 0;
+	while (!kthread_should_stop())
+	{
+		msleep_interruptible(200);
+
+		if ( IsID() == 0 )
+		{
+			// ID = host mode
+			if ( dwc_otg_device->flagID != 0 )
+			{
+				dwc_otg_device->flagID = 0;
+				printk("Set ID to host mode\n");
+				DWC_DEBUGPL(DBG_ANY, "%s - ID : host mode\n", __func__);
+				USBPHY_SetID(0);
+				USBPHY_SetMode(USBPHY_MODE_HOST);
+			}
+			dwc_otg_device->flagDeviceVBUS = 0;
+		}
+		else
+		{
+			// ID = device mode
+			if ( dwc_otg_device->flagID != 1 )
+			{
+				dwc_otg_device->flagID = 1;
+				printk("Set ID to device mode\n");
+				DWC_DEBUGPL(DBG_ANY, "%s - ID : device mode\n", __func__);
+#ifndef DWC_HOST_ONLY
+				USBPHY_SetID(1);
+				msleep_interruptible(100);
+#endif
+			}
+#ifndef DWC_HOST_ONLY
+			if ( (dwc_otg_device->pcd) ? dwc_otg_device->pcd->driver : 0 )
+			{
+				if(dwc_otg_device->flagDeviceVBUS==0)
+				{
+					dwc_otg_device->flagDeviceVBUS = 1;
+					USBPHY_SetMode(USBPHY_MODE_DEVICE);
+				}
+
+				/* Send KOBJ_ONLINE/KOBJ_OFFLINE uevent */ 
+				if (IsUSBDET()) {
+					if (dwc_otg_device->flagDeviceAttach != 1) {
+						/* online@/devices/platform/dwc_otg.0 */
+						kobject_uevent(&dwc_otg_device->pcd->gadget.dev.parent->kobj, KOBJ_ONLINE);	
+						dwc_otg_device->flagDeviceAttach = 1;
+					}
+				} else {
+					if (dwc_otg_device->flagDeviceAttach == 1) {
+						/* offline@/devices/platform/dwc_otg.0 */
+						kobject_uevent(&dwc_otg_device->pcd->gadget.dev.parent->kobj, KOBJ_OFFLINE);
+						dwc_otg_device->flagDeviceAttach = 0;
+					}
+				}
+			}
+			else
+			{
+				dwc_otg_device->flagDeviceVBUS = 0;
+				USBPHY_SetMode(USBPHY_MODE_RESET);
+			}
+#endif
+		}
+	}
+
+	DWC_DEBUGPL(DBG_ANY, "%s stopped!!!\n", __func__);
+
+	return 0;
+}
+
+/**
+ * This function is called during module intialization to verify that
+ * the module parameters are in a valid state.
+ */
+static int check_parameters(dwc_otg_core_if_t *core_if)
+{
+	int i;
+	int retval = 0;
+
+	/* Checks if the parameter is outside of its valid range of values */
+#define DWC_OTG_PARAM_TEST(_param_,_low_,_high_) \
+		((dwc_otg_module_params._param_ < (_low_)) || \
+		(dwc_otg_module_params._param_ > (_high_)))
+
+	/* If the parameter has been set by the user, check that the parameter value is
+	 * within the value range of values.  If not, report a module error. */
+#define DWC_OTG_PARAM_ERR(_param_,_low_,_high_,_string_) \
+		do { \
+			if (dwc_otg_module_params._param_ != -1) { \
+				if (DWC_OTG_PARAM_TEST(_param_,(_low_),(_high_))) { \
+					DWC_ERROR("`%d' invalid for parameter `%s'\n", \
+						dwc_otg_module_params._param_, _string_); \
+					dwc_otg_module_params._param_ = dwc_param_##_param_##_default; \
+					retval ++; \
+				} \
+			} \
+		} while (0)
+
+	DWC_OTG_PARAM_ERR(opt,0,1,"opt");
+	DWC_OTG_PARAM_ERR(otg_cap,0,2,"otg_cap");
+	DWC_OTG_PARAM_ERR(dma_enable,0,1,"dma_enable");
+	DWC_OTG_PARAM_ERR(speed,0,1,"speed");
+	DWC_OTG_PARAM_ERR(host_support_fs_ls_low_power,0,1,"host_support_fs_ls_low_power");
+	DWC_OTG_PARAM_ERR(host_ls_low_power_phy_clk,0,1,"host_ls_low_power_phy_clk");
+	DWC_OTG_PARAM_ERR(enable_dynamic_fifo,0,1,"enable_dynamic_fifo");
+	DWC_OTG_PARAM_ERR(data_fifo_size,32,32768,"data_fifo_size");
+	DWC_OTG_PARAM_ERR(dev_rx_fifo_size,16,32768,"dev_rx_fifo_size");
+	DWC_OTG_PARAM_ERR(dev_nperio_tx_fifo_size,16,32768,"dev_nperio_tx_fifo_size");
+	DWC_OTG_PARAM_ERR(host_rx_fifo_size,16,32768,"host_rx_fifo_size");
+	DWC_OTG_PARAM_ERR(host_nperio_tx_fifo_size,16,32768,"host_nperio_tx_fifo_size");
+	DWC_OTG_PARAM_ERR(host_perio_tx_fifo_size,16,32768,"host_perio_tx_fifo_size");
+	DWC_OTG_PARAM_ERR(max_transfer_size,2047,524288,"max_transfer_size");
+	DWC_OTG_PARAM_ERR(max_packet_count,15,511,"max_packet_count");
+	DWC_OTG_PARAM_ERR(host_channels,1,16,"host_channels");
+	DWC_OTG_PARAM_ERR(dev_endpoints,1,15,"dev_endpoints");
+	DWC_OTG_PARAM_ERR(phy_type,0,2,"phy_type");
+	DWC_OTG_PARAM_ERR(phy_ulpi_ddr,0,1,"phy_ulpi_ddr");
+	DWC_OTG_PARAM_ERR(phy_ulpi_ext_vbus,0,1,"phy_ulpi_ext_vbus");
+	DWC_OTG_PARAM_ERR(i2c_enable,0,1,"i2c_enable");
+	DWC_OTG_PARAM_ERR(ulpi_fs_ls,0,1,"ulpi_fs_ls");
+	DWC_OTG_PARAM_ERR(ts_dline,0,1,"ts_dline");
+
+	if (dwc_otg_module_params.dma_burst_size != -1)
+	{
+		if (DWC_OTG_PARAM_TEST(dma_burst_size,1,1) &&
+		        DWC_OTG_PARAM_TEST(dma_burst_size,4,4) &&
+		        DWC_OTG_PARAM_TEST(dma_burst_size,8,8) &&
+		        DWC_OTG_PARAM_TEST(dma_burst_size,16,16) &&
+		        DWC_OTG_PARAM_TEST(dma_burst_size,32,32) &&
+		        DWC_OTG_PARAM_TEST(dma_burst_size,64,64) &&
+		        DWC_OTG_PARAM_TEST(dma_burst_size,128,128) &&
+		        DWC_OTG_PARAM_TEST(dma_burst_size,256,256))
+		{
+			DWC_ERROR("`%d' invalid for parameter `dma_burst_size'\n",
+			          dwc_otg_module_params.dma_burst_size);
+			dwc_otg_module_params.dma_burst_size = 32;
+			retval ++;
+		}
+	}
+
+	if (dwc_otg_module_params.phy_utmi_width != -1)
+	{
+		if (DWC_OTG_PARAM_TEST(phy_utmi_width,8,8) &&
+		        DWC_OTG_PARAM_TEST(phy_utmi_width,16,16))
+		{
+			DWC_ERROR("`%d' invalid for parameter `phy_utmi_width'\n",
+			          dwc_otg_module_params.phy_utmi_width);
+			dwc_otg_module_params.phy_utmi_width = 16;
+			retval ++;
+		}
+	}
+
+	for (i=0; i<15; i++)
+	{
+		/** @todo should be like above */
+		//DWC_OTG_PARAM_ERR(dev_perio_tx_fifo_size[i],4,768,"dev_perio_tx_fifo_size");
+		if (dwc_otg_module_params.dev_perio_tx_fifo_size[i] != -1)
+		{
+			if (DWC_OTG_PARAM_TEST(dev_perio_tx_fifo_size[i],4,768))
+			{
+				DWC_ERROR("`%d' invalid for parameter `%s_%d'\n",
+				          dwc_otg_module_params.dev_perio_tx_fifo_size[i], "dev_perio_tx_fifo_size", i);
+				dwc_otg_module_params.dev_perio_tx_fifo_size[i] = dwc_param_dev_perio_tx_fifo_size_default;
+				retval ++;
+			}
+		}
+	}
+
+	DWC_OTG_PARAM_ERR(en_multiple_tx_fifo,0,1,"en_multiple_tx_fifo");
+
+	for (i=0; i<15; i++)
+	{
+		/** @todo should be like above */
+		//DWC_OTG_PARAM_ERR(dev_tx_fifo_size[i],4,768,"dev_tx_fifo_size");
+		if (dwc_otg_module_params.dev_tx_fifo_size[i] != -1)
+		{
+			if (DWC_OTG_PARAM_TEST(dev_tx_fifo_size[i],4,768))
+			{
+				DWC_ERROR("`%d' invalid for parameter `%s_%d'\n",
+				          dwc_otg_module_params.dev_tx_fifo_size[i], "dev_tx_fifo_size", i);
+				dwc_otg_module_params.dev_tx_fifo_size[i] = dwc_param_dev_tx_fifo_size_default;
+				retval ++;
+			}
+		}
+	}
+
+	DWC_OTG_PARAM_ERR(thr_ctl, 0, 7, "thr_ctl");
+	DWC_OTG_PARAM_ERR(tx_thr_length, 8, 128, "tx_thr_length");
+	DWC_OTG_PARAM_ERR(rx_thr_length, 8, 128, "rx_thr_length");
+
+
+	/* At this point, all module parameters that have been set by the user
+	 * are valid, and those that have not are left unset.  Now set their
+	 * default values and/or check the parameters against the hardware
+	 * configurations of the OTG core. */
+
+
+
+	/* This sets the parameter to the default value if it has not been set by the
+	 * user */
+#define DWC_OTG_PARAM_SET_DEFAULT(_param_) \
+	({ \
+		int changed = 1; \
+		if (dwc_otg_module_params._param_ == -1) { \
+			changed = 0; \
+			dwc_otg_module_params._param_ = dwc_param_##_param_##_default; \
+		} \
+		changed; \
+	})
+
+	/* This checks the macro agains the hardware configuration to see if it is
+	 * valid.  It is possible that the default value could be invalid.	In this
+	 * case, it will report a module error if the user touched the parameter.
+	 * Otherwise it will adjust the value without any error. */
+#define DWC_OTG_PARAM_CHECK_VALID(_param_,_str_,_is_valid_,_set_valid_) \
+	({ \
+			int changed = DWC_OTG_PARAM_SET_DEFAULT(_param_); \
+		int error = 0; \
+		if (!(_is_valid_)) { \
+			if (changed) { \
+				DWC_ERROR("`%d' invalid for parameter `%s'.	 Check HW configuration.\n", dwc_otg_module_params._param_,_str_); \
+				error = 1; \
+			} \
+			dwc_otg_module_params._param_ = (_set_valid_); \
+		} \
+		error; \
+	})
+
+	/* OTG Cap */
+	retval += DWC_OTG_PARAM_CHECK_VALID(otg_cap,"otg_cap",
+	( {
+		int valid;
+		valid = 1;
+		switch (dwc_otg_module_params.otg_cap) {
+		case DWC_OTG_CAP_PARAM_HNP_SRP_CAPABLE:
+			if (core_if->hwcfg2.b.op_mode != DWC_HWCFG2_OP_MODE_HNP_SRP_CAPABLE_OTG) valid = 0;
+			break;
+		case DWC_OTG_CAP_PARAM_SRP_ONLY_CAPABLE:
+			if ((core_if->hwcfg2.b.op_mode != DWC_HWCFG2_OP_MODE_HNP_SRP_CAPABLE_OTG) &&
+			        (core_if->hwcfg2.b.op_mode != DWC_HWCFG2_OP_MODE_SRP_ONLY_CAPABLE_OTG) &&
+			        (core_if->hwcfg2.b.op_mode != DWC_HWCFG2_OP_MODE_SRP_CAPABLE_DEVICE) &&
+			        (core_if->hwcfg2.b.op_mode != DWC_HWCFG2_OP_MODE_SRP_CAPABLE_HOST))
+			{
+				valid = 0;
+			}
+			break;
+		case DWC_OTG_CAP_PARAM_NO_HNP_SRP_CAPABLE:
+			/* always valid */
+			break;
+		}
+		valid;
+	}),
+	                                    (((core_if->hwcfg2.b.op_mode == DWC_HWCFG2_OP_MODE_HNP_SRP_CAPABLE_OTG) ||
+	                                      (core_if->hwcfg2.b.op_mode == DWC_HWCFG2_OP_MODE_SRP_ONLY_CAPABLE_OTG) ||
+	                                      (core_if->hwcfg2.b.op_mode == DWC_HWCFG2_OP_MODE_SRP_CAPABLE_DEVICE) ||
+	                                      (core_if->hwcfg2.b.op_mode == DWC_HWCFG2_OP_MODE_SRP_CAPABLE_HOST)) ?
+	                                     DWC_OTG_CAP_PARAM_SRP_ONLY_CAPABLE :
+	                                     DWC_OTG_CAP_PARAM_NO_HNP_SRP_CAPABLE));
+
+	retval += DWC_OTG_PARAM_CHECK_VALID(dma_enable,"dma_enable",
+	                                    ((dwc_otg_module_params.dma_enable == 1) && (core_if->hwcfg2.b.architecture == 0)) ? 0 : 1,
+	                                    0);
+
+	retval += DWC_OTG_PARAM_CHECK_VALID(opt,"opt",
+	                                    1,
+	                                    0);
+
+	DWC_OTG_PARAM_SET_DEFAULT(dma_burst_size);
+
+	retval += DWC_OTG_PARAM_CHECK_VALID(host_support_fs_ls_low_power,
+	                                    "host_support_fs_ls_low_power",
+	                                    1, 0);
+
+	retval += DWC_OTG_PARAM_CHECK_VALID(enable_dynamic_fifo,
+	                                    "enable_dynamic_fifo",
+	                                    ((dwc_otg_module_params.enable_dynamic_fifo == 0) ||
+	                                     (core_if->hwcfg2.b.dynamic_fifo == 1)), 0);
+
+
+	retval += DWC_OTG_PARAM_CHECK_VALID(data_fifo_size,
+	                                    "data_fifo_size",
+	                                    (dwc_otg_module_params.data_fifo_size <= 4160/*core_if->hwcfg3.b.dfifo_depth*/),
+	                                    4160/*core_if->hwcfg3.b.dfifo_depth*/);
+
+	retval += DWC_OTG_PARAM_CHECK_VALID(dev_rx_fifo_size,
+	                                    "dev_rx_fifo_size",
+	                                    (dwc_otg_module_params.dev_rx_fifo_size <= dwc_read_reg32(&core_if->core_global_regs->grxfsiz)),
+	                                    dwc_read_reg32(&core_if->core_global_regs->grxfsiz));
+
+	retval += DWC_OTG_PARAM_CHECK_VALID(dev_nperio_tx_fifo_size,
+	                                    "dev_nperio_tx_fifo_size",
+	                                    (dwc_otg_module_params.dev_nperio_tx_fifo_size <= (dwc_read_reg32(&core_if->core_global_regs->gnptxfsiz) >> 16)),
+	                                    (dwc_read_reg32(&core_if->core_global_regs->gnptxfsiz) >> 16));
+
+	retval += DWC_OTG_PARAM_CHECK_VALID(host_rx_fifo_size,
+	                                    "host_rx_fifo_size",
+	                                    (dwc_otg_module_params.host_rx_fifo_size <= dwc_read_reg32(&core_if->core_global_regs->grxfsiz)),
+	                                    dwc_read_reg32(&core_if->core_global_regs->grxfsiz));
+
+
+	retval += DWC_OTG_PARAM_CHECK_VALID(host_nperio_tx_fifo_size,
+	                                    "host_nperio_tx_fifo_size",
+	                                    (dwc_otg_module_params.host_nperio_tx_fifo_size <= (dwc_read_reg32(&core_if->core_global_regs->gnptxfsiz) >> 16)),
+	                                    (dwc_read_reg32(&core_if->core_global_regs->gnptxfsiz) >> 16));
+
+	retval += DWC_OTG_PARAM_CHECK_VALID(host_perio_tx_fifo_size,
+	                                    "host_perio_tx_fifo_size",
+	                                    (dwc_otg_module_params.host_perio_tx_fifo_size <= ((dwc_read_reg32(&core_if->core_global_regs->hptxfsiz) >> 16))),
+	                                    ((dwc_read_reg32(&core_if->core_global_regs->hptxfsiz) >> 16)));
+
+	retval += DWC_OTG_PARAM_CHECK_VALID(max_transfer_size,
+	                                    "max_transfer_size",
+	                                    (dwc_otg_module_params.max_transfer_size < (1 << (core_if->hwcfg3.b.xfer_size_cntr_width + 11))),
+	                                    ((1 << (core_if->hwcfg3.b.xfer_size_cntr_width + 11)) - 1));
+
+	retval += DWC_OTG_PARAM_CHECK_VALID(max_packet_count,
+	                                    "max_packet_count",
+	                                    (dwc_otg_module_params.max_packet_count < (1 << (core_if->hwcfg3.b.packet_size_cntr_width + 4))),
+	                                    ((1 << (core_if->hwcfg3.b.packet_size_cntr_width + 4)) - 1));
+
+	retval += DWC_OTG_PARAM_CHECK_VALID(host_channels,
+	                                    "host_channels",
+	                                    (dwc_otg_module_params.host_channels <= (core_if->hwcfg2.b.num_host_chan + 1)),
+	                                    (core_if->hwcfg2.b.num_host_chan + 1));
+
+	retval += DWC_OTG_PARAM_CHECK_VALID(dev_endpoints,
+	                                    "dev_endpoints",
+	                                    (dwc_otg_module_params.dev_endpoints <= (core_if->hwcfg2.b.num_dev_ep)),
+	                                    core_if->hwcfg2.b.num_dev_ep);
+
+	/*
+	 * Define the following to disable the FS PHY Hardware checking.  This is for
+	 * internal testing only.
+	 *
+	 * #define NO_FS_PHY_HW_CHECKS
+	 */
+
+#ifdef NO_FS_PHY_HW_CHECKS
+	retval += DWC_OTG_PARAM_CHECK_VALID(phy_type,
+	                                    "phy_type", 1, 0);
+#else
+	retval += DWC_OTG_PARAM_CHECK_VALID(phy_type,
+	                                    "phy_type",
+	( {
+		int valid = 0;
+		if ((dwc_otg_module_params.phy_type == DWC_PHY_TYPE_PARAM_UTMI) &&
+		        ((core_if->hwcfg2.b.hs_phy_type == 1) ||
+		         (core_if->hwcfg2.b.hs_phy_type == 3)))
+		{
+			valid = 1;
+		}
+		else if ((dwc_otg_module_params.phy_type == DWC_PHY_TYPE_PARAM_ULPI) &&
+		         ((core_if->hwcfg2.b.hs_phy_type == 2) ||
+		          (core_if->hwcfg2.b.hs_phy_type == 3)))
+		{
+			valid = 1;
+		}
+		else if ((dwc_otg_module_params.phy_type == DWC_PHY_TYPE_PARAM_FS) &&
+		         (core_if->hwcfg2.b.fs_phy_type == 1))
+		{
+			valid = 1;
+		}
+		valid;
+	}),
+	( {
+		int set = DWC_PHY_TYPE_PARAM_FS;
+		if (core_if->hwcfg2.b.hs_phy_type) {
+			if ((core_if->hwcfg2.b.hs_phy_type == 3) ||
+			(core_if->hwcfg2.b.hs_phy_type == 1)) {
+				set = DWC_PHY_TYPE_PARAM_UTMI;
+			}
+			else {
+				set = DWC_PHY_TYPE_PARAM_ULPI;
+			}
+		}
+		set;
+	}));
+#endif
+
+	retval += DWC_OTG_PARAM_CHECK_VALID(speed,"speed",
+	                                    (dwc_otg_module_params.speed == 0) && (dwc_otg_module_params.phy_type == DWC_PHY_TYPE_PARAM_FS) ? 0 : 1,
+	                                    dwc_otg_module_params.phy_type == DWC_PHY_TYPE_PARAM_FS ? 1 : 0);
+
+	retval += DWC_OTG_PARAM_CHECK_VALID(host_ls_low_power_phy_clk,
+	                                    "host_ls_low_power_phy_clk",
+	                                    ((dwc_otg_module_params.host_ls_low_power_phy_clk == DWC_HOST_LS_LOW_POWER_PHY_CLK_PARAM_48MHZ) && (dwc_otg_module_params.phy_type == DWC_PHY_TYPE_PARAM_FS) ? 0 : 1),
+	                                    ((dwc_otg_module_params.phy_type == DWC_PHY_TYPE_PARAM_FS) ? DWC_HOST_LS_LOW_POWER_PHY_CLK_PARAM_6MHZ : DWC_HOST_LS_LOW_POWER_PHY_CLK_PARAM_48MHZ));
+
+	DWC_OTG_PARAM_SET_DEFAULT(phy_ulpi_ddr);
+	DWC_OTG_PARAM_SET_DEFAULT(phy_ulpi_ext_vbus);
+	DWC_OTG_PARAM_SET_DEFAULT(phy_utmi_width);
+	DWC_OTG_PARAM_SET_DEFAULT(ulpi_fs_ls);
+	DWC_OTG_PARAM_SET_DEFAULT(ts_dline);
+
+#ifdef NO_FS_PHY_HW_CHECKS
+	retval += DWC_OTG_PARAM_CHECK_VALID(i2c_enable,
+	                                    "i2c_enable", 1, 0);
+#else
+	retval += DWC_OTG_PARAM_CHECK_VALID(i2c_enable,
+	                                    "i2c_enable",
+	                                    (dwc_otg_module_params.i2c_enable == 1) && (core_if->hwcfg3.b.i2c == 0) ? 0 : 1,
+	                                    0);
+#endif
+
+	for (i=0; i<15; i++)
+	{
+		//int changed = 1;
+		//int error = 0;
+
+		if (dwc_otg_module_params.dev_perio_tx_fifo_size[i] == -1)
+		{
+			//changed = 0;
+			dwc_otg_module_params.dev_perio_tx_fifo_size[i] = dwc_param_dev_perio_tx_fifo_size_default;
+		}
+		//AlenOh
+		//if (!(dwc_otg_module_params.dev_perio_tx_fifo_size[i] <= (dwc_read_reg32(&core_if->core_global_regs->dptxfsiz_dieptxf[i]))))
+		//{
+		//	if (changed)
+		//	{
+		//		DWC_ERROR("`%d' invalid for parameter `dev_perio_fifo_size_%d'.	 Check HW configuration.\n", dwc_otg_module_params.dev_perio_tx_fifo_size[i],i);
+		//		error = 1;
+		//	}
+		//	dwc_otg_module_params.dev_perio_tx_fifo_size[i] = dwc_read_reg32(&core_if->core_global_regs->dptxfsiz_dieptxf[i]);
+		//}
+		//retval += error;
+	}
+
+	retval += DWC_OTG_PARAM_CHECK_VALID(en_multiple_tx_fifo,"en_multiple_tx_fifo",
+	                                    ((dwc_otg_module_params.en_multiple_tx_fifo == 1) && (core_if->hwcfg4.b.ded_fifo_en == 0)) ? 0 : 1,
+	                                    0);
+
+	for (i=0; i<15; i++)
+	{
+		//int changed = 1;
+		//int error = 0;
+
+		if (dwc_otg_module_params.dev_tx_fifo_size[i] == -1)
+		{
+			//changed = 0;
+			dwc_otg_module_params.dev_tx_fifo_size[i] = dwc_param_dev_tx_fifo_size_default;
+		}
+		//AlenOh
+		//if (!(dwc_otg_module_params.dev_tx_fifo_size[i] <= (dwc_read_reg32(&core_if->core_global_regs->dptxfsiz_dieptxf[i]))))
+		//{
+		//	if (changed)
+		//	{
+		//		DWC_ERROR("%d' invalid for parameter `dev_perio_fifo_size_%d'.	Check HW configuration.\n", dwc_otg_module_params.dev_tx_fifo_size[i],i);
+		//		error = 1;
+		//	}
+		//	dwc_otg_module_params.dev_tx_fifo_size[i] = dwc_read_reg32(&core_if->core_global_regs->dptxfsiz_dieptxf[i]);
+		//}
+		//retval += error;
+	}
+
+	DWC_OTG_PARAM_SET_DEFAULT(thr_ctl);
+	DWC_OTG_PARAM_SET_DEFAULT(tx_thr_length);
+	DWC_OTG_PARAM_SET_DEFAULT(rx_thr_length);
+
+	return retval;
+}
+
+/**
+ * This function is the top level interrupt handler for the Common
+ * (Device and host modes) interrupts.
+ */
+static irqreturn_t dwc_otg_common_irq(int _irq, void *_dev)
+{
+	dwc_otg_device_t *otg_dev = _dev;
+	int32_t retval = IRQ_NONE;
+
+	retval = dwc_otg_handle_common_intr( otg_dev->core_if );
+	return IRQ_RETVAL(retval);
+}
+
+/**
+ * This function is called when a lm_device is unregistered with the
+ * dwc_otg_driver. This happens, for example, when the rmmod command is
+ * executed. The device may or may not be electrically present. If it is
+ * present, the driver stops device processing. Any resources used on behalf
+ * of this device are freed.
+ *
+ * @param[in] _lmdev
+ */
+static int dwc_otg_driver_remove(struct device *dev)
+{
+	dwc_otg_device_t *otg_dev = dev_get_otgdata(dev);
+	DWC_DEBUGPL(DBG_ANY, "%s(%p)\n", __func__, dev);
+
+	if (otg_dev == NULL)
+	{
+		/* Memory allocation for the dwc_otg_device failed. */
+		return 0;
+	}
+
+	if (!IS_ERR(otg_dev->vbus_usb_task)) {
+		printk("vbus_usb_task stops...\n");
+		kthread_stop(otg_dev->vbus_usb_task);
+	}
+
+	/*
+	 * Free the IRQ
+	 */
+	if (otg_dev->common_irq_installed)
+	{
+		free_irq( ARM_VP_OTG_INTR, otg_dev );
+	}
+
+#ifndef DWC_DEVICE_ONLY
+	if (otg_dev->hcd != NULL)
+	{
+		dwc_otg_hcd_remove( dev );
+	}
+#endif
+
+#ifndef DWC_HOST_ONLY
+	if (otg_dev->pcd != NULL)
+	{
+		dwc_otg_pcd_remove( dev );
+	}
+#endif
+	if (otg_dev->core_if != NULL)
+	{
+		dwc_otg_cil_remove( otg_dev->core_if );
+	}
+
+	/*
+	 * Remove the device attributes
+	 */
+#ifdef _USE_ATTR_
+	dwc_otg_attr_remove(dev);
+#endif
+#ifdef DWC_SET_MODE
+	device_remove_file(dev, &dev_attr_setmode);
+	device_remove_file(dev, &dev_attr_fsg);
+#endif
+
+	/*
+	 * Return the memory.
+	 */
+	if (otg_dev->base != NULL)
+	{
+		//iounmap(otg_dev->base);
+	}
+	kfree(otg_dev);
+
+	/*
+	 * Clear the drvdata pointer.
+	 */
+	dev_set_otgdata( dev, 0 );
+
+	return 0;
+}
+
+/**
+ * This function is called when an lm_device is bound to a
+ * dwc_otg_driver. It creates the driver components required to
+ * control the device (CIL, HCD, and PCD) and it initializes the
+ * device. The driver components are stored in a dwc_otg_device
+ * structure. A reference to the dwc_otg_device is saved in the
+ * lm_device. This allows the driver to access the dwc_otg_device
+ * structure on subsequent calls to driver methods for this device.
+ *
+ * @param[in] _lmdev  lm_device definition
+ */
+static int dwc_otg_driver_probe(struct device *dev)
+{
+	int retval = 0;
+	dwc_otg_device_t *dwc_otg_device;
+	int32_t snpsid;
+
+	dev_dbg(dev, "dwc_otg_driver_probe(%p)\n", dev);
+//	dev_dbg(&_lmdev->dev, "start=0x%08x\n", (unsigned)_lmdev->resource.start);
+
+	dwc_otg_device = kmalloc(sizeof(dwc_otg_device_t), GFP_KERNEL);
+
+	if (dwc_otg_device == 0)
+	{
+		dev_err(dev, "kmalloc of dwc_otg_device failed\n");
+		retval = -ENOMEM;
+		goto fail;
+	}
+
+	memset(dwc_otg_device, 0, sizeof(*dwc_otg_device));
+	dwc_otg_device->reg_offset = 0xFFFFFFFF;
+	dwc_otg_device->vbus_usb_task = (struct task_struct *)(-EINVAL);
+
+	/*
+	 * Map the DWC_otg Core memory into virtual address space.
+	 */
+	//dwc_otg_device->base = ioremap(VERSATILE_LT_BASE, SZ_256K);
+	//dwc_otg_device->base = (void *)tcc_p2v(HwUSB20OTG_BASE);
+	dwc_otg_device->base = (void *)0xF0550000;
+
+	if (dwc_otg_device->base == NULL)
+	{
+		dev_err(dev, "ioremap() failed\n");
+		retval = -ENOMEM;
+		goto fail;
+	}
+	dev_dbg(dev, "base=0x%08x\n", (unsigned)dwc_otg_device->base);
+
+	/*
+	 * Attempt to ensure this device is really a DWC_otg Controller.
+	 * Read and verify the SNPSID register contents. The value should be
+	 * 0x45F42XXX, which corresponds to "OT2", as in "OTG version 2.XX".
+	 */
+	snpsid = dwc_read_reg32((uint32_t *)((uint8_t *)dwc_otg_device->base + 0x40));
+
+	if ((snpsid & 0xFFFFF000) != 0x4F542000)
+	{
+		dev_err(dev, "Bad value for SNPSID: 0x%08x\n", snpsid);
+		retval = -EINVAL;
+		goto fail;
+	}
+
+	/*
+	 * Initialize driver data to point to the global DWC_otg
+	 * Device structure.
+	 */
+	dev_set_otgdata( dev, dwc_otg_device );
+	dev_dbg(dev, "dwc_otg_device=0x%p\n", dwc_otg_device);
+
+	dwc_otg_device->core_if = dwc_otg_cil_init( dwc_otg_device->base,
+	                          &dwc_otg_module_params);
+	if (dwc_otg_device->core_if == 0)
+	{
+		dev_err(dev, "CIL initialization failed!\n");
+		retval = -ENOMEM;
+		goto fail;
+	}
+
+	/*
+	 * Validate parameter values.
+	 */
+	if (check_parameters(dwc_otg_device->core_if) != 0)
+	{
+		retval = -EINVAL;
+		goto fail;
+	}
+
+	/*
+	 * Create Device Attributes in sysfs
+	 */
+#ifdef _USE_ATTR_
+	dwc_otg_attr_create (dev);
+#endif
+#ifdef DWC_SET_MODE
+	device_create_file(dev, &dev_attr_setmode);
+	dwc_otg_device->flagMode = 2;
+	device_create_file(dev, &dev_attr_fsg);
+	dwc_otg_device->flagDeviceAttach = 0;
+#endif
+
+	INIT_WORK(&dwc_otg_device->core_if->vbus_work, tcc_vbus_work);
+
+	/*
+	 * Disable the global interrupt until all the interrupt
+	 * handlers are installed.
+	 */
+	dwc_otg_disable_global_interrupts( dwc_otg_device->core_if );
+	/*
+	 * Install the interrupt handler for the common interrupts before
+	 * enabling common interrupts in core_init below.
+	 */
+	DWC_DEBUGPL( DBG_CIL, "registering (common) handler for irq%d\n",
+	             ARM_VP_OTG_INTR);
+	retval = request_irq(ARM_VP_OTG_INTR, dwc_otg_common_irq,
+	                     IRQF_SHARED, "dwc_otg", dwc_otg_device );
+	if (retval != 0)
+	{
+		DWC_ERROR("request of irq%d failed\n",ARM_VP_OTG_INTR);
+		retval = -EBUSY;
+		goto fail;
+	}
+	else
+	{
+		dwc_otg_device->common_irq_installed = 1;
+	}
+
+	/*
+	 * Initialize the DWC_otg core.
+	 */
+	tca_ckc_setiobus(RB_USB20OTG, ENABLE);	// Turn on the USB clock from IO BUS
+	TCC_DVBUS_Control(0);
+	USBPHY_SetMode(USBPHY_MODE_RESET);
+#ifdef DWC_DEVICE_ONLY
+	USBPHY_SetID(1);	// device
+#else
+	USBPHY_SetID(0);	// host for dwc_otg_hcd_init
+#endif
+	tcc_usb_link_reset();	//Reset OTG LINK - AlenOh
+	dwc_otg_core_init(dwc_otg_device->core_if);
+
+#ifndef DWC_HOST_ONLY
+	/*
+	 * Initialize the PCD
+	 */
+	retval = dwc_otg_pcd_init( dev );
+	if (retval != 0)
+	{
+		DWC_ERROR("dwc_otg_pcd_init failed\n");
+		dwc_otg_device->pcd = NULL;
+		goto fail;
+	}
+#endif
+#ifndef DWC_DEVICE_ONLY
+	/*
+	 * Initialize the HCD
+	 */
+	//TCC_DVBUS_Control(1);
+	//USBPHY_SetID(0);
+	//USBPHY_SetMode(USBPHY_MODE_HOST);
+	retval = dwc_otg_hcd_init(dev);
+	if (retval != 0)
+	{
+		DWC_ERROR("dwc_otg_hcd_init failed\n");
+		dwc_otg_device->hcd = NULL;
+		goto fail;
+	}
+#endif
+
+	dwc_otg_device->vbus_usb_task = kthread_create(tcc_usb_thread, dwc_otg_device,"tcc-usb-thread");
+	if (IS_ERR(dwc_otg_device->vbus_usb_task)) {
+		printk("\nPTR ERR %p", dwc_otg_device->vbus_usb_task);
+		return -EINVAL;
+	}
+
+	/* Tell the thread to start working */
+	wake_up_process(dwc_otg_device->vbus_usb_task);
+
+	/*
+	 * Enable the global interrupt after all the interrupt
+	 * handlers are installed.
+	 */
+	dwc_otg_enable_global_interrupts( dwc_otg_device->core_if );
+
+	/* add power control functions */
+	insert_pwm_node(DEVICE_OTG, otg_pwr_ctl, dwc_otg_device);
+
+	return 0;
+
+fail:
+	dwc_otg_driver_remove(dev);
+	return retval;
+}
+
+/**
+ * This structure defines the methods to be called by a bus driver
+ * during the lifecycle of a device on that bus. Both drivers and
+ * devices are registered with a bus driver. The bus driver matches
+ * devices to drivers based on information in the device and driver
+ * structures.
+ *
+ * The probe function is called when the bus driver matches a device
+ * to this driver. The remove function is called when a device is
+ * unregistered with the bus driver.
+ */
+static struct device_driver dwc_otg_driver =
+{
+	.name   = (char*)dwc_driver_name,
+	.bus    = &platform_bus_type,
+	.probe  = dwc_otg_driver_probe,
+	.remove = dwc_otg_driver_remove,
+};
+
+
+/**
+ * This function is called when the dwc_otg_driver is installed with the
+ * insmod command. It registers the dwc_otg_driver structure with the
+ * appropriate bus driver. This will cause the dwc_otg_driver_probe function
+ * to be called. In addition, the bus driver will automatically expose
+ * attributes defined for the device and driver in the special sysfs file
+ * system.
+ *
+ * @return
+ */
+static int __init dwc_otg_driver_init(void)
+{
+	int retval = 0;
+
+	printk(KERN_INFO "%s: version %s\n", dwc_driver_name, DWC_DRIVER_VERSION);
+	retval = driver_register(&dwc_otg_driver);
+	if (retval < 0)
+	{
+		printk(KERN_ERR "%s retval=%d\n", __func__, retval);
+		return retval;
+	}
+	driver_create_file(&dwc_otg_driver, &driver_attr_version);
+	driver_create_file(&dwc_otg_driver, &driver_attr_debuglevel);
+	driver_create_file(&dwc_otg_driver, &driver_attr_hvbus);
+
+	return retval;
+}
+module_init(dwc_otg_driver_init);
+
+/**
+ * This function is called when the driver is removed from the kernel
+ * with the rmmod command. The driver unregisters itself with its bus
+ * driver.
+ *
+ */
+static void __exit dwc_otg_driver_cleanup(void)
+{
+	printk(KERN_DEBUG "dwc_otg_driver_cleanup()\n");
+
+	driver_remove_file(&dwc_otg_driver, &driver_attr_debuglevel);
+	driver_remove_file(&dwc_otg_driver, &driver_attr_version);
+	driver_remove_file(&dwc_otg_driver, &driver_attr_hvbus);
+
+	driver_unregister(&dwc_otg_driver);
+
+	/* remove power control functions */
+	remove_pwm_node(DEVICE_OTG);
+
+	printk(KERN_INFO "%s module removed\n", dwc_driver_name);
+}
+module_exit(dwc_otg_driver_cleanup);
+
+MODULE_DESCRIPTION(DWC_DRIVER_DESC);
+MODULE_AUTHOR("Synopsys Inc.");
+MODULE_LICENSE("GPL");
+
+module_param_named(otg_cap, dwc_otg_module_params.otg_cap, int, 0444);
+MODULE_PARM_DESC(otg_cap, "OTG Capabilities 0=HNP&SRP 1=SRP Only 2=None");
+module_param_named(opt, dwc_otg_module_params.opt, int, 0444);
+MODULE_PARM_DESC(opt, "OPT Mode");
+module_param_named(dma_enable, dwc_otg_module_params.dma_enable, int, 0444);
+MODULE_PARM_DESC(dma_enable, "DMA Mode 0=Slave 1=DMA enabled");
+module_param_named(dma_burst_size, dwc_otg_module_params.dma_burst_size, int, 0444);
+MODULE_PARM_DESC(dma_burst_size, "DMA Burst Size 1, 4, 8, 16, 32, 64, 128, 256");
+module_param_named(speed, dwc_otg_module_params.speed, int, 0444);
+MODULE_PARM_DESC(speed, "Speed 0=High Speed 1=Full Speed");
+module_param_named(host_support_fs_ls_low_power, dwc_otg_module_params.host_support_fs_ls_low_power, int, 0444);
+MODULE_PARM_DESC(host_support_fs_ls_low_power, "Support Low Power w/FS or LS 0=Support 1=Don't Support");
+module_param_named(host_ls_low_power_phy_clk, dwc_otg_module_params.host_ls_low_power_phy_clk, int, 0444);
+MODULE_PARM_DESC(host_ls_low_power_phy_clk, "Low Speed Low Power Clock 0=48Mhz 1=6Mhz");
+module_param_named(enable_dynamic_fifo, dwc_otg_module_params.enable_dynamic_fifo, int, 0444);
+MODULE_PARM_DESC(enable_dynamic_fifo, "0=cC Setting 1=Allow Dynamic Sizing");
+module_param_named(data_fifo_size, dwc_otg_module_params.data_fifo_size, int, 0444);
+MODULE_PARM_DESC(data_fifo_size, "Total number of words in the data FIFO memory 32-32768");
+module_param_named(dev_rx_fifo_size, dwc_otg_module_params.dev_rx_fifo_size, int, 0444);
+MODULE_PARM_DESC(dev_rx_fifo_size, "Number of words in the Rx FIFO 16-32768");
+module_param_named(dev_nperio_tx_fifo_size, dwc_otg_module_params.dev_nperio_tx_fifo_size, int, 0444);
+MODULE_PARM_DESC(dev_nperio_tx_fifo_size, "Number of words in the non-periodic Tx FIFO 16-32768");
+module_param_named(dev_perio_tx_fifo_size_1, dwc_otg_module_params.dev_perio_tx_fifo_size[0], int, 0444);
+MODULE_PARM_DESC(dev_perio_tx_fifo_size_1, "Number of words in the periodic Tx FIFO 4-768");
+module_param_named(dev_perio_tx_fifo_size_2, dwc_otg_module_params.dev_perio_tx_fifo_size[1], int, 0444);
+MODULE_PARM_DESC(dev_perio_tx_fifo_size_2, "Number of words in the periodic Tx FIFO 4-768");
+module_param_named(dev_perio_tx_fifo_size_3, dwc_otg_module_params.dev_perio_tx_fifo_size[2], int, 0444);
+MODULE_PARM_DESC(dev_perio_tx_fifo_size_3, "Number of words in the periodic Tx FIFO 4-768");
+module_param_named(dev_perio_tx_fifo_size_4, dwc_otg_module_params.dev_perio_tx_fifo_size[3], int, 0444);
+MODULE_PARM_DESC(dev_perio_tx_fifo_size_4, "Number of words in the periodic Tx FIFO 4-768");
+module_param_named(dev_perio_tx_fifo_size_5, dwc_otg_module_params.dev_perio_tx_fifo_size[4], int, 0444);
+MODULE_PARM_DESC(dev_perio_tx_fifo_size_5, "Number of words in the periodic Tx FIFO 4-768");
+module_param_named(dev_perio_tx_fifo_size_6, dwc_otg_module_params.dev_perio_tx_fifo_size[5], int, 0444);
+MODULE_PARM_DESC(dev_perio_tx_fifo_size_6, "Number of words in the periodic Tx FIFO 4-768");
+module_param_named(dev_perio_tx_fifo_size_7, dwc_otg_module_params.dev_perio_tx_fifo_size[6], int, 0444);
+MODULE_PARM_DESC(dev_perio_tx_fifo_size_7, "Number of words in the periodic Tx FIFO 4-768");
+module_param_named(dev_perio_tx_fifo_size_8, dwc_otg_module_params.dev_perio_tx_fifo_size[7], int, 0444);
+MODULE_PARM_DESC(dev_perio_tx_fifo_size_8, "Number of words in the periodic Tx FIFO 4-768");
+module_param_named(dev_perio_tx_fifo_size_9, dwc_otg_module_params.dev_perio_tx_fifo_size[8], int, 0444);
+MODULE_PARM_DESC(dev_perio_tx_fifo_size_9, "Number of words in the periodic Tx FIFO 4-768");
+module_param_named(dev_perio_tx_fifo_size_10, dwc_otg_module_params.dev_perio_tx_fifo_size[9], int, 0444);
+MODULE_PARM_DESC(dev_perio_tx_fifo_size_10, "Number of words in the periodic Tx FIFO 4-768");
+module_param_named(dev_perio_tx_fifo_size_11, dwc_otg_module_params.dev_perio_tx_fifo_size[10], int, 0444);
+MODULE_PARM_DESC(dev_perio_tx_fifo_size_11, "Number of words in the periodic Tx FIFO 4-768");
+module_param_named(dev_perio_tx_fifo_size_12, dwc_otg_module_params.dev_perio_tx_fifo_size[11], int, 0444);
+MODULE_PARM_DESC(dev_perio_tx_fifo_size_12, "Number of words in the periodic Tx FIFO 4-768");
+module_param_named(dev_perio_tx_fifo_size_13, dwc_otg_module_params.dev_perio_tx_fifo_size[12], int, 0444);
+MODULE_PARM_DESC(dev_perio_tx_fifo_size_13, "Number of words in the periodic Tx FIFO 4-768");
+module_param_named(dev_perio_tx_fifo_size_14, dwc_otg_module_params.dev_perio_tx_fifo_size[13], int, 0444);
+MODULE_PARM_DESC(dev_perio_tx_fifo_size_14, "Number of words in the periodic Tx FIFO 4-768");
+module_param_named(dev_perio_tx_fifo_size_15, dwc_otg_module_params.dev_perio_tx_fifo_size[14], int, 0444);
+MODULE_PARM_DESC(dev_perio_tx_fifo_size_15, "Number of words in the periodic Tx FIFO 4-768");
+module_param_named(host_rx_fifo_size, dwc_otg_module_params.host_rx_fifo_size, int, 0444);
+MODULE_PARM_DESC(host_rx_fifo_size, "Number of words in the Rx FIFO 16-32768");
+module_param_named(host_nperio_tx_fifo_size, dwc_otg_module_params.host_nperio_tx_fifo_size, int, 0444);
+MODULE_PARM_DESC(host_nperio_tx_fifo_size, "Number of words in the non-periodic Tx FIFO 16-32768");
+module_param_named(host_perio_tx_fifo_size, dwc_otg_module_params.host_perio_tx_fifo_size, int, 0444);
+MODULE_PARM_DESC(host_perio_tx_fifo_size, "Number of words in the host periodic Tx FIFO 16-32768");
+module_param_named(max_transfer_size, dwc_otg_module_params.max_transfer_size, int, 0444);
+/** @todo Set the max to 512K, modify checks */
+MODULE_PARM_DESC(max_transfer_size, "The maximum transfer size supported in bytes 2047-65535");
+module_param_named(max_packet_count, dwc_otg_module_params.max_packet_count, int, 0444);
+MODULE_PARM_DESC(max_packet_count, "The maximum number of packets in a transfer 15-511");
+module_param_named(host_channels, dwc_otg_module_params.host_channels, int, 0444);
+MODULE_PARM_DESC(host_channels, "The number of host channel registers to use 1-16");
+module_param_named(dev_endpoints, dwc_otg_module_params.dev_endpoints, int, 0444);
+MODULE_PARM_DESC(dev_endpoints, "The number of endpoints in addition to EP0 available for device mode 1-15");
+module_param_named(phy_type, dwc_otg_module_params.phy_type, int, 0444);
+MODULE_PARM_DESC(phy_type, "0=Reserved 1=UTMI+ 2=ULPI");
+module_param_named(phy_utmi_width, dwc_otg_module_params.phy_utmi_width, int, 0444);
+MODULE_PARM_DESC(phy_utmi_width, "Specifies the UTMI+ Data Width 8 or 16 bits");
+module_param_named(phy_ulpi_ddr, dwc_otg_module_params.phy_ulpi_ddr, int, 0444);
+MODULE_PARM_DESC(phy_ulpi_ddr, "ULPI at double or single data rate 0=Single 1=Double");
+module_param_named(phy_ulpi_ext_vbus, dwc_otg_module_params.phy_ulpi_ext_vbus, int, 0444);
+MODULE_PARM_DESC(phy_ulpi_ext_vbus, "ULPI PHY using internal or external vbus 0=Internal");
+module_param_named(i2c_enable, dwc_otg_module_params.i2c_enable, int, 0444);
+MODULE_PARM_DESC(i2c_enable, "FS PHY Interface");
+module_param_named(ulpi_fs_ls, dwc_otg_module_params.ulpi_fs_ls, int, 0444);
+MODULE_PARM_DESC(ulpi_fs_ls, "ULPI PHY FS/LS mode only");
+module_param_named(ts_dline, dwc_otg_module_params.ts_dline, int, 0444);
+MODULE_PARM_DESC(ts_dline, "Term select Dline pulsing for all PHYs");
+module_param_named(debug, g_dbg_lvl, int, 0444);
+MODULE_PARM_DESC(debug, "");
+
+module_param_named(en_multiple_tx_fifo, dwc_otg_module_params.en_multiple_tx_fifo, int, 0444);
+MODULE_PARM_DESC(en_multiple_tx_fifo, "Dedicated Non Periodic Tx FIFOs 0=disabled 1=enabled");
+module_param_named(dev_tx_fifo_size_1, dwc_otg_module_params.dev_tx_fifo_size[0], int, 0444);
+MODULE_PARM_DESC(dev_tx_fifo_size_1, "Number of words in the Tx FIFO 4-768");
+module_param_named(dev_tx_fifo_size_2, dwc_otg_module_params.dev_tx_fifo_size[1], int, 0444);
+MODULE_PARM_DESC(dev_tx_fifo_size_2, "Number of words in the Tx FIFO 4-768");
+module_param_named(dev_tx_fifo_size_3, dwc_otg_module_params.dev_tx_fifo_size[2], int, 0444);
+MODULE_PARM_DESC(dev_tx_fifo_size_3, "Number of words in the Tx FIFO 4-768");
+module_param_named(dev_tx_fifo_size_4, dwc_otg_module_params.dev_tx_fifo_size[3], int, 0444);
+MODULE_PARM_DESC(dev_tx_fifo_size_4, "Number of words in the Tx FIFO 4-768");
+module_param_named(dev_tx_fifo_size_5, dwc_otg_module_params.dev_tx_fifo_size[4], int, 0444);
+MODULE_PARM_DESC(dev_tx_fifo_size_5, "Number of words in the Tx FIFO 4-768");
+module_param_named(dev_tx_fifo_size_6, dwc_otg_module_params.dev_tx_fifo_size[5], int, 0444);
+MODULE_PARM_DESC(dev_tx_fifo_size_6, "Number of words in the Tx FIFO 4-768");
+module_param_named(dev_tx_fifo_size_7, dwc_otg_module_params.dev_tx_fifo_size[6], int, 0444);
+MODULE_PARM_DESC(dev_tx_fifo_size_7, "Number of words in the Tx FIFO 4-768");
+module_param_named(dev_tx_fifo_size_8, dwc_otg_module_params.dev_tx_fifo_size[7], int, 0444);
+MODULE_PARM_DESC(dev_tx_fifo_size_8, "Number of words in the Tx FIFO 4-768");
+module_param_named(dev_tx_fifo_size_9, dwc_otg_module_params.dev_tx_fifo_size[8], int, 0444);
+MODULE_PARM_DESC(dev_tx_fifo_size_9, "Number of words in the Tx FIFO 4-768");
+module_param_named(dev_tx_fifo_size_10, dwc_otg_module_params.dev_tx_fifo_size[9], int, 0444);
+MODULE_PARM_DESC(dev_tx_fifo_size_10, "Number of words in the Tx FIFO 4-768");
+module_param_named(dev_tx_fifo_size_11, dwc_otg_module_params.dev_tx_fifo_size[10], int, 0444);
+MODULE_PARM_DESC(dev_tx_fifo_size_11, "Number of words in the Tx FIFO 4-768");
+module_param_named(dev_tx_fifo_size_12, dwc_otg_module_params.dev_tx_fifo_size[11], int, 0444);
+MODULE_PARM_DESC(dev_tx_fifo_size_12, "Number of words in the Tx FIFO 4-768");
+module_param_named(dev_tx_fifo_size_13, dwc_otg_module_params.dev_tx_fifo_size[12], int, 0444);
+MODULE_PARM_DESC(dev_tx_fifo_size_13, "Number of words in the Tx FIFO 4-768");
+module_param_named(dev_tx_fifo_size_14, dwc_otg_module_params.dev_tx_fifo_size[13], int, 0444);
+MODULE_PARM_DESC(dev_tx_fifo_size_14, "Number of words in the Tx FIFO 4-768");
+module_param_named(dev_tx_fifo_size_15, dwc_otg_module_params.dev_tx_fifo_size[14], int, 0444);
+MODULE_PARM_DESC(dev_tx_fifo_size_15, "Number of words in the Tx FIFO 4-768");
+
+module_param_named(thr_ctl, dwc_otg_module_params.thr_ctl, int, 0444);
+MODULE_PARM_DESC(thr_ctl, "Thresholding enable flag bit 0 - non ISO Tx thr., 1 - ISO Tx thr., 2 - Rx thr.- bit 0=disabled 1=enabled");
+module_param_named(tx_thr_length, dwc_otg_module_params.tx_thr_length, int, 0444);
+MODULE_PARM_DESC(tx_thr_length, "Tx Threshold length in 32 bit DWORDs");
+module_param_named(rx_thr_length, dwc_otg_module_params.rx_thr_length, int, 0444);
+MODULE_PARM_DESC(rx_thr_length, "Rx Threshold length in 32 bit DWORDs");
+/** @page "Module Parameters"
+ *
+ * The following parameters may be specified when starting the module.
+ * These parameters define how the DWC_otg controller should be
+ * configured.	Parameter values are passed to the CIL initialization
+ * function dwc_otg_cil_init
+ *
+ * Example: <code>modprobe dwc_otg speed=1 otg_cap=1</code>
+ *
+
+ <table>
+ <tr><td>Parameter Name</td><td>Meaning</td></tr>
+
+ <tr>
+ <td>otg_cap</td>
+ <td>Specifies the OTG capabilities. The driver will automatically detect the
+ value for this parameter if none is specified.
+ - 0: HNP and SRP capable (default, if available)
+ - 1: SRP Only capable
+ - 2: No HNP/SRP capable
+ </td></tr>
+
+ <tr>
+ <td>dma_enable</td>
+ <td>Specifies whether to use slave or DMA mode for accessing the data FIFOs.
+ The driver will automatically detect the value for this parameter if none is
+ specified.
+ - 0: Slave
+ - 1: DMA (default, if available)
+ </td></tr>
+
+ <tr>
+ <td>dma_burst_size</td>
+ <td>The DMA Burst size (applicable only for External DMA Mode).
+ - Values: 1, 4, 8 16, 32, 64, 128, 256 (default 32)
+ </td></tr>
+
+ <tr>
+ <td>speed</td>
+ <td>Specifies the maximum speed of operation in host and device mode. The
+ actual speed depends on the speed of the attached device and the value of
+ phy_type.
+ - 0: High Speed (default)
+ - 1: Full Speed
+ </td></tr>
+
+ <tr>
+ <td>host_support_fs_ls_low_power</td>
+ <td>Specifies whether low power mode is supported when attached to a Full
+ Speed or Low Speed device in host mode.
+ - 0: Don't support low power mode (default)
+ - 1: Support low power mode
+ </td></tr>
+
+ <tr>
+ <td>host_ls_low_power_phy_clk</td>
+ <td>Specifies the PHY clock rate in low power mode when connected to a Low
+ Speed device in host mode. This parameter is applicable only if
+ HOST_SUPPORT_FS_LS_LOW_POWER is enabled.
+ - 0: 48 MHz (default)
+ - 1: 6 MHz
+ </td></tr>
+
+ <tr>
+ <td>enable_dynamic_fifo</td>
+ <td> Specifies whether FIFOs may be resized by the driver software.
+ - 0: Use cC FIFO size parameters
+ - 1: Allow dynamic FIFO sizing (default)
+ </td></tr>
+
+ <tr>
+ <td>data_fifo_size</td>
+ <td>Total number of 4-byte words in the data FIFO memory. This memory
+ includes the Rx FIFO, non-periodic Tx FIFO, and periodic Tx FIFOs.
+ - Values: 32 to 32768 (default 8192)
+
+ Note: The total FIFO memory depth in the FPGA configuration is 8192.
+ </td></tr>
+
+ <tr>
+ <td>dev_rx_fifo_size</td>
+ <td>Number of 4-byte words in the Rx FIFO in device mode when dynamic
+ FIFO sizing is enabled.
+ - Values: 16 to 32768 (default 1064)
+ </td></tr>
+
+ <tr>
+ <td>dev_nperio_tx_fifo_size</td>
+ <td>Number of 4-byte words in the non-periodic Tx FIFO in device mode when
+ dynamic FIFO sizing is enabled.
+ - Values: 16 to 32768 (default 1024)
+ </td></tr>
+
+ <tr>
+ <td>dev_perio_tx_fifo_size_n (n = 1 to 15)</td>
+ <td>Number of 4-byte words in each of the periodic Tx FIFOs in device mode
+ when dynamic FIFO sizing is enabled.
+ - Values: 4 to 768 (default 256)
+ </td></tr>
+
+ <tr>
+ <td>host_rx_fifo_size</td>
+ <td>Number of 4-byte words in the Rx FIFO in host mode when dynamic FIFO
+ sizing is enabled.
+ - Values: 16 to 32768 (default 1024)
+ </td></tr>
+
+ <tr>
+ <td>host_nperio_tx_fifo_size</td>
+ <td>Number of 4-byte words in the non-periodic Tx FIFO in host mode when
+ dynamic FIFO sizing is enabled in the core.
+ - Values: 16 to 32768 (default 1024)
+ </td></tr>
+
+ <tr>
+ <td>host_perio_tx_fifo_size</td>
+ <td>Number of 4-byte words in the host periodic Tx FIFO when dynamic FIFO
+ sizing is enabled.
+ - Values: 16 to 32768 (default 1024)
+ </td></tr>
+
+ <tr>
+ <td>max_transfer_size</td>
+ <td>The maximum transfer size supported in bytes.
+ - Values: 2047 to 65,535 (default 65,535)
+ </td></tr>
+
+ <tr>
+ <td>max_packet_count</td>
+ <td>The maximum number of packets in a transfer.
+ - Values: 15 to 511 (default 511)
+ </td></tr>
+
+ <tr>
+ <td>host_channels</td>
+ <td>The number of host channel registers to use.
+ - Values: 1 to 16 (default 12)
+
+ Note: The FPGA configuration supports a maximum of 12 host channels.
+ </td></tr>
+
+ <tr>
+ <td>dev_endpoints</td>
+ <td>The number of endpoints in addition to EP0 available for device mode
+ operations.
+ - Values: 1 to 15 (default 6 IN and OUT)
+
+ Note: The FPGA configuration supports a maximum of 6 IN and OUT endpoints in
+ addition to EP0.
+ </td></tr>
+
+ <tr>
+ <td>phy_type</td>
+ <td>Specifies the type of PHY interface to use. By default, the driver will
+ automatically detect the phy_type.
+ - 0: Full Speed
+ - 1: UTMI+ (default, if available)
+ - 2: ULPI
+ </td></tr>
+
+ <tr>
+ <td>phy_utmi_width</td>
+ <td>Specifies the UTMI+ Data Width. This parameter is applicable for a
+ phy_type of UTMI+. Also, this parameter is applicable only if the
+ OTG_HSPHY_WIDTH cC parameter was set to "8 and 16 bits", meaning that the
+ core has been configured to work at either data path width.
+ - Values: 8 or 16 bits (default 16)
+ </td></tr>
+
+ <tr>
+ <td>phy_ulpi_ddr</td>
+ <td>Specifies whether the ULPI operates at double or single data rate. This
+ parameter is only applicable if phy_type is ULPI.
+ - 0: single data rate ULPI interface with 8 bit wide data bus (default)
+ - 1: double data rate ULPI interface with 4 bit wide data bus
+ </td></tr>
+
+ <tr>
+ <td>i2c_enable</td>
+ <td>Specifies whether to use the I2C interface for full speed PHY. This
+ parameter is only applicable if PHY_TYPE is FS.
+ - 0: Disabled (default)
+ - 1: Enabled
+ </td></tr>
+
+ <tr>
+ <td>otg_en_multiple_tx_fifo</td>
+ <td>Specifies whether dedicatedto tx fifos are enabled for non periodic IN EPs.
+ The driver will automatically detect the value for this parameter if none is
+ specified.
+ - 0: Disabled
+ - 1: Enabled (default, if available)
+ </td></tr>
+
+ <tr>
+ <td>dev_tx_fifo_size_n (n = 1 to 15)</td>
+ <td>Number of 4-byte words in each of the Tx FIFOs in device mode
+ when dynamic FIFO sizing is enabled.
+ - Values: 4 to 768 (default 256)
+ </td></tr>
+
+*/
Index: linux-2.6.29/drivers/usb/dwc_otg/dwc_otg_driver.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/usb/dwc_otg/dwc_otg_driver.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,80 @@
+/* ==========================================================================
+ * $File: //dwh/usb_iip/dev/software/otg_ipmate/linux/drivers/dwc_otg_driver.h $
+ * $Revision: #2 $
+ * $Date: 2007/02/07 $
+ * $Change: 791271 $
+ *
+ * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
+ * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto. You are permitted to use and
+ * redistribute this Software in source and binary forms, with or without
+ * modification, provided that redistributions of source code must retain this
+ * notice. You may not view, use, disclose, copy or distribute this file or
+ * any information contained herein except pursuant to this license grant from
+ * Synopsys. If you do not agree with this notice, including the disclaimer
+ * below, then you are not authorized to use the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================== */
+
+#if !defined(__DWC_OTG_DRIVER_H__)
+#define __DWC_OTG_DRIVER_H__
+
+/** @file
+ * This file contains the interface to the Linux driver.
+ */
+#include "dwc_otg_cil.h"
+
+#define ARM_VP_OTG_INTR INT_UOTG
+/* Type declarations */
+struct dwc_otg_pcd;
+struct dwc_otg_hcd;
+
+/**
+ * This structure is a wrapper that encapsulates the driver components used to
+ * manage a single DWC_otg controller.
+ */
+typedef struct dwc_otg_device
+{
+	/** Base address returned from ioremap() */
+	void *base;
+
+	struct lm_device *lmdev;
+
+	/** Pointer to the core interface structure. */
+	dwc_otg_core_if_t *core_if;
+
+	/** Register offset for Diagnostic API.*/
+	uint32_t reg_offset;
+
+	/** Pointer to the PCD structure. */
+	struct dwc_otg_pcd *pcd;
+
+	/** Pointer to the HCD structure. */
+	struct dwc_otg_hcd *hcd;
+
+	/** Flag to indicate whether the common IRQ handler is installed. */
+	uint8_t common_irq_installed;
+
+	uint8_t flagID;
+	uint8_t flagDeviceVBUS;
+	uint8_t flagDeviceAttach;
+	uint8_t flagMode, flagMode_backup;
+	struct task_struct	*vbus_usb_task;
+} dwc_otg_device_t;
+
+#endif
Index: linux-2.6.29/drivers/usb/dwc_otg/dwc_otg_hcd.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/usb/dwc_otg/dwc_otg_hcd.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,2760 @@
+/* ==========================================================================
+ * $File: //dwh/usb_iip/dev/software/otg_ipmate/linux/drivers/dwc_otg_hcd.c $
+ * $Revision: #16 $
+ * $Date: 2006/12/05 $
+ * $Change: 762293 $
+ *
+ * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
+ * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto. You are permitted to use and
+ * redistribute this Software in source and binary forms, with or without
+ * modification, provided that redistributions of source code must retain this
+ * notice. You may not view, use, disclose, copy or distribute this file or
+ * any information contained herein except pursuant to this license grant from
+ * Synopsys. If you do not agree with this notice, including the disclaimer
+ * below, then you are not authorized to use the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================== */
+#ifndef DWC_DEVICE_ONLY
+
+/**
+ * @file
+ *
+ * This file contains the implementation of the HCD. In Linux, the HCD
+ * implements the hc_driver API.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+#include <linux/dma-mapping.h>
+
+#ifdef _USE_ATTR_
+#include <asm/arch/lm.h>
+#endif
+
+#include "dwc_otg_driver.h"
+#include "dwc_otg_hcd.h"
+#include "dwc_otg_regs.h"
+
+static const char dwc_otg_hcd_name [] = "dwc_otg_hcd";
+
+static const struct hc_driver dwc_otg_hc_driver = {
+
+	.description =		dwc_otg_hcd_name,
+	.product_desc = 	"DWC OTG Controller",
+	.hcd_priv_size = 	sizeof(dwc_otg_hcd_t),
+
+	.irq =			dwc_otg_hcd_irq,
+
+	.flags =		HCD_MEMORY | HCD_USB2,
+
+	//.reset =
+	.start =		dwc_otg_hcd_start,
+	//.suspend =
+	//.resume =
+	.stop =			dwc_otg_hcd_stop,
+
+	.urb_enqueue =		dwc_otg_hcd_urb_enqueue,
+	.urb_dequeue =		dwc_otg_hcd_urb_dequeue,
+	.endpoint_disable =	dwc_otg_hcd_endpoint_disable,
+
+	.get_frame_number =	dwc_otg_hcd_get_frame_number,
+
+	.hub_status_data =	dwc_otg_hcd_hub_status_data,
+	.hub_control =		dwc_otg_hcd_hub_control,
+	//.hub_suspend =
+	//.hub_resume =
+};
+
+
+
+/**
+ * Work queue function for starting the HCD when A-Cable is connected.
+ * The dwc_otg_hcd_start() must be called in a process context.
+ */
+static void hcd_start_func(struct work_struct *work)
+{
+	dwc_otg_hcd_t *dwc_otg_hcd = container_of(work, struct dwc_otg_hcd, start_work);
+	struct usb_hcd *usb_hcd = dwc_otg_hcd_to_hcd(dwc_otg_hcd);
+
+	DWC_DEBUGPL(DBG_HCDV, "%s() %p\n", __func__, usb_hcd);
+	if (usb_hcd) {
+		dwc_otg_hcd_start(usb_hcd);
+	}
+}
+
+/**
+ * HCD Callback function for starting the HCD when A-Cable is
+ * connected.
+ *
+ * @param _p void pointer to the <code>struct usb_hcd</code>
+ */
+static int32_t dwc_otg_hcd_start_cb(void *_p)
+{
+	dwc_otg_hcd_t *dwc_otg_hcd = hcd_to_dwc_otg_hcd(_p);
+	dwc_otg_core_if_t *core_if = dwc_otg_hcd->core_if;
+	hprt0_data_t hprt0;
+
+	if (core_if->op_state == B_HOST) {
+		/*
+		 * Reset the port.  During a HNP mode switch the reset
+		 * needs to occur within 1ms and have a duration of at
+		 * least 50ms.
+		 */
+		hprt0.d32 = dwc_otg_read_hprt0 (core_if);
+		hprt0.b.prtrst = 1;
+		dwc_write_reg32(core_if->host_if->hprt0, hprt0.d32);
+		((struct usb_hcd *)_p)->self.is_b_host = 1;
+	} else {
+		((struct usb_hcd *)_p)->self.is_b_host = 0;
+	}
+
+	/* Need to start the HCD in a non-interrupt context. */
+	INIT_WORK(&dwc_otg_hcd->start_work, hcd_start_func);
+	schedule_work(&dwc_otg_hcd->start_work);
+
+	return 1;
+}
+
+
+/**
+ * HCD Callback function for stopping the HCD.
+ *
+ * @param _p void pointer to the <code>struct usb_hcd</code>
+ */
+static int32_t dwc_otg_hcd_stop_cb( void *_p )
+{
+	struct usb_hcd *usb_hcd = (struct usb_hcd *)_p;
+	DWC_DEBUGPL(DBG_HCDV, "%s(%p)\n", __func__, _p);
+	dwc_otg_hcd_stop( usb_hcd );
+	return 1;
+}
+
+static void del_xfer_timers(dwc_otg_hcd_t *_hcd)
+{
+#ifdef DEBUG
+	int i;
+	int num_channels = _hcd->core_if->core_params->host_channels;
+	for (i = 0; i < num_channels; i++) {
+		del_timer(&_hcd->core_if->hc_xfer_timer[i]);
+	}
+#endif
+}
+
+static void del_timers(dwc_otg_hcd_t *_hcd)
+{
+	del_xfer_timers(_hcd);
+	del_timer(&_hcd->conn_timer);
+}
+
+/**
+ * Processes all the URBs in a single list of QHs. Completes them with
+ * -ETIMEDOUT and frees the QTD.
+ */
+static void kill_urbs_in_qh_list(dwc_otg_hcd_t *_hcd, struct list_head *_qh_list)
+{
+	struct list_head	*qh_item;
+	dwc_otg_qh_t		*qh;
+	struct list_head	*qtd_item;
+	dwc_otg_qtd_t		*qtd;
+
+	list_for_each(qh_item, _qh_list) {
+		qh = list_entry(qh_item, dwc_otg_qh_t, qh_list_entry);
+		for (qtd_item = qh->qtd_list.next;
+		        qtd_item != &qh->qtd_list;
+		        qtd_item = qh->qtd_list.next) {
+			qtd = list_entry(qtd_item, dwc_otg_qtd_t, qtd_list_entry);
+			if (qtd->urb != NULL) {
+				dwc_otg_hcd_complete_urb(_hcd, qtd->urb,
+				                         -ETIMEDOUT);
+			}
+			dwc_otg_hcd_qtd_remove_and_free(qtd);
+		}
+	}
+}
+
+/**
+ * Responds with an error status of ETIMEDOUT to all URBs in the non-periodic
+ * and periodic schedules. The QTD associated with each URB is removed from
+ * the schedule and freed. This function may be called when a disconnect is
+ * detected or when the HCD is being stopped.
+ */
+static void kill_all_urbs(dwc_otg_hcd_t *_hcd)
+{
+	kill_urbs_in_qh_list(_hcd, &_hcd->non_periodic_sched_inactive);
+	kill_urbs_in_qh_list(_hcd, &_hcd->non_periodic_sched_active);
+	kill_urbs_in_qh_list(_hcd, &_hcd->periodic_sched_inactive);
+	kill_urbs_in_qh_list(_hcd, &_hcd->periodic_sched_ready);
+	kill_urbs_in_qh_list(_hcd, &_hcd->periodic_sched_assigned);
+	kill_urbs_in_qh_list(_hcd, &_hcd->periodic_sched_queued);
+}
+
+/**
+ * HCD Callback function for disconnect of the HCD.
+ *
+ * @param _p void pointer to the <code>struct usb_hcd</code>
+ */
+static int32_t dwc_otg_hcd_disconnect_cb( void *_p )
+{
+	gintsts_data_t 	intr;
+	dwc_otg_hcd_t 	*dwc_otg_hcd = hcd_to_dwc_otg_hcd (_p);
+
+	//DWC_DEBUGPL(DBG_HCDV, "%s(%p)\n", __func__, _p);
+
+	/*
+	 * Set status flags for the hub driver.
+	 */
+	dwc_otg_hcd->flags.b.port_connect_status_change = 1;
+	dwc_otg_hcd->flags.b.port_connect_status = 0;
+
+	/*
+	 * Shutdown any transfers in process by clearing the Tx FIFO Empty
+	 * interrupt mask and status bits and disabling subsequent host
+	 * channel interrupts.
+	 */
+	intr.d32 = 0;
+	intr.b.nptxfempty = 1;
+	intr.b.ptxfempty = 1;
+	intr.b.hcintr = 1;
+	dwc_modify_reg32 (&dwc_otg_hcd->core_if->core_global_regs->gintmsk, intr.d32, 0);
+	dwc_modify_reg32 (&dwc_otg_hcd->core_if->core_global_regs->gintsts, intr.d32, 0);
+
+	del_timers(dwc_otg_hcd);
+
+	/*
+	 * Turn off the vbus power only if the core has transitioned to device
+	 * mode. If still in host mode, need to keep power on to detect a
+	 * reconnection.
+	 */
+	if (dwc_otg_is_device_mode(dwc_otg_hcd->core_if)) {
+		if (dwc_otg_hcd->core_if->op_state != A_SUSPEND) {
+			dwc_otg_hcd->core_if->vbus_state = 0;
+			schedule_work(&dwc_otg_hcd->core_if->vbus_work);
+			DWC_PRINT("Disconnect: PortPower off\n");
+		}
+
+		dwc_otg_disable_host_interrupts( dwc_otg_hcd->core_if );
+	}
+
+	/* Respond with an error status to all URBs in the schedule. */
+	kill_all_urbs(dwc_otg_hcd);
+
+	if (dwc_otg_is_host_mode(dwc_otg_hcd->core_if)) {
+		/* Clean up any host channels that were in use. */
+		int			num_channels;
+		int			i;
+		dwc_hc_t		*channel;
+		dwc_otg_hc_regs_t	*hc_regs;
+		hcchar_data_t		hcchar;
+
+		num_channels = dwc_otg_hcd->core_if->core_params->host_channels;
+
+		if (!dwc_otg_hcd->core_if->dma_enable) {
+			/* Flush out any channel requests in slave mode. */
+			for (i = 0; i < num_channels; i++) {
+				channel = dwc_otg_hcd->hc_ptr_array[i];
+				if (list_empty(&channel->hc_list_entry)) {
+					hc_regs = dwc_otg_hcd->core_if->host_if->hc_regs[i];
+					hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+					if (hcchar.b.chen) {
+						hcchar.b.chen = 0;
+						hcchar.b.chdis = 1;
+						hcchar.b.epdir = 0;
+						dwc_write_reg32(&hc_regs->hcchar, hcchar.d32);
+					}
+				}
+			}
+		}
+
+		for (i = 0; i < num_channels; i++) {
+			channel = dwc_otg_hcd->hc_ptr_array[i];
+			if (list_empty(&channel->hc_list_entry)) {
+				hc_regs = dwc_otg_hcd->core_if->host_if->hc_regs[i];
+				hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+				if (hcchar.b.chen) {
+					/* Halt the channel. */
+					hcchar.b.chdis = 1;
+					dwc_write_reg32(&hc_regs->hcchar, hcchar.d32);
+				}
+
+				dwc_otg_hc_cleanup(dwc_otg_hcd->core_if, channel);
+				list_add_tail(&channel->hc_list_entry,
+				              &dwc_otg_hcd->free_hc_list);
+			}
+		}
+	}
+
+	/* A disconnect will end the session so the B-Device is no
+	 * longer a B-host. */
+	((struct usb_hcd *)_p)->self.is_b_host = 0;
+	return 1;
+}
+
+/**
+ * Connection timeout function.  An OTG host is required to display a
+ * message if the device does not connect within 10 seconds.
+ */
+void dwc_otg_hcd_connect_timeout( unsigned long _ptr )
+{
+	DWC_DEBUGPL(DBG_HCDV, "%s(%x)\n", __func__, (int)_ptr);
+	DWC_PRINT( "Connect Timeout\n");
+	DWC_ERROR( "Device Not Connected/Responding\n" );
+}
+
+/**
+ * Start the connection timer.  An OTG host is required to display a
+ * message if the device does not connect within 10 seconds.  The
+ * timer is deleted if a port connect interrupt occurs before the
+ * timer expires.
+ */
+static void dwc_otg_hcd_start_connect_timer( dwc_otg_hcd_t *_hcd)
+{
+	init_timer( &_hcd->conn_timer );
+	_hcd->conn_timer.function = dwc_otg_hcd_connect_timeout;
+	_hcd->conn_timer.data = (unsigned long)0;
+	_hcd->conn_timer.expires = jiffies + (HZ*10);
+	add_timer( &_hcd->conn_timer );
+}
+
+/**
+ * HCD Callback function for disconnect of the HCD.
+ *
+ * @param _p void pointer to the <code>struct usb_hcd</code>
+ */
+static int32_t dwc_otg_hcd_session_start_cb( void *_p )
+{
+	dwc_otg_hcd_t *dwc_otg_hcd = hcd_to_dwc_otg_hcd (_p);
+	DWC_DEBUGPL(DBG_HCDV, "%s(%p)\n", __func__, _p);
+	dwc_otg_hcd_start_connect_timer( dwc_otg_hcd );
+	return 1;
+}
+
+/**
+ * HCD Callback structure for handling mode switching.
+ */
+static dwc_otg_cil_callbacks_t hcd_cil_callbacks = {
+	.start = dwc_otg_hcd_start_cb,
+	.stop = dwc_otg_hcd_stop_cb,
+	.disconnect = dwc_otg_hcd_disconnect_cb,
+	.session_start = dwc_otg_hcd_session_start_cb,
+	.p = 0,
+};
+
+
+/**
+ * Reset tasklet function
+ */
+static void reset_tasklet_func (unsigned long data)
+{
+	dwc_otg_hcd_t *dwc_otg_hcd = (dwc_otg_hcd_t*)data;
+	dwc_otg_core_if_t *core_if = dwc_otg_hcd->core_if;
+	hprt0_data_t hprt0;
+
+	DWC_DEBUGPL(DBG_HCDV, "USB RESET tasklet called\n");
+
+	hprt0.d32 = dwc_otg_read_hprt0 (core_if);
+	hprt0.b.prtrst = 1;
+	dwc_write_reg32(core_if->host_if->hprt0, hprt0.d32);
+	mdelay (60);
+
+	hprt0.b.prtrst = 0;
+	dwc_write_reg32(core_if->host_if->hprt0, hprt0.d32);
+	dwc_otg_hcd->flags.b.port_reset_change = 1;
+
+	return;
+}
+
+static struct tasklet_struct reset_tasklet = {
+	.next = NULL,
+	.state = 0,
+	.count = ATOMIC_INIT(0),
+	.func = reset_tasklet_func,
+	.data = 0,
+};
+
+/**
+ * Initializes the HCD. This function allocates memory for and initializes the
+ * static parts of the usb_hcd and dwc_otg_hcd structures. It also registers the
+ * USB bus with the core and calls the hc_driver->start() function. It returns
+ * a negative error on failure.
+ */
+static u64 dwc_otg_dmamask = 0xffffffffUL;
+int __init dwc_otg_hcd_init(struct device *dev)
+{
+	struct usb_hcd *hcd = NULL;
+	dwc_otg_hcd_t *dwc_otg_hcd = NULL;
+	dwc_otg_device_t *otg_dev = dev_get_otgdata(dev);
+
+	int 		num_channels;
+	int 		i;
+	dwc_hc_t	*channel;
+
+	int retval = 0;
+
+	DWC_DEBUGPL(DBG_HCD, "DWC OTG HCD INIT\n");
+	DWC_DEBUGPL(DBG_CILV, "%s: dwc_otg_device(%p)\n", __func__, otg_dev);
+
+	/*
+	 * Allocate memory for the base HCD plus the DWC OTG HCD.
+	 * Initialize the base HCD.
+	 */
+	hcd = usb_create_hcd(&dwc_otg_hc_driver, dev, "DWC OTG Controller");
+	if (hcd == NULL) {
+		retval = -ENOMEM;
+		goto error1;
+	}
+	hcd->regs = otg_dev->base;
+	hcd->self.otg_port = 1;
+
+	/* Initialize the DWC OTG HCD. */
+	dwc_otg_hcd = hcd_to_dwc_otg_hcd(hcd);
+	dwc_otg_hcd->core_if = otg_dev->core_if;
+	otg_dev->hcd = dwc_otg_hcd;
+
+	/* Register the HCD CIL Callbacks */
+	dwc_otg_cil_register_hcd_callbacks(otg_dev->core_if,
+	                                   &hcd_cil_callbacks, hcd);
+
+	/* Initialize the non-periodic schedule. */
+	INIT_LIST_HEAD(&dwc_otg_hcd->non_periodic_sched_inactive);
+	INIT_LIST_HEAD(&dwc_otg_hcd->non_periodic_sched_active);
+
+	/* Initialize the periodic schedule. */
+	INIT_LIST_HEAD(&dwc_otg_hcd->periodic_sched_inactive);
+	INIT_LIST_HEAD(&dwc_otg_hcd->periodic_sched_ready);
+	INIT_LIST_HEAD(&dwc_otg_hcd->periodic_sched_assigned);
+	INIT_LIST_HEAD(&dwc_otg_hcd->periodic_sched_queued);
+
+	/*
+	 * Create a host channel descriptor for each host channel implemented
+	 * in the controller. Initialize the channel descriptor array.
+	 */
+	INIT_LIST_HEAD(&dwc_otg_hcd->free_hc_list);
+	num_channels = dwc_otg_hcd->core_if->core_params->host_channels;
+	for (i = 0; i < num_channels; i++) {
+		channel = kmalloc(sizeof(dwc_hc_t), GFP_KERNEL);
+		if (channel == NULL) {
+			retval = -ENOMEM;
+			DWC_ERROR("%s: host channel allocation failed\n", __func__);
+			goto error2;
+		}
+		memset(channel, 0, sizeof(dwc_hc_t));
+		channel->hc_num = i;
+		dwc_otg_hcd->hc_ptr_array[i] = channel;
+#ifdef DEBUG
+		init_timer(&dwc_otg_hcd->core_if->hc_xfer_timer[i]);
+#endif
+
+		DWC_DEBUGPL(DBG_HCDV, "HCD Added channel #%d, hc=%p\n", i, channel);
+	}
+
+	/* Initialize the Connection timeout timer. */
+	init_timer( &dwc_otg_hcd->conn_timer );
+
+	/* Initialize reset tasklet. */
+	reset_tasklet.data = (unsigned long) dwc_otg_hcd;
+	dwc_otg_hcd->reset_tasklet = &reset_tasklet;
+
+	/* Set device flags indicating whether the HCD supports DMA. */
+	if (otg_dev->core_if->dma_enable) {
+		DWC_PRINT("Using DMA mode\n");
+		//dev->dma_mask = (void *)~0;
+		//dev->coherent_dma_mask = ~0;
+		dev->dma_mask = &dwc_otg_dmamask;
+		dev->coherent_dma_mask = ~0;
+	} else {
+		DWC_PRINT("Using Slave mode\n");
+		dev->dma_mask = (void *)0;
+		dev->coherent_dma_mask = 0;
+	}
+
+	/*
+	 * Finish generic HCD initialization and start the HCD. This function
+	 * allocates the DMA buffer pool, registers the USB bus, requests the
+	 * IRQ line, and calls dwc_otg_hcd_start method.
+	 */
+	retval = usb_add_hcd(hcd, ARM_VP_OTG_INTR, IRQF_SHARED);
+	if (retval < 0) {
+		goto error2;
+	}
+
+	/*
+	 * Allocate space for storing data on status transactions. Normally no
+	 * data is sent, but this space acts as a bit bucket. This must be
+	 * done after usb_add_hcd since that function allocates the DMA buffer
+	 * pool.
+	 */
+	if (otg_dev->core_if->dma_enable) {
+		dwc_otg_hcd->status_buf =
+		    dma_alloc_coherent(dev,
+		                       DWC_OTG_HCD_STATUS_BUF_SIZE,
+		                       &dwc_otg_hcd->status_buf_dma,
+		                       GFP_KERNEL | GFP_DMA);
+	} else {
+		dwc_otg_hcd->status_buf = kmalloc(DWC_OTG_HCD_STATUS_BUF_SIZE,
+		                                  GFP_KERNEL);
+	}
+	if (dwc_otg_hcd->status_buf == NULL) {
+		retval = -ENOMEM;
+		DWC_ERROR("%s: status_buf allocation failed\n", __func__);
+		goto error3;
+	}
+
+	DWC_DEBUGPL(DBG_HCD, "DWC OTG HCD Initialized HCD, bus=%s, usbbus=%d\n",
+	            "DWC OTG Controller", hcd->self.busnum);
+
+	return 0;
+
+	/* Error conditions */
+error3:
+	usb_remove_hcd(hcd);
+error2:
+	dwc_otg_hcd_free(hcd);
+	usb_put_hcd(hcd);
+error1:
+	return retval;
+}
+
+/**
+ * Removes the HCD.
+ * Frees memory and resources associated with the HCD and deregisters the bus.
+ */
+void dwc_otg_hcd_remove(struct device *dev)
+{
+	dwc_otg_device_t *otg_dev = dev_get_otgdata(dev);
+	dwc_otg_hcd_t *dwc_otg_hcd;
+	struct usb_hcd *hcd;
+
+	DWC_DEBUGPL(DBG_HCD, "DWC OTG HCD REMOVE\n");
+
+	/* Turn off all interrupts */
+	dwc_otg_hcd = otg_dev->hcd;
+	dwc_write_reg32 (&dwc_otg_hcd->core_if->core_global_regs->gintmsk, 0);
+	dwc_modify_reg32 (&dwc_otg_hcd->core_if->core_global_regs->gahbcfg, 1, 0);
+
+	/* Release hcd driver */
+	hcd = dwc_otg_hcd_to_hcd(dwc_otg_hcd);
+	usb_remove_hcd(hcd);
+	dwc_otg_hcd_free(hcd);
+	usb_put_hcd(hcd);
+
+	return;
+}
+
+
+/* =========================================================================
+ *  Linux HC Driver Functions
+ * ========================================================================= */
+
+/**
+ * Initializes dynamic portions of the DWC_otg HCD state.
+ */
+static void hcd_reinit(dwc_otg_hcd_t *_hcd)
+{
+	struct list_head 	*item;
+	int			num_channels;
+	int			i;
+	dwc_hc_t		*channel;
+
+	_hcd->flags.d32 = 0;
+
+	_hcd->non_periodic_qh_ptr = &_hcd->non_periodic_sched_active;
+	_hcd->non_periodic_channels = 0;
+	_hcd->periodic_channels = 0;
+
+	/*
+	 * Put all channels in the free channel list and clean up channel
+	 * states.
+	 */
+	item = _hcd->free_hc_list.next;
+	while (item != &_hcd->free_hc_list) {
+		list_del(item);
+		item = _hcd->free_hc_list.next;
+	}
+	num_channels = _hcd->core_if->core_params->host_channels;
+	for (i = 0; i < num_channels; i++) {
+		channel = _hcd->hc_ptr_array[i];
+		list_add_tail(&channel->hc_list_entry, &_hcd->free_hc_list);
+		dwc_otg_hc_cleanup(_hcd->core_if, channel);
+	}
+
+	/* Initialize the DWC core for host mode operation. */
+	dwc_otg_core_host_init(_hcd->core_if);
+}
+
+/** Initializes the DWC_otg controller and its root hub and prepares it for host
+ * mode operation. Activates the root port. Returns 0 on success and a negative
+ * error code on failure. */
+int dwc_otg_hcd_start(struct usb_hcd *_hcd)
+{
+	dwc_otg_hcd_t *dwc_otg_hcd = hcd_to_dwc_otg_hcd (_hcd);
+	dwc_otg_core_if_t *core_if = dwc_otg_hcd->core_if;
+	struct usb_bus *bus;
+
+	DWC_DEBUGPL(DBG_HCD, "DWC OTG HCD START\n");
+
+	bus = hcd_to_bus(_hcd);
+
+	/* Initialize the bus state.  If the core is in Device Mode
+	 * HALT the USB bus and return. */
+	if (dwc_otg_is_device_mode (core_if)) {
+		_hcd->state = HC_STATE_HALT;
+		return 0;
+	}
+	_hcd->state = HC_STATE_RUNNING;
+
+	/* Initialize and connect root hub if one is not already attached */
+	if (bus->root_hub) {
+		DWC_DEBUGPL(DBG_HCD, "DWC OTG HCD Has Root Hub\n");
+		/* Inform the HUB driver to resume. */
+		usb_hcd_resume_root_hub(_hcd);
+	} else {
+		DWC_DEBUGPL(DBG_HCD, "\n!!!!! DWC OTG HCD Has Not Root Hub !!!!!\n");
+		return -ENODEV;
+	}
+
+	hcd_reinit(dwc_otg_hcd);
+
+	return 0;
+}
+
+static void qh_list_free(dwc_otg_hcd_t *_hcd, struct list_head *_qh_list)
+{
+	struct list_head 	*item;
+	dwc_otg_qh_t		*qh;
+
+	if (_qh_list->next == NULL) {
+		/* The list hasn't been initialized yet. */
+		return;
+	}
+
+	/* Ensure there are no QTDs or URBs left. */
+	kill_urbs_in_qh_list(_hcd, _qh_list);
+
+	for (item = _qh_list->next; item != _qh_list; item = _qh_list->next) {
+		qh = list_entry(item, dwc_otg_qh_t, qh_list_entry);
+		dwc_otg_hcd_qh_remove_and_free(_hcd, qh);
+	}
+}
+
+/**
+ * Halts the DWC_otg host mode operations in a clean manner. USB transfers are
+ * stopped.
+ */
+void dwc_otg_hcd_stop(struct usb_hcd *_hcd)
+{
+	dwc_otg_hcd_t *dwc_otg_hcd = hcd_to_dwc_otg_hcd (_hcd);
+
+	DWC_DEBUGPL(DBG_HCD, "DWC OTG HCD STOP\n");
+
+	/* Turn off all host-specific interrupts. */
+	dwc_otg_disable_host_interrupts( dwc_otg_hcd->core_if );
+
+	/*
+	 * The root hub should be disconnected before this function is called.
+	 * The disconnect will clear the QTD lists (via ..._hcd_urb_dequeue)
+	 * and the QH lists (via ..._hcd_endpoint_disable).
+	 */
+
+	/* Turn off the vbus power */
+	DWC_PRINT("PortPower off\n");
+	dwc_otg_hcd->core_if->vbus_state = 0;
+	schedule_work(&dwc_otg_hcd->core_if->vbus_work);
+
+	return;
+}
+
+
+/** Returns the current frame number. */
+int dwc_otg_hcd_get_frame_number(struct usb_hcd *_hcd)
+{
+	dwc_otg_hcd_t *dwc_otg_hcd = hcd_to_dwc_otg_hcd(_hcd);
+	hfnum_data_t hfnum;
+
+	hfnum.d32 = dwc_read_reg32(&dwc_otg_hcd->core_if->
+	                           host_if->host_global_regs->hfnum);
+
+#ifdef DEBUG_SOF
+	DWC_DEBUGPL(DBG_HCDV, "DWC OTG HCD GET FRAME NUMBER %d\n", hfnum.b.frnum);
+#endif
+	return hfnum.b.frnum;
+}
+
+/**
+ * Frees secondary storage associated with the dwc_otg_hcd structure contained
+ * in the struct usb_hcd field.
+ */
+void dwc_otg_hcd_free(struct usb_hcd *_hcd)
+{
+	dwc_otg_hcd_t 	*dwc_otg_hcd = hcd_to_dwc_otg_hcd(_hcd);
+	int		i;
+
+	DWC_DEBUGPL(DBG_HCD, "DWC OTG HCD FREE\n");
+
+	del_timers(dwc_otg_hcd);
+
+	/* Free memory for QH/QTD lists */
+	qh_list_free(dwc_otg_hcd, &dwc_otg_hcd->non_periodic_sched_inactive);
+	qh_list_free(dwc_otg_hcd, &dwc_otg_hcd->non_periodic_sched_active);
+	qh_list_free(dwc_otg_hcd, &dwc_otg_hcd->periodic_sched_inactive);
+	qh_list_free(dwc_otg_hcd, &dwc_otg_hcd->periodic_sched_ready);
+	qh_list_free(dwc_otg_hcd, &dwc_otg_hcd->periodic_sched_assigned);
+	qh_list_free(dwc_otg_hcd, &dwc_otg_hcd->periodic_sched_queued);
+
+	/* Free memory for the host channels. */
+	for (i = 0; i < MAX_EPS_CHANNELS; i++) {
+		dwc_hc_t *hc = dwc_otg_hcd->hc_ptr_array[i];
+		if (hc != NULL) {
+			DWC_DEBUGPL(DBG_HCDV, "HCD Free channel #%i, hc=%p\n", i, hc);
+			kfree(hc);
+		}
+	}
+
+	if (dwc_otg_hcd->core_if->dma_enable) {
+		if (dwc_otg_hcd->status_buf_dma) {
+			dma_free_coherent(_hcd->self.controller,
+			                  DWC_OTG_HCD_STATUS_BUF_SIZE,
+			                  dwc_otg_hcd->status_buf,
+			                  dwc_otg_hcd->status_buf_dma);
+		}
+	} else if (dwc_otg_hcd->status_buf != NULL) {
+		kfree(dwc_otg_hcd->status_buf);
+	}
+
+	return;
+}
+
+
+#ifdef DEBUG
+static void dump_urb_info(struct urb *_urb, char* _fn_name)
+{
+	DWC_PRINT("%s, urb %p\n", _fn_name, _urb);
+	DWC_PRINT("  Device address: %d\n", usb_pipedevice(_urb->pipe));
+	DWC_PRINT("  Endpoint: %d, %s\n", usb_pipeendpoint(_urb->pipe),
+	          (usb_pipein(_urb->pipe) ? "IN" : "OUT"));
+	DWC_PRINT("  Endpoint type: %s\n",
+		  ({char *pipetype;
+		  switch (usb_pipetype(_urb->pipe)) {
+		  case PIPE_CONTROL: pipetype = "CONTROL"; break;
+		  case PIPE_BULK: pipetype = "BULK"; break;
+		  case PIPE_INTERRUPT: pipetype = "INTERRUPT"; break;
+		  case PIPE_ISOCHRONOUS: pipetype = "ISOCHRONOUS"; break;
+		  default: pipetype = "UNKNOWN"; break;
+		  }; pipetype;}));
+	DWC_PRINT("  Speed: %s\n",
+		  ({char *speed;
+		  switch (_urb->dev->speed) {
+		  case USB_SPEED_HIGH: speed = "HIGH"; break;
+		  case USB_SPEED_FULL: speed = "FULL"; break;
+		  case USB_SPEED_LOW: speed = "LOW"; break;
+		  default: speed = "UNKNOWN"; break;
+		  }; speed;}));
+	DWC_PRINT("  Max packet size: %d\n",
+	          usb_maxpacket(_urb->dev, _urb->pipe, usb_pipeout(_urb->pipe)));
+	DWC_PRINT("  Data buffer length: %d\n", _urb->transfer_buffer_length);
+	DWC_PRINT("  Transfer buffer: %p, Transfer DMA: %p\n",
+	          _urb->transfer_buffer, (void *)_urb->transfer_dma);
+	DWC_PRINT("  Setup buffer: %p, Setup DMA: %p\n",
+	          _urb->setup_packet, (void *)_urb->setup_dma);
+	DWC_PRINT("  Interval: %d\n", _urb->interval);
+	if (usb_pipetype(_urb->pipe) == PIPE_ISOCHRONOUS) {
+		int i;
+		for (i = 0; i < _urb->number_of_packets;  i++) {
+			DWC_PRINT("  ISO Desc %d:\n", i);
+			DWC_PRINT("    offset: %d, length %d\n",
+			          _urb->iso_frame_desc[i].offset,
+			          _urb->iso_frame_desc[i].length);
+		}
+	}
+}
+
+static void dump_channel_info(dwc_otg_hcd_t *_hcd,
+                              dwc_otg_qh_t *qh)
+{
+	if (qh->channel != NULL) {
+		dwc_hc_t *hc = qh->channel;
+		struct list_head *item;
+		dwc_otg_qh_t *qh_item;
+		int num_channels = _hcd->core_if->core_params->host_channels;
+		int i;
+
+		dwc_otg_hc_regs_t *hc_regs;
+		hcchar_data_t 	hcchar;
+		hcsplt_data_t	hcsplt;
+		hctsiz_data_t 	hctsiz;
+		uint32_t	hcdma;
+
+		hc_regs = _hcd->core_if->host_if->hc_regs[hc->hc_num];
+		hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+		hcsplt.d32 = dwc_read_reg32(&hc_regs->hcsplt);
+		hctsiz.d32 = dwc_read_reg32(&hc_regs->hctsiz);
+		hcdma = dwc_read_reg32(&hc_regs->hcdma);
+
+		DWC_PRINT("  Assigned to channel %p:\n", hc);
+		DWC_PRINT("    hcchar 0x%08x, hcsplt 0x%08x\n", hcchar.d32, hcsplt.d32);
+		DWC_PRINT("    hctsiz 0x%08x, hcdma 0x%08x\n", hctsiz.d32, hcdma);
+		DWC_PRINT("    dev_addr: %d, ep_num: %d, ep_is_in: %d\n",
+		          hc->dev_addr, hc->ep_num, hc->ep_is_in);
+		DWC_PRINT("    ep_type: %d\n", hc->ep_type);
+		DWC_PRINT("    max_packet: %d\n", hc->max_packet);
+		DWC_PRINT("    data_pid_start: %d\n", hc->data_pid_start);
+		DWC_PRINT("    xfer_started: %d\n", hc->xfer_started);
+		DWC_PRINT("    halt_status: %d\n", hc->halt_status);
+		DWC_PRINT("    xfer_buff: %p\n", hc->xfer_buff);
+		DWC_PRINT("    xfer_len: %d\n", hc->xfer_len);
+		DWC_PRINT("    qh: %p\n", hc->qh);
+		DWC_PRINT("  NP inactive sched:\n");
+		list_for_each(item, &_hcd->non_periodic_sched_inactive) {
+			qh_item = list_entry(item, dwc_otg_qh_t, qh_list_entry);
+			DWC_PRINT("    %p\n", qh_item);
+		}
+		DWC_PRINT("  NP active sched:\n");
+		list_for_each(item, &_hcd->non_periodic_sched_active) {
+			qh_item = list_entry(item, dwc_otg_qh_t, qh_list_entry);
+			DWC_PRINT("    %p\n", qh_item);
+		}
+		DWC_PRINT("  Channels: \n");
+		for (i = 0; i < num_channels; i++) {
+			dwc_hc_t *hc = _hcd->hc_ptr_array[i];
+			DWC_PRINT("    %2d: %p\n", i, hc);
+		}
+	}
+}
+#endif
+
+/** Starts processing a USB transfer request specified by a USB Request Block
+ * (URB). mem_flags indicates the type of memory allocation to use while
+ * processing this URB. */
+int dwc_otg_hcd_urb_enqueue(struct usb_hcd *_hcd,
+                            struct urb *_urb,
+                            gfp_t _mem_flags)
+{
+	int retval = 0;
+	dwc_otg_hcd_t *dwc_otg_hcd = hcd_to_dwc_otg_hcd (_hcd);
+	dwc_otg_qtd_t *qtd;
+
+#ifdef DEBUG
+	if (CHK_DEBUG_LEVEL(DBG_HCD_URB)) {
+		dump_urb_info(_urb, "dwc_otg_hcd_urb_enqueue");
+	}
+#endif
+	if (!dwc_otg_hcd->flags.b.port_connect_status) {
+		/* No longer connected. */
+		return -ENODEV;
+	}
+
+	qtd = dwc_otg_hcd_qtd_create (_urb);
+	if (qtd == NULL) {
+		DWC_ERROR("DWC OTG HCD URB Enqueue failed creating QTD\n");
+		return -ENOMEM;
+	}
+
+	retval = dwc_otg_hcd_qtd_add (qtd, dwc_otg_hcd);
+	if (retval < 0) {
+		DWC_ERROR("DWC OTG HCD URB Enqueue failed adding QTD. "
+		          "Error status %d\n", retval);
+		dwc_otg_hcd_qtd_free(qtd);
+	}
+
+	return retval;
+}
+
+/** Aborts/cancels a USB transfer request. Always returns 0 to indicate
+ * success.  */
+int dwc_otg_hcd_urb_dequeue(struct usb_hcd *_hcd,
+                            struct urb *_urb,
+                            int status)
+{
+	unsigned long flags;
+	dwc_otg_hcd_t *dwc_otg_hcd;
+	dwc_otg_qtd_t *urb_qtd;
+	dwc_otg_qh_t *qh;
+	struct usb_host_endpoint *_ep = dwc_urb_to_endpoint(_urb);
+
+
+	DWC_DEBUGPL(DBG_HCD, "DWC OTG HCD URB Dequeue\n");
+
+	local_irq_save(flags);
+
+	dwc_otg_hcd = hcd_to_dwc_otg_hcd(_hcd);
+	urb_qtd = (dwc_otg_qtd_t *)_urb->hcpriv;
+	qh = (dwc_otg_qh_t *)_ep->hcpriv;
+
+#ifdef DEBUG
+	if (CHK_DEBUG_LEVEL(DBG_HCD_URB)) {
+		dump_urb_info(_urb, "dwc_otg_hcd_urb_dequeue");
+		if (urb_qtd == qh->qtd_in_process) {
+			dump_channel_info(dwc_otg_hcd, qh);
+		}
+	}
+#endif
+
+	if (urb_qtd == qh->qtd_in_process) {
+		/* The QTD is in process (it has been assigned to a channel). */
+
+		if (dwc_otg_hcd->flags.b.port_connect_status) {
+			/*
+			 * If still connected (i.e. in host mode), halt the
+			 * channel so it can be used for other transfers. If
+			 * no longer connected, the host registers can't be
+			 * written to halt the channel since the core is in
+			 * device mode.
+			 */
+			dwc_otg_hc_halt(dwc_otg_hcd->core_if, qh->channel,
+			                DWC_OTG_HC_XFER_URB_DEQUEUE);
+		}
+	}
+
+	/*
+	 * Free the QTD and clean up the associated QH. Leave the QH in the
+	 * schedule if it has any remaining QTDs.
+	 */
+	dwc_otg_hcd_qtd_remove_and_free(urb_qtd);
+	if (urb_qtd == qh->qtd_in_process) {
+		dwc_otg_hcd_qh_deactivate(dwc_otg_hcd, qh, 0);
+		qh->channel = NULL;
+		qh->qtd_in_process = NULL;
+	} else if (list_empty(&qh->qtd_list)) {
+		dwc_otg_hcd_qh_remove(dwc_otg_hcd, qh);
+	}
+
+	local_irq_restore(flags);
+
+	_urb->hcpriv = NULL;
+
+	/* Higher layer software sets URB status. */
+	usb_hcd_giveback_urb(_hcd, _urb, status);
+#ifdef DEBUG
+	if (CHK_DEBUG_LEVEL(DBG_HCD_URB)) {
+		DWC_PRINT("Called usb_hcd_giveback_urb()\n");
+		DWC_PRINT("  urb->status = %d\n", _urb->status);
+	}
+#endif
+
+	return 0;
+}
+
+
+/** Frees resources in the DWC_otg controller related to a given endpoint. Also
+ * clears state in the HCD related to the endpoint. Any URBs for the endpoint
+ * must already be dequeued. */
+void dwc_otg_hcd_endpoint_disable(struct usb_hcd *_hcd,
+                                  struct usb_host_endpoint *_ep)
+
+{
+	dwc_otg_qh_t *qh;
+	dwc_otg_hcd_t *dwc_otg_hcd = hcd_to_dwc_otg_hcd(_hcd);
+
+	DWC_DEBUGPL(DBG_HCD, "DWC OTG HCD EP DISABLE: _bEndpointAddress=0x%02x, "
+	            "endpoint=%d\n", _ep->desc.bEndpointAddress,
+	            dwc_ep_addr_to_endpoint(_ep->desc.bEndpointAddress));
+
+	qh = (dwc_otg_qh_t *)(_ep->hcpriv);
+	if (qh != NULL) {
+#ifdef DEBUG
+		/** Check that the QTD list is really empty */
+		if (!list_empty(&qh->qtd_list)) {
+			DWC_WARN("DWC OTG HCD EP DISABLE:"
+			         " QTD List for this endpoint is not empty\n");
+		}
+#endif
+
+		dwc_otg_hcd_qh_remove_and_free(dwc_otg_hcd, qh);
+		_ep->hcpriv = NULL;
+	}
+
+	return;
+}
+
+/** Handles host mode interrupts for the DWC_otg controller. Returns IRQ_NONE if
+ * there was no interrupt to handle. Returns IRQ_HANDLED if there was a valid
+ * interrupt.
+ *
+ * This function is called by the USB core when an interrupt occurs */
+irqreturn_t dwc_otg_hcd_irq(struct usb_hcd *_hcd)
+{
+	dwc_otg_hcd_t *dwc_otg_hcd = hcd_to_dwc_otg_hcd (_hcd);
+	return IRQ_RETVAL(dwc_otg_hcd_handle_intr(dwc_otg_hcd));
+}
+
+/** Creates Status Change bitmap for the root hub and root port. The bitmap is
+ * returned in buf. Bit 0 is the status change indicator for the root hub. Bit 1
+ * is the status change indicator for the single root port. Returns 1 if either
+ * change indicator is 1, otherwise returns 0. */
+int dwc_otg_hcd_hub_status_data(struct usb_hcd *_hcd,
+                                char *_buf)
+{
+	dwc_otg_hcd_t *dwc_otg_hcd = hcd_to_dwc_otg_hcd (_hcd);
+
+	_buf[0] = 0;
+	_buf[0] |= (dwc_otg_hcd->flags.b.port_connect_status_change ||
+	            dwc_otg_hcd->flags.b.port_reset_change ||
+	            dwc_otg_hcd->flags.b.port_enable_change ||
+	            dwc_otg_hcd->flags.b.port_suspend_change ||
+	            dwc_otg_hcd->flags.b.port_over_current_change) << 1;
+
+#ifdef DEBUG
+	if (_buf[0]) {
+		DWC_DEBUGPL(DBG_HCD, "DWC OTG HCD HUB STATUS DATA:"
+		            " Root port status changed\n");
+		DWC_DEBUGPL(DBG_HCDV, "  port_connect_status_change: %d\n",
+		            dwc_otg_hcd->flags.b.port_connect_status_change);
+		DWC_DEBUGPL(DBG_HCDV, "  port_reset_change: %d\n",
+		            dwc_otg_hcd->flags.b.port_reset_change);
+		DWC_DEBUGPL(DBG_HCDV, "  port_enable_change: %d\n",
+		            dwc_otg_hcd->flags.b.port_enable_change);
+		DWC_DEBUGPL(DBG_HCDV, "  port_suspend_change: %d\n",
+		            dwc_otg_hcd->flags.b.port_suspend_change);
+		DWC_DEBUGPL(DBG_HCDV, "  port_over_current_change: %d\n",
+		            dwc_otg_hcd->flags.b.port_over_current_change);
+	}
+#endif
+	return (_buf[0] != 0);
+}
+
+#ifdef DWC_HS_ELECT_TST
+/*
+ * Quick and dirty hack to implement the HS Electrical Test
+ * SINGLE_STEP_GET_DEVICE_DESCRIPTOR feature.
+ *
+ * This code was copied from our userspace app "hset". It sends a
+ * Get Device Descriptor control sequence in two parts, first the
+ * Setup packet by itself, followed some time later by the In and
+ * Ack packets. Rather than trying to figure out how to add this
+ * functionality to the normal driver code, we just hijack the
+ * hardware, using these two function to drive the hardware
+ * directly.
+ */
+
+dwc_otg_core_global_regs_t *global_regs;
+dwc_otg_host_global_regs_t *hc_global_regs;
+dwc_otg_hc_regs_t *hc_regs;
+uint32_t *data_fifo;
+
+static void do_setup(void)
+{
+	gintsts_data_t gintsts;
+	hctsiz_data_t hctsiz;
+	hcchar_data_t hcchar;
+	haint_data_t haint;
+	hcint_data_t hcint;
+
+	/* Enable HAINTs */
+	dwc_write_reg32(&hc_global_regs->haintmsk, 0x0001);
+
+	/* Enable HCINTs */
+	dwc_write_reg32(&hc_regs->hcintmsk, 0x04a3);
+
+	/* Read GINTSTS */
+	gintsts.d32 = dwc_read_reg32(&global_regs->gintsts);
+	//fprintf(stderr, "GINTSTS: %08x\n", gintsts.d32);
+
+	/* Read HAINT */
+	haint.d32 = dwc_read_reg32(&hc_global_regs->haint);
+	//fprintf(stderr, "HAINT: %08x\n", haint.d32);
+
+	/* Read HCINT */
+	hcint.d32 = dwc_read_reg32(&hc_regs->hcint);
+	//fprintf(stderr, "HCINT: %08x\n", hcint.d32);
+
+	/* Read HCCHAR */
+	hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+	//fprintf(stderr, "HCCHAR: %08x\n", hcchar.d32);
+
+	/* Clear HCINT */
+	dwc_write_reg32(&hc_regs->hcint, hcint.d32);
+
+	/* Clear HAINT */
+	dwc_write_reg32(&hc_global_regs->haint, haint.d32);
+
+	/* Clear GINTSTS */
+	dwc_write_reg32(&global_regs->gintsts, gintsts.d32);
+
+	/* Read GINTSTS */
+	gintsts.d32 = dwc_read_reg32(&global_regs->gintsts);
+	//fprintf(stderr, "GINTSTS: %08x\n", gintsts.d32);
+
+	/*
+	 * Send Setup packet (Get Device Descriptor)
+	 */
+
+	/* Make sure channel is disabled */
+	hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+	if (hcchar.b.chen) {
+		//fprintf(stderr, "Channel already enabled 1, HCCHAR = %08x\n", hcchar.d32);
+		hcchar.b.chdis = 1;
+//		hcchar.b.chen = 1;
+		dwc_write_reg32(&hc_regs->hcchar, hcchar.d32);
+		//sleep(1);
+		mdelay(1000);
+
+		/* Read GINTSTS */
+		gintsts.d32 = dwc_read_reg32(&global_regs->gintsts);
+		//fprintf(stderr, "GINTSTS: %08x\n", gintsts.d32);
+
+		/* Read HAINT */
+		haint.d32 = dwc_read_reg32(&hc_global_regs->haint);
+		//fprintf(stderr, "HAINT: %08x\n", haint.d32);
+
+		/* Read HCINT */
+		hcint.d32 = dwc_read_reg32(&hc_regs->hcint);
+		//fprintf(stderr, "HCINT: %08x\n", hcint.d32);
+
+		/* Read HCCHAR */
+		hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+		//fprintf(stderr, "HCCHAR: %08x\n", hcchar.d32);
+
+		/* Clear HCINT */
+		dwc_write_reg32(&hc_regs->hcint, hcint.d32);
+
+		/* Clear HAINT */
+		dwc_write_reg32(&hc_global_regs->haint, haint.d32);
+
+		/* Clear GINTSTS */
+		dwc_write_reg32(&global_regs->gintsts, gintsts.d32);
+
+		hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+		//if (hcchar.b.chen) {
+		//	fprintf(stderr, "** Channel _still_ enabled 1, HCCHAR = %08x **\n", hcchar.d32);
+		//}
+	}
+
+	/* Set HCTSIZ */
+	hctsiz.d32 = 0;
+	hctsiz.b.xfersize = 8;
+	hctsiz.b.pktcnt = 1;
+	hctsiz.b.pid = DWC_OTG_HC_PID_SETUP;
+	dwc_write_reg32(&hc_regs->hctsiz, hctsiz.d32);
+
+	/* Set HCCHAR */
+	hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+	hcchar.b.eptype = DWC_OTG_EP_TYPE_CONTROL;
+	hcchar.b.epdir = 0;
+	hcchar.b.epnum = 0;
+	hcchar.b.mps = 8;
+	hcchar.b.chen = 1;
+	dwc_write_reg32(&hc_regs->hcchar, hcchar.d32);
+
+	/* Fill FIFO with Setup data for Get Device Descriptor */
+	data_fifo = (uint32_t *)((char *)global_regs + 0x1000);
+	dwc_write_reg32(data_fifo++, 0x01000680);
+	dwc_write_reg32(data_fifo++, 0x00080000);
+
+	gintsts.d32 = dwc_read_reg32(&global_regs->gintsts);
+	//fprintf(stderr, "Waiting for HCINTR intr 1, GINTSTS = %08x\n", gintsts.d32);
+
+	/* Wait for host channel interrupt */
+	do {
+		gintsts.d32 = dwc_read_reg32(&global_regs->gintsts);
+	} while (gintsts.b.hcintr == 0);
+
+	//fprintf(stderr, "Got HCINTR intr 1, GINTSTS = %08x\n", gintsts.d32);
+
+	/* Disable HCINTs */
+	dwc_write_reg32(&hc_regs->hcintmsk, 0x0000);
+
+	/* Disable HAINTs */
+	dwc_write_reg32(&hc_global_regs->haintmsk, 0x0000);
+
+	/* Read HAINT */
+	haint.d32 = dwc_read_reg32(&hc_global_regs->haint);
+	//fprintf(stderr, "HAINT: %08x\n", haint.d32);
+
+	/* Read HCINT */
+	hcint.d32 = dwc_read_reg32(&hc_regs->hcint);
+	//fprintf(stderr, "HCINT: %08x\n", hcint.d32);
+
+	/* Read HCCHAR */
+	hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+	//fprintf(stderr, "HCCHAR: %08x\n", hcchar.d32);
+
+	/* Clear HCINT */
+	dwc_write_reg32(&hc_regs->hcint, hcint.d32);
+
+	/* Clear HAINT */
+	dwc_write_reg32(&hc_global_regs->haint, haint.d32);
+
+	/* Clear GINTSTS */
+	dwc_write_reg32(&global_regs->gintsts, gintsts.d32);
+
+	/* Read GINTSTS */
+	gintsts.d32 = dwc_read_reg32(&global_regs->gintsts);
+	//fprintf(stderr, "GINTSTS: %08x\n", gintsts.d32);
+}
+
+static void do_in_ack(void)
+{
+	gintsts_data_t gintsts;
+	hctsiz_data_t hctsiz;
+	hcchar_data_t hcchar;
+	haint_data_t haint;
+	hcint_data_t hcint;
+	host_grxsts_data_t grxsts;
+
+	/* Enable HAINTs */
+	dwc_write_reg32(&hc_global_regs->haintmsk, 0x0001);
+
+	/* Enable HCINTs */
+	dwc_write_reg32(&hc_regs->hcintmsk, 0x04a3);
+
+	/* Read GINTSTS */
+	gintsts.d32 = dwc_read_reg32(&global_regs->gintsts);
+	//fprintf(stderr, "GINTSTS: %08x\n", gintsts.d32);
+
+	/* Read HAINT */
+	haint.d32 = dwc_read_reg32(&hc_global_regs->haint);
+	//fprintf(stderr, "HAINT: %08x\n", haint.d32);
+
+	/* Read HCINT */
+	hcint.d32 = dwc_read_reg32(&hc_regs->hcint);
+	//fprintf(stderr, "HCINT: %08x\n", hcint.d32);
+
+	/* Read HCCHAR */
+	hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+	//fprintf(stderr, "HCCHAR: %08x\n", hcchar.d32);
+
+	/* Clear HCINT */
+	dwc_write_reg32(&hc_regs->hcint, hcint.d32);
+
+	/* Clear HAINT */
+	dwc_write_reg32(&hc_global_regs->haint, haint.d32);
+
+	/* Clear GINTSTS */
+	dwc_write_reg32(&global_regs->gintsts, gintsts.d32);
+
+	/* Read GINTSTS */
+	gintsts.d32 = dwc_read_reg32(&global_regs->gintsts);
+	//fprintf(stderr, "GINTSTS: %08x\n", gintsts.d32);
+
+	/*
+	 * Receive Control In packet
+	 */
+
+	/* Make sure channel is disabled */
+	hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+	if (hcchar.b.chen) {
+		//fprintf(stderr, "Channel already enabled 2, HCCHAR = %08x\n", hcchar.d32);
+		hcchar.b.chdis = 1;
+		hcchar.b.chen = 1;
+		dwc_write_reg32(&hc_regs->hcchar, hcchar.d32);
+		//sleep(1);
+		mdelay(1000);
+
+		/* Read GINTSTS */
+		gintsts.d32 = dwc_read_reg32(&global_regs->gintsts);
+		//fprintf(stderr, "GINTSTS: %08x\n", gintsts.d32);
+
+		/* Read HAINT */
+		haint.d32 = dwc_read_reg32(&hc_global_regs->haint);
+		//fprintf(stderr, "HAINT: %08x\n", haint.d32);
+
+		/* Read HCINT */
+		hcint.d32 = dwc_read_reg32(&hc_regs->hcint);
+		//fprintf(stderr, "HCINT: %08x\n", hcint.d32);
+
+		/* Read HCCHAR */
+		hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+		//fprintf(stderr, "HCCHAR: %08x\n", hcchar.d32);
+
+		/* Clear HCINT */
+		dwc_write_reg32(&hc_regs->hcint, hcint.d32);
+
+		/* Clear HAINT */
+		dwc_write_reg32(&hc_global_regs->haint, haint.d32);
+
+		/* Clear GINTSTS */
+		dwc_write_reg32(&global_regs->gintsts, gintsts.d32);
+
+		hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+		//if (hcchar.b.chen) {
+		//	fprintf(stderr, "** Channel _still_ enabled 2, HCCHAR = %08x **\n", hcchar.d32);
+		//}
+	}
+
+	/* Set HCTSIZ */
+	hctsiz.d32 = 0;
+	hctsiz.b.xfersize = 8;
+	hctsiz.b.pktcnt = 1;
+	hctsiz.b.pid = DWC_OTG_HC_PID_DATA1;
+	dwc_write_reg32(&hc_regs->hctsiz, hctsiz.d32);
+
+	/* Set HCCHAR */
+	hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+	hcchar.b.eptype = DWC_OTG_EP_TYPE_CONTROL;
+	hcchar.b.epdir = 1;
+	hcchar.b.epnum = 0;
+	hcchar.b.mps = 8;
+	hcchar.b.chen = 1;
+	dwc_write_reg32(&hc_regs->hcchar, hcchar.d32);
+
+	gintsts.d32 = dwc_read_reg32(&global_regs->gintsts);
+	//fprintf(stderr, "Waiting for RXSTSQLVL intr 1, GINTSTS = %08x\n", gintsts.d32);
+
+	/* Wait for receive status queue interrupt */
+	do {
+		gintsts.d32 = dwc_read_reg32(&global_regs->gintsts);
+	} while (gintsts.b.rxstsqlvl == 0);
+
+	//fprintf(stderr, "Got RXSTSQLVL intr 1, GINTSTS = %08x\n", gintsts.d32);
+
+	/* Read RXSTS */
+	grxsts.d32 = dwc_read_reg32(&global_regs->grxstsp);
+	//fprintf(stderr, "GRXSTS: %08x\n", grxsts.d32);
+
+	/* Clear RXSTSQLVL in GINTSTS */
+	gintsts.d32 = 0;
+	gintsts.b.rxstsqlvl = 1;
+	dwc_write_reg32(&global_regs->gintsts, gintsts.d32);
+
+	switch (grxsts.b.pktsts) {
+	case DWC_GRXSTS_PKTSTS_IN:
+		/* Read the data into the host buffer */
+		if (grxsts.b.bcnt > 0) {
+			int i;
+			int word_count = (grxsts.b.bcnt + 3) / 4;
+
+			data_fifo = (uint32_t *)((char *)global_regs + 0x1000);
+
+			for (i = 0; i < word_count; i++) {
+				(void)dwc_read_reg32(data_fifo++);
+			}
+		}
+
+		//fprintf(stderr, "Received %u bytes\n", (unsigned)grxsts.b.bcnt);
+		break;
+
+	default:
+		//fprintf(stderr, "** Unexpected GRXSTS packet status 1 **\n");
+		break;
+	}
+
+	gintsts.d32 = dwc_read_reg32(&global_regs->gintsts);
+	//fprintf(stderr, "Waiting for RXSTSQLVL intr 2, GINTSTS = %08x\n", gintsts.d32);
+
+	/* Wait for receive status queue interrupt */
+	do {
+		gintsts.d32 = dwc_read_reg32(&global_regs->gintsts);
+	} while (gintsts.b.rxstsqlvl == 0);
+
+	//fprintf(stderr, "Got RXSTSQLVL intr 2, GINTSTS = %08x\n", gintsts.d32);
+
+	/* Read RXSTS */
+	grxsts.d32 = dwc_read_reg32(&global_regs->grxstsp);
+	//fprintf(stderr, "GRXSTS: %08x\n", grxsts.d32);
+
+	/* Clear RXSTSQLVL in GINTSTS */
+	gintsts.d32 = 0;
+	gintsts.b.rxstsqlvl = 1;
+	dwc_write_reg32(&global_regs->gintsts, gintsts.d32);
+
+	switch (grxsts.b.pktsts) {
+	case DWC_GRXSTS_PKTSTS_IN_XFER_COMP:
+		break;
+
+	default:
+		//fprintf(stderr, "** Unexpected GRXSTS packet status 2 **\n");
+		break;
+	}
+
+	gintsts.d32 = dwc_read_reg32(&global_regs->gintsts);
+	//fprintf(stderr, "Waiting for HCINTR intr 2, GINTSTS = %08x\n", gintsts.d32);
+
+	/* Wait for host channel interrupt */
+	do {
+		gintsts.d32 = dwc_read_reg32(&global_regs->gintsts);
+	} while (gintsts.b.hcintr == 0);
+
+	//fprintf(stderr, "Got HCINTR intr 2, GINTSTS = %08x\n", gintsts.d32);
+
+	/* Read HAINT */
+	haint.d32 = dwc_read_reg32(&hc_global_regs->haint);
+	//fprintf(stderr, "HAINT: %08x\n", haint.d32);
+
+	/* Read HCINT */
+	hcint.d32 = dwc_read_reg32(&hc_regs->hcint);
+	//fprintf(stderr, "HCINT: %08x\n", hcint.d32);
+
+	/* Read HCCHAR */
+	hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+	//fprintf(stderr, "HCCHAR: %08x\n", hcchar.d32);
+
+	/* Clear HCINT */
+	dwc_write_reg32(&hc_regs->hcint, hcint.d32);
+
+	/* Clear HAINT */
+	dwc_write_reg32(&hc_global_regs->haint, haint.d32);
+
+	/* Clear GINTSTS */
+	dwc_write_reg32(&global_regs->gintsts, gintsts.d32);
+
+	/* Read GINTSTS */
+	gintsts.d32 = dwc_read_reg32(&global_regs->gintsts);
+	//fprintf(stderr, "GINTSTS: %08x\n", gintsts.d32);
+
+//	usleep(100000);
+//	mdelay(100);
+	mdelay(1);
+
+	/*
+	 * Send handshake packet
+	 */
+
+	/* Read HAINT */
+	haint.d32 = dwc_read_reg32(&hc_global_regs->haint);
+	//fprintf(stderr, "HAINT: %08x\n", haint.d32);
+
+	/* Read HCINT */
+	hcint.d32 = dwc_read_reg32(&hc_regs->hcint);
+	//fprintf(stderr, "HCINT: %08x\n", hcint.d32);
+
+	/* Read HCCHAR */
+	hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+	//fprintf(stderr, "HCCHAR: %08x\n", hcchar.d32);
+
+	/* Clear HCINT */
+	dwc_write_reg32(&hc_regs->hcint, hcint.d32);
+
+	/* Clear HAINT */
+	dwc_write_reg32(&hc_global_regs->haint, haint.d32);
+
+	/* Clear GINTSTS */
+	dwc_write_reg32(&global_regs->gintsts, gintsts.d32);
+
+	/* Read GINTSTS */
+	gintsts.d32 = dwc_read_reg32(&global_regs->gintsts);
+	//fprintf(stderr, "GINTSTS: %08x\n", gintsts.d32);
+
+	/* Make sure channel is disabled */
+	hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+	if (hcchar.b.chen) {
+		//fprintf(stderr, "Channel already enabled 3, HCCHAR = %08x\n", hcchar.d32);
+		hcchar.b.chdis = 1;
+		hcchar.b.chen = 1;
+		dwc_write_reg32(&hc_regs->hcchar, hcchar.d32);
+		//sleep(1);
+		mdelay(1000);
+
+		/* Read GINTSTS */
+		gintsts.d32 = dwc_read_reg32(&global_regs->gintsts);
+		//fprintf(stderr, "GINTSTS: %08x\n", gintsts.d32);
+
+		/* Read HAINT */
+		haint.d32 = dwc_read_reg32(&hc_global_regs->haint);
+		//fprintf(stderr, "HAINT: %08x\n", haint.d32);
+
+		/* Read HCINT */
+		hcint.d32 = dwc_read_reg32(&hc_regs->hcint);
+		//fprintf(stderr, "HCINT: %08x\n", hcint.d32);
+
+		/* Read HCCHAR */
+		hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+		//fprintf(stderr, "HCCHAR: %08x\n", hcchar.d32);
+
+		/* Clear HCINT */
+		dwc_write_reg32(&hc_regs->hcint, hcint.d32);
+
+		/* Clear HAINT */
+		dwc_write_reg32(&hc_global_regs->haint, haint.d32);
+
+		/* Clear GINTSTS */
+		dwc_write_reg32(&global_regs->gintsts, gintsts.d32);
+
+		hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+		//if (hcchar.b.chen) {
+		//	fprintf(stderr, "** Channel _still_ enabled 3, HCCHAR = %08x **\n", hcchar.d32);
+		//}
+	}
+
+	/* Set HCTSIZ */
+	hctsiz.d32 = 0;
+	hctsiz.b.xfersize = 0;
+	hctsiz.b.pktcnt = 1;
+	hctsiz.b.pid = DWC_OTG_HC_PID_DATA1;
+	dwc_write_reg32(&hc_regs->hctsiz, hctsiz.d32);
+
+	/* Set HCCHAR */
+	hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+	hcchar.b.eptype = DWC_OTG_EP_TYPE_CONTROL;
+	hcchar.b.epdir = 0;
+	hcchar.b.epnum = 0;
+	hcchar.b.mps = 8;
+	hcchar.b.chen = 1;
+	dwc_write_reg32(&hc_regs->hcchar, hcchar.d32);
+
+	gintsts.d32 = dwc_read_reg32(&global_regs->gintsts);
+	//fprintf(stderr, "Waiting for HCINTR intr 3, GINTSTS = %08x\n", gintsts.d32);
+
+	/* Wait for host channel interrupt */
+	do {
+		gintsts.d32 = dwc_read_reg32(&global_regs->gintsts);
+	} while (gintsts.b.hcintr == 0);
+
+	//fprintf(stderr, "Got HCINTR intr 3, GINTSTS = %08x\n", gintsts.d32);
+
+	/* Disable HCINTs */
+	dwc_write_reg32(&hc_regs->hcintmsk, 0x0000);
+
+	/* Disable HAINTs */
+	dwc_write_reg32(&hc_global_regs->haintmsk, 0x0000);
+
+	/* Read HAINT */
+	haint.d32 = dwc_read_reg32(&hc_global_regs->haint);
+	//fprintf(stderr, "HAINT: %08x\n", haint.d32);
+
+	/* Read HCINT */
+	hcint.d32 = dwc_read_reg32(&hc_regs->hcint);
+	//fprintf(stderr, "HCINT: %08x\n", hcint.d32);
+
+	/* Read HCCHAR */
+	hcchar.d32 = dwc_read_reg32(&hc_regs->hcchar);
+	//fprintf(stderr, "HCCHAR: %08x\n", hcchar.d32);
+
+	/* Clear HCINT */
+	dwc_write_reg32(&hc_regs->hcint, hcint.d32);
+
+	/* Clear HAINT */
+	dwc_write_reg32(&hc_global_regs->haint, haint.d32);
+
+	/* Clear GINTSTS */
+	dwc_write_reg32(&global_regs->gintsts, gintsts.d32);
+
+	/* Read GINTSTS */
+	gintsts.d32 = dwc_read_reg32(&global_regs->gintsts);
+	//fprintf(stderr, "GINTSTS: %08x\n", gintsts.d32);
+}
+#endif /* DWC_HS_ELECT_TST */
+
+/** Handles hub class-specific requests.*/
+int dwc_otg_hcd_hub_control(struct usb_hcd *_hcd,
+                            u16 _typeReq,
+                            u16 _wValue,
+                            u16 _wIndex,
+                            char *_buf,
+                            u16 _wLength)
+{
+	int retval = 0;
+
+	dwc_otg_hcd_t *dwc_otg_hcd = hcd_to_dwc_otg_hcd (_hcd);
+	dwc_otg_core_if_t *core_if = hcd_to_dwc_otg_hcd (_hcd)->core_if;
+	struct usb_hub_descriptor *desc;
+	hprt0_data_t hprt0 = {.d32 = 0};
+
+	uint32_t port_status;
+
+	switch (_typeReq) {
+	case ClearHubFeature:
+		DWC_DEBUGPL (DBG_HCD, "DWC OTG HCD HUB CONTROL - "
+		             "ClearHubFeature 0x%x\n", _wValue);
+		switch (_wValue) {
+		case C_HUB_LOCAL_POWER:
+		case C_HUB_OVER_CURRENT:
+			/* Nothing required here */
+			break;
+		default:
+			retval = -EINVAL;
+			DWC_ERROR ("DWC OTG HCD - "
+			           "ClearHubFeature request %xh unknown\n", _wValue);
+		}
+		break;
+	case ClearPortFeature:
+		if (!_wIndex || _wIndex > 1)
+			goto error;
+
+		switch (_wValue) {
+		case USB_PORT_FEAT_ENABLE:
+			DWC_DEBUGPL (DBG_ANY, "DWC OTG HCD HUB CONTROL - "
+			             "ClearPortFeature USB_PORT_FEAT_ENABLE\n");
+			hprt0.d32 = dwc_otg_read_hprt0 (core_if);
+			hprt0.b.prtena = 1;
+			dwc_write_reg32(core_if->host_if->hprt0, hprt0.d32);
+			break;
+		case USB_PORT_FEAT_SUSPEND:
+			DWC_DEBUGPL (DBG_HCD, "DWC OTG HCD HUB CONTROL - "
+			             "ClearPortFeature USB_PORT_FEAT_SUSPEND\n");
+			hprt0.d32 = dwc_otg_read_hprt0 (core_if);
+			hprt0.b.prtres = 1;
+			dwc_write_reg32(core_if->host_if->hprt0, hprt0.d32);
+			/* Clear Resume bit */
+			mdelay (100);
+			hprt0.b.prtres = 0;
+			dwc_write_reg32(core_if->host_if->hprt0, hprt0.d32);
+			break;
+		case USB_PORT_FEAT_POWER:
+			DWC_DEBUGPL (DBG_HCD, "DWC OTG HCD HUB CONTROL - "
+			             "ClearPortFeature USB_PORT_FEAT_POWER\n");
+			hprt0.d32 = dwc_otg_read_hprt0 (core_if);
+			hprt0.b.prtpwr = 0;
+			dwc_write_reg32(core_if->host_if->hprt0, hprt0.d32);
+			break;
+		case USB_PORT_FEAT_INDICATOR:
+			DWC_DEBUGPL (DBG_HCD, "DWC OTG HCD HUB CONTROL - "
+			             "ClearPortFeature USB_PORT_FEAT_INDICATOR\n");
+			/* Port inidicator not supported */
+			break;
+		case USB_PORT_FEAT_C_CONNECTION:
+			/* Clears drivers internal connect status change
+			 * flag */
+			DWC_DEBUGPL (DBG_HCD, "DWC OTG HCD HUB CONTROL - "
+			             "ClearPortFeature USB_PORT_FEAT_C_CONNECTION\n");
+			dwc_otg_hcd->flags.b.port_connect_status_change = 0;
+			break;
+		case USB_PORT_FEAT_C_RESET:
+			/* Clears the driver's internal Port Reset Change
+			 * flag */
+			DWC_DEBUGPL (DBG_HCD, "DWC OTG HCD HUB CONTROL - "
+			             "ClearPortFeature USB_PORT_FEAT_C_RESET\n");
+			dwc_otg_hcd->flags.b.port_reset_change = 0;
+			break;
+		case USB_PORT_FEAT_C_ENABLE:
+			/* Clears the driver's internal Port
+			 * Enable/Disable Change flag */
+			DWC_DEBUGPL (DBG_HCD, "DWC OTG HCD HUB CONTROL - "
+			             "ClearPortFeature USB_PORT_FEAT_C_ENABLE\n");
+			dwc_otg_hcd->flags.b.port_enable_change = 0;
+			break;
+		case USB_PORT_FEAT_C_SUSPEND:
+			/* Clears the driver's internal Port Suspend
+			 * Change flag, which is set when resume signaling on
+			 * the host port is complete */
+			DWC_DEBUGPL (DBG_HCD, "DWC OTG HCD HUB CONTROL - "
+			             "ClearPortFeature USB_PORT_FEAT_C_SUSPEND\n");
+			dwc_otg_hcd->flags.b.port_suspend_change = 0;
+			break;
+		case USB_PORT_FEAT_C_OVER_CURRENT:
+			DWC_DEBUGPL (DBG_HCD, "DWC OTG HCD HUB CONTROL - "
+			             "ClearPortFeature USB_PORT_FEAT_C_OVER_CURRENT\n");
+			dwc_otg_hcd->flags.b.port_over_current_change = 0;
+			break;
+		default:
+			retval = -EINVAL;
+			DWC_ERROR ("DWC OTG HCD - "
+			           "ClearPortFeature request %xh "
+			           "unknown or unsupported\n", _wValue);
+		}
+		break;
+	case GetHubDescriptor:
+		DWC_DEBUGPL (DBG_HCD, "DWC OTG HCD HUB CONTROL - "
+		             "GetHubDescriptor\n");
+		desc = (struct usb_hub_descriptor *)_buf;
+		desc->bDescLength = 9;
+		desc->bDescriptorType = 0x29;
+		desc->bNbrPorts = 1;
+		desc->wHubCharacteristics = 0x08;
+		desc->bPwrOn2PwrGood = 1;
+		desc->bHubContrCurrent = 0;
+		desc->bitmap[0] = 0;
+		desc->bitmap[1] = 0xff;
+		break;
+	case GetHubStatus:
+		DWC_DEBUGPL (DBG_HCD, "DWC OTG HCD HUB CONTROL - "
+		             "GetHubStatus\n");
+		memset (_buf, 0, 4);
+		break;
+	case GetPortStatus:
+		DWC_DEBUGPL (DBG_HCD, "DWC OTG HCD HUB CONTROL - "
+		             "GetPortStatus\n");
+
+		if (!_wIndex || _wIndex > 1)
+			goto error;
+
+		port_status = 0;
+
+		if (dwc_otg_hcd->flags.b.port_connect_status_change)
+			port_status |= (1 << USB_PORT_FEAT_C_CONNECTION);
+
+		if (dwc_otg_hcd->flags.b.port_enable_change)
+			port_status |= (1 << USB_PORT_FEAT_C_ENABLE);
+
+		if (dwc_otg_hcd->flags.b.port_suspend_change)
+			port_status |= (1 << USB_PORT_FEAT_C_SUSPEND);
+
+		if (dwc_otg_hcd->flags.b.port_reset_change)
+			port_status |= (1 << USB_PORT_FEAT_C_RESET);
+
+		if (dwc_otg_hcd->flags.b.port_over_current_change) {
+			DWC_ERROR("Device Not Supported\n");
+			port_status |= (1 << USB_PORT_FEAT_C_OVER_CURRENT);
+		}
+
+		if (!dwc_otg_hcd->flags.b.port_connect_status) {
+			/*
+			 * The port is disconnected, which means the core is
+			 * either in device mode or it soon will be. Just
+			 * return 0's for the remainder of the port status
+			 * since the port register can't be read if the core
+			 * is in device mode.
+			 */
+			*((__le32 *) _buf) = cpu_to_le32(port_status);
+			break;
+		}
+
+		hprt0.d32 = dwc_read_reg32(core_if->host_if->hprt0);
+		DWC_DEBUGPL(DBG_HCDV, "  HPRT0: 0x%08x\n", hprt0.d32);
+
+		if (hprt0.b.prtconnsts)
+			port_status |= (1 << USB_PORT_FEAT_CONNECTION);
+
+		if (hprt0.b.prtena)
+			port_status |= (1 << USB_PORT_FEAT_ENABLE);
+
+		if (hprt0.b.prtsusp)
+			port_status |= (1 << USB_PORT_FEAT_SUSPEND);
+
+		if (hprt0.b.prtovrcurract)
+			port_status |= (1 << USB_PORT_FEAT_OVER_CURRENT);
+
+		if (hprt0.b.prtrst)
+			port_status |= (1 << USB_PORT_FEAT_RESET);
+
+		if (hprt0.b.prtpwr)
+			port_status |= (1 << USB_PORT_FEAT_POWER);
+
+		if (hprt0.b.prtspd == DWC_HPRT0_PRTSPD_HIGH_SPEED)
+			port_status |= (1 << USB_PORT_FEAT_HIGHSPEED);
+		else if (hprt0.b.prtspd == DWC_HPRT0_PRTSPD_LOW_SPEED)
+			port_status |= (1 << USB_PORT_FEAT_LOWSPEED);
+
+		if (hprt0.b.prttstctl)
+			port_status |= (1 << USB_PORT_FEAT_TEST);
+
+		/* USB_PORT_FEAT_INDICATOR unsupported always 0 */
+
+		*((__le32 *) _buf) = cpu_to_le32(port_status);
+
+		break;
+	case SetHubFeature:
+		DWC_DEBUGPL (DBG_HCD, "DWC OTG HCD HUB CONTROL - "
+		             "SetHubFeature\n");
+		/* No HUB features supported */
+		break;
+	case SetPortFeature:
+		if (_wValue != USB_PORT_FEAT_TEST && (!_wIndex || _wIndex > 1))
+			goto error;
+
+		if (!dwc_otg_hcd->flags.b.port_connect_status) {
+			/*
+			 * The port is disconnected, which means the core is
+			 * either in device mode or it soon will be. Just
+			 * return without doing anything since the port
+			 * register can't be written if the core is in device
+			 * mode.
+			 */
+			break;
+		}
+
+		switch (_wValue) {
+		case USB_PORT_FEAT_SUSPEND:
+			DWC_DEBUGPL (DBG_HCD, "DWC OTG HCD HUB CONTROL - "
+			             "SetPortFeature - USB_PORT_FEAT_SUSPEND\n");
+			if (_hcd->self.otg_port == _wIndex &&
+			        _hcd->self.b_hnp_enable) {
+				gotgctl_data_t  gotgctl = {.d32=0};
+				gotgctl.b.hstsethnpen = 1;
+				dwc_modify_reg32( &core_if->core_global_regs->gotgctl,
+				                  0, gotgctl.d32);
+				core_if->op_state = A_SUSPEND;
+			}
+			hprt0.d32 = dwc_otg_read_hprt0 (core_if);
+			hprt0.b.prtsusp = 1;
+			dwc_write_reg32(core_if->host_if->hprt0, hprt0.d32);
+			//DWC_PRINT( "SUSPEND: HPRT0=%0x\n", hprt0.d32);
+			/* Suspend the Phy Clock */
+			{
+				pcgcctl_data_t pcgcctl = {.d32=0};
+				pcgcctl.b.stoppclk = 1;
+				dwc_write_reg32(core_if->pcgcctl, pcgcctl.d32);
+			}
+
+			/* For HNP the bus must be suspended for at least 200ms.*/
+			if (_hcd->self.b_hnp_enable) {
+				mdelay(200);
+				//DWC_PRINT( "SUSPEND: wait complete! (%d)\n", _hcd->state);
+			}
+			break;
+		case USB_PORT_FEAT_POWER:
+			DWC_DEBUGPL (DBG_HCD, "DWC OTG HCD HUB CONTROL - "
+			             "SetPortFeature - USB_PORT_FEAT_POWER\n");
+			hprt0.d32 = dwc_otg_read_hprt0 (core_if);
+			hprt0.b.prtpwr = 1;
+			dwc_write_reg32(core_if->host_if->hprt0, hprt0.d32);
+			break;
+		case USB_PORT_FEAT_RESET:
+			DWC_DEBUGPL (DBG_HCD, "DWC OTG HCD HUB CONTROL - "
+			             "SetPortFeature - USB_PORT_FEAT_RESET\n");
+			hprt0.d32 = dwc_otg_read_hprt0 (core_if);
+			/* When B-Host the Port reset bit is set in
+			 * the Start HCD Callback function, so that
+			 * the reset is started within 1ms of the HNP
+			 * success interrupt. */
+			if (!_hcd->self.is_b_host) {
+				hprt0.b.prtrst = 1;
+				dwc_write_reg32(core_if->host_if->hprt0, hprt0.d32);
+			}
+			/* Clear reset bit in 10ms (FS/LS) or 50ms (HS) */
+			MDELAY (60);
+			hprt0.b.prtrst = 0;
+			dwc_write_reg32(core_if->host_if->hprt0, hprt0.d32);
+			break;
+
+#ifdef DWC_HS_ELECT_TST
+		case USB_PORT_FEAT_TEST:
+		{
+			uint32_t t;
+			gintmsk_data_t gintmsk;
+
+			t = (_wIndex >> 8); /* MSB wIndex USB */
+			DWC_DEBUGPL (DBG_HCD, "DWC OTG HCD HUB CONTROL - "
+			             "SetPortFeature - USB_PORT_FEAT_TEST %d\n", t);
+			warn("USB_PORT_FEAT_TEST %d\n", t);
+			if (t < 6) {
+				hprt0.d32 = dwc_otg_read_hprt0 (core_if);
+				hprt0.b.prttstctl = t;
+				dwc_write_reg32(core_if->host_if->hprt0, hprt0.d32);
+			} else {
+				/* Setup global vars with reg addresses (quick and
+				 * dirty hack, should be cleaned up)
+				 */
+				global_regs = core_if->core_global_regs;
+				hc_global_regs = core_if->host_if->host_global_regs;
+				hc_regs = (dwc_otg_hc_regs_t *)((char *)global_regs + 0x500);
+				data_fifo = (uint32_t *)((char *)global_regs + 0x1000);
+
+				if (t == 6) { /* HS_HOST_PORT_SUSPEND_RESUME */
+					/* Save current interrupt mask */
+					gintmsk.d32 = dwc_read_reg32(&global_regs->gintmsk);
+
+					/* Disable all interrupts while we muck with
+					 * the hardware directly
+					 */
+					dwc_write_reg32(&global_regs->gintmsk, 0);
+
+					/* 15 second delay per the test spec */
+					mdelay(15000);
+
+					/* Drive suspend on the root port */
+					hprt0.d32 = dwc_otg_read_hprt0 (core_if);
+					hprt0.b.prtsusp = 1;
+					hprt0.b.prtres = 0;
+					dwc_write_reg32(core_if->host_if->hprt0, hprt0.d32);
+
+					/* 15 second delay per the test spec */
+					mdelay(15000);
+
+					/* Drive resume on the root port */
+					hprt0.d32 = dwc_otg_read_hprt0 (core_if);
+					hprt0.b.prtsusp = 0;
+					hprt0.b.prtres = 1;
+					dwc_write_reg32(core_if->host_if->hprt0, hprt0.d32);
+					mdelay(100);
+
+					/* Clear the resume bit */
+					hprt0.b.prtres = 0;
+					dwc_write_reg32(core_if->host_if->hprt0, hprt0.d32);
+
+					/* Restore interrupts */
+					dwc_write_reg32(&global_regs->gintmsk, gintmsk.d32);
+				} else if (t == 7) { /* SINGLE_STEP_GET_DEVICE_DESCRIPTOR setup */
+					/* Save current interrupt mask */
+					gintmsk.d32 = dwc_read_reg32(&global_regs->gintmsk);
+
+					/* Disable all interrupts while we muck with
+					 * the hardware directly
+					 */
+					dwc_write_reg32(&global_regs->gintmsk, 0);
+
+					/* 15 second delay per the test spec */
+					mdelay(15000);
+
+					/* Send the Setup packet */
+					do_setup();
+
+					/* 15 second delay so nothing else happens for awhile */
+					mdelay(15000);
+
+					/* Restore interrupts */
+					dwc_write_reg32(&global_regs->gintmsk, gintmsk.d32);
+				} else if (t == 8) { /* SINGLE_STEP_GET_DEVICE_DESCRIPTOR execute */
+					/* Save current interrupt mask */
+					gintmsk.d32 = dwc_read_reg32(&global_regs->gintmsk);
+
+					/* Disable all interrupts while we muck with
+					 * the hardware directly
+					 */
+					dwc_write_reg32(&global_regs->gintmsk, 0);
+
+					/* Send the Setup packet */
+					do_setup();
+
+					/* 15 second delay so nothing else happens for awhile */
+					mdelay(15000);
+
+					/* Send the In and Ack packets */
+					do_in_ack();
+
+					/* 15 second delay so nothing else happens for awhile */
+					mdelay(15000);
+
+					/* Restore interrupts */
+					dwc_write_reg32(&global_regs->gintmsk, gintmsk.d32);
+				}
+			}
+			break;
+		}
+#endif /* DWC_HS_ELECT_TST */
+
+		case USB_PORT_FEAT_INDICATOR:
+			DWC_DEBUGPL (DBG_HCD, "DWC OTG HCD HUB CONTROL - "
+			             "SetPortFeature - USB_PORT_FEAT_INDICATOR\n");
+			/* Not supported */
+			break;
+		default:
+			retval = -EINVAL;
+			DWC_ERROR ("DWC OTG HCD - "
+			           "SetPortFeature request %xh "
+			           "unknown or unsupported\n", _wValue);
+			break;
+		}
+		break;
+	default:
+error:
+		retval = -EINVAL;
+		DWC_WARN ("DWC OTG HCD - "
+		          "Unknown hub control request type or invalid typeReq: %xh wIndex: %xh wValue: %xh\n",
+		          _typeReq, _wIndex, _wValue);
+		break;
+	}
+
+	return retval;
+}
+
+
+/**
+ * Assigns transactions from a QTD to a free host channel and initializes the
+ * host channel to perform the transactions. The host channel is removed from
+ * the free list.
+ *
+ * @param _hcd The HCD state structure.
+ * @param _qh Transactions from the first QTD for this QH are selected and
+ * assigned to a free host channel.
+ */
+static void assign_and_init_hc(dwc_otg_hcd_t *_hcd, dwc_otg_qh_t *_qh)
+{
+	dwc_hc_t	*hc;
+	dwc_otg_qtd_t	*qtd;
+	struct urb	*urb;
+
+	DWC_DEBUGPL(DBG_HCDV, "%s(%p,%p)\n", __func__, _hcd, _qh);
+
+	hc = list_entry(_hcd->free_hc_list.next, dwc_hc_t, hc_list_entry);
+
+	/* Remove the host channel from the free list. */
+	list_del_init(&hc->hc_list_entry);
+
+	qtd = list_entry(_qh->qtd_list.next, dwc_otg_qtd_t, qtd_list_entry);
+	urb = qtd->urb;
+	_qh->channel = hc;
+	_qh->qtd_in_process = qtd;
+
+	/*
+	 * Use usb_pipedevice to determine device address. This address is
+	 * 0 before the SET_ADDRESS command and the correct address afterward.
+	 */
+	hc->dev_addr = usb_pipedevice(urb->pipe);
+	hc->ep_num = usb_pipeendpoint(urb->pipe);
+
+	if (urb->dev->speed == USB_SPEED_LOW) {
+		hc->speed = DWC_OTG_EP_SPEED_LOW;
+	} else if (urb->dev->speed == USB_SPEED_FULL) {
+		hc->speed = DWC_OTG_EP_SPEED_FULL;
+	} else {
+		hc->speed = DWC_OTG_EP_SPEED_HIGH;
+	}
+
+	hc->max_packet = dwc_max_packet(_qh->maxp);
+
+	hc->xfer_started = 0;
+	hc->halt_status = DWC_OTG_HC_XFER_NO_HALT_STATUS;
+	hc->error_state = (qtd->error_count > 0);
+	hc->halt_on_queue = 0;
+	hc->halt_pending = 0;
+	hc->requests = 0;
+
+	/*
+	 * The following values may be modified in the transfer type section
+	 * below. The xfer_len value may be reduced when the transfer is
+	 * started to accommodate the max widths of the XferSize and PktCnt
+	 * fields in the HCTSIZn register.
+	 */
+	hc->do_ping = _qh->ping_state;
+	hc->ep_is_in = (usb_pipein(urb->pipe) != 0);
+	hc->data_pid_start = _qh->data_toggle;
+	hc->multi_count = 1;
+
+	if (_hcd->core_if->dma_enable) {
+		hc->xfer_buff = (uint8_t *)urb->transfer_dma + urb->actual_length;
+	} else {
+		hc->xfer_buff = (uint8_t *)urb->transfer_buffer + urb->actual_length;
+	}
+	hc->xfer_len = urb->transfer_buffer_length - urb->actual_length;
+	hc->xfer_count = 0;
+
+	/*
+	 * Set the split attributes
+	 */
+	hc->do_split = 0;
+	if (_qh->do_split) {
+		hc->do_split = 1;
+		hc->xact_pos = qtd->isoc_split_pos;
+		hc->complete_split = qtd->complete_split;
+		hc->hub_addr = urb->dev->tt->hub->devnum;
+		hc->port_addr = urb->dev->ttport;
+	}
+
+	switch (usb_pipetype(urb->pipe)) {
+	case PIPE_CONTROL:
+		hc->ep_type = DWC_OTG_EP_TYPE_CONTROL;
+		switch (qtd->control_phase) {
+		case DWC_OTG_CONTROL_SETUP:
+			DWC_DEBUGPL(DBG_HCDV, "  Control setup transaction\n");
+			hc->do_ping = 0;
+			hc->ep_is_in = 0;
+			hc->data_pid_start = DWC_OTG_HC_PID_SETUP;
+			if (_hcd->core_if->dma_enable) {
+				hc->xfer_buff = (uint8_t *)urb->setup_dma;
+			} else {
+				hc->xfer_buff = (uint8_t *)urb->setup_packet;
+			}
+			hc->xfer_len = 8;
+			break;
+		case DWC_OTG_CONTROL_DATA:
+			DWC_DEBUGPL(DBG_HCDV, "  Control data transaction\n");
+			hc->data_pid_start = qtd->data_toggle;
+			break;
+		case DWC_OTG_CONTROL_STATUS:
+			/*
+			 * Direction is opposite of data direction or IN if no
+			 * data.
+			 */
+			DWC_DEBUGPL(DBG_HCDV, "  Control status transaction\n");
+			if (urb->transfer_buffer_length == 0) {
+				hc->ep_is_in = 1;
+			} else {
+				hc->ep_is_in = (usb_pipein(urb->pipe) != USB_DIR_IN);
+			}
+			if (hc->ep_is_in) {
+				hc->do_ping = 0;
+			}
+			hc->data_pid_start = DWC_OTG_HC_PID_DATA1;
+			hc->xfer_len = 0;
+			if (_hcd->core_if->dma_enable) {
+				hc->xfer_buff = (uint8_t *)_hcd->status_buf_dma;
+			} else {
+				hc->xfer_buff = (uint8_t *)_hcd->status_buf;
+			}
+			break;
+		}
+		break;
+	case PIPE_BULK:
+		hc->ep_type = DWC_OTG_EP_TYPE_BULK;
+		break;
+	case PIPE_INTERRUPT:
+		hc->ep_type = DWC_OTG_EP_TYPE_INTR;
+		break;
+	case PIPE_ISOCHRONOUS:
+	{
+		struct usb_iso_packet_descriptor *frame_desc;
+		frame_desc = &urb->iso_frame_desc[qtd->isoc_frame_index];
+		hc->ep_type = DWC_OTG_EP_TYPE_ISOC;
+		if (_hcd->core_if->dma_enable) {
+			hc->xfer_buff = (uint8_t *)urb->transfer_dma;
+		} else {
+			hc->xfer_buff = (uint8_t *)urb->transfer_buffer;
+		}
+		hc->xfer_buff += frame_desc->offset + qtd->isoc_split_offset;
+		hc->xfer_len = frame_desc->length - qtd->isoc_split_offset;
+
+		if (hc->xact_pos == DWC_HCSPLIT_XACTPOS_ALL) {
+			if (hc->xfer_len <= 188) {
+				hc->xact_pos = DWC_HCSPLIT_XACTPOS_ALL;
+			}
+			else {
+				hc->xact_pos = DWC_HCSPLIT_XACTPOS_BEGIN;
+			}
+		}
+	}
+	break;
+	}
+
+	if (hc->ep_type == DWC_OTG_EP_TYPE_INTR ||
+	        hc->ep_type == DWC_OTG_EP_TYPE_ISOC) {
+		/*
+		 * This value may be modified when the transfer is started to
+		 * reflect the actual transfer length.
+		 */
+		hc->multi_count = dwc_hb_mult(_qh->maxp);
+	}
+
+	dwc_otg_hc_init(_hcd->core_if, hc);
+	hc->qh = _qh;
+}
+
+/**
+ * This function selects transactions from the HCD transfer schedule and
+ * assigns them to available host channels. It is called from HCD interrupt
+ * handler functions.
+ *
+ * @param _hcd The HCD state structure.
+ *
+ * @return The types of new transactions that were assigned to host channels.
+ */
+dwc_otg_transaction_type_e dwc_otg_hcd_select_transactions(dwc_otg_hcd_t *_hcd)
+{
+	struct list_head 		*qh_ptr;
+	dwc_otg_qh_t 			*qh;
+	int				num_channels;
+	dwc_otg_transaction_type_e	ret_val = DWC_OTG_TRANSACTION_NONE;
+
+#ifdef DEBUG_SOF
+	DWC_DEBUGPL(DBG_HCD, "  Select Transactions\n");
+#endif
+
+	/* Process entries in the periodic ready list. */
+	qh_ptr = _hcd->periodic_sched_ready.next;
+	while (qh_ptr != &_hcd->periodic_sched_ready &&
+	        !list_empty(&_hcd->free_hc_list)) {
+
+		qh = list_entry(qh_ptr, dwc_otg_qh_t, qh_list_entry);
+		assign_and_init_hc(_hcd, qh);
+
+		/*
+		 * Move the QH from the periodic ready schedule to the
+		 * periodic assigned schedule.
+		 */
+		qh_ptr = qh_ptr->next;
+		list_move(&qh->qh_list_entry, &_hcd->periodic_sched_assigned);
+
+		ret_val = DWC_OTG_TRANSACTION_PERIODIC;
+	}
+
+	/*
+	 * Process entries in the inactive portion of the non-periodic
+	 * schedule. Some free host channels may not be used if they are
+	 * reserved for periodic transfers.
+	 */
+	qh_ptr = _hcd->non_periodic_sched_inactive.next;
+	num_channels = _hcd->core_if->core_params->host_channels;
+	while (qh_ptr != &_hcd->non_periodic_sched_inactive &&
+	        (_hcd->non_periodic_channels <
+	         num_channels - _hcd->periodic_channels) &&
+	        !list_empty(&_hcd->free_hc_list)) {
+
+		qh = list_entry(qh_ptr, dwc_otg_qh_t, qh_list_entry);
+		assign_and_init_hc(_hcd, qh);
+
+		/*
+		 * Move the QH from the non-periodic inactive schedule to the
+		 * non-periodic active schedule.
+		 */
+		qh_ptr = qh_ptr->next;
+		list_move(&qh->qh_list_entry, &_hcd->non_periodic_sched_active);
+
+		if (ret_val == DWC_OTG_TRANSACTION_NONE) {
+			ret_val = DWC_OTG_TRANSACTION_NON_PERIODIC;
+		} else {
+			ret_val = DWC_OTG_TRANSACTION_ALL;
+		}
+
+		_hcd->non_periodic_channels++;
+	}
+
+	return ret_val;
+}
+
+/**
+ * Attempts to queue a single transaction request for a host channel
+ * associated with either a periodic or non-periodic transfer. This function
+ * assumes that there is space available in the appropriate request queue. For
+ * an OUT transfer or SETUP transaction in Slave mode, it checks whether space
+ * is available in the appropriate Tx FIFO.
+ *
+ * @param _hcd The HCD state structure.
+ * @param _hc Host channel descriptor associated with either a periodic or
+ * non-periodic transfer.
+ * @param _fifo_dwords_avail Number of DWORDs available in the periodic Tx
+ * FIFO for periodic transfers or the non-periodic Tx FIFO for non-periodic
+ * transfers.
+ *
+ * @return 1 if a request is queued and more requests may be needed to
+ * complete the transfer, 0 if no more requests are required for this
+ * transfer, -1 if there is insufficient space in the Tx FIFO.
+ */
+static int queue_transaction(dwc_otg_hcd_t *_hcd,
+                             dwc_hc_t *_hc,
+                             uint16_t _fifo_dwords_avail)
+{
+	int retval;
+
+	if (_hcd->core_if->dma_enable) {
+		if (!_hc->xfer_started) {
+			dwc_otg_hc_start_transfer(_hcd->core_if, _hc);
+			_hc->qh->ping_state = 0;
+		}
+		retval = 0;
+	} else 	if (_hc->halt_pending) {
+		/* Don't queue a request if the channel has been halted. */
+		retval = 0;
+	} else if (_hc->halt_on_queue) {
+		dwc_otg_hc_halt(_hcd->core_if, _hc, _hc->halt_status);
+		retval = 0;
+	} else if (_hc->do_ping) {
+		if (!_hc->xfer_started) {
+			dwc_otg_hc_start_transfer(_hcd->core_if, _hc);
+		}
+		retval = 0;
+	} else if (!_hc->ep_is_in ||
+	           _hc->data_pid_start == DWC_OTG_HC_PID_SETUP) {
+		if ((_fifo_dwords_avail * 4) >= _hc->max_packet) {
+			if (!_hc->xfer_started) {
+				dwc_otg_hc_start_transfer(_hcd->core_if, _hc);
+				retval = 1;
+			} else {
+				retval = dwc_otg_hc_continue_transfer(_hcd->core_if, _hc);
+			}
+		} else {
+			retval = -1;
+		}
+	} else {
+		if (!_hc->xfer_started) {
+			dwc_otg_hc_start_transfer(_hcd->core_if, _hc);
+			retval = 1;
+		} else {
+			retval = dwc_otg_hc_continue_transfer(_hcd->core_if, _hc);
+		}
+	}
+
+	return retval;
+}
+
+/**
+ * Processes active non-periodic channels and queues transactions for these
+ * channels to the DWC_otg controller. After queueing transactions, the NP Tx
+ * FIFO Empty interrupt is enabled if there are more transactions to queue as
+ * NP Tx FIFO or request queue space becomes available. Otherwise, the NP Tx
+ * FIFO Empty interrupt is disabled.
+ */
+static void process_non_periodic_channels(dwc_otg_hcd_t *_hcd)
+{
+	gnptxsts_data_t		tx_status;
+	struct list_head	*orig_qh_ptr;
+	dwc_otg_qh_t		*qh;
+	int			status;
+	int			no_queue_space = 0;
+	int			no_fifo_space = 0;
+	int			more_to_do = 0;
+
+	dwc_otg_core_global_regs_t *global_regs = _hcd->core_if->core_global_regs;
+
+	DWC_DEBUGPL(DBG_HCDV, "Queue non-periodic transactions\n");
+#ifdef DEBUG
+	tx_status.d32 = dwc_read_reg32(&global_regs->gnptxsts);
+	DWC_DEBUGPL(DBG_HCDV, "  NP Tx Req Queue Space Avail (before queue): %d\n",
+	            tx_status.b.nptxqspcavail);
+	DWC_DEBUGPL(DBG_HCDV, "  NP Tx FIFO Space Avail (before queue): %d\n",
+	            tx_status.b.nptxfspcavail);
+#endif
+	/*
+	 * Keep track of the starting point. Skip over the start-of-list
+	 * entry.
+	 */
+	if (_hcd->non_periodic_qh_ptr == &_hcd->non_periodic_sched_active) {
+		_hcd->non_periodic_qh_ptr = _hcd->non_periodic_qh_ptr->next;
+	}
+	orig_qh_ptr = _hcd->non_periodic_qh_ptr;
+
+	/*
+	 * Process once through the active list or until no more space is
+	 * available in the request queue or the Tx FIFO.
+	 */
+	do {
+		tx_status.d32 = dwc_read_reg32(&global_regs->gnptxsts);
+		if (!_hcd->core_if->dma_enable && tx_status.b.nptxqspcavail == 0) {
+			no_queue_space = 1;
+			break;
+		}
+
+		qh = list_entry(_hcd->non_periodic_qh_ptr, dwc_otg_qh_t, qh_list_entry);
+		status = queue_transaction(_hcd, qh->channel, tx_status.b.nptxfspcavail);
+
+		if (status > 0) {
+			more_to_do = 1;
+		} else if (status < 0) {
+			no_fifo_space = 1;
+			break;
+		}
+
+		/* Advance to next QH, skipping start-of-list entry. */
+		_hcd->non_periodic_qh_ptr = _hcd->non_periodic_qh_ptr->next;
+		if (_hcd->non_periodic_qh_ptr == &_hcd->non_periodic_sched_active) {
+			_hcd->non_periodic_qh_ptr = _hcd->non_periodic_qh_ptr->next;
+		}
+
+	} while (_hcd->non_periodic_qh_ptr != orig_qh_ptr);
+
+	if (!_hcd->core_if->dma_enable) {
+		gintmsk_data_t intr_mask = {.d32 = 0};
+		intr_mask.b.nptxfempty = 1;
+
+#ifdef DEBUG
+		tx_status.d32 = dwc_read_reg32(&global_regs->gnptxsts);
+		DWC_DEBUGPL(DBG_HCDV, "  NP Tx Req Queue Space Avail (after queue): %d\n",
+		            tx_status.b.nptxqspcavail);
+		DWC_DEBUGPL(DBG_HCDV, "  NP Tx FIFO Space Avail (after queue): %d\n",
+		            tx_status.b.nptxfspcavail);
+#endif
+		if (more_to_do || no_queue_space || no_fifo_space) {
+			/*
+			 * May need to queue more transactions as the request
+			 * queue or Tx FIFO empties. Enable the non-periodic
+			 * Tx FIFO empty interrupt. (Always use the half-empty
+			 * level to ensure that new requests are loaded as
+			 * soon as possible.)
+			 */
+			dwc_modify_reg32(&global_regs->gintmsk, 0, intr_mask.d32);
+		} else {
+			/*
+			 * Disable the Tx FIFO empty interrupt since there are
+			 * no more transactions that need to be queued right
+			 * now. This function is called from interrupt
+			 * handlers to queue more transactions as transfer
+			 * states change.
+			 */
+			dwc_modify_reg32(&global_regs->gintmsk, intr_mask.d32, 0);
+		}
+	}
+}
+
+/**
+ * Processes periodic channels for the next frame and queues transactions for
+ * these channels to the DWC_otg controller. After queueing transactions, the
+ * Periodic Tx FIFO Empty interrupt is enabled if there are more transactions
+ * to queue as Periodic Tx FIFO or request queue space becomes available.
+ * Otherwise, the Periodic Tx FIFO Empty interrupt is disabled.
+ */
+static void process_periodic_channels(dwc_otg_hcd_t *_hcd)
+{
+	hptxsts_data_t		tx_status;
+	struct list_head	*qh_ptr;
+	dwc_otg_qh_t		*qh;
+	int			status;
+	int 			no_queue_space = 0;
+	int			no_fifo_space = 0;
+
+	dwc_otg_host_global_regs_t *host_regs;
+	host_regs = _hcd->core_if->host_if->host_global_regs;
+
+	DWC_DEBUGPL(DBG_HCDV, "Queue periodic transactions\n");
+#ifdef DEBUG
+	tx_status.d32 = dwc_read_reg32(&host_regs->hptxsts);
+	DWC_DEBUGPL(DBG_HCDV, "  P Tx Req Queue Space Avail (before queue): %d\n",
+	            tx_status.b.ptxqspcavail);
+	DWC_DEBUGPL(DBG_HCDV, "  P Tx FIFO Space Avail (before queue): %d\n",
+	            tx_status.b.ptxfspcavail);
+#endif
+
+	qh_ptr = _hcd->periodic_sched_assigned.next;
+	while (qh_ptr != &_hcd->periodic_sched_assigned) {
+		tx_status.d32 = dwc_read_reg32(&host_regs->hptxsts);
+		if (tx_status.b.ptxqspcavail == 0) {
+			no_queue_space = 1;
+			break;
+		}
+
+		qh = list_entry(qh_ptr, dwc_otg_qh_t, qh_list_entry);
+
+		/*
+		 * Set a flag if we're queuing high-bandwidth in slave mode.
+		 * The flag prevents any halts to get into the request queue in
+		 * the middle of multiple high-bandwidth packets getting queued.
+		 */
+		if ((!_hcd->core_if->dma_enable) &&
+		        (qh->channel->multi_count > 1))
+		{
+			_hcd->core_if->queuing_high_bandwidth = 1;
+		}
+
+		status = queue_transaction(_hcd, qh->channel, tx_status.b.ptxfspcavail);
+		if (status < 0) {
+			no_fifo_space = 1;
+			break;
+		}
+
+		/*
+		 * In Slave mode, stay on the current transfer until there is
+		 * nothing more to do or the high-bandwidth request count is
+		 * reached. In DMA mode, only need to queue one request. The
+		 * controller automatically handles multiple packets for
+		 * high-bandwidth transfers.
+		 */
+		if (_hcd->core_if->dma_enable ||
+		        (status == 0 ||
+		         qh->channel->requests == qh->channel->multi_count)) {
+			qh_ptr = qh_ptr->next;
+			/*
+			 * Move the QH from the periodic assigned schedule to
+			 * the periodic queued schedule.
+			 */
+			list_move(&qh->qh_list_entry, &_hcd->periodic_sched_queued);
+
+			/* done queuing high bandwidth */
+			_hcd->core_if->queuing_high_bandwidth = 0;
+		}
+	}
+
+	if (!_hcd->core_if->dma_enable) {
+		dwc_otg_core_global_regs_t *global_regs;
+		gintmsk_data_t intr_mask = {.d32 = 0};
+
+		global_regs = _hcd->core_if->core_global_regs;
+		intr_mask.b.ptxfempty = 1;
+#ifdef DEBUG
+		tx_status.d32 = dwc_read_reg32(&host_regs->hptxsts);
+		DWC_DEBUGPL(DBG_HCDV, "  P Tx Req Queue Space Avail (after queue): %d\n",
+		            tx_status.b.ptxqspcavail);
+		DWC_DEBUGPL(DBG_HCDV, "  P Tx FIFO Space Avail (after queue): %d\n",
+		            tx_status.b.ptxfspcavail);
+#endif
+		if (!(list_empty(&_hcd->periodic_sched_assigned)) ||
+		        no_queue_space || no_fifo_space) {
+			/*
+			 * May need to queue more transactions as the request
+			 * queue or Tx FIFO empties. Enable the periodic Tx
+			 * FIFO empty interrupt. (Always use the half-empty
+			 * level to ensure that new requests are loaded as
+			 * soon as possible.)
+			 */
+			dwc_modify_reg32(&global_regs->gintmsk, 0, intr_mask.d32);
+		} else {
+			/*
+			 * Disable the Tx FIFO empty interrupt since there are
+			 * no more transactions that need to be queued right
+			 * now. This function is called from interrupt
+			 * handlers to queue more transactions as transfer
+			 * states change.
+			 */
+			dwc_modify_reg32(&global_regs->gintmsk, intr_mask.d32, 0);
+		}
+	}
+}
+
+/**
+ * This function processes the currently active host channels and queues
+ * transactions for these channels to the DWC_otg controller. It is called
+ * from HCD interrupt handler functions.
+ *
+ * @param _hcd The HCD state structure.
+ * @param _tr_type The type(s) of transactions to queue (non-periodic,
+ * periodic, or both).
+ */
+void dwc_otg_hcd_queue_transactions(dwc_otg_hcd_t *_hcd,
+                                    dwc_otg_transaction_type_e _tr_type)
+{
+#ifdef DEBUG_SOF
+	DWC_DEBUGPL(DBG_HCD, "Queue Transactions\n");
+#endif
+	/* Process host channels associated with periodic transfers. */
+	if ((_tr_type == DWC_OTG_TRANSACTION_PERIODIC ||
+	        _tr_type == DWC_OTG_TRANSACTION_ALL) &&
+	        !list_empty(&_hcd->periodic_sched_assigned)) {
+
+		process_periodic_channels(_hcd);
+	}
+
+	/* Process host channels associated with non-periodic transfers. */
+	if ((_tr_type == DWC_OTG_TRANSACTION_NON_PERIODIC ||
+	        _tr_type == DWC_OTG_TRANSACTION_ALL)) {
+		if (!list_empty(&_hcd->non_periodic_sched_active)) {
+			process_non_periodic_channels(_hcd);
+		} else {
+			/*
+			 * Ensure NP Tx FIFO empty interrupt is disabled when
+			 * there are no non-periodic transfers to process.
+			 */
+			gintmsk_data_t gintmsk = {.d32 = 0};
+			gintmsk.b.nptxfempty = 1;
+			dwc_modify_reg32(&_hcd->core_if->core_global_regs->gintmsk,
+			                 gintmsk.d32, 0);
+		}
+	}
+}
+
+/**
+ * Sets the final status of an URB and returns it to the device driver. Any
+ * required cleanup of the URB is performed.
+ */
+void dwc_otg_hcd_complete_urb(dwc_otg_hcd_t *_hcd, struct urb *_urb, int _status)
+{
+
+#ifdef DEBUG
+	if (CHK_DEBUG_LEVEL(DBG_HCD_URB)) 
+		DWC_PRINT("%s: urb %p, device %d, ep %d %s, status=%d\n",
+	          __func__, _urb, usb_pipedevice(_urb->pipe),
+	          usb_pipeendpoint(_urb->pipe),
+	          usb_pipein(_urb->pipe) ? "IN" : "OUT", _status);
+	if (usb_pipetype(_urb->pipe) == PIPE_ISOCHRONOUS) {
+		int i;
+		for (i = 0; i < _urb->number_of_packets; i++) {
+			DWC_PRINT("  ISO Desc %d status: %d\n",
+			          i, _urb->iso_frame_desc[i].status);
+		}
+	}
+#endif
+
+	_urb->status = _status;
+	_urb->hcpriv = NULL;
+	usb_hcd_giveback_urb(dwc_otg_hcd_to_hcd(_hcd), _urb, _status);
+}
+
+/*
+ * Returns the Queue Head for an URB.
+ */
+dwc_otg_qh_t *dwc_urb_to_qh(struct urb *_urb)
+{
+	struct usb_host_endpoint *ep = dwc_urb_to_endpoint(_urb);
+	return (dwc_otg_qh_t *)ep->hcpriv;
+}
+
+#ifdef DEBUG
+void dwc_print_setup_data (uint8_t *setup)
+{
+	int i;
+	if (CHK_DEBUG_LEVEL(DBG_HCD)){
+		DWC_PRINT("Setup Data = MSB ");
+		for (i=7; i>=0; i--) DWC_PRINT ("%02x ", setup[i]);
+		DWC_PRINT("\n");
+		DWC_PRINT("  bmRequestType Tranfer = %s\n", (setup[0]&0x80) ? "Device-to-Host" : "Host-to-Device");
+		DWC_PRINT("  bmRequestType Type = ");
+		switch ((setup[0]&0x60) >> 5) {
+		case 0: DWC_PRINT("Standard\n"); break;
+		case 1:	DWC_PRINT("Class\n"); break;
+		case 2:	DWC_PRINT("Vendor\n"); break;
+		case 3: DWC_PRINT("Reserved\n"); break;
+		}
+		DWC_PRINT("  bmRequestType Recipient = ");
+		switch (setup[0]&0x1f) {
+		case 0: DWC_PRINT("Device\n"); break;
+		case 1: DWC_PRINT("Interface\n"); break;
+		case 2: DWC_PRINT("Endpoint\n"); break;
+		case 3: DWC_PRINT("Other\n"); break;
+		default: DWC_PRINT("Reserved\n"); break;
+		}
+		DWC_PRINT("  bRequest = 0x%0x\n", setup[1]);
+		DWC_PRINT("  wValue = 0x%0x\n", *((uint16_t *)&setup[2]));
+		DWC_PRINT("  wIndex = 0x%0x\n", *((uint16_t *)&setup[4]));
+		DWC_PRINT("  wLength = 0x%0x\n\n", *((uint16_t *)&setup[6]));
+	}
+}
+#endif
+
+void dwc_otg_hcd_dump_frrem(dwc_otg_hcd_t *_hcd) {
+#ifdef DEBUG
+	DWC_PRINT("Frame remaining at SOF:\n");
+	DWC_PRINT("  samples %u, accum %llu, avg %llu/%u\n",
+	          _hcd->frrem_samples, _hcd->frrem_accum,
+	          _hcd->frrem_accum, _hcd->frrem_samples);
+	//DWC_PRINT("  samples %u, accum %llu, avg %llu\n",			//[TCC] FIXME: NOT SUPPORT 64Bit division!!!
+	//	  _hcd->frrem_samples, _hcd->frrem_accum,
+	//	  (_hcd->frrem_samples > 0) ?
+	//	  _hcd->frrem_accum/_hcd->frrem_samples : 0);
+
+	DWC_PRINT("\n");
+	DWC_PRINT("Frame remaining at start_transfer (uframe 7):\n");
+	DWC_PRINT("  samples %u, accum %llu, avg %llu/%u\n",
+	          _hcd->core_if->hfnum_7_samples, _hcd->core_if->hfnum_7_frrem_accum,
+	          _hcd->core_if->hfnum_7_frrem_accum, _hcd->core_if->hfnum_7_samples);
+	//DWC_PRINT("  samples %u, accum %llu, avg %llu\n",
+	//	  _hcd->core_if->hfnum_7_samples, _hcd->core_if->hfnum_7_frrem_accum,
+	//	  (_hcd->core_if->hfnum_7_samples > 0) ?
+	//	  _hcd->core_if->hfnum_7_frrem_accum/_hcd->core_if->hfnum_7_samples : 0);
+	DWC_PRINT("Frame remaining at start_transfer (uframe 0):\n");
+	DWC_PRINT("  samples %u, accum %llu, avg %llu/%u\n",
+	          _hcd->core_if->hfnum_0_samples, _hcd->core_if->hfnum_0_frrem_accum,
+	          _hcd->core_if->hfnum_0_frrem_accum, _hcd->core_if->hfnum_0_samples);
+	//DWC_PRINT("  samples %u, accum %llu, avg %llu\n",
+	//	  _hcd->core_if->hfnum_0_samples, _hcd->core_if->hfnum_0_frrem_accum,
+	//	  (_hcd->core_if->hfnum_0_samples > 0) ?
+	//	  _hcd->core_if->hfnum_0_frrem_accum/_hcd->core_if->hfnum_0_samples : 0);
+	DWC_PRINT("Frame remaining at start_transfer (uframe 1-6):\n");
+	DWC_PRINT("  samples %u, accum %llu, avg %llu/%u\n",
+	          _hcd->core_if->hfnum_other_samples, _hcd->core_if->hfnum_other_frrem_accum,
+	          _hcd->core_if->hfnum_other_frrem_accum, _hcd->core_if->hfnum_other_samples);
+	//DWC_PRINT("  samples %u, accum %llu, avg %llu\n",
+	//	  _hcd->core_if->hfnum_other_samples, _hcd->core_if->hfnum_other_frrem_accum,
+	//	  (_hcd->core_if->hfnum_other_samples > 0) ?
+	//	  _hcd->core_if->hfnum_other_frrem_accum/_hcd->core_if->hfnum_other_samples : 0);
+
+	DWC_PRINT("\n");
+	DWC_PRINT("Frame remaining at sample point A (uframe 7):\n");
+	DWC_PRINT("  samples %u, accum %llu, avg %llu/%u\n",
+	          _hcd->hfnum_7_samples_a, _hcd->hfnum_7_frrem_accum_a,
+	          _hcd->hfnum_7_frrem_accum_a, _hcd->hfnum_7_samples_a);
+	//DWC_PRINT("  samples %u, accum %llu, avg %llu\n",
+	//	  _hcd->hfnum_7_samples_a, _hcd->hfnum_7_frrem_accum_a,
+	//	  (_hcd->hfnum_7_samples_a > 0) ?
+	//	  _hcd->hfnum_7_frrem_accum_a/_hcd->hfnum_7_samples_a : 0);
+	DWC_PRINT("Frame remaining at sample point A (uframe 0):\n");
+	DWC_PRINT("  samples %u, accum %llu, avg %llu/%u\n",
+	          _hcd->hfnum_0_samples_a, _hcd->hfnum_0_frrem_accum_a,
+	          _hcd->hfnum_0_frrem_accum_a, _hcd->hfnum_0_samples_a);
+	//DWC_PRINT("  samples %u, accum %llu, avg %llu\n",
+	//	  _hcd->hfnum_0_samples_a, _hcd->hfnum_0_frrem_accum_a,
+	//	  (_hcd->hfnum_0_samples_a > 0) ?
+	//	  _hcd->hfnum_0_frrem_accum_a/_hcd->hfnum_0_samples_a : 0);
+	DWC_PRINT("Frame remaining at sample point A (uframe 1-6):\n");
+	DWC_PRINT("  samples %u, accum %llu, avg %llu/%u\n",
+	          _hcd->hfnum_other_samples_a, _hcd->hfnum_other_frrem_accum_a,
+	          _hcd->hfnum_other_frrem_accum_a, _hcd->hfnum_other_samples_a);
+	//DWC_PRINT("  samples %u, accum %llu, avg %llu\n",
+	//	  _hcd->hfnum_other_samples_a, _hcd->hfnum_other_frrem_accum_a,
+	//	  (_hcd->hfnum_other_samples_a > 0) ?
+	//	  _hcd->hfnum_other_frrem_accum_a/_hcd->hfnum_other_samples_a : 0);
+
+	DWC_PRINT("\n");
+	DWC_PRINT("Frame remaining at sample point B (uframe 7):\n");
+	DWC_PRINT("  samples %u, accum %llu, avg %llu/%u\n",
+	          _hcd->hfnum_7_samples_b, _hcd->hfnum_7_frrem_accum_b,
+	          _hcd->hfnum_7_frrem_accum_b, _hcd->hfnum_7_samples_b);
+	//DWC_PRINT("  samples %u, accum %llu, avg %llu\n",
+	//	  _hcd->hfnum_7_samples_b, _hcd->hfnum_7_frrem_accum_b,
+	//	  (_hcd->hfnum_7_samples_b > 0) ?
+	//	  _hcd->hfnum_7_frrem_accum_b/_hcd->hfnum_7_samples_b : 0);
+	DWC_PRINT("Frame remaining at sample point B (uframe 0):\n");
+	DWC_PRINT("  samples %u, accum %llu, avg %llu/%u\n",
+	          _hcd->hfnum_0_samples_b, _hcd->hfnum_0_frrem_accum_b,
+	          _hcd->hfnum_0_frrem_accum_b, _hcd->hfnum_0_samples_b);
+	//DWC_PRINT("  samples %u, accum %llu, avg %llu\n",
+	//	  _hcd->hfnum_0_samples_b, _hcd->hfnum_0_frrem_accum_b,
+	//	  (_hcd->hfnum_0_samples_b > 0) ?
+	//	  _hcd->hfnum_0_frrem_accum_b/_hcd->hfnum_0_samples_b : 0);
+	DWC_PRINT("Frame remaining at sample point B (uframe 1-6):\n");
+	DWC_PRINT("  samples %u, accum %llu, avg %llu/%u\n",
+	          _hcd->hfnum_other_samples_b, _hcd->hfnum_other_frrem_accum_b,
+	          _hcd->hfnum_other_frrem_accum_b, _hcd->hfnum_other_samples_b);
+	//DWC_PRINT("  samples %u, accum %llu, avg %llu\n",
+	//	  _hcd->hfnum_other_samples_b, _hcd->hfnum_other_frrem_accum_b,
+	//	  (_hcd->hfnum_other_samples_b > 0) ?
+	//	  _hcd->hfnum_other_frrem_accum_b/_hcd->hfnum_other_samples_b : 0);
+#endif
+}
+
+void dwc_otg_hcd_dump_state(dwc_otg_hcd_t *_hcd)
+{
+#ifdef DEBUG
+	int num_channels;
+	int i;
+	gnptxsts_data_t	np_tx_status;
+	hptxsts_data_t p_tx_status;
+
+	num_channels = _hcd->core_if->core_params->host_channels;
+	DWC_PRINT("\n");
+	DWC_PRINT("************************************************************\n");
+	DWC_PRINT("HCD State:\n");
+	DWC_PRINT("  Num channels: %d\n", num_channels);
+	for (i = 0; i < num_channels; i++) {
+		dwc_hc_t *hc = _hcd->hc_ptr_array[i];
+		DWC_PRINT("  Channel %d:\n", i);
+		DWC_PRINT("    dev_addr: %d, ep_num: %d, ep_is_in: %d\n",
+		          hc->dev_addr, hc->ep_num, hc->ep_is_in);
+		DWC_PRINT("    speed: %d\n", hc->speed);
+		DWC_PRINT("    ep_type: %d\n", hc->ep_type);
+		DWC_PRINT("    max_packet: %d\n", hc->max_packet);
+		DWC_PRINT("    data_pid_start: %d\n", hc->data_pid_start);
+		DWC_PRINT("    multi_count: %d\n", hc->multi_count);
+		DWC_PRINT("    xfer_started: %d\n", hc->xfer_started);
+		DWC_PRINT("    xfer_buff: %p\n", hc->xfer_buff);
+		DWC_PRINT("    xfer_len: %d\n", hc->xfer_len);
+		DWC_PRINT("    xfer_count: %d\n", hc->xfer_count);
+		DWC_PRINT("    halt_on_queue: %d\n", hc->halt_on_queue);
+		DWC_PRINT("    halt_pending: %d\n", hc->halt_pending);
+		DWC_PRINT("    halt_status: %d\n", hc->halt_status);
+		DWC_PRINT("    do_split: %d\n", hc->do_split);
+		DWC_PRINT("    complete_split: %d\n", hc->complete_split);
+		DWC_PRINT("    hub_addr: %d\n", hc->hub_addr);
+		DWC_PRINT("    port_addr: %d\n", hc->port_addr);
+		DWC_PRINT("    xact_pos: %d\n", hc->xact_pos);
+		DWC_PRINT("    requests: %d\n", hc->requests);
+		DWC_PRINT("    qh: %p\n", hc->qh);
+		if (hc->xfer_started) {
+			hfnum_data_t hfnum;
+			hcchar_data_t hcchar;
+			hctsiz_data_t hctsiz;
+			hcint_data_t hcint;
+			hcintmsk_data_t hcintmsk;
+			hfnum.d32 = dwc_read_reg32(&_hcd->core_if->host_if->host_global_regs->hfnum);
+			hcchar.d32 = dwc_read_reg32(&_hcd->core_if->host_if->hc_regs[i]->hcchar);
+			hctsiz.d32 = dwc_read_reg32(&_hcd->core_if->host_if->hc_regs[i]->hctsiz);
+			hcint.d32 = dwc_read_reg32(&_hcd->core_if->host_if->hc_regs[i]->hcint);
+			hcintmsk.d32 = dwc_read_reg32(&_hcd->core_if->host_if->hc_regs[i]->hcintmsk);
+			DWC_PRINT("    hfnum: 0x%08x\n", hfnum.d32);
+			DWC_PRINT("    hcchar: 0x%08x\n", hcchar.d32);
+			DWC_PRINT("    hctsiz: 0x%08x\n", hctsiz.d32);
+			DWC_PRINT("    hcint: 0x%08x\n", hcint.d32);
+			DWC_PRINT("    hcintmsk: 0x%08x\n", hcintmsk.d32);
+		}
+		if (hc->xfer_started && (hc->qh != NULL) && (hc->qh->qtd_in_process != NULL)) {
+			dwc_otg_qtd_t *qtd;
+			struct urb *urb;
+			qtd = hc->qh->qtd_in_process;
+			urb = qtd->urb;
+			DWC_PRINT("    URB Info:\n");
+			DWC_PRINT("      qtd: %p, urb: %p\n", qtd, urb);
+			if (urb != NULL) {
+				DWC_PRINT("      Dev: %d, EP: %d %s\n",
+				          usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe),
+				          usb_pipein(urb->pipe) ? "IN" : "OUT");
+				DWC_PRINT("      Max packet size: %d\n",
+				          usb_maxpacket(urb->dev, urb->pipe, usb_pipeout(urb->pipe)));
+				DWC_PRINT("      transfer_buffer: %p\n", urb->transfer_buffer);
+				DWC_PRINT("      transfer_dma: %p\n", (void *)urb->transfer_dma);
+				DWC_PRINT("      transfer_buffer_length: %d\n", urb->transfer_buffer_length);
+				DWC_PRINT("      actual_length: %d\n", urb->actual_length);
+			}
+		}
+	}
+	DWC_PRINT("  non_periodic_channels: %d\n", _hcd->non_periodic_channels);
+	DWC_PRINT("  periodic_channels: %d\n", _hcd->periodic_channels);
+	DWC_PRINT("  periodic_usecs: %d\n", _hcd->periodic_usecs);
+	np_tx_status.d32 = dwc_read_reg32(&_hcd->core_if->core_global_regs->gnptxsts);
+	DWC_PRINT("  NP Tx Req Queue Space Avail: %d\n", np_tx_status.b.nptxqspcavail);
+	DWC_PRINT("  NP Tx FIFO Space Avail: %d\n", np_tx_status.b.nptxfspcavail);
+	p_tx_status.d32 = dwc_read_reg32(&_hcd->core_if->host_if->host_global_regs->hptxsts);
+	DWC_PRINT("  P Tx Req Queue Space Avail: %d\n", p_tx_status.b.ptxqspcavail);
+	DWC_PRINT("  P Tx FIFO Space Avail: %d\n", p_tx_status.b.ptxfspcavail);
+	dwc_otg_hcd_dump_frrem(_hcd);
+	dwc_otg_dump_global_registers(_hcd->core_if);
+	dwc_otg_dump_host_registers(_hcd->core_if);
+	DWC_PRINT("************************************************************\n");
+	DWC_PRINT("\n");
+#endif
+}
+#endif /* DWC_DEVICE_ONLY */
Index: linux-2.6.29/drivers/usb/dwc_otg/dwc_otg_hcd.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/usb/dwc_otg/dwc_otg_hcd.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,650 @@
+/* ==========================================================================
+ * $File: //dwh/usb_iip/dev/software/otg_ipmate/linux/drivers/dwc_otg_hcd.h $
+ * $Revision: #6 $
+ * $Date: 2006/12/05 $
+ * $Change: 762293 $
+ *
+ * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
+ * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto. You are permitted to use and
+ * redistribute this Software in source and binary forms, with or without
+ * modification, provided that redistributions of source code must retain this
+ * notice. You may not view, use, disclose, copy or distribute this file or
+ * any information contained herein except pursuant to this license grant from
+ * Synopsys. If you do not agree with this notice, including the disclaimer
+ * below, then you are not authorized to use the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================== */
+#ifndef DWC_DEVICE_ONLY
+#ifndef __DWC_HCD_H__
+#define __DWC_HCD_H__
+
+#include <linux/list.h>
+#include <linux/usb.h>
+#include "../core/hcd.h"
+
+#ifdef _USE_ATTR_
+struct lm_device;
+#endif
+struct dwc_otg_device;
+
+#include "dwc_otg_cil.h"
+
+/**
+ * @file
+ *
+ * This file contains the structures, constants, and interfaces for
+ * the Host Contoller Driver (HCD).
+ *
+ * The Host Controller Driver (HCD) is responsible for translating requests
+ * from the USB Driver into the appropriate actions on the DWC_otg controller.
+ * It isolates the USBD from the specifics of the controller by providing an
+ * API to the USBD.
+ */
+
+/**
+ * Phases for control transfers.
+ */
+typedef enum dwc_otg_control_phase {
+	DWC_OTG_CONTROL_SETUP,
+	DWC_OTG_CONTROL_DATA,
+	DWC_OTG_CONTROL_STATUS
+} dwc_otg_control_phase_e;
+
+/** Transaction types. */
+typedef enum dwc_otg_transaction_type {
+	DWC_OTG_TRANSACTION_NONE,
+	DWC_OTG_TRANSACTION_PERIODIC,
+	DWC_OTG_TRANSACTION_NON_PERIODIC,
+	DWC_OTG_TRANSACTION_ALL
+} dwc_otg_transaction_type_e;
+
+/**
+ * A Queue Transfer Descriptor (QTD) holds the state of a bulk, control,
+ * interrupt, or isochronous transfer. A single QTD is created for each URB
+ * (of one of these types) submitted to the HCD. The transfer associated with
+ * a QTD may require one or multiple transactions.
+ *
+ * A QTD is linked to a Queue Head, which is entered in either the
+ * non-periodic or periodic schedule for execution. When a QTD is chosen for
+ * execution, some or all of its transactions may be executed. After
+ * execution, the state of the QTD is updated. The QTD may be retired if all
+ * its transactions are complete or if an error occurred. Otherwise, it
+ * remains in the schedule so more transactions can be executed later.
+ */
+typedef struct dwc_otg_qtd {
+	/**
+	 * Determines the PID of the next data packet for the data phase of
+	 * control transfers. Ignored for other transfer types.<br>
+	 * One of the following values:
+	 *	- DWC_OTG_HC_PID_DATA0
+	 *	- DWC_OTG_HC_PID_DATA1
+	 */
+	uint8_t			data_toggle;
+
+	/** Current phase for control transfers (Setup, Data, or Status). */
+	dwc_otg_control_phase_e	control_phase;
+
+	/** Keep track of the current split type
+	 * for FS/LS endpoints on a HS Hub */
+	uint8_t                 complete_split;
+
+	/** How many bytes transferred during SSPLIT OUT */
+	uint32_t                ssplit_out_xfer_count;
+
+	/**
+	 * Holds the number of bus errors that have occurred for a transaction
+	 * within this transfer.
+	 */
+	uint8_t 		error_count;
+
+	/**
+	 * Index of the next frame descriptor for an isochronous transfer. A
+	 * frame descriptor describes the buffer position and length of the
+	 * data to be transferred in the next scheduled (micro)frame of an
+	 * isochronous transfer. It also holds status for that transaction.
+	 * The frame index starts at 0.
+	 */
+	int			isoc_frame_index;
+
+	/** Position of the ISOC split on full/low speed */
+	uint8_t                 isoc_split_pos;
+
+	/** Position of the ISOC split in the buffer for the current frame */
+	uint16_t                isoc_split_offset;
+
+	/** URB for this transfer */
+	struct urb 		*urb;
+
+	/** This list of QTDs */
+	struct list_head  	qtd_list_entry;
+
+} dwc_otg_qtd_t;
+
+/**
+ * A Queue Head (QH) holds the static characteristics of an endpoint and
+ * maintains a list of transfers (QTDs) for that endpoint. A QH structure may
+ * be entered in either the non-periodic or periodic schedule.
+ */
+typedef struct dwc_otg_qh {
+	/**
+	 * Endpoint type.
+	 * One of the following values:
+	 * 	- USB_ENDPOINT_XFER_CONTROL
+	 *	- USB_ENDPOINT_XFER_ISOC
+	 *	- USB_ENDPOINT_XFER_BULK
+	 *	- USB_ENDPOINT_XFER_INT
+	 */
+	uint8_t 		ep_type;
+	uint8_t 		ep_is_in;
+
+	/** wMaxPacketSize Field of Endpoint Descriptor. */
+	uint16_t		maxp;
+
+	/**
+	 * Determines the PID of the next data packet for non-control
+	 * transfers. Ignored for control transfers.<br>
+	 * One of the following values:
+	 *	- DWC_OTG_HC_PID_DATA0
+	 * 	- DWC_OTG_HC_PID_DATA1
+	 */
+	uint8_t			data_toggle;
+
+	/** Ping state if 1. */
+	uint8_t 		ping_state;
+
+	/**
+	 * List of QTDs for this QH.
+	 */
+	struct list_head 	qtd_list;
+
+	/** Host channel currently processing transfers for this QH. */
+	dwc_hc_t		*channel;
+
+	/** QTD currently assigned to a host channel for this QH. */
+	dwc_otg_qtd_t		*qtd_in_process;
+
+	/** Full/low speed endpoint on high-speed hub requires split. */
+	uint8_t                 do_split;
+
+	/** @name Periodic schedule information */
+	/** @{ */
+
+	/** Bandwidth in microseconds per (micro)frame. */
+	uint8_t			usecs;
+
+	/** Interval between transfers in (micro)frames. */
+	uint16_t		interval;
+
+	/**
+	 * (micro)frame to initialize a periodic transfer. The transfer
+	 * executes in the following (micro)frame.
+	 */
+	uint16_t		sched_frame;
+
+	/** (micro)frame at which last start split was initialized. */
+	uint16_t		start_split_frame;
+
+	/** @} */
+
+	/** Entry for QH in either the periodic or non-periodic schedule. */
+	struct list_head        qh_list_entry;
+} dwc_otg_qh_t;
+
+/**
+ * This structure holds the state of the HCD, including the non-periodic and
+ * periodic schedules.
+ */
+typedef struct dwc_otg_hcd {
+
+	/** DWC OTG Core Interface Layer */
+	dwc_otg_core_if_t       *core_if;
+
+	/** Internal DWC HCD Flags */
+	volatile union dwc_otg_hcd_internal_flags {
+		uint32_t d32;
+		struct {
+			unsigned port_connect_status_change : 1;
+			unsigned port_connect_status : 1;
+			unsigned port_reset_change : 1;
+			unsigned port_enable_change : 1;
+			unsigned port_suspend_change : 1;
+			unsigned port_over_current_change : 1;
+			unsigned reserved : 27;
+		} b;
+	} flags;
+
+	/**
+	 * Inactive items in the non-periodic schedule. This is a list of
+	 * Queue Heads. Transfers associated with these Queue Heads are not
+	 * currently assigned to a host channel.
+	 */
+	struct list_head 	non_periodic_sched_inactive;
+
+	/**
+	 * Active items in the non-periodic schedule. This is a list of
+	 * Queue Heads. Transfers associated with these Queue Heads are
+	 * currently assigned to a host channel.
+	 */
+	struct list_head 	non_periodic_sched_active;
+
+	/**
+	 * Pointer to the next Queue Head to process in the active
+	 * non-periodic schedule.
+	 */
+	struct list_head 	*non_periodic_qh_ptr;
+
+	/**
+	 * Inactive items in the periodic schedule. This is a list of QHs for
+	 * periodic transfers that are _not_ scheduled for the next frame.
+	 * Each QH in the list has an interval counter that determines when it
+	 * needs to be scheduled for execution. This scheduling mechanism
+	 * allows only a simple calculation for periodic bandwidth used (i.e.
+	 * must assume that all periodic transfers may need to execute in the
+	 * same frame). However, it greatly simplifies scheduling and should
+	 * be sufficient for the vast majority of OTG hosts, which need to
+	 * connect to a small number of peripherals at one time.
+	 *
+	 * Items move from this list to periodic_sched_ready when the QH
+	 * interval counter is 0 at SOF.
+	 */
+	struct list_head	periodic_sched_inactive;
+
+	/**
+	 * List of periodic QHs that are ready for execution in the next
+	 * frame, but have not yet been assigned to host channels.
+	 *
+	 * Items move from this list to periodic_sched_assigned as host
+	 * channels become available during the current frame.
+	 */
+	struct list_head	periodic_sched_ready;
+
+	/**
+	 * List of periodic QHs to be executed in the next frame that are
+	 * assigned to host channels.
+	 *
+	 * Items move from this list to periodic_sched_queued as the
+	 * transactions for the QH are queued to the DWC_otg controller.
+	 */
+	struct list_head	periodic_sched_assigned;
+
+	/**
+	 * List of periodic QHs that have been queued for execution.
+	 *
+	 * Items move from this list to either periodic_sched_inactive or
+	 * periodic_sched_ready when the channel associated with the transfer
+	 * is released. If the interval for the QH is 1, the item moves to
+	 * periodic_sched_ready because it must be rescheduled for the next
+	 * frame. Otherwise, the item moves to periodic_sched_inactive.
+	 */
+	struct list_head	periodic_sched_queued;
+
+	/**
+	 * Total bandwidth claimed so far for periodic transfers. This value
+	 * is in microseconds per (micro)frame. The assumption is that all
+	 * periodic transfers may occur in the same (micro)frame.
+	 */
+	uint16_t		periodic_usecs;
+
+	/**
+	 * Frame number read from the core at SOF. The value ranges from 0 to
+	 * DWC_HFNUM_MAX_FRNUM.
+	 */
+	uint16_t		frame_number;
+
+	/**
+	 * Free host channels in the controller. This is a list of
+	 * dwc_hc_t items.
+	 */
+	struct list_head 	free_hc_list;
+
+	/**
+	 * Number of host channels assigned to periodic transfers. Currently
+	 * assuming that there is a dedicated host channel for each periodic
+	 * transaction and at least one host channel available for
+	 * non-periodic transactions.
+	 */
+	int			periodic_channels;
+
+	/**
+	 * Number of host channels assigned to non-periodic transfers.
+	 */
+	int			non_periodic_channels;
+
+	/**
+	 * Array of pointers to the host channel descriptors. Allows accessing
+	 * a host channel descriptor given the host channel number. This is
+	 * useful in interrupt handlers.
+	 */
+	dwc_hc_t		*hc_ptr_array[MAX_EPS_CHANNELS];
+
+	/**
+	 * Buffer to use for any data received during the status phase of a
+	 * control transfer. Normally no data is transferred during the status
+	 * phase. This buffer is used as a bit bucket.
+	 */
+	uint8_t			*status_buf;
+
+	/**
+	 * DMA address for status_buf.
+	 */
+	dma_addr_t		status_buf_dma;
+#define DWC_OTG_HCD_STATUS_BUF_SIZE 64
+
+	/**
+	 * Structure to allow starting the HCD in a non-interrupt context
+	 * during an OTG role change.
+	 */
+	struct work_struct	start_work;
+
+	/**
+	 * Connection timer. An OTG host must display a message if the device
+	 * does not connect. Started when the VBus power is turned on via
+	 * sysfs attribute "buspower".
+	 */
+	struct timer_list 	conn_timer;
+
+	/* Tasket to do a reset */
+	struct tasklet_struct   *reset_tasklet;
+
+#ifdef DEBUG
+	uint32_t 		frrem_samples;
+	uint64_t 		frrem_accum;
+
+	uint32_t		hfnum_7_samples_a;
+	uint64_t		hfnum_7_frrem_accum_a;
+	uint32_t		hfnum_0_samples_a;
+	uint64_t		hfnum_0_frrem_accum_a;
+	uint32_t		hfnum_other_samples_a;
+	uint64_t		hfnum_other_frrem_accum_a;
+
+	uint32_t		hfnum_7_samples_b;
+	uint64_t		hfnum_7_frrem_accum_b;
+	uint32_t		hfnum_0_samples_b;
+	uint64_t		hfnum_0_frrem_accum_b;
+	uint32_t		hfnum_other_samples_b;
+	uint64_t		hfnum_other_frrem_accum_b;
+#endif
+
+	/**
+	 * AlenOh
+	 * It stores urb->dev->speed
+	 */
+	uint32_t		speed;
+} dwc_otg_hcd_t;
+
+/** Gets the dwc_otg_hcd from a struct usb_hcd */
+static inline dwc_otg_hcd_t *hcd_to_dwc_otg_hcd(struct usb_hcd *hcd)
+{
+	return (dwc_otg_hcd_t *)(hcd->hcd_priv);
+}
+
+/** Gets the struct usb_hcd that contains a dwc_otg_hcd_t. */
+static inline struct usb_hcd *dwc_otg_hcd_to_hcd(dwc_otg_hcd_t *dwc_otg_hcd)
+{
+	return container_of((void *)dwc_otg_hcd, struct usb_hcd, hcd_priv);
+}
+
+/** @name HCD Create/Destroy Functions */
+/** @{ */
+extern int __init dwc_otg_hcd_init(struct device *dev);
+extern void dwc_otg_hcd_remove(struct device *dev);
+/** @} */
+
+/** @name Linux HC Driver API Functions */
+/** @{ */
+
+extern int dwc_otg_hcd_start(struct usb_hcd *hcd);
+extern void dwc_otg_hcd_stop(struct usb_hcd *hcd);
+extern int dwc_otg_hcd_get_frame_number(struct usb_hcd *hcd);
+extern void dwc_otg_hcd_free(struct usb_hcd *hcd);
+extern int dwc_otg_hcd_urb_enqueue(struct usb_hcd *hcd,
+                                   struct urb *urb,
+                                   gfp_t mem_flags);
+extern int dwc_otg_hcd_urb_dequeue(struct usb_hcd *hcd,
+                                   /*				   struct usb_host_endpoint *ep,*/
+                                   struct urb *urb,
+                                   int status);
+extern void dwc_otg_hcd_endpoint_disable(struct usb_hcd *hcd,
+        struct usb_host_endpoint *ep);
+extern irqreturn_t dwc_otg_hcd_irq(struct usb_hcd *hcd);
+extern int dwc_otg_hcd_hub_status_data(struct usb_hcd *hcd,
+                                       char *buf);
+extern int dwc_otg_hcd_hub_control(struct usb_hcd *hcd,
+                                   u16 typeReq,
+                                   u16 wValue,
+                                   u16 wIndex,
+                                   char *buf,
+                                   u16 wLength);
+
+/** @} */
+
+/** @name Transaction Execution Functions */
+/** @{ */
+extern dwc_otg_transaction_type_e dwc_otg_hcd_select_transactions(dwc_otg_hcd_t *_hcd);
+extern void dwc_otg_hcd_queue_transactions(dwc_otg_hcd_t *_hcd,
+        dwc_otg_transaction_type_e _tr_type);
+extern void dwc_otg_hcd_complete_urb(dwc_otg_hcd_t *_hcd, struct urb *_urb,
+                                     int _status);
+/** @} */
+
+/** @name Interrupt Handler Functions */
+/** @{ */
+extern int32_t dwc_otg_hcd_handle_intr (dwc_otg_hcd_t *_dwc_otg_hcd);
+extern int32_t dwc_otg_hcd_handle_sof_intr (dwc_otg_hcd_t *_dwc_otg_hcd);
+extern int32_t dwc_otg_hcd_handle_rx_status_q_level_intr (dwc_otg_hcd_t *_dwc_otg_hcd);
+extern int32_t dwc_otg_hcd_handle_np_tx_fifo_empty_intr (dwc_otg_hcd_t *_dwc_otg_hcd);
+extern int32_t dwc_otg_hcd_handle_perio_tx_fifo_empty_intr (dwc_otg_hcd_t *_dwc_otg_hcd);
+extern int32_t dwc_otg_hcd_handle_incomplete_periodic_intr(dwc_otg_hcd_t *_dwc_otg_hcd);
+extern int32_t dwc_otg_hcd_handle_port_intr (dwc_otg_hcd_t *_dwc_otg_hcd);
+extern int32_t dwc_otg_hcd_handle_conn_id_status_change_intr (dwc_otg_hcd_t *_dwc_otg_hcd);
+extern int32_t dwc_otg_hcd_handle_disconnect_intr (dwc_otg_hcd_t *_dwc_otg_hcd);
+extern int32_t dwc_otg_hcd_handle_hc_intr (dwc_otg_hcd_t *_dwc_otg_hcd);
+extern int32_t dwc_otg_hcd_handle_hc_n_intr (dwc_otg_hcd_t *_dwc_otg_hcd, uint32_t _num);
+extern int32_t dwc_otg_hcd_handle_session_req_intr (dwc_otg_hcd_t *_dwc_otg_hcd);
+extern int32_t dwc_otg_hcd_handle_wakeup_detected_intr (dwc_otg_hcd_t *_dwc_otg_hcd);
+/** @} */
+
+
+/** @name Schedule Queue Functions */
+/** @{ */
+
+/* Implemented in dwc_otg_hcd_queue.c */
+extern dwc_otg_qh_t *dwc_otg_hcd_qh_create (dwc_otg_hcd_t *_hcd, struct urb *_urb);
+extern void dwc_otg_hcd_qh_init (dwc_otg_hcd_t *_hcd, dwc_otg_qh_t *_qh, struct urb *_urb);
+extern void dwc_otg_hcd_qh_free (dwc_otg_qh_t *_qh);
+extern int dwc_otg_hcd_qh_add (dwc_otg_hcd_t *_hcd, dwc_otg_qh_t *_qh);
+extern void dwc_otg_hcd_qh_remove (dwc_otg_hcd_t *_hcd, dwc_otg_qh_t *_qh);
+extern void dwc_otg_hcd_qh_deactivate (dwc_otg_hcd_t *_hcd, dwc_otg_qh_t *_qh, int sched_csplit);
+
+/** Remove and free a QH */
+static inline void dwc_otg_hcd_qh_remove_and_free (dwc_otg_hcd_t *_hcd,
+        dwc_otg_qh_t *_qh)
+{
+	dwc_otg_hcd_qh_remove (_hcd, _qh);
+	dwc_otg_hcd_qh_free (_qh);
+}
+
+/** Allocates memory for a QH structure.
+ * @return Returns the memory allocate or NULL on error. */
+static inline dwc_otg_qh_t *dwc_otg_hcd_qh_alloc (void)
+{
+	return (dwc_otg_qh_t *) kmalloc (sizeof(dwc_otg_qh_t), GFP_KERNEL);
+}
+
+extern dwc_otg_qtd_t *dwc_otg_hcd_qtd_create (struct urb *urb);
+extern void dwc_otg_hcd_qtd_init (dwc_otg_qtd_t *qtd, struct urb *urb);
+extern int dwc_otg_hcd_qtd_add (dwc_otg_qtd_t *qtd, dwc_otg_hcd_t *dwc_otg_hcd);
+
+/** Allocates memory for a QTD structure.
+ * @return Returns the memory allocate or NULL on error. */
+static inline dwc_otg_qtd_t *dwc_otg_hcd_qtd_alloc (void)
+{
+	return (dwc_otg_qtd_t *) kmalloc (sizeof(dwc_otg_qtd_t), GFP_KERNEL);
+}
+
+/** Frees the memory for a QTD structure.  QTD should already be removed from
+ * list.
+ * @param[in] _qtd QTD to free.*/
+static inline void dwc_otg_hcd_qtd_free (dwc_otg_qtd_t *_qtd)
+{
+	kfree (_qtd);
+}
+
+/** Removes a QTD from list.
+ * @param[in] _qtd QTD to remove from list. */
+static inline void dwc_otg_hcd_qtd_remove (dwc_otg_qtd_t *_qtd)
+{
+	unsigned long flags;
+	local_irq_save (flags);
+	list_del (&_qtd->qtd_list_entry);
+	local_irq_restore (flags);
+}
+
+/** Remove and free a QTD */
+static inline void dwc_otg_hcd_qtd_remove_and_free (dwc_otg_qtd_t *_qtd)
+{
+	dwc_otg_hcd_qtd_remove (_qtd);
+	dwc_otg_hcd_qtd_free (_qtd);
+}
+
+/** @} */
+
+
+/** @name Internal Functions */
+/** @{ */
+dwc_otg_qh_t *dwc_urb_to_qh(struct urb *_urb);
+void dwc_otg_hcd_dump_frrem(dwc_otg_hcd_t *_hcd);
+void dwc_otg_hcd_dump_state(dwc_otg_hcd_t *_hcd);
+/** @} */
+
+/** Gets the usb_host_endpoint associated with an URB. */
+static inline struct usb_host_endpoint *dwc_urb_to_endpoint(struct urb *_urb)
+{
+	struct usb_device *dev = _urb->dev;
+	int ep_num = usb_pipeendpoint(_urb->pipe);
+
+	if (usb_pipein(_urb->pipe))
+		return dev->ep_in[ep_num];
+	else
+		return dev->ep_out[ep_num];
+}
+
+/**
+ * Gets the endpoint number from a _bEndpointAddress argument. The endpoint is
+ * qualified with its direction (possible 32 endpoints per device).
+ */
+#define dwc_ep_addr_to_endpoint(_bEndpointAddress_) ((_bEndpointAddress_ & USB_ENDPOINT_NUMBER_MASK) | \
+                                                     ((_bEndpointAddress_ & USB_DIR_IN) != 0) << 4)
+
+/** Gets the QH that contains the list_head */
+#define dwc_list_to_qh(_list_head_ptr_) (container_of(_list_head_ptr_,dwc_otg_qh_t,qh_list_entry))
+
+/** Gets the QTD that contains the list_head */
+#define dwc_list_to_qtd(_list_head_ptr_) (container_of(_list_head_ptr_,dwc_otg_qtd_t,qtd_list_entry))
+
+/** Check if QH is non-periodic  */
+#define dwc_qh_is_non_per(_qh_ptr_) ((_qh_ptr_->ep_type == USB_ENDPOINT_XFER_BULK) || \
+                                     (_qh_ptr_->ep_type == USB_ENDPOINT_XFER_CONTROL))
+
+/** High bandwidth multiplier as encoded in highspeed endpoint descriptors */
+#define dwc_hb_mult(wMaxPacketSize) (1 + (((wMaxPacketSize) >> 11) & 0x03))
+
+/** Packet size for any kind of endpoint descriptor */
+#define dwc_max_packet(wMaxPacketSize) ((wMaxPacketSize) & 0x07ff)
+
+/**
+ * Returns true if _frame1 is less than or equal to _frame2. The comparison is
+ * done modulo DWC_HFNUM_MAX_FRNUM. This accounts for the rollover of the
+ * frame number when the max frame number is reached.
+ */
+static inline int dwc_frame_num_le(uint16_t _frame1, uint16_t _frame2)
+{
+	return ((_frame2 - _frame1) & DWC_HFNUM_MAX_FRNUM) <=
+	       (DWC_HFNUM_MAX_FRNUM >> 1);
+}
+
+/**
+ * Returns true if _frame1 is greater than _frame2. The comparison is done
+ * modulo DWC_HFNUM_MAX_FRNUM. This accounts for the rollover of the frame
+ * number when the max frame number is reached.
+ */
+static inline int dwc_frame_num_gt(uint16_t _frame1, uint16_t _frame2)
+{
+	return (_frame1 != _frame2) &&
+	       (((_frame1 - _frame2) & DWC_HFNUM_MAX_FRNUM) <
+	        (DWC_HFNUM_MAX_FRNUM >> 1));
+}
+
+/**
+ * Increments _frame by the amount specified by _inc. The addition is done
+ * modulo DWC_HFNUM_MAX_FRNUM. Returns the incremented value.
+ */
+static inline uint16_t dwc_frame_num_inc(uint16_t _frame, uint16_t _inc)
+{
+	return (_frame + _inc) & DWC_HFNUM_MAX_FRNUM;
+}
+
+static inline uint16_t dwc_full_frame_num (uint16_t _frame)
+{
+	return ((_frame) & DWC_HFNUM_MAX_FRNUM) >> 3;
+}
+
+static inline uint16_t dwc_micro_frame_num (uint16_t _frame)
+{
+	return (_frame) & 0x7;
+}
+
+#ifdef DEBUG
+/**
+ * Macro to sample the remaining PHY clocks left in the current frame. This
+ * may be used during debugging to determine the average time it takes to
+ * execute sections of code. There are two possible sample points, "a" and
+ * "b", so the _letter argument must be one of these values.
+ *
+ * To dump the average sample times, read the "hcd_frrem" sysfs attribute. For
+ * example, "cat /sys/devices/lm0/hcd_frrem".
+ */
+#define dwc_sample_frrem(_hcd, _qh, _letter) \
+{ \
+	hfnum_data_t hfnum; \
+	dwc_otg_qtd_t *qtd; \
+	qtd = list_entry(_qh->qtd_list.next, dwc_otg_qtd_t, qtd_list_entry); \
+	if (usb_pipeint(qtd->urb->pipe) && _qh->start_split_frame != 0 && !qtd->complete_split) { \
+		hfnum.d32 = dwc_read_reg32(&_hcd->core_if->host_if->host_global_regs->hfnum); \
+		switch (hfnum.b.frnum & 0x7) { \
+		case 7: \
+			_hcd->hfnum_7_samples_##_letter++; \
+			_hcd->hfnum_7_frrem_accum_##_letter += hfnum.b.frrem; \
+			break; \
+		case 0: \
+			_hcd->hfnum_0_samples_##_letter++; \
+			_hcd->hfnum_0_frrem_accum_##_letter += hfnum.b.frrem; \
+			break; \
+		default: \
+			_hcd->hfnum_other_samples_##_letter++; \
+			_hcd->hfnum_other_frrem_accum_##_letter += hfnum.b.frrem; \
+			break; \
+		} \
+	} \
+}
+#else
+#define dwc_sample_frrem(_hcd, _qh, _letter)
+#endif
+#endif
+#endif /* DWC_DEVICE_ONLY */
Index: linux-2.6.29/drivers/usb/dwc_otg/dwc_otg_hcd_intr.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/usb/dwc_otg/dwc_otg_hcd_intr.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,1820 @@
+/* ==========================================================================
+ * $File: //dwh/usb_iip/dev/software/otg_ipmate/linux/drivers/dwc_otg_hcd_intr.c $
+ * $Revision: #7 $
+ * $Date: 2005/11/02 $
+ * $Change: 553126 $
+ *
+ * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
+ * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto. You are permitted to use and
+ * redistribute this Software in source and binary forms, with or without
+ * modification, provided that redistributions of source code must retain this
+ * notice. You may not view, use, disclose, copy or distribute this file or
+ * any information contained herein except pursuant to this license grant from
+ * Synopsys. If you do not agree with this notice, including the disclaimer
+ * below, then you are not authorized to use the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================== */
+#ifndef DWC_DEVICE_ONLY
+
+#include "dwc_otg_driver.h"
+#include "dwc_otg_hcd.h"
+#include "dwc_otg_regs.h"
+/** @file
+ * This file contains the implementation of the HCD Interrupt handlers.
+ */
+
+/* Display the contents of the buffer */
+extern void dump_msg(const u8 *buf, unsigned int length);
+
+
+/** This function handles interrupts for the HCD. */
+int32_t dwc_otg_hcd_handle_intr (dwc_otg_hcd_t *_dwc_otg_hcd)
+{
+	int retval = 0;
+
+	dwc_otg_core_if_t *core_if = _dwc_otg_hcd->core_if;
+	gintsts_data_t gintsts;
+#ifdef DEBUG
+	dwc_otg_core_global_regs_t *global_regs = core_if->core_global_regs;
+#endif
+
+	/* Check if HOST Mode */
+	if (dwc_otg_is_host_mode(core_if)) {
+		gintsts.d32 = dwc_otg_read_core_intr(core_if);
+		if (!gintsts.d32) {
+			return 0;
+		}
+
+#ifdef DEBUG
+		/* Don't print debug message in the interrupt handler on SOF */
+#  ifndef DEBUG_SOF
+		if (gintsts.d32 != DWC_SOF_INTR_MASK)
+#  endif
+			DWC_DEBUGPL (DBG_HCD, "\n");
+#endif
+
+#ifdef DEBUG
+#  ifndef DEBUG_SOF
+		if (gintsts.d32 != DWC_SOF_INTR_MASK)
+#  endif
+			DWC_DEBUGPL(DBG_HCD, "DWC OTG HCD Interrupt Detected gintsts&gintmsk=0x%08x\n", gintsts.d32);
+#endif
+
+		if (gintsts.b.sofintr) {
+			retval |= dwc_otg_hcd_handle_sof_intr (_dwc_otg_hcd);
+		}
+		if (gintsts.b.rxstsqlvl) {
+			retval |= dwc_otg_hcd_handle_rx_status_q_level_intr (_dwc_otg_hcd);
+		}
+		if (gintsts.b.nptxfempty) {
+			retval |= dwc_otg_hcd_handle_np_tx_fifo_empty_intr (_dwc_otg_hcd);
+		}
+		if (gintsts.b.i2cintr) {
+			/** @todo Implement i2cintr handler. */
+		}
+		if (gintsts.b.portintr) {
+			retval |= dwc_otg_hcd_handle_port_intr (_dwc_otg_hcd);
+		}
+		if (gintsts.b.hcintr) {
+			retval |= dwc_otg_hcd_handle_hc_intr (_dwc_otg_hcd);
+		}
+		if (gintsts.b.ptxfempty) {
+			retval |= dwc_otg_hcd_handle_perio_tx_fifo_empty_intr (_dwc_otg_hcd);
+		}
+#ifdef DEBUG
+#  ifndef DEBUG_SOF
+		if (gintsts.d32 != DWC_SOF_INTR_MASK)
+#  endif
+		{
+			DWC_DEBUGPL(DBG_HCD, "DWC OTG HCD Finished Servicing Interrupts\n");
+			DWC_DEBUGPL(DBG_HCDV, "DWC OTG HCD gintsts=0x%08x\n",
+			            dwc_read_reg32(&global_regs->gintsts));
+			DWC_DEBUGPL(DBG_HCDV, "DWC OTG HCD gintmsk=0x%08x\n",
+			            dwc_read_reg32(&global_regs->gintmsk));
+		}
+#endif
+
+#ifdef DEBUG
+#  ifndef DEBUG_SOF
+		if (gintsts.d32 != DWC_SOF_INTR_MASK)
+#  endif
+			DWC_DEBUGPL (DBG_HCD, "\n");
+#endif
+
+	}
+
+	return retval;
+}
+
+#ifdef DWC_TRACK_MISSED_SOFS
+#warning Compiling code to track missed SOFs
+#define FRAME_NUM_ARRAY_SIZE 1000
+/**
+ * This function is for debug only.
+ */
+static inline void track_missed_sofs(uint16_t _curr_frame_number) {
+	static uint16_t		frame_num_array[FRAME_NUM_ARRAY_SIZE];
+	static uint16_t		last_frame_num_array[FRAME_NUM_ARRAY_SIZE];
+	static int		frame_num_idx = 0;
+	static uint16_t		last_frame_num = DWC_HFNUM_MAX_FRNUM;
+	static int		dumped_frame_num_array = 0;
+
+	if (frame_num_idx < FRAME_NUM_ARRAY_SIZE) {
+		if ((((last_frame_num + 1) & DWC_HFNUM_MAX_FRNUM) != _curr_frame_number)) {
+			frame_num_array[frame_num_idx] = _curr_frame_number;
+			last_frame_num_array[frame_num_idx++] = last_frame_num;
+		}
+	} else if (!dumped_frame_num_array) {
+		int i;
+		printk(KERN_EMERG USB_DWC "Frame     Last Frame\n");
+		printk(KERN_EMERG USB_DWC "-----     ----------\n");
+		for (i = 0; i < FRAME_NUM_ARRAY_SIZE; i++) {
+			printk(KERN_EMERG USB_DWC "0x%04x    0x%04x\n",
+			       frame_num_array[i], last_frame_num_array[i]);
+		}
+		dumped_frame_num_array = 1;
+	}
+	last_frame_num = _curr_frame_number;
+}
+#endif
+
+/**
+ * Handles the start-of-frame interrupt in host mode. Non-periodic
+ * transactions may be queued to the DWC_otg controller for the current
+ * (micro)frame. Periodic transactions may be queued to the controller for the
+ * next (micro)frame.
+ */
+int32_t dwc_otg_hcd_handle_sof_intr (dwc_otg_hcd_t *_hcd)
+{
+	hfnum_data_t		hfnum;
+	struct list_head 	*qh_entry;
+	dwc_otg_qh_t 		*qh;
+	dwc_otg_transaction_type_e tr_type;
+	gintsts_data_t gintsts = {.d32 = 0};
+
+	hfnum.d32 = dwc_read_reg32(&_hcd->core_if->host_if->host_global_regs->hfnum);
+
+#ifdef DEBUG_SOF
+	DWC_DEBUGPL(DBG_HCD, "--Start of Frame Interrupt--\n");
+#endif
+
+	_hcd->frame_number = hfnum.b.frnum;
+
+#ifdef DEBUG
+	_hcd->frrem_accum += hfnum.b.frrem;
+	_hcd->frrem_samples++;
+#endif
+
+#ifdef DWC_TRACK_MISSED_SOFS
+	track_missed_sofs(_hcd->frame_number);
+#endif
+
+	/* Determine whether any periodic QHs should be executed. */
+	qh_entry = _hcd->periodic_sched_inactive.next;
+	while (qh_entry != &_hcd->periodic_sched_inactive) {
+		qh = list_entry(qh_entry, dwc_otg_qh_t, qh_list_entry);
+		qh_entry = qh_entry->next;
+		if (dwc_frame_num_le(qh->sched_frame, _hcd->frame_number)) {
+			/*
+			 * Move QH to the ready list to be executed next
+			 * (micro)frame.
+			 */
+			list_move(&qh->qh_list_entry, &_hcd->periodic_sched_ready);
+		}
+	}
+
+	tr_type = dwc_otg_hcd_select_transactions(_hcd);
+	if (tr_type != DWC_OTG_TRANSACTION_NONE) {
+		dwc_otg_hcd_queue_transactions(_hcd, tr_type);
+	}
+
+	/* Clear interrupt */
+	gintsts.b.sofintr = 1;
+	dwc_write_reg32(&_hcd->core_if->core_global_regs->gintsts, gintsts.d32);
+
+	return 1;
+}
+
+/** Handles the Rx Status Queue Level Interrupt, which indicates that there is at
+ * least one packet in the Rx FIFO.  The packets are moved from the FIFO to
+ * memory if the DWC_otg controller is operating in Slave mode. */
+int32_t dwc_otg_hcd_handle_rx_status_q_level_intr (dwc_otg_hcd_t *_dwc_otg_hcd)
+{
+	host_grxsts_data_t grxsts;
+	dwc_hc_t *hc = NULL;
+
+	DWC_DEBUGPL(DBG_HCD, "--RxStsQ Level Interrupt--\n");
+
+	grxsts.d32 = dwc_read_reg32(&_dwc_otg_hcd->core_if->core_global_regs->grxstsp);
+
+	hc = _dwc_otg_hcd->hc_ptr_array[grxsts.b.chnum];
+
+	/* Packet Status */
+	DWC_DEBUGPL(DBG_HCDV, "    Ch num = %d\n", grxsts.b.chnum);
+	DWC_DEBUGPL(DBG_HCDV, "    Count = %d\n", grxsts.b.bcnt);
+	DWC_DEBUGPL(DBG_HCDV, "    DPID = %d, hc.dpid = %d\n", grxsts.b.dpid, hc->data_pid_start);
+	DWC_DEBUGPL(DBG_HCDV, "    PStatus = %d\n", grxsts.b.pktsts);
+
+	switch (grxsts.b.pktsts) {
+	case DWC_GRXSTS_PKTSTS_IN:
+		/* Read the data into the host buffer. */
+		if (grxsts.b.bcnt > 0) {
+			dwc_otg_read_packet(_dwc_otg_hcd->core_if,
+			                    hc->xfer_buff,
+			                    grxsts.b.bcnt);
+
+			/* Update the HC fields for the next packet received. */
+			hc->xfer_count += grxsts.b.bcnt;
+			hc->xfer_buff += grxsts.b.bcnt;
+		}
+
+	case DWC_GRXSTS_PKTSTS_IN_XFER_COMP:
+	case DWC_GRXSTS_PKTSTS_DATA_TOGGLE_ERR:
+	case DWC_GRXSTS_PKTSTS_CH_HALTED:
+		/* Handled in interrupt, just ignore data */
+		break;
+	default:
+		DWC_ERROR ("RX_STS_Q Interrupt: Unknown status %d\n", grxsts.b.pktsts);
+		break;
+	}
+
+	return 1;
+}
+
+/** This interrupt occurs when the non-periodic Tx FIFO is half-empty. More
+ * data packets may be written to the FIFO for OUT transfers. More requests
+ * may be written to the non-periodic request queue for IN transfers. This
+ * interrupt is enabled only in Slave mode. */
+int32_t dwc_otg_hcd_handle_np_tx_fifo_empty_intr (dwc_otg_hcd_t *_dwc_otg_hcd)
+{
+	DWC_DEBUGPL(DBG_HCD, "--Non-Periodic TxFIFO Empty Interrupt--\n");
+	dwc_otg_hcd_queue_transactions(_dwc_otg_hcd,
+	                               DWC_OTG_TRANSACTION_NON_PERIODIC);
+	return 1;
+}
+
+/** This interrupt occurs when the periodic Tx FIFO is half-empty. More data
+ * packets may be written to the FIFO for OUT transfers. More requests may be
+ * written to the periodic request queue for IN transfers. This interrupt is
+ * enabled only in Slave mode. */
+int32_t dwc_otg_hcd_handle_perio_tx_fifo_empty_intr (dwc_otg_hcd_t *_dwc_otg_hcd)
+{
+	DWC_DEBUGPL(DBG_HCD, "--Periodic TxFIFO Empty Interrupt--\n");
+	dwc_otg_hcd_queue_transactions(_dwc_otg_hcd,
+	                               DWC_OTG_TRANSACTION_PERIODIC);
+	return 1;
+}
+
+/** There are multiple conditions that can cause a port interrupt. This function
+ * determines which interrupt conditions have occurred and handles them
+ * appropriately. */
+int32_t dwc_otg_hcd_handle_port_intr (dwc_otg_hcd_t *_dwc_otg_hcd)
+{
+	int retval = 0;
+	hprt0_data_t hprt0;
+	hprt0_data_t hprt0_modify;
+
+	hprt0.d32 = dwc_read_reg32(_dwc_otg_hcd->core_if->host_if->hprt0);
+	hprt0_modify.d32 = dwc_read_reg32(_dwc_otg_hcd->core_if->host_if->hprt0);
+
+	/* Clear appropriate bits in HPRT0 to clear the interrupt bit in
+	 * GINTSTS */
+
+	hprt0_modify.b.prtena = 0;
+	hprt0_modify.b.prtconndet = 0;
+	hprt0_modify.b.prtenchng = 0;
+	hprt0_modify.b.prtovrcurrchng = 0;
+
+	/* Port Connect Detected
+	 * Set flag and clear if detected */
+	if (hprt0.b.prtconndet) {
+		DWC_DEBUGPL(DBG_HCD, "--Port Interrupt HPRT0=0x%08x "
+		            "Port Connect Detected--\n", hprt0.d32);
+		_dwc_otg_hcd->flags.b.port_connect_status_change = 1;
+		_dwc_otg_hcd->flags.b.port_connect_status = 1;
+		hprt0_modify.b.prtconndet = 1;
+
+		/* B-Device has connected, Delete the connection timer.  */
+		del_timer( &_dwc_otg_hcd->conn_timer );
+
+		/* The Hub driver asserts a reset when it sees port connect
+		 * status change flag */
+		retval |= 1;
+	}
+
+	/* Port Enable Changed
+	 * Clear if detected - Set internal flag if disabled */
+	if (hprt0.b.prtenchng) {
+		DWC_DEBUGPL(DBG_HCD, "  --Port Interrupt HPRT0=0x%08x "
+		            "Port Enable Changed--\n", hprt0.d32);
+		hprt0_modify.b.prtenchng = 1;
+		if (hprt0.b.prtena == 1) {
+			int do_reset = 0;
+			dwc_otg_core_params_t *params = _dwc_otg_hcd->core_if->core_params;
+			dwc_otg_core_global_regs_t *global_regs = _dwc_otg_hcd->core_if->core_global_regs;
+			dwc_otg_host_if_t *host_if = _dwc_otg_hcd->core_if->host_if;
+
+			/* Check if we need to adjust the PHY clock speed for
+			 * low power and adjust it */
+			if (params->host_support_fs_ls_low_power)
+			{
+				gusbcfg_data_t usbcfg;
+
+				usbcfg.d32 = dwc_read_reg32 (&global_regs->gusbcfg);
+
+				if ((hprt0.b.prtspd == DWC_HPRT0_PRTSPD_LOW_SPEED) ||
+				        (hprt0.b.prtspd == DWC_HPRT0_PRTSPD_FULL_SPEED))
+				{
+					/*
+					 * Low power
+					 */
+					hcfg_data_t hcfg;
+					if (usbcfg.b.phylpwrclksel == 0) {
+						/* Set PHY low power clock select for FS/LS devices */
+						usbcfg.b.phylpwrclksel = 1;
+						dwc_write_reg32(&global_regs->gusbcfg, usbcfg.d32);
+						do_reset = 1;
+					}
+
+					hcfg.d32 = dwc_read_reg32(&host_if->host_global_regs->hcfg);
+
+					if ((hprt0.b.prtspd == DWC_HPRT0_PRTSPD_LOW_SPEED) &&
+					        (params->host_ls_low_power_phy_clk ==
+					         DWC_HOST_LS_LOW_POWER_PHY_CLK_PARAM_6MHZ))
+					{
+						/* 6 MHZ */
+						DWC_DEBUGPL(DBG_CIL, "FS_PHY programming HCFG to 6 MHz (Low Power)\n");
+						if (hcfg.b.fslspclksel != DWC_HCFG_6_MHZ) {
+							hcfg.b.fslspclksel = DWC_HCFG_6_MHZ;
+							dwc_write_reg32(&host_if->host_global_regs->hcfg,
+							                hcfg.d32);
+							do_reset = 1;
+						}
+					}
+					else {
+						/* 48 MHZ */
+						DWC_DEBUGPL(DBG_CIL, "FS_PHY programming HCFG to 48 MHz ()\n");
+						if (hcfg.b.fslspclksel != DWC_HCFG_48_MHZ) {
+							hcfg.b.fslspclksel = DWC_HCFG_48_MHZ;
+							dwc_write_reg32(&host_if->host_global_regs->hcfg,
+							                hcfg.d32);
+							do_reset = 1;
+						}
+					}
+				}
+				else {
+					/*
+					 * Not low power
+					 */
+					if (usbcfg.b.phylpwrclksel == 1) {
+						usbcfg.b.phylpwrclksel = 0;
+						dwc_write_reg32(&global_regs->gusbcfg, usbcfg.d32);
+						do_reset = 1;
+					}
+				}
+
+				if (do_reset) {
+					tasklet_schedule(_dwc_otg_hcd->reset_tasklet);
+				}
+			}
+
+			if (!do_reset) {
+				/* Port has been enabled set the reset change flag */
+				_dwc_otg_hcd->flags.b.port_reset_change = 1;
+			}
+
+		} else {
+			_dwc_otg_hcd->flags.b.port_enable_change = 1;
+		}
+		retval |= 1;
+	}
+
+	/** Overcurrent Change Interrupt */
+	if (hprt0.b.prtovrcurrchng) {
+		DWC_DEBUGPL(DBG_HCD, "  --Port Interrupt HPRT0=0x%08x "
+		            "Port Overcurrent Changed--\n", hprt0.d32);
+		_dwc_otg_hcd->flags.b.port_over_current_change = 1;
+		hprt0_modify.b.prtovrcurrchng = 1;
+		retval |= 1;
+	}
+
+	/* Clear Port Interrupts */
+	dwc_write_reg32(_dwc_otg_hcd->core_if->host_if->hprt0, hprt0_modify.d32);
+
+	return retval;
+}
+
+
+/** This interrupt indicates that one or more host channels has a pending
+ * interrupt. There are multiple conditions that can cause each host channel
+ * interrupt. This function determines which conditions have occurred for each
+ * host channel interrupt and handles them appropriately. */
+int32_t dwc_otg_hcd_handle_hc_intr (dwc_otg_hcd_t *_dwc_otg_hcd)
+{
+	int i;
+	int retval = 0;
+	haint_data_t haint;
+
+	/* Clear appropriate bits in HCINTn to clear the interrupt bit in
+	 * GINTSTS */
+
+	haint.d32 = dwc_otg_read_host_all_channels_intr(_dwc_otg_hcd->core_if);
+
+	for (i=0; i<_dwc_otg_hcd->core_if->core_params->host_channels; i++) {
+		if (haint.b2.chint & (1 << i)) {
+			retval |= dwc_otg_hcd_handle_hc_n_intr (_dwc_otg_hcd, i);
+		}
+	}
+
+	return retval;
+}
+
+/* Macro used to clear one channel interrupt */
+#define clear_hc_int(_hc_regs_,_intr_) \
+do { \
+	hcint_data_t hcint_clear = {.d32 = 0}; \
+	hcint_clear.b._intr_ = 1; \
+	dwc_write_reg32(&((_hc_regs_)->hcint), hcint_clear.d32); \
+} while (0)
+
+/*
+ * Macro used to disable one channel interrupt. Channel interrupts are
+ * disabled when the channel is halted or released by the interrupt handler.
+ * There is no need to handle further interrupts of that type until the
+ * channel is re-assigned. In fact, subsequent handling may cause crashes
+ * because the channel structures are cleaned up when the channel is released.
+ */
+#define disable_hc_int(_hc_regs_,_intr_) \
+do { \
+	hcintmsk_data_t hcintmsk = {.d32 = 0}; \
+	hcintmsk.b._intr_ = 1; \
+	dwc_modify_reg32(&((_hc_regs_)->hcintmsk), hcintmsk.d32, 0); \
+} while (0)
+
+/**
+ * Gets the actual length of a transfer after the transfer halts. _halt_status
+ * holds the reason for the halt.
+ *
+ * For IN transfers where _halt_status is DWC_OTG_HC_XFER_COMPLETE,
+ * *_short_read is set to 1 upon return if less than the requested
+ * number of bytes were transferred. Otherwise, *_short_read is set to 0 upon
+ * return. _short_read may also be NULL on entry, in which case it remains
+ * unchanged.
+ */
+static uint32_t get_actual_xfer_length(dwc_hc_t *_hc,
+                                       dwc_otg_hc_regs_t *_hc_regs,
+                                       dwc_otg_qtd_t *_qtd,
+                                       dwc_otg_halt_status_e _halt_status,
+                                       int *_short_read)
+{
+	hctsiz_data_t 	hctsiz;
+	uint32_t 	length;
+
+	if (_short_read != NULL) {
+		*_short_read = 0;
+	}
+	hctsiz.d32 = dwc_read_reg32(&_hc_regs->hctsiz);
+
+	if (_halt_status == DWC_OTG_HC_XFER_COMPLETE) {
+		if (_hc->ep_is_in) {
+			length = _hc->xfer_len - hctsiz.b.xfersize;
+			if (_short_read != NULL) {
+				*_short_read = (hctsiz.b.xfersize != 0);
+			}
+		} else if (_hc->qh->do_split) {
+			length = _qtd->ssplit_out_xfer_count;
+		} else {
+			length = _hc->xfer_len;
+		}
+	} else {
+		/*
+		 * Must use the hctsiz.pktcnt field to determine how much data
+		 * has been transferred. This field reflects the number of
+		 * packets that have been transferred via the USB. This is
+		 * always an integral number of packets if the transfer was
+		 * halted before its normal completion. (Can't use the
+		 * hctsiz.xfersize field because that reflects the number of
+		 * bytes transferred via the AHB, not the USB).
+		 */
+		length = (_hc->start_pkt_count - hctsiz.b.pktcnt) * _hc->max_packet;
+	}
+
+	return length;
+}
+
+/**
+ * Updates the state of the URB after a Transfer Complete interrupt on the
+ * host channel. Updates the actual_length field of the URB based on the
+ * number of bytes transferred via the host channel. Sets the URB status
+ * if the data transfer is finished.
+ *
+ * @return 1 if the data transfer specified by the URB is completely finished,
+ * 0 otherwise.
+ */
+static int update_urb_state_xfer_comp(dwc_hc_t *_hc,
+                                      dwc_otg_hc_regs_t *_hc_regs,
+                                      struct urb *_urb,
+                                      dwc_otg_qtd_t *_qtd)
+{
+	int 		xfer_done = 0;
+	int 		short_read = 0;
+
+	_urb->actual_length += get_actual_xfer_length(_hc, _hc_regs, _qtd,
+	                       DWC_OTG_HC_XFER_COMPLETE,
+	                       &short_read);
+
+	if (short_read || (_urb->actual_length == _urb->transfer_buffer_length)) {
+		xfer_done = 1;
+		if (short_read && (_urb->transfer_flags & URB_SHORT_NOT_OK)) {
+			_urb->status = -EREMOTEIO;
+		}
+		else {
+			_urb->status = 0;
+		}
+	}
+
+#ifdef DEBUG
+	{
+		hctsiz_data_t 	hctsiz;
+		hctsiz.d32 = dwc_read_reg32(&_hc_regs->hctsiz);
+		DWC_DEBUGPL(DBG_HCDV, "DWC_otg: %s: %s, channel %d\n",
+		            __func__, (_hc->ep_is_in ? "IN" : "OUT"), _hc->hc_num);
+		DWC_DEBUGPL(DBG_HCDV, "  hc->xfer_len %d\n", _hc->xfer_len);
+		DWC_DEBUGPL(DBG_HCDV, "  hctsiz.xfersize %d\n", hctsiz.b.xfersize);
+		DWC_DEBUGPL(DBG_HCDV, "  urb->transfer_buffer_length %d\n",
+		            _urb->transfer_buffer_length);
+		DWC_DEBUGPL(DBG_HCDV, "  urb->actual_length %d\n", _urb->actual_length);
+		DWC_DEBUGPL(DBG_HCDV, "  short_read %d, xfer_done %d\n",
+		            short_read, xfer_done);
+	}
+#endif
+
+	return xfer_done;
+}
+
+/*
+ * Save the starting data toggle for the next transfer. The data toggle is
+ * saved in the QH for non-control transfers and it's saved in the QTD for
+ * control transfers.
+ */
+static void save_data_toggle(dwc_hc_t *_hc,
+                             dwc_otg_hc_regs_t *_hc_regs,
+                             dwc_otg_qtd_t *_qtd)
+{
+	hctsiz_data_t hctsiz;
+	hctsiz.d32 = dwc_read_reg32(&_hc_regs->hctsiz);
+
+	if (_hc->ep_type != DWC_OTG_EP_TYPE_CONTROL) {
+		dwc_otg_qh_t *qh = _hc->qh;
+		if (hctsiz.b.pid == DWC_HCTSIZ_DATA0) {
+			qh->data_toggle = DWC_OTG_HC_PID_DATA0;
+		} else {
+			qh->data_toggle = DWC_OTG_HC_PID_DATA1;
+		}
+	} else {
+		if (hctsiz.b.pid == DWC_HCTSIZ_DATA0) {
+			_qtd->data_toggle = DWC_OTG_HC_PID_DATA0;
+		} else {
+			_qtd->data_toggle = DWC_OTG_HC_PID_DATA1;
+		}
+	}
+}
+
+/**
+ * Frees the first QTD in the QH's list if free_qtd is 1. For non-periodic
+ * QHs, removes the QH from the active non-periodic schedule. If any QTDs are
+ * still linked to the QH, the QH is added to the end of the inactive
+ * non-periodic schedule. For periodic QHs, removes the QH from the periodic
+ * schedule if no more QTDs are linked to the QH.
+ */
+static void deactivate_qh(dwc_otg_hcd_t *_hcd,
+                          dwc_otg_qh_t *_qh,
+                          int free_qtd)
+{
+	int continue_split = 0;
+	dwc_otg_qtd_t *qtd;
+
+	DWC_DEBUGPL(DBG_HCDV, "  %s(%p,%p,%d)\n", __func__, _hcd, _qh, free_qtd);
+
+	qtd = list_entry(_qh->qtd_list.next, dwc_otg_qtd_t, qtd_list_entry);
+
+	if (qtd->complete_split) {
+		continue_split = 1;
+	}
+	else if ((qtd->isoc_split_pos == DWC_HCSPLIT_XACTPOS_MID) ||
+	         (qtd->isoc_split_pos == DWC_HCSPLIT_XACTPOS_END))
+	{
+		continue_split = 1;
+	}
+
+	if (free_qtd) {
+		dwc_otg_hcd_qtd_remove_and_free(qtd);
+		continue_split = 0;
+	}
+
+	_qh->channel = NULL;
+	_qh->qtd_in_process = NULL;
+	dwc_otg_hcd_qh_deactivate(_hcd, _qh, continue_split);
+}
+
+/**
+ * Updates the state of an Isochronous URB when the transfer is stopped for
+ * any reason. The fields of the current entry in the frame descriptor array
+ * are set based on the transfer state and the input _halt_status. Completes
+ * the Isochronous URB if all the URB frames have been completed.
+ *
+ * @return DWC_OTG_HC_XFER_COMPLETE if there are more frames remaining to be
+ * transferred in the URB. Otherwise return DWC_OTG_HC_XFER_URB_COMPLETE.
+ */
+static dwc_otg_halt_status_e
+update_isoc_urb_state(dwc_otg_hcd_t *_hcd,
+                      dwc_hc_t *_hc,
+                      dwc_otg_hc_regs_t *_hc_regs,
+                      dwc_otg_qtd_t *_qtd,
+                      dwc_otg_halt_status_e _halt_status)
+{
+	struct urb *urb = _qtd->urb;
+	dwc_otg_halt_status_e ret_val = _halt_status;
+	struct usb_iso_packet_descriptor *frame_desc;
+
+	frame_desc = &urb->iso_frame_desc[_qtd->isoc_frame_index];
+	switch (_halt_status) {
+	case DWC_OTG_HC_XFER_COMPLETE:
+		frame_desc->status = 0;
+		frame_desc->actual_length =
+		    get_actual_xfer_length(_hc, _hc_regs, _qtd,
+		                           _halt_status, NULL);
+		break;
+	case DWC_OTG_HC_XFER_FRAME_OVERRUN:
+		urb->error_count++;
+		if (_hc->ep_is_in) {
+			frame_desc->status = -ENOSR;
+		} else {
+			frame_desc->status = -ECOMM;
+		}
+		frame_desc->actual_length = 0;
+		break;
+	case DWC_OTG_HC_XFER_BABBLE_ERR:
+		urb->error_count++;
+		frame_desc->status = -EOVERFLOW;
+		/* Don't need to update actual_length in this case. */
+		break;
+	case DWC_OTG_HC_XFER_XACT_ERR:
+		urb->error_count++;
+		frame_desc->status = -EPROTO;
+		frame_desc->actual_length =
+		    get_actual_xfer_length(_hc, _hc_regs, _qtd,
+		                           _halt_status, NULL);
+	default:
+		DWC_ERROR("%s: Unhandled _halt_status (%d)\n", __func__,
+		          _halt_status);
+		BUG();
+		break;
+	}
+
+	if (++_qtd->isoc_frame_index == urb->number_of_packets) {
+		/*
+		 * urb->status is not used for isoc transfers.
+		 * The individual frame_desc statuses are used instead.
+		 */
+		dwc_otg_hcd_complete_urb(_hcd, urb, 0);
+		ret_val = DWC_OTG_HC_XFER_URB_COMPLETE;
+	} else {
+		ret_val = DWC_OTG_HC_XFER_COMPLETE;
+	}
+
+	return ret_val;
+}
+
+/**
+ * Releases a host channel for use by other transfers. Attempts to select and
+ * queue more transactions since at least one host channel is available.
+ *
+ * @param _hcd The HCD state structure.
+ * @param _hc The host channel to release.
+ * @param _qtd The QTD associated with the host channel. This QTD may be freed
+ * if the transfer is complete or an error has occurred.
+ * @param _halt_status Reason the channel is being released. This status
+ * determines the actions taken by this function.
+ */
+static void release_channel(dwc_otg_hcd_t *_hcd,
+                            dwc_hc_t *_hc,
+                            dwc_otg_qtd_t *_qtd,
+                            dwc_otg_halt_status_e _halt_status)
+{
+	dwc_otg_transaction_type_e tr_type;
+	int free_qtd;
+
+	DWC_DEBUGPL(DBG_HCDV, "  %s: channel %d, halt_status %d\n",
+	            __func__, _hc->hc_num, _halt_status);
+
+	switch (_halt_status) {
+	case DWC_OTG_HC_XFER_URB_COMPLETE:
+		free_qtd = 1;
+		break;
+	case DWC_OTG_HC_XFER_AHB_ERR:
+	case DWC_OTG_HC_XFER_STALL:
+	case DWC_OTG_HC_XFER_BABBLE_ERR:
+		free_qtd = 1;
+		break;
+	case DWC_OTG_HC_XFER_XACT_ERR:
+		if (_qtd->error_count >= 3) {
+			DWC_DEBUGPL(DBG_HCDV, "  Complete URB with transaction error\n");
+			free_qtd = 1;
+			_qtd->urb->status = -EPROTO;
+			dwc_otg_hcd_complete_urb(_hcd, _qtd->urb, -EPROTO);
+		} else {
+			free_qtd = 0;
+		}
+		break;
+	case DWC_OTG_HC_XFER_URB_DEQUEUE:
+		/*
+		 * The QTD has already been removed and the QH has been
+		 * deactivated. Don't want to do anything except release the
+		 * host channel and try to queue more transfers.
+		 */
+		goto cleanup;
+	case DWC_OTG_HC_XFER_NO_HALT_STATUS:
+		DWC_ERROR("%s: No halt_status, channel %d\n", __func__, _hc->hc_num);
+		free_qtd = 0;
+		break;
+	default:
+		free_qtd = 0;
+		break;
+	}
+
+
+	deactivate_qh(_hcd, _hc->qh, free_qtd);
+
+cleanup:
+	/*
+	 * Release the host channel for use by other transfers. The cleanup
+	 * function clears the channel interrupt enables and conditions, so
+	 * there's no need to clear the Channel Halted interrupt separately.
+	 */
+	dwc_otg_hc_cleanup(_hcd->core_if, _hc);
+	list_add_tail(&_hc->hc_list_entry, &_hcd->free_hc_list);
+
+	switch (_hc->ep_type) {
+	case DWC_OTG_EP_TYPE_CONTROL:
+	case DWC_OTG_EP_TYPE_BULK:
+		_hcd->non_periodic_channels--;
+		break;
+
+	default:
+		/*
+		 * Don't release reservations for periodic channels here.
+		 * That's done when a periodic transfer is descheduled (i.e.
+		 * when the QH is removed from the periodic schedule).
+		 */
+		break;
+	}
+
+	/* Try to queue more transfers now that there's a free channel. */
+	tr_type = dwc_otg_hcd_select_transactions(_hcd);
+	if (tr_type != DWC_OTG_TRANSACTION_NONE) {
+		dwc_otg_hcd_queue_transactions(_hcd, tr_type);
+	}
+}
+
+/**
+ * Halts a host channel. If the channel cannot be halted immediately because
+ * the request queue is full, this function ensures that the FIFO empty
+ * interrupt for the appropriate queue is enabled so that the halt request can
+ * be queued when there is space in the request queue.
+ *
+ * This function may also be called in DMA mode. In that case, the channel is
+ * simply released since the core always halts the channel automatically in
+ * DMA mode.
+ */
+static void halt_channel(dwc_otg_hcd_t *_hcd,
+                         dwc_hc_t *_hc,
+                         dwc_otg_qtd_t *_qtd,
+                         dwc_otg_halt_status_e _halt_status)
+{
+	if (_hcd->core_if->dma_enable) {
+		release_channel(_hcd, _hc, _qtd, _halt_status);
+		return;
+	}
+
+	/* Slave mode processing... */
+	dwc_otg_hc_halt(_hcd->core_if, _hc, _halt_status);
+
+	if (_hc->halt_on_queue) {
+		gintmsk_data_t gintmsk = {.d32 = 0};
+		dwc_otg_core_global_regs_t *global_regs;
+		global_regs = _hcd->core_if->core_global_regs;
+
+		if (_hc->ep_type == DWC_OTG_EP_TYPE_CONTROL ||
+		        _hc->ep_type == DWC_OTG_EP_TYPE_BULK) {
+			/*
+			 * Make sure the Non-periodic Tx FIFO empty interrupt
+			 * is enabled so that the non-periodic schedule will
+			 * be processed.
+			 */
+			gintmsk.b.nptxfempty = 1;
+			dwc_modify_reg32(&global_regs->gintmsk, 0, gintmsk.d32);
+		} else {
+			/*
+			 * Move the QH from the periodic queued schedule to
+			 * the periodic assigned schedule. This allows the
+			 * halt to be queued when the periodic schedule is
+			 * processed.
+			 */
+			list_move(&_hc->qh->qh_list_entry,
+			          &_hcd->periodic_sched_assigned);
+
+			/*
+			 * Make sure the Periodic Tx FIFO Empty interrupt is
+			 * enabled so that the periodic schedule will be
+			 * processed.
+			 */
+			gintmsk.b.ptxfempty = 1;
+			dwc_modify_reg32(&global_regs->gintmsk, 0, gintmsk.d32);
+		}
+	}
+}
+
+/**
+ * Performs common cleanup for non-periodic transfers after a Transfer
+ * Complete interrupt. This function should be called after any endpoint type
+ * specific handling is finished to release the host channel.
+ */
+static void complete_non_periodic_xfer(dwc_otg_hcd_t *_hcd,
+                                       dwc_hc_t *_hc,
+                                       dwc_otg_hc_regs_t *_hc_regs,
+                                       dwc_otg_qtd_t *_qtd,
+                                       dwc_otg_halt_status_e _halt_status)
+{
+	hcint_data_t hcint;
+
+	_qtd->error_count = 0;
+
+	hcint.d32 = dwc_read_reg32(&_hc_regs->hcint);
+	if (hcint.b.nyet) {
+		/*
+		 * Got a NYET on the last transaction of the transfer. This
+		 * means that the endpoint should be in the PING state at the
+		 * beginning of the next transfer.
+		 */
+		_hc->qh->ping_state = 1;
+		clear_hc_int(_hc_regs,nyet);
+	}
+
+	/*
+	 * Always halt and release the host channel to make it available for
+	 * more transfers. There may still be more phases for a control
+	 * transfer or more data packets for a bulk transfer at this point,
+	 * but the host channel is still halted. A channel will be reassigned
+	 * to the transfer when the non-periodic schedule is processed after
+	 * the channel is released. This allows transactions to be queued
+	 * properly via dwc_otg_hcd_queue_transactions, which also enables the
+	 * Tx FIFO Empty interrupt if necessary.
+	 */
+	if (_hc->ep_is_in) {
+		/*
+		 * IN transfers in Slave mode require an explicit disable to
+		 * halt the channel. (In DMA mode, this call simply releases
+		 * the channel.)
+		 */
+		halt_channel(_hcd, _hc, _qtd, _halt_status);
+	} else {
+		/*
+		 * The channel is automatically disabled by the core for OUT
+		 * transfers in Slave mode.
+		 */
+		release_channel(_hcd, _hc, _qtd, _halt_status);
+	}
+}
+
+/**
+ * Performs common cleanup for periodic transfers after a Transfer Complete
+ * interrupt. This function should be called after any endpoint type specific
+ * handling is finished to release the host channel.
+ */
+static void complete_periodic_xfer(dwc_otg_hcd_t *_hcd,
+                                   dwc_hc_t *_hc,
+                                   dwc_otg_hc_regs_t *_hc_regs,
+                                   dwc_otg_qtd_t *_qtd,
+                                   dwc_otg_halt_status_e _halt_status)
+{
+	hctsiz_data_t hctsiz;
+	_qtd->error_count = 0;
+
+	hctsiz.d32 = dwc_read_reg32(&_hc_regs->hctsiz);
+	if (!_hc->ep_is_in || hctsiz.b.pktcnt == 0) {
+		/* Core halts channel in these cases. */
+		release_channel(_hcd, _hc, _qtd, _halt_status);
+	} else {
+		/* Flush any outstanding requests from the Tx queue. */
+		halt_channel(_hcd, _hc, _qtd, _halt_status);
+	}
+}
+
+/**
+ * Handles a host channel Transfer Complete interrupt. This handler may be
+ * called in either DMA mode or Slave mode.
+ */
+static int32_t handle_hc_xfercomp_intr(dwc_otg_hcd_t *_hcd,
+                                       dwc_hc_t *_hc,
+                                       dwc_otg_hc_regs_t *_hc_regs,
+                                       dwc_otg_qtd_t *_qtd)
+{
+	int 			urb_xfer_done;
+	dwc_otg_halt_status_e 	halt_status = DWC_OTG_HC_XFER_COMPLETE;
+	struct urb 		*urb = _qtd->urb;
+	int 			pipe_type = usb_pipetype(urb->pipe);
+	hcint_data_t hcint;
+	hcintmsk_data_t hcintmsk;
+
+	DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "
+	            "Transfer Complete--\n", _hc->hc_num);
+
+	hcint.d32 = dwc_read_reg32(&_hc_regs->hcint);
+	hcintmsk.d32 = dwc_read_reg32(&_hc_regs->hcintmsk);
+	DWC_DEBUGPL(DBG_HCDV, "  hcint 0x%08x, hcintmsk 0x%08x, hcint&hcintmsk 0x%08x\n",hcint.d32, hcintmsk.d32, (hcint.d32 & hcintmsk.d32));
+	/*
+	* Handle xfer complete on CSPLIT.
+	*/
+	if (_hc->qh->do_split) {
+		_qtd->complete_split = 0;
+	}
+
+	/* Update the QTD and URB states. */
+	switch (pipe_type) {
+	case PIPE_CONTROL:
+		switch (_qtd->control_phase) {
+		case DWC_OTG_CONTROL_SETUP:
+			if (urb->transfer_buffer_length > 0) {
+				_qtd->control_phase = DWC_OTG_CONTROL_DATA;
+			} else {
+				_qtd->control_phase = DWC_OTG_CONTROL_STATUS;
+			}
+			DWC_DEBUGPL(DBG_HCDV, "  Control setup transaction done\n");
+			halt_status = DWC_OTG_HC_XFER_COMPLETE;
+			break;
+		case DWC_OTG_CONTROL_DATA: {
+			urb_xfer_done = update_urb_state_xfer_comp(_hc, _hc_regs, urb, _qtd);
+			if (urb_xfer_done) {
+				_qtd->control_phase = DWC_OTG_CONTROL_STATUS;
+				DWC_DEBUGPL(DBG_HCDV, "  Control data transfer done\n");
+			} else {
+				save_data_toggle(_hc, _hc_regs, _qtd);
+			}
+
+			// Added by Sheeja S on 14th Sep 07 for debuging
+//			dump_msg(urb->transfer_buffer, urb->transfer_buffer_length);
+
+			halt_status = DWC_OTG_HC_XFER_COMPLETE;
+			break;
+		}
+		case DWC_OTG_CONTROL_STATUS:
+			DWC_DEBUGPL(DBG_HCDV, "  Control transfer complete\n");
+			if (urb->status == -EINPROGRESS) {
+				urb->status = 0;
+			}
+			dwc_otg_hcd_complete_urb(_hcd, urb, urb->status);
+			halt_status = DWC_OTG_HC_XFER_URB_COMPLETE;
+			break;
+		}
+
+		complete_non_periodic_xfer(_hcd, _hc, _hc_regs, _qtd, halt_status);
+		break;
+	case PIPE_BULK:
+		DWC_DEBUGPL(DBG_HCDV, "  Bulk transfer complete\n");
+		urb_xfer_done = update_urb_state_xfer_comp(_hc, _hc_regs, urb, _qtd);
+		if (urb_xfer_done) {
+			dwc_otg_hcd_complete_urb(_hcd, urb, urb->status);
+			halt_status = DWC_OTG_HC_XFER_URB_COMPLETE;
+		} else {
+			halt_status = DWC_OTG_HC_XFER_COMPLETE;
+		}
+
+		save_data_toggle(_hc, _hc_regs, _qtd);
+		complete_non_periodic_xfer(_hcd, _hc, _hc_regs, _qtd, halt_status);
+		break;
+	case PIPE_INTERRUPT:
+		DWC_DEBUGPL(DBG_HCDV, "  Interrupt transfer complete\n");
+		update_urb_state_xfer_comp(_hc, _hc_regs, urb, _qtd);
+
+		/*
+		 * Interrupt URB is done on the first transfer complete
+		 * interrupt.
+		 */
+		dwc_otg_hcd_complete_urb(_hcd, urb, urb->status);
+		save_data_toggle(_hc, _hc_regs, _qtd);
+		complete_periodic_xfer(_hcd, _hc, _hc_regs, _qtd,
+		                       DWC_OTG_HC_XFER_URB_COMPLETE);
+		break;
+	case PIPE_ISOCHRONOUS:
+		DWC_DEBUGPL(DBG_HCDV,  "  Isochronous transfer complete\n");
+		if (_qtd->isoc_split_pos == DWC_HCSPLIT_XACTPOS_ALL)
+		{
+			halt_status = update_isoc_urb_state(_hcd, _hc, _hc_regs, _qtd,
+			                                    DWC_OTG_HC_XFER_COMPLETE);
+		}
+		complete_periodic_xfer(_hcd, _hc, _hc_regs, _qtd, halt_status);
+		break;
+	}
+
+	disable_hc_int(_hc_regs,xfercompl);
+	hcint.d32 = dwc_read_reg32(&_hc_regs->hcint);
+	hcintmsk.d32 = dwc_read_reg32(&_hc_regs->hcintmsk);
+	DWC_DEBUGPL(DBG_HCDV, "  hcint 0x%08x, hcintmsk 0x%08x, hcint&hcintmsk 0x%08x\n",hcint.d32, hcintmsk.d32, (hcint.d32 & hcintmsk.d32));
+	return 1;
+}
+
+/**
+ * Handles a host channel STALL interrupt. This handler may be called in
+ * either DMA mode or Slave mode.
+ */
+static int32_t handle_hc_stall_intr(dwc_otg_hcd_t *_hcd,
+                                    dwc_hc_t *_hc,
+                                    dwc_otg_hc_regs_t *_hc_regs,
+                                    dwc_otg_qtd_t *_qtd)
+{
+	struct urb *urb = _qtd->urb;
+	int pipe_type = usb_pipetype(urb->pipe);
+
+	DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "
+	            "STALL Received--\n", _hc->hc_num);
+
+	if (pipe_type == PIPE_CONTROL) {
+		dwc_otg_hcd_complete_urb(_hcd, _qtd->urb, -EPIPE);
+	}
+
+	if (pipe_type == PIPE_BULK || pipe_type == PIPE_INTERRUPT) {
+		dwc_otg_hcd_complete_urb(_hcd, _qtd->urb, -EPIPE);
+		/*
+		 * USB protocol requires resetting the data toggle for bulk
+		 * and interrupt endpoints when a CLEAR_FEATURE(ENDPOINT_HALT)
+		 * setup command is issued to the endpoint. Anticipate the
+		 * CLEAR_FEATURE command since a STALL has occurred and reset
+		 * the data toggle now.
+		 */
+		_hc->qh->data_toggle = 0;
+	}
+
+	halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER_STALL);
+
+	disable_hc_int(_hc_regs,stall);
+
+	return 1;
+}
+
+/*
+ * Updates the state of the URB when a transfer has been stopped due to an
+ * abnormal condition before the transfer completes. Modifies the
+ * actual_length field of the URB to reflect the number of bytes that have
+ * actually been transferred via the host channel.
+ */
+static void update_urb_state_xfer_intr(dwc_hc_t *_hc,
+                                       dwc_otg_hc_regs_t *_hc_regs,
+                                       struct urb *_urb,
+                                       dwc_otg_qtd_t *_qtd,
+                                       dwc_otg_halt_status_e _halt_status)
+{
+	uint32_t bytes_transferred = get_actual_xfer_length(_hc, _hc_regs, _qtd,
+	                             _halt_status, NULL);
+	_urb->actual_length += bytes_transferred;
+
+#ifdef DEBUG
+	{
+		hctsiz_data_t 	hctsiz;
+		hctsiz.d32 = dwc_read_reg32(&_hc_regs->hctsiz);
+		DWC_DEBUGPL(DBG_HCDV, "DWC_otg: %s: %s, channel %d\n",
+		            __func__, (_hc->ep_is_in ? "IN" : "OUT"), _hc->hc_num);
+		DWC_DEBUGPL(DBG_HCDV, "  _hc->start_pkt_count %d\n", _hc->start_pkt_count);
+		DWC_DEBUGPL(DBG_HCDV, "  hctsiz.pktcnt %d\n", hctsiz.b.pktcnt);
+		DWC_DEBUGPL(DBG_HCDV, "  _hc->max_packet %d\n", _hc->max_packet);
+		DWC_DEBUGPL(DBG_HCDV, "  bytes_transferred %d\n", bytes_transferred);
+		DWC_DEBUGPL(DBG_HCDV, "  _urb->actual_length %d\n", _urb->actual_length);
+		DWC_DEBUGPL(DBG_HCDV, "  _urb->transfer_buffer_length %d\n",
+		            _urb->transfer_buffer_length);
+	}
+#endif
+}
+
+/**
+ * Handles a host channel NAK interrupt. This handler may be called in either
+ * DMA mode or Slave mode.
+ */
+static int32_t handle_hc_nak_intr(dwc_otg_hcd_t *_hcd,
+                                  dwc_hc_t *_hc,
+                                  dwc_otg_hc_regs_t *_hc_regs,
+                                  dwc_otg_qtd_t *_qtd)
+{
+	DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "
+	            "NAK Received--\n", _hc->hc_num);
+
+	/*
+	 * Handle NAK for IN/OUT SSPLIT/CSPLIT transfers, bulk, control, and
+	 * interrupt.  Re-start the SSPLIT transfer.
+	 */
+	if (_hc->do_split) {
+		if (_hc->complete_split) {
+			_qtd->error_count = 0;
+		}
+		_qtd->complete_split = 0;
+		halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER_NAK);
+		goto handle_nak_done;
+	}
+
+	switch (usb_pipetype(_qtd->urb->pipe)) {
+	case PIPE_CONTROL:
+	case PIPE_BULK:
+		if (_hcd->core_if->dma_enable && _hc->ep_is_in) {
+			/*
+			 * NAK interrupts are enabled on bulk/control IN
+			 * transfers in DMA mode for the sole purpose of
+			 * resetting the error count after a transaction error
+			 * occurs. The core will continue transferring data.
+			 */
+			_qtd->error_count = 0;
+			goto handle_nak_done;
+		}
+
+		/*
+		 * NAK interrupts normally occur during OUT transfers in DMA
+		 * or Slave mode. For IN transfers, more requests will be
+		 * queued as request queue space is available.
+		 */
+		_qtd->error_count = 0;
+
+		if (!_hc->qh->ping_state) {
+			update_urb_state_xfer_intr(_hc, _hc_regs, _qtd->urb,
+			                           _qtd, DWC_OTG_HC_XFER_NAK);
+			save_data_toggle(_hc, _hc_regs, _qtd);
+			if (_qtd->urb->dev->speed == USB_SPEED_HIGH) {
+				_hc->qh->ping_state = 1;
+			}
+		}
+
+		/*
+		 * Halt the channel so the transfer can be re-started from
+		 * the appropriate point or the PING protocol will
+		 * start/continue.
+		 */
+		halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER_NAK);
+		break;
+	case PIPE_INTERRUPT:
+		_qtd->error_count = 0;
+		halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER_NAK);
+		break;
+	case PIPE_ISOCHRONOUS:
+		/* Should never get called for isochronous transfers. */
+		BUG();
+		break;
+	}
+
+handle_nak_done:
+	disable_hc_int(_hc_regs,nak);
+
+	return 1;
+}
+
+/**
+ * Handles a host channel ACK interrupt. This interrupt is enabled when
+ * performing the PING protocol in Slave mode, when errors occur during
+ * either Slave mode or DMA mode, and during Start Split transactions.
+ */
+static int32_t handle_hc_ack_intr(dwc_otg_hcd_t *_hcd,
+                                  dwc_hc_t *_hc,
+                                  dwc_otg_hc_regs_t *_hc_regs,
+                                  dwc_otg_qtd_t *_qtd)
+{
+	DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "
+	            "ACK Received--\n", _hc->hc_num);
+
+	if (_hc->do_split) {
+		/*
+		 * Handle ACK on SSPLIT.
+		 * ACK should not occur in CSPLIT.
+		 */
+		if ((!_hc->ep_is_in) && (_hc->data_pid_start != DWC_OTG_HC_PID_SETUP)) {
+			_qtd->ssplit_out_xfer_count = _hc->xfer_len;
+		}
+		if (!(_hc->ep_type == DWC_OTG_EP_TYPE_ISOC && !_hc->ep_is_in)) {
+			/* Don't need complete for isochronous out transfers. */
+			_qtd->complete_split = 1;
+		}
+
+		/* ISOC OUT */
+		if ((_hc->ep_type == DWC_OTG_EP_TYPE_ISOC) && !_hc->ep_is_in) {
+			switch (_hc->xact_pos) {
+			case DWC_HCSPLIT_XACTPOS_ALL:
+				break;
+			case DWC_HCSPLIT_XACTPOS_END:
+				_qtd->isoc_split_pos = DWC_HCSPLIT_XACTPOS_ALL;
+				_qtd->isoc_split_offset = 0;
+				break;
+			case DWC_HCSPLIT_XACTPOS_BEGIN:
+			case DWC_HCSPLIT_XACTPOS_MID:
+				/*
+				 * For BEGIN or MID, calculate the length for
+				 * the next microframe to determine the correct
+				 * SSPLIT token, either MID or END.
+				 */
+				do {
+					struct usb_iso_packet_descriptor *frame_desc;
+
+					frame_desc = &_qtd->urb->iso_frame_desc[_qtd->isoc_frame_index];
+					_qtd->isoc_split_offset += 188;
+
+					if ((frame_desc->length - _qtd->isoc_split_offset) <= 188) {
+						_qtd->isoc_split_pos = DWC_HCSPLIT_XACTPOS_END;
+					}
+					else {
+						_qtd->isoc_split_pos = DWC_HCSPLIT_XACTPOS_MID;
+					}
+
+				} while (0);
+				break;
+			}
+		}
+		else {
+			halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER_ACK);
+		}
+	} else {
+		_qtd->error_count = 0;
+
+		if (_hc->qh->ping_state) {
+			_hc->qh->ping_state = 0;
+			/*
+			 * Halt the channel so the transfer can be re-started
+			 * from the appropriate point. This only happens in
+			 * Slave mode. In DMA mode, the ping_state is cleared
+			 * when the transfer is started because the core
+			 * automatically executes the PING, then the transfer.
+			 */
+			halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER_ACK);
+		}
+	}
+
+	/*
+	 * If the ACK occurred when _not_ in the PING state, let the channel
+	 * continue transferring data after clearing the error count.
+	 */
+
+	disable_hc_int(_hc_regs,ack);
+
+	return 1;
+}
+
+/**
+ * Handles a host channel NYET interrupt. This interrupt should only occur on
+ * Bulk and Control OUT endpoints and for complete split transactions. If a
+ * NYET occurs at the same time as a Transfer Complete interrupt, it is
+ * handled in the xfercomp interrupt handler, not here. This handler may be
+ * called in either DMA mode or Slave mode.
+ */
+static int32_t handle_hc_nyet_intr(dwc_otg_hcd_t *_hcd,
+                                   dwc_hc_t *_hc,
+                                   dwc_otg_hc_regs_t *_hc_regs,
+                                   dwc_otg_qtd_t *_qtd)
+{
+	DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "
+	            "NYET Received--\n", _hc->hc_num);
+
+	/*
+	 * NYET on CSPLIT
+	 * re-do the CSPLIT immediately on non-periodic
+	 */
+	if ((_hc->do_split) && (_hc->complete_split)) {
+		if ((_hc->ep_type == DWC_OTG_EP_TYPE_INTR) ||
+		        (_hc->ep_type == DWC_OTG_EP_TYPE_ISOC)) {
+			int frnum = dwc_otg_hcd_get_frame_number(dwc_otg_hcd_to_hcd(_hcd));
+
+			if (dwc_full_frame_num(frnum) !=
+			        dwc_full_frame_num(_hc->qh->sched_frame)) {
+				/*
+				 * No longer in the same full speed frame.
+				 * Treat this as a transaction error.
+				 */
+#if 0
+				/** @todo Fix system performance so this can
+				 * be treated as an error. Right now complete
+				 * splits cannot be scheduled precisely enough
+				 * due to other system activity, so this error
+				 * occurs regularly in Slave mode.
+				 */
+				_qtd->error_count++;
+#endif
+				_qtd->complete_split = 0;
+				halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER_XACT_ERR);
+				/** @todo add support for isoc release */
+				goto handle_nyet_done;
+			}
+		}
+
+		halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER_NYET);
+		goto handle_nyet_done;
+	}
+
+	_hc->qh->ping_state = 1;
+	_qtd->error_count = 0;
+
+	update_urb_state_xfer_intr(_hc, _hc_regs, _qtd->urb, _qtd,
+	                           DWC_OTG_HC_XFER_NYET);
+	save_data_toggle(_hc, _hc_regs, _qtd);
+
+	/*
+	 * Halt the channel and re-start the transfer so the PING
+	 * protocol will start.
+	 */
+	halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER_NYET);
+
+handle_nyet_done:
+	disable_hc_int(_hc_regs,nyet);
+	return 1;
+}
+
+/**
+ * Handles a host channel babble interrupt. This handler may be called in
+ * either DMA mode or Slave mode.
+ */
+static int32_t handle_hc_babble_intr(dwc_otg_hcd_t *_hcd,
+                                     dwc_hc_t *_hc,
+                                     dwc_otg_hc_regs_t *_hc_regs,
+                                     dwc_otg_qtd_t *_qtd)
+{
+	DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "
+	            "Babble Error--\n", _hc->hc_num);
+	if (_hc->ep_type != DWC_OTG_EP_TYPE_ISOC) {
+		dwc_otg_hcd_complete_urb(_hcd, _qtd->urb, -EOVERFLOW);
+		halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER_BABBLE_ERR);
+	} else {
+		dwc_otg_halt_status_e halt_status;
+		halt_status = update_isoc_urb_state(_hcd, _hc, _hc_regs, _qtd,
+		                                    DWC_OTG_HC_XFER_BABBLE_ERR);
+		halt_channel(_hcd, _hc, _qtd, halt_status);
+	}
+	disable_hc_int(_hc_regs,bblerr);
+	return 1;
+}
+
+/**
+ * Handles a host channel AHB error interrupt. This handler is only called in
+ * DMA mode.
+ */
+static int32_t handle_hc_ahberr_intr(dwc_otg_hcd_t *_hcd,
+                                     dwc_hc_t *_hc,
+                                     dwc_otg_hc_regs_t *_hc_regs,
+                                     dwc_otg_qtd_t *_qtd)
+{
+	hcchar_data_t 	hcchar;
+	hcsplt_data_t	hcsplt;
+	hctsiz_data_t 	hctsiz;
+	uint32_t	hcdma;
+	struct urb	*urb = _qtd->urb;
+
+	DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "
+	            "AHB Error--\n", _hc->hc_num);
+
+	hcchar.d32 = dwc_read_reg32(&_hc_regs->hcchar);
+	hcsplt.d32 = dwc_read_reg32(&_hc_regs->hcsplt);
+	hctsiz.d32 = dwc_read_reg32(&_hc_regs->hctsiz);
+	hcdma = dwc_read_reg32(&_hc_regs->hcdma);
+
+	DWC_ERROR("AHB ERROR, Channel %d\n", _hc->hc_num);
+	DWC_ERROR("  hcchar 0x%08x, hcsplt 0x%08x\n", hcchar.d32, hcsplt.d32);
+	DWC_ERROR("  hctsiz 0x%08x, hcdma 0x%08x\n", hctsiz.d32, hcdma);
+	DWC_DEBUGPL(DBG_HCD, "DWC OTG HCD URB Enqueue\n");
+	DWC_ERROR("  Device address: %d\n", usb_pipedevice(urb->pipe));
+	DWC_ERROR("  Endpoint: %d, %s\n", usb_pipeendpoint(urb->pipe),
+	          (usb_pipein(urb->pipe) ? "IN" : "OUT"));
+	DWC_ERROR("  Endpoint type: %s\n",
+		    ({char *pipetype;
+		    switch (usb_pipetype(urb->pipe)) {
+		    case PIPE_CONTROL: pipetype = "CONTROL"; break;
+		    case PIPE_BULK: pipetype = "BULK"; break;
+		    case PIPE_INTERRUPT: pipetype = "INTERRUPT"; break;
+		    case PIPE_ISOCHRONOUS: pipetype = "ISOCHRONOUS"; break;
+		    default: pipetype = "UNKNOWN"; break;
+		    }; pipetype;}));
+	DWC_ERROR("  Speed: %s\n",
+		    ({char *speed;
+		    switch (urb->dev->speed) {
+		    case USB_SPEED_HIGH: speed = "HIGH"; break;
+		    case USB_SPEED_FULL: speed = "FULL"; break;
+		    case USB_SPEED_LOW: speed = "LOW"; break;
+		    default: speed = "UNKNOWN"; break;
+		    }; speed;}));
+	DWC_ERROR("  Max packet size: %d\n",
+	          usb_maxpacket(urb->dev, urb->pipe, usb_pipeout(urb->pipe)));
+	DWC_ERROR("  Data buffer length: %d\n", urb->transfer_buffer_length);
+	DWC_ERROR("  Transfer buffer: %p, Transfer DMA: %p\n",
+	          urb->transfer_buffer, (void *)urb->transfer_dma);
+	DWC_ERROR("  Setup buffer: %p, Setup DMA: %p\n",
+	          urb->setup_packet, (void *)urb->setup_dma);
+	DWC_ERROR("  Interval: %d\n", urb->interval);
+
+	dwc_otg_hcd_complete_urb(_hcd, urb, -EIO);
+
+	/*
+	 * Force a channel halt. Don't call halt_channel because that won't
+	 * write to the HCCHARn register in DMA mode to force the halt.
+	 */
+	dwc_otg_hc_halt(_hcd->core_if, _hc, DWC_OTG_HC_XFER_AHB_ERR);
+
+	disable_hc_int(_hc_regs,ahberr);
+	return 1;
+}
+
+/**
+ * Handles a host channel transaction error interrupt. This handler may be
+ * called in either DMA mode or Slave mode.
+ */
+static int32_t handle_hc_xacterr_intr(dwc_otg_hcd_t *_hcd,
+                                      dwc_hc_t *_hc,
+                                      dwc_otg_hc_regs_t *_hc_regs,
+                                      dwc_otg_qtd_t *_qtd)
+{
+	DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "
+	            "Transaction Error--\n", _hc->hc_num);
+
+	switch (usb_pipetype(_qtd->urb->pipe)) {
+	case PIPE_CONTROL:
+	case PIPE_BULK:
+		_qtd->error_count++;
+		if (!_hc->qh->ping_state) {
+			update_urb_state_xfer_intr(_hc, _hc_regs, _qtd->urb,
+			                           _qtd, DWC_OTG_HC_XFER_XACT_ERR);
+			save_data_toggle(_hc, _hc_regs, _qtd);
+			if (!_hc->ep_is_in && _qtd->urb->dev->speed == USB_SPEED_HIGH) {
+				_hc->qh->ping_state = 1;
+			}
+		}
+
+		/*
+		 * Halt the channel so the transfer can be re-started from
+		 * the appropriate point or the PING protocol will start.
+		 */
+		halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER_XACT_ERR);
+		break;
+	case PIPE_INTERRUPT:
+		_qtd->error_count++;
+		if ((_hc->do_split) && (_hc->complete_split)) {
+			_qtd->complete_split = 0;
+		}
+		halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER_XACT_ERR);
+		break;
+	case PIPE_ISOCHRONOUS:
+	{
+		dwc_otg_halt_status_e halt_status;
+		halt_status = update_isoc_urb_state(_hcd, _hc, _hc_regs, _qtd,
+		                                    DWC_OTG_HC_XFER_XACT_ERR);
+
+		halt_channel(_hcd, _hc, _qtd, halt_status);
+	}
+	break;
+	}
+
+
+	disable_hc_int(_hc_regs,xacterr);
+
+	return 1;
+}
+
+/**
+ * Handles a host channel frame overrun interrupt. This handler may be called
+ * in either DMA mode or Slave mode.
+ */
+static int32_t handle_hc_frmovrun_intr(dwc_otg_hcd_t *_hcd,
+                                       dwc_hc_t *_hc,
+                                       dwc_otg_hc_regs_t *_hc_regs,
+                                       dwc_otg_qtd_t *_qtd)
+{
+	DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "
+	            "Frame Overrun--\n", _hc->hc_num);
+
+	switch (usb_pipetype(_qtd->urb->pipe)) {
+	case PIPE_CONTROL:
+	case PIPE_BULK:
+		break;
+	case PIPE_INTERRUPT:
+		halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER_FRAME_OVERRUN);
+		break;
+	case PIPE_ISOCHRONOUS:
+	{
+		dwc_otg_halt_status_e halt_status;
+		halt_status = update_isoc_urb_state(_hcd, _hc, _hc_regs, _qtd,
+		                                    DWC_OTG_HC_XFER_FRAME_OVERRUN);
+
+		halt_channel(_hcd, _hc, _qtd, halt_status);
+	}
+	break;
+	}
+
+	disable_hc_int(_hc_regs,frmovrun);
+
+	return 1;
+}
+
+/**
+ * Handles a host channel data toggle error interrupt. This handler may be
+ * called in either DMA mode or Slave mode.
+ */
+static int32_t handle_hc_datatglerr_intr(dwc_otg_hcd_t *_hcd,
+        dwc_hc_t *_hc,
+        dwc_otg_hc_regs_t *_hc_regs,
+        dwc_otg_qtd_t *_qtd)
+{
+	DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "
+	            "Data Toggle Error--\n", _hc->hc_num);
+
+	if (_hc->ep_is_in) {
+		_qtd->error_count = 0;
+	} else {
+		DWC_ERROR("Data Toggle Error on OUT transfer,"
+		          "channel %d\n", _hc->hc_num);
+	}
+
+	disable_hc_int(_hc_regs,datatglerr);
+
+	return 1;
+}
+
+#ifdef DEBUG
+/**
+ * This function is for debug only. It checks that a valid halt status is set
+ * and that HCCHARn.chdis is clear. If there's a problem, corrective action is
+ * taken and a warning is issued.
+ * @return 1 if halt status is ok, 0 otherwise.
+ */
+static inline int halt_status_ok(dwc_otg_hcd_t *_hcd,
+                                 dwc_hc_t *_hc,
+                                 dwc_otg_hc_regs_t *_hc_regs,
+                                 dwc_otg_qtd_t *_qtd)
+{
+	hcchar_data_t hcchar;
+	hctsiz_data_t hctsiz;
+	hcint_data_t hcint;
+	hcintmsk_data_t hcintmsk;
+	hcsplt_data_t hcsplt;
+
+	if (_hc->halt_status == DWC_OTG_HC_XFER_NO_HALT_STATUS) {
+		/*
+		 * This code is here only as a check. This condition should
+		 * never happen. Ignore the halt if it does occur.
+		 */
+		hcchar.d32 = dwc_read_reg32(&_hc_regs->hcchar);
+		hctsiz.d32 = dwc_read_reg32(&_hc_regs->hctsiz);
+		hcint.d32 = dwc_read_reg32(&_hc_regs->hcint);
+		hcintmsk.d32 = dwc_read_reg32(&_hc_regs->hcintmsk);
+		hcsplt.d32 = dwc_read_reg32(&_hc_regs->hcsplt);
+		DWC_WARN("%s: _hc->halt_status == DWC_OTG_HC_XFER_NO_HALT_STATUS, "
+		         "channel %d, hcchar 0x%08x, hctsiz 0x%08x, "
+		         "hcint 0x%08x, hcintmsk 0x%08x, "
+		         "hcsplt 0x%08x, qtd->complete_split %d\n",
+		         __func__, _hc->hc_num, hcchar.d32, hctsiz.d32,
+		         hcint.d32, hcintmsk.d32,
+		         hcsplt.d32, _qtd->complete_split);
+
+		DWC_WARN("%s: no halt status, channel %d, ignoring interrupt\n",
+		         __func__, _hc->hc_num);
+		DWC_WARN("\n");
+		clear_hc_int(_hc_regs,chhltd);
+		return 0;
+	}
+
+	/*
+	 * This code is here only as a check. hcchar.chdis should
+	 * never be set when the halt interrupt occurs. Halt the
+	 * channel again if it does occur.
+	 */
+	hcchar.d32 = dwc_read_reg32(&_hc_regs->hcchar);
+	if (hcchar.b.chdis) {
+		DWC_WARN("%s: hcchar.chdis set unexpectedly, "
+		         "hcchar 0x%08x, trying to halt again\n",
+		         __func__, hcchar.d32);
+		clear_hc_int(_hc_regs,chhltd);
+		_hc->halt_pending = 0;
+		halt_channel(_hcd, _hc, _qtd, _hc->halt_status);
+		return 0;
+	}
+
+	return 1;
+}
+#endif
+
+/**
+ * Handles a host Channel Halted interrupt in DMA mode. This handler
+ * determines the reason the channel halted and proceeds accordingly.
+ */
+static void handle_hc_chhltd_intr_dma(dwc_otg_hcd_t *_hcd,
+                                      dwc_hc_t *_hc,
+                                      dwc_otg_hc_regs_t *_hc_regs,
+                                      dwc_otg_qtd_t *_qtd)
+{
+	hcint_data_t hcint;
+	hcintmsk_data_t hcintmsk;
+
+	if (_hc->halt_status == DWC_OTG_HC_XFER_URB_DEQUEUE ||
+	        _hc->halt_status == DWC_OTG_HC_XFER_AHB_ERR) {
+		/*
+		 * Just release the channel. A dequeue can happen on a
+		 * transfer timeout. In the case of an AHB Error, the channel
+		 * was forced to halt because there's no way to gracefully
+		 * recover.
+		 */
+		release_channel(_hcd, _hc, _qtd, _hc->halt_status);
+		return;
+	}
+
+	/* Read the HCINTn register to determine the cause for the halt. */
+	hcint.d32 = dwc_read_reg32(&_hc_regs->hcint);
+	hcintmsk.d32 = dwc_read_reg32(&_hc_regs->hcintmsk);
+
+	if (hcint.b.xfercomp) {
+		/** @todo This is here because of a possible hardware bug.  Spec
+		 * says that on SPLIT-ISOC OUT transfers in DMA mode that a HALT
+		 * interrupt w/ACK bit set should occur, but I only see the
+		 * XFERCOMP bit, even with it masked out.  This is a workaround
+		 * for that behavior.  Should fix this when hardware is fixed.
+		 */
+		if ((_hc->ep_type == DWC_OTG_EP_TYPE_ISOC) && (!_hc->ep_is_in)) {
+			handle_hc_ack_intr(_hcd, _hc, _hc_regs, _qtd);
+		}
+		handle_hc_xfercomp_intr(_hcd, _hc, _hc_regs, _qtd);
+	} else if (hcint.b.stall) {
+		handle_hc_stall_intr(_hcd, _hc, _hc_regs, _qtd);
+	} else if (hcint.b.xacterr) {
+		/*
+		 * Must handle xacterr before nak or ack. Could get a xacterr
+		 * at the same time as either of these on a BULK/CONTROL OUT
+		 * that started with a PING. The xacterr takes precedence.
+		 */
+		handle_hc_xacterr_intr(_hcd, _hc, _hc_regs, _qtd);
+	} else if (hcint.b.nyet) {
+		/*
+		 * Must handle nyet before nak or ack. Could get a nyet at the
+		 * same time as either of those on a BULK/CONTROL OUT that
+		 * started with a PING. The nyet takes precedence.
+		 */
+		handle_hc_nyet_intr(_hcd, _hc, _hc_regs, _qtd);
+	} else if (hcint.b.bblerr) {
+		handle_hc_babble_intr(_hcd, _hc, _hc_regs, _qtd);
+	} else if (hcint.b.frmovrun) {
+		handle_hc_frmovrun_intr(_hcd, _hc, _hc_regs, _qtd);
+	} else if (hcint.b.nak && !hcintmsk.b.nak) {
+		/*
+		 * If nak is not masked, it's because a non-split IN transfer
+		 * is in an error state. In that case, the nak is handled by
+		 * the nak interrupt handler, not here. Handle nak here for
+		 * BULK/CONTROL OUT transfers, which halt on a NAK to allow
+		 * rewinding the buffer pointer.
+		 */
+		handle_hc_nak_intr(_hcd, _hc, _hc_regs, _qtd);
+	} else if (hcint.b.ack && !hcintmsk.b.ack) {
+		/*
+		 * If ack is not masked, it's because a non-split IN transfer
+		 * is in an error state. In that case, the ack is handled by
+		 * the ack interrupt handler, not here. Handle ack here for
+		 * split transfers. Start splits halt on ACK.
+		 */
+		handle_hc_ack_intr(_hcd, _hc, _hc_regs, _qtd);
+	} else {
+		if (_hc->ep_type == DWC_OTG_EP_TYPE_INTR ||
+		        _hc->ep_type == DWC_OTG_EP_TYPE_ISOC) {
+			/*
+			 * A periodic transfer halted with no other channel
+			 * interrupts set. Assume it was halted by the core
+			 * because it could not be completed in its scheduled
+			 * (micro)frame.
+			 */
+#ifdef DEBUG
+			DWC_PRINT("%s: Halt channel %d (assume incomplete periodic transfer)\n",
+			          __func__, _hc->hc_num);
+#endif
+			halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER_PERIODIC_INCOMPLETE);
+		} else {
+			DWC_ERROR("%s: Channel %d, DMA Mode -- ChHltd set, but reason "
+			          "for halting is unknown, hcint 0x%08x, intsts 0x%08x\n",
+			          __func__, _hc->hc_num, hcint.d32,
+			          dwc_read_reg32(&_hcd->core_if->core_global_regs->gintsts));
+		}
+	}
+}
+
+/**
+ * Handles a host channel Channel Halted interrupt.
+ *
+ * In slave mode, this handler is called only when the driver specifically
+ * requests a halt. This occurs during handling other host channel interrupts
+ * (e.g. nak, xacterr, stall, nyet, etc.).
+ *
+ * In DMA mode, this is the interrupt that occurs when the core has finished
+ * processing a transfer on a channel. Other host channel interrupts (except
+ * ahberr) are disabled in DMA mode.
+ */
+static int32_t handle_hc_chhltd_intr(dwc_otg_hcd_t *_hcd,
+                                     dwc_hc_t *_hc,
+                                     dwc_otg_hc_regs_t *_hc_regs,
+                                     dwc_otg_qtd_t *_qtd)
+{
+	DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "
+	            "Channel Halted--\n", _hc->hc_num);
+
+	if (_hcd->core_if->dma_enable) {
+		handle_hc_chhltd_intr_dma(_hcd, _hc, _hc_regs, _qtd);
+	} else {
+#ifdef DEBUG
+		if (!halt_status_ok(_hcd, _hc, _hc_regs, _qtd)) {
+			return 1;
+		}
+#endif
+		release_channel(_hcd, _hc, _qtd, _hc->halt_status);
+	}
+
+	return 1;
+}
+
+/** Handles interrupt for a specific Host Channel */
+int32_t dwc_otg_hcd_handle_hc_n_intr (dwc_otg_hcd_t *_dwc_otg_hcd, uint32_t _num)
+{
+	int retval = 0;
+	hcint_data_t hcint;
+	hcintmsk_data_t hcintmsk;
+	dwc_hc_t *hc;
+	dwc_otg_hc_regs_t *hc_regs;
+	dwc_otg_qtd_t *qtd;
+
+	DWC_DEBUGPL(DBG_HCDV, "--Host Channel Interrupt--, Channel %d\n", _num);
+
+	hc = _dwc_otg_hcd->hc_ptr_array[_num];
+	hc_regs = _dwc_otg_hcd->core_if->host_if->hc_regs[_num];
+	qtd = list_entry(hc->qh->qtd_list.next, dwc_otg_qtd_t, qtd_list_entry);
+
+	hcint.d32 = dwc_read_reg32(&hc_regs->hcint);
+	hcintmsk.d32 = dwc_read_reg32(&hc_regs->hcintmsk);
+	DWC_DEBUGPL(DBG_HCDV, "  hcint 0x%08x, hcintmsk 0x%08x, hcint&hcintmsk 0x%08x\n",
+	            hcint.d32, hcintmsk.d32, (hcint.d32 & hcintmsk.d32));
+	hcint.d32 = hcint.d32 & hcintmsk.d32;
+
+	if (!_dwc_otg_hcd->core_if->dma_enable) {
+		if ((hcint.b.chhltd) && (hcint.d32 != 0x2)) {
+			hcint.b.chhltd = 0;
+		}
+	}
+
+	if (hcint.b.xfercomp) {
+		retval |= handle_hc_xfercomp_intr(_dwc_otg_hcd, hc, hc_regs, qtd);
+		/*
+		 * If NYET occurred at same time as Xfer Complete, the NYET is
+		 * handled by the Xfer Complete interrupt handler. Don't want
+		 * to call the NYET interrupt handler in this case.
+		 */
+		hcint.b.nyet = 0;
+	}
+	if (hcint.b.chhltd) {
+		retval |= handle_hc_chhltd_intr(_dwc_otg_hcd, hc, hc_regs, qtd);
+	}
+	if (hcint.b.ahberr) {
+		retval |= handle_hc_ahberr_intr(_dwc_otg_hcd, hc, hc_regs, qtd);
+	}
+	if (hcint.b.stall) {
+		retval |= handle_hc_stall_intr(_dwc_otg_hcd, hc, hc_regs, qtd);
+	}
+	if (hcint.b.nak) {
+		retval |= handle_hc_nak_intr(_dwc_otg_hcd, hc, hc_regs, qtd);
+	}
+	if (hcint.b.ack) {
+		retval |= handle_hc_ack_intr(_dwc_otg_hcd, hc, hc_regs, qtd);
+	}
+	if (hcint.b.nyet) {
+		retval |= handle_hc_nyet_intr(_dwc_otg_hcd, hc, hc_regs, qtd);
+	}
+	if (hcint.b.xacterr) {
+		retval |= handle_hc_xacterr_intr(_dwc_otg_hcd, hc, hc_regs, qtd);
+	}
+	if (hcint.b.bblerr) {
+		retval |= handle_hc_babble_intr(_dwc_otg_hcd, hc, hc_regs, qtd);
+	}
+	if (hcint.b.frmovrun) {
+		retval |= handle_hc_frmovrun_intr(_dwc_otg_hcd, hc, hc_regs, qtd);
+	}
+	if (hcint.b.datatglerr) {
+		retval |= handle_hc_datatglerr_intr(_dwc_otg_hcd, hc, hc_regs, qtd);
+	}
+
+	return retval;
+}
+
+#endif /* DWC_DEVICE_ONLY */
Index: linux-2.6.29/drivers/usb/dwc_otg/dwc_otg_hcd_queue.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/usb/dwc_otg/dwc_otg_hcd_queue.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,660 @@
+/* ==========================================================================
+ * $File: //dwh/usb_iip/dev/software/otg_ipmate/linux/drivers/dwc_otg_hcd_queue.c $
+ * $Revision: #4 $
+ * $Date: 2005/09/15 $
+ * $Change: 537387 $
+ *
+ * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
+ * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto. You are permitted to use and
+ * redistribute this Software in source and binary forms, with or without
+ * modification, provided that redistributions of source code must retain this
+ * notice. You may not view, use, disclose, copy or distribute this file or
+ * any information contained herein except pursuant to this license grant from
+ * Synopsys. If you do not agree with this notice, including the disclaimer
+ * below, then you are not authorized to use the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================== */
+#ifndef DWC_DEVICE_ONLY
+
+/**
+ * @file
+ *
+ * This file contains the functions to manage Queue Heads and Queue
+ * Transfer Descriptors.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+
+#ifdef _USE_ATTR_
+#include <asm/arch/lm.h>
+#endif
+
+#include "dwc_otg_driver.h"
+#include "dwc_otg_hcd.h"
+#include "dwc_otg_regs.h"
+
+/**
+ * This function allocates and initializes a QH.
+ *
+ * @param _hcd The HCD state structure for the DWC OTG controller.
+ * @param[in] _urb Holds the information about the device/endpoint that we need
+ * to initialize the QH.
+ *
+ * @return Returns pointer to the newly allocated QH, or NULL on error. */
+dwc_otg_qh_t *dwc_otg_hcd_qh_create (dwc_otg_hcd_t *_hcd, struct urb *_urb)
+{
+	dwc_otg_qh_t *qh;
+
+	/* Allocate memory */
+	/** @todo add memflags argument */
+	qh = dwc_otg_hcd_qh_alloc ();
+	if (qh == NULL) {
+		return NULL;
+	}
+
+	dwc_otg_hcd_qh_init (_hcd, qh, _urb);
+	return qh;
+}
+
+/** Free each QTD in the QH's QTD-list then free the QH.  QH should already be
+ * removed from a list.  QTD list should already be empty if called from URB
+ * Dequeue.
+ *
+ * @param[in] _qh The QH to free.
+ */
+void dwc_otg_hcd_qh_free (dwc_otg_qh_t *_qh)
+{
+	dwc_otg_qtd_t *qtd;
+	struct list_head *pos;
+	unsigned long flags;
+
+	/* Free each QTD in the QTD list */
+	local_irq_save (flags);
+	for (pos = _qh->qtd_list.next;
+	        pos != &_qh->qtd_list;
+	        pos = _qh->qtd_list.next)
+	{
+		list_del (pos);
+		qtd = dwc_list_to_qtd (pos);
+		dwc_otg_hcd_qtd_free (qtd);
+	}
+	local_irq_restore (flags);
+
+	kfree (_qh);
+	return;
+}
+
+/** Initializes a QH structure.
+ *
+ * @param[in] _hcd The HCD state structure for the DWC OTG controller.
+ * @param[in] _qh The QH to init.
+ * @param[in] _urb Holds the information about the device/endpoint that we need
+ * to initialize the QH. */
+#define SCHEDULE_SLOP 10
+void dwc_otg_hcd_qh_init(dwc_otg_hcd_t *_hcd, dwc_otg_qh_t *_qh, struct urb *_urb)
+{
+	memset (_qh, 0, sizeof (dwc_otg_qh_t));
+
+	/* Initialize QH */
+	switch (usb_pipetype(_urb->pipe)) {
+	case PIPE_CONTROL:
+		_qh->ep_type = USB_ENDPOINT_XFER_CONTROL;
+		break;
+	case PIPE_BULK:
+		_qh->ep_type = USB_ENDPOINT_XFER_BULK;
+		break;
+	case PIPE_ISOCHRONOUS:
+		_qh->ep_type = USB_ENDPOINT_XFER_ISOC;
+		break;
+	case PIPE_INTERRUPT:
+		_qh->ep_type = USB_ENDPOINT_XFER_INT;
+		break;
+	}
+
+	_qh->ep_is_in = usb_pipein(_urb->pipe) ? 1 : 0;
+
+	_qh->data_toggle = DWC_OTG_HC_PID_DATA0;
+	_qh->maxp = usb_maxpacket(_urb->dev, _urb->pipe, !(usb_pipein(_urb->pipe)));
+	INIT_LIST_HEAD(&_qh->qtd_list);
+	INIT_LIST_HEAD(&_qh->qh_list_entry);
+	_qh->channel = NULL;
+
+	/* FS/LS Enpoint on HS Hub
+	 * NOT virtual root hub */
+	_qh->do_split = 0;
+	if (((_urb->dev->speed == USB_SPEED_LOW) ||
+	        (_urb->dev->speed == USB_SPEED_FULL)) &&
+	        (_urb->dev->tt) && (_urb->dev->tt->hub/*AlenOh*/) && (_urb->dev->tt->hub->devnum != 1))
+	{
+		DWC_DEBUGPL(DBG_HCD, "QH init: EP %d: TT found at hub addr %d, for port %d\n",
+		            usb_pipeendpoint(_urb->pipe), _urb->dev->tt->hub->devnum,
+		            _urb->dev->ttport);
+		_qh->do_split = 1;
+	}
+
+	if (_qh->ep_type == USB_ENDPOINT_XFER_INT ||
+	        _qh->ep_type == USB_ENDPOINT_XFER_ISOC) {
+		/* Compute scheduling parameters once and save them. */
+		hprt0_data_t hprt;
+
+		/** @todo Account for split transfers in the bus time. */
+		int bytecount = dwc_hb_mult(_qh->maxp) * dwc_max_packet(_qh->maxp);
+		_qh->usecs = usb_calc_bus_time(_urb->dev->speed,
+		                               usb_pipein(_urb->pipe),
+		                               (_qh->ep_type == USB_ENDPOINT_XFER_ISOC),
+		                               bytecount);
+
+		/* Start in a slightly future (micro)frame. */
+		_qh->sched_frame = dwc_frame_num_inc(_hcd->frame_number,
+		                                     SCHEDULE_SLOP);
+
+		_qh->interval = _urb->interval;
+#if 0
+		/* Increase interrupt polling rate for debugging. */
+		if (_qh->ep_type == USB_ENDPOINT_XFER_INT) {
+			_qh->interval = 8;
+		}
+#endif
+		hprt.d32 = dwc_read_reg32(_hcd->core_if->host_if->hprt0);
+		if ((hprt.b.prtspd == DWC_HPRT0_PRTSPD_HIGH_SPEED) &&
+		        ((_urb->dev->speed == USB_SPEED_LOW) ||
+		         (_urb->dev->speed == USB_SPEED_FULL)))
+		{
+			_qh->interval *= 8;
+			_qh->sched_frame |= 0x7;
+			_qh->start_split_frame = _qh->sched_frame;
+		}
+
+	}
+
+	DWC_DEBUGPL(DBG_HCD, "DWC OTG HCD QH Initialized\n");
+	DWC_DEBUGPL(DBG_HCDV, "DWC OTG HCD QH  - qh = %p\n", _qh);
+	DWC_DEBUGPL(DBG_HCDV, "DWC OTG HCD QH  - Device Address = %d\n",
+	            _urb->dev->devnum);
+	DWC_DEBUGPL(DBG_HCDV, "DWC OTG HCD QH  - Endpoint %d, %s\n",
+		    usb_pipeendpoint(_urb->pipe),
+		    usb_pipein(_urb->pipe) == USB_DIR_IN ? "IN" : "OUT");
+	DWC_DEBUGPL(DBG_HCDV, "DWC OTG HCD QH  - Speed = %s\n", 
+		    ({ char *speed; switch (_urb->dev->speed) {
+		    case USB_SPEED_LOW: speed = "low";	break;
+		    case USB_SPEED_FULL: speed = "full";	break;
+		    case USB_SPEED_HIGH: speed = "high";	break;
+		    default: speed = "?";	break;
+		    }; speed;}));
+	DWC_DEBUGPL(DBG_HCDV, "DWC OTG HCD QH  - Type = %s\n",
+		    ({ char *type; switch (_qh->ep_type) {
+		    case USB_ENDPOINT_XFER_ISOC: type = "isochronous";	break;
+		    case USB_ENDPOINT_XFER_INT: type = "interrupt";	break;
+		    case USB_ENDPOINT_XFER_CONTROL: type = "control";	break;
+		    case USB_ENDPOINT_XFER_BULK: type = "bulk";	break;
+		    default: type = "?";	break;
+		    }; type;}));
+#ifdef DEBUG
+	if (_qh->ep_type == USB_ENDPOINT_XFER_INT) {
+		DWC_DEBUGPL(DBG_HCDV, "DWC OTG HCD QH - usecs = %d\n",
+		            _qh->usecs);
+		DWC_DEBUGPL(DBG_HCDV, "DWC OTG HCD QH - interval = %d\n",
+		            _qh->interval);
+	}
+#endif
+
+	return;
+}
+
+/**
+ * Checks that a channel is available for a periodic transfer.
+ *
+ * @return 0 if successful, negative error code otherise.
+ */
+static int periodic_channel_available(dwc_otg_hcd_t *_hcd)
+{
+	/*
+	 * Currently assuming that there is a dedicated host channnel for each
+	 * periodic transaction plus at least one host channel for
+	 * non-periodic transactions.
+	 */
+	int status;
+	int num_channels;
+
+	num_channels = _hcd->core_if->core_params->host_channels;
+	if ((_hcd->periodic_channels + _hcd->non_periodic_channels < num_channels) &&
+	        (_hcd->periodic_channels < num_channels - 1)) {
+		status = 0;
+	}
+	else {
+		DWC_NOTICE("%s: Total channels: %d, Periodic: %d, Non-periodic: %d\n",
+		           __func__, num_channels, _hcd->periodic_channels,
+		           _hcd->non_periodic_channels);
+		status = -ENOSPC;
+	}
+
+	return status;
+}
+
+/**
+ * Checks that there is sufficient bandwidth for the specified QH in the
+ * periodic schedule. For simplicity, this calculation assumes that all the
+ * transfers in the periodic schedule may occur in the same (micro)frame.
+ *
+ * @param _hcd The HCD state structure for the DWC OTG controller.
+ * @param _qh QH containing periodic bandwidth required.
+ *
+ * @return 0 if successful, negative error code otherwise.
+ */
+static int check_periodic_bandwidth(dwc_otg_hcd_t *_hcd, dwc_otg_qh_t *_qh)
+{
+	int 		status;
+	uint16_t 	max_claimed_usecs;
+
+	status = 0;
+
+	//AlenOh, It prevent unwanted change of OTG speed
+	//if (_hcd->core_if->core_params->speed == DWC_SPEED_PARAM_HIGH) {
+	if (_hcd->speed == DWC_SPEED_PARAM_HIGH) {
+		/*
+		 * High speed mode.
+		 * Max periodic usecs is 80% x 125 usec = 100 usec.
+		 */
+		max_claimed_usecs = 100 - _qh->usecs;
+	} else {
+		/*
+		 * Full speed mode.
+		 * Max periodic usecs is 90% x 1000 usec = 900 usec.
+		 */
+		max_claimed_usecs = 900 - _qh->usecs;
+	}
+
+	if (_hcd->periodic_usecs > max_claimed_usecs) {
+		DWC_NOTICE("%s: already claimed usecs %d, required usecs %d\n",
+		           __func__, _hcd->periodic_usecs, _qh->usecs);
+		status = -ENOSPC;
+	}
+
+	return status;
+}
+
+/**
+ * Checks that the max transfer size allowed in a host channel is large enough
+ * to handle the maximum data transfer in a single (micro)frame for a periodic
+ * transfer.
+ *
+ * @param _hcd The HCD state structure for the DWC OTG controller.
+ * @param _qh QH for a periodic endpoint.
+ *
+ * @return 0 if successful, negative error code otherwise.
+ */
+static int check_max_xfer_size(dwc_otg_hcd_t *_hcd, dwc_otg_qh_t *_qh)
+{
+	int		status;
+	uint32_t 	max_xfer_size;
+	uint32_t	max_channel_xfer_size;
+
+	status = 0;
+
+	max_xfer_size = dwc_max_packet(_qh->maxp) * dwc_hb_mult(_qh->maxp);
+	max_channel_xfer_size = _hcd->core_if->core_params->max_transfer_size;
+
+	if (max_xfer_size > max_channel_xfer_size) {
+		DWC_NOTICE("%s: Periodic xfer length %d > "
+		           "max xfer length for channel %d\n",
+		           __func__, max_xfer_size, max_channel_xfer_size);
+		status = -ENOSPC;
+	}
+
+	return status;
+}
+
+/**
+ * Schedules an interrupt or isochronous transfer in the periodic schedule.
+ *
+ * @param _hcd The HCD state structure for the DWC OTG controller.
+ * @param _qh QH for the periodic transfer. The QH should already contain the
+ * scheduling information.
+ *
+ * @return 0 if successful, negative error code otherwise.
+ */
+static int schedule_periodic(dwc_otg_hcd_t *_hcd, dwc_otg_qh_t *_qh)
+{
+	int status = 0;
+
+	status = periodic_channel_available(_hcd);
+	if (status) {
+		DWC_NOTICE("%s: No host channel available for periodic "
+		           "transfer.\n", __func__);
+		return status;
+	}
+
+	status = check_periodic_bandwidth(_hcd, _qh);
+	if (status) {
+		DWC_NOTICE("%s: Insufficient periodic bandwidth for "
+		           "periodic transfer.\n", __func__);
+		return status;
+	}
+
+	status = check_max_xfer_size(_hcd, _qh);
+	if (status) {
+		DWC_NOTICE("%s: Channel max transfer size too small "
+		           "for periodic transfer.\n", __func__);
+		return status;
+	}
+
+	/* Always start in the inactive schedule. */
+	list_add_tail(&_qh->qh_list_entry, &_hcd->periodic_sched_inactive);
+
+	/* Reserve the periodic channel. */
+	_hcd->periodic_channels++;
+
+	/* Update claimed usecs per (micro)frame. */
+	_hcd->periodic_usecs += _qh->usecs;
+
+	/* Update average periodic bandwidth claimed and # periodic reqs for usbfs. */
+	hcd_to_bus(dwc_otg_hcd_to_hcd(_hcd))->bandwidth_allocated += _qh->usecs / _qh->interval;
+	if (_qh->ep_type == USB_ENDPOINT_XFER_INT) {
+		hcd_to_bus(dwc_otg_hcd_to_hcd(_hcd))->bandwidth_int_reqs++;
+		DWC_DEBUGPL(DBG_HCD, "Scheduled intr: qh %p, usecs %d, period %d\n",
+		            _qh, _qh->usecs, _qh->interval);
+	} else {
+		hcd_to_bus(dwc_otg_hcd_to_hcd(_hcd))->bandwidth_isoc_reqs++;
+		DWC_DEBUGPL(DBG_HCD, "Scheduled isoc: qh %p, usecs %d, period %d\n",
+		            _qh, _qh->usecs, _qh->interval);
+	}
+
+	return status;
+}
+
+/**
+ * This function adds a QH to either the non periodic or periodic schedule if
+ * it is not already in the schedule. If the QH is already in the schedule, no
+ * action is taken.
+ *
+ * @return 0 if successful, negative error code otherwise.
+ */
+int dwc_otg_hcd_qh_add (dwc_otg_hcd_t *_hcd, dwc_otg_qh_t *_qh)
+{
+	unsigned long flags;
+	int status = 0;
+
+	local_irq_save(flags);
+
+	if (!list_empty(&_qh->qh_list_entry)) {
+		/* QH already in a schedule. */
+		goto done;
+	}
+
+	/* Add the new QH to the appropriate schedule */
+	if (dwc_qh_is_non_per(_qh)) {
+		/* Always start in the inactive schedule. */
+		list_add_tail(&_qh->qh_list_entry, &_hcd->non_periodic_sched_inactive);
+	} else {
+		status = schedule_periodic(_hcd, _qh);
+	}
+
+done:
+	local_irq_restore(flags);
+
+	return status;
+}
+
+/**
+ * Removes an interrupt or isochronous transfer from the periodic schedule.
+ *
+ * @param _hcd The HCD state structure for the DWC OTG controller.
+ * @param _qh QH for the periodic transfer.
+ */
+static void deschedule_periodic(dwc_otg_hcd_t *_hcd, dwc_otg_qh_t *_qh)
+{
+	list_del_init(&_qh->qh_list_entry);
+
+	/* Release the periodic channel reservation. */
+	_hcd->periodic_channels--;
+
+	/* Update claimed usecs per (micro)frame. */
+	_hcd->periodic_usecs -= _qh->usecs;
+
+	/* Update average periodic bandwidth claimed and # periodic reqs for usbfs. */
+	hcd_to_bus(dwc_otg_hcd_to_hcd(_hcd))->bandwidth_allocated -= _qh->usecs / _qh->interval;
+
+	if (_qh->ep_type == USB_ENDPOINT_XFER_INT) {
+		hcd_to_bus(dwc_otg_hcd_to_hcd(_hcd))->bandwidth_int_reqs--;
+		DWC_DEBUGPL(DBG_HCD, "Descheduled intr: qh %p, usecs %d, period %d\n",
+		            _qh, _qh->usecs, _qh->interval);
+	} else {
+		hcd_to_bus(dwc_otg_hcd_to_hcd(_hcd))->bandwidth_isoc_reqs--;
+		DWC_DEBUGPL(DBG_HCD, "Descheduled isoc: qh %p, usecs %d, period %d\n",
+		            _qh, _qh->usecs, _qh->interval);
+	}
+}
+
+/**
+ * Removes a QH from either the non-periodic or periodic schedule.  Memory is
+ * not freed.
+ *
+ * @param[in] _hcd The HCD state structure.
+ * @param[in] _qh QH to remove from schedule. */
+void dwc_otg_hcd_qh_remove (dwc_otg_hcd_t *_hcd, dwc_otg_qh_t *_qh)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	if (list_empty(&_qh->qh_list_entry)) {
+		/* QH is not in a schedule. */
+		goto done;
+	}
+
+	if (dwc_qh_is_non_per(_qh)) {
+		if (_hcd->non_periodic_qh_ptr == &_qh->qh_list_entry) {
+			_hcd->non_periodic_qh_ptr = _hcd->non_periodic_qh_ptr->next;
+		}
+		list_del_init(&_qh->qh_list_entry);
+	} else {
+		deschedule_periodic(_hcd, _qh);
+	}
+
+done:
+	local_irq_restore(flags);
+}
+
+/**
+ * Deactivates a QH. For non-periodic QHs, removes the QH from the active
+ * non-periodic schedule. The QH is added to the inactive non-periodic
+ * schedule if any QTDs are still attached to the QH.
+ *
+ * For periodic QHs, the QH is removed from the periodic queued schedule. If
+ * there are any QTDs still attached to the QH, the QH is added to either the
+ * periodic inactive schedule or the periodic ready schedule and its next
+ * scheduled frame is calculated. The QH is placed in the ready schedule if
+ * the scheduled frame has been reached already. Otherwise it's placed in the
+ * inactive schedule. If there are no QTDs attached to the QH, the QH is
+ * completely removed from the periodic schedule.
+ */
+void dwc_otg_hcd_qh_deactivate(dwc_otg_hcd_t *_hcd, dwc_otg_qh_t *_qh, int sched_next_periodic_split)
+{
+	unsigned long flags;
+	local_irq_save(flags);
+
+	if (dwc_qh_is_non_per(_qh)) {
+		dwc_otg_hcd_qh_remove(_hcd, _qh);
+		if (!list_empty(&_qh->qtd_list)) {
+			/* Add back to inactive non-periodic schedule. */
+			dwc_otg_hcd_qh_add(_hcd, _qh);
+		}
+	} else {
+		uint16_t frame_number =	dwc_otg_hcd_get_frame_number(dwc_otg_hcd_to_hcd(_hcd));
+
+		if (_qh->do_split) {
+			/* Schedule the next continuing periodic split transfer */
+			if (sched_next_periodic_split) {
+
+				_qh->sched_frame = frame_number;
+				if (dwc_frame_num_le(frame_number,
+				                     dwc_frame_num_inc(_qh->start_split_frame, 1))) {
+					/*
+					 * Allow one frame to elapse after start
+					 * split microframe before scheduling
+					 * complete split, but DONT if we are
+					 * doing the next start split in the
+					 * same frame for an ISOC out.
+					 */
+					if ((_qh->ep_type != USB_ENDPOINT_XFER_ISOC) || (_qh->ep_is_in != 0)) {
+						_qh->sched_frame = dwc_frame_num_inc(_qh->sched_frame, 1);
+					}
+				}
+			} else {
+				_qh->sched_frame = dwc_frame_num_inc(_qh->start_split_frame,
+				                                     _qh->interval);
+				if (dwc_frame_num_le(_qh->sched_frame, frame_number)) {
+					_qh->sched_frame = frame_number;
+				}
+				_qh->sched_frame |= 0x7;
+				_qh->start_split_frame = _qh->sched_frame;
+			}
+		} else {
+			_qh->sched_frame = dwc_frame_num_inc(_qh->sched_frame, _qh->interval);
+			if (dwc_frame_num_le(_qh->sched_frame, frame_number)) {
+				_qh->sched_frame = frame_number;
+			}
+		}
+
+		if (list_empty(&_qh->qtd_list)) {
+			dwc_otg_hcd_qh_remove(_hcd, _qh);
+		} else {
+			/*
+			 * Remove from periodic_sched_queued and move to
+			 * appropriate queue.
+			 */
+			if (_qh->sched_frame == frame_number) {
+				list_move(&_qh->qh_list_entry,
+				          &_hcd->periodic_sched_ready);
+			} else {
+				list_move(&_qh->qh_list_entry,
+				          &_hcd->periodic_sched_inactive);
+			}
+		}
+	}
+
+	local_irq_restore(flags);
+}
+
+/**
+ * This function allocates and initializes a QTD.
+ *
+ * @param[in] _urb The URB to create a QTD from.  Each URB-QTD pair will end up
+ * pointing to each other so each pair should have a unique correlation.
+ *
+ * @return Returns pointer to the newly allocated QTD, or NULL on error. */
+dwc_otg_qtd_t *dwc_otg_hcd_qtd_create (struct urb *_urb)
+{
+	dwc_otg_qtd_t *qtd;
+
+	qtd = dwc_otg_hcd_qtd_alloc ();
+	if (qtd == NULL) {
+		return NULL;
+	}
+
+	dwc_otg_hcd_qtd_init (qtd, _urb);
+	return qtd;
+}
+
+/**
+ * Initializes a QTD structure.
+ *
+ * @param[in] _qtd The QTD to initialize.
+ * @param[in] _urb The URB to use for initialization.  */
+void dwc_otg_hcd_qtd_init (dwc_otg_qtd_t *_qtd, struct urb *_urb)
+{
+	memset (_qtd, 0, sizeof (dwc_otg_qtd_t));
+	_qtd->urb = _urb;
+	if (usb_pipecontrol(_urb->pipe)) {
+		/*
+		 * The only time the QTD data toggle is used is on the data
+		 * phase of control transfers. This phase always starts with
+		 * DATA1.
+		 */
+		_qtd->data_toggle = DWC_OTG_HC_PID_DATA1;
+		_qtd->control_phase = DWC_OTG_CONTROL_SETUP;
+	}
+
+	/* start split */
+	_qtd->complete_split = 0;
+	_qtd->isoc_split_pos = DWC_HCSPLIT_XACTPOS_ALL;
+	_qtd->isoc_split_offset = 0;
+
+	/* Store the qtd ptr in the urb to reference what QTD. */
+	_urb->hcpriv = _qtd;
+	return;
+}
+
+/**
+ * This function adds a QTD to the QTD-list of a QH.  It will find the correct
+ * QH to place the QTD into.  If it does not find a QH, then it will create a
+ * new QH. If the QH to which the QTD is added is not currently scheduled, it
+ * is placed into the proper schedule based on its EP type.
+ *
+ * @param[in] _qtd The QTD to add
+ * @param[in] _dwc_otg_hcd The DWC HCD structure
+ *
+ * @return 0 if successful, negative error code otherwise.
+ */
+int dwc_otg_hcd_qtd_add (dwc_otg_qtd_t *_qtd,
+                         dwc_otg_hcd_t *_dwc_otg_hcd)
+{
+	struct usb_host_endpoint *ep;
+	dwc_otg_qh_t *qh;
+	unsigned long flags;
+	int retval = 0;
+
+	struct urb *urb = _qtd->urb;
+
+	local_irq_save(flags);
+
+	/*
+	 * Get the QH which holds the QTD-list to insert to. Create QH if it
+	 * doesn't exist.
+	 */
+	ep = dwc_urb_to_endpoint(urb);
+	qh = (dwc_otg_qh_t *)ep->hcpriv;
+	if (qh == NULL) {
+		qh = dwc_otg_hcd_qh_create (_dwc_otg_hcd, urb);
+		if (qh == NULL) {
+			goto done;
+		}
+		ep->hcpriv = qh;
+	}
+	//AlenOh, It prevent unwanted change of OTG speed
+	//_dwc_otg_hcd->core_if->core_params->speed = urb->dev->speed;
+	_dwc_otg_hcd->speed = urb->dev->speed;
+	retval = dwc_otg_hcd_qh_add(_dwc_otg_hcd, qh);
+	if (retval == 0) {
+		list_add_tail(&_qtd->qtd_list_entry, &qh->qtd_list);
+	}
+
+done:
+	local_irq_restore(flags);
+	return retval;
+}
+
+#endif /* DWC_DEVICE_ONLY */
Index: linux-2.6.29/drivers/usb/dwc_otg/dwc_otg_pcd.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/usb/dwc_otg/dwc_otg_pcd.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,1665 @@
+/* ==========================================================================
+ * $File: //dwh/usb_iip/dev/software/otg_ipmate/linux/drivers/dwc_otg_pcd.c $
+ * $Revision: #18 $
+ * $Date: 2007/02/07 $
+ * $Change: 791271 $
+ *
+ * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
+ * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto. You are permitted to use and
+ * redistribute this Software in source and binary forms, with or without
+ * modification, provided that redistributions of source code must retain this
+ * notice. You may not view, use, disclose, copy or distribute this file or
+ * any information contained herein except pursuant to this license grant from
+ * Synopsys. If you do not agree with this notice, including the disclaimer
+ * below, then you are not authorized to use the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================== */
+#ifndef DWC_HOST_ONLY
+
+/** @file
+ * This file implements the Peripheral Controller Driver.
+ *
+ * The Peripheral Controller Driver (PCD) is responsible for
+ * translating requests from the Function Driver into the appropriate
+ * actions on the DWC_otg controller. It isolates the Function Driver
+ * from the specifics of the controller by providing an API to the
+ * Function Driver.
+ *
+ * The Peripheral Controller Driver for Linux will implement the
+ * Gadget API, so that the existing Gadget drivers can be used.
+ * (Gadget Driver is the Linux terminology for a Function Driver.)
+ *
+ * The Linux Gadget API is defined in the header file
+ * <code><linux/usb_gadget.h></code>.  The USB EP operations API is
+ * defined in the structure <code>usb_ep_ops</code> and the USB
+ * Controller API is defined in the structure
+ * <code>usb_gadget_ops</code>.
+ *
+ * An important function of the PCD is managing interrupts generated
+ * by the DWC_otg controller. The implementation of the DWC_otg device
+ * mode interrupt service routines is in dwc_otg_pcd_intr.c.
+ *
+ * @todo Add Device Mode test modes (Test J mode, Test K mode, etc).
+ * @todo Does it work when the request size is greater than DEPTSIZ
+ * transfer size
+ *
+ */
+
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+#include <linux/dma-mapping.h>
+
+#ifdef _USE_ATTR_
+#include <asm/arch/lm.h>
+#endif
+
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+
+#include "dwc_otg_driver.h"
+#include "dwc_otg_pcd.h"
+#include "tcc_usb_def.h"
+
+/* For Signature */
+#define DWC_OTG_PCD_SIGNATURE			'D','W','C','_','O','T','G','_','P','C','D','_'
+#define DWC_OTG_PCD_VERSION				'V','2','.','0','0','2'
+static const unsigned char DWC_OTG_PCD_C_Version[] =
+    {SIGBYAHONG, DWC_OTG_PCD_SIGNATURE, SIGN_OS ,SIGN_CHIPSET, DWC_OTG_PCD_VERSION, 0};
+
+
+const unsigned char* dwc_otg_pcd_get_version(void)
+{
+	return DWC_OTG_PCD_C_Version;
+}
+
+
+/**
+ * Static PCD pointer for use in usb_gadget_register_driver and
+ * usb_gadget_unregister_driver.  Initialized in dwc_otg_pcd_init.
+ */
+static	 dwc_otg_pcd_t *s_pcd = 0;
+
+
+/* Display the contents of the buffer */
+extern void dump_msg(const u8 *buf, unsigned int length);
+
+
+/**
+ * This function completes a request.  It call's the request call back.
+ */
+void request_done(dwc_otg_pcd_ep_t *_ep, dwc_otg_pcd_request_t *_req,
+                  int _status)
+{
+	unsigned stopped = _ep->stopped;
+
+	DWC_DEBUGPL(DBG_PCDV, "%s(%p)\n", __func__, _ep);
+	list_del_init(&_req->queue);
+
+	if (_req->req.status == -EINPROGRESS)
+	{
+		_req->req.status = _status;
+	}
+	else
+	{
+		_status = _req->req.status;
+	}
+
+	/* don't modify queue heads during completion callback */
+	_ep->stopped = 1;
+	SPIN_UNLOCK(&_ep->pcd->lock);
+	_req->req.complete(&_ep->ep, &_req->req);
+	SPIN_LOCK(&_ep->pcd->lock);
+
+	if (_ep->pcd->request_pending > 0)
+	{
+		--_ep->pcd->request_pending;
+	}
+
+	_ep->stopped = stopped;
+}
+
+/**
+ * This function terminates all the requsts in the EP request queue.
+ */
+void request_nuke( dwc_otg_pcd_ep_t *_ep )
+{
+	dwc_otg_pcd_request_t *req;
+
+	_ep->stopped = 1;
+
+	/* called with irqs blocked?? */
+	while (!list_empty(&_ep->queue))
+	{
+		req = list_entry(_ep->queue.next, dwc_otg_pcd_request_t,
+		                 queue);
+		request_done(_ep, req, -ESHUTDOWN );
+	}
+}
+
+/* USB Endpoint Operations */
+/*
+ * The following sections briefly describe the behavior of the Gadget
+ * API endpoint operations implemented in the DWC_otg driver
+ * software. Detailed descriptions of the generic behavior of each of
+ * these functions can be found in the Linux header file
+ * include/linux/usb_gadget.h.
+ *
+ * The Gadget API provides wrapper functions for each of the function
+ * pointers defined in usb_ep_ops. The Gadget Driver calls the wrapper
+ * function, which then calls the underlying PCD function. The
+ * following sections are named according to the wrapper
+ * functions. Within each section, the corresponding DWC_otg PCD
+ * function name is specified.
+ *
+ */
+
+/**
+ * This function assigns periodic Tx FIFO to an periodic EP
+ * in shared Tx FIFO mode
+ */
+//static uint32_t assign_perio_tx_fifo(dwc_otg_core_if_t	*core_if)
+//{
+//	uint32_t PerTxMsk = 1;
+//	int i;
+//	for(i = 0; i < core_if->hwcfg4.b.num_dev_perio_in_ep; ++i)
+//	{
+//		if((PerTxMsk & core_if->p_tx_msk) == 0)
+//		{
+//			core_if->p_tx_msk |= PerTxMsk;
+//			return i + 1;
+//		}
+//		PerTxMsk <<= 1;
+//	}
+//	return 0;
+//}
+/**
+ * This function releases periodic Tx FIFO
+ * in shared Tx FIFO mode
+ */
+static void release_perio_tx_fifo(dwc_otg_core_if_t *core_if, uint32_t fifo_num)
+{
+	core_if->p_tx_msk = (core_if->p_tx_msk & (1 << (fifo_num - 1))) ^ core_if->p_tx_msk;
+}
+/**
+ * This function assigns periodic Tx FIFO to an periodic EP
+ * in shared Tx FIFO mode
+ */
+//static uint32_t assign_tx_fifo(dwc_otg_core_if_t *core_if)
+//{
+//	uint32_t TxMsk = 1;
+//	int i;
+//
+//	for (i = 0; i < core_if->hwcfg4.b.num_in_eps; ++i)
+//	{
+//		if ((TxMsk & core_if->tx_msk) == 0)
+//		{
+//			core_if->tx_msk |= TxMsk;
+//			return i + 1;
+//		}
+//		TxMsk <<= 1;
+//	}
+//	return 0;
+//}
+/**
+ * This function releases periodic Tx FIFO
+ * in shared Tx FIFO mode
+ */
+static void release_tx_fifo(dwc_otg_core_if_t	*core_if, uint32_t fifo_num)
+{
+	core_if->tx_msk = (core_if->tx_msk & (1 << (fifo_num - 1))) ^ core_if->tx_msk;
+}
+/**
+ * This function is called by the Gadget Driver for each EP to be
+ * configured for the current configuration (SET_CONFIGURATION).
+ *
+ * This function initializes the dwc_otg_ep_t data structure, and then
+ * calls dwc_otg_ep_activate.
+ */
+static int dwc_otg_pcd_ep_enable(struct usb_ep *_ep,
+                                 const struct usb_endpoint_descriptor *_desc)
+{
+	dwc_otg_pcd_ep_t *ep = 0;
+	dwc_otg_pcd_t *pcd = 0;
+	unsigned long flags;
+	
+	DWC_DEBUGPL(DBG_PCDV,"%s(%p,%p)\n", __func__, _ep, _desc );
+	ep = container_of(_ep, dwc_otg_pcd_ep_t, ep);
+	if (!_ep || !_desc || ep->desc ||
+	        _desc->bDescriptorType != USB_DT_ENDPOINT)
+	{
+		DWC_WARN( "%s, bad ep or descriptor\n", __func__);
+		return -EINVAL;
+	}
+	if (ep == &ep->pcd->ep0)
+	{
+		DWC_WARN("%s, bad ep(0)\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Check FIFO size? */
+	if (!_desc->wMaxPacketSize)
+	{
+		DWC_WARN("%s, bad %s maxpacket\n", __func__, _ep->name);
+		return -ERANGE;
+	}
+
+	pcd = ep->pcd;
+	if (!pcd->driver || pcd->gadget.speed == USB_SPEED_UNKNOWN)
+	{
+		DWC_WARN("%s, bogus device state\n", __func__);
+		return -ESHUTDOWN;
+	}
+
+	SPIN_LOCK_IRQSAVE(&pcd->lock, flags);
+
+	ep->desc = _desc;
+	ep->ep.maxpacket = le16_to_cpu (_desc->wMaxPacketSize);
+
+	/*
+	 * Activate the EP
+	 */
+	ep->stopped = 0;
+
+	ep->dwc_ep.is_in = (USB_DIR_IN & _desc->bEndpointAddress) != 0;
+	ep->dwc_ep.maxpacket = ep->ep.maxpacket;
+
+	ep->dwc_ep.type = _desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
+
+	if (ep->dwc_ep.is_in)
+	{
+		//if(!pcd->otg_dev->core_if->en_multiple_tx_fifo)
+		//{
+		//	ep->dwc_ep.tx_fifo_num = 0;
+		//
+		//	if ((_desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
+		//		USB_ENDPOINT_XFER_ISOC )
+		//	{
+		//		/*
+		//		 * if ISOC EP then assign a Periodic Tx FIFO.
+		//		 */
+		//		ep->dwc_ep.tx_fifo_num = assign_perio_tx_fifo(pcd->otg_dev->core_if);
+		//	 }
+		//}
+		//else
+		{
+			/*
+			 * if Dedicated FIFOs mode is on then assign a Tx FIFO.
+			 */
+			ep->dwc_ep.tx_fifo_num = ep->dwc_ep.num;//assign_tx_fifo(pcd->otg_dev->core_if);
+		}
+	}
+	/* Set initial data PID. */
+	if ((_desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
+	        USB_ENDPOINT_XFER_BULK )
+	{
+		ep->dwc_ep.data_pid_start = 0;
+	}
+
+	DWC_DEBUGPL(DBG_PCD, " Activate %s-%s: type=%d, mps=%d desc=%p\n",
+	            ep->ep.name, (ep->dwc_ep.is_in ?"IN":"OUT"),
+	            ep->dwc_ep.type, ep->dwc_ep.maxpacket, ep->desc );
+
+
+	dwc_otg_ep_activate( GET_CORE_IF(pcd), &ep->dwc_ep );
+	SPIN_UNLOCK_IRQRESTORE(&pcd->lock, flags);
+	return 0;
+}
+
+/**
+ * This function is called when an EP is disabled due to disconnect or
+ * change in configuration. Any pending requests will terminate with a
+ * status of -ESHUTDOWN.
+ *
+ * This function modifies the dwc_otg_ep_t data structure for this EP,
+ * and then calls dwc_otg_ep_deactivate.
+ */
+int dwc_otg_pcd_ep_disable(struct usb_ep *_ep)
+{
+	dwc_otg_pcd_ep_t *ep;
+	unsigned long flags;
+
+	DWC_DEBUGPL(DBG_PCDV,"%s(%p)\n", __func__, _ep);
+	ep = container_of(_ep, dwc_otg_pcd_ep_t, ep);
+	if (!_ep || !ep->desc)
+	{
+		DWC_DEBUGPL(DBG_PCD, "%s, %s not enabled\n", __func__,
+		            _ep ? ep->ep.name : NULL);
+		return -EINVAL;
+	}
+
+	SPIN_LOCK_IRQSAVE(&ep->pcd->lock, flags);
+
+	request_nuke( ep );
+
+	dwc_otg_ep_deactivate( GET_CORE_IF(ep->pcd), &ep->dwc_ep );
+	ep->desc = 0;
+	ep->stopped = 1;
+
+	if (ep->dwc_ep.is_in)
+	{
+		release_perio_tx_fifo(GET_CORE_IF(ep->pcd), ep->dwc_ep.tx_fifo_num);
+		release_tx_fifo(GET_CORE_IF(ep->pcd), ep->dwc_ep.tx_fifo_num);
+	}
+
+	SPIN_UNLOCK_IRQRESTORE(&ep->pcd->lock, flags);
+
+	DWC_DEBUGPL(DBG_PCD, "%s disabled\n", _ep->name);
+	return 0;
+}
+
+
+/**
+ * This function allocates a request object to use with the specified
+ * endpoint.
+ *
+ * @param _ep The endpoint to be used with with the request
+ * @param _gfp_flags the GFP_* flags to use.
+ */
+static struct usb_request *dwc_otg_pcd_alloc_request(struct usb_ep *_ep,
+        gfp_t _gfp_flags)
+{
+	dwc_otg_pcd_request_t *req;
+
+	DWC_DEBUGPL(DBG_PCDV,"%s(%p,%d)\n", __func__, _ep, _gfp_flags);
+	if (0 == _ep )
+	{
+		DWC_WARN("%s() %s\n", __func__, "Invalid EP!\n");
+		return 0;
+	}
+	req = kmalloc( sizeof(dwc_otg_pcd_request_t), _gfp_flags);
+	if (0 == req)
+	{
+		DWC_WARN("%s() %s\n", __func__,
+		         "request allocation failed!\n");
+		return 0;
+	}
+	memset(req, 0, sizeof(dwc_otg_pcd_request_t));
+	req->req.dma = DMA_ADDR_INVALID;
+	INIT_LIST_HEAD(&req->queue);
+	return &req->req;
+}
+
+/**
+ * This function frees a request object.
+ *
+ * @param _ep The endpoint associated with the request
+ * @param _req The request being freed
+ */
+static void dwc_otg_pcd_free_request(struct usb_ep *_ep,
+                                     struct usb_request *_req)
+{
+	dwc_otg_pcd_request_t *req;
+	DWC_DEBUGPL(DBG_PCDV,"%s(%p,%p)\n", __func__, _ep, _req);
+
+	if (0 == _ep || 0 == _req)
+	{
+		DWC_WARN("%s() %s\n", __func__,
+		         "Invalid ep or req argument!\n");
+		return;
+	}
+
+	req = container_of(_req, dwc_otg_pcd_request_t, req);
+	kfree(req);
+}
+
+/**
+ * This function is used to submit an I/O Request to an EP.
+ *
+ *	- When the request completes the request's completion callback
+ *	  is called to return the request to the driver.
+ *	- An EP, except control EPs, may have multiple requests
+ *	  pending.
+ *	- Once submitted the request cannot be examined or modified.
+ *	- Each request is turned into one or more packets.
+ *	- A BULK EP can queue any amount of data; the transfer is
+ *	  packetized.
+ *	- Zero length Packets are specified with the request 'zero'
+ *	  flag.
+ */
+static int dwc_otg_pcd_ep_queue(struct usb_ep *_ep,
+                                struct usb_request *_req, gfp_t _gfp_flags)
+{
+	int prevented = 0;
+	dwc_otg_pcd_request_t *req;
+	dwc_otg_pcd_ep_t *ep;
+	dwc_otg_pcd_t	*pcd;
+	unsigned long flags = 0;
+
+	DWC_DEBUGPL(DBG_PCDV,"%s(%p,%p,%d)\n",
+	            __func__, _ep, _req, _gfp_flags);
+
+	req = container_of(_req, dwc_otg_pcd_request_t, req);
+	if (!_req || !_req->complete || !_req->buf ||
+	        !list_empty(&req->queue))
+	{
+		DWC_WARN("%s, bad params\n", __func__);
+		return -EINVAL;
+	}
+
+	ep = container_of(_ep, dwc_otg_pcd_ep_t, ep);
+	if (!_ep || (!ep->desc && ep->dwc_ep.num != 0))
+	{
+		DWC_WARN("%s, bad ep\n", __func__);
+		return -EINVAL;
+	}
+	pcd = ep->pcd;
+	if (!pcd->driver || pcd->gadget.speed == USB_SPEED_UNKNOWN)
+	{
+		DWC_DEBUGPL(DBG_PCDV, "gadget.speed=%d\n", pcd->gadget.speed);
+		DWC_WARN("%s, bogus device state\n", __func__);
+		return -ESHUTDOWN;
+	}
+
+
+	DWC_DEBUGPL(DBG_PCD, "%s queue req %p, len %d buf %p\n",
+	            _ep->name, _req, _req->length, _req->buf);
+
+	if (!GET_CORE_IF(pcd)->core_params->opt)
+	{
+		if (ep->dwc_ep.num != 0)
+		{
+			DWC_ERROR("%s queue req %p, len %d buf %p\n",
+			          _ep->name, _req, _req->length, _req->buf);
+		}
+	}
+
+	SPIN_LOCK_IRQSAVE(&ep->pcd->lock, flags);
+
+#if defined(DEBUG) & defined(VERBOSE)
+	dump_msg(_req->buf, _req->length);
+#endif
+	//MDELAY(5);
+	_req->status = -EINPROGRESS;
+	_req->actual = 0;
+
+	/*
+	 * For EP0 IN without premature status, zlp is required?
+	 */
+	if (ep->dwc_ep.num == 0 && ep->dwc_ep.is_in)
+	{
+		DWC_DEBUGPL(DBG_PCDV, "%s-OUT ZLP\n", _ep->name);
+		//_req->zero = 1;
+	}
+
+	/* Start the transfer */
+	if (list_empty(&ep->queue) && !ep->stopped)
+	{
+		/* EP0 Transfer? */
+		if (ep->dwc_ep.num == 0)
+		{
+			switch (pcd->ep0state)
+			{
+			case EP0_IN_DATA_PHASE:
+				DWC_DEBUGPL(DBG_PCD,
+				            "%s ep0: EP0_IN_DATA_PHASE\n",
+				            __func__);
+				break;
+
+			case EP0_OUT_DATA_PHASE:
+				DWC_DEBUGPL(DBG_PCD,
+				            "%s ep0: EP0_OUT_DATA_PHASE\n",
+				            __func__);
+				//if (pcd->request_config)
+				//{
+				//	/* Complete STATUS PHASE */
+				//	ep->dwc_ep.is_in = 1;
+				//	pcd->ep0state = EP0_STATUS;
+				//}
+				break;
+
+			case EP0_STATUS:
+				DWC_DEBUGPL(DBG_PCD,
+				            "%s ep0: EP0_STATUS\n",
+				            __func__);
+				break;
+
+			default:
+				DWC_DEBUGPL(DBG_ANY, "ep0: odd state %d\n",
+				            pcd->ep0state);
+				SPIN_UNLOCK_IRQRESTORE(&pcd->lock, flags);
+				return -EL2HLT;
+			}
+
+			ep->dwc_ep.dma_addr = _req->dma;
+			ep->dwc_ep.start_xfer_buff = _req->buf;
+			ep->dwc_ep.xfer_buff = _req->buf;
+			ep->dwc_ep.xfer_len = _req->length;
+			ep->dwc_ep.xfer_count = 0;
+			ep->dwc_ep.sent_zlp = 0;
+			ep->dwc_ep.total_len = ep->dwc_ep.xfer_len;
+			dwc_otg_ep0_start_transfer( GET_CORE_IF(pcd),
+			                            &ep->dwc_ep );
+		}
+		else
+		{
+			/* Setup and start the Transfer */
+			ep->dwc_ep.dma_addr = _req->dma;
+			ep->dwc_ep.start_xfer_buff = _req->buf;
+			ep->dwc_ep.xfer_buff = _req->buf;
+			ep->dwc_ep.xfer_len = _req->length;
+			ep->dwc_ep.xfer_count = 0;
+			ep->dwc_ep.sent_zlp = 0;
+			ep->dwc_ep.total_len = ep->dwc_ep.xfer_len;
+			dwc_otg_ep_start_transfer( GET_CORE_IF(pcd),
+			                           &ep->dwc_ep );
+		}
+	}
+
+	if ((req != 0) || prevented)
+	{
+		++pcd->request_pending;
+		list_add_tail(&req->queue, &ep->queue);
+		if (ep->dwc_ep.is_in && ep->stopped && !(GET_CORE_IF(pcd)->dma_enable))
+		{
+			/** @todo NGS Create a function for this. */
+			diepmsk_data_t diepmsk = { .d32 = 0};
+			diepmsk.b.intktxfemp = 1;
+			dwc_modify_reg32( &GET_CORE_IF(pcd)->dev_if->dev_global_regs->diepmsk, 0, diepmsk.d32 );
+		}
+	}
+
+	SPIN_UNLOCK_IRQRESTORE(&pcd->lock, flags);
+	return 0;
+}
+
+/**
+ * This function cancels an I/O request from an EP.
+ */
+static int dwc_otg_pcd_ep_dequeue(struct usb_ep *_ep,
+                                  struct usb_request *_req)
+{
+	dwc_otg_pcd_request_t *req;
+	dwc_otg_pcd_ep_t *ep;
+	dwc_otg_pcd_t	*pcd;
+	unsigned long flags;
+
+	DWC_DEBUGPL(DBG_PCDV,"%s(%p,%p)\n", __func__, _ep, _req);
+
+	ep = container_of(_ep, dwc_otg_pcd_ep_t, ep);
+	if (!_ep || !_req || (!ep->desc && ep->dwc_ep.num != 0))
+	{
+		DWC_WARN("%s, bad argument\n", __func__);
+		return -EINVAL;
+	}
+	pcd = ep->pcd;
+	if (!pcd->driver || pcd->gadget.speed == USB_SPEED_UNKNOWN)
+	{
+		DWC_WARN("%s, bogus device state\n", __func__);
+		return -ESHUTDOWN;
+	}
+
+	SPIN_LOCK_IRQSAVE(&pcd->lock, flags);
+	DWC_DEBUGPL(DBG_PCDV, "%s %s %s %p\n", __func__, _ep->name,
+	            ep->dwc_ep.is_in ? "IN" : "OUT",
+	            _req);
+
+	/* make sure it's actually queued on this endpoint */
+	list_for_each_entry( req, &ep->queue, queue)
+	{
+		if (&req->req == _req)
+		{
+			break;
+		}
+	}
+
+	if (&req->req != _req)
+	{
+		SPIN_UNLOCK_IRQRESTORE(&pcd->lock, flags);
+		return -EINVAL;
+	}
+
+	if (!list_empty(&req->queue))
+	{
+		request_done(ep, req, -ECONNRESET);
+	}
+	else
+	{
+		req = 0;
+	}
+
+	SPIN_UNLOCK_IRQRESTORE(&pcd->lock, flags);
+
+	return req ? 0 : -EOPNOTSUPP;
+}
+
+/**
+ * usb_ep_set_halt stalls an endpoint.
+ *
+ * usb_ep_clear_halt clears an endpoint halt and resets its data
+ * toggle.
+ *
+ * Both of these functions are implemented with the same underlying
+ * function. The behavior depends on the value argument.
+ *
+ * @param[in] _ep the Endpoint to halt or clear halt.
+ * @param[in] _value
+ *	- 0 means clear_halt.
+ *	- 1 means set_halt,
+ *	- 2 means clear stall lock flag.
+ *	- 3 means set  stall lock flag.
+ */
+static int dwc_otg_pcd_ep_set_halt(struct usb_ep *_ep, int _value)
+{
+	int retval = 0;
+	unsigned long flags;
+	dwc_otg_pcd_ep_t *ep = 0;
+
+
+	DWC_DEBUGPL(DBG_PCD,"HALT %s %d\n", _ep->name, _value);
+
+	ep = container_of(_ep, dwc_otg_pcd_ep_t, ep);
+
+	if (!_ep || (!ep->desc && ep != &ep->pcd->ep0) ||
+	        ep->desc->bmAttributes == USB_ENDPOINT_XFER_ISOC)
+	{
+		DWC_WARN("%s, bad ep\n", __func__);
+		return -EINVAL;
+	}
+
+	SPIN_LOCK_IRQSAVE(&ep->pcd->lock, flags);
+	if (!list_empty(&ep->queue))
+	{
+		DWC_WARN("%s() %s XFer In process\n", __func__, _ep->name);
+		retval = -EAGAIN;
+	}
+	else if (_value == 0)
+	{
+		dwc_otg_ep_clear_stall( ep->pcd->otg_dev->core_if,
+		                        &ep->dwc_ep );
+	}
+	else if (_value == 1)
+	{
+		if (ep->dwc_ep.num == 0)
+		{
+			ep->pcd->ep0state = EP0_STALL;
+		}
+
+		ep->stopped = 1;
+		dwc_otg_ep_set_stall( ep->pcd->otg_dev->core_if,
+		                      &ep->dwc_ep );
+	}
+	else if (_value == 2)
+	{
+		ep->dwc_ep.stall_clear_flag = 0;
+	}
+	else if (_value == 3)
+	{
+		ep->dwc_ep.stall_clear_flag = 1;
+	}
+
+	SPIN_UNLOCK_IRQRESTORE(&ep->pcd->lock, flags);
+	return retval;
+}
+
+
+static struct usb_ep_ops dwc_otg_pcd_ep_ops =
+{
+	.enable         = dwc_otg_pcd_ep_enable,
+	.disable        = dwc_otg_pcd_ep_disable,
+
+	.alloc_request  = dwc_otg_pcd_alloc_request,
+	.free_request   = dwc_otg_pcd_free_request,
+
+	.queue          = dwc_otg_pcd_ep_queue,
+	.dequeue        = dwc_otg_pcd_ep_dequeue,
+
+	.set_halt       = dwc_otg_pcd_ep_set_halt,
+	.fifo_status    = 0,
+	.fifo_flush     = 0,
+};
+
+/*	Gadget Operations */
+/**
+ * The following gadget operations will be implemented in the DWC_otg
+ * PCD. Functions in the API that are not described below are not
+ * implemented.
+ *
+ * The Gadget API provides wrapper functions for each of the function
+ * pointers defined in usb_gadget_ops. The Gadget Driver calls the
+ * wrapper function, which then calls the underlying PCD function. The
+ * following sections are named according to the wrapper functions
+ * (except for ioctl, which doesn't have a wrapper function). Within
+ * each section, the corresponding DWC_otg PCD function name is
+ * specified.
+ *
+ */
+
+/**
+ *Gets the USB Frame number of the last SOF.
+ */
+static int dwc_otg_pcd_get_frame(struct usb_gadget *_gadget)
+{
+	dwc_otg_pcd_t *pcd;
+
+	DWC_DEBUGPL(DBG_PCDV,"%s(%p)\n", __func__, _gadget);
+
+	if (_gadget == 0)
+	{
+		return -ENODEV;
+	}
+	else
+	{
+		pcd = container_of(_gadget, dwc_otg_pcd_t, gadget);
+		dwc_otg_get_frame_number( GET_CORE_IF(pcd) );
+	}
+
+	return 0;
+}
+
+void dwc_otg_pcd_initiate_srp(dwc_otg_pcd_t *_pcd)
+{
+	uint32_t *addr = (uint32_t *)&(GET_CORE_IF(_pcd)->core_global_regs->gotgctl);
+	gotgctl_data_t mem;
+	gotgctl_data_t val;
+
+	val.d32 = dwc_read_reg32( addr );
+	if (val.b.sesreq)
+	{
+		DWC_ERROR("Session Request Already active!\n");
+		return;
+	}
+
+	DWC_NOTICE("Session Request Initated\n");
+	mem.d32 = dwc_read_reg32(addr);
+	mem.b.sesreq = 1;
+	dwc_write_reg32(addr, mem.d32);
+
+	/* Start the SRP timer */
+	dwc_otg_pcd_start_srp_timer( _pcd );
+	return;
+}
+
+void dwc_otg_pcd_remote_wakeup(dwc_otg_pcd_t *_pcd, int set)
+{
+	dctl_data_t dctl = {.d32=0};
+	volatile uint32_t *addr =
+	    &(GET_CORE_IF(_pcd)->dev_if->dev_global_regs->dctl);
+
+	if (dwc_otg_is_device_mode(GET_CORE_IF(_pcd)))
+	{
+		if (_pcd->remote_wakeup_enable)
+		{
+			if (set)
+			{
+				dctl.b.rmtwkupsig = 1;
+				dwc_modify_reg32( addr, 0, dctl.d32 );
+				DWC_DEBUGPL(DBG_PCD, "Set Remote Wakeup\n");
+				mdelay(1);
+				dwc_modify_reg32( addr, dctl.d32, 0 );
+				DWC_DEBUGPL(DBG_PCD, "Clear Remote Wakeup\n");
+			}
+			else
+			{
+			}
+		}
+		else
+		{
+			DWC_DEBUGPL(DBG_PCD, "Remote Wakeup is disabled\n");
+		}
+	}
+
+	return;
+}
+
+/**
+ * Initiates Session Request Protocol (SRP) to wakeup the host if no
+ * session is in progress. If a session is already in progress, but
+ * the device is suspended, remote wakeup signaling is started.
+ *
+ */
+static int dwc_otg_pcd_wakeup(struct usb_gadget *_gadget)
+{
+	unsigned long flags;
+	dwc_otg_pcd_t *pcd;
+	dsts_data_t		dsts;
+	gotgctl_data_t	gotgctl;
+
+	DWC_DEBUGPL(DBG_PCDV,"%s(%p)\n", __func__, _gadget);
+
+	if (_gadget == 0)
+	{
+		return -ENODEV;
+	}
+	else
+	{
+		pcd = container_of(_gadget, dwc_otg_pcd_t, gadget);
+	}
+	SPIN_LOCK_IRQSAVE(&pcd->lock, flags);
+
+	/*
+	 * This function starts the Protocol if no session is in progress. If
+	 * a session is already in progress, but the device is suspended,
+	 * remote wakeup signaling is started.
+	 */
+
+	/* Check if valid session */
+	gotgctl.d32 = dwc_read_reg32(&(GET_CORE_IF(pcd)->core_global_regs->gotgctl));
+	if (gotgctl.b.bsesvld)
+	{
+		/* Check if suspend state */
+		dsts.d32 = dwc_read_reg32(&(GET_CORE_IF(pcd)->dev_if->dev_global_regs->dsts));
+		if (dsts.b.suspsts)
+		{
+			dwc_otg_pcd_remote_wakeup(pcd, 1);
+		}
+	}
+	else
+	{
+		dwc_otg_pcd_initiate_srp(pcd);
+	}
+
+	SPIN_UNLOCK_IRQRESTORE(&pcd->lock, flags);
+	return 0;
+}
+
+static const struct usb_gadget_ops dwc_otg_pcd_ops =
+{
+	.get_frame	 = dwc_otg_pcd_get_frame,
+	.wakeup		 = dwc_otg_pcd_wakeup,
+	// current versions must always be self-powered
+};
+
+/**
+ * This function updates the otg values in the gadget structure.
+ */
+void dwc_otg_pcd_update_otg( dwc_otg_pcd_t *_pcd, const unsigned _reset )
+{
+
+	if (!_pcd->gadget.is_otg)
+		return;
+
+	if (_reset)
+	{
+		_pcd->b_hnp_enable = 0;
+		_pcd->a_hnp_support = 0;
+		_pcd->a_alt_hnp_support = 0;
+	}
+
+	_pcd->gadget.b_hnp_enable = _pcd->b_hnp_enable;
+	_pcd->gadget.a_hnp_support =  _pcd->a_hnp_support;
+	_pcd->gadget.a_alt_hnp_support = _pcd->a_alt_hnp_support;
+}
+
+/**
+ * This function is the top level PCD interrupt handler.
+ */
+static irqreturn_t
+dwc_otg_pcd_irq(int _irq, void *_dev)
+{
+	dwc_otg_pcd_t *pcd = _dev;
+	int32_t retval = IRQ_NONE;
+	retval = dwc_otg_pcd_handle_intr( pcd );
+	return IRQ_RETVAL(retval);
+}
+
+/**
+ * PCD Callback function for initializing the PCD when switching to
+ * device mode.
+ *
+ * @param _p void pointer to the <code>dwc_otg_pcd_t</code>
+ */
+static int32_t dwc_otg_pcd_start_cb( void *_p )
+{
+	dwc_otg_pcd_t *pcd = (dwc_otg_pcd_t *)_p;
+
+	/*
+	 * Initialized the Core for Device mode.
+	 */
+	if (dwc_otg_is_device_mode( GET_CORE_IF(pcd) ))
+	{
+		dwc_otg_core_dev_init(GET_CORE_IF(pcd));
+	}
+
+	return 1;
+}
+
+/**
+ * PCD Callback function for stopping the PCD when switching to Host
+ * mode.
+ *
+ * @param _p void pointer to the <code>dwc_otg_pcd_t</code>
+ */
+static int32_t dwc_otg_pcd_stop_cb( void *_p )
+{
+	dwc_otg_pcd_t *pcd = (dwc_otg_pcd_t *)_p;
+	extern void dwc_otg_pcd_stop(dwc_otg_pcd_t *_pcd);
+
+	dwc_otg_pcd_stop( pcd );
+	return 1;
+}
+
+
+/**
+ * PCD Callback function for notifying the PCD when resuming from
+ * suspend.
+ *
+ * @param _p void pointer to the <code>dwc_otg_pcd_t</code>
+ */
+static int32_t dwc_otg_pcd_suspend_cb( void *_p )
+{
+	dwc_otg_pcd_t *pcd = (dwc_otg_pcd_t *)_p;
+
+	if (pcd->driver && pcd->driver->suspend)
+	{
+		SPIN_UNLOCK(&pcd->lock);
+		pcd->driver->suspend(&pcd->gadget);
+		SPIN_LOCK(&pcd->lock);
+	}
+
+	return 1;
+}
+
+
+/**
+ * PCD Callback function for notifying the PCD when resuming from
+ * suspend.
+ *
+ * @param _p void pointer to the <code>dwc_otg_pcd_t</code>
+ */
+static int32_t dwc_otg_pcd_resume_cb( void *_p )
+{
+	dwc_otg_pcd_t *pcd = (dwc_otg_pcd_t *)_p;
+
+	if (pcd->driver && pcd->driver->resume)
+	{
+		SPIN_UNLOCK(&pcd->lock);
+		pcd->driver->resume(&pcd->gadget);
+		SPIN_LOCK(&pcd->lock);
+	}
+
+	/* Stop the SRP timeout timer. */
+	if ((GET_CORE_IF(pcd)->core_params->phy_type != DWC_PHY_TYPE_PARAM_FS) ||
+	        (!GET_CORE_IF(pcd)->core_params->i2c_enable))
+	{
+		if (GET_CORE_IF(pcd)->srp_timer_started)
+		{
+			GET_CORE_IF(pcd)->srp_timer_started = 0;
+			del_timer( &pcd->srp_timer );
+		}
+	}
+	return 1;
+}
+
+
+/**
+ * PCD Callback structure for handling mode switching.
+ */
+static dwc_otg_cil_callbacks_t pcd_callbacks =
+{
+	.start = dwc_otg_pcd_start_cb,
+	.stop = dwc_otg_pcd_stop_cb,
+	.suspend = dwc_otg_pcd_suspend_cb,
+	.resume_wakeup = dwc_otg_pcd_resume_cb,
+	.p = 0, /* Set at registration */
+};
+
+/**
+ * This function is called when the SRP timer expires.	The SRP should
+ * complete within 6 seconds.
+ */
+static void srp_timeout( unsigned long _ptr )
+{
+	gotgctl_data_t gotgctl;
+	dwc_otg_core_if_t *core_if = (dwc_otg_core_if_t *)_ptr;
+	volatile uint32_t *addr = &core_if->core_global_regs->gotgctl;
+
+	gotgctl.d32 = dwc_read_reg32(addr);
+
+	core_if->srp_timer_started = 0;
+
+	if ((core_if->core_params->phy_type == DWC_PHY_TYPE_PARAM_FS) &&
+	        (core_if->core_params->i2c_enable))
+	{
+		DWC_PRINT( "SRP Timeout\n");
+
+		if ((core_if->srp_success) &&
+		        (gotgctl.b.bsesvld))
+		{
+			if (core_if->pcd_cb && core_if->pcd_cb->resume_wakeup )
+			{
+				core_if->pcd_cb->resume_wakeup(core_if->pcd_cb->p);
+			}
+
+			/* Clear Session Request */
+			gotgctl.d32 = 0;
+			gotgctl.b.sesreq = 1;
+			dwc_modify_reg32( &core_if->core_global_regs->gotgctl,
+			                  gotgctl.d32, 0);
+
+			core_if->srp_success = 0;
+		}
+		else
+		{
+			DWC_ERROR( "Device not connected/responding\n");
+			gotgctl.b.sesreq = 0;
+			dwc_write_reg32(addr, gotgctl.d32);
+		}
+	}
+	else if (gotgctl.b.sesreq)
+	{
+		DWC_PRINT( "SRP Timeout\n");
+
+		DWC_ERROR( "Device not connected/responding\n");
+		gotgctl.b.sesreq = 0;
+		dwc_write_reg32(addr, gotgctl.d32);
+	}
+	else
+	{
+		DWC_PRINT( " SRP GOTGCTL=%0x\n", gotgctl.d32);
+	}
+}
+
+/**
+ * Start the SRP timer to detect when the SRP does not complete within
+ * 6 seconds.
+ *
+ * @param _pcd the pcd structure.
+ */
+void dwc_otg_pcd_start_srp_timer(dwc_otg_pcd_t *_pcd )
+{
+	struct timer_list *srp_timer = &_pcd->srp_timer;
+	GET_CORE_IF(_pcd)->srp_timer_started = 1;
+	init_timer( srp_timer );
+	srp_timer->function = srp_timeout;
+	srp_timer->data = (unsigned long)GET_CORE_IF(_pcd);
+	srp_timer->expires = jiffies + (HZ*6);
+	add_timer( srp_timer );
+}
+
+/**
+ * Tasklet
+ *
+ */
+extern void start_next_request( dwc_otg_pcd_ep_t *_ep );
+
+static void start_xfer_tasklet_func (unsigned long data)
+{
+	dwc_otg_pcd_t *pcd = (dwc_otg_pcd_t*)data;
+	dwc_otg_core_if_t *core_if = pcd->otg_dev->core_if;
+
+	int i;
+	depctl_data_t diepctl;
+
+	DWC_DEBUGPL(DBG_PCDV, "Start xfer tasklet\n");
+
+	diepctl.d32 = dwc_read_reg32( &core_if->dev_if->in_ep_regs[0]->diepctl);
+
+	if (pcd->ep0.queue_sof)
+	{
+		pcd->ep0.queue_sof = 0;
+		start_next_request (&pcd->ep0);
+		// break;
+	}
+
+	for (i=0; i<core_if->dev_if->num_in_eps; i++)
+	{
+		depctl_data_t diepctl;
+		diepctl.d32 = dwc_read_reg32( &core_if->dev_if->in_ep_regs[i]->diepctl);
+
+		if (pcd->in_ep[i].queue_sof)
+		{
+			pcd->in_ep[i].queue_sof = 0;
+			start_next_request (&pcd->in_ep[i]);
+			// break;
+		}
+	}
+
+	return;
+}
+
+
+
+
+
+
+
+static struct tasklet_struct start_xfer_tasklet = {
+	.next = NULL,
+	.state = 0,
+	.count = ATOMIC_INIT(0),
+	.func = start_xfer_tasklet_func,
+	.data = 0,
+};
+/**
+ * This function initialized the pcd Dp structures to there default
+ * state.
+ *
+ * @param _pcd the pcd structure.
+ */
+void dwc_otg_pcd_reinit(dwc_otg_pcd_t *_pcd)
+{
+	static const char * names[] =
+	{
+
+		"ep0",
+		"ep1in",
+		"ep2in",
+		"ep3in",
+		"ep4in",
+		"ep5in",
+		"ep6in",
+		"ep7in",
+		"ep8in",
+		"ep9in",
+		"ep10in",
+		"ep11in",
+		"ep12in",
+		"ep13in",
+		"ep14in",
+		"ep15in",
+		"ep1out",
+		"ep2out",
+		"ep3out",
+		"ep4out",
+		"ep5out",
+		"ep6out",
+		"ep7out",
+		"ep8out",
+		"ep9out",
+		"ep10out",
+		"ep11out",
+		"ep12out",
+		"ep13out",
+		"ep14out",
+		"ep15out"
+
+	};
+
+	int i;
+	int in_ep_cntr, out_ep_cntr;
+	uint32_t hwcfg1;
+	uint32_t num_in_eps = (GET_CORE_IF(_pcd))->dev_if->num_in_eps;
+	uint32_t num_out_eps = (GET_CORE_IF(_pcd))->dev_if->num_out_eps;
+	dwc_otg_pcd_ep_t *ep;
+
+	DWC_DEBUGPL(DBG_PCDV, "%s(%p)\n", __func__, _pcd);
+
+	INIT_LIST_HEAD (&_pcd->gadget.ep_list);
+	_pcd->gadget.ep0 = &_pcd->ep0.ep;
+	_pcd->gadget.speed = USB_SPEED_UNKNOWN;
+
+	INIT_LIST_HEAD (&_pcd->gadget.ep0->ep_list);
+
+	/**
+	 * Initialize the EP0 structure.
+	 */
+	ep = &_pcd->ep0;
+
+	/* Init EP structure */
+	ep->desc = 0;
+	ep->pcd = _pcd;
+	ep->stopped = 1;
+
+	/* Init DWC ep structure */
+	ep->dwc_ep.num = 0;
+	ep->dwc_ep.active = 0;
+	ep->dwc_ep.tx_fifo_num = 0;
+	/* Control until ep is actvated */
+	ep->dwc_ep.type = DWC_OTG_EP_TYPE_CONTROL;
+	ep->dwc_ep.maxpacket = MAX_PACKET_SIZE;
+	ep->dwc_ep.dma_addr = 0;
+	ep->dwc_ep.start_xfer_buff = 0;
+	ep->dwc_ep.xfer_buff = 0;
+	ep->dwc_ep.xfer_len = 0;
+	ep->dwc_ep.xfer_count = 0;
+	ep->dwc_ep.sent_zlp = 0;
+	ep->dwc_ep.total_len = 0;
+	ep->queue_sof = 0;
+
+	/* Init the usb_ep structure. */
+	ep->ep.name = names[0];
+	ep->ep.ops = &dwc_otg_pcd_ep_ops;
+
+	/**
+	 * @todo NGS: What should the max packet size be set to
+	 * here?  Before EP type is set?
+	 */
+	ep->ep.maxpacket = MAX_PACKET_SIZE;
+
+	list_add_tail (&ep->ep.ep_list, &_pcd->gadget.ep_list);
+
+	INIT_LIST_HEAD (&ep->queue);
+	/**
+	 * Initialize the EP structures.
+	 */
+	in_ep_cntr = 0;
+	hwcfg1 = (GET_CORE_IF(_pcd))->hwcfg1.d32 >> 3;
+
+	for (i = 1; in_ep_cntr < num_in_eps; i++)
+	{
+		if ((hwcfg1 & 0x1) == 0)
+		{
+			dwc_otg_pcd_ep_t *ep = &_pcd->in_ep[in_ep_cntr];
+			in_ep_cntr ++;
+
+			/* Init EP structure */
+			ep->desc = 0;
+			ep->pcd = _pcd;
+			ep->stopped = 1;
+
+			/* Init DWC ep structure */
+			ep->dwc_ep.is_in = 1;
+			ep->dwc_ep.num = i;
+			ep->dwc_ep.active = 0;
+			ep->dwc_ep.tx_fifo_num = 0;
+
+			/* Control until ep is actvated */
+			ep->dwc_ep.type = DWC_OTG_EP_TYPE_CONTROL;
+			ep->dwc_ep.maxpacket = MAX_PACKET_SIZE;
+			ep->dwc_ep.dma_addr = 0;
+			ep->dwc_ep.start_xfer_buff = 0;
+			ep->dwc_ep.xfer_buff = 0;
+			ep->dwc_ep.xfer_len = 0;
+			ep->dwc_ep.xfer_count = 0;
+			ep->dwc_ep.sent_zlp = 0;
+			ep->dwc_ep.total_len = 0;
+			ep->queue_sof = 0;
+
+			/* Init the usb_ep structure. */
+			/**
+			 * @todo NGS: Add direction to EP, based on contents
+			 * of HWCFG1.  Need a copy of HWCFG1 in pcd structure?
+			 * sprintf( ";r
+			 */
+			ep->ep.name = names[i];
+			ep->ep.ops = &dwc_otg_pcd_ep_ops;
+
+			/**
+			 * @todo NGS: What should the max packet size be set to
+			 * here?  Before EP type is set?
+			 */
+			ep->ep.maxpacket = MAX_PACKET_SIZE;
+
+			list_add_tail (&ep->ep.ep_list, &_pcd->gadget.ep_list);
+
+			INIT_LIST_HEAD (&ep->queue);
+		}
+		hwcfg1 >>= 2;
+	}
+
+	out_ep_cntr = 0;
+	hwcfg1 = (GET_CORE_IF(_pcd))->hwcfg1.d32 >> 2;
+
+	for (i = 1; out_ep_cntr < num_out_eps; i++)
+	{
+		if ((hwcfg1 & 0x1) == 0)
+		{
+			dwc_otg_pcd_ep_t *ep = &_pcd->out_ep[out_ep_cntr];
+			out_ep_cntr++;
+
+			/* Init EP structure */
+			ep->desc = 0;
+			ep->pcd = _pcd;
+			ep->stopped = 1;
+
+			/* Init DWC ep structure */
+			ep->dwc_ep.is_in = 0;
+			ep->dwc_ep.num = i;
+			ep->dwc_ep.active = 0;
+			ep->dwc_ep.tx_fifo_num = 0;
+			/* Control until ep is actvated */
+			ep->dwc_ep.type = DWC_OTG_EP_TYPE_CONTROL;
+			ep->dwc_ep.maxpacket = MAX_PACKET_SIZE;
+			ep->dwc_ep.dma_addr = 0;
+			ep->dwc_ep.start_xfer_buff = 0;
+			ep->dwc_ep.xfer_buff = 0;
+			ep->dwc_ep.xfer_len = 0;
+			ep->dwc_ep.xfer_count = 0;
+			ep->dwc_ep.sent_zlp = 0;
+			ep->dwc_ep.total_len = 0;
+			ep->queue_sof = 0;
+
+			/* Init the usb_ep structure. */
+			/**
+			 * @todo NGS: Add direction to EP, based on contents
+			 * of HWCFG1.  Need a copy of HWCFG1 in pcd structure?
+			 * sprintf( ";r
+			 */
+			ep->ep.name = names[15 + i];
+			ep->ep.ops = &dwc_otg_pcd_ep_ops;
+			/**
+			 * @todo NGS: What should the max packet size be set to
+			 * here?  Before EP type is set?
+			 */
+			ep->ep.maxpacket = MAX_PACKET_SIZE;
+
+			list_add_tail (&ep->ep.ep_list, &_pcd->gadget.ep_list);
+
+			INIT_LIST_HEAD (&ep->queue);
+		}
+		hwcfg1 >>= 2;
+	}
+
+	/* remove ep0 from the list.  There is a ep0 pointer.*/
+	list_del_init (&_pcd->ep0.ep.ep_list);
+
+	_pcd->ep0state = EP0_DISCONNECT;
+	_pcd->ep0.ep.maxpacket = MAX_EP0_SIZE;
+	_pcd->ep0.dwc_ep.maxpacket = MAX_EP0_SIZE;
+	_pcd->ep0.dwc_ep.type = DWC_OTG_EP_TYPE_CONTROL;
+}
+
+/**
+ * This function releases the Gadget device.
+ * required by device_unregister().
+ *
+ * @todo Should this do something?	Should it free the PCD?
+ */
+static void dwc_otg_pcd_gadget_release(struct device *_dev)
+{
+	DWC_DEBUGPL(DBG_PCDV,"%s(%p)\n", __func__, _dev);
+}
+
+
+static const char on_string[] = "on";
+static ssize_t set_srp(struct device *dev, struct device_attribute *attr,
+                       const char *_buf, size_t _count)
+{
+	dwc_otg_device_t *otg_dev = dev_get_otgdata(dev);
+	int rc = 0;
+	int len = _count;
+	char *cp = memchr(_buf, '\n', _count);
+	if (cp)
+		len = cp - _buf;
+
+	if (len == sizeof on_string - 1 && strncmp(_buf, on_string, len) == 0)
+		dwc_otg_pcd_initiate_srp(otg_dev->pcd);
+	else
+		rc = -EINVAL;
+
+	return (rc < 0 ? rc : _count);
+}
+static DEVICE_ATTR(srpinit, S_IWUSR, NULL, set_srp);
+
+/**
+ * This function initialized the PCD portion of the driver.
+ *
+ */
+
+int __init dwc_otg_pcd_init(struct device *dev)
+{
+	static char pcd_name[] = "dwc_otg_pcd";
+	dwc_otg_pcd_t *pcd;
+	dwc_otg_device_t *otg_dev = dev_get_otgdata(dev);
+	int retval = 0;
+
+	device_create_file(dev,&dev_attr_srpinit);
+
+	DWC_DEBUGPL(DBG_PCDV,"%s(%p)\n",__func__, dev );
+	/*
+	 * Allocate PCD structure
+	 */
+	pcd = kmalloc( sizeof(dwc_otg_pcd_t), GFP_KERNEL);
+
+	if (pcd == 0)
+	{
+		return -ENOMEM;
+	}
+
+	memset( pcd, 0, sizeof(dwc_otg_pcd_t));
+	spin_lock_init( &pcd->lock );
+
+	otg_dev->pcd = pcd;
+	s_pcd = pcd;
+	pcd->gadget.name = pcd_name;
+	strcpy(pcd->gadget.dev.bus_id, "gadget");
+
+	pcd->otg_dev = dev_get_otgdata(dev);
+
+	pcd->gadget.dev.parent = dev;
+	pcd->gadget.dev.release = dwc_otg_pcd_gadget_release;
+	pcd->gadget.ops = &dwc_otg_pcd_ops;
+
+	if (GET_CORE_IF(pcd)->hwcfg4.b.ded_fifo_en)
+	{
+		DWC_PRINT("Dedicated Tx FIFOs mode\n");
+	}
+	else
+	{
+		DWC_PRINT("Shared Tx FIFO mode\n");
+	}
+
+	/* If the module is set to FS or if the PHY_TYPE is FS then the gadget
+	 * should not report as dual-speed capable. replace the following line
+	 * with the block of code below it once the software is debugged for
+	 * this.  If is_dualspeed = 0 then the gadget driver should not report
+	 * a device qualifier descriptor when queried. */
+	if ((GET_CORE_IF(pcd)->core_params->speed == DWC_SPEED_PARAM_FULL) ||
+	        ((GET_CORE_IF(pcd)->hwcfg2.b.hs_phy_type == 2) &&
+	         (GET_CORE_IF(pcd)->hwcfg2.b.fs_phy_type == 1) &&
+	         (GET_CORE_IF(pcd)->core_params->ulpi_fs_ls)))
+	{
+		pcd->gadget.is_dualspeed = 0;
+	}
+	else
+	{
+		pcd->gadget.is_dualspeed = 1;
+	}
+
+	//if ((otg_dev->core_if->hwcfg2.b.op_mode == DWC_HWCFG2_OP_MODE_NO_SRP_CAPABLE_DEVICE) ||
+	//(otg_dev->core_if->hwcfg2.b.op_mode == DWC_HWCFG2_OP_MODE_NO_SRP_CAPABLE_HOST) ||
+	//(otg_dev->core_if->hwcfg2.b.op_mode == DWC_HWCFG2_OP_MODE_SRP_CAPABLE_DEVICE) ||
+	//(otg_dev->core_if->hwcfg2.b.op_mode == DWC_HWCFG2_OP_MODE_SRP_CAPABLE_HOST))
+	//{
+	//	pcd->gadget.is_otg = 0;
+	//}
+	//else
+	{
+		pcd->gadget.is_otg = 1;
+	}
+
+	pcd->driver = 0;
+	/* Register the gadget device */
+	device_register( &pcd->gadget.dev );
+
+	/*
+	 * Initialized the Core for Device mode.
+	 */
+	if (dwc_otg_is_device_mode( GET_CORE_IF(pcd) ))
+	{
+		dwc_otg_core_dev_init( GET_CORE_IF(pcd) );
+	}
+	/*
+	 * Initialize EP structures
+	 */
+	dwc_otg_pcd_reinit( pcd );
+
+	/*
+	 * Register the PCD Callbacks.
+	 */
+	dwc_otg_cil_register_pcd_callbacks( otg_dev->core_if, &pcd_callbacks,pcd );
+	/*
+	 * Setup interupt handler
+	 */
+	DWC_DEBUGPL( DBG_ANY, "registering handler for irq%d\n",ARM_VP_OTG_INTR );
+	retval = request_irq(ARM_VP_OTG_INTR, dwc_otg_pcd_irq,
+	                     IRQF_SHARED, pcd->gadget.name, pcd);
+	if (retval != 0)
+	{
+		DWC_ERROR("request of irq%d failed\n", ARM_VP_OTG_INTR);
+		kfree (pcd);
+		return -EBUSY;
+	}
+
+	/*
+	 * Initialize the DMA buffer for SETUP packets
+	 */
+	if (GET_CORE_IF(pcd)->dma_enable)
+	{
+		pcd->setup_pkt = dma_alloc_coherent (NULL, sizeof (*pcd->setup_pkt) * 5, &pcd->setup_pkt_dma_handle, 0);
+		pcd->status_buf = dma_alloc_coherent (NULL, sizeof (uint16_t), &pcd->status_buf_dma_handle, 0);
+	}
+	else
+	{
+		pcd->setup_pkt = kmalloc (sizeof (*pcd->setup_pkt) * 5, GFP_KERNEL);
+		pcd->status_buf = kmalloc (sizeof (uint16_t), GFP_KERNEL);
+	}
+
+	if (pcd->setup_pkt == 0)
+	{
+		kfree (pcd);
+		return -ENOMEM;
+	}
+
+	/* Initialize tasklet */
+	start_xfer_tasklet.data = (unsigned long)pcd;
+	pcd->start_xfer_tasklet = &start_xfer_tasklet;
+
+	return 0;
+}
+
+/**
+ * Cleanup the PCD.
+ */
+void dwc_otg_pcd_remove( struct device *dev )
+{
+	dwc_otg_device_t *otg_dev = dev_get_otgdata(dev);
+	dwc_otg_pcd_t *pcd = otg_dev->pcd;
+
+	DWC_DEBUGPL(DBG_PCDV, "%s(%p)\n", __func__, dev);
+
+	device_remove_file(dev,&dev_attr_srpinit);
+
+	/*
+	 * Free the IRQ
+	 */
+	free_irq( ARM_VP_OTG_INTR, pcd );
+
+	/* start with the driver above us */
+	if (pcd->driver)
+	{
+		/* should have been done already by driver model core */
+		DWC_WARN("driver '%s' is still registered\n",
+		         pcd->driver->driver.name);
+		usb_gadget_unregister_driver( pcd->driver);
+	}
+	device_unregister(&pcd->gadget.dev);
+
+	if (GET_CORE_IF(pcd)->dma_enable)
+	{
+		dma_free_coherent (NULL, sizeof (*pcd->setup_pkt) * 5, pcd->setup_pkt, pcd->setup_pkt_dma_handle);
+		dma_free_coherent (NULL, sizeof (uint16_t), pcd->status_buf, pcd->status_buf_dma_handle);
+	}
+	else
+	{
+		kfree (pcd->setup_pkt);
+		kfree (pcd->status_buf);
+	}
+
+	kfree( pcd );
+	otg_dev->pcd = 0;
+}
+
+/**
+ * This function registers a gadget driver with the PCD.
+ *
+ * When a driver is successfully registered, it will receive control
+ * requests including set_configuration(), which enables non-control
+ * requests.  then usb traffic follows until a disconnect is reported.
+ * then a host may connect again, or the driver might get unbound.
+ *
+ * @param _driver The driver being registered
+ */
+int usb_gadget_register_driver(struct usb_gadget_driver *_driver)
+{
+	int retval;
+
+	DWC_DEBUGPL(DBG_PCD, "registering gadget driver '%s'\n", _driver->driver.name);
+
+	if (!_driver || _driver->speed == USB_SPEED_UNKNOWN ||
+	        !_driver->bind ||
+	        !_driver->unbind ||
+	        !_driver->disconnect ||
+	        !_driver->setup)
+	{
+		DWC_DEBUGPL(DBG_PCDV,"EINVAL\n");
+		return -EINVAL;
+	}
+	if (s_pcd == 0)
+	{
+		DWC_DEBUGPL(DBG_PCDV,"ENODEV\n");
+		return -ENODEV;
+	}
+	if (s_pcd->driver != 0)
+	{
+		DWC_DEBUGPL(DBG_PCDV,"EBUSY (%p)\n", s_pcd->driver);
+		return -EBUSY;
+	}
+
+	/* hook up the driver */
+	s_pcd->driver = _driver;
+	s_pcd->gadget.dev.driver = &_driver->driver;
+
+	DWC_DEBUGPL(DBG_PCD, "bind to driver %s\n", _driver->driver.name);
+	retval = _driver->bind(&s_pcd->gadget);
+	if (retval)
+	{
+		DWC_ERROR("bind to driver %s --> error %d\n",
+		          _driver->driver.name, retval);
+		s_pcd->driver = 0;
+		s_pcd->gadget.dev.driver = 0;
+		return retval;
+	}
+	DWC_DEBUGPL(DBG_ANY, "registered gadget driver '%s'\n",
+	            _driver->driver.name);
+	return 0;
+}
+
+EXPORT_SYMBOL(usb_gadget_register_driver);
+
+/**
+ * This function unregisters a gadget driver
+ *
+ * @param _driver The driver being unregistered
+ */
+int usb_gadget_unregister_driver(struct usb_gadget_driver *_driver)
+{
+	//DWC_DEBUGPL(DBG_PCDV,"%s(%p)\n", __func__, _driver);
+
+	if (s_pcd == 0)
+	{
+		DWC_DEBUGPL(DBG_ANY, "%s Return(%d): s_pcd==0\n", __func__,
+		            -ENODEV);
+		return -ENODEV;
+	}
+	if (_driver == 0 || _driver != s_pcd->driver)
+	{
+		DWC_DEBUGPL( DBG_ANY, "%s Return(%d): driver?\n", __func__,
+		             -EINVAL);
+		return -EINVAL;
+	}
+
+	_driver->unbind(&s_pcd->gadget);
+	s_pcd->driver = 0;
+
+	DWC_DEBUGPL(DBG_ANY, "unregistered driver '%s'\n",
+	            _driver->driver.name);
+	return 0;
+}
+EXPORT_SYMBOL(usb_gadget_unregister_driver);
+
+#endif /* DWC_HOST_ONLY */
Index: linux-2.6.29/drivers/usb/dwc_otg/dwc_otg_pcd.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/usb/dwc_otg/dwc_otg_pcd.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,214 @@
+/* ==========================================================================
+ * $File: //dwh/usb_iip/dev/software/otg_ipmate/linux/drivers/dwc_otg_pcd.h $
+ * $Revision: #6 $
+ * $Date: 2007/02/07 $
+ * $Change: 791271 $
+ *
+ * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
+ * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto. You are permitted to use and
+ * redistribute this Software in source and binary forms, with or without
+ * modification, provided that redistributions of source code must retain this
+ * notice. You may not view, use, disclose, copy or distribute this file or
+ * any information contained herein except pursuant to this license grant from
+ * Synopsys. If you do not agree with this notice, including the disclaimer
+ * below, then you are not authorized to use the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================== */
+#ifndef DWC_HOST_ONLY
+#if !defined(__DWC_PCD_H__)
+#define __DWC_PCD_H__
+
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/device.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+
+struct lm_device;
+struct dwc_otg_device;
+
+#include "dwc_otg_cil.h"
+
+/**
+ * @file
+ *
+ * This file contains the structures, constants, and interfaces for
+ * the Perpherial Contoller Driver (PCD).
+ *
+ * The Peripheral Controller Driver (PCD) for Linux will implement the
+ * Gadget API, so that the existing Gadget drivers can be used.	 For
+ * the Mass Storage Function driver the File-backed USB Storage Gadget
+ * (FBS) driver will be used.  The FBS driver supports the
+ * Control-Bulk (CB), Control-Bulk-Interrupt (CBI), and Bulk-Only
+ * transports.
+ *
+ */
+
+/** Invalid DMA Address */
+#define DMA_ADDR_INVALID	(~(dma_addr_t)0)
+/** Maxpacket size for EP0 */
+#define MAX_EP0_SIZE	64
+/** Maxpacket size for any EP */
+#define MAX_PACKET_SIZE 1024
+
+/**
+ * Get the pointer to the core_if from the pcd pointer.
+ */
+#define GET_CORE_IF( _pcd ) (_pcd->otg_dev->core_if)
+
+/**
+ * States of EP0.
+ */
+typedef enum ep0_state
+{
+	EP0_DISCONNECT,		/* no host */
+	EP0_IDLE,
+	EP0_IN_DATA_PHASE,
+	EP0_OUT_DATA_PHASE,
+	EP0_STATUS,
+	EP0_STALL,
+} ep0state_e;
+
+/** Fordward declaration.*/
+struct dwc_otg_pcd;
+
+/**	  PCD EP structure.
+ * This structure describes an EP, there is an array of EPs in the PCD
+ * structure.
+ */
+typedef struct dwc_otg_pcd_ep
+{
+	/** USB EP data */
+	struct usb_ep		ep;
+	/** USB EP Descriptor */
+	const struct usb_endpoint_descriptor	*desc;
+
+	/** queue of dwc_otg_pcd_requests. */
+	struct list_head	queue;
+	unsigned stopped : 1;
+	unsigned disabling : 1;
+	unsigned dma : 1;
+	unsigned queue_sof : 1;
+
+	/** DWC_otg ep data. */
+	dwc_ep_t dwc_ep;
+
+	/** Pointer to PCD */
+	struct dwc_otg_pcd *pcd;
+} dwc_otg_pcd_ep_t;
+
+
+
+/** DWC_otg PCD Structure.
+ * This structure encapsulates the data for the dwc_otg PCD.
+ */
+typedef struct dwc_otg_pcd
+{
+	/** USB gadget */
+	struct usb_gadget gadget;
+	/** USB gadget driver pointer*/
+	struct usb_gadget_driver *driver;
+	/** The DWC otg device pointer. */
+	struct dwc_otg_device *otg_dev;
+
+	/** State of EP0 */
+	ep0state_e	ep0state;
+	/** EP0 Request is pending */
+	unsigned	ep0_pending : 1;
+	/** Indicates when SET CONFIGURATION Request is in process */
+	//unsigned	request_config : 1;
+	/** The state of the Remote Wakeup Enable. */
+	unsigned	remote_wakeup_enable : 1;
+	/** The state of the B-Device HNP Enable. */
+	unsigned	b_hnp_enable : 1;
+	/** The state of A-Device HNP Support. */
+	unsigned	a_hnp_support : 1;
+	/** The state of the A-Device Alt HNP support. */
+	unsigned	a_alt_hnp_support : 1;
+	/** Count of pending Requests */
+	unsigned	request_pending;
+
+	/** SETUP packet for EP0
+	* This structure is allocated as a DMA buffer on PCD initialization
+	* with enough space for up to 3 setup packets.
+	*/
+	union
+	{
+		struct usb_ctrlrequest	req;
+		uint32_t	d32[2];
+	} *setup_pkt;
+
+	dma_addr_t setup_pkt_dma_handle;
+
+	/** 2-byte dma buffer used to return status from GET_STATUS */
+	uint16_t *status_buf;
+	dma_addr_t status_buf_dma_handle;
+
+	/** Array of EPs. */
+	dwc_otg_pcd_ep_t ep0;
+	/** Array of IN EPs. */
+	dwc_otg_pcd_ep_t in_ep[ MAX_EPS_CHANNELS - 1];
+	/** Array of OUT EPs. */
+	dwc_otg_pcd_ep_t out_ep[ MAX_EPS_CHANNELS - 1];
+	/** number of valid EPs in the above array. */
+//	  unsigned	num_eps : 4;
+	spinlock_t	lock;
+	/** Timer for SRP.	If it expires before SRP is successful
+	 * clear the SRP. */
+	struct timer_list srp_timer;
+
+	/** Tasklet to defer starting of TEST mode transmissions until
+	 *	Status Phase has been completed.
+	 */
+	struct tasklet_struct test_mode_tasklet;
+
+	/** Tasklet to delay starting of xfer in DMA mode */
+	struct tasklet_struct *start_xfer_tasklet;
+
+	/** The test mode to enter when the tasklet is executed. */
+	unsigned test_mode;
+
+} dwc_otg_pcd_t;
+
+
+/** DWC_otg request structure.
+ * This structure is a list of requests.
+ */
+typedef struct dwc_otg_pcd_request
+{
+	struct usb_request	req; /**< USB Request. */
+	struct list_head	queue;	/**< queue of these requests. */
+} dwc_otg_pcd_request_t;
+
+
+extern int __init dwc_otg_pcd_init(struct device *dev);
+
+//extern void dwc_otg_pcd_remove( struct dwc_otg_device *_otg_dev );
+extern void dwc_otg_pcd_remove( struct device *dev );
+extern int32_t dwc_otg_pcd_handle_intr( dwc_otg_pcd_t *_pcd );
+extern void dwc_otg_pcd_start_srp_timer(dwc_otg_pcd_t *_pcd );
+
+extern void dwc_otg_pcd_initiate_srp(dwc_otg_pcd_t *_pcd);
+extern void dwc_otg_pcd_remote_wakeup(dwc_otg_pcd_t *_pcd, int set);
+
+#endif
+#endif /* DWC_HOST_ONLY */
Index: linux-2.6.29/drivers/usb/dwc_otg/dwc_otg_pcd_intr.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/usb/dwc_otg/dwc_otg_pcd_intr.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,2713 @@
+/* ==========================================================================
+ * $File: //dwh/usb_iip/dev/software/otg_ipmate/linux/drivers/dwc_otg_pcd_intr.c $
+ * $Revision: #18 $
+ * $Date: 2007/02/07 $
+ * $Change: 791271 $
+ *
+ * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
+ * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto. You are permitted to use and
+ * redistribute this Software in source and binary forms, with or without
+ * modification, provided that redistributions of source code must retain this
+ * notice. You may not view, use, disclose, copy or distribute this file or
+ * any information contained herein except pursuant to this license grant from
+ * Synopsys. If you do not agree with this notice, including the disclaimer
+ * below, then you are not authorized to use the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================== */
+#ifndef DWC_HOST_ONLY
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include "dwc_otg_driver.h"
+#include "dwc_otg_pcd.h"
+#include "tcc_usb_def.h"
+
+/* For Signature */
+#define DWC_OTG_PCD_INTR_SIGNATURE			'D','W','C','_','O','T','G','_','P','C','D','_','I','N','T','R','_'
+#define DWC_OTG_PCD_INTR_VERSION			'V','2','.','0','0','1'
+static const unsigned char DWC_OTG_PCD_INTR_C_Version[] =
+    {SIGBYAHONG, DWC_OTG_PCD_INTR_SIGNATURE, SIGN_OS ,SIGN_CHIPSET, DWC_OTG_PCD_INTR_VERSION, 0};
+
+
+const unsigned char* dwc_otg_pcd_intr_get_version(void)
+{
+	return DWC_OTG_PCD_INTR_C_Version;
+}
+
+
+#define DEBUG_EP0
+
+/* request functions defined in "dwc_otg_pcd.c" */
+extern void request_done( dwc_otg_pcd_ep_t *_ep, dwc_otg_pcd_request_t *_req,
+                          int _status);
+extern void request_nuke( dwc_otg_pcd_ep_t *_ep );
+extern void dwc_otg_pcd_update_otg( dwc_otg_pcd_t *_pcd,
+                                    const unsigned _reset );
+
+/** @file
+ * This file contains the implementation of the PCD Interrupt handlers.
+ *
+ * The PCD handles the device interrupts.  Many conditions can cause a
+ * device interrupt. When an interrupt occurs, the device interrupt
+ * service routine determines the cause of the interrupt and
+ * dispatches handling to the appropriate function. These interrupt
+ * handling functions are described below.
+ * All interrupt registers are processed from LSB to MSB.
+ */
+
+
+/**
+ * This function prints the ep0 state for debug purposes.
+ */
+static inline void print_ep0_state( dwc_otg_pcd_t *_pcd )
+{
+#ifdef DEBUG
+	char str[40];
+
+	switch (_pcd->ep0state)
+	{
+	case EP0_DISCONNECT:
+		strcpy(str, "EP0_DISCONNECT");
+		break;
+	case EP0_IDLE:
+		strcpy(str, "EP0_IDLE");
+		break;
+	case EP0_IN_DATA_PHASE:
+		strcpy(str, "EP0_IN_DATA_PHASE");
+		break;
+	case EP0_OUT_DATA_PHASE:
+		strcpy(str, "EP0_OUT_DATA_PHASE");
+		break;
+	case EP0_STATUS:
+		strcpy(str,"EP0_STATUS");
+		break;
+	case EP0_STALL:
+		strcpy(str,"EP0_STALL");
+		break;
+	default:
+		strcpy(str,"EP0_INVALID");
+	}
+
+	DWC_DEBUGPL(DBG_ANY, "%s(%d)\n", str, _pcd->ep0state);
+#endif
+}
+
+/**
+ * This function returns pointer to in ep struct with number ep_num
+ */
+static inline dwc_otg_pcd_ep_t* get_in_ep( dwc_otg_pcd_t *_pcd, uint32_t ep_num)
+{
+	int i;
+	int num_in_eps = GET_CORE_IF(_pcd)->dev_if->num_in_eps;
+	if (ep_num == 0)
+	{
+		return &_pcd->ep0;
+	}
+	else
+	{
+		for (i = 0; i < num_in_eps; ++i)
+		{
+			if (_pcd->in_ep[i].dwc_ep.num == ep_num)
+				return &_pcd->in_ep[i];
+		}
+		return 0;
+	}
+}
+/**
+ * This function returns pointer to out ep struct with number ep_num
+ */
+static inline dwc_otg_pcd_ep_t* get_out_ep( dwc_otg_pcd_t *_pcd, uint32_t ep_num)
+{
+	int i;
+	int num_out_eps = GET_CORE_IF(_pcd)->dev_if->num_out_eps;
+	if (ep_num == 0)
+	{
+		return &_pcd->ep0;
+	}
+	else
+	{
+		for (i = 0; i < num_out_eps; ++i)
+		{
+			if (_pcd->out_ep[i].dwc_ep.num == ep_num)
+				return &_pcd->out_ep[i];
+		}
+		return 0;
+	}
+}
+/**
+ * This functions gets a pointer to an EP from the wIndex address
+ * value of the control request.
+ */
+static dwc_otg_pcd_ep_t *get_ep_by_addr (dwc_otg_pcd_t *_pcd, u16 _wIndex)
+{
+	dwc_otg_pcd_ep_t	*ep;
+
+	if ((_wIndex & USB_ENDPOINT_NUMBER_MASK) == 0)
+		return &_pcd->ep0;
+	list_for_each_entry( ep, &_pcd->gadget.ep_list, ep.ep_list)
+	{
+		u8	bEndpointAddress;
+
+		if (!ep->desc)
+			continue;
+		bEndpointAddress = ep->desc->bEndpointAddress;
+		if ((_wIndex ^ bEndpointAddress) & USB_DIR_IN)
+			continue;
+		if ((_wIndex & 0x0f) == (bEndpointAddress & 0x0f))
+			return ep;
+	}
+	return NULL;
+}
+
+/**
+ * This function checks the EP request queue, if the queue is not
+ * empty the next request is started.
+ */
+void start_next_request( dwc_otg_pcd_ep_t *_ep )
+{
+	dwc_otg_pcd_request_t *req = 0;
+
+	if (!list_empty(&_ep->queue))
+	{
+		req = list_entry(_ep->queue.next,
+		                 dwc_otg_pcd_request_t, queue);
+
+		/* Setup and start the Transfer */
+		_ep->dwc_ep.start_xfer_buff = req->req.buf;
+		_ep->dwc_ep.xfer_buff = req->req.buf;
+		_ep->dwc_ep.xfer_len = req->req.length;
+		_ep->dwc_ep.xfer_count = 0;
+		_ep->dwc_ep.dma_addr = req->req.dma;
+		_ep->dwc_ep.sent_zlp = 0;
+		_ep->dwc_ep.total_len = _ep->dwc_ep.xfer_len;
+
+		//DWC_ERROR(" -> starting transfer (start_next_req) %s %s\n",
+		//_ep->ep.name, _ep->dwc_ep.is_in?"IN":"OUT");
+
+		dwc_otg_ep_start_transfer( GET_CORE_IF(_ep->pcd), &_ep->dwc_ep );
+	}
+}
+
+/**
+ * This function handles the SOF Interrupts. At this time the SOF
+ * Interrupt is disabled.
+ */
+int32_t dwc_otg_pcd_handle_sof_intr(dwc_otg_pcd_t *_pcd)
+{
+	dwc_otg_core_if_t *core_if = GET_CORE_IF(_pcd);
+
+	gintsts_data_t gintsts;
+
+	//DWC_DEBUGPL(DBG_PCD, "SOF\n");
+
+	/* Clear interrupt */
+	gintsts.d32 = 0;
+	gintsts.b.sofintr = 1;
+	dwc_write_reg32 (&core_if->core_global_regs->gintsts, gintsts.d32);
+
+	return 1;
+}
+
+
+/**
+ * This function handles the Rx Status Queue Level Interrupt, which
+ * indicates that there is a least one packet in the Rx FIFO.  The
+ * packets are moved from the FIFO to memory, where they will be
+ * processed when the Endpoint Interrupt Register indicates Transfer
+ * Complete or SETUP Phase Done.
+ *
+ * Repeat the following until the Rx Status Queue is empty:
+ *	 -# Read the Receive Status Pop Register (GRXSTSP) to get Packet
+ *		info
+ *	 -# If Receive FIFO is empty then skip to step Clear the interrupt
+ *		and exit
+ *	 -# If SETUP Packet call dwc_otg_read_setup_packet to copy the
+ *		SETUP data to the buffer
+ *	 -# If OUT Data Packet call dwc_otg_read_packet to copy the data
+ *		to the destination buffer
+ */
+int32_t dwc_otg_pcd_handle_rx_status_q_level_intr(dwc_otg_pcd_t *_pcd)
+{
+	dwc_otg_core_if_t *core_if = GET_CORE_IF(_pcd);
+	dwc_otg_core_global_regs_t *global_regs = core_if->core_global_regs;
+	gintmsk_data_t gintmask = {.d32=0};
+	device_grxsts_data_t status;
+	dwc_otg_pcd_ep_t *ep;
+	gintsts_data_t gintsts;
+#ifdef DEBUG
+	static char *dpid_str[] ={ "D0", "D2", "D1", "MDATA" };
+#endif
+
+	//DWC_DEBUGPL(DBG_PCDV, "%s(%p)\n", __func__, _pcd);
+	/* Disable the Rx Status Queue Level interrupt */
+	gintmask.b.rxstsqlvl= 1;
+	dwc_modify_reg32( &global_regs->gintmsk, gintmask.d32, 0);
+
+	/* Get the Status from the top of the FIFO */
+	status.d32 = dwc_read_reg32( &global_regs->grxstsp );
+
+	DWC_DEBUGPL(DBG_PCD, "EP:%d BCnt:%d DPID:%s "
+	            "pktsts:%x Frame:%d(0x%0x)\n",
+	            status.b.epnum, status.b.bcnt,
+	            dpid_str[status.b.dpid],
+	            status.b.pktsts, status.b.fn, status.b.fn);
+	/* Get pointer to EP structure */
+	ep = get_out_ep(_pcd, status.b.epnum);
+//	  ep = &_pcd->out_ep[ status.b.epnum - 1];
+
+	switch (status.b.pktsts)
+	{
+	case DWC_DSTS_GOUT_NAK:
+		DWC_DEBUGPL(DBG_PCDV, "Global OUT NAK\n");
+		break;
+	case DWC_STS_DATA_UPDT:
+		DWC_DEBUGPL(DBG_PCDV, "OUT Data Packet\n");
+		if (status.b.bcnt && ep->dwc_ep.xfer_buff)
+		{
+			/** @todo NGS Check for buffer overflow? */
+			dwc_otg_read_packet( core_if,
+			                     ep->dwc_ep.xfer_buff,
+			                     status.b.bcnt);
+			ep->dwc_ep.xfer_count += status.b.bcnt;
+			ep->dwc_ep.xfer_buff += status.b.bcnt;
+		}
+		break;
+	case DWC_STS_XFER_COMP:
+		DWC_DEBUGPL(DBG_PCDV, "OUT Complete\n");
+		break;
+	case DWC_DSTS_SETUP_COMP:
+#ifdef DEBUG_EP0
+		DWC_DEBUGPL(DBG_PCDV, "Setup Complete\n");
+#endif
+		break;
+	case DWC_DSTS_SETUP_UPDT:
+		dwc_otg_read_setup_packet( core_if, _pcd->setup_pkt->d32);
+#ifdef DEBUG_EP0
+		DWC_DEBUGPL(DBG_PCD,
+		            "SETUP PKT: %02x.%02x v%04x i%04x l%04x\n",
+		            _pcd->setup_pkt->req.bRequestType,
+		            _pcd->setup_pkt->req.bRequest,
+		            _pcd->setup_pkt->req.wValue,
+		            _pcd->setup_pkt->req.wIndex,
+		            _pcd->setup_pkt->req.wLength);
+#endif
+		ep->dwc_ep.xfer_count += status.b.bcnt;
+		break;
+	default:
+		DWC_DEBUGPL(DBG_PCDV, "Invalid Packet Status (0x%0x)\n",
+		            status.b.pktsts);
+		break;
+	}
+
+	/* Enable the Rx Status Queue Level interrupt */
+	dwc_modify_reg32( &global_regs->gintmsk, 0, gintmask.d32);
+	/* Clear interrupt */
+	gintsts.d32 = 0;
+	gintsts.b.rxstsqlvl = 1;
+	dwc_write_reg32 (&global_regs->gintsts, gintsts.d32);
+
+	//DWC_DEBUGPL(DBG_PCDV, "EXIT: %s\n", __func__);
+	return 1;
+}
+/**
+ * This function examines the Device IN Token Learning Queue to
+ * determine the EP number of the last IN token received.  This
+ * implementation is for the Mass Storage device where there are only
+ * 2 IN EPs (Control-IN and BULK-IN).
+ *
+ * The EP numbers for the first six IN Tokens are in DTKNQR1 and there
+ * are 8 EP Numbers in each of the other possible DTKNQ Registers.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ *
+ */
+static inline int get_ep_of_last_in_token(dwc_otg_core_if_t *_core_if)
+{
+	dwc_otg_device_global_regs_t *dev_global_regs =
+	    _core_if->dev_if->dev_global_regs;
+	const uint32_t TOKEN_Q_DEPTH = _core_if->hwcfg2.b.dev_token_q_depth;
+	/* Number of Token Queue Registers */
+	const int DTKNQ_REG_CNT = (TOKEN_Q_DEPTH + 7) / 8;
+	dtknq1_data_t dtknqr1;
+	uint32_t in_tkn_epnums[4];
+	int ndx = 0;
+	int i = 0;
+	volatile uint32_t *addr = &dev_global_regs->dtknqr1;
+	int epnum = 0;
+
+	//DWC_DEBUGPL(DBG_PCD,"dev_token_q_depth=%d\n",TOKEN_Q_DEPTH);
+
+
+	/* Read the DTKNQ Registers */
+	for (i = 0; i < DTKNQ_REG_CNT; i++)
+	{
+		in_tkn_epnums[ i ] = dwc_read_reg32(addr);
+		DWC_DEBUGPL(DBG_PCDV, "DTKNQR%d=0x%08x\n", i+1,
+		            in_tkn_epnums[i]);
+		if (addr == &dev_global_regs->dvbusdis)
+		{
+			addr = &dev_global_regs->dtknqr3_dthrctl;
+		}
+		else
+		{
+			++addr;
+		}
+
+	}
+
+	/* Copy the DTKNQR1 data to the bit field. */
+	dtknqr1.d32 = in_tkn_epnums[0];
+	/* Get the EP numbers */
+	in_tkn_epnums[0] = dtknqr1.b.epnums0_5;
+	ndx = dtknqr1.b.intknwptr - 1;
+
+	//DWC_DEBUGPL(DBG_PCDV,"ndx=%d\n",ndx);
+	if (ndx == -1)
+	{
+		/** @todo Find a simpler way to calculate the max
+		 * queue position.*/
+		int cnt = TOKEN_Q_DEPTH;
+		if (TOKEN_Q_DEPTH <= 6)
+		{
+			cnt = TOKEN_Q_DEPTH - 1;
+		}
+		else if (TOKEN_Q_DEPTH <= 14)
+		{
+			cnt = TOKEN_Q_DEPTH - 7;
+		}
+		else if (TOKEN_Q_DEPTH <= 22)
+		{
+			cnt = TOKEN_Q_DEPTH - 15;
+		}
+		else
+		{
+			cnt = TOKEN_Q_DEPTH - 23;
+		}
+		epnum = (in_tkn_epnums[ DTKNQ_REG_CNT - 1 ] >> (cnt * 4)) & 0xF;
+	}
+	else
+	{
+		if (ndx <= 5)
+		{
+			epnum = (in_tkn_epnums[0] >> (ndx * 4)) & 0xF;
+		}
+		else if (ndx <= 13 )
+		{
+			ndx -= 6;
+			epnum = (in_tkn_epnums[1] >> (ndx * 4)) & 0xF;
+		}
+		else if (ndx <= 21 )
+		{
+			ndx -= 14;
+			epnum = (in_tkn_epnums[2] >> (ndx * 4)) & 0xF;
+		}
+		else if (ndx <= 29 )
+		{
+			ndx -= 22;
+			epnum = (in_tkn_epnums[3] >> (ndx * 4)) & 0xF;
+		}
+	}
+	//DWC_DEBUGPL(DBG_PCD,"epnum=%d\n",epnum);
+	return epnum;
+}
+
+/**
+ * This interrupt occurs when the non-periodic Tx FIFO is half-empty.
+ * The active request is checked for the next packet to be loaded into
+ * the non-periodic Tx FIFO.
+ */
+//int32_t dwc_otg_pcd_handle_np_tx_fifo_empty_intr(dwc_otg_pcd_t *_pcd)
+//{
+//	dwc_otg_core_if_t *core_if = GET_CORE_IF(_pcd);
+//	dwc_otg_core_global_regs_t *global_regs =
+//			core_if->core_global_regs;
+//	dwc_otg_dev_in_ep_regs_t *ep_regs;
+//	gnptxsts_data_t txstatus = {.d32 = 0};
+//	gintsts_data_t gintsts;
+//
+//	int epnum = 0;
+//	dwc_otg_pcd_ep_t *ep = 0;
+//	uint32_t len = 0;
+//	int dwords;
+//
+//	/* Get the epnum from the IN Token Learning Queue. */
+//	epnum = get_ep_of_last_in_token(core_if);
+//	ep = get_in_ep(_pcd, epnum);
+///*
+//	if(epnum != 0)
+//		ep = &_pcd->in_ep[epnum-1];
+//	else
+//		ep = &_pcd->ep0;
+//*/
+//        DWC_DEBUGPL(DBG_PCD, "NP TxFifo Empty: %s(%d) \n", ep->ep.name, epnum );
+//
+//	ep_regs = core_if->dev_if->in_ep_regs[epnum];
+//
+//	len = ep->dwc_ep.xfer_len - ep->dwc_ep.xfer_count;
+//	if (len > ep->dwc_ep.maxpacket)
+//	{
+//		len = ep->dwc_ep.maxpacket;
+//	}
+//	dwords = (len + 3)/4;
+//
+//
+//	/* While there is space in the queue and space in the FIFO and
+//	* More data to tranfer, Write packets to the Tx FIFO */
+//	txstatus.d32 = dwc_read_reg32( &global_regs->gnptxsts );
+//	DWC_DEBUGPL(DBG_PCDV, "b4 GNPTXSTS=0x%08x\n",txstatus.d32);
+//
+//	while  (txstatus.b.nptxqspcavail > 0 &&
+//				txstatus.b.nptxfspcavail >= dwords &&
+//				ep->dwc_ep.xfer_count < ep->dwc_ep.xfer_len)
+//	{
+//		/* Write the FIFO */
+//		dwc_otg_ep_write_packet( core_if, &ep->dwc_ep, 0 );
+//		len = ep->dwc_ep.xfer_len - ep->dwc_ep.xfer_count;
+//
+//		if (len > ep->dwc_ep.maxpacket)
+//		{
+//			len = ep->dwc_ep.maxpacket;
+//		}
+//
+//		dwords = (len + 3)/4;
+//		txstatus.d32 = dwc_read_reg32(&global_regs->gnptxsts);
+//		DWC_DEBUGPL(DBG_PCDV,"GNPTXSTS=0x%08x\n",txstatus.d32);
+//	}
+//
+//	DWC_DEBUGPL(DBG_PCDV, "GNPTXSTS=0x%08x\n",
+//					dwc_read_reg32( &global_regs->gnptxsts));
+//
+//	/* Clear interrupt */
+//	gintsts.d32 = 0;
+//	gintsts.b.nptxfempty = 1;
+//	dwc_write_reg32 (&global_regs->gintsts, gintsts.d32);
+//
+//	return 1;
+//}
+
+/**
+ * This function is called when dedicated Tx FIFO Empty interrupt occurs.
+ * The active request is checked for the next packet to be loaded into
+ * apropriate Tx FIFO.
+ */
+static int32_t write_empty_tx_fifo(dwc_otg_pcd_t *_pcd, uint32_t epnum)
+{
+	dwc_otg_core_if_t *core_if = GET_CORE_IF(_pcd);
+	dwc_otg_dev_if_t* dev_if = core_if->dev_if;
+	//dwc_otg_dev_in_ep_regs_t *ep_regs;
+	dtxfsts_data_t txstatus = {.d32 = 0};
+	dwc_otg_pcd_ep_t *ep = 0;
+	uint32_t len = 0;
+	int dwords;
+
+	ep = get_in_ep(_pcd, epnum);
+	/*
+		if(epnum != 0)
+			ep = &_pcd->in_ep[epnum-1];
+		else
+			ep = &_pcd->ep0;
+	*/
+	DWC_DEBUGPL(DBG_PCD, "Dedicated TxFifo Empty: %s(%d) \n", ep->ep.name, epnum );
+
+	if ( ep->dwc_ep.xfer_count >= ep->dwc_ep.xfer_len )	//AlenOh
+	{
+		DWC_DEBUGPL(DBG_PCD, "There are no data for write to TxFifo\n");
+		return 0;
+	}
+
+	//ep_regs = core_if->dev_if->in_ep_regs[epnum];
+
+	len = ep->dwc_ep.xfer_len - ep->dwc_ep.xfer_count;
+
+	if (len > ep->dwc_ep.maxpacket)
+	{
+		len = ep->dwc_ep.maxpacket;
+	}
+
+	dwords = (len + 3)/4;
+
+	/* While there is space in the queue and space in the FIFO and
+	 * More data to tranfer, Write packets to the Tx FIFO */
+	txstatus.d32 = dwc_read_reg32( &dev_if->in_ep_regs[epnum]->dtxfsts);
+	DWC_DEBUGPL(DBG_PCDV, "b4 dtxfsts[%d]=0x%08x\n",epnum,txstatus.d32);
+
+	while  (txstatus.b.txfspcavail >= dwords &&
+	        ep->dwc_ep.xfer_count < ep->dwc_ep.xfer_len &&
+	        ep->dwc_ep.xfer_len != 0)
+	{
+		/* Write the FIFO */
+		dwc_otg_ep_write_packet( core_if, &ep->dwc_ep, 0);
+
+		len = ep->dwc_ep.xfer_len - ep->dwc_ep.xfer_count;
+		if (len > ep->dwc_ep.maxpacket)
+		{
+			len = ep->dwc_ep.maxpacket;
+		}
+
+		dwords = (len + 3)/4;
+		txstatus.d32 = dwc_read_reg32(&dev_if->in_ep_regs[epnum]->dtxfsts);
+		DWC_DEBUGPL(DBG_PCDV,"dtxfsts[%d]=0x%08x\n", epnum, txstatus.d32);
+	}
+
+	DWC_DEBUGPL(DBG_PCDV, "b4 dtxfsts[%d]=0x%08x\n",epnum,dwc_read_reg32(&dev_if->in_ep_regs[epnum]->dtxfsts));
+
+	return 1;
+}
+
+
+/**
+ * This function is called when the Device is disconnected.	 It stops
+ * any active requests and informs the Gadget driver of the
+ * disconnect.
+ */
+void dwc_otg_pcd_stop(dwc_otg_pcd_t *_pcd)
+{
+	int i, num_in_eps, num_out_eps;
+	dwc_otg_pcd_ep_t *ep;
+
+	//gintmsk_data_t intr_mask = {.d32 = 0};
+
+	num_in_eps = GET_CORE_IF(_pcd)->dev_if->num_in_eps;
+	num_out_eps = GET_CORE_IF(_pcd)->dev_if->num_out_eps;
+
+	DWC_DEBUGPL(DBG_PCDV, "%s() \n", __func__ );
+	/* don't disconnect drivers more than once */
+	if (_pcd->ep0state == EP0_DISCONNECT)
+	{
+		DWC_DEBUGPL(DBG_ANY, "%s() Already Disconnected\n", __func__ );
+		return;
+	}
+	_pcd->ep0state = EP0_DISCONNECT;
+
+	/* Reset the OTG state. */
+	dwc_otg_pcd_update_otg( _pcd, 1);
+
+	/* Disable the NP Tx Fifo Empty Interrupt. */
+	//intr_mask.b.nptxfempty = 1;
+	//dwc_modify_reg32(&GET_CORE_IF(_pcd)->core_global_regs->gintmsk,
+	//				 intr_mask.d32, 0);
+
+	/* Flush the FIFOs */
+	/**@todo NGS Flush Periodic FIFOs */
+	dwc_otg_flush_tx_fifo( GET_CORE_IF(_pcd), 0x10); //AlenOh all Tx FIFOs
+	dwc_otg_flush_rx_fifo( GET_CORE_IF(_pcd) );
+
+	/* prevent new request submissions, kill any outstanding requests  */
+	ep = &_pcd->ep0;
+	request_nuke(ep);
+	/* prevent new request submissions, kill any outstanding requests  */
+	for (i = 0; i < num_in_eps; i++)
+	{
+		dwc_otg_pcd_ep_t *ep = &_pcd->in_ep[i];
+		request_nuke(ep);
+	}
+	/* prevent new request submissions, kill any outstanding requests  */
+	for (i = 0; i < num_out_eps; i++)
+	{
+		dwc_otg_pcd_ep_t *ep = &_pcd->out_ep[i];
+		request_nuke(ep);
+	}
+
+	/* report disconnect; the driver is already quiesced */
+	if (_pcd->driver && _pcd->driver->disconnect)
+	{
+		SPIN_UNLOCK(&_pcd->lock);
+		_pcd->driver->disconnect(&_pcd->gadget);
+		SPIN_LOCK(&_pcd->lock);
+	}
+}
+
+/**
+ * This interrupt indicates that ...
+ */
+int32_t dwc_otg_pcd_handle_i2c_intr(dwc_otg_pcd_t *_pcd)
+{
+	gintmsk_data_t intr_mask = { .d32 = 0};
+	gintsts_data_t gintsts;
+
+	DWC_PRINT("INTERRUPT Handler not implemented for %s\n", "i2cintr");
+	intr_mask.b.i2cintr = 1;
+	dwc_modify_reg32( &GET_CORE_IF(_pcd)->core_global_regs->gintmsk,
+	                  intr_mask.d32, 0 );
+
+	/* Clear interrupt */
+	gintsts.d32 = 0;
+	gintsts.b.i2cintr = 1;
+	dwc_write_reg32 (&GET_CORE_IF(_pcd)->core_global_regs->gintsts,
+	                 gintsts.d32);
+	return 1;
+}
+
+
+/**
+ * This interrupt indicates that ...
+ */
+int32_t dwc_otg_pcd_handle_early_suspend_intr(dwc_otg_pcd_t *_pcd)
+{
+	gintsts_data_t gintsts;
+#if defined(VERBOSE)
+	DWC_PRINT("Early Suspend Detected\n");
+#endif
+	/* Clear interrupt */
+	gintsts.d32 = 0;
+	gintsts.b.erlysuspend = 1;
+	dwc_write_reg32( &GET_CORE_IF(_pcd)->core_global_regs->gintsts,
+	                 gintsts.d32);
+	return 1;
+}
+
+/**
+ * This function configures EPO to receive SETUP packets.
+ *
+ * @todo NGS: Update the comments from the HW FS.
+ *
+ *	-# Program the following fields in the endpoint specific registers
+ *	for Control OUT EP 0, in order to receive a setup packet
+ *	- DOEPTSIZ0.Packet Count = 3 (To receive up to 3 back to back
+ *	  setup packets)
+ *	- DOEPTSIZE0.Transfer Size = 24 Bytes (To receive up to 3 back
+ *	  to back setup packets)
+ *		- In DMA mode, DOEPDMA0 Register with a memory address to
+ *		  store any setup packets received
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ * @param _pcd	  Programming view of the PCD.
+ */
+static inline void ep0_out_start( dwc_otg_core_if_t *_core_if, dwc_otg_pcd_t *_pcd )
+{
+	dwc_otg_dev_if_t *dev_if = _core_if->dev_if;
+	deptsiz0_data_t doeptsize0 = { .d32 = 0};
+
+#ifdef VERBOSE
+	DWC_DEBUGPL(DBG_PCDV,"%s() doepctl0=%0x\n", __func__,
+	            dwc_read_reg32(&dev_if->out_ep_regs[0]->doepctl));
+#endif
+
+	doeptsize0.b.supcnt = 3;
+	doeptsize0.b.pktcnt = 1;
+	doeptsize0.b.xfersize = 8*3;
+
+	dwc_write_reg32( &dev_if->out_ep_regs[0]->doeptsiz,
+	                 doeptsize0.d32 );
+
+	if (_core_if->dma_enable)
+	{
+		depctl_data_t doepctl = { .d32 = 0 };
+		/** @todo dma needs to handle multiple setup packets (up to 3) */
+		dwc_write_reg32(&dev_if->out_ep_regs[0]->doepdma,
+		                _pcd->setup_pkt_dma_handle);
+		// EP enable
+		doepctl.d32 = dwc_read_reg32(&dev_if->out_ep_regs[0]->doepctl);
+		doepctl.b.epena = 1;
+
+		doepctl.d32 = 0x80008000;
+		dwc_write_reg32(&dev_if->out_ep_regs[0]->doepctl,
+		                doepctl.d32);
+	}
+#ifdef VERBOSE
+	DWC_DEBUGPL(DBG_PCDV,"doepctl0=%0x\n",
+	            dwc_read_reg32(&dev_if->out_ep_regs[0]->doepctl));
+	DWC_DEBUGPL(DBG_PCDV,"diepctl0=%0x\n",
+	            dwc_read_reg32(&dev_if->in_ep_regs[0]->diepctl));
+#endif
+
+}
+
+
+/**
+ * This interrupt occurs when a USB Reset is detected.	When the USB
+ * Reset Interrupt occurs the device state is set to DEFAULT and the
+ * EP0 state is set to IDLE.
+ *	-#	Set the NAK bit for all OUT endpoints (DOEPCTLn.SNAK = 1)
+ *	-#	Unmask the following interrupt bits
+ *		- DAINTMSK.INEP0 = 1 (Control 0 IN endpoint)
+ *	- DAINTMSK.OUTEP0 = 1 (Control 0 OUT endpoint)
+ *	- DOEPMSK.SETUP = 1
+ *	- DOEPMSK.XferCompl = 1
+ *	- DIEPMSK.XferCompl = 1
+ *	- DIEPMSK.TimeOut = 1
+ *	-# Program the following fields in the endpoint specific registers
+ *	for Control OUT EP 0, in order to receive a setup packet
+ *	- DOEPTSIZ0.Packet Count = 3 (To receive up to 3 back to back
+ *	  setup packets)
+ *	- DOEPTSIZE0.Transfer Size = 24 Bytes (To receive up to 3 back
+ *	  to back setup packets)
+ *		- In DMA mode, DOEPDMA0 Register with a memory address to
+ *		  store any setup packets received
+ * At this point, all the required initialization, except for enabling
+ * the control 0 OUT endpoint is done, for receiving SETUP packets.
+ */
+int32_t dwc_otg_pcd_handle_usb_reset_intr( dwc_otg_pcd_t * _pcd)
+{
+	dwc_otg_core_if_t *core_if = GET_CORE_IF(_pcd);
+	dwc_otg_dev_if_t *dev_if = core_if->dev_if;
+	depctl_data_t doepctl = { .d32 = 0};
+	daint_data_t daintmsk = { .d32 = 0};
+	doepmsk_data_t doepmsk = { .d32 = 0};
+	diepmsk_data_t diepmsk = { .d32 = 0};
+	dcfg_data_t dcfg = { .d32=0 };
+	grstctl_t resetctl = { .d32=0 };
+	dctl_data_t dctl = {.d32=0};
+	int i = 0;
+	gintsts_data_t gintsts;
+
+	DWC_PRINT("USB RESET\n");
+
+	/* reset the HNP settings */
+	dwc_otg_pcd_update_otg( _pcd, 1);
+
+	/* Clear the Remote Wakeup Signalling */
+	dctl.b.rmtwkupsig = 1;
+	dwc_modify_reg32( &core_if->dev_if->dev_global_regs->dctl,
+	                  dctl.d32, 0 );
+
+	/* Set NAK for all OUT EPs */
+	doepctl.b.snak = 1;
+	for (i=0; i <= dev_if->num_out_eps; i++)
+	{
+		dwc_write_reg32( &dev_if->out_ep_regs[i]->doepctl,
+		                 doepctl.d32 );
+		//AlenOh
+		dwc_write_reg32( &dev_if->in_ep_regs[i]->diepctl,
+		                 doepctl.d32 );
+	}
+
+	//AlenOh
+	/* Flush the FIFOs */
+	dwc_otg_flush_tx_fifo( core_if, 0x10 ); /* all Tx FIFOs */
+	dwc_otg_flush_rx_fifo( core_if );
+
+	/* Flush the Learning Queue */
+	resetctl.b.intknqflsh = 1;
+	dwc_write_reg32( &core_if->core_global_regs->grstctl, resetctl.d32);
+
+	daintmsk.b.inep0 = 1;
+	daintmsk.b.outep0 = 1;
+	dwc_write_reg32( &dev_if->dev_global_regs->daintmsk, daintmsk.d32 );
+
+	doepmsk.b.setup = 1;
+	doepmsk.b.xfercompl = 1;
+	doepmsk.b.ahberr = 1;
+	doepmsk.b.epdisabled = 1;
+	dwc_write_reg32( &dev_if->dev_global_regs->doepmsk, doepmsk.d32 );
+
+	diepmsk.b.xfercompl = 1;
+	diepmsk.b.timeout = 1;
+	diepmsk.b.epdisabled = 1;
+	diepmsk.b.ahberr = 1;
+//	diepmsk.b.intknepmis = 1;
+	dwc_write_reg32( &dev_if->dev_global_regs->diepmsk, diepmsk.d32 );
+	/* Reset Device Address */
+	dcfg.d32 = dwc_read_reg32( &dev_if->dev_global_regs->dcfg);
+	dcfg.b.devaddr = 0;
+	dwc_write_reg32( &dev_if->dev_global_regs->dcfg, dcfg.d32);
+
+	/* setup EP0 to receive SETUP packets */
+	ep0_out_start( core_if, _pcd );
+
+	/* Clear interrupt */
+	gintsts.d32 = 0;
+	gintsts.b.usbreset = 1;
+	dwc_write_reg32 (&core_if->core_global_regs->gintsts, gintsts.d32);
+
+	return 1;
+}
+
+/**
+ * Get the device speed from the device status register and convert it
+ * to USB speed constant.
+ *
+ * @param _core_if Programming view of DWC_otg controller.
+ */
+static int get_device_speed( dwc_otg_core_if_t *_core_if )
+{
+	dsts_data_t dsts;
+	enum usb_device_speed speed = USB_SPEED_UNKNOWN;
+	dsts.d32 = dwc_read_reg32(&_core_if->dev_if->dev_global_regs->dsts);
+
+	switch (dsts.b.enumspd)
+	{
+	case DWC_DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ:
+		speed = USB_SPEED_HIGH;
+		break;
+	case DWC_DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ:
+	case DWC_DSTS_ENUMSPD_FS_PHY_48MHZ:
+		speed = USB_SPEED_FULL;
+		break;
+
+	case DWC_DSTS_ENUMSPD_LS_PHY_6MHZ:
+		speed = USB_SPEED_LOW;
+		break;
+	}
+
+	return speed;
+}
+
+/**
+ * Read the device status register and set the device speed in the
+ * data structure.
+ * Set up EP0 to receive SETUP packets by calling dwc_ep0_activate.
+ */
+int32_t dwc_otg_pcd_handle_enum_done_intr(dwc_otg_pcd_t *_pcd)
+{
+	dwc_otg_pcd_ep_t *ep0 = &_pcd->ep0;
+	gintsts_data_t gintsts;
+	gusbcfg_data_t gusbcfg;
+	dwc_otg_core_global_regs_t *global_regs =
+	    GET_CORE_IF(_pcd)->core_global_regs;
+	uint32_t gsnpsid = global_regs->gsnpsid;
+	uint8_t utmi16b, utmi8b;
+	DWC_DEBUGPL(DBG_PCD, "SPEED ENUM\n");
+
+	if (gsnpsid >= (uint32_t)0x4f54260a)
+	{
+		utmi16b = 5;
+		utmi8b = 9;
+	}
+	else
+	{
+		utmi16b = 4;
+		utmi8b = 8;
+	}
+	dwc_otg_ep0_activate( GET_CORE_IF(_pcd), &ep0->dwc_ep );
+
+#ifdef DEBUG_EP0
+	print_ep0_state(_pcd);
+#endif
+
+	if (_pcd->ep0state == EP0_DISCONNECT)
+	{
+		_pcd->ep0state = EP0_IDLE;
+	}
+	else if (_pcd->ep0state == EP0_STALL)
+	{
+		_pcd->ep0state = EP0_IDLE;
+	}
+
+	_pcd->ep0state = EP0_IDLE;
+
+	ep0->stopped = 0;
+
+	_pcd->gadget.speed = get_device_speed(GET_CORE_IF(_pcd));
+
+	/* Set USB turnaround time based on device speed and PHY interface. */
+	gusbcfg.d32 = dwc_read_reg32(&global_regs->gusbcfg);
+	if (_pcd->gadget.speed == USB_SPEED_HIGH)
+	{
+		if (GET_CORE_IF(_pcd)->hwcfg2.b.hs_phy_type == DWC_HWCFG2_HS_PHY_TYPE_ULPI)
+		{
+			/* ULPI interface */
+			gusbcfg.b.usbtrdtim = 9;
+		}
+		if (GET_CORE_IF(_pcd)->hwcfg2.b.hs_phy_type == DWC_HWCFG2_HS_PHY_TYPE_UTMI)
+		{
+/////
+			/* UTMI+ interface */
+			if (GET_CORE_IF(_pcd)->hwcfg4.b.utmi_phy_data_width == 0)
+			{
+				gusbcfg.b.usbtrdtim = utmi8b;
+			}
+			else if (GET_CORE_IF(_pcd)->hwcfg4.b.utmi_phy_data_width == 1)
+			{
+				gusbcfg.b.usbtrdtim = utmi16b;
+			}
+			else if (GET_CORE_IF(_pcd)->core_params->phy_utmi_width == 8)
+			{
+				gusbcfg.b.usbtrdtim = utmi8b;
+			}
+			else
+			{
+				gusbcfg.b.usbtrdtim = utmi16b;
+			}
+		}
+		if (GET_CORE_IF(_pcd)->hwcfg2.b.hs_phy_type == DWC_HWCFG2_HS_PHY_TYPE_UTMI_ULPI)
+		{
+			/* UTMI+  OR  ULPI interface */
+			if (gusbcfg.b.ulpi_utmi_sel == 1)
+			{
+				/* ULPI interface */
+				gusbcfg.b.usbtrdtim = 9;
+			}
+			else
+			{
+				/* UTMI+ interface */
+				if (GET_CORE_IF(_pcd)->core_params->phy_utmi_width == 16)
+				{
+					gusbcfg.b.usbtrdtim = utmi16b;
+				}
+				else
+				{
+					gusbcfg.b.usbtrdtim = utmi8b;
+				}
+			}
+		}
+	}
+	else
+	{
+		/* Full or low speed */
+		gusbcfg.b.usbtrdtim = 9;
+	}
+	dwc_write_reg32(&global_regs->gusbcfg, gusbcfg.d32);
+
+	/* Clear interrupt */
+	gintsts.d32 = 0;
+	gintsts.b.enumdone = 1;
+	dwc_write_reg32( &GET_CORE_IF(_pcd)->core_global_regs->gintsts,
+	                 gintsts.d32 );
+	return 1;
+}
+
+/**
+ * This interrupt indicates that the ISO OUT Packet was dropped due to
+ * Rx FIFO full or Rx Status Queue Full.  If this interrupt occurs
+ * read all the data from the Rx FIFO.
+ */
+int32_t dwc_otg_pcd_handle_isoc_out_packet_dropped_intr(dwc_otg_pcd_t *_pcd )
+{
+	gintmsk_data_t intr_mask = { .d32 = 0};
+	gintsts_data_t gintsts;
+
+	DWC_PRINT("INTERRUPT Handler not implemented for %s\n",
+	          "ISOC Out Dropped");
+
+	intr_mask.b.isooutdrop = 1;
+	dwc_modify_reg32( &GET_CORE_IF(_pcd)->core_global_regs->gintmsk,
+	                  intr_mask.d32, 0 );
+
+	/* Clear interrupt */
+	gintsts.d32 = 0;
+	gintsts.b.isooutdrop = 1;
+	dwc_write_reg32 (&GET_CORE_IF(_pcd)->core_global_regs->gintsts,
+	                 gintsts.d32);
+
+	return 1;
+}
+
+/**
+ * This interrupt indicates the end of the portion of the micro-frame
+ * for periodic transactions.  If there is a periodic transaction for
+ * the next frame, load the packets into the EP periodic Tx FIFO.
+ */
+int32_t dwc_otg_pcd_handle_end_periodic_frame_intr(dwc_otg_pcd_t *_pcd )
+{
+	gintmsk_data_t intr_mask = { .d32 = 0};
+	gintsts_data_t gintsts;
+	DWC_PRINT("INTERRUPT Handler not implemented for %s\n",
+	          "EOP");
+
+	intr_mask.b.eopframe = 1;
+	dwc_modify_reg32( &GET_CORE_IF(_pcd)->core_global_regs->gintmsk,
+	                  intr_mask.d32, 0 );
+
+	/* Clear interrupt */
+	gintsts.d32 = 0;
+	gintsts.b.eopframe = 1;
+	dwc_write_reg32( &GET_CORE_IF(_pcd)->core_global_regs->gintsts,
+	                 gintsts.d32);
+
+	return 1;
+}
+
+/**
+ * This interrupt indicates that EP of the packet on the top of the
+ * non-periodic Tx FIFO does not match EP of the IN Token received.
+ *
+ * The "Device IN Token Queue" Registers are read to determine the
+ * order the IN Tokens have been received.	The non-periodic Tx FIFO
+ * is flushed, so it can be reloaded in the order seen in the IN Token
+ * Queue.
+ */
+int32_t dwc_otg_pcd_handle_ep_mismatch_intr(dwc_otg_core_if_t *_core_if)
+{
+	gintsts_data_t gintsts;
+	DWC_DEBUGPL(DBG_PCDV, "%s(%p)\n", __func__, _core_if);
+
+	/* Clear interrupt */
+	gintsts.d32 = 0;
+	gintsts.b.epmismatch = 1;
+	dwc_write_reg32 (&_core_if->core_global_regs->gintsts, gintsts.d32);
+
+	return 1;
+}
+
+/**
+ * This funcion stalls EP0.
+ */
+static inline void ep0_do_stall( dwc_otg_pcd_t *_pcd, const int err_val )
+{
+	dwc_otg_pcd_ep_t *ep0 = &_pcd->ep0;
+	//struct usb_ctrlrequest	*ctrl = &_pcd->setup_pkt->req;
+	//DWC_WARN("req %02x.%02x protocol STALL; err %d\n",
+	//		 ctrl->bRequestType, ctrl->bRequest, err_val);
+
+	ep0->dwc_ep.is_in = 1;
+	dwc_otg_ep_set_stall( _pcd->otg_dev->core_if, &ep0->dwc_ep );
+	_pcd->ep0.stopped = 1;
+	_pcd->ep0state = EP0_IDLE;
+	ep0_out_start( GET_CORE_IF(_pcd), _pcd );
+}
+
+/**
+ * This functions delegates the setup command to the gadget driver.
+ */
+static inline void do_gadget_setup( dwc_otg_pcd_t *_pcd,
+                                    struct usb_ctrlrequest * _ctrl)
+{
+	int ret = 0;
+	if (_pcd->driver && _pcd->driver->setup)
+	{
+		SPIN_UNLOCK(&_pcd->lock);
+		ret = _pcd->driver->setup(&_pcd->gadget, _ctrl);
+		SPIN_LOCK(&_pcd->lock);
+		if (ret < 0)
+		{
+			ep0_do_stall( _pcd, ret );
+		}
+
+		/** @todo This is a g_file_storage gadget driver specific
+		 * workaround: a DELAYED_STATUS result from the fsg_setup
+		 * routine will result in the gadget queueing a EP0 IN status
+		 * phase for a two-stage control transfer.	Exactly the same as
+		 * a SET_CONFIGURATION/SET_INTERFACE except that this is a class
+		 * specific request.  Need a generic way to know when the gadget
+		 * driver will queue the status phase.	Can we assume when we
+		 * call the gadget driver setup() function that it will always
+		 * queue and require the following flag?  Need to look into
+		 * this.
+		 */
+		/*		if (ret == 256 + 999)
+				{
+					_pcd->request_config = 1;
+				}*/
+	}
+}
+
+/**
+ * This function starts the Zero-Length Packet for the IN status phase
+ * of a 2 stage control transfer.
+ */
+static inline void do_setup_in_status_phase( dwc_otg_pcd_t *_pcd)
+{
+	dwc_otg_pcd_ep_t *ep0 = &_pcd->ep0;
+	if (_pcd->ep0state == EP0_STALL)
+	{
+		return;
+	}
+
+	_pcd->ep0state = EP0_STATUS;
+
+	/* Prepare for more SETUP Packets */
+	DWC_DEBUGPL(DBG_PCD, "EP0 IN ZLP\n");
+	ep0->dwc_ep.xfer_len = 0;
+	ep0->dwc_ep.xfer_count = 0;
+	ep0->dwc_ep.is_in = 1;
+	ep0->dwc_ep.dma_addr = _pcd->setup_pkt_dma_handle;
+
+	dwc_otg_ep0_start_transfer( GET_CORE_IF(_pcd), &ep0->dwc_ep );
+
+	/* Prepare for more SETUP Packets */
+	ep0_out_start( GET_CORE_IF(_pcd), _pcd );
+
+}
+
+/**
+ * This function starts the Zero-Length Packet for the OUT status phase
+ * of a 2 stage control transfer.
+ */
+static inline void do_setup_out_status_phase( dwc_otg_pcd_t *_pcd)
+{
+	dwc_otg_pcd_ep_t *ep0 = &_pcd->ep0;
+	if (_pcd->ep0state == EP0_STALL)
+	{
+		DWC_DEBUGPL(DBG_PCD, "EP0 STALLED\n");
+		return;
+	}
+	_pcd->ep0state = EP0_STATUS;
+
+	/* Prepare for more SETUP Packets */
+	//ep0_out_start( GET_CORE_IF(_pcd), _pcd );
+
+	DWC_DEBUGPL(DBG_PCD, "EP0 OUT ZLP\n");
+	ep0->dwc_ep.xfer_len = 0;
+	ep0->dwc_ep.xfer_count = 0;
+	ep0->dwc_ep.is_in = 0;
+	//ep0->dwc_ep.dma_addr = 0xffffffff;
+	ep0->dwc_ep.dma_addr = _pcd->setup_pkt_dma_handle;
+	dwc_otg_ep0_start_transfer( GET_CORE_IF(_pcd), &ep0->dwc_ep );
+
+	/* Prepare for more SETUP Packets */
+	ep0_out_start( GET_CORE_IF(_pcd), _pcd );
+
+}
+
+/**
+ * Clear the EP halt (STALL) and if pending requests start the
+ * transfer.
+ */
+static inline void pcd_clear_halt( dwc_otg_pcd_t *_pcd, dwc_otg_pcd_ep_t *_ep )
+{
+	if (_ep->dwc_ep.stall_clear_flag == 0)
+		dwc_otg_ep_clear_stall( GET_CORE_IF(_pcd), &_ep->dwc_ep );
+
+	/* Reactive the EP */
+	dwc_otg_ep_activate( GET_CORE_IF(_pcd), &_ep->dwc_ep );
+	if (_ep->stopped)
+	{
+		_ep->stopped = 0;
+		/* If there is a request in the EP queue start it */
+
+		/** @todo FIXME: this causes an EP mismatch in DMA mode.
+		 * epmismatch not yet implemented. */
+
+		/*
+		 * Above fixme is solved by implmenting a tasklet to call the
+		 * start_next_request(), outside of interrupt context at some
+		 * time after the current time, after a clear-halt setup packet.
+		 * Still need to implement ep mismatch in the future if a gadget
+		 * ever uses more than one endpoint at once
+		 */
+		if (GET_CORE_IF(_pcd)->dma_enable)
+		{
+			_ep->queue_sof = 1;
+			tasklet_schedule (_pcd->start_xfer_tasklet);
+		}
+		else
+		{
+#if 0
+			_ep->queue_sof = 1;
+			DWC_ERROR("tasklet schedule\n");
+			tasklet_schedule (_pcd->start_xfer_tasklet);
+			if (GET_CORE_IF(_pcd)->core_params->opt)
+			{
+				start_next_request( _ep );
+			}
+#endif
+		}
+	}
+	/* Start Control Status Phase */
+	do_setup_in_status_phase( _pcd );
+}
+
+/**
+ * This function is called when the SET_FEATURE TEST_MODE Setup packet
+ * is sent from the host.  The Device Control register is written with
+ * the Test Mode bits set to the specified Test Mode.  This is done as
+ * a tasklet so that the "Status" phase of the control transfer
+ * completes before transmitting the TEST packets.
+ *
+ * @todo This has not been tested since the tasklet struct was put
+ * into the PCD struct!
+ *
+ */
+static void do_test_mode( unsigned long _data )
+{
+	dctl_data_t		dctl;
+	dwc_otg_pcd_t *pcd = (dwc_otg_pcd_t *)_data;
+	dwc_otg_core_if_t *core_if = GET_CORE_IF(pcd);
+	int test_mode = pcd->test_mode;
+
+
+//	  DWC_WARN("%s() has not been tested since being rewritten!\n", __func__);
+
+	dctl.d32 = dwc_read_reg32(&core_if->dev_if->dev_global_regs->dctl);
+	switch (test_mode)
+	{
+	case 1: // TEST_J
+		dctl.b.tstctl = 1;
+		break;
+
+	case 2: // TEST_K
+		dctl.b.tstctl = 2;
+		break;
+
+	case 3: // TEST_SE0_NAK
+		dctl.b.tstctl = 3;
+		break;
+
+	case 4: // TEST_PACKET
+		dctl.b.tstctl = 4;
+		break;
+
+	case 5: // TEST_FORCE_ENABLE
+		dctl.b.tstctl = 5;
+		break;
+	}
+	dwc_write_reg32(&core_if->dev_if->dev_global_regs->dctl,
+	                dctl.d32);
+}
+
+
+/**
+ * This function process the SET_FEATURE Setup Commands.
+ */
+static inline void do_set_feature( dwc_otg_pcd_t *_pcd )
+{
+	dwc_otg_core_if_t *core_if = GET_CORE_IF(_pcd);
+	dwc_otg_core_global_regs_t *global_regs =
+	    core_if->core_global_regs;
+	struct usb_ctrlrequest	ctrl = _pcd->setup_pkt->req;
+	dwc_otg_pcd_ep_t	*ep = 0;
+	int32_t otg_cap_param = core_if->core_params->otg_cap;
+	gotgctl_data_t gotgctl = { .d32 = 0 };
+
+	DWC_DEBUGPL(DBG_PCD, "SET_FEATURE:%02x.%02x v%04x i%04x l%04x\n",
+	            ctrl.bRequestType, ctrl.bRequest,
+	            ctrl.wValue, ctrl.wIndex, ctrl.wLength);
+	DWC_DEBUGPL(DBG_PCD,"otg_cap=%d\n", otg_cap_param);
+
+
+	switch (ctrl.bRequestType & USB_RECIP_MASK)
+	{
+	case USB_RECIP_DEVICE:
+		switch (ctrl.wValue)
+		{
+		case USB_DEVICE_REMOTE_WAKEUP:
+			_pcd->remote_wakeup_enable = 1;
+			break;
+
+		case USB_DEVICE_TEST_MODE:
+			/* Setup the Test Mode tasklet to do the Test
+			* Packet generation after the SETUP Status
+			* phase has completed. */
+
+			/** @todo This has not been tested since the
+			* tasklet struct was put into the PCD
+			* struct! */
+			_pcd->test_mode_tasklet.next = 0;
+			_pcd->test_mode_tasklet.state = 0;
+			atomic_set( &_pcd->test_mode_tasklet.count, 0);
+			_pcd->test_mode_tasklet.func = do_test_mode;
+			_pcd->test_mode_tasklet.data = (unsigned long)_pcd;
+			_pcd->test_mode = ctrl.wIndex >> 8;
+			tasklet_schedule(&_pcd->test_mode_tasklet);
+			break;
+
+		case USB_DEVICE_B_HNP_ENABLE:
+			DWC_DEBUGPL(DBG_PCDV, "SET_FEATURE: USB_DEVICE_B_HNP_ENABLE\n");
+
+			/* dev may initiate HNP */
+			if (otg_cap_param == DWC_OTG_CAP_PARAM_HNP_SRP_CAPABLE)
+			{
+				_pcd->b_hnp_enable = 1;
+				dwc_otg_pcd_update_otg( _pcd, 0 );
+				DWC_DEBUGPL(DBG_PCD, "Request B HNP\n");
+				/**@todo Is the gotgctl.devhnpen cleared
+				* by a USB Reset? */
+				gotgctl.b.devhnpen = 1;
+				gotgctl.b.hnpreq = 1;
+				dwc_write_reg32( &global_regs->gotgctl, gotgctl.d32 );
+			}
+			else
+			{
+				ep0_do_stall( _pcd, -EOPNOTSUPP);
+			}
+			break;
+
+		case USB_DEVICE_A_HNP_SUPPORT:
+			/* RH port supports HNP */
+			DWC_DEBUGPL(DBG_PCDV, "SET_FEATURE: USB_DEVICE_A_HNP_SUPPORT\n");
+			if (otg_cap_param == DWC_OTG_CAP_PARAM_HNP_SRP_CAPABLE)
+			{
+				_pcd->a_hnp_support = 1;
+				dwc_otg_pcd_update_otg( _pcd, 0 );
+			}
+			else
+			{
+				ep0_do_stall( _pcd, -EOPNOTSUPP);
+			}
+			break;
+
+		case USB_DEVICE_A_ALT_HNP_SUPPORT:
+			/* other RH port does */
+			DWC_DEBUGPL(DBG_PCDV, "SET_FEATURE: USB_DEVICE_A_ALT_HNP_SUPPORT\n");
+			if (otg_cap_param == DWC_OTG_CAP_PARAM_HNP_SRP_CAPABLE)
+			{
+				_pcd->a_alt_hnp_support = 1;
+				dwc_otg_pcd_update_otg( _pcd, 0 );
+			}
+			else
+			{
+				ep0_do_stall( _pcd, -EOPNOTSUPP);
+			}
+			break;
+
+		default:
+			ep0_do_stall(_pcd, -EOPNOTSUPP);
+			return;
+		}
+		do_setup_in_status_phase( _pcd );
+		break;
+
+	case USB_RECIP_INTERFACE:
+		do_gadget_setup(_pcd, &ctrl );
+		break;
+
+	case USB_RECIP_ENDPOINT:
+		if (ctrl.wValue == USB_ENDPOINT_HALT)
+		{
+			ep = get_ep_by_addr(_pcd, ctrl.wIndex);
+			if (ep == 0)
+			{
+				ep0_do_stall(_pcd, -EOPNOTSUPP);
+				return;
+			}
+			ep->stopped = 1;
+			dwc_otg_ep_set_stall( core_if, &ep->dwc_ep );
+		}
+		do_setup_in_status_phase( _pcd );
+		break;
+	}
+}
+
+/**
+ * This function process the CLEAR_FEATURE Setup Commands.
+ */
+static inline void do_clear_feature( dwc_otg_pcd_t *_pcd )
+{
+	struct usb_ctrlrequest	ctrl = _pcd->setup_pkt->req;
+	dwc_otg_pcd_ep_t	*ep = 0;
+
+
+	DWC_DEBUGPL(DBG_PCD,
+	            "CLEAR_FEATURE:%02x.%02x v%04x i%04x l%04x\n",
+	            ctrl.bRequestType, ctrl.bRequest,
+	            ctrl.wValue, ctrl.wIndex, ctrl.wLength);
+
+	switch (ctrl.bRequestType & USB_RECIP_MASK)
+	{
+	case USB_RECIP_DEVICE:
+		switch (ctrl.wValue)
+		{
+		case USB_DEVICE_REMOTE_WAKEUP:
+			_pcd->remote_wakeup_enable = 0;
+			break;
+
+		case USB_DEVICE_TEST_MODE:
+			/** @todo Add CLEAR_FEATURE for TEST modes. */
+			break;
+		}
+		do_setup_in_status_phase( _pcd );
+		break;
+
+	case USB_RECIP_ENDPOINT:
+		ep = get_ep_by_addr(_pcd, ctrl.wIndex);
+		if (ep == 0)
+		{
+			ep0_do_stall(_pcd, -EOPNOTSUPP);
+			return;
+		}
+
+		pcd_clear_halt(_pcd, ep );
+
+		break;
+	}
+}
+
+/**
+ *	This function processes SETUP commands.	 In Linux, the USB Command
+ *	processing is done in two places - the first being the PCD and the
+ *	second in the Gadget Driver (for example, the File-Backed Storage
+ *	Gadget Driver).
+ *
+ * <table>
+ * <tr><td>Command	</td><td>Driver </td><td>Description</td></tr>
+ *
+ * <tr><td>GET_STATUS </td><td>PCD </td><td>Command is processed as
+ * defined in chapter 9 of the USB 2.0 Specification chapter 9
+ * </td></tr>
+ *
+ * <tr><td>CLEAR_FEATURE </td><td>PCD </td><td>The Device and Endpoint
+ * requests are the ENDPOINT_HALT feature is procesed, all others the
+ * interface requests are ignored.</td></tr>
+ *
+ * <tr><td>SET_FEATURE </td><td>PCD </td><td>The Device and Endpoint
+ * requests are processed by the PCD.  Interface requests are passed
+ * to the Gadget Driver.</td></tr>
+ *
+ * <tr><td>SET_ADDRESS </td><td>PCD </td><td>Program the DCFG reg,
+ * with device address received </td></tr>
+ *
+ * <tr><td>GET_DESCRIPTOR </td><td>Gadget Driver </td><td>Return the
+ * requested descriptor</td></tr>
+ *
+ * <tr><td>SET_DESCRIPTOR </td><td>Gadget Driver </td><td>Optional -
+ * not implemented by any of the existing Gadget Drivers.</td></tr>
+ *
+ * <tr><td>SET_CONFIGURATION </td><td>Gadget Driver </td><td>Disable
+ * all EPs and enable EPs for new configuration.</td></tr>
+ *
+ * <tr><td>GET_CONFIGURATION </td><td>Gadget Driver </td><td>Return
+ * the current configuration</td></tr>
+ *
+ * <tr><td>SET_INTERFACE </td><td>Gadget Driver </td><td>Disable all
+ * EPs and enable EPs for new configuration.</td></tr>
+ *
+ * <tr><td>GET_INTERFACE </td><td>Gadget Driver </td><td>Return the
+ * current interface.</td></tr>
+ *
+ * <tr><td>SYNC_FRAME </td><td>PCD </td><td>Display debug
+ * message.</td></tr>
+ * </table>
+ *
+ * When the SETUP Phase Done interrupt occurs, the PCD SETUP commands are
+ * processed by pcd_setup. Calling the Function Driver's setup function from
+ * pcd_setup processes the gadget SETUP commands.
+ */
+static inline void pcd_setup( dwc_otg_pcd_t *_pcd )
+{
+	dwc_otg_core_if_t *core_if = GET_CORE_IF(_pcd);
+	dwc_otg_dev_if_t *dev_if = core_if->dev_if;
+	struct usb_ctrlrequest	ctrl = _pcd->setup_pkt->req;
+	dwc_otg_pcd_ep_t	*ep;
+	dwc_otg_pcd_ep_t	*ep0 = &_pcd->ep0;
+	uint16_t				*status = _pcd->status_buf;
+
+	deptsiz0_data_t doeptsize0 = { .d32 = 0};
+
+#ifdef DEBUG_EP0
+	DWC_DEBUGPL(DBG_PCD, "SETUP %02x.%02x v%04x i%04x l%04x\n",
+	            ctrl.bRequestType, ctrl.bRequest,
+	            ctrl.wValue, ctrl.wIndex, ctrl.wLength);
+#endif
+
+	doeptsize0.d32 = dwc_read_reg32( &dev_if->out_ep_regs[0]->doeptsiz );
+
+	/** @todo handle > 1 setup packet , assert error for now */
+	if (core_if->dma_enable && (doeptsize0.b.supcnt < 2))
+	{
+		DWC_ERROR ("\n\n-----------	 CANNOT handle > 1 setup packet in DMA mode\n\n");
+	}
+
+	/* Clean up the request queue */
+	request_nuke( ep0 );
+	ep0->stopped = 0;
+
+	if (ctrl.bRequestType & USB_DIR_IN)
+	{
+		ep0->dwc_ep.is_in = 1;
+		_pcd->ep0state = EP0_IN_DATA_PHASE;
+	}
+	else
+	{
+		ep0->dwc_ep.is_in = 0;
+		_pcd->ep0state = EP0_OUT_DATA_PHASE;
+	}
+
+	if ( ctrl.wLength == 0 )	//AlenOh
+	{
+		ep0->dwc_ep.is_in = 1;
+		_pcd->ep0state = EP0_STATUS;
+	}
+
+	if ((ctrl.bRequestType & USB_TYPE_MASK) != USB_TYPE_STANDARD)
+	{
+		/* handle non-standard (class/vendor) requests in the gadget driver */
+		do_gadget_setup(_pcd, &ctrl );
+		return;
+	}
+
+	/** @todo NGS: Handle bad setup packet? */
+
+	switch (ctrl.bRequest)
+	{
+	case USB_REQ_GET_STATUS:
+#ifdef DEBUG_EP0
+		DWC_DEBUGPL(DBG_PCD,
+		            "GET_STATUS %02x.%02x v%04x i%04x l%04x\n",
+		            ctrl.bRequestType, ctrl.bRequest,
+		            ctrl.wValue, ctrl.wIndex, ctrl.wLength);
+#endif
+
+		switch (ctrl.bRequestType & USB_RECIP_MASK)
+		{
+		case USB_RECIP_DEVICE:
+			*status = 0x1; /* Self powered */
+			*status |= _pcd->remote_wakeup_enable << 1;
+			break;
+
+		case USB_RECIP_INTERFACE:
+			*status = 0;
+			break;
+
+		case USB_RECIP_ENDPOINT:
+			ep = get_ep_by_addr(_pcd, ctrl.wIndex);
+			if ( ep == 0 || ctrl.wLength > 2)
+			{
+				ep0_do_stall(_pcd, -EOPNOTSUPP);
+				return;
+			}
+			/** @todo check for EP stall */
+			*status = ep->stopped;
+			break;
+		}
+		_pcd->ep0_pending = 1;
+
+		ep0->dwc_ep.start_xfer_buff = (uint8_t *)status;
+		ep0->dwc_ep.xfer_buff = (uint8_t *)status;
+		ep0->dwc_ep.dma_addr = _pcd->status_buf_dma_handle;
+		ep0->dwc_ep.xfer_len = 2;
+		ep0->dwc_ep.xfer_count = 0;
+		ep0->dwc_ep.total_len = ep0->dwc_ep.xfer_len;
+		dwc_otg_ep0_start_transfer( GET_CORE_IF(_pcd), &ep0->dwc_ep );
+		break;
+
+	case USB_REQ_CLEAR_FEATURE:
+		do_clear_feature( _pcd );
+		break;
+
+	case USB_REQ_SET_FEATURE:
+		do_set_feature( _pcd );
+		break;
+
+	case USB_REQ_SET_ADDRESS:
+		if (ctrl.bRequestType == USB_RECIP_DEVICE)
+		{
+			dcfg_data_t dcfg = {.d32=0};
+
+#ifdef DEBUG_EP0
+			DWC_DEBUGPL(DBG_PCDV, "SET_ADDRESS:%d\n", ctrl.wValue);
+#endif
+			dcfg.b.devaddr = ctrl.wValue;
+			dwc_modify_reg32( &dev_if->dev_global_regs->dcfg,
+			                  0, dcfg.d32);
+			do_setup_in_status_phase( _pcd );
+			return;
+		}
+		break;
+
+	case USB_REQ_SET_INTERFACE:
+	case USB_REQ_SET_CONFIGURATION:
+		//_pcd->request_config = 1;	/* Configuration changed */
+		do_gadget_setup(_pcd, &ctrl );
+		break;
+
+	case USB_REQ_SYNCH_FRAME:
+		do_gadget_setup(_pcd, &ctrl );
+		break;
+
+	default:
+		/* Call the Gadget Driver's setup functions */
+		do_gadget_setup(_pcd, &ctrl );
+		break;
+	}
+}
+
+/**
+ * This function completes the ep0 control transfer.
+ */
+static int32_t ep0_complete_request( dwc_otg_pcd_ep_t *_ep )
+{
+	dwc_otg_core_if_t *core_if = GET_CORE_IF(_ep->pcd);
+	dwc_otg_dev_if_t *dev_if = core_if->dev_if;
+	dwc_otg_dev_in_ep_regs_t *in_ep_regs =
+	    dev_if->in_ep_regs[_ep->dwc_ep.num];
+#ifdef DEBUG_EP0
+	dwc_otg_dev_out_ep_regs_t *out_ep_regs =
+	    dev_if->out_ep_regs[_ep->dwc_ep.num];
+#endif
+	deptsiz0_data_t deptsiz;
+	dwc_otg_pcd_request_t *req;
+	int is_last = 0;
+	dwc_otg_pcd_t *pcd = _ep->pcd;
+
+	//DWC_DEBUGPL(DBG_PCDV, "%s() %s\n", __func__, _ep->ep.name);
+
+	if (pcd->ep0_pending && list_empty(&_ep->queue))
+	{
+		if (_ep->dwc_ep.is_in)
+		{
+#ifdef DEBUG_EP0
+			DWC_DEBUGPL(DBG_PCDV, "Do setup OUT status phase\n");
+#endif
+			do_setup_out_status_phase(pcd);
+		}
+		else
+		{
+#ifdef DEBUG_EP0
+			DWC_DEBUGPL(DBG_PCDV, "Do setup IN status phase\n");
+#endif
+			do_setup_in_status_phase(pcd);
+		}
+		pcd->ep0_pending = 0;
+		pcd->ep0state = EP0_STATUS;
+		return 1;
+	}
+
+	if (list_empty(&_ep->queue))
+	{
+		return 0;
+	}
+	req = list_entry(_ep->queue.next, dwc_otg_pcd_request_t, queue);
+
+
+	if (pcd->ep0state == EP0_STATUS)
+	{
+		is_last = 1;
+	}
+	else if ( req->req.zero && (_ep->dwc_ep.xfer_count%_ep->dwc_ep.maxpacket)==0 )
+	{
+		req->req.actual = _ep->dwc_ep.xfer_count;
+		//do_setup_in_status_phase (pcd);
+		req->req.zero = 0;
+		_ep->dwc_ep.xfer_len = 0;
+		_ep->dwc_ep.xfer_count = 0;
+		_ep->dwc_ep.sent_zlp = 1;
+		dwc_otg_ep0_start_transfer( GET_CORE_IF(pcd), &_ep->dwc_ep );
+		return 1;
+	}
+	else if (_ep->dwc_ep.is_in)
+	{
+		deptsiz.d32 = dwc_read_reg32( &in_ep_regs->dieptsiz);
+#ifdef DEBUG_EP0
+		DWC_DEBUGPL(DBG_PCDV, "%s len=%d  xfersize=%d pktcnt=%d\n",
+		            _ep->ep.name, _ep->dwc_ep.xfer_len,
+		            deptsiz.b.xfersize, deptsiz.b.pktcnt);
+#endif
+		if (deptsiz.b.xfersize == 0)
+		{
+			req->req.actual = _ep->dwc_ep.xfer_count;
+			/* Is a Zero Len Packet needed? */
+			//if (req->req.zero) {
+#ifdef DEBUG_EP0
+			DWC_DEBUGPL(DBG_PCD, "Setup Rx ZLP\n");
+#endif
+			do_setup_out_status_phase(pcd);
+		}
+	}
+	else
+	{
+		/* ep0-OUT */
+#ifdef DEBUG_EP0
+		deptsiz.d32 = dwc_read_reg32( &out_ep_regs->doeptsiz);
+		DWC_DEBUGPL(DBG_PCDV, "%s len=%d xsize=%d pktcnt=%d\n",
+		            _ep->ep.name, _ep->dwc_ep.xfer_len,
+		            deptsiz.b.xfersize,
+		            deptsiz.b.pktcnt);
+#endif
+		req->req.actual = _ep->dwc_ep.xfer_count;
+
+		/* Is a Zero Len Packet needed? */
+		//if (req->req.zero) {
+#ifdef DEBUG_EP0
+		DWC_DEBUGPL(DBG_PCDV, "Setup Tx ZLP\n");
+#endif
+		do_setup_in_status_phase(pcd);
+	}
+
+	/* Complete the request */
+	if (is_last)
+	{
+		request_done(_ep, req, 0);
+		_ep->dwc_ep.start_xfer_buff = 0;
+		_ep->dwc_ep.xfer_buff = 0;
+		_ep->dwc_ep.xfer_len = 0;
+		return 1;
+	}
+	return 0;
+}
+
+/**
+ * This function completes the request for the EP.	If there are
+ * additional requests for the EP in the queue they will be started.
+ */
+static void complete_ep( dwc_otg_pcd_ep_t *_ep )
+{
+	dwc_otg_core_if_t *core_if = GET_CORE_IF(_ep->pcd);
+	dwc_otg_dev_if_t *dev_if = core_if->dev_if;
+	dwc_otg_dev_in_ep_regs_t *in_ep_regs =
+	    dev_if->in_ep_regs[_ep->dwc_ep.num];
+	deptsiz_data_t deptsiz;
+	dwc_otg_pcd_request_t *req = 0;
+	int is_last = 0;
+
+	DWC_DEBUGPL(DBG_PCDV,"%s() %s-%s \n", __func__, _ep->ep.name,
+	            (_ep->dwc_ep.is_in?"IN":"OUT"));
+
+	/* Get any pending requests */
+	if (!list_empty(&_ep->queue))
+	{
+		req = list_entry(_ep->queue.next, dwc_otg_pcd_request_t, queue);
+	}
+	else	// AlenOh
+	{
+		printk("no pending request\n");
+		return;
+	}
+	DWC_DEBUGPL(DBG_PCD, "Requests %d\n",_ep->pcd->request_pending);
+
+	if (_ep->dwc_ep.is_in)
+	{
+		deptsiz.d32 = dwc_read_reg32( &in_ep_regs->dieptsiz);
+		if (core_if->dma_enable)
+		{
+			if (deptsiz.b.xfersize == 0)
+				_ep->dwc_ep.xfer_count = _ep->dwc_ep.xfer_len;
+		}
+
+		DWC_DEBUGPL(DBG_PCDV, "%s len=%d  xfersize=%d pktcnt=%d\n",
+		            _ep->ep.name, _ep->dwc_ep.xfer_len,
+		            deptsiz.b.xfersize, deptsiz.b.pktcnt);
+
+		if (deptsiz.b.xfersize == 0 && deptsiz.b.pktcnt == 0 &&
+		        _ep->dwc_ep.xfer_count == _ep->dwc_ep.xfer_len)
+		{
+			is_last = 1;
+		}
+		else
+		{
+			DWC_WARN("Incomplete transfer (%s-%s [siz=%d pkt=%d])\n",
+			         _ep->ep.name, (_ep->dwc_ep.is_in?"IN":"OUT"),
+			         deptsiz.b.xfersize, deptsiz.b.pktcnt);
+		}
+	}
+	else
+	{
+		dwc_otg_dev_out_ep_regs_t *out_ep_regs =
+		    dev_if->out_ep_regs[_ep->dwc_ep.num];
+		deptsiz.d32 = 0;
+		deptsiz.d32 = dwc_read_reg32( &out_ep_regs->doeptsiz);
+
+#ifdef DEBUG
+
+		DWC_DEBUGPL(DBG_PCDV, "addr %p,	 %s len=%d cnt=%d xsize=%d pktcnt=%d\n",
+		            &out_ep_regs->doeptsiz, _ep->ep.name, _ep->dwc_ep.xfer_len,
+		            _ep->dwc_ep.xfer_count,
+		            deptsiz.b.xfersize,
+		            deptsiz.b.pktcnt);
+#endif
+		is_last = 1;
+	}
+
+	/* Complete the request */
+	if (is_last)
+	{
+
+		if (core_if->dma_enable)
+		{
+			req->req.actual = _ep->dwc_ep.xfer_len - deptsiz.b.xfersize;
+		}
+		else
+		{
+			req->req.actual = _ep->dwc_ep.xfer_count;
+		}
+
+		request_done(_ep, req, 0);
+
+		_ep->dwc_ep.start_xfer_buff = 0;
+		_ep->dwc_ep.xfer_buff = 0;
+		_ep->dwc_ep.xfer_len = 0;
+
+		/* If there is a request in the queue start it.*/
+		start_next_request( _ep );
+	}
+}
+
+/**
+ * This function handles EP0 Control transfers.
+ *
+ * The state of the control tranfers are tracked in
+ * <code>ep0state</code>.
+ */
+static void handle_ep0( dwc_otg_pcd_t *_pcd )
+{
+	dwc_otg_core_if_t *core_if = GET_CORE_IF(_pcd);
+	dwc_otg_pcd_ep_t *ep0 = &_pcd->ep0;
+
+#ifdef DEBUG_EP0
+	DWC_DEBUGPL(DBG_PCDV, "%s()\n", __func__);
+	print_ep0_state(_pcd);
+#endif
+
+	switch (_pcd->ep0state)
+	{
+	case EP0_DISCONNECT:
+		break;
+
+	case EP0_IDLE:
+		//_pcd->request_config = 0;
+
+		pcd_setup( _pcd );
+		break;
+
+	case EP0_IN_DATA_PHASE:
+#ifdef DEBUG_EP0
+		DWC_DEBUGPL(DBG_PCD, "DATA_IN EP%d-%s: type=%d, mps=%d\n",
+		            ep0->dwc_ep.num, (ep0->dwc_ep.is_in ?"IN":"OUT"),
+		            ep0->dwc_ep.type, ep0->dwc_ep.maxpacket );
+#endif
+		if (core_if->dma_enable)
+		{
+			/*
+			 * For EP0 we can only program 1 packet at a time so we
+			 * need to do the make calculations after each complete.
+			 * Call write_packet to make the calculations, as in
+			 * slave mode, and use those values to determine if we
+			 * can complete.
+			 */
+			dwc_otg_ep_write_packet (core_if, &ep0->dwc_ep, 1);
+		}
+		if (ep0->dwc_ep.xfer_count < ep0->dwc_ep.total_len)
+		{
+			dwc_otg_ep0_continue_transfer ( GET_CORE_IF(_pcd), &ep0->dwc_ep );
+			DWC_DEBUGPL(DBG_PCD, "CONTINUE TRANSFER\n");
+		}
+		else
+		{
+			ep0_complete_request( ep0 );
+			DWC_DEBUGPL(DBG_PCD, "COMPLETE TRANSFER\n");
+		}
+		break;
+	case EP0_OUT_DATA_PHASE:
+		//#ifdef DEBUG_EP0
+		DWC_DEBUGPL(DBG_PCD, "DATA_OUT EP%d-%s: type=%d, mps=%d\n",
+		            ep0->dwc_ep.num, (ep0->dwc_ep.is_in ?"IN":"OUT"),
+		            ep0->dwc_ep.type, ep0->dwc_ep.maxpacket );
+		//#endif
+		ep0_complete_request( ep0 );
+		break;
+
+
+	case EP0_STATUS:
+		DWC_DEBUGPL(DBG_PCD, "CASE: EP0_STATUS\n");
+		ep0_complete_request( ep0 );
+		_pcd->ep0state = EP0_IDLE;
+		ep0->stopped = 1;
+		ep0->dwc_ep.is_in = 0;	/* OUT for next SETUP */
+
+		/* Prepare for more SETUP Packets */
+		if (core_if->dma_enable)
+		{
+			ep0_out_start( core_if, _pcd );
+		}
+
+		if (!GET_CORE_IF(_pcd)->dma_enable)
+		{
+			int i;
+
+			depctl_data_t diepctl;
+			diepctl.d32 = dwc_read_reg32( &core_if->dev_if->in_ep_regs[0]->diepctl);
+
+			if (_pcd->ep0.queue_sof)
+			{
+				_pcd->ep0.queue_sof = 0;
+				start_next_request (&_pcd->ep0);
+			}
+
+			diepctl.d32 = dwc_read_reg32( &core_if->dev_if->in_ep_regs[0]->diepctl);
+
+			if (_pcd->ep0.queue_sof)
+			{
+				_pcd->ep0.queue_sof = 0;
+				start_next_request (&_pcd->ep0);
+			}
+			for (i=0; i < core_if->dev_if->num_in_eps; i++)
+			{
+				diepctl.d32 = dwc_read_reg32( &core_if->dev_if->in_ep_regs[i+1]->diepctl);
+
+				if (_pcd->in_ep[i].queue_sof)
+				{
+					_pcd->in_ep[i].queue_sof = 0;
+					start_next_request (&_pcd->in_ep[i]);
+				}
+			}
+		}
+		break;
+
+	case EP0_STALL:
+		DWC_ERROR("EP0 STALLed, should not get here pcd_setup()\n");
+		break;
+	}
+#ifdef DEBUG_EP0
+	print_ep0_state(_pcd);
+#endif
+}
+
+/**
+ * Restart transfer
+ */
+static void restart_transfer( dwc_otg_pcd_t *_pcd, const uint32_t _epnum)
+{
+	dwc_otg_core_if_t *core_if = GET_CORE_IF(_pcd);
+	dwc_otg_dev_if_t *dev_if = core_if->dev_if;
+	deptsiz_data_t dieptsiz = {.d32=0};
+	//depctl_data_t diepctl = {.d32=0};
+	dwc_otg_pcd_ep_t *ep;
+
+	dieptsiz.d32 = dwc_read_reg32(&dev_if->in_ep_regs[_epnum]->dieptsiz);
+
+	ep = get_in_ep(_pcd, _epnum);
+	/*
+		if(_epnum != 0)
+			ep = &_pcd->in_ep[ _epnum - 1];
+		else
+			ep = &_pcd->ep0;
+	*/
+	DWC_DEBUGPL(DBG_PCD,"xfer_buff=%p xfer_count=%0x xfer_len=%0x"
+	            " stopped=%d\n", ep->dwc_ep.xfer_buff,
+	            ep->dwc_ep.xfer_count, ep->dwc_ep.xfer_len ,
+	            ep->stopped);
+	/*
+	 * If xfersize is 0 and pktcnt in not 0, resend the last packet.
+	 */
+	if ( dieptsiz.b.pktcnt && dieptsiz.b.xfersize == 0 &&
+	        ep->dwc_ep.start_xfer_buff != 0)
+	{
+		if ( ep->dwc_ep.xfer_len <= ep->dwc_ep.maxpacket )
+		{
+			ep->dwc_ep.xfer_count = 0;
+			ep->dwc_ep.xfer_buff = ep->dwc_ep.start_xfer_buff;
+		}
+		else
+		{
+			ep->dwc_ep.xfer_count -= ep->dwc_ep.maxpacket;
+			/* convert packet size to dwords. */
+			ep->dwc_ep.xfer_buff -= ep->dwc_ep.maxpacket;
+		}
+		ep->stopped = 0;
+		DWC_DEBUGPL(DBG_PCD,"xfer_buff=%p xfer_count=%0x "
+		            "xfer_len=%0x stopped=%d\n",
+		            ep->dwc_ep.xfer_buff,
+		            ep->dwc_ep.xfer_count, ep->dwc_ep.xfer_len ,
+		            ep->stopped
+		           );
+		if (_epnum == 0)
+		{
+			dwc_otg_ep0_start_transfer(core_if, &ep->dwc_ep);
+		}
+		else
+		{
+			dwc_otg_ep_start_transfer(core_if, &ep->dwc_ep);
+		}
+	}
+}
+
+
+/**
+ * handle the IN EP disable interrupt.
+ */
+static inline void handle_in_ep_disable_intr(dwc_otg_pcd_t *_pcd,
+        const uint32_t _epnum)
+{
+	dwc_otg_core_if_t *core_if = GET_CORE_IF(_pcd);
+	dwc_otg_dev_if_t *dev_if = core_if->dev_if;
+	deptsiz_data_t dieptsiz = {.d32=0};
+	dctl_data_t dctl = {.d32=0};
+	dwc_otg_pcd_ep_t *ep;
+	dwc_ep_t *dwc_ep;
+
+	ep = get_in_ep(_pcd, _epnum);
+	dwc_ep = &ep->dwc_ep;
+	/*
+	if(_epnum != 0)
+	{
+		ep = &_pcd->in_ep[ _epnum - 1];
+		dwc_ep = &_pcd->in_ep[ _epnum - 1].dwc_ep;
+	}
+	else
+	{
+		ep = &_pcd->ep0;
+		dwc_ep = &_pcd->ep0.dwc_ep;
+	}
+	*/
+	DWC_DEBUGPL(DBG_PCD,"diepctl%d=%0x\n", _epnum,
+	            dwc_read_reg32(&dev_if->in_ep_regs[_epnum]->diepctl));
+	dieptsiz.d32 = dwc_read_reg32(&dev_if->in_ep_regs[_epnum]->dieptsiz);
+
+	DWC_DEBUGPL(DBG_ANY, "pktcnt=%d size=%d\n",
+	            dieptsiz.b.pktcnt,
+	            dieptsiz.b.xfersize );
+
+	if (ep->stopped)
+	{
+		/* Flush the Tx FIFO */
+		/** @todo NGS: This is not the correct FIFO */
+		if (dwc_ep->type == USB_ENDPOINT_XFER_ISOC) {
+			dwc_otg_flush_tx_fifo( core_if, _epnum );
+		}
+		else
+			dwc_otg_flush_tx_fifo( core_if, _epnum );
+		/* Clear the Global IN NP NAK */
+		dctl.d32 = 0;
+		dctl.b.cgnpinnak = 1;
+		dwc_modify_reg32(&dev_if->dev_global_regs->dctl,
+		                 dctl.d32, 0);
+		/* Restart the transaction */
+		if (dieptsiz.b.pktcnt != 0 ||
+		        dieptsiz.b.xfersize != 0)
+		{
+			restart_transfer( _pcd, _epnum );
+		}
+	}
+	else
+	{
+		/* Restart the transaction */
+		if (dieptsiz.b.pktcnt != 0 ||
+		        dieptsiz.b.xfersize != 0)
+		{
+			restart_transfer( _pcd, _epnum );
+		}
+		DWC_DEBUGPL(DBG_ANY, "STOPPED!!!\n");
+	}
+}
+
+/**
+ * Handler for the IN EP timeout handshake interrupt.
+ */
+static inline void handle_in_ep_timeout_intr(dwc_otg_pcd_t *_pcd,
+        const uint32_t _epnum)
+{
+	dwc_otg_core_if_t *core_if = GET_CORE_IF(_pcd);
+	dwc_otg_dev_if_t *dev_if = core_if->dev_if;
+
+#ifdef DEBUG
+	deptsiz_data_t dieptsiz = {.d32=0};
+	uint32_t epnum = 0;
+#endif
+	dctl_data_t dctl = {.d32=0};
+	dwc_otg_pcd_ep_t *ep;
+
+	gintmsk_data_t intr_mask = {.d32 = 0};
+
+	ep = get_in_ep(_pcd, _epnum);
+	/*
+	if(_epnum != 0)
+		ep = &_pcd->in_ep[ _epnum - 1];
+	else
+		ep = &_pcd->ep0;
+	*/
+
+	/* Disable the NP Tx Fifo Empty Interrrupt */
+	//if (!core_if->dma_enable)
+	//{
+	//	intr_mask.b.nptxfempty = 1;
+	//	dwc_modify_reg32( &core_if->core_global_regs->gintmsk, intr_mask.d32, 0);
+	//}
+	/** @todo NGS Check EP type.
+	 * Implement for Periodic EPs */
+	/*
+	 * Non-periodic EP
+	 */
+	/* Enable the Global IN NAK Effective Interrupt */
+	intr_mask.b.ginnakeff = 1;
+	dwc_modify_reg32( &core_if->core_global_regs->gintmsk,
+	                  0, intr_mask.d32);
+
+	/* Set Global IN NAK */
+	dctl.b.sgnpinnak = 1;
+	dwc_modify_reg32(&dev_if->dev_global_regs->dctl,
+	                 dctl.d32, dctl.d32);
+
+	ep->stopped = 1;
+
+#ifdef DEBUG
+	dieptsiz.d32 = dwc_read_reg32(&dev_if->in_ep_regs[epnum]->dieptsiz);
+	DWC_DEBUGPL(DBG_ANY, "pktcnt=%d size=%d\n",
+	            dieptsiz.b.pktcnt,
+	            dieptsiz.b.xfersize );
+#endif
+
+#ifdef DISABLE_PERIODIC_EP
+	/*
+	 * Set the NAK bit for this EP to
+	 * start the disable process.
+	 */
+	diepctl.d32 = 0;
+	diepctl.b.snak = 1;
+	dwc_modify_reg32(&dev_if->in_ep_regs[epnum]->diepctl, diepctl.d32, diepctl.d32);
+	ep->disabling = 1;
+	ep->stopped = 1;
+#endif
+}
+
+
+/**
+ * This interrupt indicates that an IN EP has a pending Interrupt.
+ * The sequence for handling the IN EP interrupt is shown below:
+ * -#	Read the Device All Endpoint Interrupt register
+ * -#	Repeat the following for each IN EP interrupt bit set (from
+ *		LSB to MSB).
+ * -#	Read the Device Endpoint Interrupt (DIEPINTn) register
+ * -#	If "Transfer Complete" call the request complete function
+ * -#	If "Endpoint Disabled" complete the EP disable procedure.
+ * -#	If "AHB Error Interrupt" log error
+ * -#	If "Time-out Handshake" log error
+ * -#	If "IN Token Received when TxFIFO Empty" write packet to Tx
+ *		FIFO.
+ * -#	If "IN Token EP Mismatch" (disable, this is handled by EP
+ *		Mismatch Interrupt)
+ */
+static int32_t dwc_otg_pcd_handle_in_ep_intr(dwc_otg_pcd_t *_pcd)
+{
+#define CLEAR_IN_EP_INTR(__core_if,__epnum,__intr) \
+do { \
+		diepint_data_t diepint = {.d32=0}; \
+		diepint.b.__intr = 1; \
+		dwc_write_reg32(&__core_if->dev_if->in_ep_regs[__epnum]->diepint, \
+		diepint.d32); \
+} while (0)
+
+	dwc_otg_core_if_t *core_if = GET_CORE_IF(_pcd);
+	dwc_otg_dev_if_t *dev_if = core_if->dev_if;
+	diepint_data_t diepint = {.d32=0};
+	depctl_data_t diepctl = {.d32=0};
+	uint32_t ep_intr;
+	uint32_t epnum = 0;
+	dwc_otg_pcd_ep_t *ep;
+	dwc_ep_t *dwc_ep;
+	uint32_t _empty_msk, _diepctl;
+	//gintmsk_data_t intr_mask = {.d32 = 0};
+
+
+	DWC_DEBUGPL(DBG_PCDV, "%s(%p)\n", __func__, _pcd);
+
+	/* Read in the device interrupt bits */
+	ep_intr = dwc_otg_read_dev_all_in_ep_intr( core_if );
+
+	/* Service the Device IN interrupts for each endpoint */
+	while ( ep_intr )
+	{
+		if (ep_intr&0x1)
+		{
+			/* Get EP pointer */
+			ep = get_in_ep(_pcd, epnum);
+			dwc_ep = &ep->dwc_ep;
+
+			_diepctl = dwc_read_reg32(&dev_if->in_ep_regs[epnum]->diepctl);
+			_empty_msk = dwc_read_reg32(&dev_if->dev_global_regs->dtknqr4_fifoemptymsk);
+
+//			DWC_DEBUGPL(DBG_PCDV, "IN EP INTERRUPT - %d\nepmty_msk - %8x  diepctl - %8x\n",epnum, _empty_msk, _diepctl);
+
+			DWC_DEBUGPL(DBG_PCD,
+			            "EP%d-%s: type=%d, mps=%d\n",
+			            dwc_ep->num, (dwc_ep->is_in ?"IN":"OUT"),
+			            dwc_ep->type, dwc_ep->maxpacket );
+
+			diepint.d32 = dwc_otg_read_dev_in_ep_intr( core_if, dwc_ep );
+
+			DWC_DEBUGPL(DBG_PCDV, "EP %d Interrupt Register - 0x%x\n", epnum, diepint.d32);
+			/* Transfer complete */
+			if ( diepint.b.xfercompl )
+			{
+				DWC_DEBUGPL(DBG_PCD,"EP%d IN Xfer Complete\n", epnum);
+
+				/* Disable the NP Tx FIFO Empty
+				 * Interrrupt */
+				//if(core_if->en_multiple_tx_fifo == 0)
+				//{
+				//	intr_mask.b.nptxfempty = 1;
+				//	dwc_modify_reg32( &core_if->core_global_regs->gintmsk, intr_mask.d32, 0);
+				//}
+				//else
+				{
+					/* Disable the Tx FIFO Empty Interrupt for this EP */
+					uint32_t fifoemptymsk = 0x1 << dwc_ep->num;
+					dwc_modify_reg32(&core_if->dev_if->dev_global_regs->dtknqr4_fifoemptymsk, fifoemptymsk, 0);
+					//intr_mask.b.nptxfempty = 1;
+					//dwc_modify_reg32( &core_if->core_global_regs->gintmsk, intr_mask.d32, 0);
+				}
+				/* Clear the bit in DIEPINTn for this interrupt */
+				CLEAR_IN_EP_INTR(core_if,epnum,xfercompl);
+
+				/* Complete the transfer */
+				if (epnum == 0)
+				{
+					handle_ep0( _pcd );
+				}
+				else
+				{
+					complete_ep( ep );
+				}
+			}
+			/* Endpoint disable	 */
+			if ( diepint.b.epdisabled )
+			{
+				DWC_DEBUGPL(DBG_ANY,"EP%d IN disabled\n", epnum);
+				handle_in_ep_disable_intr( _pcd, epnum );
+
+				/* Clear the bit in DIEPINTn for this interrupt */
+				CLEAR_IN_EP_INTR(core_if,epnum,epdisabled);
+			}
+			/* AHB Error */
+			if ( diepint.b.ahberr )
+			{
+				DWC_DEBUGPL(DBG_ANY,"EP%d IN AHB Error\n", epnum);
+				/* Clear the bit in DIEPINTn for this interrupt */
+				CLEAR_IN_EP_INTR(core_if,epnum,ahberr);
+			}
+			/* TimeOUT Handshake (non-ISOC IN EPs) */
+			if ( diepint.b.timeout )
+			{
+				DWC_DEBUGPL(DBG_ANY,"EP%d IN Time-out\n", epnum);
+				handle_in_ep_timeout_intr( _pcd, epnum );
+
+				CLEAR_IN_EP_INTR(core_if,epnum,timeout);
+			}
+			/** IN Token received with TxF Empty */
+			if (diepint.b.intktxfemp)
+			{
+				DWC_DEBUGPL(DBG_ANY,"EP%d IN TKN TxFifo Empty\n",
+				            epnum);
+				if (!ep->stopped && epnum != 0)
+				{
+					diepmsk_data_t diepmsk = { .d32 = 0};
+					diepmsk.b.intktxfemp = 1;
+					dwc_modify_reg32( &dev_if->dev_global_regs->diepmsk, diepmsk.d32, 0 );
+					start_next_request(ep);
+				}
+				CLEAR_IN_EP_INTR(core_if,epnum,intktxfemp);
+			}
+			/** IN Token Received with EP mismatch */
+			if (diepint.b.intknepmis)
+			{
+				DWC_DEBUGPL(DBG_ANY,"EP%d IN TKN EP Mismatch\n", epnum);
+				CLEAR_IN_EP_INTR(core_if,epnum,intknepmis);
+			}
+			/** IN Endpoint NAK Effective */
+			if (diepint.b.inepnakeff)
+			{
+				DWC_DEBUGPL(DBG_ANY,"EP%d IN EP NAK Effective\n", epnum);
+				/* Periodic EP */
+				if (ep->disabling)
+				{
+					diepctl.d32 = 0;
+					diepctl.b.snak = 1;
+					diepctl.b.epdis = 1;
+					dwc_modify_reg32(&dev_if->in_ep_regs[epnum]->diepctl, diepctl.d32, diepctl.d32);
+				}
+				CLEAR_IN_EP_INTR(core_if,epnum,inepnakeff);
+
+			}
+
+			/** IN EP Tx FIFO Empty Intr */
+			if (diepint.b.emptyintr)
+			{
+				DWC_DEBUGPL(DBG_ANY,"EP%d Tx FIFO Empty Intr \n", epnum);
+				if (write_empty_tx_fifo(_pcd, epnum)==0)
+				{
+					//AlenOh
+					/* Disable the NP Tx FIFO Empty
+					 * Interrrupt */
+					//if(core_if->en_multiple_tx_fifo == 0)
+					//{
+					//	intr_mask.b.nptxfempty = 1;
+					//	dwc_modify_reg32( &core_if->core_global_regs->gintmsk, intr_mask.d32, 0);
+					//}
+					//else
+					{
+						/* Disable the Tx FIFO Empty Interrupt for this EP */
+						uint32_t fifoemptymsk = 0x1 << dwc_ep->num;
+						dwc_modify_reg32(&core_if->dev_if->dev_global_regs->dtknqr4_fifoemptymsk, fifoemptymsk, 0);
+						//intr_mask.b.nptxfempty = 1;
+						//dwc_modify_reg32( &core_if->core_global_regs->gintmsk, intr_mask.d32, 0);
+					}
+				}
+
+				CLEAR_IN_EP_INTR(core_if,epnum,emptyintr);
+
+			}
+		}
+		epnum++;
+		ep_intr >>=1;
+	}
+
+	return 1;
+#undef CLEAR_IN_EP_INTR
+}
+
+/**
+ * This interrupt indicates that an OUT EP has a pending Interrupt.
+ * The sequence for handling the OUT EP interrupt is shown below:
+ * -#	Read the Device All Endpoint Interrupt register
+ * -#	Repeat the following for each OUT EP interrupt bit set (from
+ *		LSB to MSB).
+ * -#	Read the Device Endpoint Interrupt (DOEPINTn) register
+ * -#	If "Transfer Complete" call the request complete function
+ * -#	If "Endpoint Disabled" complete the EP disable procedure.
+ * -#	If "AHB Error Interrupt" log error
+ * -#	If "Setup Phase Done" process Setup Packet (See Standard USB
+ *		Command Processing)
+ */
+static int32_t dwc_otg_pcd_handle_out_ep_intr(dwc_otg_pcd_t *_pcd)
+{
+#define CLEAR_OUT_EP_INTR(__core_if,__epnum,__intr) \
+do { \
+		doepint_data_t doepint = {.d32=0}; \
+		doepint.b.__intr = 1; \
+		dwc_write_reg32(&__core_if->dev_if->out_ep_regs[__epnum]->doepint, \
+		doepint.d32); \
+} while (0)
+
+	dwc_otg_core_if_t *core_if = GET_CORE_IF(_pcd);
+	uint32_t ep_intr;
+	doepint_data_t doepint = {.d32=0};
+	uint32_t epnum = 0;
+	dwc_ep_t *dwc_ep;
+
+	DWC_DEBUGPL(DBG_PCDV, "%s()\n", __func__);
+
+	/* Read in the device interrupt bits */
+	ep_intr = dwc_otg_read_dev_all_out_ep_intr( core_if );
+
+	while ( ep_intr )
+	{
+		if (ep_intr&0x1)
+		{
+			/* Get EP pointer */
+			dwc_ep = &((get_out_ep(_pcd, epnum))->dwc_ep);
+//			  dwc_ep = &_pcd->out_ep[ epnum - 1].dwc_ep;
+#ifdef VERBOSE
+			DWC_DEBUGPL(DBG_PCDV,
+			            "EP%d-%s: type=%d, mps=%d\n",
+			            dwc_ep->num, (dwc_ep->is_in ?"IN":"OUT"),
+			            dwc_ep->type, dwc_ep->maxpacket );
+#endif
+			doepint.d32 = dwc_otg_read_dev_out_ep_intr(core_if, dwc_ep);
+			/* Transfer complete */
+			if ( doepint.b.xfercompl )
+			{
+				DWC_DEBUGPL(DBG_PCD,"EP%d OUT Xfer Complete\n",
+				            epnum);
+				/* Clear the bit in DOEPINTn for this interrupt */
+				CLEAR_OUT_EP_INTR(core_if,epnum,xfercompl);
+
+				if (epnum == 0)
+				{
+					handle_ep0( _pcd );
+				}
+				else
+				{
+					complete_ep( get_out_ep(_pcd, epnum) );
+//					complete_ep( &_pcd->out_ep[ epnum - 1] );
+				}
+			}
+			/* Endpoint disable	 */
+			if ( doepint.b.epdisabled )
+			{
+				DWC_DEBUGPL(DBG_PCD,"EP%d OUT disabled\n", epnum);
+				/* Clear the bit in DOEPINTn for this interrupt */
+				CLEAR_OUT_EP_INTR(core_if,epnum,epdisabled);
+			}
+			/* AHB Error */
+			if ( doepint.b.ahberr )
+			{
+				DWC_DEBUGPL(DBG_PCD,"EP%d OUT AHB Error\n", epnum);
+				DWC_DEBUGPL(DBG_PCD,"EP DMA REG	 %d \n", core_if->dev_if->out_ep_regs[epnum]->doepdma);
+				CLEAR_OUT_EP_INTR(core_if,epnum,ahberr);
+			}
+			/* Setup Phase Done (contorl EPs) */
+			if ( doepint.b.setup )
+			{
+#ifdef DEBUG_EP0
+				DWC_DEBUGPL(DBG_PCD,"EP%d SETUP Done\n",
+				            epnum);
+#endif
+				handle_ep0( _pcd );
+				CLEAR_OUT_EP_INTR(core_if,epnum,setup);
+			}
+		}
+		epnum++;
+		ep_intr >>=1;
+	}
+
+	return 1;
+
+#undef CLEAR_OUT_EP_INTR
+}
+
+/**
+ * Incomplete ISO IN Transfer Interrupt.
+ * This interrupt indicates one of the following conditions occurred
+ * while transmitting an ISOC transaction.
+ * - Corrupted IN Token for ISOC EP.
+ * - Packet not complete in FIFO.
+ * The follow actions will be taken:
+ *	-#	Determine the EP
+ *	-#	Set incomplete flag in dwc_ep structure
+ *	-#	Disable EP; when "Endpoint Disabled" interrupt is received
+ *		Flush FIFO
+ */
+int32_t dwc_otg_pcd_handle_incomplete_isoc_in_intr(dwc_otg_pcd_t *_pcd)
+{
+	gintmsk_data_t intr_mask = { .d32 = 0};
+	gintsts_data_t gintsts;
+#if 0
+	depctl_data_t diepctl ;
+	diepint_data_t diepint;
+	int epnum =0, i =0;
+#endif
+	DWC_PRINT("INTERRUPT Handler not implemented for %s\n",
+	          "IN ISOC Incomplete");
+
+	/* The application must read the EP Control register for all isochronous IN endpoints to detect EPs with
+	       incomplete IN data transfers.
+	    */
+#if 0
+	for (i=1; i<=15; i++) {
+		diepctl.d32 = dwc_read_reg32(&GET_CORE_IF(_pcd)->dev_if->in_ep_regs[i]->diepctl);
+		if ((diepctl.b.epena) && (diepctl.b.eptype == 0x01)) {
+			epnum = i;
+			break;
+		}
+	}
+	/* Disable the Periodic IN Endpoint*/
+
+	diepctl.b.snak = 1;
+
+	diepctl.b.epdis = 1;
+	dwc_write_reg32(&GET_CORE_IF(_pcd)->dev_if->in_ep_regs[epnum]->diepctl,diepctl.d32);
+
+	/* End */
+#endif
+	intr_mask.b.incomplisoin = 1;
+	dwc_modify_reg32( &GET_CORE_IF(_pcd)->core_global_regs->gintmsk,
+	                  intr_mask.d32, 0 );
+
+	/* Clear interrupt */
+	gintsts.d32 = 0;
+	gintsts.b.incomplisoin = 1;
+	dwc_write_reg32 (&GET_CORE_IF(_pcd)->core_global_regs->gintsts,
+	                 gintsts.d32);
+
+	return 1;
+}
+
+/**
+ * Incomplete ISO OUT Transfer Interrupt.
+ *
+ * This interrupt indicates that the core has dropped an ISO OUT
+ * packet.	The following conditions can be the cause:
+ * - FIFO Full, the entire packet would not fit in the FIFO.
+ * - CRC Error
+ * - Corrupted Token
+ * The follow actions will be taken:
+ *	-#	Determine the EP
+ *	-#	Set incomplete flag in dwc_ep structure
+ *	-#	Read any data from the FIFO
+ *	-#	Disable EP.	 when "Endpoint Disabled" interrupt is received
+ *		re-enable EP.
+ */
+int32_t dwc_otg_pcd_handle_incomplete_isoc_out_intr(dwc_otg_pcd_t *_pcd)
+{
+	/** @todo implement ISR */
+	gintmsk_data_t intr_mask = { .d32 = 0};
+	gintsts_data_t gintsts;
+	DWC_PRINT("INTERRUPT Handler not implemented for %s\n",
+	          "OUT ISOC Incomplete");
+
+	intr_mask.b.incomplisoout = 1;
+	dwc_modify_reg32( &GET_CORE_IF(_pcd)->core_global_regs->gintmsk,
+	                  intr_mask.d32, 0 );
+
+	/* Clear interrupt */
+	gintsts.d32 = 0;
+	gintsts.b.incomplisoout = 1;
+	dwc_write_reg32 (&GET_CORE_IF(_pcd)->core_global_regs->gintsts,
+	                 gintsts.d32);
+
+	return 1;
+}
+
+/**
+ * This function handles the Global IN NAK Effective interrupt.
+ *
+ */
+int32_t dwc_otg_pcd_handle_in_nak_effective( dwc_otg_pcd_t *_pcd )
+{
+	dwc_otg_dev_if_t *dev_if = GET_CORE_IF(_pcd)->dev_if;
+	depctl_data_t diepctl = { .d32 = 0};
+	depctl_data_t diepctl_rd = { .d32 = 0};
+	gintmsk_data_t intr_mask = { .d32 = 0};
+	gintsts_data_t gintsts;
+	int i;
+
+	DWC_DEBUGPL(DBG_PCD, "Global IN NAK Effective\n");
+
+	/* Disable all active IN EPs */
+	diepctl.b.epdis = 1;
+	diepctl.b.snak = 1;
+
+	for (i=0; i <= dev_if->num_in_eps; i++)
+	{
+		diepctl_rd.d32 = dwc_read_reg32(&dev_if->in_ep_regs[i]->diepctl);
+		if (diepctl_rd.b.epena)
+		{
+			dwc_write_reg32( &dev_if->in_ep_regs[i]->diepctl,
+			                 diepctl.d32 );
+		}
+	}
+	/* Disable the Global IN NAK Effective Interrupt */
+	intr_mask.b.ginnakeff = 1;
+	dwc_modify_reg32( &GET_CORE_IF(_pcd)->core_global_regs->gintmsk,
+	                  intr_mask.d32, 0);
+
+	/* Clear interrupt */
+	gintsts.d32 = 0;
+	gintsts.b.ginnakeff = 1;
+	dwc_write_reg32( &GET_CORE_IF(_pcd)->core_global_regs->gintsts,
+	                 gintsts.d32);
+
+	return 1;
+}
+
+/**
+ * OUT NAK Effective.
+ *
+ */
+int32_t dwc_otg_pcd_handle_out_nak_effective( dwc_otg_pcd_t *_pcd )
+{
+	gintmsk_data_t intr_mask = { .d32 = 0};
+	gintsts_data_t gintsts;
+
+	DWC_PRINT("INTERRUPT Handler not implemented for %s\n",
+	          "Global IN NAK Effective\n");
+	/* Disable the Global IN NAK Effective Interrupt */
+	intr_mask.b.goutnakeff = 1;
+	dwc_modify_reg32( &GET_CORE_IF(_pcd)->core_global_regs->gintmsk,
+	                  intr_mask.d32, 0);
+
+	/* Clear interrupt */
+	gintsts.d32 = 0;
+	gintsts.b.goutnakeff = 1;
+	dwc_write_reg32 (&GET_CORE_IF(_pcd)->core_global_regs->gintsts,
+	                 gintsts.d32);
+
+	return 1;
+}
+
+
+/**
+ * PCD interrupt handler.
+ *
+ * The PCD handles the device interrupts.  Many conditions can cause a
+ * device interrupt. When an interrupt occurs, the device interrupt
+ * service routine determines the cause of the interrupt and
+ * dispatches handling to the appropriate function. These interrupt
+ * handling functions are described below.
+ *
+ * All interrupt registers are processed from LSB to MSB.
+ *
+ */
+int32_t dwc_otg_pcd_handle_intr( dwc_otg_pcd_t *_pcd )
+{
+	dwc_otg_core_if_t *core_if = GET_CORE_IF(_pcd);
+#ifdef VERBOSE
+	dwc_otg_core_global_regs_t *global_regs =
+	    core_if->core_global_regs;
+#endif
+	gintsts_data_t gintr_status;
+	int32_t retval = 0;
+
+#ifdef VERBOSE
+	DWC_DEBUGPL(DBG_ANY, "%s() gintsts=%08x	 gintmsk=%08x\n",
+	            __func__,
+	            dwc_read_reg32( &global_regs->gintsts),
+	            dwc_read_reg32( &global_regs->gintmsk));
+#endif
+
+	if (dwc_otg_is_device_mode(core_if))
+	{
+		SPIN_LOCK(&_pcd->lock);
+#ifdef VERBOSE
+		DWC_DEBUGPL(DBG_PCDV, "%s() gintsts=%08x  gintmsk=%08x\n",
+		            __func__,
+		            dwc_read_reg32( &global_regs->gintsts),
+		            dwc_read_reg32( &global_regs->gintmsk));
+#endif
+
+		gintr_status.d32 = dwc_otg_read_core_intr(core_if);
+		if (!gintr_status.d32)
+		{
+			return 0;
+		}
+		DWC_DEBUGPL(DBG_PCDV, "%s: gintsts&gintmsk=%08x\n",
+		            __func__, gintr_status.d32 );
+
+		if (gintr_status.b.sofintr)
+		{
+			retval |= dwc_otg_pcd_handle_sof_intr( _pcd );
+		}
+		if (gintr_status.b.rxstsqlvl)
+		{
+			retval |= dwc_otg_pcd_handle_rx_status_q_level_intr( _pcd );
+		}
+		//if (gintr_status.b.nptxfempty)
+		//{
+		//	retval |= dwc_otg_pcd_handle_np_tx_fifo_empty_intr( _pcd );
+		//}
+		if (gintr_status.b.ginnakeff)
+		{
+			retval |= dwc_otg_pcd_handle_in_nak_effective( _pcd );
+		}
+		if (gintr_status.b.goutnakeff)
+		{
+			retval |= dwc_otg_pcd_handle_out_nak_effective( _pcd );
+		}
+		if (gintr_status.b.i2cintr)
+		{
+			retval |= dwc_otg_pcd_handle_i2c_intr( _pcd );
+		}
+		if (gintr_status.b.erlysuspend)
+		{
+			retval |= dwc_otg_pcd_handle_early_suspend_intr( _pcd );
+		}
+		if (gintr_status.b.usbreset)
+		{
+			retval |= dwc_otg_pcd_handle_usb_reset_intr( _pcd );
+		}
+		if (gintr_status.b.enumdone)
+		{
+			retval |= dwc_otg_pcd_handle_enum_done_intr( _pcd );
+		}
+		if (gintr_status.b.isooutdrop)
+		{
+			retval |= dwc_otg_pcd_handle_isoc_out_packet_dropped_intr( _pcd );
+		}
+		if (gintr_status.b.eopframe)
+		{
+			retval |= dwc_otg_pcd_handle_end_periodic_frame_intr( _pcd );
+		}
+		if (gintr_status.b.epmismatch)
+		{
+			retval |= dwc_otg_pcd_handle_ep_mismatch_intr( core_if );
+		}
+		if (gintr_status.b.inepint)
+		{
+			retval |= dwc_otg_pcd_handle_in_ep_intr( _pcd );
+		}
+		if (gintr_status.b.outepintr)
+		{
+			retval |= dwc_otg_pcd_handle_out_ep_intr( _pcd );
+		}
+		if (gintr_status.b.incomplisoin)
+		{
+			retval |= dwc_otg_pcd_handle_incomplete_isoc_in_intr( _pcd );
+		}
+		if (gintr_status.b.incomplisoout)
+		{
+			retval |= dwc_otg_pcd_handle_incomplete_isoc_out_intr( _pcd );
+		}
+#ifdef VERBOSE
+		DWC_DEBUGPL(DBG_PCDV, "%s() gintsts=%0x\n", __func__,
+		            dwc_read_reg32( &global_regs->gintsts));
+#endif
+		SPIN_UNLOCK(&_pcd->lock);
+	}
+	return retval;
+}
+
+#endif /* DWC_HOST_ONLY */
Index: linux-2.6.29/drivers/usb/dwc_otg/dwc_otg_plat.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/usb/dwc_otg/dwc_otg_plat.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,291 @@
+/* ==========================================================================
+ * $File: //dwh/usb_iip/dev/software/otg_ipmate/linux/platform/dwc_otg_plat.h $
+ * $Revision: #1 $
+ * $Date: 2005/07/07 $
+ * $Change: 510301 $
+ *
+ * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
+ * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto. You are permitted to use and
+ * redistribute this Software in source and binary forms, with or without
+ * modification, provided that redistributions of source code must retain this
+ * notice. You may not view, use, disclose, copy or distribute this file or
+ * any information contained herein except pursuant to this license grant from
+ * Synopsys. If you do not agree with this notice, including the disclaimer
+ * below, then you are not authorized to use the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================== */
+
+#if !defined(__DWC_OTG_PLAT_H__)
+#define __DWC_OTG_PLAT_H__
+
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <linux/device.h>
+
+/**
+ * @file
+ *
+ * This file contains the Platform Specific constants, interfaces
+ * (functions and macros) for Linux.
+ *
+ */
+#if !defined(__LINUX_ARM_ARCH__)
+#error "The contents of this file is Linux specific!!!"
+#endif
+
+/**
+ * Reads the content of a register.
+ *
+ * @param _reg address of register to read.
+ * @return contents of the register.
+ *
+
+ * Usage:<br>
+ * <code>uint32_t dev_ctl = dwc_read_reg32(&dev_regs->dctl);</code>
+ */
+static __inline__ uint32_t dwc_read_reg32( volatile uint32_t *_reg)
+{
+	return readl(_reg);
+};
+
+/**
+ * Writes a register with a 32 bit value.
+ *
+ * @param _reg address of register to read.
+ * @param _value to write to _reg.
+ *
+ * Usage:<br>
+ * <code>dwc_write_reg32(&dev_regs->dctl, 0); </code>
+ */
+static __inline__ void dwc_write_reg32( volatile uint32_t *_reg, const uint32_t _value)
+{
+	writel( _value, _reg );
+};
+
+/**
+ * This function modifies bit values in a register.  Using the
+ * algorithm: (reg_contents & ~clear_mask) | set_mask.
+ *
+ * @param _reg address of register to read.
+ * @param _clear_mask bit mask to be cleared.
+ * @param _set_mask bit mask to be set.
+ *
+ * Usage:<br>
+ * <code> // Clear the SOF Interrupt Mask bit and <br>
+ * // set the OTG Interrupt mask bit, leaving all others as they were.
+ *    dwc_modify_reg32(&dev_regs->gintmsk, DWC_SOF_INT, DWC_OTG_INT);</code>
+ */
+static __inline__
+void dwc_modify_reg32( volatile uint32_t *_reg, const uint32_t _clear_mask, const uint32_t _set_mask)
+{
+	writel( (readl(_reg) & ~_clear_mask) | _set_mask, _reg );
+};
+
+static __inline__
+void *dev_get_otgdata(const struct device *dev)
+{
+	return dev->platform_data;
+}
+
+static __inline__
+void dev_set_otgdata(struct device *dev, void *data)
+{
+	dev->platform_data = data;
+}
+
+/**
+ * Wrapper for the OS micro-second delay function.
+ * @param[in] _usecs Microseconds of delay
+ */
+static __inline__ void UDELAY( const uint32_t _usecs )
+{
+	udelay( _usecs );
+}
+
+/**
+ * Wrapper for the OS milli-second delay function.
+ * @param[in] _msecs milliseconds of delay
+ */
+static __inline__ void MDELAY( const uint32_t _msecs )
+{
+	mdelay( _msecs );
+}
+
+/**
+ * Wrapper for the Linux spin_lock.  On the ARM (Integrator)
+ * spin_lock() is a nop.
+ *
+ * @param _lock Pointer to the spinlock.
+ */
+static __inline__ void SPIN_LOCK( spinlock_t *_lock )
+{
+	spin_lock(_lock);
+}
+
+/**
+ * Wrapper for the Linux spin_unlock.  On the ARM (Integrator)
+ * spin_lock() is a nop.
+ *
+ * @param _lock Pointer to the spinlock.
+ */
+static __inline__ void SPIN_UNLOCK( spinlock_t *_lock )
+{
+	spin_unlock(_lock);
+}
+
+/**
+ * Wrapper (macro) for the Linux spin_lock_irqsave.  On the ARM
+ * (Integrator) spin_lock() is a nop.
+ *
+ * @param _l Pointer to the spinlock.
+ * @param _f unsigned long for irq flags storage.
+ */
+#define SPIN_LOCK_IRQSAVE( _l, _f )  { \
+	spin_lock_irqsave(_l,_f); \
+	}
+
+/**
+ * Wrapper (macro) for the Linux spin_unlock_irqrestore.  On the ARM
+ * (Integrator) spin_lock() is a nop.
+ *
+ * @param _l Pointer to the spinlock.
+ * @param _f unsigned long for irq flags storage.
+ */
+#define SPIN_UNLOCK_IRQRESTORE( _l,_f ) {\
+	spin_unlock_irqrestore(_l,_f); 	\
+	}
+
+
+/*
+ * Debugging support vanishes in non-debug builds.
+ */
+
+
+/**
+ * The Debug Level bit-mask variable.
+ */
+extern uint32_t g_dbg_lvl;
+/**
+ * Set the Debug Level variable.
+ */
+static inline uint32_t SET_DEBUG_LEVEL( const uint32_t _new )
+{
+	uint32_t old = g_dbg_lvl;
+	g_dbg_lvl = _new;
+	return old;
+}
+
+/** When debug level has the DBG_CIL bit set, display CIL Debug messages. */
+#define DBG_CIL		(0x2)
+/** When debug level has the DBG_CILV bit set, display CIL Verbose debug
+ * messages */
+#define DBG_CILV	(0x20)
+/**  When debug level has the DBG_PCD bit set, display PCD (Device) debug
+ *  messages */
+#define DBG_PCD		(0x4)
+/** When debug level has the DBG_PCDV set, display PCD (Device) Verbose debug
+ * messages */
+#define DBG_PCDV	(0x40)
+/** When debug level has the DBG_HCD bit set, display Host debug messages */
+#define DBG_HCD		(0x8)
+/** When debug level has the DBG_HCDV bit set, display Verbose Host debug
+ * messages */
+#define DBG_HCDV	(0x80)
+/** When debug level has the DBG_HCD_URB bit set, display enqueued URBs in host
+ *  mode. */
+#define DBG_HCD_URB	(0x800)
+
+/** When debug level has any bit set, display debug messages */
+#define DBG_ANY		(0xFF)
+
+/** All debug messages off */
+#define DBG_OFF		0
+
+/** Prefix string for DWC_DEBUG print macros. */
+#define USB_DWC "DWC_otg: "
+
+/**
+ * Print a debug message when the Global debug level variable contains
+ * the bit defined in <code>lvl</code>.
+ *
+ * @param[in] lvl - Debug level, use one of the DBG_ constants above.
+ * @param[in] x - like printf
+ *
+ *    Example:<p>
+ * <code>
+ *      DWC_DEBUGPL( DBG_ANY, "%s(%p)\n", __func__, _reg_base_addr);
+ * </code>
+ * <br>
+ * results in:<br>
+ * <code>
+ * usb-DWC_otg: dwc_otg_cil_init(ca867000)
+ * </code>
+ */
+#if 1
+#ifdef DEBUG
+
+# define DWC_DEBUGPL(lvl, x...) do{ if ((lvl)&g_dbg_lvl)printk( KERN_DEBUG USB_DWC x ); }while(0)
+# define DWC_DEBUGP(x...)	DWC_DEBUGPL(DBG_ANY, x )
+
+# define CHK_DEBUG_LEVEL(level) ((level) & g_dbg_lvl)
+
+#else
+
+# define DWC_DEBUGPL(lvl, x...) do{}while(0)
+# define DWC_DEBUGP(x...)
+
+# define CHK_DEBUG_LEVEL(level) (0)
+
+#endif /*DEBUG*/
+#else
+#ifdef DEBUG
+# define DWC_DEBUGPL(lvl, x...) printk(KERN_INFO USB_DWC x )
+# define DWC_DEBUGP(x...)       printk(KERN_INFO USB_DWC X )
+#endif
+#endif
+
+#ifdef DEBUG
+/**
+ * Print an Error message.
+ */
+#define DWC_ERROR(x...) printk( KERN_ERR USB_DWC x )
+/**
+ * Print a Warning message.
+ */
+#define DWC_WARN(x...) printk( KERN_WARNING USB_DWC x )
+/**
+ * Print a notice (normal but significant message).
+ */
+#define DWC_NOTICE(x...) printk( KERN_NOTICE USB_DWC x )
+/**
+ *  Basic message printing.
+ */
+#define DWC_PRINT(x...) printk( KERN_INFO USB_DWC x )
+#else
+#define DWC_ERROR(x...)
+#define DWC_WARN(x...)
+#define DWC_NOTICE(x...)
+#define DWC_PRINT(x...)
+#endif
+
+#endif
+
Index: linux-2.6.29/drivers/usb/dwc_otg/dwc_otg_regs.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/usb/dwc_otg/dwc_otg_regs.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,1884 @@
+/* ==========================================================================
+ * $File: //dwh/usb_iip/dev/software/otg_ipmate/linux/drivers/dwc_otg_regs.h $
+ * $Revision: #8 $
+ * $Date: 2007/02/07 $
+ * $Change: 791271 $
+ *
+ * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
+ * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto. You are permitted to use and
+ * redistribute this Software in source and binary forms, with or without
+ * modification, provided that redistributions of source code must retain this
+ * notice. You may not view, use, disclose, copy or distribute this file or
+ * any information contained herein except pursuant to this license grant from
+ * Synopsys. If you do not agree with this notice, including the disclaimer
+ * below, then you are not authorized to use the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================== */
+
+#ifndef __DWC_OTG_REGS_H__
+#define __DWC_OTG_REGS_H__
+
+/**
+ * @file
+ *
+ * This file contains the data structures for accessing the DWC_otg core registers.
+ *
+ * The application interfaces with the HS OTG core by reading from and
+ * writing to the Control and Status Register (CSR) space through the
+ * AHB Slave interface. These registers are 32 bits wide, and the
+ * addresses are 32-bit-block aligned.
+ * CSRs are classified as follows:
+ * - Core Global Registers
+ * - Device Mode Registers
+ * - Device Global Registers
+ * - Device Endpoint Specific Registers
+ * - Host Mode Registers
+ * - Host Global Registers
+ * - Host Port CSRs
+ * - Host Channel Specific Registers
+ *
+ * Only the Core Global registers can be accessed in both Device and
+ * Host modes. When the HS OTG core is operating in one mode, either
+ * Device or Host, the application must not access registers from the
+ * other mode. When the core switches from one mode to another, the
+ * registers in the new mode of operation must be reprogrammed as they
+ * would be after a power-on reset.
+ */
+
+/****************************************************************************/
+/** DWC_otg Core registers .
+ * The dwc_otg_core_global_regs structure defines the size
+ * and relative field offsets for the Core Global registers.
+ */
+typedef struct dwc_otg_core_global_regs
+{
+	/** OTG Control and Status Register.  <i>Offset: 000h</i> */
+	volatile uint32_t gotgctl;
+	/** OTG Interrupt Register.	 <i>Offset: 004h</i> */
+	volatile uint32_t gotgint;
+	/**Core AHB Configuration Register.	 <i>Offset: 008h</i> */
+	volatile uint32_t gahbcfg;
+
+#define DWC_GLBINTRMASK		0x0001
+#define DWC_DMAENABLE		0x0020
+#define DWC_NPTXEMPTYLVL_EMPTY	0x0080
+#define DWC_NPTXEMPTYLVL_HALFEMPTY	0x0000
+#define DWC_PTXEMPTYLVL_EMPTY	0x0100
+#define DWC_PTXEMPTYLVL_HALFEMPTY	0x0000
+
+	/**Core USB Configuration Register.	 <i>Offset: 00Ch</i> */
+	volatile uint32_t gusbcfg;
+	/**Core Reset Register.	 <i>Offset: 010h</i> */
+	volatile uint32_t grstctl;
+	/**Core Interrupt Register.	 <i>Offset: 014h</i> */
+	volatile uint32_t gintsts;
+	/**Core Interrupt Mask Register.  <i>Offset: 018h</i> */
+	volatile uint32_t gintmsk;
+	/**Receive Status Queue Read Register (Read Only).	<i>Offset: 01Ch</i> */
+	volatile uint32_t grxstsr;
+	/**Receive Status Queue Read & POP Register (Read Only).  <i>Offset: 020h</i>*/
+	volatile uint32_t grxstsp;
+	/**Receive FIFO Size Register.	<i>Offset: 024h</i> */
+	volatile uint32_t grxfsiz;
+	/**Non Periodic Transmit FIFO Size Register.  <i>Offset: 028h</i> */
+	volatile uint32_t gnptxfsiz;
+	/**Non Periodic Transmit FIFO/Queue Status Register (Read
+	 * Only). <i>Offset: 02Ch</i> */
+	volatile uint32_t gnptxsts;
+	/**I2C Access Register.	 <i>Offset: 030h</i> */
+	volatile uint32_t gi2cctl;
+	/**PHY Vendor Control Register.	 <i>Offset: 034h</i> */
+	volatile uint32_t gpvndctl;
+	/**General Purpose Input/Output Register.  <i>Offset: 038h</i> */
+	volatile uint32_t ggpio;
+	/**User ID Register.  <i>Offset: 03Ch</i> */
+	volatile uint32_t guid;
+	/**Synopsys ID Register (Read Only).  <i>Offset: 040h</i> */
+	volatile uint32_t gsnpsid;
+	/**User HW Config1 Register (Read Only).  <i>Offset: 044h</i> */
+	volatile uint32_t ghwcfg1;
+	/**User HW Config2 Register (Read Only).  <i>Offset: 048h</i> */
+	volatile uint32_t ghwcfg2;
+#define DWC_SLAVE_ONLY_ARCH 0
+#define DWC_EXT_DMA_ARCH 1
+#define DWC_INT_DMA_ARCH 2
+
+#define DWC_MODE_HNP_SRP_CAPABLE	0
+#define DWC_MODE_SRP_ONLY_CAPABLE	1
+#define DWC_MODE_NO_HNP_SRP_CAPABLE		2
+#define DWC_MODE_SRP_CAPABLE_DEVICE		3
+#define DWC_MODE_NO_SRP_CAPABLE_DEVICE	4
+#define DWC_MODE_SRP_CAPABLE_HOST	5
+#define DWC_MODE_NO_SRP_CAPABLE_HOST	6
+
+	/**User HW Config3 Register (Read Only).  <i>Offset: 04Ch</i> */
+	volatile uint32_t ghwcfg3;
+	/**User HW Config4 Register (Read Only).  <i>Offset: 050h</i>*/
+	volatile uint32_t ghwcfg4;
+	/** Reserved  <i>Offset: 054h-0FFh</i> */
+	uint32_t reserved[43];
+	/** Host Periodic Transmit FIFO Size Register. <i>Offset: 100h</i> */
+	volatile uint32_t hptxfsiz;
+	/** Device Periodic Transmit FIFO#n Register if dedicated fifos are disabled,
+		otherwise Device Transmit FIFO#n Register.
+	 * <i>Offset: 104h + (FIFO_Number-1)*04h, 1 <= FIFO Number <= 15 (1<=n<=15).</i> */
+	volatile uint32_t dptxfsiz_dieptxf[15];
+} dwc_otg_core_global_regs_t;
+
+/**
+ * This union represents the bit fields of the Core OTG Control
+ * and Status Register (GOTGCTL).  Set the bits using the bit
+ * fields then write the <i>d32</i> value to the register.
+ */
+typedef union gotgctl_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned sesreqscs : 1;
+		unsigned sesreq : 1;
+		unsigned reserved2_7 : 6;
+		unsigned hstnegscs : 1;
+		unsigned hnpreq : 1;
+		unsigned hstsethnpen : 1;
+		unsigned devhnpen : 1;
+		unsigned reserved12_15 : 4;
+		unsigned conidsts : 1;
+		unsigned reserved17 : 1;
+		unsigned asesvld : 1;
+		unsigned bsesvld : 1;
+		unsigned currmod : 1;
+		unsigned reserved21_31 : 11;
+	} b;
+} gotgctl_data_t;
+
+/**
+ * This union represents the bit fields of the Core OTG Interrupt Register
+ * (GOTGINT).  Set/clear the bits using the bit fields then write the <i>d32</i>
+ * value to the register.
+ */
+typedef union gotgint_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Current Mode */
+		unsigned reserved0_1 : 2;
+
+		/** Session End Detected */
+		unsigned sesenddet : 1;
+
+		unsigned reserved3_7 : 5;
+
+		/** Session Request Success Status Change */
+		unsigned sesreqsucstschng : 1;
+		/** Host Negotiation Success Status Change */
+		unsigned hstnegsucstschng : 1;
+
+		unsigned reserver10_16 : 7;
+
+		/** Host Negotiation Detected */
+		unsigned hstnegdet : 1;
+		/** A-Device Timeout Change */
+		unsigned adevtoutchng : 1;
+		/** Debounce Done */
+		unsigned debdone : 1;
+
+		unsigned reserved31_20 : 12;
+
+	} b;
+} gotgint_data_t;
+
+
+/**
+ * This union represents the bit fields of the Core AHB Configuration
+ * Register (GAHBCFG).	Set/clear the bits using the bit fields then
+ * write the <i>d32</i> value to the register.
+ */
+typedef union gahbcfg_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned glblintrmsk : 1;
+#define DWC_GAHBCFG_GLBINT_ENABLE		1
+
+		unsigned hburstlen : 4;
+#define DWC_GAHBCFG_INT_DMA_BURST_SINGLE	0
+#define DWC_GAHBCFG_INT_DMA_BURST_INCR		1
+#define DWC_GAHBCFG_INT_DMA_BURST_INCR4		3
+#define DWC_GAHBCFG_INT_DMA_BURST_INCR8		5
+#define DWC_GAHBCFG_INT_DMA_BURST_INCR16	7
+
+		unsigned dmaenable : 1;
+#define DWC_GAHBCFG_DMAENABLE			1
+		unsigned reserved : 1;
+		unsigned nptxfemplvl_txfemplvl : 1;
+		unsigned ptxfemplvl : 1;
+#define DWC_GAHBCFG_TXFEMPTYLVL_EMPTY		1
+#define DWC_GAHBCFG_TXFEMPTYLVL_HALFEMPTY	0
+		unsigned reserved9_31 : 23;
+	} b;
+} gahbcfg_data_t;
+
+/**
+ * This union represents the bit fields of the Core USB Configuration
+ * Register (GUSBCFG).	Set the bits using the bit fields then write
+ * the <i>d32</i> value to the register.
+ */
+typedef union gusbcfg_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned toutcal : 3;
+		unsigned phyif : 1;
+		unsigned ulpi_utmi_sel : 1;
+		unsigned fsintf : 1;
+		unsigned physel : 1;
+		unsigned ddrsel : 1;
+		unsigned srpcap : 1;
+		unsigned hnpcap : 1;
+		unsigned usbtrdtim : 4;
+		unsigned nptxfrwnden : 1;
+		unsigned phylpwrclksel : 1;
+		unsigned otgutmifssel : 1;
+		unsigned ulpi_fsls : 1;
+		unsigned ulpi_auto_res : 1;
+		unsigned ulpi_clk_sus_m : 1;
+		unsigned ulpi_ext_vbus_drv : 1;
+		unsigned ulpi_int_vbus_indicator : 1;
+		unsigned term_sel_dl_pulse : 1;
+		unsigned reserved : 9;
+	} b;
+} gusbcfg_data_t;
+
+/**
+ * This union represents the bit fields of the Core Reset Register
+ * (GRSTCTL).  Set/clear the bits using the bit fields then write the
+ * <i>d32</i> value to the register.
+ */
+typedef union grstctl_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Core Soft Reset (CSftRst) (Device and Host)
+		 *
+		 * The application can flush the control logic in the
+		 * entire core using this bit. This bit resets the
+		 * pipelines in the AHB Clock domain as well as the
+		 * PHY Clock domain.
+		 *
+		 * The state machines are reset to an IDLE state, the
+		 * control bits in the CSRs are cleared, all the
+		 * transmit FIFOs and the receive FIFO are flushed.
+		 *
+		 * The status mask bits that control the generation of
+		 * the interrupt, are cleared, to clear the
+		 * interrupt. The interrupt status bits are not
+		 * cleared, so the application can get the status of
+		 * any events that occurred in the core after it has
+		 * set this bit.
+		 *
+		 * Any transactions on the AHB are terminated as soon
+		 * as possible following the protocol. Any
+		 * transactions on the USB are terminated immediately.
+		 *
+		 * The configuration settings in the CSRs are
+		 * unchanged, so the software doesn't have to
+		 * reprogram these registers (Device
+		 * Configuration/Host Configuration/Core System
+		 * Configuration/Core PHY Configuration).
+		 *
+		 * The application can write to this bit, any time it
+		 * wants to reset the core. This is a self clearing
+		 * bit and the core clears this bit after all the
+		 * necessary logic is reset in the core, which may
+		 * take several clocks, depending on the current state
+		 * of the core.
+		 */
+		unsigned csftrst : 1;
+		/** Hclk Soft Reset
+		 *
+		 * The application uses this bit to reset the control logic in
+		 * the AHB clock domain. Only AHB clock domain pipelines are
+		 * reset.
+		 */
+		unsigned hsftrst : 1;
+		/** Host Frame Counter Reset (Host Only)<br>
+		 *
+		 * The application can reset the (micro)frame number
+		 * counter inside the core, using this bit. When the
+		 * (micro)frame counter is reset, the subsequent SOF
+		 * sent out by the core, will have a (micro)frame
+		 * number of 0.
+		 */
+		unsigned hstfrm : 1;
+		/** In Token Sequence Learning Queue Flush
+		 * (INTknQFlsh) (Device Only)
+		 */
+		unsigned intknqflsh : 1;
+		/** RxFIFO Flush (RxFFlsh) (Device and Host)
+		 *
+		 * The application can flush the entire Receive FIFO
+		 * using this bit.	<p>The application must first
+		 * ensure that the core is not in the middle of a
+		 * transaction.	 <p>The application should write into
+		 * this bit, only after making sure that neither the
+		 * DMA engine is reading from the RxFIFO nor the MAC
+		 * is writing the data in to the FIFO.	<p>The
+		 * application should wait until the bit is cleared
+		 * before performing any other operations. This bit
+		 * will takes 8 clocks (slowest of PHY or AHB clock)
+		 * to clear.
+		 */
+		unsigned rxfflsh : 1;
+		/** TxFIFO Flush (TxFFlsh) (Device and Host).
+		 *
+		 * This bit is used to selectively flush a single or
+		 * all transmit FIFOs.	The application must first
+		 * ensure that the core is not in the middle of a
+		 * transaction.	 <p>The application should write into
+		 * this bit, only after making sure that neither the
+		 * DMA engine is writing into the TxFIFO nor the MAC
+		 * is reading the data out of the FIFO.	 <p>The
+		 * application should wait until the core clears this
+		 * bit, before performing any operations. This bit
+		 * will takes 8 clocks (slowest of PHY or AHB clock)
+		 * to clear.
+		 */
+		unsigned txfflsh : 1;
+
+		/** TxFIFO Number (TxFNum) (Device and Host).
+		 *
+		 * This is the FIFO number which needs to be flushed,
+		 * using the TxFIFO Flush bit. This field should not
+		 * be changed until the TxFIFO Flush bit is cleared by
+		 * the core.
+		 *	 - 0x0 : Non Periodic TxFIFO Flush
+		 *	 - 0x1 : Periodic TxFIFO #1 Flush in device mode
+		 *	   or Periodic TxFIFO in host mode
+		 *	 - 0x2 : Periodic TxFIFO #2 Flush in device mode.
+		 *	 - ...
+		 *	 - 0xF : Periodic TxFIFO #15 Flush in device mode
+		 *	 - 0x10: Flush all the Transmit NonPeriodic and
+		 *	   Transmit Periodic FIFOs in the core
+		 */
+		unsigned txfnum : 5;
+		/** Reserved */
+		unsigned reserved11_29 : 19;
+		/** DMA Request Signal.	 Indicated DMA request is in
+		 * probress.  Used for debug purpose. */
+		unsigned dmareq : 1;
+		/** AHB Master Idle.  Indicates the AHB Master State
+		 * Machine is in IDLE condition. */
+		unsigned ahbidle : 1;
+	} b;
+} grstctl_t;
+
+
+/**
+ * This union represents the bit fields of the Core Interrupt Mask
+ * Register (GINTMSK).	Set/clear the bits using the bit fields then
+ * write the <i>d32</i> value to the register.
+ */
+typedef union gintmsk_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned reserved0 : 1;
+		unsigned modemismatch : 1;
+		unsigned otgintr : 1;
+		unsigned sofintr : 1;
+		unsigned rxstsqlvl : 1;
+		unsigned nptxfempty : 1;
+		unsigned ginnakeff : 1;
+		unsigned goutnakeff : 1;
+		unsigned reserved8 : 1;
+		unsigned i2cintr : 1;
+		unsigned erlysuspend : 1;
+		unsigned usbsuspend : 1;
+		unsigned usbreset : 1;
+		unsigned enumdone : 1;
+		unsigned isooutdrop : 1;
+		unsigned eopframe : 1;
+		unsigned reserved16 : 1;
+		unsigned epmismatch : 1;
+		unsigned inepintr : 1;
+		unsigned outepintr : 1;
+		unsigned incomplisoin : 1;
+		unsigned incomplisoout : 1;
+		unsigned reserved22_23 : 2;
+		unsigned portintr : 1;
+		unsigned hcintr : 1;
+		unsigned ptxfempty : 1;
+		unsigned reserved27 : 1;
+		unsigned conidstschng : 1;
+		unsigned disconnect : 1;
+		unsigned sessreqintr : 1;
+		unsigned wkupintr : 1;
+	} b;
+} gintmsk_data_t;
+/**
+ * This union represents the bit fields of the Core Interrupt Register
+ * (GINTSTS).  Set/clear the bits using the bit fields then write the
+ * <i>d32</i> value to the register.
+ */
+typedef union gintsts_data
+{
+	/** raw register data */
+	uint32_t d32;
+#define DWC_SOF_INTR_MASK 0x0008
+	/** register bits */
+	struct
+	{
+#define DWC_HOST_MODE 1
+		unsigned curmode : 1;
+		unsigned modemismatch : 1;
+		unsigned otgintr : 1;
+		unsigned sofintr : 1;
+		unsigned rxstsqlvl : 1;
+		unsigned nptxfempty : 1;
+		unsigned ginnakeff : 1;
+		unsigned goutnakeff : 1;
+		unsigned reserved8 : 1;
+		unsigned i2cintr : 1;
+		unsigned erlysuspend : 1;
+		unsigned usbsuspend : 1;
+		unsigned usbreset : 1;
+		unsigned enumdone : 1;
+		unsigned isooutdrop : 1;
+		unsigned eopframe : 1;
+		unsigned intokenrx : 1;
+		unsigned epmismatch : 1;
+		unsigned inepint: 1;
+		unsigned outepintr : 1;
+		unsigned incomplisoin : 1;
+		unsigned incomplisoout : 1;
+		unsigned reserved22_23 : 2;
+		unsigned portintr : 1;
+		unsigned hcintr : 1;
+		unsigned ptxfempty : 1;
+		unsigned reserved27 : 1;
+		unsigned conidstschng : 1;
+		unsigned disconnect : 1;
+		unsigned sessreqintr : 1;
+		unsigned wkupintr : 1;
+	} b;
+} gintsts_data_t;
+
+
+/**
+ * This union represents the bit fields in the Device Receive Status Read and
+ * Pop Registers (GRXSTSR, GRXSTSP) Read the register into the <i>d32</i>
+ * element then read out the bits using the <i>b</i>it elements.
+ */
+typedef union device_grxsts_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned epnum : 4;
+		unsigned bcnt : 11;
+		unsigned dpid : 2;
+
+#define DWC_STS_DATA_UPDT		0x2				  // OUT Data Packet
+#define DWC_STS_XFER_COMP		0x3				  // OUT Data Transfer Complete
+
+#define DWC_DSTS_GOUT_NAK		0x1				  // Global OUT NAK
+#define DWC_DSTS_SETUP_COMP		0x4				  // Setup Phase Complete
+#define DWC_DSTS_SETUP_UPDT 0x6				  // SETUP Packet
+		unsigned pktsts : 4;
+		unsigned fn : 4;
+		unsigned reserved : 7;
+	} b;
+} device_grxsts_data_t;
+
+/**
+ * This union represents the bit fields in the Host Receive Status Read and
+ * Pop Registers (GRXSTSR, GRXSTSP) Read the register into the <i>d32</i>
+ * element then read out the bits using the <i>b</i>it elements.
+ */
+typedef union host_grxsts_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned chnum : 4;
+		unsigned bcnt : 11;
+		unsigned dpid : 2;
+
+		unsigned pktsts : 4;
+#define DWC_GRXSTS_PKTSTS_IN			  0x2
+#define DWC_GRXSTS_PKTSTS_IN_XFER_COMP	  0x3
+#define DWC_GRXSTS_PKTSTS_DATA_TOGGLE_ERR 0x5
+#define DWC_GRXSTS_PKTSTS_CH_HALTED		  0x7
+
+		unsigned reserved : 11;
+	} b;
+} host_grxsts_data_t;
+
+/**
+ * This union represents the bit fields in the FIFO Size Registers (HPTXFSIZ,
+ * GNPTXFSIZ, DPTXFSIZn, DIEPTXFn). Read the register into the <i>d32</i> element then
+ * read out the bits using the <i>b</i>it elements.
+ */
+typedef union fifosize_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned startaddr : 16;
+		unsigned depth : 16;
+	} b;
+} fifosize_data_t;
+
+/**
+ * This union represents the bit fields in the Non-Periodic Transmit
+ * FIFO/Queue Status Register (GNPTXSTS). Read the register into the
+ * <i>d32</i> element then read out the bits using the <i>b</i>it
+ * elements.
+ */
+typedef union gnptxsts_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned nptxfspcavail : 16;
+		unsigned nptxqspcavail : 8;
+		/** Top of the Non-Periodic Transmit Request Queue
+		 *	- bit 24 - Terminate (Last entry for the selected
+		 *	  channel/EP)
+		 *	- bits 26:25 - Token Type
+		 *	  - 2'b00 - IN/OUT
+		 *	  - 2'b01 - Zero Length OUT
+		 *	  - 2'b10 - PING/Complete Split
+		 *	  - 2'b11 - Channel Halt
+		 *	- bits 30:27 - Channel/EP Number
+		 */
+		unsigned nptxqtop_terminate : 1;
+		unsigned nptxqtop_token : 2;
+		unsigned nptxqtop_chnep : 4;
+		unsigned reserved : 1;
+	} b;
+} gnptxsts_data_t;
+
+/**
+ * This union represents the bit fields in the Transmit
+ * FIFO Status Register (DTXFSTS). Read the register into the
+ * <i>d32</i> element then read out the bits using the <i>b</i>it
+ * elements.
+ */
+typedef union dtxfsts_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned txfspcavail : 16;
+		unsigned reserved : 16;
+	} b;
+} dtxfsts_data_t;
+
+/**
+ * This union represents the bit fields in the I2C Control Register
+ * (I2CCTL). Read the register into the <i>d32</i> element then read out the
+ * bits using the <i>b</i>it elements.
+ */
+typedef union gi2cctl_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned rwdata : 8;
+		unsigned regaddr : 8;
+		unsigned addr : 7;
+		unsigned i2cen : 1;
+		unsigned ack : 1;
+		unsigned i2csuspctl : 1;
+		unsigned i2cdevaddr : 2;
+		unsigned reserved : 2;
+		unsigned rw : 1;
+		unsigned bsydne : 1;
+	} b;
+} gi2cctl_data_t;
+
+/**
+ * This union represents the bit fields in the User HW Config1
+ * Register.  Read the register into the <i>d32</i> element then read
+ * out the bits using the <i>b</i>it elements.
+ */
+typedef union hwcfg1_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned ep_dir0 : 2;
+		unsigned ep_dir1 : 2;
+		unsigned ep_dir2 : 2;
+		unsigned ep_dir3 : 2;
+		unsigned ep_dir4 : 2;
+		unsigned ep_dir5 : 2;
+		unsigned ep_dir6 : 2;
+		unsigned ep_dir7 : 2;
+		unsigned ep_dir8 : 2;
+		unsigned ep_dir9 : 2;
+		unsigned ep_dir10 : 2;
+		unsigned ep_dir11 : 2;
+		unsigned ep_dir12 : 2;
+		unsigned ep_dir13 : 2;
+		unsigned ep_dir14 : 2;
+		unsigned ep_dir15 : 2;
+	} b;
+} hwcfg1_data_t;
+
+/**
+ * This union represents the bit fields in the User HW Config2
+ * Register.  Read the register into the <i>d32</i> element then read
+ * out the bits using the <i>b</i>it elements.
+ */
+typedef union hwcfg2_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/* GHWCFG2 */
+		unsigned op_mode : 3;
+#define DWC_HWCFG2_OP_MODE_HNP_SRP_CAPABLE_OTG 0
+#define DWC_HWCFG2_OP_MODE_SRP_ONLY_CAPABLE_OTG 1
+#define DWC_HWCFG2_OP_MODE_NO_HNP_SRP_CAPABLE_OTG 2
+#define DWC_HWCFG2_OP_MODE_SRP_CAPABLE_DEVICE 3
+#define DWC_HWCFG2_OP_MODE_NO_SRP_CAPABLE_DEVICE 4
+#define DWC_HWCFG2_OP_MODE_SRP_CAPABLE_HOST 5
+#define DWC_HWCFG2_OP_MODE_NO_SRP_CAPABLE_HOST 6
+
+		unsigned architecture : 2;
+		unsigned point2point : 1;
+		unsigned hs_phy_type : 2;
+#define DWC_HWCFG2_HS_PHY_TYPE_NOT_SUPPORTED 0
+#define DWC_HWCFG2_HS_PHY_TYPE_UTMI 1
+#define DWC_HWCFG2_HS_PHY_TYPE_ULPI 2
+#define DWC_HWCFG2_HS_PHY_TYPE_UTMI_ULPI 3
+
+		unsigned fs_phy_type : 2;
+		unsigned num_dev_ep : 4;
+		unsigned num_host_chan : 4;
+		unsigned perio_ep_supported : 1;
+		unsigned dynamic_fifo : 1;
+		unsigned rx_status_q_depth : 2;
+		unsigned nonperio_tx_q_depth : 2;
+		unsigned host_perio_tx_q_depth : 2;
+		unsigned dev_token_q_depth : 5;
+		unsigned reserved31 : 1;
+	} b;
+} hwcfg2_data_t;
+
+/**
+ * This union represents the bit fields in the User HW Config3
+ * Register.  Read the register into the <i>d32</i> element then read
+ * out the bits using the <i>b</i>it elements.
+ */
+typedef union hwcfg3_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/* GHWCFG3 */
+		unsigned xfer_size_cntr_width : 4;
+		unsigned packet_size_cntr_width : 3;
+		unsigned otg_func : 1;
+		unsigned i2c : 1;
+		unsigned vendor_ctrl_if : 1;
+		unsigned optional_features : 1;
+		unsigned synch_reset_type : 1;
+		unsigned ahb_phy_clock_synch : 1;
+		unsigned reserved15_13 : 3;
+		unsigned dfifo_depth : 16;
+	} b;
+} hwcfg3_data_t;
+
+/**
+ * This union represents the bit fields in the User HW Config4
+ * Register.  Read the register into the <i>d32</i> element then read
+ * out the bits using the <i>b</i>it elements.
+ */
+typedef union hwcfg4_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned num_dev_perio_in_ep : 4;
+		unsigned power_optimiz : 1;
+		unsigned min_ahb_freq : 9;
+		unsigned utmi_phy_data_width : 2;
+		unsigned num_dev_mode_ctrl_ep : 4;
+		unsigned iddig_filt_en : 1;
+		unsigned vbus_valid_filt_en : 1;
+		unsigned a_valid_filt_en : 1;
+		unsigned b_valid_filt_en : 1;
+		unsigned session_end_filt_en : 1;
+		unsigned ded_fifo_en : 1;
+		unsigned num_in_eps : 4;
+		unsigned reserved31_30 : 2;
+	} b;
+} hwcfg4_data_t;
+
+////////////////////////////////////////////
+// Device Registers
+/**
+ * Device Global Registers. <i>Offsets 800h-BFFh</i>
+ *
+ * The following structures define the size and relative field offsets
+ * for the Device Mode Registers.
+ *
+ * <i>These registers are visible only in Device mode and must not be
+ * accessed in Host mode, as the results are unknown.</i>
+ */
+typedef struct dwc_otg_dev_global_regs
+{
+	/** Device Configuration Register. <i>Offset 800h</i> */
+	volatile uint32_t dcfg;
+	/** Device Control Register. <i>Offset: 804h</i> */
+	volatile uint32_t dctl;
+	/** Device Status Register (Read Only). <i>Offset: 808h</i> */
+	volatile uint32_t dsts;
+	/** Reserved. <i>Offset: 80Ch</i> */
+	uint32_t unused;
+	/** Device IN Endpoint Common Interrupt Mask
+	 * Register. <i>Offset: 810h</i> */
+	volatile uint32_t diepmsk;
+	/** Device OUT Endpoint Common Interrupt Mask
+	 * Register. <i>Offset: 814h</i> */
+	volatile uint32_t doepmsk;
+	/** Device All Endpoints Interrupt Register.  <i>Offset: 818h</i> */
+	volatile uint32_t daint;
+	/** Device All Endpoints Interrupt Mask Register.  <i>Offset:
+	 * 81Ch</i> */
+	volatile uint32_t daintmsk;
+	/** Device IN Token Queue Read Register-1 (Read Only).
+	 * <i>Offset: 820h</i> */
+	volatile uint32_t dtknqr1;
+	/** Device IN Token Queue Read Register-2 (Read Only).
+	 * <i>Offset: 824h</i> */
+	volatile uint32_t dtknqr2;
+	/** Device VBUS	 discharge Register.  <i>Offset: 828h</i> */
+	volatile uint32_t dvbusdis;
+	/** Device VBUS Pulse Register.	 <i>Offset: 82Ch</i> */
+	volatile uint32_t dvbuspulse;
+	/** Device IN Token Queue Read Register-3 (Read Only). /
+	 *	Device Thresholding control register (Read/Write)
+	 * <i>Offset: 830h</i> */
+	volatile uint32_t dtknqr3_dthrctl;
+	/** Device IN Token Queue Read Register-4 (Read Only). /
+	 *	Device IN EPs empty Inr. Mask Register (Read/Write)
+	 * <i>Offset: 834h</i> */
+	volatile uint32_t dtknqr4_fifoemptymsk;
+} dwc_otg_device_global_regs_t;
+
+/**
+ * This union represents the bit fields in the Device Configuration
+ * Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.  Write the
+ * <i>d32</i> member to the dcfg register.
+ */
+typedef union dcfg_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Device Speed */
+		unsigned devspd : 2;
+		/** Non Zero Length Status OUT Handshake */
+		unsigned nzstsouthshk : 1;
+#define DWC_DCFG_SEND_STALL 1
+
+		unsigned reserved3 : 1;
+		/** Device Addresses */
+		unsigned devaddr : 7;
+		/** Periodic Frame Interval */
+		unsigned perfrint : 2;
+#define DWC_DCFG_FRAME_INTERVAL_80 0
+#define DWC_DCFG_FRAME_INTERVAL_85 1
+#define DWC_DCFG_FRAME_INTERVAL_90 2
+#define DWC_DCFG_FRAME_INTERVAL_95 3
+
+		unsigned reserved13_17 : 5;
+		/** In Endpoint Mis-match count */
+		unsigned epmscnt : 4;
+	} b;
+} dcfg_data_t;
+
+/**
+ * This union represents the bit fields in the Device Control
+ * Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.
+ */
+typedef union dctl_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Remote Wakeup */
+		unsigned rmtwkupsig : 1;
+		/** Soft Disconnect */
+		unsigned sftdiscon : 1;
+		/** Global Non-Periodic IN NAK Status */
+		unsigned gnpinnaksts : 1;
+		/** Global OUT NAK Status */
+		unsigned goutnaksts : 1;
+		/** Test Control */
+		unsigned tstctl : 3;
+		/** Set Global Non-Periodic IN NAK */
+		unsigned sgnpinnak : 1;
+		/** Clear Global Non-Periodic IN NAK */
+		unsigned cgnpinnak : 1;
+		/** Set Global OUT NAK */
+		unsigned sgoutnak : 1;
+		/** Clear Global OUT NAK */
+		unsigned cgoutnak : 1;
+
+		unsigned reserved : 21;
+	} b;
+} dctl_data_t;
+
+/**
+ * This union represents the bit fields in the Device Status
+ * Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.
+ */
+typedef union dsts_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Suspend Status */
+		unsigned suspsts : 1;
+		/** Enumerated Speed */
+		unsigned enumspd : 2;
+#define DWC_DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ 0
+#define DWC_DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ 1
+#define DWC_DSTS_ENUMSPD_LS_PHY_6MHZ		   2
+#define DWC_DSTS_ENUMSPD_FS_PHY_48MHZ		   3
+		/** Erratic Error */
+		unsigned errticerr : 1;
+		unsigned reserved4_7: 4;
+		/** Frame or Microframe Number of the received SOF */
+		unsigned soffn : 14;
+		unsigned reserved22_31 : 10;
+	} b;
+} dsts_data_t;
+
+
+/**
+ * This union represents the bit fields in the Device IN EP Interrupt
+ * Register and the Device IN EP Common Mask Register.
+ *
+ * - Read the register into the <i>d32</i> member then set/clear the
+ *	 bits using the <i>b</i>it elements.
+ */
+typedef union diepint_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Transfer complete mask */
+		unsigned xfercompl : 1;
+		/** Endpoint disable mask */
+		unsigned epdisabled : 1;
+		/** AHB Error mask */
+		unsigned ahberr : 1;
+		/** TimeOUT Handshake mask (non-ISOC EPs) */
+		unsigned timeout : 1;
+		/** IN Token received with TxF Empty mask */
+		unsigned intktxfemp : 1;
+		/** IN Token Received with EP mismatch mask */
+		unsigned intknepmis : 1;
+		/** IN Endpoint HAK Effective mask */
+		unsigned inepnakeff : 1;
+		/** IN Endpoint HAK Effective mask */
+		unsigned emptyintr : 1;
+
+		unsigned txfifoundrn : 1;
+
+		unsigned reserved08_31 : 23;
+	} b;
+} diepint_data_t;
+/**
+ * This union represents the bit fields in the Device IN EP Common
+ * Interrupt Mask Register.
+ */
+typedef union diepint_data diepmsk_data_t;
+
+/**
+ * This union represents the bit fields in the Device OUT EP Interrupt
+ * Registerand Device OUT EP Common Interrupt Mask Register.
+ *
+ * - Read the register into the <i>d32</i> member then set/clear the
+ *	 bits using the <i>b</i>it elements.
+ */
+typedef union doepint_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Transfer complete */
+		unsigned xfercompl : 1;
+		/** Endpoint disable  */
+		unsigned epdisabled : 1;
+		/** AHB Error */
+		unsigned ahberr : 1;
+		/** Setup Phase Done (contorl EPs) */
+		unsigned setup : 1;
+		unsigned reserved04_31 : 28;
+	} b;
+} doepint_data_t;
+/**
+ * This union represents the bit fields in the Device OUT EP Common
+ * Interrupt Mask Register.
+ */
+typedef union doepint_data doepmsk_data_t;
+
+
+/**
+ * This union represents the bit fields in the Device All EP Interrupt
+ * and Mask Registers.
+ * - Read the register into the <i>d32</i> member then set/clear the
+ *	 bits using the <i>b</i>it elements.
+ */
+typedef union daint_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** IN Endpoint bits */
+		unsigned in : 16;
+		/** OUT Endpoint bits */
+		unsigned out : 16;
+	} ep;
+	struct
+	{
+		/** IN Endpoint bits */
+		unsigned inep0	: 1;
+		unsigned inep1	: 1;
+		unsigned inep2	: 1;
+		unsigned inep3	: 1;
+		unsigned inep4	: 1;
+		unsigned inep5	: 1;
+		unsigned inep6	: 1;
+		unsigned inep7	: 1;
+		unsigned inep8	: 1;
+		unsigned inep9	: 1;
+		unsigned inep10 : 1;
+		unsigned inep11 : 1;
+		unsigned inep12 : 1;
+		unsigned inep13 : 1;
+		unsigned inep14 : 1;
+		unsigned inep15 : 1;
+		/** OUT Endpoint bits */
+		unsigned outep0	 : 1;
+		unsigned outep1	 : 1;
+		unsigned outep2	 : 1;
+		unsigned outep3	 : 1;
+		unsigned outep4	 : 1;
+		unsigned outep5	 : 1;
+		unsigned outep6	 : 1;
+		unsigned outep7	 : 1;
+		unsigned outep8	 : 1;
+		unsigned outep9	 : 1;
+		unsigned outep10 : 1;
+		unsigned outep11 : 1;
+		unsigned outep12 : 1;
+		unsigned outep13 : 1;
+		unsigned outep14 : 1;
+		unsigned outep15 : 1;
+	} b;
+} daint_data_t;
+
+/**
+ * This union represents the bit fields in the Device IN Token Queue
+ * Read Registers.
+ * - Read the register into the <i>d32</i> member.
+ * - READ-ONLY Register
+ */
+typedef union dtknq1_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** In Token Queue Write Pointer */
+		unsigned intknwptr : 5;
+		/** Reserved */
+		unsigned reserved05_06 : 2;
+		/** write pointer has wrapped. */
+		unsigned wrap_bit : 1;
+		/** EP Numbers of IN Tokens 0 ... 4 */
+		unsigned epnums0_5 : 24;
+	} b;
+} dtknq1_data_t;
+
+/**
+ * This union represents Threshold control Register
+ * - Read and write the register into the <i>d32</i> member.
+ * - READ-WRITABLE Register
+ */
+typedef union dthrctl_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** non ISO Tx Thr. Enable */
+		unsigned non_iso_thr_en : 1;
+		/** ISO Tx Thr. Enable */
+		unsigned iso_thr_en : 1;
+		/** Tx Thr. Length */
+		unsigned tx_thr_len : 9;
+		/** Reserved */
+		unsigned reserved11_15 : 5;
+		/** Rx Thr. Enable */
+		unsigned rx_thr_en : 1;
+		/** Rx Thr. Length */
+		unsigned rx_thr_len : 9;
+		/** Reserved */
+		unsigned reserved26 : 1;
+		/** Arbiter Parking Enable */ //AlenOh
+		unsigned arb_prk_en : 1;
+		/** Reserved */ //AlenOh
+		unsigned reservied28_31 : 4;
+	} b;
+} dthrctl_data_t;
+
+
+/**
+ * Device Logical IN Endpoint-Specific Registers. <i>Offsets
+ * 900h-AFCh</i>
+ *
+ * There will be one set of endpoint registers per logical endpoint
+ * implemented.
+ *
+ * <i>These registers are visible only in Device mode and must not be
+ * accessed in Host mode, as the results are unknown.</i>
+ */
+typedef struct dwc_otg_dev_in_ep_regs
+{
+	/** Device IN Endpoint Control Register. <i>Offset:900h +
+	 * (ep_num * 20h) + 00h</i> */
+	volatile uint32_t diepctl;
+	/** Reserved. <i>Offset:900h + (ep_num * 20h) + 04h</i> */
+	uint32_t reserved04;
+	/** Device IN Endpoint Interrupt Register. <i>Offset:900h +
+	 * (ep_num * 20h) + 08h</i> */
+	volatile uint32_t diepint;
+	/** Reserved. <i>Offset:900h + (ep_num * 20h) + 0Ch</i> */
+	uint32_t reserved0C;
+	/** Device IN Endpoint Transfer Size
+	 * Register. <i>Offset:900h + (ep_num * 20h) + 10h</i> */
+	volatile uint32_t dieptsiz;
+	/** Device IN Endpoint DMA Address Register. <i>Offset:900h +
+	 * (ep_num * 20h) + 14h</i> */
+	volatile uint32_t diepdma;
+	/** Device IN Endpoint Transmit FIFO Status Register. <i>Offset:900h +
+	 * (ep_num * 20h) + 18h</i> */
+	volatile uint32_t dtxfsts;
+	/** Reserved. <i>Offset:900h + (ep_num * 20h) + 1Ch - 900h +
+	 * (ep_num * 20h) + 1Ch</i>*/
+	uint32_t reserved18;
+} dwc_otg_dev_in_ep_regs_t;
+
+/**
+ * Device Logical OUT Endpoint-Specific Registers. <i>Offsets:
+ * B00h-CFCh</i>
+ *
+ * There will be one set of endpoint registers per logical endpoint
+ * implemented.
+ *
+ * <i>These registers are visible only in Device mode and must not be
+ * accessed in Host mode, as the results are unknown.</i>
+ */
+typedef struct dwc_otg_dev_out_ep_regs
+{
+	/** Device OUT Endpoint Control Register. <i>Offset:B00h +
+	 * (ep_num * 20h) + 00h</i> */
+	volatile uint32_t doepctl;
+	/** Device OUT Endpoint Frame number Register.	<i>Offset:
+	 * B00h + (ep_num * 20h) + 04h</i> */
+	volatile uint32_t doepfn;
+	/** Device OUT Endpoint Interrupt Register. <i>Offset:B00h +
+	 * (ep_num * 20h) + 08h</i> */
+	volatile uint32_t doepint;
+	/** Reserved. <i>Offset:B00h + (ep_num * 20h) + 0Ch</i> */
+	uint32_t reserved0C;
+	/** Device OUT Endpoint Transfer Size Register. <i>Offset:
+	 * B00h + (ep_num * 20h) + 10h</i> */
+	volatile uint32_t doeptsiz;
+	/** Device OUT Endpoint DMA Address Register. <i>Offset:B00h
+	 * + (ep_num * 20h) + 14h</i> */
+	volatile uint32_t doepdma;
+	/** Reserved. <i>Offset:B00h + (ep_num * 20h) + 18h - B00h +
+	 * (ep_num * 20h) + 1Ch</i> */
+	uint32_t unused[2];
+} dwc_otg_dev_out_ep_regs_t;
+
+/**
+ * This union represents the bit fields in the Device EP Control
+ * Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.
+ */
+typedef union depctl_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Maximum Packet Size
+		 * IN/OUT EPn
+		 * IN/OUT EP0 - 2 bits
+		 *	 2'b00: 64 Bytes
+		 *	 2'b01: 32
+		 *	 2'b10: 16
+		 *	 2'b11: 8 */
+		unsigned mps : 11;
+#define DWC_DEP0CTL_MPS_64	 0
+#define DWC_DEP0CTL_MPS_32	 1
+#define DWC_DEP0CTL_MPS_16	 2
+#define DWC_DEP0CTL_MPS_8	 3
+
+		/** Next Endpoint
+		 * IN EPn/IN EP0
+		 * OUT EPn/OUT EP0 - reserved */
+		unsigned nextep : 4;
+
+		/** USB Active Endpoint */
+		unsigned usbactep : 1;
+
+		/** Endpoint DPID (INTR/Bulk IN and OUT endpoints)
+		 * This field contains the PID of the packet going to
+		 * be received or transmitted on this endpoint. The
+		 * application should program the PID of the first
+		 * packet going to be received or transmitted on this
+		 * endpoint , after the endpoint is
+		 * activated. Application use the SetD1PID and
+		 * SetD0PID fields of this register to program either
+		 * D0 or D1 PID.
+		 *
+		 * The encoding for this field is
+		 *	 - 0: D0
+		 *	 - 1: D1
+		 */
+		unsigned dpid : 1;
+
+		/** NAK Status */
+		unsigned naksts : 1;
+
+		/** Endpoint Type
+		 *	2'b00: Control
+		 *	2'b01: Isochronous
+		 *	2'b10: Bulk
+		 *	2'b11: Interrupt */
+		unsigned eptype : 2;
+
+		/** Snoop Mode
+		 * OUT EPn/OUT EP0
+		 * IN EPn/IN EP0 - reserved */
+		unsigned snp : 1;
+
+		/** Stall Handshake */
+		unsigned stall : 1;
+
+		/** Tx Fifo Number
+		 * IN EPn/IN EP0
+		 * OUT EPn/OUT EP0 - reserved */
+		unsigned txfnum : 4;
+
+		/** Clear NAK */
+		unsigned cnak : 1;
+		/** Set NAK */
+		unsigned snak : 1;
+		/** Set DATA0 PID (INTR/Bulk IN and OUT endpoints)
+		 * Writing to this field sets the Endpoint DPID (DPID)
+		 * field in this register to DATA0. Set Even
+		 * (micro)frame (SetEvenFr) (ISO IN and OUT Endpoints)
+		 * Writing to this field sets the Even/Odd
+		 * (micro)frame (EO_FrNum) field to even (micro)
+		 * frame.
+		 */
+		unsigned setd0pid : 1;
+		/** Set DATA1 PID (INTR/Bulk IN and OUT endpoints)
+		 * Writing to this field sets the Endpoint DPID (DPID)
+		 * field in this register to DATA1 Set Odd
+		 * (micro)frame (SetOddFr) (ISO IN and OUT Endpoints)
+		 * Writing to this field sets the Even/Odd
+		 * (micro)frame (EO_FrNum) field to odd (micro) frame.
+		 */
+		unsigned setd1pid : 1;
+
+		/** Endpoint Disable */
+		unsigned epdis : 1;
+		/** Endpoint Enable */
+		unsigned epena : 1;
+	} b;
+} depctl_data_t;
+
+/**
+ * This union represents the bit fields in the Device EP Transfer
+ * Size Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.
+ */
+typedef union deptsiz_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		/** Transfer size */
+		unsigned xfersize : 19;
+		/** Packet Count */
+		unsigned pktcnt : 10;
+		/** Multi Count - Periodic IN endpoints */
+		unsigned mc : 2;
+		unsigned reserved : 1;
+	} b;
+} deptsiz_data_t;
+
+/**
+ * This union represents the bit fields in the Device EP 0 Transfer
+ * Size Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.
+ */
+typedef union deptsiz0_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		/** Transfer size */
+		unsigned xfersize : 7;
+		/** Reserved */
+		unsigned reserved7_18 : 12;
+		/** Packet Count */
+		unsigned pktcnt : 1;
+		/** Reserved */
+		unsigned reserved20_28 : 9;
+		/**Setup Packet Count (DOEPTSIZ0 Only) */
+		unsigned supcnt : 2;
+		unsigned reserved31;
+	} b;
+} deptsiz0_data_t;
+
+
+/** Maximum number of Periodic FIFOs */
+#define MAX_PERIO_FIFOS 15
+/** Maximum number of Periodic FIFOs */
+#define MAX_TX_FIFOS 15
+
+/** Maximum number of Endpoints/HostChannels */
+#define MAX_EPS_CHANNELS 16
+
+/**
+ * The dwc_otg_dev_if structure contains information needed to manage
+ * the DWC_otg controller acting in device mode. It represents the
+ * programming view of the device-specific aspects of the controller.
+ */
+typedef struct dwc_otg_dev_if
+{
+	/** Pointer to device Global registers.
+	 * Device Global Registers starting at offset 800h
+	 */
+	dwc_otg_device_global_regs_t *dev_global_regs;
+#define DWC_DEV_GLOBAL_REG_OFFSET 0x800
+
+	/**
+	 * Device Logical IN Endpoint-Specific Registers 900h-AFCh
+	 */
+	dwc_otg_dev_in_ep_regs_t	 *in_ep_regs[MAX_EPS_CHANNELS];
+#define DWC_DEV_IN_EP_REG_OFFSET 0x900
+#define DWC_EP_REG_OFFSET 0x20
+
+	/** Device Logical OUT Endpoint-Specific Registers B00h-CFCh */
+	dwc_otg_dev_out_ep_regs_t	 *out_ep_regs[MAX_EPS_CHANNELS];
+#define DWC_DEV_OUT_EP_REG_OFFSET 0xB00
+
+	/* Device configuration information*/
+	uint8_t	 speed;				 /**< Device Speed	0: Unknown, 1: LS, 2:FS, 3: HS */
+	uint8_t	 num_in_eps;		 /**< Number # of Tx EP range: 0-15 exept ep0 */
+	uint8_t	 num_out_eps;		 /**< Number # of Rx EP range: 0-15 exept ep 0*/
+
+	/** Size of periodic FIFOs (Bytes) */
+	uint16_t perio_tx_fifo_size[MAX_PERIO_FIFOS];
+
+	/** Size of Tx FIFOs (Bytes) */
+	uint16_t tx_fifo_size[MAX_TX_FIFOS];
+
+	/** Thresholding enable flags and length varaiables **/
+	uint16_t rx_thr_en;
+	uint16_t iso_tx_thr_en;
+	uint16_t non_iso_tx_thr_en;
+
+	uint16_t rx_thr_length;
+	uint16_t tx_thr_length;
+
+} dwc_otg_dev_if_t;
+
+
+
+
+/////////////////////////////////////////////////
+// Host Mode Register Structures
+//
+/**
+ * The Host Global Registers structure defines the size and relative
+ * field offsets for the Host Mode Global Registers.  Host Global
+ * Registers offsets 400h-7FFh.
+*/
+typedef struct dwc_otg_host_global_regs
+{
+	/** Host Configuration Register.   <i>Offset: 400h</i> */
+	volatile uint32_t hcfg;
+	/** Host Frame Interval Register.	<i>Offset: 404h</i> */
+	volatile uint32_t hfir;
+	/** Host Frame Number / Frame Remaining Register. <i>Offset: 408h</i> */
+	volatile uint32_t hfnum;
+	/** Reserved.	<i>Offset: 40Ch</i> */
+	uint32_t reserved40C;
+	/** Host Periodic Transmit FIFO/ Queue Status Register. <i>Offset: 410h</i> */
+	volatile uint32_t hptxsts;
+	/** Host All Channels Interrupt Register. <i>Offset: 414h</i> */
+	volatile uint32_t haint;
+	/** Host All Channels Interrupt Mask Register. <i>Offset: 418h</i> */
+	volatile uint32_t haintmsk;
+} dwc_otg_host_global_regs_t;
+
+/**
+ * This union represents the bit fields in the Host Configuration Register.
+ * Read the register into the <i>d32</i> member then set/clear the bits using
+ * the <i>b</i>it elements. Write the <i>d32</i> member to the hcfg register.
+ */
+typedef union hcfg_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		/** FS/LS Phy Clock Select */
+		unsigned fslspclksel : 2;
+#define DWC_HCFG_30_60_MHZ 0
+#define DWC_HCFG_48_MHZ	   1
+#define DWC_HCFG_6_MHZ	   2
+
+		/** FS/LS Only Support */
+		unsigned fslssupp : 1;
+	} b;
+} hcfg_data_t;
+
+/**
+ * This union represents the bit fields in the Host Frame Remaing/Number
+ * Register.
+ */
+typedef union hfir_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		unsigned frint : 16;
+		unsigned reserved : 16;
+	} b;
+} hfir_data_t;
+
+/**
+ * This union represents the bit fields in the Host Frame Remaing/Number
+ * Register.
+ */
+typedef union hfnum_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		unsigned frnum : 16;
+#define DWC_HFNUM_MAX_FRNUM 0x3FFF
+		unsigned frrem : 16;
+	} b;
+} hfnum_data_t;
+
+typedef union hptxsts_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		unsigned ptxfspcavail : 16;
+		unsigned ptxqspcavail : 8;
+		/** Top of the Periodic Transmit Request Queue
+		 *	- bit 24 - Terminate (last entry for the selected channel)
+		 *	- bits 26:25 - Token Type
+		 *	  - 2'b00 - Zero length
+		 *	  - 2'b01 - Ping
+		 *	  - 2'b10 - Disable
+		 *	- bits 30:27 - Channel Number
+		 *	- bit 31 - Odd/even microframe
+		 */
+		unsigned ptxqtop_terminate : 1;
+		unsigned ptxqtop_token : 2;
+		unsigned ptxqtop_chnum : 4;
+		unsigned ptxqtop_odd : 1;
+	} b;
+} hptxsts_data_t;
+
+/**
+ * This union represents the bit fields in the Host Port Control and Status
+ * Register. Read the register into the <i>d32</i> member then set/clear the
+ * bits using the <i>b</i>it elements. Write the <i>d32</i> member to the
+ * hprt0 register.
+ */
+typedef union hprt0_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned prtconnsts : 1;
+		unsigned prtconndet : 1;
+		unsigned prtena : 1;
+		unsigned prtenchng : 1;
+		unsigned prtovrcurract : 1;
+		unsigned prtovrcurrchng : 1;
+		unsigned prtres : 1;
+		unsigned prtsusp : 1;
+		unsigned prtrst : 1;
+		unsigned reserved9 : 1;
+		unsigned prtlnsts : 2;
+		unsigned prtpwr : 1;
+		unsigned prttstctl : 4;
+		unsigned prtspd : 2;
+#define DWC_HPRT0_PRTSPD_HIGH_SPEED 0
+#define DWC_HPRT0_PRTSPD_FULL_SPEED 1
+#define DWC_HPRT0_PRTSPD_LOW_SPEED	2
+		unsigned reserved19_31 : 13;
+	} b;
+} hprt0_data_t;
+
+/**
+ * This union represents the bit fields in the Host All Interrupt
+ * Register.
+ */
+typedef union haint_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned ch0 : 1;
+		unsigned ch1 : 1;
+		unsigned ch2 : 1;
+		unsigned ch3 : 1;
+		unsigned ch4 : 1;
+		unsigned ch5 : 1;
+		unsigned ch6 : 1;
+		unsigned ch7 : 1;
+		unsigned ch8 : 1;
+		unsigned ch9 : 1;
+		unsigned ch10 : 1;
+		unsigned ch11 : 1;
+		unsigned ch12 : 1;
+		unsigned ch13 : 1;
+		unsigned ch14 : 1;
+		unsigned ch15 : 1;
+		unsigned reserved : 16;
+	} b;
+
+	struct
+	{
+		unsigned chint : 16;
+		unsigned reserved : 16;
+	} b2;
+} haint_data_t;
+
+/**
+ * This union represents the bit fields in the Host All Interrupt
+ * Register.
+ */
+typedef union haintmsk_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		unsigned ch0 : 1;
+		unsigned ch1 : 1;
+		unsigned ch2 : 1;
+		unsigned ch3 : 1;
+		unsigned ch4 : 1;
+		unsigned ch5 : 1;
+		unsigned ch6 : 1;
+		unsigned ch7 : 1;
+		unsigned ch8 : 1;
+		unsigned ch9 : 1;
+		unsigned ch10 : 1;
+		unsigned ch11 : 1;
+		unsigned ch12 : 1;
+		unsigned ch13 : 1;
+		unsigned ch14 : 1;
+		unsigned ch15 : 1;
+		unsigned reserved : 16;
+	} b;
+
+	struct
+	{
+		unsigned chint : 16;
+		unsigned reserved : 16;
+	} b2;
+} haintmsk_data_t;
+
+/**
+ * Host Channel Specific Registers. <i>500h-5FCh</i>
+ */
+typedef struct dwc_otg_hc_regs
+{
+	/** Host Channel 0 Characteristic Register. <i>Offset: 500h + (chan_num * 20h) + 00h</i> */
+	volatile uint32_t hcchar;
+	/** Host Channel 0 Split Control Register. <i>Offset: 500h + (chan_num * 20h) + 04h</i> */
+	volatile uint32_t hcsplt;
+	/** Host Channel 0 Interrupt Register. <i>Offset: 500h + (chan_num * 20h) + 08h</i> */
+	volatile uint32_t hcint;
+	/** Host Channel 0 Interrupt Mask Register. <i>Offset: 500h + (chan_num * 20h) + 0Ch</i> */
+	volatile uint32_t hcintmsk;
+	/** Host Channel 0 Transfer Size Register. <i>Offset: 500h + (chan_num * 20h) + 10h</i> */
+	volatile uint32_t hctsiz;
+	/** Host Channel 0 DMA Address Register. <i>Offset: 500h + (chan_num * 20h) + 14h</i> */
+	volatile uint32_t hcdma;
+	/** Reserved.  <i>Offset: 500h + (chan_num * 20h) + 18h - 500h + (chan_num * 20h) + 1Ch</i> */
+	uint32_t reserved[2];
+} dwc_otg_hc_regs_t;
+
+/**
+ * This union represents the bit fields in the Host Channel Characteristics
+ * Register. Read the register into the <i>d32</i> member then set/clear the
+ * bits using the <i>b</i>it elements. Write the <i>d32</i> member to the
+ * hcchar register.
+ */
+typedef union hcchar_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		/** Maximum packet size in bytes */
+		unsigned mps : 11;
+
+		/** Endpoint number */
+		unsigned epnum : 4;
+
+		/** 0: OUT, 1: IN */
+		unsigned epdir : 1;
+
+		unsigned reserved : 1;
+
+		/** 0: Full/high speed device, 1: Low speed device */
+		unsigned lspddev : 1;
+
+		/** 0: Control, 1: Isoc, 2: Bulk, 3: Intr */
+		unsigned eptype : 2;
+
+		/** Packets per frame for periodic transfers. 0 is reserved. */
+		unsigned multicnt : 2;
+
+		/** Device address */
+		unsigned devaddr : 7;
+
+		/**
+		 * Frame to transmit periodic transaction.
+		 * 0: even, 1: odd
+		 */
+		unsigned oddfrm : 1;
+
+		/** Channel disable */
+		unsigned chdis : 1;
+
+		/** Channel enable */
+		unsigned chen : 1;
+	} b;
+} hcchar_data_t;
+
+typedef union hcsplt_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		/** Port Address */
+		unsigned prtaddr : 7;
+
+		/** Hub Address */
+		unsigned hubaddr : 7;
+
+		/** Transaction Position */
+		unsigned xactpos : 2;
+#define DWC_HCSPLIT_XACTPOS_MID 0
+#define DWC_HCSPLIT_XACTPOS_END 1
+#define DWC_HCSPLIT_XACTPOS_BEGIN 2
+#define DWC_HCSPLIT_XACTPOS_ALL 3
+
+		/** Do Complete Split */
+		unsigned compsplt : 1;
+
+		/** Reserved */
+		unsigned reserved : 14;
+
+		/** Split Enble */
+		unsigned spltena : 1;
+	} b;
+} hcsplt_data_t;
+
+
+/**
+ * This union represents the bit fields in the Host All Interrupt
+ * Register.
+ */
+typedef union hcint_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct
+	{
+		/** Transfer Complete */
+		unsigned xfercomp : 1;
+		/** Channel Halted */
+		unsigned chhltd : 1;
+		/** AHB Error */
+		unsigned ahberr : 1;
+		/** STALL Response Received */
+		unsigned stall : 1;
+		/** NAK Response Received */
+		unsigned nak : 1;
+		/** ACK Response Received */
+		unsigned ack : 1;
+		/** NYET Response Received */
+		unsigned nyet : 1;
+		/** Transaction Err */
+		unsigned xacterr : 1;
+		/** Babble Error */
+		unsigned bblerr : 1;
+		/** Frame Overrun */
+		unsigned frmovrun : 1;
+		/** Data Toggle Error */
+		unsigned datatglerr : 1;
+		/** Reserved */
+		unsigned reserved : 21;
+	} b;
+} hcint_data_t;
+
+/**
+ * This union represents the bit fields in the Host Channel Transfer Size
+ * Register. Read the register into the <i>d32</i> member then set/clear the
+ * bits using the <i>b</i>it elements. Write the <i>d32</i> member to the
+ * hcchar register.
+ */
+typedef union hctsiz_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		/** Total transfer size in bytes */
+		unsigned xfersize : 19;
+
+		/** Data packets to transfer */
+		unsigned pktcnt : 10;
+
+		/**
+		 * Packet ID for next data packet
+		 * 0: DATA0
+		 * 1: DATA2
+		 * 2: DATA1
+		 * 3: MDATA (non-Control), SETUP (Control)
+		 */
+		unsigned pid : 2;
+#define DWC_HCTSIZ_DATA0 0
+#define DWC_HCTSIZ_DATA1 2
+#define DWC_HCTSIZ_DATA2 1
+#define DWC_HCTSIZ_MDATA 3
+#define DWC_HCTSIZ_SETUP 3
+
+		/** Do PING protocol when 1 */
+		unsigned dopng : 1;
+	} b;
+} hctsiz_data_t;
+
+/**
+ * This union represents the bit fields in the Host Channel Interrupt Mask
+ * Register. Read the register into the <i>d32</i> member then set/clear the
+ * bits using the <i>b</i>it elements. Write the <i>d32</i> member to the
+ * hcintmsk register.
+ */
+typedef union hcintmsk_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		unsigned xfercompl : 1;
+		unsigned chhltd : 1;
+		unsigned ahberr : 1;
+		unsigned stall : 1;
+		unsigned nak : 1;
+		unsigned ack : 1;
+		unsigned nyet : 1;
+		unsigned xacterr : 1;
+		unsigned bblerr : 1;
+		unsigned frmovrun : 1;
+		unsigned datatglerr : 1;
+		unsigned reserved : 21;
+	} b;
+} hcintmsk_data_t;
+
+/** OTG Host Interface Structure.
+ *
+ * The OTG Host Interface Structure structure contains information
+ * needed to manage the DWC_otg controller acting in host mode. It
+ * represents the programming view of the host-specific aspects of the
+ * controller.
+ */
+typedef struct dwc_otg_host_if
+{
+	/** Host Global Registers starting at offset 400h.*/
+	dwc_otg_host_global_regs_t *host_global_regs;
+#define DWC_OTG_HOST_GLOBAL_REG_OFFSET 0x400
+
+	/** Host Port 0 Control and Status Register */
+	volatile uint32_t *hprt0;
+#define DWC_OTG_HOST_PORT_REGS_OFFSET 0x440
+
+
+	/** Host Channel Specific Registers at offsets 500h-5FCh. */
+	dwc_otg_hc_regs_t *hc_regs[MAX_EPS_CHANNELS];
+#define DWC_OTG_HOST_CHAN_REGS_OFFSET 0x500
+#define DWC_OTG_CHAN_REGS_OFFSET 0x20
+
+
+	/* Host configuration information */
+	/** Number of Host Channels (range: 1-16) */
+	uint8_t	 num_host_channels;
+	/** Periodic EPs supported (0: no, 1: yes) */
+	uint8_t	 perio_eps_supported;
+	/** Periodic Tx FIFO Size (Only 1 host periodic Tx FIFO) */
+	uint16_t perio_tx_fifo_size;
+
+} dwc_otg_host_if_t;
+
+
+/**
+ * This union represents the bit fields in the Power and Clock Gating Control
+ * Register. Read the register into the <i>d32</i> member then set/clear the
+ * bits using the <i>b</i>it elements.
+ */
+typedef union pcgcctl_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		/** Stop Pclk */
+		unsigned stoppclk : 1;
+		/** Gate Hclk */
+		unsigned gatehclk : 1;
+		/** Power Clamp */
+		unsigned pwrclmp : 1;
+		/** Reset Power Down Modules */
+		unsigned rstpdwnmodule : 1;
+		/** PHY Suspended */
+		unsigned physuspended : 1;
+
+		unsigned reserved : 27;
+	} b;
+} pcgcctl_data_t;
+
+
+#endif
Index: linux-2.6.29/drivers/usb/dwc_otg/tcc_usb_def.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/usb/dwc_otg/tcc_usb_def.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,59 @@
+/*
+ *
+ */
+#ifndef __TCC_USB_DEF_H__
+#define __TCC_USB_DEF_H__
+
+#include <bsp.h>
+
+//===================================================================
+//
+//		DRIVER SIGNATURE
+//
+//===================================================================
+#define SIGBYAHONG				'S','I','G','B','Y','A','H','O','N','G','_'
+
+#if defined(_WINCE_)
+#define SIGN_OS					'W','I','N','C','E','_'
+#elif defined(_LINUX_)
+#define SIGN_OS					'L','I','N','U','X','_'
+#else
+#define SIGN_OS					'N','U','_'
+#endif
+
+#if defined(TCC77X)
+#define SIGN_CHIPSET			'T','C','C','7','7','X','X','_'
+#elif defined(TCC78X)
+#define SIGN_CHIPSET			'T','C','C','7','8','X','X','_'
+#elif defined(TCC79X)
+#define SIGN_CHIPSET			'T','C','C','7','9','X','X','_'
+#elif defined(TCC81XX)
+#define SIGN_CHIPSET			'T','C','C','8','1','X','X','_'
+#elif defined(TCC82XX)
+#define SIGN_CHIPSET			'T','C','C','8','2','X','X','_'
+#elif defined(TCC83XX)
+#define SIGN_CHIPSET			'T','C','C','8','3','X','X','_'
+#elif defined(TCC87XX)
+#define SIGN_CHIPSET			'T','C','C','8','7','X','X','_'
+#elif defined(CONFIG_MACH_TCC8900)
+#define SIGN_CHIPSET			'T','C','C','8','9','X','X','_'
+#elif defined(TCC91XX)
+#define SIGN_CHIPSET			'T','C','C','9','1','X','X','_'
+#elif defined(TCC92XX)
+#define SIGN_CHIPSET			'T','C','C','9','2','X','X','_'
+#else
+#error
+#endif
+
+
+typedef enum {
+	USB_MODE_NONE,
+	USB_MODE_HOST,
+	USB_MODE_DEVICE
+} USB_MODE_T;
+
+
+#define pUSBPHYCFG		((PUSBPHYCFG)&HwUSBPHYCFG_BASE)
+#define pUSBOTGCFG		((PUSBOTGCFG)&HwUSBOTGCFG_BASE)
+
+#endif /*__TCC_USB_DEF_H__*/
Index: linux-2.6.29/drivers/usb/dwc_otg/tcc_usb_phy.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/usb/dwc_otg/tcc_usb_phy.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,181 @@
+/*
+ *
+ */
+#include <linux/kernel.h>
+#include <bsp.h>
+#include <mach/tcc_pca953x.h>
+#include "tcc_usb_def.h"
+#include "tcc_usb_phy.h"
+
+/* For Signature */
+#define TCC_USB_PHY_SIGNATURE			'T','C','C','_','U','S','B','_','P','H','Y','_'
+#define TCC_USB_PHY_VERSION				'V','2','.','0','0','0'
+static const unsigned char TCC_USB_PHY_C_Version[] =
+    {SIGBYAHONG, TCC_USB_PHY_SIGNATURE, SIGN_OS ,SIGN_CHIPSET, TCC_USB_PHY_VERSION, 0};
+
+#define	UPCR0_PR						Hw14					// (1:enable)/(0:disable) Port Reset
+#define	UPCR0_CM_EN						Hw13					// Common Block Power Down Enable
+#define	UPCR0_CM_DIS					~Hw13					// Common Block Power Down Disable
+#define	UPCR0_RCS_11					(Hw12+Hw11)				// Reference Clock Select for PLL Block ; The PLL uses CLKCORE as reference
+#define	UPCR0_RCS_10					Hw12					// Reference Clock Select for PLL Block ; The PLL uses CLKCORE as reference
+#define	UPCR0_RCS_01					Hw11					// Reference Clock Select for PLL Block ; The XO block uses an external clock supplied on the XO pin
+#define	UPCR0_RCS_00					((~Hw12)&(~Hw11))		// Reference Clock Select for PLL Block ; The XO block uses the clock from a crystal
+#define	UPCR0_RCD_48					Hw10					// Reference Clock Frequency Select ; 48MHz
+#define	UPCR0_RCD_24					Hw9						// Reference Clock Frequency Select ; 24MHz
+#define	UPCR0_RCD_12					((~Hw10)&(~Hw9))		// Reference Clock Frequency Select ; 12MHz
+#define	UPCR0_SDI_EN					Hw8						// IDDQ Test Enable ; The analog blocks are powered down
+#define	UPCR0_SDI_DIS					~Hw8					// IDDQ Test Disable ; The analog blocks are not powered down
+#define	UPCR0_FO_SI						Hw7						// UTMI/Serial Interface Select ; Serial Interface
+#define	UPCR0_FO_UTMI					~Hw7					// UTMI/Serial Interface Select ; UTMI
+#define UPCR0_VBDS						Hw6
+#define UPCR0_DMPD						Hw5						// 1:enable / 0:disable the pull-down resistance on D-
+#define UPCR0_DPPD						Hw4						// 1: enable, 0:disable the pull-down resistance on D+
+#define UPCR0_VBD						Hw1						// The VBUS signal is (1:valid)/(0:invalid), and the pull-up resistor on D+ is (1:enabled)/(0:disabled)
+
+#define UPCR1_TXFSLST(x)				((x&0xF)<<12)
+#define UPCR1_SQRXT(x)					((x&0x7)<<8)
+#define UPCR1_OTGT(x)					((x&0x7)<<4)
+#define UPCR1_CDT(x)					(x&0x7)
+
+#define UPCR2_TM_FS						Hw14
+#define UPCR2_TM_HS						0
+#define UPCR2_XCVRSEL_LS_ON_FS			(Hw13|Hw12)
+#define UPCR2_XCVRSEL_LS				Hw13
+#define UPCR2_XCVRSEL_FS				Hw12
+#define UPCR2_XCVRSEL_HS				0
+#define UPCR2_OPMODE_MASK				(Hw10|Hw9)
+#define UPCR2_OPMODE_SYNC_EOP			(Hw10|Hw9)
+#define UPCR2_OPMODE_DIS_BITS_NRZI		Hw10
+#define UPCR2_OPMODE_NON_DRVING			Hw9
+#define UPCR2_OPMODE_NORMAL				0
+#define UPCR2_TXVRT(x)					((x&0xF)<<5)
+#define UPCR2_TXRT(x)					((x&0x3)<<2)
+#define UPCR2_TP_EN						Hw0
+#define UPCR2_TP_DIS					0
+
+
+const unsigned char * USBPHY_GetVersion(void)
+{
+	return TCC_USB_PHY_C_Version;
+}
+
+void USBPHY_EnableClock(void)
+{
+	/* MODE=0 for USBOTG, SDI=0 for turn on all analog blocks */
+	BITCLR(pUSBPHYCFG->UPCR0, Hw15|Hw8);
+}
+
+void USBPHY_SetMode(USBPHY_MODE_T mode)
+{
+	/*if ( mode == USB_MODE_NONE )
+	{
+		pUSBPHYCFG->UPCR0	= 0x2940;	// float DP,PM pins
+	}
+	else*/ if ( mode == USBPHY_MODE_RESET )
+	{
+		pUSBPHYCFG->UPCR0	= 0x4870;
+	}
+	else if ( mode == USBPHY_MODE_HOST )
+	{
+		pUSBPHYCFG->UPCR0	= 0x2800;
+		pUSBPHYCFG->UPCR1	=
+		    UPCR1_TXFSLST(7)	// FS/LS Pull-Up Resistance Adjustment = Design default
+		    | UPCR1_SQRXT(3)	// Squelch Threshold Tune = -5%
+		    | UPCR1_OTGT(4)		// VBUS Valid Threshold Adjustment = Design default
+		    | UPCR1_CDT(3);		// Disconnect Threshold Adjustment = Design default
+		pUSBPHYCFG->UPCR2	=
+		    UPCR2_TM_HS
+		    | UPCR2_XCVRSEL_HS
+		    | UPCR2_OPMODE_NORMAL
+		    | UPCR2_TXVRT(8)	// HS DC voltage level adjustment = Design default
+		    | UPCR2_TXRT(0)		// HS Transmitter Rise/Fall Time Adjustment = Design default
+		    | UPCR2_TP_DIS;
+		//pUSBPHYCFG->UPCR3	= 0x9000;	// OTG disable
+	}
+	else if ( mode == USBPHY_MODE_DEVICE )
+	{
+		pUSBPHYCFG->UPCR0	= 0x2800;
+		pUSBPHYCFG->UPCR1	=
+		    UPCR1_TXFSLST(7)	// FS/LS Pull-Up Resistance Adjustment = Design default
+		    | UPCR1_SQRXT(3)	// Squelch Threshold Tune = -5%
+		    | UPCR1_OTGT(4)		// VBUS Valid Threshold Adjustment = Design default
+		    | UPCR1_CDT(3);		// Disconnect Threshold Adjustment = Design default
+		pUSBPHYCFG->UPCR2	=
+		    UPCR2_TM_HS
+		    | UPCR2_XCVRSEL_HS
+		    | UPCR2_OPMODE_NORMAL
+		    | UPCR2_TXVRT(8)	// HS DC voltage level adjustment = Design default
+		    | UPCR2_TXRT(0)		// HS Transmitter Rise/Fall Time Adjustment = Design default
+		    | UPCR2_TP_DIS;
+		//pUSBPHYCFG->UPCR3	= 0x9000;	// OTG disable
+	}
+}
+
+#ifndef OTGID_ID_HOST
+#define OTGID_ID_HOST						(~Hw9)
+#endif
+#ifndef OTGID_ID_DEVICE
+#define OTGID_ID_DEVICE						Hw9
+#endif
+void USBPHY_SetID(unsigned int ID)
+{
+	if ( ID ) {
+		pUSBOTGCFG->OTGID |= OTGID_ID_DEVICE;
+	} else {
+		pUSBOTGCFG->OTGID &= OTGID_ID_HOST;
+	}
+}
+
+/*
+ * OTG VBUS Power Control. It is controlled GPIO_EXPAND DVBUS_ON.
+ * - Host mode: DVBUS_ON is HIGH
+ * - Device mode: DVBUS_ON is LOW
+ */
+void TCC_DVBUS_Control(int on)
+{
+	if (on) {
+		tcc_pca953x_setup(PCA9538_U4_SLAVE_ADDR, PWR_GP1, OUTPUT, HIGH, SET_DIRECTION|SET_VALUE);
+		tcc_pca953x_setup(PCA9538_U4_SLAVE_ADDR, DVBUS_ON, OUTPUT, HIGH, SET_DIRECTION|SET_VALUE);
+	} else {
+		tcc_pca953x_setup(PCA9538_U4_SLAVE_ADDR, DVBUS_ON, OUTPUT, LOW, SET_DIRECTION|SET_VALUE);
+#if !defined(CONFIG_USB_OHCI_HCD) && !defined(CONFIG_USB_OHCI_HCD_MODULE)
+		tcc_pca953x_setup(PCA9538_U4_SLAVE_ADDR, PWR_GP1, OUTPUT, LOW, SET_DIRECTION|SET_VALUE);
+#endif
+	}
+	printk(KERN_DEBUG "DVBUS_ON power %s\n", (tcc_pca953x_setup(PCA9538_U4_SLAVE_ADDR, 0, OUTPUT, 0, GET_VALUE)&DVBUS_ON)?"ON":"OFF");
+	printk(KERN_DEBUG "PWR_GP1  power %s\n", (tcc_pca953x_setup(PCA9538_U4_SLAVE_ADDR, 0, OUTPUT, 0, GET_VALUE)&PWR_GP1)?"ON":"OFF");
+}
+
+/*
+ * USBPHY Power on/off
+ */
+void USBPHY_Off(void)
+{
+#if 0
+	BITCSET(pUSBPHYCFG->UPCR2, Hw10|Hw9/*UPCR2_OPMODE_MASK*/, Hw9/*UPCR2_OPMODE_NON_DRVING*/);
+	pUSBPHYCFG->UPCR0 = 0x4840;
+	pUSBPHYCFG->UPCR0 = 0x6940;
+#else
+	BITSET(pUSBPHYCFG->UPCR0, Hw8);
+#endif
+}
+
+void USBPHY_On(void)
+{
+#if 0
+	BITCSET(pUSBPHYCFG->UPCR2, Hw10|Hw9/*UPCR2_OPMODE_MASK*/, 0/*UPCR2_OPMODE_NORMAL*/);
+	pUSBPHYCFG->UPCR0 = 0x2842; /* TODO: 0x2800 */
+#else
+	BITCLR(pUSBPHYCFG->UPCR0, Hw8);
+#endif
+
+}
+
+//void TCC_SetIntr(void)
+//{
+//	BITCLR(HwPIC->POL1, HwINT1_UOTG);		// 0:active-high / 1:active-low
+//	BITSET(HwPIC->MODE1, HwINT1_UOTG);		// 1:Level / 0:edge trigger
+//	//BITCLR(HwPIC->MODEA1, HwINT1_UOTG);	// 0:single edge / 1:both edge
+//}
+
+/* end of file */
Index: linux-2.6.29/drivers/usb/dwc_otg/tcc_usb_phy.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/usb/dwc_otg/tcc_usb_phy.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,24 @@
+/*
+ *
+ */
+#ifndef __TCC_USB_PHY_H__
+#define __TCC_USB_PHY_H__
+
+#include "tcc_usb_def.h"
+
+typedef enum {
+	USBPHY_MODE_RESET,
+	USBPHY_MODE_HOST,
+	USBPHY_MODE_DEVICE
+} USBPHY_MODE_T;
+
+extern const unsigned char * USBPHY_GetVersion(void);
+extern void USBPHY_EnableClock(void);
+extern void USBPHY_SetMode(USBPHY_MODE_T mode);
+void USBPHY_DEVICE_VBUS(unsigned int valid);
+extern void USBPHY_SetID(unsigned int ID);
+extern void TCC_DVBUS_Control(int on);
+extern void USBPHY_On(void);
+extern void USBPHY_Off(void);
+
+#endif /*__TCC_USB_PHY_H__*/
\ No newline at end of file
Index: linux-2.6.29/drivers/usb/gadget/Kconfig
===================================================================
--- linux-2.6.29.orig/drivers/usb/gadget/Kconfig	2010-04-07 12:29:34.000000000 -0400
+++ linux-2.6.29/drivers/usb/gadget/Kconfig	2010-04-07 12:29:36.000000000 -0400
@@ -15,6 +15,7 @@
 
 menuconfig USB_GADGET
 	tristate "USB Gadget Support"
+	depends on TCC_DWC_OTG_DUAL_ROLE && TCC_DWC_OTG_DEVICE_ONLY
 	help
 	   USB is a master/slave protocol, organized with one master
 	   host (such as a PC) controlling up to 127 peripheral devices.
@@ -119,6 +120,23 @@
 	   often need board-specific hooks.
 
 #
+# Telechips USB DWC OTG Controller
+#
+config USB_GADGET_TCC_OTG
+	boolean "Telechips USB DWC OTG Device Controller"
+	depends on ARCH_TCC && TCC_DWC_OTG
+	select USB_GADGET_SELECTED
+	select USB_GADGET_DUALSPEED
+	help
+	   Telechips USB OTG Device Controller Driver
+	   Synopsys DesignWare Hi-Speed USB On-The-Go (OTG) Core used on the Telechips SoC.
+
+config USB_TCC_OTG
+	tristate
+	depends on USB_GADGET_TCC_OTG
+	default USB_GADGET
+	
+#
 # Integrated controllers
 #
 
Index: linux-2.6.29/drivers/usb/gadget/Makefile
===================================================================
--- linux-2.6.29.orig/drivers/usb/gadget/Makefile	2010-04-07 12:29:34.000000000 -0400
+++ linux-2.6.29/drivers/usb/gadget/Makefile	2010-04-07 12:29:36.000000000 -0400
@@ -3,6 +3,7 @@
 #
 ifeq ($(CONFIG_USB_GADGET_DEBUG),y)
 	EXTRA_CFLAGS		+= -DDEBUG
+	EXTRA_CFLAGS		+= -O0
 endif
 
 obj-$(CONFIG_USB_DUMMY_HCD)	+= dummy_hcd.o
Index: linux-2.6.29/drivers/usb/gadget/file_storage.c
===================================================================
--- linux-2.6.29.orig/drivers/usb/gadget/file_storage.c	2010-04-07 12:29:34.000000000 -0400
+++ linux-2.6.29/drivers/usb/gadget/file_storage.c	2010-04-07 12:29:36.000000000 -0400
@@ -247,13 +247,15 @@
 #include <linux/string.h>
 #include <linux/freezer.h>
 #include <linux/utsname.h>
+#include <linux/dma-mapping.h>
 
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
 
 #include "gadget_chips.h"
 
-
+#include <bsp.h>
+#include <linux/tcc_ioctl.h>
 
 /*
  * Kbuild is not very cooperative with respect to linking separately
@@ -283,9 +285,15 @@
  *
  * DO NOT REUSE THESE IDs with any other driver!!  Ever!!
  * Instead:  allocate your own, using normal USB-IF procedures. */
+#ifdef CONFIG_ARCH_TCC
+#define DRIVER_VENDOR_ID	0x140e	// Telechips
+#define DRIVER_PRODUCT_ID	0xb058	// TCC79x MSC
+#else
 #define DRIVER_VENDOR_ID	0x0525	// NetChip
 #define DRIVER_PRODUCT_ID	0xa4a5	// Linux-USB File-backed Storage Gadget
+#endif
 
+#define DMA_MODE
 
 /*
  * This driver assumes self-powered hardware and has no way for users to
@@ -341,14 +349,18 @@
 
 #define MAX_LUNS	8
 
+/* Number of buffers we will use.  2 is enough for double-buffering */
+#define NUM_BUFFERS	2
+
 static struct {
-	char		*file[MAX_LUNS];
-	int		ro[MAX_LUNS];
+	char			*file[MAX_LUNS];
+	int				ro[MAX_LUNS];
+	int				can_ioctl[MAX_LUNS];
+	int				removable[MAX_LUNS];
 	unsigned int	num_filenames;
 	unsigned int	num_ros;
 	unsigned int	nluns;
 
-	int		removable;
 	int		can_stall;
 	int		cdrom;
 
@@ -365,9 +377,18 @@
 	char		*protocol_name;
 
 } mod_data = {					// Default values
+#ifdef CONFIG_ARCH_TCC
+	.file			= {"/dev/ndda1", "", "", "", ""},
+	.can_ioctl		= {0, 0, 0, 0, 0},
+	.ro				= {0, 0, 0, 0, 0},
+	.removable		= {1, 1, 1, 1, 1},
+	.num_filenames	= 5,
+	.num_ros		= 5,
+	.nluns			= 5,
+#endif
+
 	.transport_parm		= "BBB",
 	.protocol_parm		= "SCSI",
-	.removable		= 0,
 	.can_stall		= 1,
 	.cdrom			= 0,
 	.vendor			= DRIVER_VENDOR_ID,
@@ -376,7 +397,7 @@
 	.buflen			= 16384,
 	};
 
-
+#ifndef CONFIG_ARCH_TCC
 module_param_array_named(file, mod_data.file, charp, &mod_data.num_filenames,
 		S_IRUGO);
 MODULE_PARM_DESC(file, "names of backing files or devices");
@@ -387,11 +408,12 @@
 module_param_named(luns, mod_data.nluns, uint, S_IRUGO);
 MODULE_PARM_DESC(luns, "number of LUNs");
 
-module_param_named(removable, mod_data.removable, bool, S_IRUGO);
-MODULE_PARM_DESC(removable, "true to simulate removable media");
+//module_param_named(removable, mod_data.removable, bool, S_IRUGO);
+//MODULE_PARM_DESC(removable, "true to simulate removable media");
 
 module_param_named(stall, mod_data.can_stall, bool, S_IRUGO);
 MODULE_PARM_DESC(stall, "false to prevent bulk stalls");
+#endif
 
 module_param_named(cdrom, mod_data.cdrom, bool, S_IRUGO);
 MODULE_PARM_DESC(cdrom, "true to emulate cdrom instead of disk");
@@ -570,6 +592,8 @@
 	loff_t		num_sectors;
 
 	unsigned int	ro : 1;
+	unsigned int	can_ioctl : 1;
+	unsigned int	removable : 1;
 	unsigned int	prevent_medium_removal : 1;
 	unsigned int	registered : 1;
 	unsigned int	info_valid : 1;
@@ -593,9 +617,6 @@
 #define EP0_BUFSIZE	256
 #define DELAYED_STATUS	(EP0_BUFSIZE + 999)	// An impossibly large value
 
-/* Number of buffers we will use.  2 is enough for double-buffering */
-#define NUM_BUFFERS	2
-
 enum fsg_buffer_state {
 	BUF_STATE_EMPTY = 0,
 	BUF_STATE_FULL,
@@ -604,6 +625,9 @@
 
 struct fsg_buffhd {
 	void				*buf;
+	#ifdef DMA_MODE
+	dma_addr_t			dma;	//for dma (AlenOh)
+	#endif
 	enum fsg_buffer_state		state;
 	struct fsg_buffhd		*next;
 
@@ -1016,7 +1040,11 @@
 /* The CBI specification limits the serial string to 12 uppercase hexadecimal
  * characters. */
 static char				manufacturer[64];
+#ifdef CONFIG_ARCH_TCC
+static char				serial[]="0123456789ABCDEF0123456789ABCDEF";
+#else
 static char				serial[13];
+#endif
 
 /* Static strings, in UTF-8 (for simplicity we use only ASCII characters) */
 static struct usb_string		strings[] = {
@@ -1487,7 +1515,9 @@
 	dump_msg(fsg, "ep0-setup", (u8 *) ctrl, sizeof(*ctrl));
 
 	if ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_CLASS)
+	{
 		rc = class_setup_req(fsg, ctrl);
+	}
 	else
 		rc = standard_setup_req(fsg, ctrl);
 
@@ -1619,10 +1649,13 @@
 		amount = min((unsigned int) amount_left, mod_data.buflen);
 		amount = min((loff_t) amount,
 				curlun->file_length - file_offset);
-		partial_page = file_offset & (PAGE_CACHE_SIZE - 1);
-		if (partial_page > 0)
-			amount = min(amount, (unsigned int) PAGE_CACHE_SIZE -
-					partial_page);
+
+		if (curlun->can_ioctl==0)
+		{
+			partial_page = file_offset & (PAGE_CACHE_SIZE - 1);
+			if (partial_page > 0)
+				amount = min(amount, (unsigned int) PAGE_CACHE_SIZE - partial_page);
+		}
 
 		/* Wait for the next buffer to become available */
 		bh = fsg->next_buffhd_to_fill;
@@ -1646,9 +1679,25 @@
 
 		/* Perform the read */
 		file_offset_tmp = file_offset;
-		nread = vfs_read(curlun->filp,
-				(char __user *) bh->buf,
-				amount, &file_offset_tmp);
+		if(curlun->can_ioctl)
+		{
+			struct storage_direct sdArg;
+			sdArg.buf = bh->buf;
+			sdArg.count = (size_t)amount;
+			sdArg.pos = file_offset_tmp;
+			sdArg.actual = 0;
+			sdArg.user_space = 0;
+			if(curlun->filp->f_op->unlocked_ioctl)
+				curlun->filp->f_op->unlocked_ioctl(curlun->filp, IOCTL_STORAGE_DIRECT_READ, (unsigned long)&sdArg);
+			file_offset_tmp = sdArg.pos;
+			nread = sdArg.actual;
+		}
+		else
+		{
+			nread = vfs_read(curlun->filp,
+					(char __user *) bh->buf,
+					amount, &file_offset_tmp);
+		}
 		VLDBG(curlun, "file read %u @ %llu -> %d\n", amount,
 				(unsigned long long) file_offset,
 				(int) nread);
@@ -1759,10 +1808,13 @@
 			amount = min(amount_left_to_req, mod_data.buflen);
 			amount = min((loff_t) amount, curlun->file_length -
 					usb_offset);
-			partial_page = usb_offset & (PAGE_CACHE_SIZE - 1);
-			if (partial_page > 0)
-				amount = min(amount,
-	(unsigned int) PAGE_CACHE_SIZE - partial_page);
+
+			if (curlun->can_ioctl==0)
+			{
+				partial_page = usb_offset & (PAGE_CACHE_SIZE - 1);
+				if (partial_page > 0)
+					amount = min(amount, (unsigned int) PAGE_CACHE_SIZE - partial_page);
+			}
 
 			if (amount == 0) {
 				get_some_more = 0;
@@ -1819,17 +1871,35 @@
 			amount = bh->outreq->actual;
 			if (curlun->file_length - file_offset < amount) {
 				LERROR(curlun,
-	"write %u @ %llu beyond end %llu\n",
-	amount, (unsigned long long) file_offset,
-	(unsigned long long) curlun->file_length);
-				amount = curlun->file_length - file_offset;
+						"write %u @ %llu beyond end %llu\n",
+						amount, (unsigned long long) file_offset,
+						(unsigned long long) curlun->file_length);
+									amount = curlun->file_length - file_offset;
 			}
 
 			/* Perform the write */
 			file_offset_tmp = file_offset;
-			nwritten = vfs_write(curlun->filp,
-					(char __user *) bh->buf,
-					amount, &file_offset_tmp);
+
+			if(curlun->can_ioctl)
+			{
+				struct storage_direct sdArg;
+				sdArg.buf = bh->buf;
+				sdArg.count = (size_t)amount;
+				sdArg.pos = file_offset_tmp;
+				sdArg.actual = 0;
+				sdArg.user_space = 0;
+				if(curlun->filp->f_op->unlocked_ioctl)
+					curlun->filp->f_op->unlocked_ioctl(curlun->filp, IOCTL_STORAGE_DIRECT_WRITE, (unsigned long)&sdArg);
+				file_offset_tmp = sdArg.pos;
+				nwritten = sdArg.actual;
+			}
+			else
+			{
+				nwritten = vfs_write(curlun->filp,
+						(char __user *) bh->buf,
+						amount, &file_offset_tmp);
+			}
+
 			VLDBG(curlun, "file write %u @ %llu -> %d\n", amount,
 					(unsigned long long) file_offset,
 					(int) nwritten);
@@ -1988,9 +2058,25 @@
 
 		/* Perform the read */
 		file_offset_tmp = file_offset;
-		nread = vfs_read(curlun->filp,
-				(char __user *) bh->buf,
-				amount, &file_offset_tmp);
+		if(curlun->can_ioctl)
+		{
+			struct storage_direct sdArg;
+			sdArg.buf = bh->buf;
+			sdArg.count = (size_t)amount;
+			sdArg.pos = file_offset_tmp;
+			sdArg.actual = 0;
+			sdArg.user_space = 0;
+			if(curlun->filp->f_op->unlocked_ioctl)
+				curlun->filp->f_op->unlocked_ioctl(curlun->filp, IOCTL_STORAGE_DIRECT_READ, (unsigned long)&sdArg);
+			file_offset_tmp = sdArg.pos;
+			nread = sdArg.actual;
+		}
+		else
+		{
+			nread = vfs_read(curlun->filp,
+					(char __user *) bh->buf,
+					amount, &file_offset_tmp);
+		}
 		VLDBG(curlun, "file read %u @ %llu -> %d\n", amount,
 				(unsigned long long) file_offset,
 				(int) nread);
@@ -2025,9 +2111,16 @@
 {
 	u8	*buf = (u8 *) bh->buf;
 
+#ifdef CONFIG_ARCH_TCC
+	static char vendor_id[] = "TELECHIP";
+	static char product_id[] = "MASS STORAGE    ";
+	static char product_cdrom_id[] = "MASS STORAGE CD ";
+	printk("do_inquiry\n");
+#else
 	static char vendor_id[] = "Linux   ";
 	static char product_disk_id[] = "File-Stor Gadget";
 	static char product_cdrom_id[] = "File-CD Gadget  ";
+#endif
 
 	if (!fsg->curlun) {		// Unsupported LUNs are okay
 		fsg->bad_lun_okay = 1;
@@ -2039,10 +2132,17 @@
 
 	memset(buf, 0, 8);
 	buf[0] = (mod_data.cdrom ? TYPE_CDROM : TYPE_DISK);
-	if (mod_data.removable)
+//removed by mer-smartq-kernel team
+//	if (mod_data.removable)
+	if(fsg->curlun->removable)
 		buf[1] = 0x80;
+#ifdef CONFIG_ARCH_TCC
+	buf[2] = 0;			// 0 for UFI device
+	buf[3] = 1;			// 1 for UFI device
+#else
 	buf[2] = 2;		// ANSI SCSI level 2
 	buf[3] = 2;		// SCSI-2 INQUIRY data format
+#endif
 	buf[4] = 31;		// Additional length
 				// No special options
 	sprintf(buf + 8, "%-8s%-16s%04x", vendor_id,
@@ -2278,7 +2378,8 @@
 	struct lun	*curlun = fsg->curlun;
 	int		loej, start;
 
-	if (!mod_data.removable) {
+	//if (!mod_data.removable) {
+	if (curlun->removable) {
 		curlun->sense_data = SS_INVALID_COMMAND;
 		return -EINVAL;
 	}
@@ -2328,7 +2429,8 @@
 	struct lun	*curlun = fsg->curlun;
 	int		prevent;
 
-	if (!mod_data.removable) {
+	//if (!mod_data.removable) {
+	if (curlun->removable) {
 		curlun->sense_data = SS_INVALID_COMMAND;
 		return -EINVAL;
 	}
@@ -2678,6 +2780,9 @@
 
 		fsg->intr_buffhd = bh;		// Point to the right buffhd
 		fsg->intreq->buf = bh->inreq->buf;
+		#ifdef DMA_MODE
+		fsg->intreq->dma = bh->inreq->dma;	//for dma (AlenOh)
+		#endif
 		fsg->intreq->context = bh;
 		start_transfer(fsg, fsg->intr_in, fsg->intreq,
 				&fsg->intreq_busy, &bh->state);
@@ -3309,6 +3414,9 @@
 		if ((rc = alloc_request(fsg, fsg->bulk_out, &bh->outreq)) != 0)
 			goto reset;
 		bh->inreq->buf = bh->outreq->buf = bh->buf;
+		#ifdef DMA_MODE
+		bh->inreq->dma = bh->outreq->dma = bh->dma;	//for dma (AlenOh)
+		#endif
 		bh->inreq->context = bh->outreq->context = bh;
 		bh->inreq->complete = bulk_in_complete;
 		bh->outreq->complete = bulk_out_complete;
@@ -3629,6 +3737,14 @@
 		return PTR_ERR(filp);
 	}
 
+	if(curlun->can_ioctl && filp->f_op->unlocked_ioctl)
+	{
+  		if(filp->f_op->unlocked_ioctl(filp, IOCTL_STORAGE_PING, 0) != 0 )
+		{
+			curlun->can_ioctl = 0;
+		}
+	}
+
 	if (!(filp->f_mode & FMODE_WRITE))
 		ro = 1;
 
@@ -3774,6 +3890,12 @@
 	struct fsg_dev	*fsg = dev_get_drvdata(dev);
 	int		rc = 0;
 
+	if( !curlun->removable )
+	{
+		LDBG(curlun, "It's not removable\n");
+		return -EBUSY;
+	}
+
 	if (curlun->prevent_medium_removal && backing_file_is_open(curlun)) {
 		LDBG(curlun, "eject attempt prevented\n");
 		return -EBUSY;				// "Door is locked"
@@ -3856,11 +3978,21 @@
 
 	/* Free the data buffers */
 	for (i = 0; i < NUM_BUFFERS; ++i)
+	{
+		#ifdef DMA_MODE
+		dma_free_coherent (NULL, mod_data.buflen, fsg->buffhds[i].buf, fsg->buffhds[i].dma);	//for dma (AlenOh)
+		#else
 		kfree(fsg->buffhds[i].buf);
+		#endif
+	}
 
 	/* Free the request and buffer for endpoint 0 */
 	if (req) {
+		#ifdef DMA_MODE
+		dma_free_coherent (NULL, EP0_BUFSIZE, req->buf, req->dma);	//for dma (AlenOh)
+		#else
 		kfree(req->buf);
+		#endif
 		usb_ep_free_request(fsg->ep0, req);
 	}
 
@@ -3873,7 +4005,7 @@
 	int	prot;
 	int	gcnum;
 
-	/* Store the default values */
+	/* Store the default values */ 
 	mod_data.transport_type = USB_PR_BULK;
 	mod_data.transport_name = "Bulk-only";
 	mod_data.protocol_type = USB_SC_SCSI;
@@ -3956,6 +4088,17 @@
 	return 0;
 }
 
+static int fsg_removable(void)
+{
+	unsigned int i;
+	for(i=0;i<mod_data.nluns;i++)
+	{
+		if(mod_data.removable[i])
+			return 1;
+	}
+
+	return 0;
+}
 
 static int __init fsg_bind(struct usb_gadget *gadget)
 {
@@ -3967,22 +4110,30 @@
 	struct usb_request	*req;
 	char			*pathbuf, *p;
 
+#ifdef CONFIG_ARCH_TCC
+	printk("[tcc-gadget]fsg_bind start\n");
+#endif
+
 	fsg->gadget = gadget;
 	set_gadget_data(gadget, fsg);
 	fsg->ep0 = gadget->ep0;
 	fsg->ep0->driver_data = fsg;
 
-	if ((rc = check_parameters(fsg)) != 0)
+ 	if ((rc = check_parameters(fsg)) != 0) {
+#ifdef CONFIG_ARCH_TCC
+	printk("[tcc-gadget]check_parameters fail\n");
+#endif
 		goto out;
+	}
 
-	if (mod_data.removable) {	// Enable the store_xxx attributes
+//	if (mod_data.removable) {	// Enable the store_xxx attributes
 		dev_attr_file.attr.mode = 0644;
 		dev_attr_file.store = store_file;
 		if (!mod_data.cdrom) {
 			dev_attr_ro.attr.mode = 0644;
 			dev_attr_ro.store = store_ro;
 		}
-	}
+//	}
 
 	/* Find out how many LUNs there should be */
 	i = mod_data.nluns;
@@ -3998,6 +4149,9 @@
 	 * LUN devices in sysfs. */
 	fsg->luns = kzalloc(i * sizeof(struct lun), GFP_KERNEL);
 	if (!fsg->luns) {
+#ifdef CONFIG_ARCH_TCC
+        printk("[tcc-gadget]kzalloc fail\n");
+#endif
 		rc = -ENOMEM;
 		goto out;
 	}
@@ -4008,6 +4162,8 @@
 		curlun->ro = mod_data.ro[i];
 		if (mod_data.cdrom)
 			curlun->ro = 1;
+		//curlun->can_ioctl = mod_data.can_ioctl[i];
+		curlun->removable = mod_data.removable[i];
 		curlun->dev.release = lun_release;
 		curlun->dev.parent = &gadget->dev;
 		curlun->dev.driver = &fsg_driver.driver;
@@ -4017,6 +4173,9 @@
 
 		if ((rc = device_register(&curlun->dev)) != 0) {
 			INFO(fsg, "failed to register LUN%d: %d\n", i, rc);
+#ifdef CONFIG_ARCH_TCC
+            printk("[tcc-gadget]register LUN%d: %d fail\n", i, rc);
+#endif
 			goto out;
 		}
 		if ((rc = device_create_file(&curlun->dev,
@@ -4024,6 +4183,9 @@
 				(rc = device_create_file(&curlun->dev,
 					&dev_attr_file)) != 0) {
 			device_unregister(&curlun->dev);
+#ifdef CONFIG_ARCH_TCC
+            printk("[tcc-gadget]device create file fail\n");
+#endif
 			goto out;
 		}
 		curlun->registered = 1;
@@ -4031,10 +4193,18 @@
 
 		if (mod_data.file[i] && *mod_data.file[i]) {
 			if ((rc = open_backing_file(curlun,
-					mod_data.file[i])) != 0)
+					mod_data.file[i])) != 0) {
+#ifdef CONFIG_ARCH_TCC
+                printk("[tcc-gadget]open backing file fail\n");
+#endif
 				goto out;
-		} else if (!mod_data.removable) {
+            }
+		//} else if (!mod_data.removable) {
+		} else if (!fsg_removable()) {
 			ERROR(fsg, "no file given for LUN%d\n", i);
+#ifdef CONFIG_ARCH_TCC
+            printk("[tcc-gadget]no file given\n");
+#endif
 			rc = -EINVAL;
 			goto out;
 		}
@@ -4042,22 +4212,35 @@
 
 	/* Find all the endpoints we will use */
 	usb_ep_autoconfig_reset(gadget);
-	ep = usb_ep_autoconfig(gadget, &fs_bulk_in_desc);
-	if (!ep)
-		goto autoconf_fail;
-	ep->driver_data = fsg;		// claim the endpoint
-	fsg->bulk_in = ep;
 
 	ep = usb_ep_autoconfig(gadget, &fs_bulk_out_desc);
-	if (!ep)
+	if (!ep) {
+#ifdef CONFIG_ARCH_TCC
+        printk("[tcc-gadget]bulk out autoconf_fail\n");
+#endif
 		goto autoconf_fail;
+    }
 	ep->driver_data = fsg;		// claim the endpoint
 	fsg->bulk_out = ep;
 
+	ep = usb_ep_autoconfig(gadget, &fs_bulk_in_desc);
+	if (!ep) {
+#ifdef CONFIG_ARCH_TCC
+        printk("[tcc-gadget]bulk in autoconf_fail\n");
+#endif
+		goto autoconf_fail;
+    }
+	ep->driver_data = fsg;		// claim the endpoint
+	fsg->bulk_in = ep;
+
 	if (transport_is_cbi()) {
 		ep = usb_ep_autoconfig(gadget, &fs_intr_in_desc);
-		if (!ep)
+		if (!ep) {
+#ifdef CONFIG_ARCH_TCC
+            printk("[tcc-gadget]int in autoconf_fail\n");
+#endif
 			goto autoconf_fail;
+        }
 		ep->driver_data = fsg;		// claim the endpoint
 		fsg->intr_in = ep;
 	}
@@ -4089,18 +4272,33 @@
 				fs_intr_in_desc.bEndpointAddress;
 	}
 
-	if (gadget_is_otg(gadget))
+	if (gadget_is_otg(gadget)) {
 		otg_desc.bmAttributes |= USB_OTG_HNP;
+		/* Commented  by Sheeja S on 6th Feb 2006 to disable Remote Wakeup. */ //from dwc_otg, AlenOh
+		//AlenOh config_desc.bmAttributes |= USB_CONFIG_ATT_WAKEUP;
+	}
 
 	rc = -ENOMEM;
 
 	/* Allocate the request and buffer for endpoint 0 */
 	fsg->ep0req = req = usb_ep_alloc_request(fsg->ep0, GFP_KERNEL);
-	if (!req)
+	if (!req) {
+#ifdef CONFIG_ARCH_TCC
+        printk("[tcc-gadget]ep alloc request fail\n");
+#endif
 		goto out;
+    }
+	#ifdef DMA_MODE
+	req->buf = dma_alloc_coherent(NULL,EP0_BUFSIZE,&req->dma,GFP_KERNEL | GFP_DMA);	//for dma (AlenOh)
+	#else
 	req->buf = kmalloc(EP0_BUFSIZE, GFP_KERNEL);
-	if (!req->buf)
+	#endif
+	if (!req->buf) {
+#ifdef CONFIG_ARCH_TCC
+        printk("[tcc-gadget]kmalloc EP0_BUFSIZE fail\n");
+#endif
 		goto out;
+    }
 	req->complete = ep0_complete;
 
 	/* Allocate the data buffers */
@@ -4110,9 +4308,17 @@
 		/* Allocate for the bulk-in endpoint.  We assume that
 		 * the buffer will also work with the bulk-out (and
 		 * interrupt-in) endpoint. */
+		#ifdef DMA_MODE
+		bh->buf = dma_alloc_coherent(NULL,mod_data.buflen,&bh->dma,GFP_KERNEL | GFP_DMA);	//for dma (AlenOh)
+		#else
 		bh->buf = kmalloc(mod_data.buflen, GFP_KERNEL);
-		if (!bh->buf)
+		#endif
+		if (!bh->buf) {
+#ifdef CONFIG_ARCH_TCC
+            printk("[tcc-gadget]kmalloc mod_data.buflen fail\n");
+#endif
 			goto out;
+        }
 		bh->next = bh + 1;
 	}
 	fsg->buffhds[NUM_BUFFERS - 1].next = &fsg->buffhds[0];
@@ -4120,12 +4326,17 @@
 	/* This should reflect the actual gadget power source */
 	usb_gadget_set_selfpowered(gadget);
 
+#ifdef CONFIG_ARCH_TCC
+    snprintf(manufacturer, sizeof manufacturer, "TELECHIPS");
+#else
 	snprintf(manufacturer, sizeof manufacturer, "%s %s with %s",
 			init_utsname()->sysname, init_utsname()->release,
 			gadget->name);
+#endif
 
 	/* On a real device, serial[] would be loaded from permanent
 	 * storage.  We just encode it from the driver version string. */
+#ifndef CONFIG_ARCH_TCC
 	for (i = 0; i < sizeof(serial) - 2; i += 2) {
 		unsigned char		c = DRIVER_VERSION[i / 2];
 
@@ -4133,11 +4344,15 @@
 			break;
 		sprintf(&serial[i], "%02X", c);
 	}
+#endif
 
 	fsg->thread_task = kthread_create(fsg_main_thread, fsg,
 			"file-storage-gadget");
 	if (IS_ERR(fsg->thread_task)) {
 		rc = PTR_ERR(fsg->thread_task);
+#ifdef CONFIG_ARCH_TCC
+        printk("[tcc-gadget]PTR ERR\n");
+#endif
 		goto out;
 	}
 
@@ -4168,7 +4383,7 @@
 	DBG(fsg, "VendorID=x%04x, ProductID=x%04x, Release=x%04x\n",
 			mod_data.vendor, mod_data.product, mod_data.release);
 	DBG(fsg, "removable=%d, stall=%d, cdrom=%d, buflen=%u\n",
-			mod_data.removable, mod_data.can_stall,
+			/*mod_data.removable*/fsg_removable(), mod_data.can_stall,
 			mod_data.cdrom, mod_data.buflen);
 	DBG(fsg, "I/O thread pid: %d\n", task_pid_nr(fsg->thread_task));
 
@@ -4258,11 +4473,21 @@
 	int		rc;
 	struct fsg_dev	*fsg;
 
-	if ((rc = fsg_alloc()) != 0)
+#ifdef CONFIG_ARCH_TCC
+    printk("[tcc-gadget]fsg_init start\n");
+#endif
+	if ((rc = fsg_alloc()) != 0) {
+#ifdef CONFIG_ARCH_TCC
+    printk("[tcc-gadget]fsg_alloc fail\n");
+#endif
 		return rc;
+    }
 	fsg = the_fsg;
 	if ((rc = usb_gadget_register_driver(&fsg_driver)) != 0)
 		kref_put(&fsg->ref, fsg_release);
+#ifdef CONFIG_ARCH_TCC
+    printk("[tcc-gadget]fsg init end\n");
+#endif
 	return rc;
 }
 module_init(fsg_init);
Index: linux-2.6.29/drivers/usb/gadget/gadget_chips.h
===================================================================
--- linux-2.6.29.orig/drivers/usb/gadget/gadget_chips.h	2010-04-07 12:29:34.000000000 -0400
+++ linux-2.6.29/drivers/usb/gadget/gadget_chips.h	2010-04-07 13:00:58.000000000 -0400
@@ -167,6 +167,13 @@
 // CONFIG_USB_GADGET_AU1X00
 // ...
 
+#if defined(CONFIG_USB_GADGET_TCC_OTG_STANDALONE)
+#define gadget_is_tcc(g) !strcmp("tcc-udc", (g)->name)
+#elif defined(CONFIG_TCC_DWC_OTG_DEVICE)
+#define gadget_is_tcc(g) !strcmp("dwc_otg_pcd", (g)->name)
+#else
+#define gadget_is_tcc(g) 0
+#endif
 
 /**
  * usb_gadget_controller_number - support bcdDevice id convention
@@ -231,6 +238,8 @@
 		return 0x22;
 	else if (gadget_is_ci13xxx(gadget))
 		return 0x23;
+ 	else if (gadget_is_tcc(gadget))
+ 		return 0xff;
 	return -ENOENT;
 }
 
Index: linux-2.6.29/drivers/usb/host/Kconfig
===================================================================
--- linux-2.6.29.orig/drivers/usb/host/Kconfig	2010-04-07 12:29:34.000000000 -0400
+++ linux-2.6.29/drivers/usb/host/Kconfig	2010-04-07 12:29:36.000000000 -0400
@@ -137,7 +137,7 @@
 	  module will be called isp1760.
 
 config USB_OHCI_HCD
-	tristate "OHCI HCD support"
+	tristate "OHCI HCD support (TCC8900 only)"
 	depends on USB && USB_ARCH_HAS_OHCI
 	select ISP1301_OMAP if MACH_OMAP_H2 || MACH_OMAP_H3
 	select USB_OTG_UTILS if ARCH_OMAP
Index: linux-2.6.29/drivers/usb/host/ohci-hcd.c
===================================================================
--- linux-2.6.29.orig/drivers/usb/host/ohci-hcd.c	2010-04-07 12:29:34.000000000 -0400
+++ linux-2.6.29/drivers/usb/host/ohci-hcd.c	2010-04-07 12:29:36.000000000 -0400
@@ -992,6 +992,11 @@
 #define PCI_DRIVER		ohci_pci_driver
 #endif
 
+#ifdef CONFIG_ARCH_TCC
+#include "ohci-tcc.c"
+#define PLATFORM_DRIVER		ohci_hcd_tcc_driver
+#endif
+
 #if defined(CONFIG_ARCH_SA1100) && defined(CONFIG_SA1111)
 #include "ohci-sa1111.c"
 #define SA1111_DRIVER		ohci_hcd_sa1111_driver
Index: linux-2.6.29/drivers/usb/host/ohci-tcc.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/usb/host/ohci-tcc.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,488 @@
+/*
+ * linux/drivers/usb/host/ohci-tcc.c
+ *
+ * Description: OHCI HCD (Host Controller Driver) for USB.
+ *              Bus Glue for Telechips TCCXXX
+ *
+ * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
+ * (C) Copyright 2000-2002 David Brownell <dbrownell@users.sourceforge.net>
+ * (C) Copyright 2002 Hewlett-Packard Company
+ * (C) Copyright 2008-2009 Telechips <linux@telechips.com>
+ * (C) Copyright 2008-2009 Telechips 
+ *
+ * Rewritten by <linux@telechips.com>
+ * Written by Christopher Hoover <ch@hpl.hp.com>
+ * Based on fragments of previous driver by Russell King et al.
+ *
+ * Modified for LH7A404 from ohci-sa1111.c
+ *  by Durgesh Pattamatta <pattamattad@sharpsec.com>
+ *
+ * Modified for pxa27x from ohci-lh7a404.c
+ *  by Nick Bane <nick@cecomputing.co.uk> 26-8-2004
+ *
+ * Modified for TCCXXX from ohci-pxa27x.c
+ *  by Telechips Linux Team <linux@telechips.com> 03-9-2008
+ *
+ * This file is licenced under the GPL.
+ */
+
+#include <linux/device.h>
+#include <linux/signal.h>
+#include <linux/platform_device.h>
+#include <asm/mach-types.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include <linux/tcc_pwm.h>
+#include <linux/tcc_ll.h>
+
+#include <bsp.h>
+#include <mach/ohci.h>
+#include <mach/tcc_pca953x.h>
+
+static int tcc_ohci_select_pmm(unsigned long reg_base, int mode, int num_port, int *port_mode)
+{
+	volatile struct _USBHOST11 *ohci_reg;
+	ohci_reg = (volatile struct _USBHOST11 *)reg_base;
+
+	switch (mode) {
+		case USBOHCI_PPM_NPS:
+			/* set NO Power Switching mode */
+			ohci_reg->HcRhDescriptorA |= USBOHCI_UHCRHDA_NPS;
+			break;
+		case USBOHCI_PPM_GLOBAL:
+			/* make sure the NO Power Switching mode bit is OFF so Power Switching can occur
+			 * make sure the PSM bit is CLEAR, which allows all ports to be controlled with
+			 * the GLOBAL set and clear power commands
+			 */
+			ohci_reg->HcRhDescriptorA &= ~(USBOHCI_UHCRHDA_NPS|USBOHCI_UHCRHDA_PSM_PERPORT);
+			break;
+		case USBOHCI_PPM_PERPORT:
+			/* make sure the NO Power Switching mode bit is OFF so Power Switching can occur
+			 * make sure the PSM bit is SET, which allows all ports to be controlled with 
+			 * the PER PORT set and clear power commands 
+			 */
+			ohci_reg->HcRhDescriptorA &= ~USBOHCI_UHCRHDA_NPS;
+			ohci_reg->HcRhDescriptorA |=  USBOHCI_UHCRHDA_PSM_PERPORT;
+
+			/* set the power management mode for each individual port to Per Port. */
+			{
+				int p;
+				for (p = 0; p < num_port; p++) {
+					ohci_reg->HcRhDescriptorB |= (unsigned int)( 1u << (p+17) );   // port 1 begins at bit 17
+				}
+			}
+			break;
+		case USBOHCI_PPM_MIXED:
+			/* make sure the NO Power Switching mode bit is OFF so Power Switching can occur
+			 * make sure the PSM bit is SET, which allows all ports to be controlled with
+			 * the PER PORT set and clear power commands
+			 */
+			ohci_reg->HcRhDescriptorA &= ~USBOHCI_UHCRHDA_NPS;
+			ohci_reg->HcRhDescriptorA |=  USBOHCI_UHCRHDA_PSM_PERPORT;
+
+			/* set the power management mode for each individual port to Per Port.
+			 * if the value in the PortMode array is non-zero, set Per Port mode for the port.
+			 * if the value in the PortMode array is zero, set Global mode for the port
+			 */
+			{
+				int p;
+				for (p = 0; p < num_port; p++) {
+					if (port_mode[p]) {
+						ohci_reg->HcRhDescriptorB |= (unsigned int)( 1u << (p+17) );   // port 1 begins at bit 17
+					} else {
+						ohci_reg->HcRhDescriptorB &= ~(unsigned int)( 1u << (p+17) );  // port 1 begins at bit 17
+					}
+				}
+			}
+			break;
+		default:
+			printk(KERN_ERR "Invalid mode %d, set to non-power switch mode.\n", mode);
+			ohci_reg->HcRhDescriptorA |= USBOHCI_UHCRHDA_NPS;
+	}
+	return 0;
+}
+
+extern int usb_disabled(void);
+
+/*-------------------------------------------------------------------------*/
+
+static void USBHostVBUSControl(int on)
+{	
+	/* GPIO_EXPAND HVBUS & PWR_GP1 control */
+	if (on) {
+		tcc_pca953x_setup(PCA9538_U4_SLAVE_ADDR, PWR_GP1, OUTPUT, HIGH, SET_DIRECTION|SET_VALUE);
+		tcc_pca953x_setup(PCA9538_U4_SLAVE_ADDR, HVBUS_ON, OUTPUT, HIGH, SET_DIRECTION|SET_VALUE);
+	} else {
+#if !defined(CONFIG_TCC_DWC_OTG) && !defined(CONFIG_TCC_DWC_OTG_MODULE)
+		tcc_pca953x_setup(PCA9538_U4_SLAVE_ADDR, PWR_GP1, OUTPUT, LOW, SET_DIRECTION|SET_VALUE);
+#endif
+		tcc_pca953x_setup(PCA9538_U4_SLAVE_ADDR, HVBUS_ON, OUTPUT, LOW, SET_DIRECTION|SET_VALUE);
+	}
+}
+
+static void TurnOnUSBHostClocks(void)
+{
+	PIOBUSCFG pIOBUSCfg;
+	pIOBUSCfg = (PIOBUSCFG)tcc_p2v(HwIOBUSCFG_BASE);
+	tca_ckc_setperi(PERI_USB11H, ENABLE, 480000, PCDIRECTPLL3);
+	BITSET(pIOBUSCfg->HCLKEN0, Hw0);	// Bit0 is USB1.1 Host IOBUS AHB clock
+	BITSET(pIOBUSCfg->HRSTEN0, Hw0);	// Bit0 is USB1.1 Host IOBUS AHB Hreset
+}
+
+static void TurnOffUSBHostClocks(void)
+{
+	PIOBUSCFG pIOBUSCfg;
+	pIOBUSCfg = (PIOBUSCFG)tcc_p2v(HwIOBUSCFG_BASE);
+	tca_ckc_setperi(PERI_USB11H, DISABLE, 480000, PCDIRECTPLL3);
+	BITCLR(pIOBUSCfg->HCLKEN0, Hw0);
+	BITCLR(pIOBUSCfg->HRSTEN0, Hw0);
+}
+
+static void USBHostReset(void)
+{
+	PIOBUSCFG pIOBUSCfg;
+	pIOBUSCfg = (PIOBUSCFG)tcc_p2v(HwIOBUSCFG_BASE);
+	BITCLR(pIOBUSCfg->HRSTEN0, Hw0);
+	BITSET(pIOBUSCfg->HRSTEN0, Hw0);
+}
+
+static int tcc_set_cken(int sw)
+{
+	if (sw){
+		TurnOnUSBHostClocks();
+		USBHostReset();
+	} else {
+		TurnOffUSBHostClocks();
+	}
+	return 0;
+}
+
+static int tcc_start_hc(struct device *dev)
+{
+	int retval = 0;
+	struct tccohci_platform_data *inf;
+	PIOBUSCFG pIOBUSCfg;
+	inf = dev->platform_data;
+
+	/* USB 1.1 Host Configuration Register
+	 * DP, DN pull-down enable
+	 */
+	pIOBUSCfg = (PIOBUSCFG)tcc_p2v(HwIOBUSCFG_BASE);
+	BITSET(pIOBUSCfg->USB11H, Hw4|Hw3);
+
+	tcc_set_cken(1);
+
+	if (inf->init)
+		retval = inf->init(dev);
+	if (retval < 0)
+		return retval;
+
+	return 0;
+}
+
+static void tcc_stop_hc(struct device *dev)
+{
+	struct tccohci_platform_data *inf;
+	inf = dev->platform_data;
+	if (inf->exit)
+		inf->exit(dev);
+
+	tcc_set_cken(0);
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* configure so an HC device and id are always provided */
+/* always called with process context; sleeping is OK */
+
+
+/**
+ * usb_hcd_tcc_probe - initialize tcc-based HCDs
+ * Context: !in_interrupt()
+ *
+ * Allocates basic resources for this USB host controller, and
+ * then invokes the start() method for the HCD associated with it
+ * through the hotplug entry's driver_data.
+ *
+ */
+static int usb_hcd_tcc_probe (const struct hc_driver *driver, struct platform_device *pdev)
+{
+	int retval = 0;
+	struct usb_hcd *hcd;
+	struct tccohci_platform_data *inf;
+
+	inf = pdev->dev.platform_data;
+	if (!inf) {
+		return -ENODEV;
+	}
+
+	if (pdev->resource[1].flags != IORESOURCE_IRQ) {
+		printk(KERN_ERR "resource[1] is not IORESOURCE_IRQ");
+		return -ENOMEM;
+	}
+
+	hcd = usb_create_hcd (driver, &pdev->dev, "tcc");
+	if (!hcd)
+		return -ENOMEM;
+	hcd->rsrc_start = io_p2v(pdev->resource[0].start);
+	hcd->rsrc_len   = pdev->resource[0].end - pdev->resource[0].start + 1;
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
+		printk(KERN_ERR "request_mem_region failed");
+		retval = -EBUSY;
+		goto err1;
+	}
+	hcd->regs = (void __iomem *)(int)(hcd->rsrc_start);
+
+	/* GPIO_EXPAND HVBUS & PWR_GP1 Power-on */
+	USBHostVBUSControl(1);
+	retval = tcc_pca953x_setup(PCA9538_U4_SLAVE_ADDR, 0, OUTPUT, 0, GET_VALUE);
+	if (!(retval & PWR_GP1) || !(retval & HVBUS_ON)) {
+		printk(KERN_ERR "ohci-tcc: GPIO_EXPAND power failed\n");
+		retval = -EIO;
+		goto err2;
+	}
+
+	if ((retval = tcc_start_hc(&pdev->dev)) < 0) {
+		printk(KERN_ERR "tcc_start_hc failed");
+		goto err2;
+	}
+
+	/* Select Power Management Mode */
+	tcc_ohci_select_pmm(hcd->rsrc_start, inf->port_mode, 0, 0);
+
+	if (inf->power_budget)
+		hcd->power_budget = inf->power_budget;
+
+	ohci_hcd_init(hcd_to_ohci(hcd));
+
+	retval = usb_add_hcd(hcd, pdev->resource[1].start, IRQF_DISABLED);
+	if (retval == 0) {
+		return retval;
+	}
+
+	tcc_stop_hc(&pdev->dev);
+err2:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+err1:
+	usb_put_hcd(hcd);
+	return retval;
+}
+
+
+/* may be called without controller electrically present */
+/* may be called with controller, bus, and devices active */
+
+/**
+ * usb_hcd_tcc_remove - shutdown processing for tcc-based HCDs
+ * @dev: USB Host Controller being removed
+ * Context: !in_interrupt()
+ *
+ * Reverses the effect of usb_hcd_tcc_probe(), first invoking
+ * the HCD's stop() method.  It is always called from a thread
+ * context, normally "rmmod", "apmd", or something similar.
+ *
+ */
+static void usb_hcd_tcc_remove (struct usb_hcd *hcd, struct platform_device *pdev)
+{
+	usb_remove_hcd(hcd);
+
+	tcc_stop_hc(&pdev->dev);
+
+	/* GPIO_EXPAND HVBUS & PWR_GP1 Power-off */
+	USBHostVBUSControl(0);
+
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+}
+
+/*-------------------------------------------------------------------------*/
+
+static int __devinit ohci_tcc_start (struct usb_hcd *hcd)
+{
+	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
+	int ret;
+
+	tcc_set_cken(1);
+
+	/* The value of NDP in roothub_a is incorrect on this hardware */
+	ohci->num_ports = 1;
+
+	if ((ret = ohci_init(ohci)) < 0) {
+		return ret;
+	}
+	if ((ret = ohci_run (ohci)) < 0) {
+		err ("can't start %s", hcd->self.bus_name);
+		ohci_stop (hcd);
+		return ret;
+	}
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static const struct hc_driver ohci_tcc_hc_driver = {
+	.description =		hcd_name,
+	.product_desc =		"TCC OHCI",
+	.hcd_priv_size =	sizeof(struct ohci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq =			ohci_irq,
+	.flags =		HCD_USB11 | HCD_MEMORY,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.start =		ohci_tcc_start,
+	.stop =			ohci_stop,
+#ifndef __OLD__
+	.shutdown =		ohci_shutdown,
+#endif
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue =		ohci_urb_enqueue,
+	.urb_dequeue =		ohci_urb_dequeue,
+	.endpoint_disable =	ohci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number =	ohci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data =	ohci_hub_status_data,
+	.hub_control =		ohci_hub_control,
+#ifdef  CONFIG_PM
+	.bus_suspend = 		ohci_bus_suspend,
+	.bus_resume =		ohci_bus_resume,
+#endif
+	.start_port_reset =	ohci_start_port_reset,
+};
+
+
+/*-------------------------------------------------------------------------*/
+
+#ifdef	CONFIG_PM
+static int ohci_hcd_tcc_drv_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
+	if (time_before(jiffies, ohci->next_statechange))
+		msleep(5);
+	ohci->next_statechange = jiffies;
+
+	tcc_stop_hc(&pdev->dev);
+	hcd->state = HC_STATE_SUSPENDED;
+
+	return 0;
+}
+
+static int ohci_hcd_tcc_drv_resume(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
+	int status;
+	if (time_before(jiffies, ohci->next_statechange))
+		msleep(5);
+	ohci->next_statechange = jiffies;
+
+	if ((status = tcc_start_hc(&pdev->dev)) < 0)
+		return status;
+	ohci_finish_controller_resume(hcd);
+
+	return 0;
+}
+#endif
+
+/*-----------------------------------------------------------------
+ * OHCI Power on/off control
+ */
+static stpwrinfo pwrinfo = {PWR_STATUS_ON};
+static int ohci_pwr_ctl(void *h_private, int cmd, void *p_out)
+{
+	struct platform_device *pdev = (struct platform_device *)h_private;
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	switch (cmd) {
+		case PWR_CMD_OFF:
+			//printk("PWR_CMD_OFF command ==> [%d]\n", cmd);
+			if (pwrinfo.status == PWR_STATUS_OFF) {
+				return 0;
+			}
+			pwrinfo.status = PWR_STATUS_OFF;
+			/* refer to ohci_hcd_tcc_drv_remove */
+			usb_hcd_tcc_remove(hcd, pdev);
+			platform_set_drvdata(pdev, NULL);
+			break;
+		case PWR_CMD_ON:
+			//printk("PWR_CMD_ON command ==> [%d]\n", cmd);
+			if (pwrinfo.status == PWR_STATUS_ON) {
+				return 0;
+			}
+			pwrinfo.status = PWR_STATUS_ON;
+			/* refer to ohci_hcd_tcc_drv_probe */
+			if (usb_disabled()) { return -EIO; }
+			usb_hcd_tcc_probe(&ohci_tcc_hc_driver, pdev);
+			break;
+		case PWR_CMD_GETSTATUS:
+			//printk("PWR_CMD_GETSTATUS command ==> [%d], status:[%d]\n", cmd, pwrinfo.status);
+			memcpy(p_out, &pwrinfo, sizeof(stpwrinfo));
+			break;
+		default:
+			//printk("unknown pwr command !!! ==> [%d]\n", cmd);
+			return -EINVAL;
+			break;
+	}
+
+	return 0;
+}
+
+static int ohci_hcd_tcc_drv_probe(struct platform_device *pdev)
+{
+	if (usb_disabled()) {
+		return -ENODEV;
+	}
+
+	/* add power control functions */
+	insert_pwm_node(DEVICE_OHCI, ohci_pwr_ctl, pdev);
+
+	return usb_hcd_tcc_probe(&ohci_tcc_hc_driver, pdev);
+}
+
+static int ohci_hcd_tcc_drv_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	/* remove power control functions */
+	remove_pwm_node(DEVICE_OHCI);
+
+	usb_hcd_tcc_remove(hcd, pdev);
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+
+static struct platform_driver ohci_hcd_tcc_driver = {
+	.probe		= ohci_hcd_tcc_drv_probe,
+	.remove		= ohci_hcd_tcc_drv_remove,
+#ifdef CONFIG_PM
+	.suspend	= ohci_hcd_tcc_drv_suspend,
+	.resume		= ohci_hcd_tcc_drv_resume,
+#endif
+	.driver		= {
+		.name	= "tcc-ohci",
+		.owner	= THIS_MODULE,
+	},
+};
+
+
+/* work with hotplug and coldplug */
+MODULE_ALIAS("platform:tcc-ohci");
Index: linux-2.6.29/drivers/video/Kconfig
===================================================================
--- linux-2.6.29.orig/drivers/video/Kconfig	2010-04-07 12:29:33.000000000 -0400
+++ linux-2.6.29/drivers/video/Kconfig	2010-04-07 13:00:44.000000000 -0400
@@ -1887,6 +1887,21 @@
 
 	  If unsure, say N.
 
+config FB_TCC8900
+	tristate "Telechips TCC8900 DEMO board framebuffer support"
+	depends on FB && MACH_TCC8900
+	default n
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	select TCC_BL
+	---help---
+		Frame buffer driver for the built-in LCD controller in the Telechips
+		TCC8900 processor.
+
+		If unsure, say N.
+
+
 config FB_SH_MOBILE_LCDC
 	tristate "SuperH Mobile LCDC framebuffer support"
 	depends on FB && SUPERH
Index: linux-2.6.29/drivers/video/Makefile
===================================================================
--- linux-2.6.29.orig/drivers/video/Makefile	2010-04-07 12:29:33.000000000 -0400
+++ linux-2.6.29/drivers/video/Makefile	2010-04-07 13:00:43.000000000 -0400
@@ -123,6 +123,7 @@
 obj-$(CONFIG_XEN_FBDEV_FRONTEND)  += xen-fbfront.o
 obj-$(CONFIG_FB_CARMINE)          += carminefb.o
 obj-$(CONFIG_FB_MB862XX)	  += mb862xx/
+obj-$(CONFIG_FB_TCC8900)		  += tccfb.o tca_lcdc.o tca_tvout.o
 
 # Platform or fallback drivers go here
 obj-$(CONFIG_FB_UVESA)            += uvesafb.o
Index: linux-2.6.29/drivers/video/tca_backlight.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/video/tca_backlight.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1 @@
+../char/tca_backlight.h
\ No newline at end of file
Index: linux-2.6.29/drivers/video/tca_lcdc.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/video/tca_lcdc.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,781 @@
+
+
+/****************************************************************************
+ *   FileName    : tca_lcdc.c
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+
+#include <asm/io.h>
+#include <bsp.h>
+
+enum {
+	IMGFMT_1BPP		= 0,	// 1bpp indexed color
+	IMGFMT_2BPP		= 1,	// 2bpp indexed color
+	IMGFMT_4BPP		= 2,	// 4bpp indexed color
+	IMGFMT_8BPP		= 3,	// 8bpp indexed color
+	//...
+	IMGFMT_RGB332	= 8,	// RGB332 - 1bytes aligned - R[7:5],G[4:2],B[1:0]
+	IMGFMT_RGB444	= 9,	// RGB444 - 2bytes aligned - A[15:12],R[11:8],G[7:3],B[3:0]
+	IMGFMT_RGB565	= 10,	// RGB565 - 2bytes aligned - R[15:11],G[10:5],B[4:0]
+	IMGFMT_RGB555	= 11,	// RGB555 - 2bytes aligned - A[15],R[14:10],G[9:5],B[4:0]
+	IMGFMT_RGB888	= 12,	// RGB888 - 4bytes aligned - A[31:24],R[23:16],G[15:8],B[7:0]
+	IMGFMT_RGB666	= 13,	// RGB666 - 4bytes aligned - A[23:18],R[17:12],G[11:6],B[5:0]
+	//...
+	IMGFMT_YUV420	= 24,	// YCbCr 4:2:0 Separated format - Not Supported for Image 1 and 2
+	IMGFMT_YUV422	= 25,	// YCbCr 4:2:2 Separated format - Not Supported for Image 1 and 2
+	IMGFMT_YUV422P	= 26,	// YCbCr 4:2:2 Sequential format
+	//...
+	IMGFMT_YUV420I0	= 28,	// YCbCr 4:2:0 interleved type 0 format - Not Supported for Image 1 and 2
+	IMGFMT_YUV420I1	= 29,	// YCbCr 4:2:0 interleved type 1 format - Not Supported for Image 1 and 2
+	IMGFMT_YUV422I0	= 30,	// YCbCr 4:2:2 interleved type 0 format - Not Supported for Image 1 and 2
+	IMGFMT_YUV422I1	= 31,	// YCbCr 4:2:2 interleved type 1 format - Not Supported for Image 1 and 2
+
+};// IMGCH_FMT_t;
+
+/*
+ * Channel(IMGx) Enable/Disable
+ *
+ * ch :   0 - IMG0
+ *		  1 - IMG1
+ *		  2 - IMG2
+ *
+ * flag : 0 - disable
+ *        1 - enable
+ *
+ */
+void tca_lcdc_setimgchenable(int id, unsigned int ch, unsigned int flag)
+{
+	volatile PLCDC	pLCDC;
+
+	if (id)	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC1_BASE);
+	else	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC0_BASE);
+	
+	switch(ch)
+	{
+		case 0:
+			BITCSET (pLCDC->LI0C, Hw28, (flag) << 28);
+			break;
+		case 1:
+			BITCSET (pLCDC->LI1C, Hw28, (flag) << 28);
+			break;
+		case 2:
+			BITCSET (pLCDC->LI2C, Hw28, (flag) << 28);
+			break;
+		default:
+			break;
+	}
+}
+
+
+
+/*
+ * Alpha Blending Enable for Image 0/1/2
+ *
+ * imgch: 0 - Image Ch0
+ *		  1 - Image Ch1
+ *		  2 - Layer Ch2
+ *
+ * flag : 0 - disable
+ *		  1 - enable
+ * 
+ */
+void tca_lcdc_setlayeralphablendingenable(int id, unsigned int imgch, unsigned int flag)
+{
+	volatile PLCDC	pLCDC;
+
+	if (id)	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC1_BASE);
+	else	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC0_BASE);
+
+	switch(imgch)
+	{
+		case 0:
+			BITCSET (pLCDC->LI0C, Hw30, (flag) << 30);
+			break;
+		case 1:
+			BITCSET (pLCDC->LI1C, Hw30, (flag) << 30);
+			break;
+		case 2:
+			BITCSET (pLCDC->LI2C, Hw30, (flag) << 30);
+			break;
+		default:
+			break;
+	}
+}
+
+
+/*
+ * Alpha Selection for Image 0/1/2
+ *
+ * imgch: 0 - Image Ch0
+ *		  1 - Image Ch1
+ *		  2 - Layer Ch2
+ *
+ * asel : 0 - A10 bits and A11 are used as alpha value
+ *            (Ref->tca_lcdc_setlayeralphavalue())
+ *		  1 - Alpha bits in the pixel are used as alpha value.
+ * 
+ */
+void tca_lcdc_setalphaselection(int id, unsigned int imgch, unsigned int asel)
+{
+	volatile PLCDC	pLCDC;
+
+	if (id)	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC1_BASE);
+	else	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC0_BASE);
+	
+	switch(imgch)
+	{
+		case 0:
+			BITCSET (pLCDC->LI0C, Hw24, (asel) << 24);
+			break;
+		case 1:
+			BITCSET (pLCDC->LI1C, Hw24, (asel) << 24);
+			break;
+		case 2:
+			BITCSET (pLCDC->LI2C, Hw24, (asel) << 24);
+			break;
+		default:
+			break;
+	}
+}
+
+
+/*
+ * Setting alpha-value for Image 0/1/2
+ *
+ * imgch: Image 0/1/2
+ *
+ * alpha:  Output Pixel = Main Pixel * (1-alpha/256) + Overlay Pixel*(alpha)
+ * 
+ */
+void tca_lcdc_setlayeralphavalue(int id, unsigned int imgch, unsigned char alpha)
+{
+	volatile PLCDC	pLCDC;
+
+	if (id)	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC1_BASE);
+	else	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC0_BASE);
+
+	switch(imgch)
+	{
+		case 0:
+			BITCSET(pLCDC->LI0A, (Hw24-Hw16) | (Hw8-Hw0), ((alpha&0x000000ff)<<16) | ((alpha&0x000000ff)));
+			break;
+		case 1:
+			BITCSET(pLCDC->LI1A, (Hw24-Hw16) | (Hw8-Hw0), ((alpha&0x000000ff)<<16) | ((alpha&0x000000ff)));
+			break;
+		case 2:
+			BITCSET(pLCDC->LI2A, (Hw24-Hw16) | (Hw8-Hw0), ((alpha&0x000000ff)<<16) | ((alpha&0x000000ff)));
+			break;
+	}
+}
+
+
+
+/*
+ * Chroma Key Enable for Image 0/1/2
+ *
+ * imgch: Image 0/1/2
+ *
+ * flag : 0 - disable
+ *		  1 - enable
+ * 
+ */
+void tca_lcdc_setlayerchromakeyenable(int id, unsigned int imgch, unsigned int flag)
+{
+	volatile PLCDC	pLCDC;
+
+	if (id)	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC1_BASE);
+	else	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC0_BASE);
+
+	switch(imgch)
+	{
+		case 0:
+			BITCSET (pLCDC->LI0C, Hw29, (flag) << 29);
+			break;
+		case 1:
+			BITCSET (pLCDC->LI1C, Hw29, (flag) << 29);
+			break;
+		case 2:
+			BITCSET (pLCDC->LI2C, Hw29, (flag) << 29);
+			break;
+		default:
+			break;
+	}
+}
+
+
+
+/*
+ * Setting croma-key value for Image 0/1/2
+ *
+ * imgch: Image 0/1/2
+ *
+ *	ry  : chroma-key value in R(Y) channel for Layer
+ *	gu  : chroma-key value in G(U) channel for Layer
+ *	bv  : chroma-key value in V(V) channel for Layer
+ *
+ */
+void tca_lcdc_setlayerchromakeyvalue(int id, unsigned int imgch, unsigned int ry, unsigned int gu, unsigned int bv)
+{
+	volatile PLCDC	pLCDC;
+
+	if (id)	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC1_BASE);
+	else	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC0_BASE);
+
+	switch(imgch)
+	{
+		case 0:
+			BITCSET (pLCDC->LI0KR, Hw8-Hw0, (ry&0x000000ff));
+			BITCSET (pLCDC->LI0KG, Hw8-Hw0, (gu&0x000000ff));
+			BITCSET (pLCDC->LI0KB, Hw8-Hw0, (bv&0x000000ff));
+			break;
+		case 1:
+			BITCSET (pLCDC->LI1KR, Hw8-Hw0, (ry&0x000000ff));
+			BITCSET (pLCDC->LI1KG, Hw8-Hw0, (gu&0x000000ff));
+			BITCSET (pLCDC->LI1KB, Hw8-Hw0, (bv&0x000000ff));
+			break;
+		case 2:
+			BITCSET (pLCDC->LI2KR, Hw8-Hw0, (ry&0x000000ff));
+			BITCSET (pLCDC->LI2KG, Hw8-Hw0, (gu&0x000000ff));
+			BITCSET (pLCDC->LI2KB, Hw8-Hw0, (bv&0x000000ff));
+			break;
+		default:
+			break;
+	}
+}
+
+
+/*
+ * Setting masking croma-key value for layer1/layer2
+ *
+ * imgch: Image 0/1/2
+ *
+ *	mry	: masking chroma-key value in R(Y) channel for Layer
+ *	mgu	: masking chroma-key value in G(U) channel for Layer
+ *	mbv	: masking chroma-key value in V(V) channel for Layer
+ *
+ */
+void tca_lcdc_setlayerchromakeymask(int id, unsigned int imgch, unsigned int mry, unsigned int mgu, unsigned int mbv)
+{
+	volatile PLCDC	pLCDC;
+
+	if (id)	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC1_BASE);
+	else	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC0_BASE);
+
+	switch(imgch)
+	{
+		case 0:
+			BITCSET (pLCDC->LI0KR, Hw24-Hw16, (mry&0x000000ff)<<16);
+			BITCSET (pLCDC->LI0KG, Hw24-Hw16, (mgu&0x000000ff)<<16);
+			BITCSET (pLCDC->LI0KB, Hw24-Hw16, (mbv&0x000000ff)<<16);
+			break;
+		case 1:
+			BITCSET (pLCDC->LI1KR, Hw24-Hw16, (mry&0x000000ff)<<16);
+			BITCSET (pLCDC->LI1KG, Hw24-Hw16, (mgu&0x000000ff)<<16);
+			BITCSET (pLCDC->LI1KB, Hw24-Hw16, (mbv&0x000000ff)<<16);
+			break;
+		case 2:
+			BITCSET (pLCDC->LI2KR, Hw24-Hw16, (mry&0x000000ff)<<16);
+			BITCSET (pLCDC->LI2KG, Hw24-Hw16, (mgu&0x000000ff)<<16);
+			BITCSET (pLCDC->LI2KB, Hw24-Hw16, (mbv&0x000000ff)<<16);
+			break;
+		default:
+			break;
+	}
+}
+
+
+/*
+ * Setting IMGx Format.
+ *
+ * ch  : 0 - IMG0
+ *		 1 - IMG1
+ *		 2 - IMG2
+ *
+ * fmt : Ref to IMGCH_FMT_t type
+ *
+ */
+// default ZERO-FILL
+void tca_lcdc_setimgchfmt(int id, unsigned int imgch, unsigned int fmt/*, unsigned int pd*/)
+{
+	volatile PLCDC	pLCDC;
+
+	if (id)	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC1_BASE);
+	else	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC0_BASE);
+
+	switch(imgch)
+	{
+		case 0:
+			BITCSET (pLCDC->LI0C, Hw5-Hw0, fmt);
+			if(fmt >=24)
+				BITSET (pLCDC->LI0C, Hw8);
+			else
+				BITCLR (pLCDC->LI0C, Hw8);
+			break;
+		case 1:
+			BITCSET (pLCDC->LI1C, Hw5-Hw0, fmt);
+			if(fmt >=24)
+				BITSET (pLCDC->LI1C, Hw8);
+			else
+				BITCLR (pLCDC->LI1C, Hw8);
+			break;
+		case 2:
+			BITCSET (pLCDC->LI2C, Hw5-Hw0, fmt);
+			if(fmt >=24)
+				BITSET (pLCDC->LI2C, Hw8);
+			else
+				BITCLR (pLCDC->LI2C, Hw8);
+			break;
+		default:
+			break;
+	}
+
+	
+}
+
+
+void tca_lcdc_getimgchfmt(int id, unsigned int imgch, unsigned int *out_fmt/*, unsigned int *out_pd*/)
+{
+	volatile PLCDC	pLCDC;
+
+	if (id)	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC1_BASE);
+	else	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC0_BASE);
+
+	switch(imgch)
+	{
+		case 0:
+			*out_fmt= (pLCDC->LI0C & 0x0000001F);
+			break;
+		case 1:
+			*out_fmt= (pLCDC->LI1C & 0x0000001F);
+			break;
+		case 2:
+			*out_fmt= (pLCDC->LI2C & 0x0000001F);
+			break;
+	}
+}
+
+
+
+/*
+ * Setting LCD IMGx base address
+ *
+ * ch	 : IMG channel.
+ *         0 - IMG0
+ *         1 - IMG1
+ *         2 - IMG2
+ * base0 : IMGx base address. IMG0 Y base address.
+ * base1 :                    IMG0 U base address.
+ * base2 :                    IMG0 V base address. 
+ *
+ */
+void tca_lcdc_setimgchbase(int id, unsigned int imgch, unsigned int base0, unsigned int base1, unsigned int base2)
+{
+	volatile PLCDC	pLCDC;
+
+	if (id)	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC1_BASE);
+	else	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC0_BASE);
+	
+	switch (imgch) 
+	{
+		case 0: //IMG_CH0 :
+			BITCSET(pLCDC->LI0BA0, 0xFFFFFFFF, base0);
+			BITCSET(pLCDC->LI0BA1, 0xFFFFFFFF, base1);
+			BITCSET(pLCDC->LI0BA2, 0xFFFFFFFF, base2);
+			break;
+		case 1: //IMG_CH1 :
+			BITCSET(pLCDC->LI1BA0, 0xFFFFFFFF, base0);
+			break;
+		case 2: //IMG_CH2 :
+			BITCSET(pLCDC->LI2BA0, 0xFFFFFFFF, base0);
+			break;
+	}
+}
+
+void tca_lcdc_getimgchbase(int id, unsigned int imgch, unsigned int *out_base0, unsigned int *out_base1, unsigned int *out_base2)
+{
+	volatile PLCDC	pLCDC;
+
+	if (id)	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC1_BASE);
+	else	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC0_BASE);
+	
+	switch (imgch) 
+	{
+		case 0: //IMG_CH0 :
+			*out_base0 = (pLCDC->LI0BA0);
+			*out_base1 = (pLCDC->LI0BA1);
+			*out_base2 = (pLCDC->LI0BA2);
+			break;
+		case 1: //IMG_CH1 :
+			*out_base0 = (pLCDC->LI1BA0);
+			*out_base1 = 0;
+			*out_base2 = 0;
+			break;
+		case 2: //IMG_CH2 :
+			*out_base0 = (pLCDC->LI2BA0);
+			*out_base1 = 0;
+			*out_base2 = 0;
+			break;
+	}
+}
+
+
+void tca_lcdc_setimgchOffsetInfo(int id, unsigned int imgch, unsigned int offset0, unsigned int offset1)
+{
+	volatile PLCDC	pLCDC;
+
+	if (id)	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC1_BASE);
+	else	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC0_BASE);
+	
+	switch (imgch) 
+	{
+		case 0: //IMG_CH0 :
+			BITCSET(pLCDC->LI0O, 0xFFFFFFFF, (offset0&0x0000ffff) | (offset1&0x0000ffff)<<16);
+			break;
+		case 1: //IMG_CH1 :
+			BITCSET(pLCDC->LI1O, 0xFFFFFFFF, (offset0&0x0000ffff));
+			break;
+		case 2: //IMG_CH2 :
+			BITCSET(pLCDC->LI2O, 0xFFFFFFFF, (offset0&0x0000ffff));
+			break;
+	}
+}
+
+void tca_lcdc_setaddroffset(int id, unsigned int imgch, unsigned int imgwidth, unsigned int fmt)
+{
+	unsigned int offset0=0;
+	unsigned int offset1=0;
+
+	volatile PLCDC	pLCDC;
+
+	if (id)	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC1_BASE);
+	else	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC0_BASE);
+
+	switch(fmt)
+	{
+		case IMGFMT_1BPP:	// 1bpp indexed color
+			offset0 = (1*imgwidth)/8;
+			break;
+		case IMGFMT_2BPP:	// 2bpp indexed color
+			offset0 = (1*imgwidth)/4;
+			break;
+		case IMGFMT_4BPP:	// 4bpp indexed color
+			offset0 = (1*imgwidth)/2;
+			break;
+		case IMGFMT_8BPP:	// 8bpp indexed color
+			offset0 = (1*imgwidth);
+			break;
+		//...
+		case IMGFMT_RGB332:	// RGB332 - 1bytes aligned - R[7:5],G[4:2],B[1:0]
+			offset0 = 1*imgwidth;
+			break;
+		case IMGFMT_RGB444:	// RGB444 - 2bytes aligned - A[15:12],R[11:8],G[7:3],B[3:0]
+		case IMGFMT_RGB565:	// RGB565 - 2bytes aligned - R[15:11],G[10:5],B[4:0]
+		case IMGFMT_RGB555:	// RGB555 - 2bytes aligned - A[15],R[14:10],G[9:5],B[4:0]
+			offset0 = 2*imgwidth;
+			break;
+		case IMGFMT_RGB888:	// RGB888 - 4bytes aligned - A[31:24],R[23:16],G[15:8],B[7:0]
+		case IMGFMT_RGB666:	// RGB666 - 4bytes aligned - A[23:18],R[17:12],G[11:6],B[5:0]
+			offset0 = 4*imgwidth;
+			break;
+		//...
+		case IMGFMT_YUV420:	// YCbCr 4:2:0 Separated format - Not Supported for Image 1 and 2
+			//!!!!
+			offset0 = imgwidth;
+			offset1 = imgwidth/2;
+			break;
+		case IMGFMT_YUV422:		// YCbCr 4:2:2 Separated format - Not Supported for Image 1 and 2
+			//!!!!
+			offset0 = imgwidth;
+			offset1 = imgwidth/2;
+			break;
+		case IMGFMT_YUV422P:	// YCbCr 4:2:2 Sequential format
+			offset0 = 2*imgwidth;
+			break;
+		//...
+		case IMGFMT_YUV420I0:	// YCbCr 4:2:0 interleved type 0 format - Not Supported for Image 1 and 2
+		case IMGFMT_YUV420I1:	// YCbCr 4:2:0 interleved type 1 format - Not Supported for Image 1 and 2
+			//!!!!
+			offset0 = imgwidth;
+			offset1 = imgwidth;
+			break;
+		case IMGFMT_YUV422I0:	// YCbCr 4:2:2 interleved type 0 format - Not Supported for Image 1 and 2
+		case IMGFMT_YUV422I1:	// YCbCr 4:2:2 interleved type 1 format - Not Supported for Image 1 and 2
+			//!!!!
+			offset0 = imgwidth;
+			offset1 = imgwidth;
+			break;
+	}
+
+	switch (imgch) 
+	{
+		case 0: //IMG_CH0 :
+			BITCSET(pLCDC->LI0O, 0xFFFFFFFF, (offset0&0x0000ffff) | (offset1&0x0000ffff)<<16);
+			break;
+		case 1: //IMG_CH1 :
+			BITCSET(pLCDC->LI1O, 0xFFFFFFFF, (offset0&0x0000ffff));
+			break;
+		case 2: //IMG_CH2 :
+			BITCSET(pLCDC->LI2O, 0xFFFFFFFF, (offset0&0x0000ffff));
+			break;
+	}
+}
+
+/*
+ * Setting LCD IMGx Window
+ *
+ * ch	 : IMG channel.
+ *         0 - IMG0
+ *         1 - IMG1
+ *         2 - IMG2
+ * sx    : start offset x
+ * sy    : start offset y
+ * w     : width 
+ * h     : height
+ */
+void tca_lcdc_setimgchwindow(int id, unsigned int imgch, unsigned int sx, unsigned int sy, unsigned int w, unsigned int h)
+{
+	volatile PLCDC	pLCDC;
+
+	if (id)	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC1_BASE);
+	else	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC0_BASE);
+	
+	switch (imgch) 
+	{
+		case 0: //IMG_CH0 :
+			BITCSET(pLCDC->LI0P, 0xFFFFFFFF, (sx&0x0000ffff) | (sy&0x0000ffff)<<16);
+			BITCSET(pLCDC->LI0S, 0xFFFFFFFF, (w &0x0000ffff) | (h &0x0000ffff)<<16);
+			break;
+		case 1: //IMG_CH1 :
+			BITCSET(pLCDC->LI1P, 0xFFFFFFFF, (sx&0x0000ffff) | (sy&0x0000ffff)<<16);
+			BITCSET(pLCDC->LI1S, 0xFFFFFFFF, (w &0x0000ffff) | (h &0x0000ffff)<<16);
+			break;
+		case 2: //IMG_CH2 :
+			BITCSET(pLCDC->LI2P, 0xFFFFFFFF, (sx&0x0000ffff) | (sy&0x0000ffff)<<16);
+			BITCSET(pLCDC->LI2S, 0xFFFFFFFF, (w &0x0000ffff) | (h &0x0000ffff)<<16);
+			break;
+	}
+}
+
+enum {
+	R2Y_CONV_OPTION_0 = 0,		// * Y = 0.299*R + 0.587G + 0.114B 
+								// * Cb = -0.172*R - 0.339*G + 0.511*B + 128 
+								// * Cr = 0.511*R - 0.428*G - 0.083*B + 128 
+								// The range for "RGB" is 16 ~ 235, "Studio Color". 
+								// The result is "Studio Color" - Normally SDTV. 
+
+	R2Y_CONV_OPTION_1 = 1,		// * Y = 0.257*R + 0.504*G + 0.098*B + 16 
+								// * Cb = -0.148*R - 0.291*G + 0.439*B + 128 
+								// * Cr = 0.439*R - 0.368*G - 0.071*B + 128 	
+								// The range for "RGB" is 0 ~ 255, "Computer System Color" 
+								// The result is "Studio Color" - Normally SDTV. 
+
+	R2Y_CONV_OPTION_2 = 2,		// * Y = 0.213*R + 0.715*G + 0.072*B 
+								// * Cb = -0.117*R - 0.394*G + 0.511*B + 128 
+								// * Cr = 0.511*R - 0.464*G - 0.047*B + 128 
+								// The range for "RGB" is 16 ~ 235, "Studio Color".. 
+								// The result is "Studio Color" - Normally HDTV. 
+
+	R2Y_CONV_OPTION_3 = 3,		// * Y = 0.183*R + 0.614*G + 0.062*B + 16 
+								// * Cb = -0.101*R - 0.338*G + 0.439*B + 128 
+								// * Cr = 0.439*R - 0.399*G - 0.040*B + 128
+								// The range for "RGB" is 0 ~ 255, "Computer System Color". 
+								// The result is "Studio Color" - Normally HDTV. 
+};// RGB2YUV_CONV_OPTION_t;
+
+// RGB to YCbCr Conversion Option
+void tca_lcdc_setr2yconvopt(int id, unsigned int conv_opt)
+{
+	volatile PLCDC	pLCDC;
+
+	if (id)	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC1_BASE);
+	else	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC0_BASE);
+
+	if(conv_opt > (unsigned int)R2Y_CONV_OPTION_3)
+		return;
+
+	BITCSET(pLCDC->LCTRL, Hw29|Hw28, conv_opt<<28);
+}
+
+void tca_lcdc_getr2yconvopt(int id, unsigned int *conv_opt_out)
+{
+	volatile PLCDC	pLCDC;
+	volatile unsigned int value;
+
+	if (id)	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC1_BASE);
+	else	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC0_BASE);
+
+	if(conv_opt_out == 0)
+		return;
+
+	value = (pLCDC->LCTRL) & (Hw29|Hw28);
+	*conv_opt_out = (value>>28) & 0x3;;
+}
+
+
+enum {
+	Y2R_CONV_OPTION_0 = 0,		// * R = Y + 1.371 * (Cr - 128) 
+								// * G = Y + 0.336 * (Cb - 128) - 0.698 * (Cr - 128) 
+								// * B = Y + 1.732 * (Cb - 128) 
+								// The range for "YCbCr" is 16 ~ 235, "Studio Color". 
+								// The result is "Studio Color" - Normally SDTV. 
+
+	Y2R_CONV_OPTION_1 = 1,		// * R = 1.164 * (Y - 16) + 1.596 * (Cr - 128) 
+								// * G = 1.164 * (Y - 16) - 0.391 * (Cb - 128) - 0.813 * (Cr - 128) 
+								// * B = 1.164 * (Y - 16) + 2.018 * (Cb - 128) 
+								// The range for "YCbCr" is 16 ~ 235, "Studio Color". 
+								// The result is "Computer System Color" - Normally SDTV. 
+
+	Y2R_CONV_OPTION_2 = 2,		// * R = Y + 1.540 * (Cr - 128) 
+								// * G = Y - 0.183 * (Cb - 128) - 0.459 * (Cr - 128) 
+								// * B = Y + 1.816 * (Cb - 128) 
+								// The range for "YCbCr" is 16 ~ 235, "Studio Color". 
+								// The result is "Studio Color" - Normally HDTV.
+
+	Y2R_CONV_OPTION_3 = 3,		// * R = 1.164 * (Y - 16) + 1.793 * (Cr - 128) 
+								// * G = 1.164 * (Y - 16) - 0.213 * (Cb - 128) - 0.534 * (Cr - 128) 
+								// * B = 1.164 * (Y - 16) + 2.115 * (Cb - 128) 
+								// The range for "YCbCr" is 16 ~ 235, "Studio Color". 
+								// The result is "Computer System Color" - Normally HDTV.
+
+};// YUV2RGB_CONV_OPTION_t;
+
+void tca_lcdc_setimgy2rconvopt(int id, unsigned int imgch, unsigned int conv_opt)
+{
+	volatile PLCDC	pLCDC;
+
+	if (id)	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC1_BASE);
+	else	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC0_BASE);
+
+	if (id!=1 && imgch>0)
+		return;
+	
+	switch (imgch) 
+	{
+		case 0: //IMG_CH0 :
+			BITCSET(pLCDC->LI0C, 0x00000600, conv_opt<<9);
+			break;
+		case 1: //IMG_CH1 :
+			BITCSET(pLCDC->LI1C, 0x00000600, conv_opt<<9);
+			break;
+		case 2: //IMG_CH2 :
+			BITCSET(pLCDC->LI2C, 0x00000600, conv_opt<<9);
+			break;
+	}
+}
+
+void tca_lcdc_getimgy2rconvopt(int id, unsigned int imgch, unsigned int *conv_opt_out)
+{
+	volatile PLCDC	pLCDC;
+
+	if (id)	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC1_BASE);
+	else	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC0_BASE);
+
+	if (id!=1 && imgch>0)
+		return;
+	
+	switch (imgch) 
+	{
+		case 0: //IMG_CH0 :
+			*conv_opt_out	= ((pLCDC->LI0C)>>9) & 0x3;
+			break;
+		case 1: //IMG_CH1 :
+			*conv_opt_out	= ((pLCDC->LI1C)>>9) & 0x3;
+			break;
+		case 2: //IMG_CH2 :
+			*conv_opt_out	= ((pLCDC->LI2C)>>9) & 0x3;
+			break;
+	}
+}
+
+
+void tca_lcdc_setcolorenhancement(int id, unsigned int hue, unsigned int bright, unsigned int cont)
+{
+	volatile PLCDC	pLCDC;
+
+	if (id)	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC1_BASE);
+	else	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC0_BASE);
+
+	BITCSET(pLCDC->LENH, 0x00ff0000, hue<<16);
+	BITCSET(pLCDC->LENH, 0x0000ff00, bright<<8);
+	BITCSET(pLCDC->LENH, 0x000000ff, cont);
+}
+
+void tca_lcdc_getcolorenhancement(int id, unsigned int *hue, unsigned int *bright, unsigned int *cont)
+{
+	volatile PLCDC	pLCDC;
+
+	if (id)	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC1_BASE);
+	else	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC0_BASE);
+
+	*hue	= ((pLCDC->LENH)>>16) & 0xff;
+	*bright = ((pLCDC->LENH)>> 8) & 0xff;
+	*cont	= ((pLCDC->LENH)>> 0) & 0xff;
+}
+
+void tca_lcdc_setimgenhancement(int id, unsigned int imgch, unsigned int hue, unsigned int bright, unsigned int cont)
+{
+	volatile PLCDC	pLCDC;
+
+	if (id)	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC1_BASE);
+	else	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC0_BASE);
+
+	if (id!=1 && imgch>0)
+		return;
+	
+	switch (imgch) 
+	{
+		case 0: //IMG_CH0 :
+			BITCSET(pLCDC->LI0EN, 0x00ff0000, hue<<16);
+			BITCSET(pLCDC->LI0EN, 0x0000ff00, bright<<8);
+			BITCSET(pLCDC->LI0EN, 0x000000ff, cont);
+			break;
+		case 1: //IMG_CH1 :
+			BITCSET(pLCDC->LI1EN, 0x00ff0000, hue<<16);
+			BITCSET(pLCDC->LI1EN, 0x0000ff00, bright<<8);
+			BITCSET(pLCDC->LI1EN, 0x000000ff, cont);
+			break;
+		case 2: //IMG_CH2 :
+			BITCSET(pLCDC->LI2EN, 0x00ff0000, hue<<16);
+			BITCSET(pLCDC->LI2EN, 0x0000ff00, bright<<8);
+			BITCSET(pLCDC->LI2EN, 0x000000ff, cont);
+			break;
+	}
+}
+
+void tca_lcdc_getimgenhancement(int id, unsigned int imgch, unsigned int *hue, unsigned int *bright, unsigned int *cont)
+{
+	volatile PLCDC	pLCDC;
+
+	if (id)	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC1_BASE);
+	else	pLCDC = (volatile PLCDC)tcc_p2v(HwLCDC0_BASE);
+
+	if (id!=1 && imgch>0)
+		return;
+	
+	switch (imgch) 
+	{
+		case 0: //IMG_CH0 :
+			*hue	= ((pLCDC->LI0EN)>>16) & 0xff;
+			*bright = ((pLCDC->LI0EN)>> 8) & 0xff;
+			*cont	= ((pLCDC->LI0EN)>> 0) & 0xff;
+			break;
+		case 1: //IMG_CH1 :
+			*hue	= ((pLCDC->LI1EN)>>16) & 0xff;
+			*bright = ((pLCDC->LI1EN)>> 8) & 0xff;
+			*cont	= ((pLCDC->LI1EN)>> 0) & 0xff;
+			break;
+		case 2: //IMG_CH2 :
+			*hue	= ((pLCDC->LI2EN)>>16) & 0xff;
+			*bright = ((pLCDC->LI2EN)>> 8) & 0xff;
+			*cont	= ((pLCDC->LI2EN)>> 0) & 0xff;
+			break;
+	}
+}
+
+
Index: linux-2.6.29/drivers/video/tca_tvout.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/video/tca_tvout.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,930 @@
+
+/****************************************************************************
+ *   FileName    : tca_tvo.c
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+/*****************************************************************************
+*
+* Header Files Include
+*
+******************************************************************************/
+
+#ifdef __KERNEL__
+#include <linux/delay.h>
+#include <linux/string.h>
+#include "bsp.h"
+#include <mach/tca_ckc.h>
+#else
+#include <windows.h>
+#include <bsp.h>
+
+#include "TCC89x_Physical.h"
+#include "TCC89x_Structures.h"
+#include "tcc_ckc.h"
+#include "tcc_gpio.h"
+#endif
+
+#include "tca_tvout.h"
+
+/*****************************************************************************
+*
+* Defines
+*
+******************************************************************************/
+// trick.
+
+#if defined(__KERNEL__)
+#define	tcc_allocbaseaddress(X)		(X)
+
+void tcc_ckc_setperi(unsigned int periname,unsigned int isenable, unsigned int freq, unsigned int sor)
+{
+	tca_ckc_setperi(periname,isenable, freq, sor);
+}
+
+volatile int tcc_ckc_getperi(unsigned int periname)
+{
+	return tca_ckc_getperi(periname);
+}
+
+#endif
+
+#if !defined(__KERNEL__)
+
+#if defined(HwTVE_BASE)
+#undef HwTVE_BASE
+#endif
+#define	HwTVE_BASE								*(volatile unsigned long *)0xB0240000	// TV Encoder Base Register
+
+#endif //__KERNEL__
+
+#define	HwTVESTATA								*(volatile unsigned long *)(((unsigned long)&HwTVE_BASE) + 0x0)//0xB0240000	// R, Status Register
+
+#define	HwTVECMDA								*(volatile unsigned long *)(((unsigned long)&HwTVE_BASE) + 0x4)//0xB0240004	// R/W, Encoder Mode Control Register A
+	#define	HwTVECMDA_PWDENC_PD					Hw7								// Power down mode for entire digital logic of TV encoder
+	#define	HwTVECMDA_FDRST_1					Hw6								// Chroma is free running as compared to H-sync
+	#define	HwTVECMDA_FDRST_0					HwZERO							// Relationship between color burst & H-sync is maintained for video standards
+	#define	HwTVECMDA_FSCSEL(X)					((X)*Hw4)
+	#define	HwTVECMDA_FSCSEL_NTSC					HwTVECMDA_FSCSEL(0)			// Color subcarrier frequency is 3.57954545 MHz for NTSC
+	#define	HwTVECMDA_FSCSEL_PALX					HwTVECMDA_FSCSEL(1)			// Color subcarrier frequency is 4.43361875 MHz for PAL-B,D,G,H,I,N
+	#define	HwTVECMDA_FSCSEL_PALM					HwTVECMDA_FSCSEL(2)			// Color subcarrier frequency is 3.57561149 MHz for PAL-M
+	#define	HwTVECMDA_FSCSEL_PALCN					HwTVECMDA_FSCSEL(3)			// Color subcarrier frequency is 3.58205625 MHz for PAL-combination N
+	#define	HwTVECMDA_FSCSEL_MASK					HwTVECMDA_FSCSEL(3)
+	#define	HwTVECMDA_PEDESTAL					Hw3								// Video Output has a pedestal
+	#define	HwTVECMDA_NO_PEDESTAL				HwZERO							// Video Output has no pedestal
+	#define	HwTVECMDA_PIXEL_SQUARE				Hw2								// Input data is at square pixel rates.
+	#define	HwTVECMDA_PIXEL_601					HwZERO							// Input data is at 601 rates.
+	#define	HwTVECMDA_IFMT_625					Hw1								// Output data has 625 lines
+	#define	HwTVECMDA_IFMT_525					HwZERO							// Output data has 525 lines
+	#define	HwTVECMDA_PHALT_PAL					Hw0								// PAL encoded chroma signal output
+	#define	HwTVECMDA_PHALT_NTSC				HwZERO							// NTSC encoded chroma signal output
+
+#define	HwTVECMDB								*(volatile unsigned long *)(((unsigned long)&HwTVE_BASE) + 0x8)//0xB0240008	// R/W, Encoder Mode Control Register B
+	#define	HwTVECMDB_YBIBLK_BLACK				Hw4								// Video data is forced to Black level for Vertical non VBI processed lines.
+	#define	HwTVECMDB_YBIBLK_BYPASS				HwZERO							// Input data is passed through forn non VBI processed lines.
+	#define	HwTVECMDB_CBW(X)					((X)*Hw2)
+	#define	HwTVECMDB_CBW_LOW						HwTVECMDB_CBW(0)			// Low Chroma band-width
+	#define	HwTVECMDB_CBW_MEDIUM					HwTVECMDB_CBW(1)			// Medium Chroma band-width
+	#define	HwTVECMDB_CBW_HIGH						HwTVECMDB_CBW(2)			// High Chroma band-width
+	#define	HwTVECMDB_CBW_MASK						HwTVECMDB_CBW(3)			// 
+	#define	HwTVECMDB_YBW(X)					((X)*Hw0)
+	#define	HwTVECMDB_YBW_LOW						HwTVECMDB_YBW(0)			// Low Luma band-width
+	#define	HwTVECMDB_YBW_MEDIUM					HwTVECMDB_YBW(1)			// Medium Luma band-width
+	#define	HwTVECMDB_YBW_HIGH						HwTVECMDB_YBW(2)			// High Luma band-width
+	#define	HwTVECMDB_YBW_MASK						HwTVECMDB_YBW(3)			// 
+
+#define	HwTVEGLK								*(volatile unsigned long *)(((unsigned long)&HwTVE_BASE) + 0xc)//0xB024000C	// R/W, Encoder Clock Generator Register
+	#define	HwTVEGLK_XT24_24MHZ					Hw4								// 24MHz Clock input
+	#define	HwTVEGLK_XT24_27MHZ					HwZERO							// 27MHz Clock input
+	#define	HwTVEGLK_GLKEN_RST_EN				Hw3								// Reset Genlock
+	#define	HwTVEGLK_GLKEN_RST_DIS				~Hw3							// Release Genlock
+	#define	HwTVEGLK_GLKE(X)					((X)*Hw1)
+	#define	HwTVEGLK_GLKE_INT						HwTVEGLK_GLKE(0)			// Chroma Fsc is generated from internal constants based on current user setting
+	#define	HwTVEGLK_GLKE_RTCO						HwTVEGLK_GLKE(2)			// Chroma Fsc is adjusted based on external RTCO input
+	#define	HwTVEGLK_GLKE_CLKI						HwTVEGLK_GLKE(3)			// Chroma Fsc tracks non standard encoder clock (CLKI) frequency
+	#define	HwTVEGLK_GLKE_MASK						HwTVEGLK_GLKE(3)			//
+	#define	HwTVEGLK_GLKEN_GLKPL_HIGH			Hw0								// PAL ID polarity is active high
+	#define	HwTVEGLK_GLKEN_GLKPL_LOW			HwZERO							// PAL ID polarity is active low
+
+#define	HwTVESCH								*(volatile unsigned long *)(((unsigned long)&HwTVE_BASE) + 0x10)//0xB0240010	// R/W, Color burst phase relation control (relative to Sync trip)
+
+#define	HwTVEHUE								*(volatile unsigned long *)(((unsigned long)&HwTVE_BASE) + 0x14)//0xB0240014	// R/W, Active video Color burst phase relation control (relative to color burst)
+
+#define	HwTVESAT								*(volatile unsigned long *)(((unsigned long)&HwTVE_BASE) + 0x18)//0xB0240018	// R/W, Active video Chroma gain control relative to color burst gain
+
+#define	HwTVECONT								*(volatile unsigned long *)(((unsigned long)&HwTVE_BASE) + 0x1c)//0xB024001C	// R/W, Luma gain control
+
+#define	HwTVEBRIGHT								*(volatile unsigned long *)(((unsigned long)&HwTVE_BASE) + 0x20)//0xB0240020	// R/W, Luma offset control
+
+#define	HwTVEFSC_ADJM							*(volatile unsigned long *)(((unsigned long)&HwTVE_BASE) + 0x24)//0xB0240024	// R/W, MSB of Fsc adjust value
+#define	HwTVEFSC_ADJL							*(volatile unsigned long *)(((unsigned long)&HwTVE_BASE) + 0x28)//0xB0240028	// R/W, LSB of Fsc adjust value
+
+#define	HwTVECMDC								*(volatile unsigned long *)(((unsigned long)&HwTVE_BASE) + 0x2c)//0xB024002C	// R/W, Encoder Mode Control Register C
+	#define	HwTVECMDC_CSMDE_EN					Hw7								// Composite Sync mode enabled
+	#define	HwTVECMDC_CSMDE_DIS					~Hw7							// Composite Sync mode disabled (pin is tri-stated)
+	#define	HwTVECMDC_CSMD(X)					((X)*Hw5)
+	#define	HwTVECMDC_CSMD_CSYNC					HwTVECMDC_CSMD(0)			// CSYN pin is Composite sync signal
+	#define	HwTVECMDC_CSMD_KEYCLAMP					HwTVECMDC_CSMD(1)			// CSYN pin is Keyed clamp signal
+	#define	HwTVECMDC_CSMD_KEYPULSE					HwTVECMDC_CSMD(2)			// CSYN pin is Keyed pulse signal
+	#define	HwTVECMDC_CSMD_MASK						HwTVECMDC_CSMD(3)
+	#define	HwTVECMDC_RGBSYNC(X)				((X)*Hw3)
+	#define	HwTVECMDC_RGBSYNC_NOSYNC				HwTVECMDC_RGBSYNC(0)		// Disable RGBSYNC (when output is configured for analog EGB mode)
+	#define	HwTVECMDC_RGBSYNC_RGB					HwTVECMDC_RGBSYNC(1)		// Sync on RGB output signal (when output is configured for analog EGB mode)
+	#define	HwTVECMDC_RGBSYNC_G						HwTVECMDC_RGBSYNC(2)		// Sync on G output signal (when output is configured for analog EGB mode)
+	#define	HwTVECMDC_RGBSYNC_MASK					HwTVECMDC_RGBSYNC(3)
+
+#define	HwTVEDACSEL								*(volatile unsigned long *)(((unsigned long)&HwTVE_BASE) + 0x40)//0xB0240040	// R/W, DAC Output Selection
+	#define	HwTVEDACSEL_DACSEL_CODE0			HwZERO							// Data output is diabled (output is code '0')
+	#define	HwTVEDACSEL_DACSEL_CVBS				Hw0								// Data output in CVBS format
+
+#define	HwTVEDACPD								*(volatile unsigned long *)(((unsigned long)&HwTVE_BASE) + 0x50)//0xB0240050	// R/W, DAC Power Down
+	#define	HwTVEDACPD_PD_EN					Hw0								// DAC Power Down Enabled
+	#define	HwTVEDACPD_PD_DIS					~Hw0							// DAC Power Down Disabled
+
+#define	HwTVEICNTL								*(volatile unsigned long *)(((unsigned long)&HwTVE_BASE) + 0x80)//0xB0240080	// R/W, Sync Control
+	#define	HwTVEICNTL_FSIP_ODDHIGH				Hw7								// Odd field active high
+	#define	HwTVEICNTL_FSIP_ODDLOW				HwZERO							// Odd field active low
+	#define	HwTVEICNTL_VSIP_HIGH				Hw6								// V-sync active high
+	#define	HwTVEICNTL_VSIP_LOW					HwZERO							// V-sync active low
+	#define	HwTVEICNTL_HSIP_HIGH				Hw5								// H-sync active high
+	#define	HwTVEICNTL_HSIP_LOW					HwZERO							// H-sync active low
+	#define	HwTVEICNTL_HSVSP_RISING				Hw4								// H/V-sync latch enabled at rising edge
+	#define	HwTVEICNTL_HVVSP_FALLING			HwZERO							// H/V-sync latch enabled at falling edge
+	#define	HwTVEICNTL_VSMD_START				Hw3								// Even/Odd field H/V sync output are aligned to video line start
+	#define	HwTVEICNTL_VSMD_MID					HwZERO							// Even field H/V sync output are aligned to video line midpoint
+	#define	HwTVEICNTL_ISYNC(X)					((X)*Hw0)
+	#define	HwTVEICNTL_ISYNC_FSI					HwTVEICNTL_ISYNC(0)			// Alignment input format from FSI pin
+	#define	HwTVEICNTL_ISYNC_HVFSI					HwTVEICNTL_ISYNC(1)			// Alignment input format from HSI,VSI,FSI pin
+	#define	HwTVEICNTL_ISYNC_HVSI					HwTVEICNTL_ISYNC(2)			// Alignment input format from HSI,VSI pin
+	#define	HwTVEICNTL_ISYNC_VFSI					HwTVEICNTL_ISYNC(3)			// Alignment input format from VSI,FSI pin
+	#define	HwTVEICNTL_ISYNC_VSI					HwTVEICNTL_ISYNC(4)			// Alignment input format from VSI pin
+	#define	HwTVEICNTL_ISYNC_ESAV_L					HwTVEICNTL_ISYNC(5)			// Alignment input format from EAV,SAV codes (line by line)
+	#define	HwTVEICNTL_ISYNC_ESAV_F					HwTVEICNTL_ISYNC(6)			// Alignment input format from EAV,SAV codes (frame by frame)
+	#define	HwTVEICNTL_ISYNC_FREE					HwTVEICNTL_ISYNC(7)			// Alignment is free running (Master mode)
+	#define	HwTVEICNTL_ISYNC_MASK					HwTVEICNTL_ISYNC(7)
+
+#define	HwTVEHVOFFST							*(volatile unsigned long *)(((unsigned long)&HwTVE_BASE) + 0x84)//0xB0240084	// R/W, Offset Control
+	#define	HwTVEHVOFFST_INSEL(X)				((X)*Hw6)
+	#define	HwTVEHVOFFST_INSEL_BW16_27MHZ			HwTVEHVOFFST_INSEL(0)		// 16bit YUV 4:2:2 sampled at 27MHz
+	#define	HwTVEHVOFFST_INSEL_BW16_13P5MHZ			HwTVEHVOFFST_INSEL(1)		// 16bit YUV 4:2:2 sampled at 13.5MHz
+	#define	HwTVEHVOFFST_INSEL_BW8_13P5MHZ			HwTVEHVOFFST_INSEL(2)		// 8bit YUV 4:2:2 sampled at 13.5MHz
+	#define	HwTVEHVOFFST_INSEL_MASK					HwTVEHVOFFST_INSEL(3)
+	#define	HwTVEHVOFFST_VOFFST_256				Hw3								// Vertical offset bit 8 (Refer to HwTVEVOFFST)
+	#define	HwTVEHVOFFST_HOFFST_1024			Hw2								// Horizontal offset bit 10 (Refer to HwTVEHOFFST)
+	#define	HwTVEHVOFFST_HOFFST_512				Hw1								// Horizontal offset bit 9 (Refer to HwTVEHOFFST)
+	#define	HwTVEHVOFFST_HOFFST_256				Hw0								// Horizontal offset bit 8 (Refer to HwTVEHOFFST)
+
+#define	HwTVEHOFFST								*(volatile unsigned long *)(((unsigned long)&HwTVE_BASE) + 0x88)//0xB0240088	// R/W, Horizontal Offset Control (bit [7:0], bit 10~8 is at HwTVEHVOFFST)
+#define	HwTVEVOFFST								*(volatile unsigned long *)(((unsigned long)&HwTVE_BASE) + 0x8c)//0xB024008C	// R/W, Vertical Offset Control (bit [7:0], bit 8 is at HwTVEHVOFFST)
+
+#define	HwTVEHSVSO								*(volatile unsigned long *)(((unsigned long)&HwTVE_BASE) + 0x90)//0xB0240090	// R/W, Sync Output Control
+	#define	HwTVEHSVSO_VSOB_256					Hw6								// VSOB bit 8 (Refer to HwVSOB)
+	#define	HwTVEHSVSO_HSOB_1024				Hw5								// HSOB bit 10 (Refer to HwHSOB)
+	#define	HwTVEHSVSO_HSOB_512					Hw4								// HSOB bit 9 (Refer to HwHSOB)
+	#define	HwTVEHSVSO_HSOB_256					Hw3								// HSOB bit 8 (Refer to HwHSOB)
+	#define	HwTVEHSVSO_HSOE_1024				Hw2								// HSOE bit 10 (Refer to HwHSOE)
+	#define	HwTVEHSVSO_HSOE_512					Hw1								// HSOE bit 9 (Refer to HwHSOE)
+	#define	HwTVEHSVSO_HSOE_256					Hw0								// HSOE bit 8 (Refer to HwHSOE)
+
+#define	HwTVEHSOE								*(volatile unsigned long *)(((unsigned long)&HwTVE_BASE) + 0x94)//0xB0240094	// R/W, Trailing Edge of Horizontal Sync Control (bit[7:0], bit 10~8 is at HwTVEHSVSO)
+
+#define	HwTVEHSOB								*(volatile unsigned long *)(((unsigned long)&HwTVE_BASE) + 0x98)//0xB0240098	// R/W, Leading Edge of Horizontal Sync Control (bit[7:0], bit 10~8 is at HwTVEHSVSO)
+
+#define	HwTVEVSOB								*(volatile unsigned long *)(((unsigned long)&HwTVE_BASE) + 0x9c)//0xB024009C	// R/W, Leading Edge of Vertical Sync Control (bit[7:0], bit 8 is at HwTVEHSVSO)
+
+#define	HwTVEVSOE								*(volatile unsigned long *)(((unsigned long)&HwTVE_BASE) + 0xa0)//0xB02400A0	// R/W, Trailing Edge of Vertical Sync Control
+	#define	HwTVEVSOE_VSOST(X)					((X)*Hw6)						// Programs V-sync relative location for Odd/Even Fields.
+	#define	HwTVEVSOE_NOVRST_EN					Hw5								// No vertical reset on every field
+	#define	HwTVEVSOE_NOVRST_NORMAL				HwZERO							// Normal vertical reset operation (interlaced output timing)
+	#define	HwTVEVSOE_VSOE(X)					((X)*Hw0)						// Trailing Edge of Vertical Sync Control
+
+#define	HwTVEVENCON								*(volatile unsigned long *)(((unsigned long)&HwTVE_BASE) + 0x800)//0xB0240800	// R/W, Connection between LCDC & TVEncoder Control
+	#define	HwTVEVENCON_EN_EN					Hw0								// Connection between LCDC & TVEncoder Enabled
+	#define	HwTVEVENCON_EN_DIS					~Hw0							// Connection between LCDC & TVEncoder Disabled
+
+#define	HwTVEVENCIF								*(volatile unsigned long *)(((unsigned long)&HwTVE_BASE) + 0x804)//0xB0240804	// R/W, I/F between LCDC & TVEncoder Selection
+	#define	HwTVEVENCIF_DAC_EN					Hw2								// Enable DAC of TVEncoder
+	#define	HwTVEVENCIF_MV_1					Hw1								// reserved
+	#define	HwTVEVENCIF_FMT_1					Hw0								// PXDATA[7:0] => CIN[7:0], PXDATA[15:8] => YIN[7:0]
+	#define	HwTVEVENCIF_FMT_0					HwZERO							// PXDATA[7:0] => YIN[7:0], PXDATA[15:8] => CIN[7:0]
+
+/*****************************************************************************
+*
+* structures
+*
+******************************************************************************/
+
+/*****************************************************************************
+*
+* Variables
+*
+******************************************************************************/
+
+	static unsigned int  gTvoutFlag=0;
+	static unsigned int  gTvoutFlag_prev=0;
+
+	static unsigned int	 gTvoutLcdcId = 1;
+
+	unsigned long gRegPCK_LCD;
+	unsigned long gRegLCLKDIV;
+
+	unsigned long gRegLHTIME1;
+    unsigned long gRegLHTIME2;
+	
+    unsigned long gRegLVTIME1;
+    unsigned long gRegLVTIME2;
+    unsigned long gRegLVTIME3;
+    unsigned long gRegLVTIME4;
+
+    unsigned long gRegLDS;
+	unsigned long gRegLCTRL;
+
+	unsigned long gRegLI0P;
+	unsigned long gRegLI1P;
+	unsigned long gRegLI2P;
+
+	unsigned long gRegLI0C;
+	unsigned long gRegLI1C;
+	unsigned long gRegLI2C;
+
+	unsigned long gRegLI0S;
+	unsigned long gRegLI1S;
+	unsigned long gRegLI2S;
+
+	static int gHDMIPWRFlag=0;
+
+/*****************************************************************************
+*
+* Functions
+*
+******************************************************************************/
+
+/*****************************************************************************
+* Function Name : tca_tvo_setmode()
+******************************************************************************/
+void tca_tvo_connectlcdc(unsigned int id)
+{
+	PDDICONFIG  pDDICfg = (DDICONFIG *)tcc_allocbaseaddress((unsigned int)&HwDDI_CONFIG_BASE);
+
+	if(id)
+	{
+		pDDICfg->NTSCPAL_SEL |= Hw0;	// LCDC1	- default
+		gTvoutLcdcId = 1;
+	}
+	else
+	{
+		pDDICfg->NTSCPAL_SEL &= ~Hw0;	// LCDC0
+		gTvoutLcdcId= 0;
+	}
+}
+
+
+void tca_tvo_setlclk27mhz(int lcdc_id)
+{
+	const unsigned int dst_lclk = 270000;//540000;	// 270000 * ((div))
+	const unsigned int div = 1;
+
+	PLCDC	pLCDC_BASE[2]   = {(LCDC *)tcc_allocbaseaddress((unsigned int)&HwLCDC0_BASE),
+							   (LCDC *)tcc_allocbaseaddress((unsigned int)&HwLCDC1_BASE)};
+	PLCDC	pLCDC;
+
+	unsigned int src_pll;
+	unsigned int ret_lclk;
+	unsigned int diff_cur, diff_tmp;
+	int i;
+
+	pLCDC = pLCDC_BASE[lcdc_id];
+
+	src_pll  = PCDIRECTPLL0;
+	diff_tmp = dst_lclk*2;
+	
+	for(i=PCDIRECTPLL0; i<=PCDIRECTPLL3; i++)
+	{
+		tcc_ckc_setperi(PERI_LCD0+gTvoutLcdcId,ENABLE,dst_lclk,i);
+		ret_lclk = tcc_ckc_getperi(PERI_LCD0+gTvoutLcdcId);
+
+		diff_cur = (ret_lclk>dst_lclk)?(ret_lclk-dst_lclk):(dst_lclk-ret_lclk);
+
+		if(diff_cur <= diff_tmp)
+		{
+			src_pll = i;
+			diff_tmp = diff_cur;
+		}
+
+#ifdef __KERNEL__
+	printk("Check   LCLK --> %d, %s%d.  pclk(%d)\n", ret_lclk, "PCDIRECTPLL", i, ret_lclk/div);
+#else
+	RETAILMSG(1, (TEXT("Check   LCLK --> %d, %s%d.  pclk(%d)\r\n"), ret_lclk, TEXT("PCDIRECTPLL"), i, ret_lclk/div));
+#endif
+	}
+	
+	tcc_ckc_setperi(PERI_LCD0+gTvoutLcdcId,ENABLE,dst_lclk,src_pll);
+	ret_lclk = tcc_ckc_getperi(PERI_LCD0+gTvoutLcdcId);
+	
+	pLCDC->LCLKDIV = div/2;
+
+#ifdef __KERNEL__
+	printk("LCDC%d - PCLK[%d] LCLK[%d] , %s%d.\n", gTvoutLcdcId, ret_lclk/div, ret_lclk, "PCDIRECTPLL", src_pll);
+#else
+	RETAILMSG(1, (TEXT("LCDC%d - PCLK[%d] LCLK[%d] , %s%d.\r\n"), gTvoutLcdcId, ret_lclk/div, ret_lclk, TEXT("PCDIRECTPLL"), src_pll));
+#endif
+}
+
+
+/*****************************************************************************
+* Function Name : tca_tvo_setmode()
+******************************************************************************/
+void tca_tvo_setmode(unsigned int type)
+{
+	PPMU lPMU = (PMU *)tcc_allocbaseaddress((unsigned int)&HwPMU_BASE);
+	
+	lPMU->PWROFF &= ~Hw0;	/* Video DAC */
+
+	switch(type)
+	{
+		case	NTSC_M:
+		case	NTSC_M_J:
+		default:
+				HwTVECMDA = 
+//					HwTVECMDA_PWDENC_PD				|	// [7]   Power down mode for entire digital logic of TV encoder
+					HwTVECMDA_FDRST_1				|	// [6]   Chroma is free running as compared to H-sync
+//					HwTVECMDA_FDRST_0				|	// [6]   Relationship between color burst & H-sync is maintained for video standards
+					HwTVECMDA_FSCSEL_NTSC			|	// [5:4] Color subcarrier frequency is 3.57954545 MHz for NTSC
+//					HwTVECMDA_FSCSEL_PALX			|	// [5:4] Color subcarrier frequency is 4.43361875 MHz for PAL-B,D,G,H,I,N
+//					HwTVECMDA_FSCSEL_PALM			|	// [5:4] Color subcarrier frequency is 3.57561149 MHz for PAL-M
+//					HwTVECMDA_FSCSEL_PALCN			|	// [5:4] Color subcarrier frequency is 3.58205625 MHz for PAL-combination N
+					HwTVECMDA_PEDESTAL				|	// [3]   Video Output has a pedestal (0 is NTSC-J)
+//					HwTVECMDA_PIXEL_SQUARE			|	// [2]   Input data is at square pixel rates.
+					HwTVECMDA_PIXEL_601				|	// [2]   Input data is at 601 rates.
+//					HwTVECMDA_IFMT_625				|	// [1]   Output data has 625 lines
+					HwTVECMDA_IFMT_525				|	// [1]   Output data has 525 lines
+//					HwTVECMDA_PHALT_PAL				|	// [0]   PAL encoded chroma signal output
+					HwTVECMDA_PHALT_NTSC			|	// [0]   NTSC encoded chroma signal output
+					0;
+
+				if	(type == NTSC_M_J)
+					HwTVECMDA &= ~(HwTVECMDA_PEDESTAL);
+//				RETAILMSG(1,(TEXT("[TV Out] Set to NTSC-M Mode\n")));
+				break;
+
+		case	NTSC_N:
+		case	NTSC_N_J:
+				HwTVECMDA = 
+//					HwTVECMDA_PWDENC_PD				|	// [7]   Power down mode for entire digital logic of TV encoder
+//					HwTVECMDA_FDRST_1				|	// [6]   Chroma is free running as compared to H-sync
+					HwTVECMDA_FDRST_0				|	// [6]   Relationship between color burst & H-sync is maintained for video standards
+					HwTVECMDA_FSCSEL_NTSC			|	// [5:4] Color subcarrier frequency is 3.57954545 MHz for NTSC
+//					HwTVECMDA_FSCSEL_PALX			|	// [5:4] Color subcarrier frequency is 4.43361875 MHz for PAL-B,D,G,H,I,N
+//					HwTVECMDA_FSCSEL_PALM			|	// [5:4] Color subcarrier frequency is 3.57561149 MHz for PAL-M
+//					HwTVECMDA_FSCSEL_PALCN			|	// [5:4] Color subcarrier frequency is 3.58205625 MHz for PAL-combination N
+					HwTVECMDA_PEDESTAL				|	// [3]   Video Output has a pedestal (0 is NTSC-J)
+//					HwTVECMDA_PIXEL_SQUARE			|	// [2]   Input data is at square pixel rates.
+					HwTVECMDA_PIXEL_601				|	// [2]   Input data is at 601 rates.
+					HwTVECMDA_IFMT_625				|	// [1]   Output data has 625 lines
+//					HwTVECMDA_IFMT_525				|	// [1]   Output data has 525 lines
+//					HwTVECMDA_PHALT_PAL				|	// [0]   PAL encoded chroma signal output
+					HwTVECMDA_PHALT_NTSC			|	// [0]   NTSC encoded chroma signal output
+					0;
+
+				if	(type == NTSC_M_J)
+					HwTVECMDA &= ~(HwTVECMDA_PEDESTAL);
+//				RETAILMSG(1,(TEXT("[TV Out] Set to NTSC-N Mode\n")));
+				break;
+
+		case	NTSC_443:
+				HwTVECMDA = 
+//					HwTVECMDA_PWDENC_PD				|	// [7]   Power down mode for entire digital logic of TV encoder
+//					HwTVECMDA_FDRST_1				|	// [6]   Chroma is free running as compared to H-sync
+					HwTVECMDA_FDRST_0				|	// [6]   Relationship between color burst & H-sync is maintained for video standards
+//					HwTVECMDA_FSCSEL_NTSC			|	// [5:4] Color subcarrier frequency is 3.57954545 MHz for NTSC
+					HwTVECMDA_FSCSEL_PALX			|	// [5:4] Color subcarrier frequency is 4.43361875 MHz for PAL-B,D,G,H,I,N
+//					HwTVECMDA_FSCSEL_PALM			|	// [5:4] Color subcarrier frequency is 3.57561149 MHz for PAL-M
+//					HwTVECMDA_FSCSEL_PALCN			|	// [5:4] Color subcarrier frequency is 3.58205625 MHz for PAL-combination N
+					HwTVECMDA_PEDESTAL				|	// [3]   Video Output has a pedestal (0 is NTSC-J)
+//					HwTVECMDA_PIXEL_SQUARE			|	// [2]   Input data is at square pixel rates.
+					HwTVECMDA_PIXEL_601				|	// [2]   Input data is at 601 rates.
+//					HwTVECMDA_IFMT_625				|	// [1]   Output data has 625 lines
+					HwTVECMDA_IFMT_525				|	// [1]   Output data has 525 lines
+//					HwTVECMDA_PHALT_PAL				|	// [0]   PAL encoded chroma signal output
+					HwTVECMDA_PHALT_NTSC			|	// [0]   NTSC encoded chroma signal output
+					0;
+//				RETAILMSG(1,(TEXT("[TV Out] Set to NTSC 4.43 Mode\n")));
+				break;
+
+		case	PAL_M:
+				HwTVECMDA = 
+//					HwTVECMDA_PWDENC_PD				|	// [7]   Power down mode for entire digital logic of TV encoder
+//					HwTVECMDA_FDRST_1				|	// [6]   Chroma is free running as compared to H-sync
+					HwTVECMDA_FDRST_0				|	// [6]   Relationship between color burst & H-sync is maintained for video standards
+//					HwTVECMDA_FSCSEL_NTSC			|	// [5:4] Color subcarrier frequency is 3.57954545 MHz for NTSC
+//					HwTVECMDA_FSCSEL_PALX			|	// [5:4] Color subcarrier frequency is 4.43361875 MHz for PAL-B,D,G,H,I,N
+					HwTVECMDA_FSCSEL_PALM			|	// [5:4] Color subcarrier frequency is 3.57561149 MHz for PAL-M
+//					HwTVECMDA_FSCSEL_PALCN			|	// [5:4] Color subcarrier frequency is 3.58205625 MHz for PAL-combination N
+					HwTVECMDA_PEDESTAL				|	// [3]   Video Output has a pedestal (0 is NTSC-J)
+//					HwTVECMDA_PIXEL_SQUARE			|	// [2]   Input data is at square pixel rates.
+					HwTVECMDA_PIXEL_601				|	// [2]   Input data is at 601 rates.
+//					HwTVECMDA_IFMT_625				|	// [1]   Output data has 625 lines
+					HwTVECMDA_IFMT_525				|	// [1]   Output data has 525 lines
+					HwTVECMDA_PHALT_PAL				|	// [0]   PAL encoded chroma signal output
+//					HwTVECMDA_PHALT_NTSC			|	// [0]   NTSC encoded chroma signal output
+					0;
+//				RETAILMSG(1,(TEXT("[TV Out] Set to PAL-M Mode\n")));
+				break;
+
+		case	PAL_N:
+				HwTVECMDA = 
+//					HwTVECMDA_PWDENC_PD				|	// [7]   Power down mode for entire digital logic of TV encoder
+//					HwTVECMDA_FDRST_1				|	// [6]   Chroma is free running as compared to H-sync
+					HwTVECMDA_FDRST_0				|	// [6]   Relationship between color burst & H-sync is maintained for video standards
+//					HwTVECMDA_FSCSEL_NTSC			|	// [5:4] Color subcarrier frequency is 3.57954545 MHz for NTSC
+//					HwTVECMDA_FSCSEL_PALX			|	// [5:4] Color subcarrier frequency is 4.43361875 MHz for PAL-B,D,G,H,I,N
+//					HwTVECMDA_FSCSEL_PALM			|	// [5:4] Color subcarrier frequency is 3.57561149 MHz for PAL-M
+					HwTVECMDA_FSCSEL_PALCN			|	// [5:4] Color subcarrier frequency is 3.58205625 MHz for PAL-combination N
+					HwTVECMDA_PEDESTAL				|	// [3]   Video Output has a pedestal (0 is NTSC-J)
+//					HwTVECMDA_PIXEL_SQUARE			|	// [2]   Input data is at square pixel rates.
+					HwTVECMDA_PIXEL_601				|	// [2]   Input data is at 601 rates.
+					HwTVECMDA_IFMT_625				|	// [1]   Output data has 625 lines
+//					HwTVECMDA_IFMT_525				|	// [1]   Output data has 525 lines
+					HwTVECMDA_PHALT_PAL				|	// [0]   PAL encoded chroma signal output
+//					HwTVECMDA_PHALT_NTSC			|	// [0]   NTSC encoded chroma signal output
+					0;
+//				RETAILMSG(1,(TEXT("[TV Out] Set to PAL-N Mode\n")));
+				break;
+
+		case	PAL_B:
+		case	PAL_G:
+		case	PAL_H:
+		case	PAL_I:
+				HwTVECMDA = 
+//					HwTVECMDA_PWDENC_PD				|	// [7]   Power down mode for entire digital logic of TV encoder
+					HwTVECMDA_FDRST_1				|	// [6]   Chroma is free running as compared to H-sync
+//					HwTVECMDA_FDRST_0				|	// [6]   Relationship between color burst & H-sync is maintained for video standards
+//					HwTVECMDA_FSCSEL_NTSC			|	// [5:4] Color subcarrier frequency is 3.57954545 MHz for NTSC
+					HwTVECMDA_FSCSEL_PALX			|	// [5:4] Color subcarrier frequency is 4.43361875 MHz for PAL-B,D,G,H,I,N
+//					HwTVECMDA_FSCSEL_PALM			|	// [5:4] Color subcarrier frequency is 3.57561149 MHz for PAL-M
+//					HwTVECMDA_FSCSEL_PALCN			|	// [5:4] Color subcarrier frequency is 3.58205625 MHz for PAL-combination N
+//					HwTVECMDA_PEDESTAL				|	// [3]   Video Output has a pedestal (0 is NTSC-J)
+//					HwTVECMDA_PIXEL_SQUARE			|	// [2]   Input data is at square pixel rates.
+					HwTVECMDA_PIXEL_601				|	// [2]   Input data is at 601 rates.
+					HwTVECMDA_IFMT_625				|	// [1]   Output data has 625 lines
+//					HwTVECMDA_IFMT_525				|	// [1]   Output data has 525 lines
+					HwTVECMDA_PHALT_PAL				|	// [0]   PAL encoded chroma signal output
+//					HwTVECMDA_PHALT_NTSC			|	// [0]   NTSC encoded chroma signal output
+					0;
+//				RETAILMSG(1,(TEXT("[TV Out] Set to PAL_B/G/H/I Mode\n")));
+				break;
+
+		case	PSEUDO_PAL:
+				HwTVECMDA = 
+//					HwTVECMDA_PWDENC_PD				|	// [7]   Power down mode for entire digital logic of TV encoder
+//					HwTVECMDA_FDRST_1				|	// [6]   Chroma is free running as compared to H-sync
+					HwTVECMDA_FDRST_0				|	// [6]   Relationship between color burst & H-sync is maintained for video standards
+//					HwTVECMDA_FSCSEL_NTSC			|	// [5:4] Color subcarrier frequency is 3.57954545 MHz for NTSC
+					HwTVECMDA_FSCSEL_PALX			|	// [5:4] Color subcarrier frequency is 4.43361875 MHz for PAL-B,D,G,H,I,N
+//					HwTVECMDA_FSCSEL_PALM			|	// [5:4] Color subcarrier frequency is 3.57561149 MHz for PAL-M
+//					HwTVECMDA_FSCSEL_PALCN			|	// [5:4] Color subcarrier frequency is 3.58205625 MHz for PAL-combination N
+					HwTVECMDA_PEDESTAL				|	// [3]   Video Output has a pedestal (0 is NTSC-J)
+//					HwTVECMDA_PIXEL_SQUARE			|	// [2]   Input data is at square pixel rates.
+					HwTVECMDA_PIXEL_601				|	// [2]   Input data is at 601 rates.
+//					HwTVECMDA_IFMT_625				|	// [1]   Output data has 625 lines
+					HwTVECMDA_IFMT_525				|	// [1]   Output data has 525 lines
+					HwTVECMDA_PHALT_PAL				|	// [0]   PAL encoded chroma signal output
+//					HwTVECMDA_PHALT_NTSC			|	// [0]   NTSC encoded chroma signal output
+					0;
+//				RETAILMSG(1,(TEXT("[TV Out] Set to Pseudo PAL Mode\n")));
+				break;
+
+		case	PSEUDO_NTSC:
+				HwTVECMDA = 
+//					HwTVECMDA_PWDENC_PD				|	// [7]   Power down mode for entire digital logic of TV encoder
+//					HwTVECMDA_FDRST_1				|	// [6]   Chroma is free running as compared to H-sync
+					HwTVECMDA_FDRST_0				|	// [6]   Relationship between color burst & H-sync is maintained for video standards
+					HwTVECMDA_FSCSEL_NTSC			|	// [5:4] Color subcarrier frequency is 3.57954545 MHz for NTSC
+//					HwTVECMDA_FSCSEL_PALX			|	// [5:4] Color subcarrier frequency is 4.43361875 MHz for PAL-B,D,G,H,I,N
+//					HwTVECMDA_FSCSEL_PALM			|	// [5:4] Color subcarrier frequency is 3.57561149 MHz for PAL-M
+//					HwTVECMDA_FSCSEL_PALCN			|	// [5:4] Color subcarrier frequency is 3.58205625 MHz for PAL-combination N
+					HwTVECMDA_PEDESTAL				|	// [3]   Video Output has a pedestal (0 is NTSC-J)
+//					HwTVECMDA_PIXEL_SQUARE			|	// [2]   Input data is at square pixel rates.
+					HwTVECMDA_PIXEL_601				|	// [2]   Input data is at 601 rates.
+					HwTVECMDA_IFMT_625				|	// [1]   Output data has 625 lines
+//					HwTVECMDA_IFMT_525				|	// [1]   Output data has 525 lines
+//					HwTVECMDA_PHALT_PAL				|	// [0]   PAL encoded chroma signal output
+					HwTVECMDA_PHALT_NTSC			|	// [0]   NTSC encoded chroma signal output
+					0;
+//				RETAILMSG(0,(TEXT("[TV Out] Set to Pseudo NTSC Mode\n")));
+				break;
+	}
+
+	HwTVECMDB = 
+//		HwTVECMDB_YBIBLK_BLACK			|	// [4]   Video data is forced to Black level for Vertical non VBI processed lines.
+		HwTVECMDB_YBIBLK_BYPASS			|	// [4]   Input data is passed through forn non VBI processed lines.
+		HwTVECMDB_CBW_LOW				|	// [3:2] Low Chroma band-width
+//		HwTVECMDB_CBW_MEDIUM			|	// [3:2] Medium Chroma band-width
+//		HwTVECMDB_CBW_HIGH				|	// [3:2] High Chroma band-width
+		HwTVECMDB_YBW_LOW				|	// [1:0] Low Luma band-width
+//		HwTVECMDB_YBW_MEDIUM			|	// [1:0] Medium Luma band-width
+//		HwTVECMDB_YBW_HIGH				|	// [1:0] High Luma band-width
+		0;
+
+	//Set DACSEL Register
+	HwTVEDACSEL = 1; //DACSEL0 - CVBS output
+
+	HwTVEICNTL  = 
+//		HwTVEICNTL_FSIP_ODDHIGH			|	// [7]   Odd field active high
+		HwTVEICNTL_VSIP_HIGH			|	// [6]   V-sync active high
+//		HwTVEICNTL_HSIP_HIGH			|	// [5]   H-sync active high
+		HwTVEICNTL_HSVSP_RISING			|	// [4]   H/V-sync latch enabled at rising edge
+//		HwTVEICNTL_VSMD_START			|	// [3]   Even/Odd field H/V sync output are aligned to video line start
+//		HwTVEICNTL_ISYNC_FSI			|	// [2:0] Alignment input format from FSI pin
+//		HwTVEICNTL_ISYNC_HVFSI			|	// [2:0] Alignment input format from HSI,VSI,FSI pin
+		HwTVEICNTL_ISYNC_HVSI			|	// [2:0] Alignment input format from HSI,VSI pin
+//		HwTVEICNTL_ISYNC_VFSI			|	// [2:0] Alignment input format from VSI,FSI pin
+//		HwTVEICNTL_ISYNC_VSI			|	// [2:0] Alignment input format from VSI pin
+//		HwTVEICNTL_ISYNC_ESAV_L			|	// [2:0] Alignment input format from EAV,SAV codes (line by line)
+//		HwTVEICNTL_ISYNC_ESAV_F			|	// [2:0] Alignment input format from EAV,SAV codes (frame by frame)
+//		HwTVEICNTL_ISYNC_FREE			|	// [2:0] Alignment is free running (Master mode)
+		0;
+
+	HwTVEHVOFFST = 
+//		HwTVEHVOFFST_INSEL_BW16_27MHZ	|	// [7:6] 16bit YUV 4:2:2 sampled at 27MHz
+//		HwTVEHVOFFST_INSEL_BW16_13P5MHZ	|	// [7:6] 16bit YUV 4:2:2 sampled at 13.5MHz
+		HwTVEHVOFFST_INSEL_BW8_13P5MHZ	|	// [7:6] 8bit YUV 4:2:2 sampled at 13.5MHz
+		0;
+
+	HwTVEHOFFST = 0;	//48;
+	HwTVEVOFFST = 1;	// 8;
+	HwTVEHSVSO  = 0;
+	HwTVEHSOB   = 0;
+	HwTVEHSOE   = 0;
+	HwTVEVSOB   = 0;
+	HwTVEVSOE   = 
+		HwTVEVSOE_VSOST(0)				|	// [7:6] Programs V-sync relative location for Odd/Even Fields.
+//		HwTVEVSOE_NOVRST_EN				|	// [5]   No vertical reset on every field
+		HwTVEVSOE_NOVRST_NORMAL			|	// [5]   Normal vertical reset operation (interlaced output timing)
+		HwTVEVSOE_VSOE(0)				|	// [4:0] Trailing Edge of Vertical Sync Control
+		0;
+
+	//Set VENCIF Register
+	BITSET(HwTVEVENCIF, HwTVEVENCIF_FMT_1);
+	//HwTVEVENCIF = 1;
+
+}
+
+
+/*****************************************************************************
+* Function Name : tca_tvo_setlcd2tv()
+******************************************************************************/
+void tca_tvo_setlcd2tv(unsigned int type)
+{
+	PLCDC	pLCDC_BASE[2]   = {(LCDC *)tcc_allocbaseaddress((unsigned int)&HwLCDC0_BASE),
+							   (LCDC *)tcc_allocbaseaddress((unsigned int)&HwLCDC1_BASE)};
+	PLCDC	pLCDC;
+
+	PCKC	pCKC = (CKC *)tcc_allocbaseaddress((unsigned int)&HwCLK_BASE);
+
+	unsigned int TV_HSIZE, TV_VSIZE = 0;
+	unsigned int TV_HPW,   TV_HBP,   TV_HFP;
+	unsigned int TV_VPW0,  TV_VBP0,  TV_VFP0;
+	unsigned int TV_VPW1,  TV_VBP1,  TV_VFP1;
+
+	pLCDC = pLCDC_BASE[gTvoutLcdcId];
+	
+
+{
+	PGPIO	pGPIO 	= (GPIO *)tcc_allocbaseaddress((unsigned int)&HwGPIO_BASE);
+	BITCLR(pGPIO->GPCDAT, Hw28);	//	LCD_DISP Off
+}
+
+	//todo: Backlight off
+	
+	pLCDC->LCTRL &= (~Hw0); 	// LCDC Disable
+
+	if(!gTvoutFlag)
+	{
+		if(gTvoutLcdcId)
+			gRegPCK_LCD = pCKC->PCLK_LCD1;
+		else
+			gRegPCK_LCD = pCKC->PCLK_LCD0;
+
+		gRegLCLKDIV = pLCDC->LCLKDIV;
+		
+		gRegLHTIME1 = pLCDC->LHTIME1;
+		gRegLHTIME2 = pLCDC->LHTIME2;
+		
+		gRegLVTIME1 = pLCDC->LVTIME1;
+		gRegLVTIME2 = pLCDC->LVTIME2;
+		gRegLVTIME3 = pLCDC->LVTIME3;
+		gRegLVTIME4 = pLCDC->LVTIME4;
+		
+		gRegLDS 	= pLCDC->LDS;
+		gRegLCTRL	= pLCDC->LCTRL;
+
+		gRegLI0P	= pLCDC->LI0P;
+		if(gTvoutLcdcId)
+		{
+			gRegLI1P	= pLCDC->LI1P;
+			gRegLI2P	= pLCDC->LI2P;
+		}
+
+		gRegLI0C	= pLCDC->LI0C;
+		if(gTvoutLcdcId)
+		{
+			gRegLI1C	= pLCDC->LI1C;
+			gRegLI2C	= pLCDC->LI2C;
+		}
+
+		gRegLI0S	= pLCDC->LI0S;
+		if(gTvoutLcdcId)
+		{
+			gRegLI1S	= pLCDC->LI1S;
+			gRegLI2S	= pLCDC->LI2S;
+		}
+
+		gTvoutFlag = 1;
+	}
+
+	while(pLCDC->LSTATUS & Hw30)	// BUSY
+	{
+#ifdef __KERNEL__
+		udelay(1000*1);
+#else
+		Sleep(1);
+#endif
+	}
+
+	if (gHDMIPWRFlag == 0)
+	{
+		PPMU  pPMU = (PMU *)tcc_allocbaseaddress((unsigned int)&HwPMU_BASE);
+		BITCLR(pPMU->PWROFF, Hw1);  /*HD[1]*/
+
+		gHDMIPWRFlag = 1;
+	}
+
+//	tcc_ckc_setperi(PERI_LCD0+gTvoutLcdcId,ENABLE,270000,PCHDMI);
+//	pLCDC->LCLKDIV = 0;
+
+	tca_tvo_setlclk27mhz(gTvoutLcdcId);
+
+	switch(type)
+	{
+		case	NTSC_M:
+		case	NTSC_M_J:
+		case	PAL_M:
+		case	NTSC_443:
+		case	PSEUDO_PAL:
+				TV_HSIZE = 720; TV_VSIZE = 486;
+				TV_HPW	 = 212; TV_HBP	 =	32; TV_HFP	 =	32;
+				TV_VPW0  =	 6; TV_VBP0  =	28; TV_VFP0  =	 5;
+				TV_VPW1  =	 6; TV_VBP1  =	29; TV_VFP1  =	 4;
+
+				pLCDC->LHTIME1 = ((TV_HPW-1)  << 16) | ((TV_HSIZE*2) - 1);
+				pLCDC->LHTIME2 = ((TV_HBP-1)  << 16) | (TV_HFP-1);
+
+				pLCDC->LVTIME1 = ((TV_VPW0-1) << 16) | (TV_VSIZE - 1);
+				pLCDC->LVTIME2 = ((TV_VBP0-1) << 16) | (TV_VFP0-1);
+				pLCDC->LVTIME3 = ((TV_VPW1-1) << 16) | (TV_VSIZE - 1);
+				pLCDC->LVTIME4 = ((TV_VBP1-1) << 16) | (TV_VFP1-1);
+				break;
+
+		case	NTSC_N:
+		case	NTSC_N_J:
+		case	PAL_N:
+		case	PAL_B:
+		case	PAL_G:
+		case	PAL_H:
+		case	PAL_I:
+		case	PSEUDO_NTSC:
+				TV_HSIZE = 720; TV_VSIZE = 576;
+		//		TV_HPW	 = 280; TV_HBP	 =	 2; TV_HFP	 =	 6;
+				TV_HPW	 = 128; TV_HBP	 = 138; TV_HFP	 =	22;
+				TV_VPW0  =	 1; TV_VBP0  =	43; TV_VFP0  =	 5;
+				TV_VPW1  =	 1; TV_VBP1  =	44; TV_VFP1  =	 4;
+
+				pLCDC->LHTIME1 = ((TV_HPW-1)  << 16) | ((TV_HSIZE*2) - 1);
+				pLCDC->LHTIME2 = ((TV_HBP-1)  << 16) | (TV_HFP-1);
+				
+				pLCDC->LVTIME1 = ((TV_VPW0-1) << 16) | (TV_VSIZE - 1);
+				pLCDC->LVTIME2 = ((TV_VBP0-1) << 16) | (TV_VFP0-1);
+				pLCDC->LVTIME3 = ((TV_VPW1-1) << 16) | (TV_VSIZE - 1);
+				pLCDC->LVTIME4 = ((TV_VBP1-1) << 16) | (TV_VFP1-1);
+
+				break;
+	}
+
+    pLCDC->LDS     = (TV_VSIZE<< 16) | TV_HSIZE;
+
+	#if (1)
+	if(gTvoutFlag_prev == 0)
+	{
+		unsigned int IMGx_HSIZE[3], IMGx_VSIZE[3];
+		unsigned int IMGx_POSX[3], IMGx_POSY[3];
+		unsigned int TMP_POSX=0, TMP_POSY=0;
+
+		memset(IMGx_HSIZE, 0, sizeof(unsigned int)*3);
+		memset(IMGx_VSIZE, 0, sizeof(unsigned int)*3);
+		memset(IMGx_POSX, 0, sizeof(unsigned int)*3);
+		memset(IMGx_POSY, 0, sizeof(unsigned int)*3);
+
+		if(pLCDC->LI0C & Hw28)	//IMG0 EN
+		{
+			IMGx_HSIZE[0] = (unsigned int)(pLCDC->LI0S & 0x0fff);
+			IMGx_VSIZE[0] = (unsigned int)((pLCDC->LI0S & 0x0fff0000) >> 16);
+
+			TMP_POSX = (unsigned int)(pLCDC->LI0P & 0x0fff);
+			TMP_POSY = (unsigned int)((pLCDC->LI0P & 0x0fff0000) >> 16);
+
+			if(IMGx_HSIZE[0] < TV_HSIZE)
+			{
+				IMGx_POSX[0] = (TV_HSIZE - IMGx_HSIZE[0]) >> 1;
+			}
+			if(IMGx_VSIZE[0] < TV_VSIZE)
+			{
+				IMGx_POSY[0] = (TV_VSIZE - IMGx_VSIZE[0]) >> 2;
+			}
+			
+			pLCDC->LI0P = ((IMGx_POSY[0]+TMP_POSY) << 16) | (IMGx_POSX[0]+TMP_POSX);
+			pLCDC->LI0C	|= 0x80000000;
+
+			pLCDC->LI0S = TV_VSIZE << 16 | TV_HSIZE;
+
+		}
+		if(gTvoutLcdcId)
+		{
+			if(pLCDC->LI1C & Hw28)	//IMG1 EN
+			{
+				IMGx_HSIZE[1] = (unsigned int)(pLCDC->LI1S & 0x0fff);
+				IMGx_VSIZE[1] = (unsigned int)((pLCDC->LI1S & 0x0fff0000) >> 16);
+				
+				TMP_POSX = (unsigned int)(pLCDC->LI1P & 0x0fff);
+				TMP_POSY = (unsigned int)((pLCDC->LI1P & 0x0fff0000) >> 16);
+				
+				if(IMGx_HSIZE[1] < TV_HSIZE)
+				{
+					IMGx_POSX[1] = (TV_HSIZE - IMGx_HSIZE[1]) >> 1;
+				}
+				if(IMGx_VSIZE[1] < TV_VSIZE)
+				{
+					IMGx_POSY[1] = (TV_VSIZE - IMGx_VSIZE[1]) >> 2;
+				}
+				
+				pLCDC->LI1P = ((IMGx_POSY[1]+TMP_POSY) << 16) | (IMGx_POSX[1]+TMP_POSX);
+				pLCDC->LI1C	|= 0x80000000;
+
+				pLCDC->LI1S = TV_VSIZE << 16 | TV_HSIZE;
+			}
+			if(pLCDC->LI2C & Hw28)	//IMG2 EN
+			{
+				IMGx_HSIZE[2] = (unsigned int)(pLCDC->LI2S & 0x0fff);
+				IMGx_VSIZE[2] = (unsigned int)((pLCDC->LI2S & 0x0fff0000) >> 16);
+				
+				TMP_POSX = (unsigned int)(pLCDC->LI2P & 0x0fff);
+				TMP_POSY = (unsigned int)((pLCDC->LI2P & 0x0fff0000) >> 16);
+				
+				if(IMGx_HSIZE[2] < TV_HSIZE)
+				{
+					IMGx_POSX[2] = (TV_HSIZE - IMGx_HSIZE[2]) >> 1;
+				}
+				if(IMGx_VSIZE[2] < TV_VSIZE)
+				{
+					IMGx_POSY[2] = (TV_VSIZE - IMGx_VSIZE[2]) >> 2;
+				}
+				
+				pLCDC->LI2P = ((IMGx_POSY[2]+TMP_POSY) << 16) | (IMGx_POSX[2]+TMP_POSX);
+				pLCDC->LI2C	|= 0x80000000;
+
+				pLCDC->LI2S = TV_VSIZE << 16 | TV_HSIZE;
+			}
+		}
+		
+		gTvoutFlag_prev = 1;
+	}
+	#endif
+
+	pLCDC->LCTRL = (pLCDC->LCTRL & 0xFFF0001E)
+				 | (0xf & 0x6) << 16	// PXDW=6
+				 | (0xf & 0xf) << 12	// ID=1, IV=1, IH=1, IP=1
+				 | (0x1 & 0x1) << 10	// R2Y=1
+				 | (0x1 & 0x0) << 9		// DP=0
+				 | (0x1 & 0x0) << 8		// NI=0
+				 | (0x7 & 0x4) << 5		// TV=1, TFT=0, STN=0
+				 | (0x1 & 0x1) << 0		// LEN=1
+				 | 0;
+			
+}
+
+
+/*****************************************************************************
+* Function Name : tca_tvo_settv2lcd()
+******************************************************************************/
+void tca_tvo_settv2lcd(void)
+{
+	PLCDC	pLCDC_BASE[2]   = {(LCDC *)tcc_allocbaseaddress((unsigned int)&HwLCDC0_BASE),
+							   (LCDC *)tcc_allocbaseaddress((unsigned int)&HwLCDC1_BASE)};
+	PLCDC	pLCDC;
+
+	PCKC	pCKC = (CKC *)tcc_allocbaseaddress((unsigned int)&HwCLK_BASE);
+
+	pLCDC = pLCDC_BASE[gTvoutLcdcId];
+	
+
+{
+	PGPIO	pGPIO 	= (GPIO *)tcc_allocbaseaddress((unsigned int)&HwGPIO_BASE);
+	BITSET(pGPIO->GPCDAT, Hw28);	//	LCD_DISP On
+}
+	pLCDC->LCTRL   &= (~Hw0);		// LCDC Disable
+
+	while(pLCDC->LSTATUS & Hw30)	// BUSY
+	{
+#ifdef __KERNEL__
+		udelay(1000*1);
+#else
+		Sleep(1);
+#endif
+	}
+
+	if(gTvoutLcdcId)
+		pCKC->PCLK_LCD1 = gRegPCK_LCD;
+	else
+		pCKC->PCLK_LCD0 = gRegPCK_LCD;
+
+	pLCDC->LCLKDIV  = gRegLCLKDIV;
+
+	pLCDC->LHTIME1  = gRegLHTIME1;
+    pLCDC->LHTIME2  = gRegLHTIME2;
+	
+    pLCDC->LVTIME1  = gRegLVTIME1;
+    pLCDC->LVTIME2  = gRegLVTIME2;
+    pLCDC->LVTIME3  = gRegLVTIME3;
+    pLCDC->LVTIME4  = gRegLVTIME4;
+
+    pLCDC->LDS      = gRegLDS;
+	pLCDC->LI0P	    = gRegLI0P;
+	if(gTvoutLcdcId)
+	{
+		pLCDC->LI1P	    = gRegLI1P;
+		pLCDC->LI2P	    = gRegLI2P;
+	}
+
+	pLCDC->LI0C	    = gRegLI0C;
+	if(gTvoutLcdcId)
+	{
+		pLCDC->LI1C	    = gRegLI1C;
+		pLCDC->LI2C	    = gRegLI2C;
+	}
+
+	pLCDC->LI0S	    = gRegLI0S;
+	if(gTvoutLcdcId)
+	{
+		pLCDC->LI1S	    = gRegLI1S;
+		pLCDC->LI2S	    = gRegLI2S;
+	}
+
+
+	pLCDC->LCTRL    = gRegLCTRL | Hw0;	// Restore LCD Control and Enable LCD
+
+#if (0)
+{
+	PPMU  pPMU = (PMU *)tcc_allocbaseaddress((unsigned int)&HwPMU_BASE, sizeof(PMU));
+	BITSET(pPMU->PWROFF, Hw1);  /*HD[1]*/
+}
+#endif
+
+	// todo: Backlight On
+
+
+	gTvoutFlag = 0;
+	gTvoutFlag_prev = 0;
+}
+
+
+/*****************************************************************************
+* Function Name : tca_tvo_enable()
+******************************************************************************/
+void tca_tvo_enable(unsigned int onoff)
+{
+	PPMU lPMU = (PMU *)tcc_allocbaseaddress((unsigned int)&HwPMU_BASE);
+
+	if (onoff == 1)
+	{
+		lPMU->PWROFF &= ~Hw0;	/* Video DAC */
+		
+		HwTVEVENCON  = 1;
+		HwTVEDACPD   = 0; 						// Normal Operation
+		HwTVECMDA   &=~(HwTVECMDA_PWDENC_PD);	// Normal Operation
+	}
+	else
+	{
+		HwTVEVENCON  = 0;
+		HwTVEDACPD   = 1; 						// Power Down
+		HwTVECMDA   |= (HwTVECMDA_PWDENC_PD);	// Power Down
+
+		lPMU->PWROFF &= ~Hw0;	/* Video DAC */
+		lPMU->PWROFF |=  Hw0;	/* Video DAC */
+	}
+}
+
Index: linux-2.6.29/drivers/video/tca_tvout.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/video/tca_tvout.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,84 @@
+
+/****************************************************************************
+ *   FileName    : tca_tvo.h
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+#ifndef __TCA_TVO_H__
+#define __TCA_TVO_H__
+
+/*****************************************************************************
+*
+* Defines
+*
+******************************************************************************/
+
+#define NTSC_M      0x0000
+#define NTSC_M_J    0x0001
+#define NTSC_N      0x0010
+#define NTSC_N_J    0x0011
+#define NTSC_443    0x0020
+#define PAL_M       0x0100
+#define PAL_N       0x0110
+#define PAL_B       0x0120
+#define PAL_G       0x0130
+#define PAL_H       0x0140
+#define PAL_I       0x0150
+#define PSEUDO_NTSC 0x1000
+#define PSEUDO_PAL  0x1010
+
+/*****************************************************************************
+*
+* Enum
+*
+******************************************************************************/
+
+
+/*****************************************************************************
+*
+* Type Defines
+*
+******************************************************************************/
+
+
+/*****************************************************************************
+*
+* Structures
+*
+******************************************************************************/
+
+
+/*****************************************************************************
+*
+* External Variables
+*
+******************************************************************************/
+
+
+/*****************************************************************************
+*
+* External Functions
+*
+******************************************************************************/
+#ifdef __cplusplus
+extern 
+"C" { 
+#endif
+
+void tca_tvo_connectlcdc(unsigned int id);
+void tca_tvo_setmode(unsigned int type);
+void tca_tvo_setlcd2tv(unsigned int type);
+void tca_tvo_settv2lcd(void);
+void tca_tvo_enable(unsigned int onoff);
+
+#ifdef __cplusplus
+ } 
+#endif
+
+#endif	//__TCA_TVO_H__
+
Index: linux-2.6.29/drivers/video/tccfb.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/video/tccfb.c	2010-04-07 13:00:58.000000000 -0400
@@ -0,0 +1,3013 @@
+/*
+ * linux/drivers/video/tccfb.c
+ *
+ * Based on:    Based on s3c2410fb.c, sa1100fb.c and others
+ * Author:  <linux@telechips.com>
+ * Created: June 10, 2008
+ * Description: TCC LCD Controller Frame Buffer Driver
+ *
+ * Copyright (C) 2008-2009 Telechips 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see the file COPYING, or write
+ * to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/wait.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/div64.h>
+#include <asm/mach/map.h>
+#ifdef CONFIG_PM
+#include <linux/pm.h>
+#include "tca_backlight.h"
+#endif
+
+#include <bsp.h>
+#include <mach/tca_ckc.h>
+#include <mach/tcc_pca953x.h>
+#include <mach/memory.h>
+
+#include "tccfb.h"
+#include <linux/tccfb_ioctl.h>
+//#include "tcc_lcdc_info.h"
+//#include "tca_lcdc.h"
+
+//#include "tcboot_lcd.h"
+
+#define USED_IN_KERNEL
+#include "../../../../bootloader/tcboot/include/lcd.h"
+
+
+#define TV_OUT_INCLUDE
+
+#define TCC_FB_DOUBLE_
+
+#define MAIN_LCDC_ID	1	// 0: LCDC0, 1: LCDC1
+
+#if 1
+extern void tca_lcdc_getimgchfmt(int id, unsigned int imgch, unsigned int * out_fmt);
+extern void tca_lcdc_setimgchenable(int id, unsigned int ch, unsigned int flag);
+extern void tca_lcdc_setlayeralphablendingenable(int id, unsigned int imgch, unsigned int flag);
+extern void tca_lcdc_setlayeralphavalue(int id, unsigned int imgch, unsigned char alpha);
+extern void tca_lcdc_setalphaselection(int id, unsigned int imgch, unsigned int asel);
+extern void tca_lcdc_setlayerchromakeyenable(int id, unsigned int imgch, unsigned int flag);
+extern void tca_lcdc_setlayerchromakeyvalue(int id, unsigned int imgch, unsigned int ry, unsigned int gu, unsigned int bv);
+extern void tca_lcdc_setlayerchromakeymask(int id, unsigned int imgch, unsigned int mry, unsigned int mgu, unsigned int mbv);
+extern void tca_lcdc_setimgchfmt(int id, unsigned int imgch, unsigned int fmt);
+extern void tca_lcdc_setimgchbase(int id, unsigned int imgch, unsigned int base0, unsigned int base1, unsigned int base2);
+extern void tca_lcdc_getimgchbase(int id, unsigned int imgch, unsigned int * out_base0, unsigned int * out_base1, unsigned int * out_base2);
+extern void tca_lcdc_setimgchOffsetInfo(int id, unsigned int imgch, unsigned int offset0, unsigned int offset1);
+extern void tca_lcdc_setaddroffset(int id, unsigned int imgch, unsigned int imgwidth, unsigned int fmt);
+extern void tca_lcdc_setimgchwindow(int id, unsigned int imgch, unsigned int sx, unsigned int sy, unsigned int w, unsigned int h);
+extern void tca_lcdc_setr2yconvopt(int id, unsigned int conv_opt);
+extern void tca_lcdc_getr2yconvopt(int id, unsigned int *conv_opt_out);
+extern void tca_lcdc_setimgy2rconvopt(int id, unsigned int imgch, unsigned int conv_opt);
+extern void tca_lcdc_getimgy2rconvopt(int id, unsigned int imgch, unsigned int *conv_opt_out);
+extern void tca_lcdc_setcolorenhancement(int id, unsigned int hue, unsigned int bright, unsigned int cont);
+extern void tca_lcdc_getcolorenhancement(int id, unsigned int *hue, unsigned int *bright, unsigned int *cont);
+extern void tca_lcdc_setimgenhancement(int id, unsigned int imgch, unsigned int hue, unsigned int bright, unsigned int cont);
+extern void tca_lcdc_getimgenhancement(int id, unsigned int imgch, unsigned int *hue, unsigned int *bright, unsigned int *cont);
+
+#ifdef TV_OUT_INCLUDE
+extern void tca_tvo_connectlcdc(unsigned int id);
+extern void tca_tvo_setmode(unsigned int type);
+extern void tca_tvo_setlcd2tv(unsigned int type);
+extern void tca_tvo_settv2lcd(void);
+extern void tca_tvo_enable(unsigned int onoff);
+#endif
+#endif
+
+/* Debugging stuff */
+//#ifdef CONFIG_FB_DEBUG
+#if 0
+static int debug	   = 1;
+#else
+static int debug	   = 0;
+#endif
+#define dprintk(msg...)	if (debug) { printk( "tccfb: " msg); }
+
+#define LCD_SCREEN_WIDTH	800
+#define LCD_SCREEN_HEIGHT	480
+
+#if defined(USE_LVDS_1024_768)
+#define LVDS_SCREEN_WIDTH	1024
+#define LVDS_SCREEN_HEIGHT	768
+#else
+#define LVDS_SCREEN_WIDTH	1280
+#define LVDS_SCREEN_HEIGHT	800
+#endif
+
+#define HDMI_SCREEN_WIDTH	1920
+#define HDMI_SCREEN_HEIGHT	1080
+
+
+#define TCC_LCD_FB_IOCTL		0x46FF
+
+
+#define CONFIG_FB_TCC_DEVS_MAX	3	// do not change!
+#define CONFIG_FB_TCC_DEVS		3
+
+#if (CONFIG_FB_TCC_DEVS > CONFIG_FB_TCC_DEVS_MAX)
+	#undef CONFIG_FB_TCC_DEVS
+	#define CONFIG_FB_TCC_DEVS	CONFIG_FB_TCC_DEVS_MAX
+#endif
+
+
+#define SCREEN_DEPTH_MAX	32	// 32 or 16 
+//								 : 32 - 32bpp(alpah+rgb888)
+//								 : 16 - 16bpp(rgb565)
+
+const unsigned int default_scn_depth[CONFIG_FB_TCC_DEVS_MAX] = 
+{
+#if 0
+/* fb0, Layer0: bottom */  (SCREEN_DEPTH_MAX), // 32 or 16
+/* fb1, Layer1: middle */  (SCREEN_DEPTH_MAX), //  "
+/* fb2, Layer2: top    */  (SCREEN_DEPTH_MAX)  //  "
+#else
+/* fb0, Layer0: bottom */  (16), // 32 or 16
+/* fb1, Layer1: middle */  (16), //  "
+/* fb2, Layer2: top    */  (16)  //  "
+#endif
+};
+
+#if   defined(DEMO_LOADSHOW_LVDS)
+	const unsigned int fb_width[3]  = {LVDS_SCREEN_WIDTH,  LVDS_SCREEN_WIDTH,  LVDS_SCREEN_WIDTH};
+	const unsigned int fb_height[3] = {LVDS_SCREEN_HEIGHT, LVDS_SCREEN_HEIGHT, LVDS_SCREEN_HEIGHT};
+	const unsigned int fb_lcdcid[3] = {1, 1, 1};
+#elif defined(DEMO_LOADSHOW_LCD_LVDS)
+	const unsigned int fb_width[3]  = {LVDS_SCREEN_WIDTH,  LVDS_SCREEN_WIDTH,  LCD_SCREEN_WIDTH};
+	const unsigned int fb_height[3] = {LVDS_SCREEN_HEIGHT, LVDS_SCREEN_HEIGHT, LCD_SCREEN_HEIGHT};
+	const unsigned int fb_lcdcid[3] = {1, 1, 0};
+#elif defined(DEMO_LOADSHOW_LCD_LVDSHDMI)
+	const unsigned int fb_width[3]  = {LVDS_SCREEN_WIDTH,  LCD_SCREEN_WIDTH,  LCD_SCREEN_WIDTH};
+	const unsigned int fb_height[3] = {LVDS_SCREEN_HEIGHT, LCD_SCREEN_HEIGHT, LCD_SCREEN_HEIGHT};
+	const unsigned int fb_lcdcid[3] = {0, 1, 1};
+#elif defined(DEMO_LOADSHOW_LCD_HDMI)
+	const unsigned int fb_width[3]  = {LCD_SCREEN_WIDTH,  LCD_SCREEN_WIDTH,  LCD_SCREEN_WIDTH};
+	const unsigned int fb_height[3] = {LCD_SCREEN_HEIGHT, LCD_SCREEN_HEIGHT, LCD_SCREEN_HEIGHT};
+	const unsigned int fb_lcdcid[3] = {1, 1, 0};
+#else
+	const unsigned int fb_width[3]  = {LCD_SCREEN_WIDTH,  LCD_SCREEN_WIDTH,  LCD_SCREEN_WIDTH};
+	const unsigned int fb_height[3] = {LCD_SCREEN_HEIGHT, LCD_SCREEN_HEIGHT, LCD_SCREEN_HEIGHT};
+	const unsigned int fb_lcdcid[3] = {1, 1, 1};
+#endif
+
+
+// for frame buffer clear
+static u_char *fb_mem_vaddr[CONFIG_FB_TCC_DEVS]= {0,};
+static u_int   fb_mem_size [CONFIG_FB_TCC_DEVS]= {0,};
+
+// for reserved frame buffer memory.
+static u_long fb_reseved_mem_paddr[CONFIG_FB_TCC_DEVS_MAX] = {TCC_FB_OFFSET,
+															  TCC_FB_OFFSET + TCC_FB0_SIZE,
+															  TCC_FB_OFFSET + TCC_FB0_SIZE + TCC_FB1_SIZE };
+static u_int  fb_reseved_mem_size [CONFIG_FB_TCC_DEVS_MAX] = {TCC_FB0_SIZE,
+															  TCC_FB1_SIZE,
+															  TCC_FB2_SIZE};
+
+/* Register */
+PDDICONFIG	pDDICfg;
+PLCDC		pLCDC0;
+PLCDC		pLCDC1;
+PGPIO		pGPIO;
+
+PM2MSCALER	pM2MSCALER[2];
+
+typedef struct {
+	volatile unsigned int	LIxC;				//   LCD Image x Control Register 
+	volatile unsigned int	LIxP;				//   LCD Image x Position Register 
+	volatile unsigned int	LIxS;				//   LCD Image x Size Register 
+	volatile unsigned int	LIxBA0;				//   LCD Image x Base Address 0 Register. 
+	volatile unsigned int	LIxCA;				//   LCD Image x Current Address Register. 
+	volatile unsigned int	LIxBA1;				//   LCD Image x Base Address 1 Register 
+	volatile unsigned int	LIxBA2;				//   LCD Image x Base Address 2 Register 
+	volatile unsigned int	LIxO;				//   LCD Image x Offset Register 
+	volatile unsigned int	LIxSR;				//   LCD Image x Scale ratio 
+	volatile unsigned int	LIxA;				//   LCD Image x Alpha Configuration Register 
+	volatile unsigned int	LIxKR;				//   LCD Image x Keying Register for RED or LUMA(Y) 
+	volatile unsigned int	LIxKG;				//   LCD Image x Keying Register for BLUE or CHROMA(Cb) 
+	volatile unsigned int	LIxKB;				//   LCD Image x Keying Register for GREEN or CHROMA(Cr) 
+	volatile unsigned int	LIxEN;				//   LCD Image x Enhancement Register 
+} LCDC_IMG, *PLCDC_IMG;
+
+PLCDC_IMG	pLCDC1_IMG[3], pLCDC0_IMG[1];
+
+#if defined(ROADSHOW_DEMO_TYPE1)
+static unsigned int gLCDOnOffFlag=1;
+#endif
+
+void tcc_lcd_on(void)
+{
+	PGPIO	pGPIO 	= (GPIO *)&HwGPIO_BASE;
+	PLCDC	pLCDC;
+	lcd_cfg_t *cfg = &lcd_cfg[0];
+
+#if defined(DEMO_LOADSHOW_LCD_LVDSHDMI)
+
+	pLCDC = pLCDC0;
+
+	#if defined(USE_LVDS_1024_768)
+	tca_ckc_setperi(PERI_LCD0,ENABLE,1300000,PCDIRECTPLL3);	
+	cfg = &lcd_cfg[1];
+	#else
+	tca_ckc_setperi(PERI_LCD0,ENABLE,1422200,PCDIRECTPLL2);
+	cfg = &lcd_cfg[2];
+	#endif
+
+#elif defined(DEMO_LOADSHOW_LCD_HDMI)
+
+	return;
+
+#elif defined(DEMO_LOADSHOW_LCD_LVDS)
+
+	pLCDC = pLCDC1;
+
+	#if defined(USE_LVDS_1024_768)
+	tca_ckc_setperi(PERI_LCD1,ENABLE,1300000,PCDIRECTPLL3);	
+	cfg = &lcd_cfg[1];
+	#else
+	tca_ckc_setperi(PERI_LCD1,ENABLE,1422200,PCDIRECTPLL2);
+	cfg = &lcd_cfg[2];
+	#endif
+
+#elif defined(DEMO_LOADSHOW_LVDS)
+
+	pLCDC = pLCDC1;
+
+	#if defined(USE_LVDS_1024_768)
+	tca_ckc_setperi(PERI_LCD1,ENABLE,1300000,PCDIRECTPLL3);	
+	cfg = &lcd_cfg[1];
+	#else
+	tca_ckc_setperi(PERI_LCD1,ENABLE,1422200,PCDIRECTPLL2);
+	cfg = &lcd_cfg[2];
+	#endif
+
+#else
+
+	pLCDC = pLCDC1;
+	tca_ckc_setperi(PERI_LCD1,ENABLE,1560000,PCDIRECTPLL3);
+
+#endif
+
+
+#if defined(ROADSHOW_DEMO_TYPE1)
+
+//		if (gLCDOnOffFlag)
+//			return;
+
+		gLCDOnOffFlag = 1;
+		
+		BITCLR(pGPIO->GPCFN0, 0xFFFFFFFF);
+		BITCLR(pGPIO->GPCFN1, 0xFFFFFFFF);
+		BITCLR(pGPIO->GPCFN2, 0xFFFFFFFF);
+		BITCLR(pGPIO->GPCFN3, (Hw16-Hw0));
+
+		//LCDC1 RGB Interface
+		BITSET(pGPIO->GPCFN0, 0x55555555);
+		BITSET(pGPIO->GPCFN1, 0x55555555);
+		BITSET(pGPIO->GPCFN2, 0x55555555);
+		BITCSET(pGPIO->GPCFN3, (Hw16-Hw0), 0x5555);
+
+		BITSET(pLCDC1->LI2C, Hw28);
+		
+#endif
+
+//	Set LCD controller
+	pLCDC->LCTRL = (
+	//			Hw31|			// EVP[31] - External VSYNC Polarity	(0: Direct Input, 1: Inverted Input)
+	//			Hw30|			// EVS[30] - External VSYNC Enable		(0: Disabled, 1: Enabled)
+				(0<<28)|		// R2YMD[29:28] - RGB to YCbCr Conversion Option (type0)
+	//			(1<<28)|		// 												 (type1)
+	//			(2<<28)|		//												 (type2)
+	//			(3<<28)|		//												 (type3)
+				(0<<26)|		// LUT[27:26] - LUT Option Bits	(Not used)
+	//			(1<<26)|		// 								(Used for Image 0)
+	//			(2<<26)|		//								(Used for Image 0)
+	//			(3<<26)|		//								(Used for Image 0)
+	//			Hw25|			// GEN[25] - Gamma Corection Enable Bit (0: Disabled, 1: Enabled)
+	//			Hw24|			// 656[24] - CCIR 656 Mode (0: Disabled, 1: Enabled)
+	//			Hw23|			// CKG[23] - Clock Gating Enable for Timing Generator
+	//			Hw22|Hw21|Hw20| // BPP[22:20] - Bit Per Pixel for STN-LCD
+				(cfg->pwdx<<16)|		//PXDW[19:16] - C : 24Bit(888) Hw19(1)|Hw18(1)|Hw17(0)|Hw16(0)|
+										//PXDW[19:16] - 5 : 18Bit(666) Hw19(0)|Hw18(1)|Hw17(0)|Hw16(1)|
+	//			Hw15|			// Inverted Data Enable (ACBIAS pin)
+				Hw14|			// Inverted Vertical Sync
+				Hw13|			// Inverted Horizontal Sync
+	//			Hw12|			// Inverted Pixel Clock
+	//			Hw11|			// Clipping Enable
+	//			Hw10|			// RGB to YCbCr Converter Enable for OUTPUT
+	//			Hw9 |			// Double Pixel Data
+				Hw8 |			// Non-interlace
+				(0x2<<5)|		// TFT-LCD mode: STN(Hw5), TFT(Hw6), TV(Hw7)
+	//			Hw4 |			// Master Select for IMG0
+				(0x5<<1)|		// OVP[3:1] - 5 : Image2 > Image1 > Image0
+				Hw0 |			// LCD Controller Enable
+				0); 			// End Of Value
+
+// Set LCD clock
+	pLCDC->LCLKDIV &= 0xFF00FF00;
+	pLCDC->LCLKDIV |= ( (1 << 16) | cfg->devide); //((PCK_LCD+1)/2)/((LCD_DEVIDE)*2)
+
+//  Horizontal timing
+    pLCDC->LHTIME1 = ((cfg->hpw-1) << 16) | (cfg->res_width - 1);
+    pLCDC->LHTIME2 = ((cfg->hbp-1) << 16) | (cfg->hfp-1);
+
+//  Vertical timing
+    pLCDC->LVTIME1 = ((cfg->vpw-1) << 16) | (cfg->res_height - 1);
+    pLCDC->LVTIME2 = ((cfg->vbp-1) << 16) | (cfg->vfp-1);
+    pLCDC->LVTIME3 = ((cfg->vpw-1) << 16) | (cfg->res_height - 1);
+    pLCDC->LVTIME4 = ((cfg->vbp-1) << 16) | (cfg->vfp-1);
+
+//	Display Size
+	pLCDC->LDS = (cfg->res_height << 16) | cfg->res_width;
+
+	// non-interlace mode (progressive mode)
+	{
+		unsigned regl;
+		regl = readl(&pLCDC->LI0C);
+		writel(regl & ~(0x80000000), &pLCDC->LI0C);
+		regl = readl(&pLCDC->LI1C);
+		writel(regl & ~(0x80000000), &pLCDC->LI1C);
+		regl = readl(&pLCDC->LI2C);
+		writel(regl & ~(0x80000000), &pLCDC->LI2C);
+	}
+
+#if defined(DEMO_LOADSHOW_LVDS) || defined(DEMO_LOADSHOW_LCD_LVDS) || defined(DEMO_LOADSHOW_LCD_LVDSHDMI)
+
+	tcc_pca953x_setup(PCA9539_U3_SLAVE_ADDR, LVDSIVT, OUTPUT, HIGH, SET_DIRECTION|SET_VALUE);
+	tcc_pca953x_setup(PCA9539_U3_SLAVE_ADDR, LVDSLPCTRL, OUTPUT, HIGH, SET_DIRECTION|SET_VALUE);
+//	tcc_pca953x_setup(PCA9538_U4_SLAVE_ADDR, SATAHDMI, OUTPUT, HIGH, SET_DIRECTION|SET_VALUE);
+
+#else
+//	LCD_DISP On
+	BITSET(pGPIO->GPCDAT, Hw28);
+
+//	LCD_BL_EN(Backlight) On
+	BITSET(pGPIO->GPADAT, Hw7);
+#endif
+}
+
+void tcc_lcd_off(void)
+{
+#if defined(DEMO_LOADSHOW_LVDS) || defined(DEMO_LOADSHOW_LCD_LVDS) || defined(DEMO_LOADSHOW_LCD_LVDSHDMI)
+
+	tcc_pca953x_setup(PCA9539_U3_SLAVE_ADDR, LVDSIVT, OUTPUT, LOW, SET_DIRECTION|SET_VALUE);
+	tcc_pca953x_setup(PCA9539_U3_SLAVE_ADDR, LVDSLPCTRL, OUTPUT, LOW, SET_DIRECTION|SET_VALUE);
+//	tcc_pca953x_setup(PCA9538_U4_SLAVE_ADDR, SATAHDMI, OUTPUT, LOW, SET_DIRECTION|SET_VALUE);
+
+#elif defined(DEMO_LOADSHOW_LCD_HDMI)
+
+	return;
+
+#else
+
+	#if defined(ROADSHOW_DEMO_TYPE1)
+
+		PLCDC	pLCDC;
+		lcd_cfg_t *cfg = &lcd_cfg[0];
+
+
+//		if (gLCDOnOffFlag==0)
+//			return;
+
+		gLCDOnOffFlag = 0;
+
+		pLCDC = pLCDC0;
+		tca_ckc_setperi(PERI_LCD0,ENABLE,1560000,PCDIRECTPLL3);
+
+		BITCLR(pLCDC->LCTRL, Hw0);
+
+		while(pLCDC->LSTATUS & Hw30)	// BUSY
+		{
+			udelay(1000*1);
+		}
+
+		BITCLR(pGPIO->GPCFN0, 0xFFFFFFFF);
+		BITCLR(pGPIO->GPCFN1, 0xFFFFFFFF);
+		BITCLR(pGPIO->GPCFN2, 0xFFFFFFFF);
+		BITCLR(pGPIO->GPCFN3, (Hw16-Hw0));
+
+		//LCDC0 RGB Interface
+		BITSET(pGPIO->GPCFN0, 0x22222222);
+		BITSET(pGPIO->GPCFN1, 0x22222222);
+		BITSET(pGPIO->GPCFN2, 0x22222222);
+		BITCSET(pGPIO->GPCFN3, (Hw16-Hw0), 0x2222);
+
+		*pLCDC0_IMG[0] = *pLCDC1_IMG[2];
+
+		BITCLR(pLCDC1->LI2C, Hw28);
+
+//	Set LCD controller
+	pLCDC->LCTRL = (
+	//			Hw31|			// EVP[31] - External VSYNC Polarity	(0: Direct Input, 1: Inverted Input)
+	//			Hw30|			// EVS[30] - External VSYNC Enable		(0: Disabled, 1: Enabled)
+				(0<<28)|		// R2YMD[29:28] - RGB to YCbCr Conversion Option (type0)
+	//			(1<<28)|		// 												 (type1)
+	//			(2<<28)|		//												 (type2)
+	//			(3<<28)|		//												 (type3)
+				(0<<26)|		// LUT[27:26] - LUT Option Bits	(Not used)
+	//			(1<<26)|		// 								(Used for Image 0)
+	//			(2<<26)|		//								(Used for Image 0)
+	//			(3<<26)|		//								(Used for Image 0)
+	//			Hw25|			// GEN[25] - Gamma Corection Enable Bit (0: Disabled, 1: Enabled)
+	//			Hw24|			// 656[24] - CCIR 656 Mode (0: Disabled, 1: Enabled)
+	//			Hw23|			// CKG[23] - Clock Gating Enable for Timing Generator
+	//			Hw22|Hw21|Hw20| // BPP[22:20] - Bit Per Pixel for STN-LCD
+				(cfg->pwdx<<16)|		//PXDW[19:16] - C : 24Bit(888) Hw19(1)|Hw18(1)|Hw17(0)|Hw16(0)|
+										//PXDW[19:16] - 5 : 18Bit(666) Hw19(0)|Hw18(1)|Hw17(0)|Hw16(1)|
+	//			Hw15|			// Inverted Data Enable (ACBIAS pin)
+				Hw14|			// Inverted Vertical Sync
+				Hw13|			// Inverted Horizontal Sync
+	//			Hw12|			// Inverted Pixel Clock
+	//			Hw11|			// Clipping Enable
+	//			Hw10|			// RGB to YCbCr Converter Enable for OUTPUT
+	//			Hw9 |			// Double Pixel Data
+				Hw8 |			// Non-interlace
+				(0x2<<5)|		// TFT-LCD mode: STN(Hw5), TFT(Hw6), TV(Hw7)
+	//			Hw4 |			// Master Select for IMG0
+				(0x5<<1)|		// OVP[3:1] - 5 : Image2 > Image1 > Image0
+				Hw0 |			// LCD Controller Enable
+				0); 			// End Of Value
+
+// Set LCD clock
+	pLCDC->LCLKDIV &= 0xFF00FF00;
+	pLCDC->LCLKDIV |= ( (1 << 16) | cfg->devide); //((PCK_LCD+1)/2)/((LCD_DEVIDE)*2)
+
+//  Horizontal timing
+    pLCDC->LHTIME1 = ((cfg->hpw-1) << 16) | (cfg->res_width - 1);
+    pLCDC->LHTIME2 = ((cfg->hbp-1) << 16) | (cfg->hfp-1);
+
+//  Vertical timing
+    pLCDC->LVTIME1 = ((cfg->vpw-1) << 16) | (cfg->res_height - 1);
+    pLCDC->LVTIME2 = ((cfg->vbp-1) << 16) | (cfg->vfp-1);
+    pLCDC->LVTIME3 = ((cfg->vpw-1) << 16) | (cfg->res_height - 1);
+    pLCDC->LVTIME4 = ((cfg->vbp-1) << 16) | (cfg->vfp-1);
+
+//	Display Size
+	pLCDC->LDS = (cfg->res_height << 16) | cfg->res_width;
+
+		BITSET(pLCDC->LI0C, Hw28);
+		BITSET(pLCDC->LCTRL, Hw0);
+
+		return;
+
+	#endif
+
+	PGPIO	pGPIO 	= (GPIO *)&HwGPIO_BASE;
+
+//	LCD_DISP Off
+	BITCLR(pGPIO->GPCDAT, Hw28);
+
+//	LCD_BL_EN(Backlight) Off
+	BITCLR(pGPIO->GPADAT, Hw7);
+#endif
+}
+
+
+typedef struct _tccfb_m2m_info {
+	int use;
+	int m2m;
+	int lcdc;
+	int img;
+	int direct;
+} tccfb_m2m_info_t;
+
+static tccfb_m2m_info_t	gFbM2MInfo = {0, };
+
+//@ 
+// lcdc_idx	: 0 - LCDC0,	other - LCDC1
+// m2m_idx	: 0 - M2M0,		other - M2M1
+// imgch	: 0 - IMG0,		1 - IMG1,	 2 - IMG2
+static int tcc_m2m_set(int enable)
+{
+	PM2MSCALER	pM2MScaler;
+	PLCDC		pLCDC;
+	PLCDC_IMG	pIMG;
+
+	int lcdc_idx	= 1;
+	int img_ch		= 2;
+	int m2m_idx		= 1;
+
+	volatile unsigned int img_is_en = 0;
+	volatile unsigned int bitIxEOF;
+
+	unsigned int count=0;
+//	unsigned int count_max=1;//1000;
+	unsigned int width, height;
+
+	//@ m2m reg-base
+	if (m2m_idx==0)
+		pM2MScaler = pM2MSCALER[0];
+	else
+		pM2MScaler = pM2MSCALER[1];
+
+	//@ lcdc reg-base
+	//@ img  reg-base
+	if (lcdc_idx==0) {
+		pLCDC = pLCDC0;
+
+		switch(img_ch) {
+		case 0:
+			pIMG = pLCDC0_IMG[0];
+			bitIxEOF = Hw27;
+			break;
+		default:
+			return -1;
+		}
+	} else {
+		pLCDC = pLCDC1;
+
+		switch(img_ch) {
+		case 0:
+			pIMG = pLCDC1_IMG[0];
+			bitIxEOF = Hw27;
+			break;
+		case 1:
+			pIMG = pLCDC1_IMG[1];
+			bitIxEOF = Hw26;
+			break;
+		case 2:
+			pIMG = pLCDC1_IMG[2];
+			bitIxEOF = Hw25;
+			break;
+		default:
+			return -1;
+		}
+	}
+
+	img_is_en = (pIMG->LIxC & Hw28);
+
+	//! m2m disable
+	if (enable == 0)
+	{
+	//	BITCLR(pIMG->LIxC, Hw27);
+
+		if (gFbM2MInfo.use)
+		{
+			if (img_is_en)
+			{
+				count=0;
+
+				BITCLR(pIMG->LIxC, Hw28);
+
+				#if (0)
+				while((pLCDC->LCTRL & Hw0) && !(pLCDC->LSTATUS & bitIxEOF))	//IxEOF
+				{
+					printk("[0x%08x] 0x%08x\n", bitIxEOF, pLCDC->LSTATUS);
+					//{volatile int ttt;for(ttt=0;ttt<0x100;ttt++);}
+					udelay(1000);
+					if(++count == count_max)
+						break;
+				}
+				#else
+				{
+					volatile unsigned int data;
+
+					count = 0;
+					data = (pLCDC->LSTATUS & Hw31);
+					while(1 && (pLCDC->LCTRL & Hw0))
+					{
+						if (data != (pLCDC->LSTATUS & Hw31))
+							break;
+						count++;
+					}
+				}
+				#endif
+			}
+
+			BITCLR(pIMG->LIxC, Hw27);
+			
+			#if (1)
+			if (m2m_idx)
+			{
+				BITCSET(pDDICfg->ON_THE_FLY, Hw5|Hw4, 3<<4);	// mscl1 - not used
+				BITSET(pDDICfg->SWRESET, Hw6);
+				BITSET(pDDICfg->PWDN,Hw6);
+				BITCLR(pDDICfg->SWRESET, Hw6);
+			}
+			else
+			{
+				BITCSET(pDDICfg->ON_THE_FLY, Hw3|Hw2, 2<<2);	// mscl0 - not used
+				BITSET(pDDICfg->SWRESET, Hw5);
+				BITSET(pDDICfg->PWDN,Hw5);	
+				BITCLR(pDDICfg->SWRESET, Hw5);
+			}
+			#else
+			pM2MScaler->MSCCTR = 0;
+			#endif
+
+			#if (1)
+			if (img_is_en)
+				BITSET(pIMG->LIxC, Hw28);
+			#endif
+			
+			memset(&gFbM2MInfo, 0, sizeof(gFbM2MInfo));
+
+			printk(" -- count-->[%d]\n", count);
+		}
+
+		return 0;
+	}
+
+	if (img_is_en)
+	{
+		count=0;
+
+		BITCLR(pIMG->LIxC, Hw28);
+
+		#if (0)
+		while((pLCDC->LCTRL & Hw0) && !(pLCDC->LSTATUS & bitIxEOF))	//IxEOF
+		{
+			printk("[0x%08x] 0x%08x\n", bitIxEOF, pLCDC->LSTATUS);
+			//{volatile int ttt;for(ttt=0;ttt<0x100;ttt++);}
+			udelay(1000);
+			if(++count == count_max)
+				break;
+		}
+		#else
+		{
+			volatile unsigned int data;
+
+			count = 0;
+			data = (pLCDC->LSTATUS & Hw31);
+			while(1 && (pLCDC->LCTRL & Hw0))
+			{
+				if (data != (pLCDC->LSTATUS & Hw31))
+					break;
+				count++;
+			}
+		}
+		#endif
+
+	}
+
+	if (gFbM2MInfo.use)
+	{
+		// refresh
+
+	}
+	else
+	{
+		gFbM2MInfo.use  = 1;
+		gFbM2MInfo.lcdc = lcdc_idx;
+		gFbM2MInfo.m2m  = m2m_idx;
+		gFbM2MInfo.img  = img_ch;
+		gFbM2MInfo.direct = 1;
+	}
+
+	// !! m2m reset !!
+	if (m2m_idx)
+	{
+		//	BITCSET(pDDICfg->ON_THE_FLY, Hw5|Hw4, 3<<4);	// mscl1 - not used
+			BITSET(pDDICfg->SWRESET, Hw6);
+			BITCLR(pDDICfg->PWDN,Hw6);	
+			BITCLR(pDDICfg->SWRESET, Hw6);
+	}
+	else
+	{
+		//	BITCSET(pDDICfg->ON_THE_FLY, Hw3|Hw2, 2<<2);	// mscl0 - not used
+			BITSET(pDDICfg->SWRESET, Hw5);
+			BITCLR(pDDICfg->PWDN,Hw5);	
+			BITCLR(pDDICfg->SWRESET, Hw5);
+	}
+
+	width  = pIMG->LIxS & 0x0fff;
+	height = (pIMG->LIxS>>16) & 0x0fff;
+	
+	pM2MScaler->SRCBASEY = pIMG->LIxBA0;
+	pM2MScaler->SRCBASEU = pM2MScaler->SRCBASEY;
+	pM2MScaler->SRCBASEV = pM2MScaler->SRCBASEY;
+	pM2MScaler->SRCSIZE  = pIMG->LIxS;
+	pM2MScaler->SRCOFF   = (((pIMG->LIxS & 0x0fff)*2)<<16) + ((pIMG->LIxS & 0x0fff)*2);
+	pM2MScaler->SRCCFG   = 4;	// type 4 - rgb565
+
+	pM2MScaler->DSTBASEY = pIMG->LIxBA0;
+	pM2MScaler->DSTBASEU = pM2MScaler->DSTBASEY;
+	pM2MScaler->DSTBASEV = pM2MScaler->DSTBASEY;
+	pM2MScaler->DSTSIZE  = pIMG->LIxS;
+	pM2MScaler->DSTOFF   = (((pIMG->LIxS & 0x0fff)*2)<<16) + ((pIMG->LIxS & 0x0fff)*2);
+	pM2MScaler->DSTCFG   = 0
+						 | ((Hw3-Hw0) & (( 4)<< 0))		// type 4 - rgb565
+						 | ((Hw4)     & (( 1)<< 4))		// 0: memory, 1: LCDC
+						 | ((Hw6)     & (( 1)<< 6))		// RDY
+						 | 0;
+
+	pM2MScaler->MSCINF	 = ((256)<<16) + (256);		// scale ratio
+	pM2MScaler->MSCCTR	 = 0
+						 | ((Hw5    ) & (( 1)<< 5))	// 0: One-Time Mode, 1: Continuous Mode
+						 | ((Hw0    ) & (( 0)<< 0))	// 0: Operation Disable, 1: Operation Enable
+						 | 0;
+
+	if (m2m_idx)
+		BITCSET(pDDICfg->ON_THE_FLY, Hw5|Hw4, 1<<4);	// mscl1 - lcdc1
+	else
+		BITCSET(pDDICfg->ON_THE_FLY, Hw3|Hw2, 1<<2);	// mscl0 - lcdc1
+		
+	pM2MScaler->MSCCTR	|= Hw0;	// Operation Enable
+
+	BITSET(pIMG->LIxC, Hw27);
+
+	if (img_is_en)
+		BITSET(pIMG->LIxC, Hw28);
+
+	printk(" -- count-->[%d]\n", count);
+
+	return 0;
+}
+
+static int tcc_m2m_refresh(void)
+{
+	PM2MSCALER	pM2MScaler;
+	PLCDC		pLCDC;
+	PLCDC_IMG	pIMG;
+
+	if (gFbM2MInfo.use)
+	{
+		//@ m2m reg-base
+		if (gFbM2MInfo.m2m==0)
+			pM2MScaler = pM2MSCALER[0];
+		else
+			pM2MScaler = pM2MSCALER[1];
+
+		//@ lcdc reg-base
+		//@ img  reg-base
+		if (gFbM2MInfo.lcdc==0) {
+			pLCDC = pLCDC0;
+
+			switch(gFbM2MInfo.img) {
+			case 0:
+				pIMG = pLCDC0_IMG[0];
+				break;
+			default:
+				return -1;
+			}
+		} else {
+			pLCDC = pLCDC1;
+
+			switch(gFbM2MInfo.img) {
+			case 0:
+				pIMG = pLCDC1_IMG[0];
+				break;
+			case 1:
+				pIMG = pLCDC1_IMG[1];
+				break;
+			case 2:
+				pIMG = pLCDC1_IMG[2];
+				break;
+			default:
+				return -1;
+			}
+		}
+
+		if (pM2MScaler->SRCBASEY != pIMG->LIxBA0 || pM2MScaler->SRCSIZE  != pIMG->LIxS)
+		{
+			printk("m2m - refresh\n");
+
+			tcc_m2m_set(1);
+		}
+	}
+
+	return 0;
+}
+
+
+static void tcc_regbase_init(void)
+{
+	pDDICfg = (volatile PDDICONFIG)tcc_p2v(HwDDI_CONFIG_BASE);
+	pLCDC0  = (volatile PLCDC)tcc_p2v(HwLCDC0_BASE);
+	pLCDC1  = (volatile PLCDC)tcc_p2v(HwLCDC1_BASE);
+	pGPIO   = (volatile PGPIO)tcc_p2v(HwGPIO_BASE);
+
+	pM2MSCALER[0] = (volatile PM2MSCALER)tcc_p2v(HwM2MSCALER0_BASE);
+	pM2MSCALER[1] = (volatile PM2MSCALER)tcc_p2v(HwM2MSCALER1_BASE);
+
+	pLCDC1_IMG[0] = (PLCDC_IMG)&pLCDC1->LI0C;
+	pLCDC1_IMG[1] = (PLCDC_IMG)&pLCDC1->LI1C;
+	pLCDC1_IMG[2] = (PLCDC_IMG)&pLCDC1->LI2C;
+
+	pLCDC0_IMG[0] = (PLCDC_IMG)&pLCDC0->LI0C;
+}
+
+
+static void tcc_lcdc_interrupt(int lcdcid, char onoff)
+{
+	if(lcdcid)
+	{
+		if(onoff == 1)
+		{
+			BITCSET(pLCDC1->LIM, 0xFFFFFFFF, Hw3);
+
+			BITSET(HwPIC->POL0, HwINT0_LCD1);
+			BITSET(HwPIC->SEL0, HwINT0_LCD1);
+			BITSET(HwPIC->MODE0, HwINT0_LCD1);
+
+			BITSET(HwPIC->IEN0, HwINT0_LCD1);
+		}
+		else
+		{
+			BITCLR(HwPIC->IEN0, HwINT0_LCD1);
+		}
+	}
+	else
+	{
+		if(onoff == 1)
+		{
+			BITCSET(pLCDC0->LIM, 0xFFFFFFFF, Hw3);
+
+			BITSET(HwPIC->POL0, HwINT0_LCD0);
+			BITSET(HwPIC->SEL0, HwINT0_LCD0);
+			BITSET(HwPIC->MODE0, HwINT0_LCD0);
+
+			BITSET(HwPIC->IEN0, HwINT0_LCD0);
+		}
+		else
+		{
+			BITCLR(HwPIC->IEN0, HwINT0_LCD0);
+		}
+	}
+}
+
+
+#if 0
+static void tcc_start_lcd_int_dd(void)
+{
+    /* [config] LCD interrupt Masking Register (LIM) */
+	//todo
+
+    /* [config] LCD Status Register (LSTATUS) */
+	//todo
+}
+#endif
+
+static void tcc_stop_lcd_int_dd(void)
+{
+    /* [config] LCD interrupt Masking Register (LIM) */
+	//TODO
+
+    /* [config] LCD Control Registers (LCTRL) */
+	//todo
+}
+
+#if 0
+static void tcc_set_reg_for_int_dd(void)
+{
+    /* [config] LCD Control Registers (LCTRL) */
+	//todo
+}
+#endif
+
+//static struct tccfb_mach_info *mach_info;
+
+/*
+ *	tccfb_check_var():
+ *	Get the video params out of 'var'. If a value doesn't fit, round it up,
+ *	if it's too big, return -EINVAL.
+ *
+ */
+static int tccfb_check_var(struct fb_var_screeninfo *var,
+			       struct fb_info *info)
+{
+	dprintk("check_var(var=%p, info=%p)\n", var, info);
+
+	/* validate bpp */
+	if (var->bits_per_pixel > 32)
+		var->bits_per_pixel = 32;
+	else if (var->bits_per_pixel < 16)
+		var->bits_per_pixel = 16;
+	
+	/* set r/g/b positions */
+	if (var->bits_per_pixel == 16) {
+		var->red.offset 	= 11;
+		var->green.offset	= 5;
+		var->blue.offset	= 0;
+		var->red.length 	= 5;
+		var->green.length	= 6;
+		var->blue.length	= 5;
+		var->transp.length	= 0;
+	} else if (var->bits_per_pixel == 32) {
+		var->red.offset 	= 16;
+		var->green.offset	= 8;
+		var->blue.offset	= 0;
+		var->transp.offset	= 24;
+		var->red.length 	= 8;
+		var->green.length	= 8;
+		var->blue.length	= 8;
+		var->transp.length	= 8;
+	} else {
+		var->red.length 	= var->bits_per_pixel;
+		var->red.offset 	= 0;
+		var->green.length	= var->bits_per_pixel;
+		var->green.offset	= 0;
+		var->blue.length	= var->bits_per_pixel;
+		var->blue.offset	= 0;
+		var->transp.length	= 0;
+	}
+
+	return 0;
+}
+
+/* tccfb_pan_display
+ *
+ * pandisplay (set) the controller from the given framebuffer
+ * information
+*/
+struct lcd_struct {
+	spinlock_t lock;
+	wait_queue_head_t waitq;
+	char state;
+};
+
+static struct lcd_struct lcdc_struct[2];
+
+static int tccfb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	struct tccfb_info *fbi = (struct tccfb_info *)info->par;
+
+	unsigned int parm_lcdcid;
+	unsigned int parm_imgch;
+
+	PLCDC	pLCDC;
+
+//	return 0;
+
+	unsigned int status;
+
+	parm_lcdcid = MAIN_LCDC_ID;
+	parm_imgch = fbi->imgch;
+
+#if defined(DEMO_LOADSHOW_LCD_HDMI) || defined(DEMO_LOADSHOW_LCD_LVDS)
+	if(fbi->imgch == 2)
+	{
+		parm_lcdcid = 0;
+		parm_imgch  = 0;
+	}
+#elif defined(DEMO_LOADSHOW_LCD_LVDSHDMI)
+	if(fbi->imgch == 0)
+	{
+		parm_lcdcid = 0;
+		parm_imgch  = 0;
+	}
+#endif
+
+	if(parm_lcdcid)
+		pLCDC = pLCDC1;
+	else
+		pLCDC = pLCDC0;
+
+	status = pLCDC->LSTATUS;
+
+	pLCDC->LSTATUS = status | Hw3;
+	lcdc_struct[parm_lcdcid].state = 0;
+
+	(fbi->fb)->var.yoffset = var->yoffset;
+	(fbi->fb)->var.xoffset = var->xoffset;
+
+	switch (fbi->imgch)
+	{
+		case 2:	// IMG2
+	#if defined(DEMO_LOADSHOW_LCD_HDMI) || defined(DEMO_LOADSHOW_LCD_LVDS)
+			pLCDC0->LI0BA0 = fbi->map_dma + (fbi->fb)->var.xres*(fbi->fb)->var.yoffset*(fbi->fb)->var.bits_per_pixel/8;
+	#else
+			pLCDC1->LI2BA0 = fbi->map_dma + (fbi->fb)->var.xres*(fbi->fb)->var.yoffset*(fbi->fb)->var.bits_per_pixel/8;
+	#endif
+			break;
+		case 1:	// IMG1
+			pLCDC1->LI1BA0 = fbi->map_dma + (fbi->fb)->var.xres*(fbi->fb)->var.yoffset*(fbi->fb)->var.bits_per_pixel/8;
+			break;
+		case 0:	// IMG0
+	#if defined(DEMO_LOADSHOW_LCD_LVDSHDMI)
+			pLCDC0->LI0BA0 = fbi->map_dma + (fbi->fb)->var.xres*(fbi->fb)->var.yoffset*(fbi->fb)->var.bits_per_pixel/8;
+	#else
+			pLCDC1->LI0BA0 = fbi->map_dma + (fbi->fb)->var.xres*(fbi->fb)->var.yoffset*(fbi->fb)->var.bits_per_pixel/8;
+	#endif
+			break;
+	}
+
+	tcc_m2m_refresh();
+	
+	tcc_lcdc_interrupt(parm_lcdcid, 1);
+	wait_event_interruptible(lcdc_struct[parm_lcdcid].waitq, lcdc_struct[parm_lcdcid].state == 1 );
+
+	dprintk("tccfb_pan_display:%5d, yoffset:%5d \n",fbi->fb->var.xres,var->yoffset );
+
+    return 0;
+}
+
+
+/* tccfb_activate_var
+ *
+ * activate (set) the controller from the given framebuffer
+ * information
+*/
+
+static void tccfb_activate_var(struct tccfb_info *fbi,
+				   struct fb_var_screeninfo *var)
+{
+//	dprintk("activate_var\n");
+
+	unsigned int imgch = 0;
+	unsigned int bpp_value;
+//	unsigned int tmp_value;
+
+	unsigned int sx, sy;
+	int lcdc_channel = 1;
+	
+	dprintk("%s:fb%d var->bpp	= %d\n", __FUNCTION__, fbi->fb->node, var->bits_per_pixel);
+
+	if((0 <= fbi->fb->node) && (fbi->fb->node < CONFIG_FB_TCC_DEVS))
+		imgch = fbi->fb->node;
+	else
+		return;
+
+	if(fbi->fb->var.bits_per_pixel == 32)
+		bpp_value = IMGFMT_RGB888;	//0x000C; //RGB888
+	else if(fbi->fb->var.bits_per_pixel == 16)
+		bpp_value = IMGFMT_RGB565;	//0x000A; //RGB565
+	else
+	{
+		dprintk("%s:fb%d Not Supported BPP!\n", __FUNCTION__, fbi->fb->node);
+		return;
+	}
+
+	/* write new registers */
+	#if 0
+	switch(imgch)
+	{
+		case 0:
+			tmp_value = pLCDC1->LI0C;
+			pLCDC1->LI0C = (tmp_value & 0xFFFFFFE0) | (bpp_value & 0x0000001F);
+			pLCDC1->LI0O = (fbi->fb->var.xres*(fbi->fb->var.bits_per_pixel/8));
+			break;
+		case 1:
+			tmp_value = pLCDC1->LI1C;
+			pLCDC1->LI1C = (tmp_value & 0xFFFFFFE0) | (bpp_value & 0x0000001F);
+			pLCDC1->LI1O = (fbi->fb->var.xres*(fbi->fb->var.bits_per_pixel/8));
+			break;
+		case 2:
+			tmp_value = pLCDC1->LI2C;
+			pLCDC1->LI2C = (tmp_value & 0xFFFFFFE0) | (bpp_value & 0x0000001F);
+			pLCDC1->LI2O = (fbi->fb->var.xres*(fbi->fb->var.bits_per_pixel/8));
+			break;
+	}
+	#else
+
+	switch(imgch)
+	{
+		case 0:
+		#if defined(DEMO_LOADSHOW_LCD_LVDSHDMI)
+			sx = pLCDC0->LI0P & 0x0000ffff;
+			sy = (pLCDC0->LI0P>>16) & 0x0000ffff;
+			lcdc_channel = 0; imgch = 0;
+		#else
+			sx = pLCDC1->LI0P & 0x0000ffff;
+			sy = (pLCDC1->LI0P>>16) & 0x0000ffff;
+			lcdc_channel = 1;
+		#endif
+			break;
+		case 1:
+			sx = pLCDC1->LI1P & 0x0000ffff;
+			sy = (pLCDC1->LI1P>>16) & 0x0000ffff;
+			lcdc_channel = 1;
+			break;
+		case 2:
+		#if defined(DEMO_LOADSHOW_LCD_HDMI) || defined(DEMO_LOADSHOW_LCD_LVDS)
+			sx = pLCDC0->LI0P & 0x0000ffff;
+			sy = (pLCDC0->LI0P>>16) & 0x0000ffff;
+			lcdc_channel = 0; imgch = 0;
+		#else
+			sx = pLCDC1->LI2P & 0x0000ffff;
+			sy = (pLCDC1->LI2P>>16) & 0x0000ffff;
+			lcdc_channel = 1;
+		#endif
+			break;
+	}
+	
+	tca_lcdc_setimgchfmt(lcdc_channel, imgch, bpp_value);
+	tca_lcdc_setimgchwindow(lcdc_channel, imgch, sx, sy, fbi->fb->var.xres, fbi->fb->var.yres);
+	tca_lcdc_setaddroffset(lcdc_channel, imgch, fbi->fb->var.xres, bpp_value);
+
+	tcc_m2m_refresh();
+	#endif
+
+	return;
+}
+
+
+/*
+ *      tccfb_set_par - Optional function. Alters the hardware state.
+ *      @info: frame buffer structure that represents a single frame buffer
+ *
+ */
+static int tccfb_set_par(struct fb_info *info)
+{
+	struct tccfb_info *fbi = info->par;
+	struct fb_var_screeninfo *var = &info->var;
+
+	dprintk("set_par\n");
+	
+	if (var->bits_per_pixel == 16)
+		fbi->fb->fix.visual = FB_VISUAL_TRUECOLOR;
+	else if (var->bits_per_pixel == 32)
+		fbi->fb->fix.visual = FB_VISUAL_TRUECOLOR;
+	else
+		fbi->fb->fix.visual = FB_VISUAL_PSEUDOCOLOR;
+
+	fbi->fb->fix.line_length = (var->width*var->bits_per_pixel)/8;
+
+	/* activate this new configuration */
+
+	tccfb_activate_var(fbi, var);
+	return 0;
+}
+
+#ifdef TV_OUT_INCLUDE
+
+#include <linux/tcc_ll.h>
+#include <linux/tcc_pwm.h>
+
+static stpwrinfo gTvoPwrInfo = {PWR_STATUS_OFF};
+
+//@tvo
+static unsigned int gTvoType;
+static unsigned int gTvoStatus; // 1: enabled tv-out, 0: disabled tv-out
+
+static int tvo_pwr_ctl(void *h_private, int cmd, void *p_out)
+{
+	int ret = 0;
+	
+    switch (cmd) {
+    case PWR_CMD_OFF:
+		tca_tvo_enable(0);
+		gTvoPwrInfo.status = PWR_STATUS_OFF;
+		if (p_out)
+		{
+			memcpy(p_out, &gTvoPwrInfo, sizeof(stpwrinfo));
+		}
+		break;
+    case PWR_CMD_ON:
+		tca_tvo_enable(1);
+		gTvoPwrInfo.status = PWR_STATUS_ON;
+		if (p_out)
+		{
+			memcpy(p_out, &gTvoPwrInfo, sizeof(stpwrinfo));
+		}
+		break;
+    case PWR_CMD_GETSTATUS:
+		if (p_out)
+		{
+			memcpy(p_out, &gTvoPwrInfo, sizeof(stpwrinfo));
+		}
+		else
+		{
+			ret = -EINVAL;
+		}
+		break;
+    default:
+        ret = -EINVAL;
+        break;
+    }
+    return ret;
+}
+unsigned int tvo_init(void)
+{
+	gTvoStatus = 0;
+	insert_pwm_node(DEVICE_TVOUT, tvo_pwr_ctl, NULL);
+	return 0;
+}
+unsigned int tvo_open(void)
+{
+	return 0;
+}
+unsigned int tvo_close(void)
+{
+	return 0;
+}
+unsigned int tvo_cleanup(void)
+{
+	remove_pwm_node(DEVICE_TVOUT);
+	return 0;
+}
+void tvo_powerup(void)
+{
+	if(gTvoStatus)
+	{
+		tca_tvo_setmode(gTvoType); // need to input type
+		tca_tvo_enable(1);
+
+		gTvoPwrInfo.status = PWR_STATUS_ON;
+	}
+}
+void tvo_powerdown(void)
+{
+	if(gTvoStatus)
+	{
+		tca_tvo_enable(0);
+
+		gTvoPwrInfo.status = PWR_STATUS_OFF;
+	}
+}
+unsigned int tvo_ioctl(unsigned int cmd,unsigned long arg)
+{
+	unsigned int value;
+	
+	switch(cmd)
+	{
+		case TCC_LCD_FB_IOCTL_TVOUT_CONNECT_LCDC:
+			copy_from_user((void *)&value, (const void *)arg, sizeof(unsigned int));
+			tca_tvo_connectlcdc(value);
+			break;
+			
+		case TCC_LCD_FB_IOCTL_TVOUT_TYPE:
+			copy_from_user((void *)&gTvoType, (const void *)arg, sizeof(unsigned int));
+			break;
+		
+		case TCC_LCD_FB_IOCTL_TVOUT_OPEN:
+			if (gTvoStatus==0)
+			{
+				PTIMER vTimerAddr = (PTIMER)((unsigned int)&HwTMR_BASE);
+				PGPIO vGpioAddr = (PGPIO)((unsigned int)&HwGPIO_BASE);
+
+				tca_bkl_powerdown((unsigned int)vTimerAddr,(unsigned int)vGpioAddr);
+
+				tca_tvo_setlcd2tv(gTvoType);
+				tca_tvo_setmode(gTvoType); // need to input type
+				tca_tvo_enable(1);
+			
+				gTvoStatus = 1;
+				gTvoPwrInfo.status = PWR_STATUS_ON;
+			}
+			break;
+		
+		case TCC_LCD_FB_IOCTL_TVOUT_CLOSE:
+			if(gTvoStatus==1)
+			{
+				PTIMER vTimerAddr = (PTIMER)((unsigned int)&HwTMR_BASE);
+				PGPIO vGpioAddr = (PGPIO)((unsigned int)&HwGPIO_BASE);
+
+				tca_tvo_enable(0);
+				tca_tvo_settv2lcd();
+
+				tca_bkl_powerup((unsigned int)vTimerAddr,(unsigned int)vGpioAddr);
+
+				gTvoStatus = 0;
+				gTvoPwrInfo.status = PWR_STATUS_OFF;
+			}
+		
+			break;
+		
+		default:
+			break;			
+
+	}
+	
+	return 0;
+}
+#endif
+
+static int tccfb_ioctl(struct fb_info *info, unsigned int cmd,unsigned long arg)
+{
+	unsigned int imgch=0;
+	
+	unsigned int prev_fmt[CONFIG_FB_TCC_DEVS];
+	unsigned int curr_fmt[CONFIG_FB_TCC_DEVS];
+	int ch_num;
+	int parm_lcdcid=MAIN_LCDC_ID;
+	int parm_imgch;
+
+	if((0 <= info->node) && (info->node < CONFIG_FB_TCC_DEVS))
+	{
+		imgch = info->node;
+	}
+	else
+	{
+		dprintk("ioctl: Error - fix.id[%d]\n", info->node);
+		return 0;
+	}
+
+	for (ch_num=0; ch_num<CONFIG_FB_TCC_DEVS; ch_num++)
+	{
+		parm_lcdcid = MAIN_LCDC_ID;
+		parm_imgch = ch_num;
+		
+	#if defined(DEMO_LOADSHOW_LCD_HDMI) || defined(DEMO_LOADSHOW_LCD_LVDS)
+		if(ch_num == 2)
+		{
+			parm_lcdcid = 0;
+			parm_imgch  = 0;
+		}
+	#elif defined(DEMO_LOADSHOW_LCD_LVDSHDMI)
+		if(ch_num == 0)
+		{
+			parm_lcdcid = 0;
+			parm_imgch  = 0;
+		}
+	#endif
+		tca_lcdc_getimgchfmt(parm_lcdcid, parm_imgch, &prev_fmt[ch_num]);
+	}
+
+	switch(cmd)
+	{
+		case TCC_LCD_FB_IOCTL:
+			dprintk("ioctl: ioctl\n");
+			break;
+
+			
+#if 1
+		case TCC_LCD_FB_IOCTL_SET_OVP:
+			{
+				unsigned char ovp;
+				copy_from_user((void *)&ovp, (const void *)arg, sizeof(unsigned char));
+
+				BITCSET(pLCDC1->LCTRL, Hw4-Hw1, ovp<<1);
+
+				printk("ioctl: set_ovp (%d)\n", ovp);
+			}
+			break;
+
+		case TCC_LCD_FB_IOCTL_SET_M2M:
+			{
+				unsigned int value;
+				copy_from_user((void *)&value, (const void *)arg, sizeof(unsigned int));
+
+				tcc_m2m_set(value);
+
+				printk("ioctl: set_m2m (%d)\n", value);
+			}
+			break;
+			
+		case TCC_LCD_FB_IOCTL_LCD_ONOFF:
+			{//ok
+				unsigned int onoff;
+
+				copy_from_user((void *)&onoff, (const void *)arg, sizeof(unsigned int));
+
+				switch(imgch)
+				{
+					case 0: //img0
+					case 1: //img1
+					case 2: //img2
+						if(onoff)
+							tcc_lcd_on();
+						else
+							tcc_lcd_off();
+						break;
+					default:
+						break;
+				}
+
+				printk("ioctl: lcd_onoff(%d)\n", onoff);
+			}
+			break;
+
+		case TCC_LCD_FB_IOCTL_DISP_ONOFF:
+			{//ok
+				unsigned int onoff;
+
+				copy_from_user((void *)&onoff, (const void *)arg, sizeof(unsigned int));
+
+				parm_lcdcid = MAIN_LCDC_ID;
+				parm_imgch = imgch;
+
+				switch(imgch)
+				{
+					case 0: //img0
+					case 1: //img1
+					case 2: //img2
+
+					#if defined(DEMO_LOADSHOW_LCD_HDMI) || defined(DEMO_LOADSHOW_LCD_LVDS)
+						if(imgch == 2)
+						{
+							parm_lcdcid = 0;
+							parm_imgch  = 0;
+						}
+					#elif defined(DEMO_LOADSHOW_LCD_LVDSHDMI)
+						if(imgch == 0)
+						{
+							parm_lcdcid = 0;
+							parm_imgch  = 0;
+						}
+					#endif
+						tca_lcdc_setimgchenable(parm_lcdcid, parm_imgch, onoff);
+						break;
+					default:
+						break;
+				}
+
+				dprintk("ioctl: lcd_img%d_disp_onoff(%d)\n", imgch, onoff);
+			}
+			break;
+			
+		case TCC_LCD_FB_IOCTL_ALPHA_ONOFF:
+			{//ok
+				unsigned int onoff;
+
+				copy_from_user((void *)&onoff, (const void *)arg, sizeof(unsigned int));
+
+				parm_lcdcid = MAIN_LCDC_ID;
+				parm_imgch = imgch;
+
+				switch(imgch)
+				{
+					case 0: //img0
+					case 1: //img1
+					case 2: //img2
+
+					#if defined(DEMO_LOADSHOW_LCD_HDMI) || defined(DEMO_LOADSHOW_LCD_LVDS)
+						if(imgch == 2)
+						{
+							parm_lcdcid = 0;
+							parm_imgch  = 0;
+						}
+					#elif defined(DEMO_LOADSHOW_LCD_LVDSHDMI)
+						if(imgch == 0)
+						{
+							parm_lcdcid = 0;
+							parm_imgch  = 0;
+						}
+					#endif
+						tca_lcdc_setlayeralphablendingenable(parm_lcdcid, parm_imgch, onoff);
+						break;
+					default:
+						break;
+				}
+
+				dprintk("ioctl: lcd_layer%d_alpha_onoff(%d)\n", imgch, onoff);
+			}
+			break;		
+			
+		case TCC_LCD_FB_IOCTL_ALPHA_SET:
+			{
+				unsigned char alpha;
+
+				copy_from_user((void *)&alpha, (const void *)arg, sizeof(unsigned char));
+
+				parm_lcdcid = MAIN_LCDC_ID;
+				parm_imgch = imgch;
+
+				switch(imgch)
+				{
+					case 0: //img0
+					case 1: //img1
+					case 2: //img2
+
+					#if defined(DEMO_LOADSHOW_LCD_HDMI) || defined(DEMO_LOADSHOW_LCD_LVDS)
+						if(imgch == 2)
+						{
+							parm_lcdcid = 0;
+							parm_imgch  = 0;
+						}
+					#elif defined(DEMO_LOADSHOW_LCD_LVDSHDMI)
+						if(imgch == 0)
+						{
+							parm_lcdcid = 0;
+							parm_imgch  = 0;
+						}
+					#endif
+					
+						tca_lcdc_setlayeralphavalue(parm_lcdcid, parm_imgch, alpha);
+						break;
+					default:
+						break;
+				}
+
+				dprintk("ioctl: lcd_layer%d_alpha_%d(0x%x)\n", imgch, alpha, alpha);
+			}
+			break;
+
+		case TCC_LCD_FB_IOCTL_ALPHA_SELECTION:
+			{
+				unsigned int asel;
+
+				copy_from_user((void *)&asel, (const void *)arg, sizeof(unsigned int));
+
+				parm_lcdcid = MAIN_LCDC_ID;
+				parm_imgch = imgch;
+
+				switch(imgch)
+				{
+					case 0: //img0
+					case 1: //img1
+					case 2: //img2
+
+					#if defined(DEMO_LOADSHOW_LCD_HDMI) || defined(DEMO_LOADSHOW_LCD_LVDS)
+						if(imgch == 2)
+						{
+							parm_lcdcid = 0;
+							parm_imgch  = 0;
+						}
+					#elif defined(DEMO_LOADSHOW_LCD_LVDSHDMI)
+						if(imgch == 0)
+						{
+							parm_lcdcid = 0;
+							parm_imgch  = 0;
+						}
+					#endif
+					
+						tca_lcdc_setalphaselection(parm_lcdcid, parm_imgch, asel);
+						break;
+					default:
+						break;
+				}
+
+				dprintk("ioctl: lcd_layer%d_alpha_sel_%d(0x%x)\n", imgch, asel, asel);
+			}
+			break;
+		
+		
+		case TCC_LCD_FB_IOCTL_CHROMAKEY_ONOFF:
+			{
+				unsigned int onoff;
+
+				copy_from_user((void *)&onoff, (const void *)arg, sizeof(unsigned int));
+
+				parm_lcdcid = MAIN_LCDC_ID;
+				parm_imgch = imgch;
+
+				switch(imgch)
+				{
+					case 0: //img0
+					case 1: //img1
+					case 2: //img2
+
+					#if defined(DEMO_LOADSHOW_LCD_HDMI) || defined(DEMO_LOADSHOW_LCD_LVDS)
+						if(imgch == 2)
+						{
+							parm_lcdcid = 0;
+							parm_imgch  = 0;
+
+							#if defined(DEMO_LOADSHOW_LCD_HDMI)
+							break;
+							#endif
+						}
+					#elif defined(DEMO_LOADSHOW_LCD_LVDSHDMI)
+						if(imgch == 0)
+						{
+							parm_lcdcid = 0;
+							parm_imgch  = 0;
+						}
+					#endif
+
+						tca_lcdc_setlayerchromakeyenable(parm_lcdcid, parm_imgch, onoff);
+						break;
+					default:
+						break;
+				}
+
+				dprintk("ioctl: lcd_img%d_chromakey_onoff(%d)\n", imgch, onoff);
+			}
+			break;		
+			
+		case TCC_LCD_FB_IOCTL_CHROMAKEY_SET_VALUE:
+			{
+				unsigned char value[3];
+
+				copy_from_user((void *)value, (const void *)arg, sizeof(unsigned char)*3);
+
+				parm_lcdcid = MAIN_LCDC_ID;
+				parm_imgch = imgch;
+
+				switch(imgch)
+				{
+					case 0: //img0
+					case 1: //img1
+					case 2: //img2
+
+					#if defined(DEMO_LOADSHOW_LCD_HDMI) || defined(DEMO_LOADSHOW_LCD_LVDS)
+						if(imgch == 2)
+						{
+							parm_lcdcid = 0;
+							parm_imgch  = 0;
+						}
+					#elif defined(DEMO_LOADSHOW_LCD_LVDSHDMI)
+						if(imgch == 0)
+						{
+							parm_lcdcid = 0;
+							parm_imgch  = 0;
+						}
+					#endif
+
+						tca_lcdc_setlayerchromakeyvalue(parm_lcdcid, parm_imgch, value[0], value[1], value[2]);
+						break;
+					default:
+						break;
+				}
+				
+				dprintk("ioctl: lcd_img%d_chromakey_RY%d(0x%x)GU%d(0x%x)BV%d(0x%x)\n", imgch, value[0], value[0], value[1], value[1], value[2], value[2]);
+			}
+			break;		
+
+		case TCC_LCD_FB_IOCTL_CHROMAKEY_SET_MASK:
+			{
+				unsigned char mask[3];
+
+				copy_from_user((void *)mask, (const void *)arg, sizeof(unsigned char)*3);
+
+				parm_lcdcid = MAIN_LCDC_ID;
+				parm_imgch = imgch;
+
+				switch(imgch)
+				{
+					case 0: //img0
+					case 1: //img1
+					case 2: //img2
+
+					#if defined(DEMO_LOADSHOW_LCD_HDMI) || defined(DEMO_LOADSHOW_LCD_LVDS)
+						if(imgch == 2)
+						{
+							parm_lcdcid = 0;
+							parm_imgch  = 0;
+						}
+					#elif defined(DEMO_LOADSHOW_LCD_LVDSHDMI)
+						if(imgch == 0)
+						{
+							parm_lcdcid = 0;
+							parm_imgch  = 0;
+						}
+					#endif
+
+						tca_lcdc_setlayerchromakeymask(parm_lcdcid, parm_imgch, mask[0], mask[1], mask[2]);
+						break;
+					default:
+						break;
+				}
+
+				dprintk("ioctl: lcd_img%d_chromakeymask_RY%d(0x%x)GU%d(0x%x)BV%d(0x%x)\n", imgch, mask[0], mask[0], mask[1], mask[1], mask[2], mask[2]);
+			}
+			break;	
+#endif
+
+		case TCC_LCD_FB_IOCTL_SET_FORMAT:
+			{
+				unsigned int fmt;
+//				unsigned offset0=0, offset1=0;
+				unsigned int img_width=0;
+
+				copy_from_user((void *)&fmt, (const void *)arg, sizeof(unsigned int));
+
+				parm_lcdcid = MAIN_LCDC_ID;
+				parm_imgch = imgch;
+
+				switch(imgch)
+				{
+					case 0: //img0
+					#if defined(DEMO_LOADSHOW_LCD_LVDSHDMI)
+						img_width = pLCDC0->LI0S & 0x0000ffff;
+						parm_lcdcid = 0;
+						parm_imgch  = 0;
+					#else
+						img_width = pLCDC1->LI0S & 0x0000ffff;
+					#endif
+						break;
+					case 1: //img1
+						img_width = pLCDC1->LI1S & 0x0000ffff;
+						break;
+					case 2: //img2
+					#if defined(DEMO_LOADSHOW_LCD_HDMI) || defined(DEMO_LOADSHOW_LCD_LVDS)
+						img_width = pLCDC0->LI0S & 0x0000ffff;
+						parm_lcdcid = 0;
+						parm_imgch  = 0;
+					#else
+						img_width = pLCDC1->LI2S & 0x0000ffff;
+					#endif
+						break;
+					default:
+						break;
+				}
+				tca_lcdc_setimgchfmt(parm_lcdcid, parm_imgch, fmt);
+				tca_lcdc_setaddroffset(parm_lcdcid, parm_imgch, img_width, fmt);
+			//	tca_lcdc_setimgchOffsetInfo(parm_lcdcid, parm_imgch, offset0, offset1);
+
+				dprintk("ioctl: lcd_img%d_set_format(%d)\n", imgch, fmt);
+			}
+			break;		
+			
+
+		case TCC_LCD_FB_IOCTL_SET_BASEADDR:
+			{
+				unsigned int addr[3];
+
+				copy_from_user((void *)addr, (const void *)arg, sizeof(unsigned int)*3);
+
+				parm_lcdcid = MAIN_LCDC_ID;
+				parm_imgch = imgch;
+
+				switch(imgch)
+				{
+					case 0: //img0
+					case 1: //img1
+					case 2: //img2
+
+					#if defined(DEMO_LOADSHOW_LCD_HDMI) || defined(DEMO_LOADSHOW_LCD_LVDS)
+						if(imgch == 2)
+						{
+							parm_lcdcid = 0;
+							parm_imgch  = 0;
+						}
+					#elif defined(DEMO_LOADSHOW_LCD_LVDSHDMI)
+						if(imgch == 0)
+						{
+							parm_lcdcid = 0;
+							parm_imgch  = 0;
+						}
+					#endif
+
+						tca_lcdc_setimgchbase(parm_lcdcid, parm_imgch, addr[0], addr[1], addr[2]);
+
+						tcc_m2m_refresh();
+
+						break;
+					default:
+						break;
+				}
+
+				#if (1)	// Debug :: LCDC under-run, Base address align.
+				{
+					unsigned int stat=0;
+
+					if(pLCDC1->LCTRL & 0x1)
+					{
+						stat = pLCDC1->LSTATUS;
+						if(stat & 0x01)
+						{
+							printk("LCDC1 Underrun...\n");
+							pLCDC1->LSTATUS = stat;
+						}
+
+#if (0)
+						if ( ((pLCDC1->LI0BA0 & 0x1FF) != 0)
+						  || ((pLCDC1->LI1BA0 & 0x1FF) != 0)
+						  || ((pLCDC1->LI2BA0 & 0x1FF) != 0)
+						)
+						{
+							printk("LCDC1 IMGxBA: %x  %x  %x \n", pLCDC1->LI0BA0, pLCDC1->LI1BA0, pLCDC1->LI2BA0);
+						}
+#else
+						if (parm_lcdcid == 0)	// lcdc0
+						{
+							if ((pLCDC0->LI0BA0 & 0x1FF) != 0)
+							{
+								printk("(warning) LCDC0 IMG0BA : %x\n", pLCDC0->LI0BA0);
+							}
+						}
+						else					// lcdc1
+						{
+							switch(parm_imgch)
+							{
+								case 0:
+									if ((pLCDC1->LI0BA0 & 0x1FF) != 0)
+										printk("(warning) LCDC1 IMG0BA : %x\n", pLCDC1->LI0BA0);
+									break;
+								case 1:
+									if ((pLCDC1->LI1BA0 & 0x1FF) != 0)
+										printk("(warning) LCDC1 IMG1BA : %x\n", pLCDC1->LI1BA0);
+									break;
+								case 2:
+									if ((pLCDC1->LI2BA0 & 0x1FF) != 0)
+										printk("(warning) LCDC1 IMG2BA : %x\n", pLCDC1->LI2BA0);
+									break;
+							}
+						}
+#endif
+					}
+
+					if(pLCDC0->LCTRL & 0x1)
+					{
+					stat = pLCDC0->LSTATUS;
+						if(stat & 0x01)
+						{
+							printk("LCDC0 Underrun...\n");
+							pLCDC0->LSTATUS = stat;
+						}
+
+						if ( ((pLCDC0->LI0BA0 & 0x1FF) != 0))
+						{
+							printk("LCDC0 IMGxBA: %x\n", pLCDC0->LI0BA0);
+						}
+					}
+
+				}
+				#endif
+
+				dprintk("ioctl: lcd_img%d_set_baseaddr(0x%08x, 0x%08x, 0x%08x)\n", imgch, addr[0], addr[1], addr[2]);
+			}
+			break;		
+
+		case TCC_LCD_FB_IOCTL_GET_BASEADDR:
+			{
+				unsigned int addr[3];
+
+				parm_lcdcid = MAIN_LCDC_ID;
+				parm_imgch = imgch;
+
+				switch(imgch)
+				{
+					case 0: //img0
+					case 1: //img1
+					case 2: //img2
+
+					#if defined(DEMO_LOADSHOW_LCD_HDMI) || defined(DEMO_LOADSHOW_LCD_LVDS)
+						if(imgch == 2)
+						{
+							parm_lcdcid = 0;
+							parm_imgch  = 0;
+						}
+					#elif defined(DEMO_LOADSHOW_LCD_LVDSHDMI)
+						if(imgch == 0)
+						{
+							parm_lcdcid = 0;
+							parm_imgch  = 0;
+						}
+					#endif
+
+						tca_lcdc_getimgchbase(parm_lcdcid, parm_imgch, &addr[0], &addr[1], &addr[2]);
+						break;
+					default:
+						break;
+				}
+
+				copy_to_user((void *)arg, (const void *)addr, sizeof(unsigned int)*3);
+
+				dprintk("ioctl: lcd_img%d_get_baseaddr(0x%08x, 0x%08x, 0x%08x)\n", imgch, addr[0], addr[1], addr[2]);
+			}
+			break;		
+
+		case TCC_LCD_FB_IOCTL_SET_ADDROFFSET:
+			{
+				unsigned int offset[2];
+
+				copy_from_user((void *)offset, (const void *)arg, sizeof(unsigned int)*2);
+
+				parm_lcdcid = MAIN_LCDC_ID;
+				parm_imgch = imgch;
+
+				switch(imgch)
+				{
+					case 0: //img0
+					case 1: //img1
+					case 2: //img2
+
+					#if defined(DEMO_LOADSHOW_LCD_HDMI) || defined(DEMO_LOADSHOW_LCD_LVDS)
+						if(imgch == 2)
+						{
+							parm_lcdcid = 0;
+							parm_imgch  = 0;
+						}
+					#elif defined(DEMO_LOADSHOW_LCD_LVDSHDMI)
+						if(imgch == 0)
+						{
+							parm_lcdcid = 0;
+							parm_imgch  = 0;
+						}
+					#endif
+
+						tca_lcdc_setimgchOffsetInfo(parm_lcdcid, parm_imgch, offset[0], offset[1]);
+						break;
+					default:
+						break;
+				}
+
+				dprintk("ioctl: lcd_img%d_set_offsetinfo(0x%08x, 0x%08x)\n", imgch, offset[0], offset[1]);
+			}
+			break;		
+
+		case TCC_LCD_FB_IOCTL_SET_IMGWINDOW:
+			{
+				unsigned int value[4];
+				unsigned int fmt;
+
+				copy_from_user((void *)value, (const void *)arg, sizeof(unsigned int)*4);
+
+				parm_lcdcid = MAIN_LCDC_ID;
+				parm_imgch = imgch;
+
+				switch(imgch)
+				{
+					case 0: //img0
+					case 1: //img1
+					case 2: //img2
+
+					#if defined(DEMO_LOADSHOW_LCD_HDMI) || defined(DEMO_LOADSHOW_LCD_LVDS)
+						if(imgch == 2)
+						{
+							parm_lcdcid = 0;
+							parm_imgch  = 0;
+						}
+					#elif defined(DEMO_LOADSHOW_LCD_LVDSHDMI)
+						if(imgch == 0)
+						{
+							parm_lcdcid = 0;
+							parm_imgch  = 0;
+						}
+					#endif
+
+						tca_lcdc_getimgchfmt(parm_lcdcid, parm_imgch, &fmt);
+						tca_lcdc_setimgchwindow(parm_lcdcid, parm_imgch, value[0], value[1], value[2], value[3]);
+						tca_lcdc_setaddroffset(parm_lcdcid, parm_imgch, value[2], fmt);
+
+						tcc_m2m_refresh();
+
+						break;
+					default:
+						break;
+				}
+				
+				dprintk("ioctl: lcd_img%d_setimgwindow_sx(%d)sy(%d)w(%d)h(%d)\n", imgch, value[0], value[1], value[2], value[3]);
+			}
+			break;	
+
+		case TCC_LCD_FB_IOCTL_SET_R2YCONV_OPTION:
+			{
+				unsigned int value[2];
+
+				copy_from_user((void *)value, (const void *)arg, sizeof(unsigned int)*2);
+
+				switch(value[0])
+				{
+					case 0:
+					case 1:
+						tca_lcdc_setr2yconvopt(value[0], value[1]);
+						break;
+					default:
+						break;
+				}
+				dprintk("ioctl: lcdc%d_set_r2yconvopt(%d)\n", value[0], value[1]);
+			}
+			break;
+
+		case TCC_LCD_FB_IOCTL_GET_R2YCONV_OPTION:
+			{
+				unsigned int value[2];
+
+				copy_from_user((void *)value, (const void *)arg, sizeof(unsigned int)*2);
+
+				switch(value[0])
+				{
+					case 0:
+					case 1:
+						tca_lcdc_getr2yconvopt(value[0], &value[1]);
+						break;
+					default:
+						break;
+				}
+
+				copy_to_user((void *)arg, (const void *)value, sizeof(unsigned int)*2);
+
+				dprintk("ioctl: lcdc%d_get_r2yconvopt(%d)\n", value[0], value[1]);
+			}
+			break;
+
+		case TCC_LCD_FB_IOCTL_SET_IMG_Y2RCONV_OPTION:
+			{
+				unsigned int value;
+
+				copy_from_user((void *)&value, (const void *)arg, sizeof(unsigned int));
+
+				parm_lcdcid = MAIN_LCDC_ID;
+				parm_imgch = imgch;
+
+				switch(imgch)
+				{
+					case 0: //img0
+					case 1: //img1
+					case 2: //img2
+
+					#if defined(DEMO_LOADSHOW_LCD_HDMI) || defined(DEMO_LOADSHOW_LCD_LVDS)
+						if(imgch == 2)
+						{
+							parm_lcdcid = 0;
+							parm_imgch  = 0;
+						}
+					#elif defined(DEMO_LOADSHOW_LCD_LVDSHDMI)
+						if(imgch == 0)
+						{
+							parm_lcdcid = 0;
+							parm_imgch  = 0;
+						}
+					#endif
+						tca_lcdc_setimgy2rconvopt(parm_lcdcid, parm_imgch, value);
+						break;
+					default:
+						break;
+				}
+				
+				dprintk("ioctl: lcdc%d.img%d_set_imgconvopt(%d)\n", parm_lcdcid, imgch, value);
+			}
+			break;	
+
+		case TCC_LCD_FB_IOCTL_GET_IMG_Y2RCONV_OPTION:
+			{
+				unsigned int value;
+
+				parm_lcdcid = MAIN_LCDC_ID;
+				parm_imgch = imgch;
+
+				switch(imgch)
+				{
+					case 0: //img0
+					case 1: //img1
+					case 2: //img2
+
+					#if defined(DEMO_LOADSHOW_LCD_HDMI) || defined(DEMO_LOADSHOW_LCD_LVDS)
+						if(imgch == 2)
+						{
+							parm_lcdcid = 0;
+							parm_imgch  = 0;
+						}
+					#elif defined(DEMO_LOADSHOW_LCD_LVDSHDMI)
+						if(imgch == 0)
+						{
+							parm_lcdcid = 0;
+							parm_imgch  = 0;
+						}
+					#endif
+
+						tca_lcdc_getimgy2rconvopt(parm_lcdcid, parm_imgch, &value);
+						break;
+					default:
+						break;
+				}
+
+				copy_to_user((void *)arg, (const void *)&value, sizeof(unsigned int));
+
+				dprintk("ioctl: lcdc%d.img%d_get_imgconvopt(%d)\n", parm_lcdcid, imgch, value);
+			}
+			break;		
+
+		case TCC_LCD_FB_IOCTL_SET_COLOR_ENAHNCEMENT:
+			{
+				unsigned int value[4];
+
+				copy_from_user((void *)value, (const void *)arg, sizeof(unsigned int)*4);
+
+				switch(value[0])
+				{
+					case 0:
+					case 1:
+						tca_lcdc_setcolorenhancement(value[0], value[1], value[2], value[3]);
+						break;
+					default:
+						break;
+				}
+				dprintk("ioctl: lcdc%d_set_colorenhancement(hue:%d,bright:%d,contrast:%d)\n", value[0], value[1], value[2], value[3]);
+			}
+			break;
+
+		case TCC_LCD_FB_IOCTL_GET_COLOR_ENAHNCEMENT:
+			{
+				unsigned int value[4];
+
+				copy_from_user((void *)value, (const void *)arg, sizeof(unsigned int)*4);
+
+				switch(value[0])
+				{
+					case 0:
+					case 1:
+						tca_lcdc_getcolorenhancement(value[0], &value[1], &value[2], &value[3]);
+						break;
+					default:
+						break;
+				}
+
+				copy_to_user((void *)arg, (const void *)value, sizeof(unsigned int)*4);
+
+				dprintk("ioctl: lcdc%d_get_colorenhancement(hue:%d,bright:%d,contrast:%d)\n", value[0], value[1], value[2], value[3]);
+			}
+			break;
+
+		case TCC_LCD_FB_IOCTL_SET_IMAGE_ENAHNCEMENT:
+			{
+				unsigned int value[3];
+
+				copy_from_user((void *)value, (const void *)arg, sizeof(unsigned int)*3);
+
+				parm_lcdcid = MAIN_LCDC_ID;
+				parm_imgch = imgch;
+
+				switch(imgch)
+				{
+					case 0: //img0
+					case 1: //img1
+					case 2: //img2
+
+					#if defined(DEMO_LOADSHOW_LCD_HDMI) || defined(DEMO_LOADSHOW_LCD_LVDS)
+						if(imgch == 2)
+						{
+							parm_lcdcid = 0;
+							parm_imgch  = 0;
+						}
+					#elif defined(DEMO_LOADSHOW_LCD_LVDSHDMI)
+						if(imgch == 0)
+						{
+							parm_lcdcid = 0;
+							parm_imgch  = 0;
+						}
+					#endif
+						tca_lcdc_setimgenhancement(parm_lcdcid, parm_imgch, value[0], value[1], value[2]);
+						break;
+					default:
+						break;
+				}
+				
+				dprintk("ioctl: lcdc%d.img%d_set_imageenhancement(hue:%d,bright:%d,contrast:%d)\n", parm_lcdcid, imgch, value[0], value[1], value[2]);
+			}
+			break;	
+
+		case TCC_LCD_FB_IOCTL_GET_IMAGE_ENAHNCEMENT:
+			{
+				unsigned int value[3];
+
+				parm_lcdcid = MAIN_LCDC_ID;
+				parm_imgch = imgch;
+
+				switch(imgch)
+				{
+					case 0: //img0
+					case 1: //img1
+					case 2: //img2
+
+					#if defined(DEMO_LOADSHOW_LCD_HDMI) || defined(DEMO_LOADSHOW_LCD_LVDS)
+						if(imgch == 2)
+						{
+							parm_lcdcid = 0;
+							parm_imgch  = 0;
+						}
+					#elif defined(DEMO_LOADSHOW_LCD_LVDSHDMI)
+						if(imgch == 0)
+						{
+							parm_lcdcid = 0;
+							parm_imgch  = 0;
+						}
+					#endif
+
+						tca_lcdc_getimgenhancement(parm_lcdcid, parm_imgch, &value[0], &value[1], &value[2]);
+						break;
+					default:
+						break;
+				}
+
+				copy_to_user((void *)arg, (const void *)value, sizeof(unsigned int)*3);
+
+				dprintk("ioctl: lcdc%d.img%d_get_imageenhancement(hue:%d,bright:%d,contrast:%d)\n", parm_lcdcid, imgch, value[0], value[1], value[2]);
+			}
+			break;		
+
+#if 0
+		//@lcdc info set/get (new method!)
+		case TCC_LCD_FB_IOCTL_LCDC_SETALLINFO	:
+			{
+				copy_from_user((void *)g_pLCDCInfo, (const void *)arg, sizeof(TCC_LCDC_INFO));
+				LCDC_SetAllInfo(g_pLCDCInfo);
+			}
+
+			break;
+			
+		case TCC_LCD_FB_IOCTL_LCDC_GETALLINFO	:
+			{
+				LCDC_GetAllInfo(g_pLCDCInfo);
+				copy_to_user((void *)arg, (const void *)g_pLCDCInfo, sizeof(TCC_LCDC_INFO));
+			}
+
+			break;
+			
+		case TCC_LCD_FB_IOCTL_LCDC_SETDISPLAYINFO	:
+			{
+				copy_from_user((void *)g_pLCDCDisInfo, (const void *)arg, sizeof(TCC_LCDC_DISPLAY_INFO));
+				LCDC_SetDisplayInfo(g_pLCDCDisInfo);
+			}
+
+			break;
+			
+		case TCC_LCD_FB_IOCTL_LCDC_GETDISPLAYINFO	:
+			{
+				LCDC_GetDisplayInfo(g_pLCDCDisInfo);
+				copy_to_user((void *)arg, (const void *)g_pLCDCDisInfo, sizeof(TCC_LCDC_DISPLAY_INFO));
+			}
+
+			break;
+			
+		case TCC_LCD_FB_IOCTL_LCDC_SETINTERFACEINFO :
+			{
+				copy_from_user((void *)g_pLCDCIfInfo, (const void *)arg, sizeof(TCC_LCDC_INTERFACE_INFO));
+				LCDC_SetInterfaceInfo(g_pLCDCIfInfo);
+			}
+
+			break;
+			
+		case TCC_LCD_FB_IOCTL_LCDC_GETINTERFACEINFO :
+			{
+				LCDC_GetInterfaceInfo(g_pLCDCIfInfo);
+				copy_to_user((void *)arg, (const void *)g_pLCDCIfInfo, sizeof(TCC_LCDC_INTERFACE_INFO));
+			}
+
+			break;
+			
+		case TCC_LCD_FB_IOCTL_LCDC_SETIMGCH0INFO :
+			{
+				copy_from_user((void *)g_pLCDCImgChInfo[TCC_LCDC_IMGCH0], (const void *)arg, sizeof(TCC_LCDC_IMGCH_INFO));
+				LCDC_SetImgChInfo(TCC_LCDC_IMGCH0, g_pLCDCImgChInfo[TCC_LCDC_IMGCH0]);
+			}
+
+			break;
+
+		case TCC_LCD_FB_IOCTL_LCDC_SETIMGCH1INFO :
+			{
+				copy_from_user((void *)g_pLCDCImgChInfo[TCC_LCDC_IMGCH1], (const void *)arg, sizeof(TCC_LCDC_IMGCH_INFO));
+				LCDC_SetImgChInfo(TCC_LCDC_IMGCH1, g_pLCDCImgChInfo[TCC_LCDC_IMGCH1]);
+			}
+		
+			break;
+
+		case TCC_LCD_FB_IOCTL_LCDC_SETIMGCH2INFO :
+			{
+				copy_from_user((void *)g_pLCDCImgChInfo[TCC_LCDC_IMGCH2], (const void *)arg, sizeof(TCC_LCDC_IMGCH_INFO));
+				LCDC_SetImgChInfo(TCC_LCDC_IMGCH2, g_pLCDCImgChInfo[TCC_LCDC_IMGCH2]);
+			}
+		
+			break;
+
+			
+		case TCC_LCD_FB_IOCTL_LCDC_GETIMGCH0INFO :
+			{
+				LCDC_GetImgChInfo(TCC_LCDC_IMGCH0, g_pLCDCImgChInfo[TCC_LCDC_IMGCH0]);
+				copy_to_user((void *)arg, (const void *)g_pLCDCImgChInfo[TCC_LCDC_IMGCH0], sizeof(TCC_LCDC_IMGCH_INFO));
+			}
+
+			break;
+
+		case TCC_LCD_FB_IOCTL_LCDC_GETIMGCH1INFO :
+			{
+				LCDC_GetImgChInfo(TCC_LCDC_IMGCH1, g_pLCDCImgChInfo[TCC_LCDC_IMGCH1]);
+				copy_to_user((void *)arg, (const void *)g_pLCDCImgChInfo[TCC_LCDC_IMGCH1], sizeof(TCC_LCDC_IMGCH_INFO));
+			}
+		
+			break;
+
+		case TCC_LCD_FB_IOCTL_LCDC_GETIMGCH2INFO :
+			{
+				LCDC_GetImgChInfo(TCC_LCDC_IMGCH2, g_pLCDCImgChInfo[TCC_LCDC_IMGCH2]);
+				copy_to_user((void *)arg, (const void *)g_pLCDCImgChInfo[TCC_LCDC_IMGCH2], sizeof(TCC_LCDC_IMGCH_INFO));
+			}
+		
+			break;
+
+			
+		case TCC_LCD_FB_IOCTL_LCDC_SETLAYER1INFO :
+			{
+				copy_from_user((void *)g_pLCDCLayerInfo[TCC_LCDC_LAYER1], (const void *)arg, sizeof(TCC_LCDC_LAYER_INFO));
+				LCDC_SetLayerInfo(TCC_LCDC_LAYER1, g_pLCDCLayerInfo[TCC_LCDC_LAYER1]);
+			}
+			
+			break;
+			
+		case TCC_LCD_FB_IOCTL_LCDC_SETLAYER2INFO :
+			{
+				copy_from_user((void *)g_pLCDCLayerInfo[TCC_LCDC_LAYER2], (const void *)arg, sizeof(TCC_LCDC_LAYER_INFO));
+				LCDC_SetLayerInfo(TCC_LCDC_LAYER2, g_pLCDCLayerInfo[TCC_LCDC_LAYER2]);
+			}
+			
+			break;
+
+		case TCC_LCD_FB_IOCTL_LCDC_GETLAYER1INFO :
+			{
+				LCDC_GetLayerInfo(TCC_LCDC_LAYER1, g_pLCDCLayerInfo[TCC_LCDC_LAYER1]);
+				copy_to_user((void *)arg, (const void *)g_pLCDCLayerInfo[TCC_LCDC_LAYER1], sizeof(TCC_LCDC_LAYER_INFO));
+			}
+
+			break;
+
+		case TCC_LCD_FB_IOCTL_LCDC_GETLAYER2INFO :
+			{
+				LCDC_GetLayerInfo(TCC_LCDC_LAYER2, g_pLCDCLayerInfo[TCC_LCDC_LAYER2]);
+				copy_to_user((void *)arg, (const void *)g_pLCDCLayerInfo[TCC_LCDC_LAYER2], sizeof(TCC_LCDC_LAYER_INFO));
+			}
+
+			break;
+		//~end
+#endif
+
+		//@tvo
+		#ifdef TV_OUT_INCLUDE
+		case TCC_LCD_FB_IOCTL_TVOUT_TYPE:
+		case TCC_LCD_FB_IOCTL_TVOUT_OPEN:
+		case TCC_LCD_FB_IOCTL_TVOUT_CLOSE:
+		case TCC_LCD_FB_IOCTL_TVOUT_CONNECT_LCDC:
+			tvo_ioctl(cmd, arg);
+			break;
+		#endif
+
+		default:
+			dprintk("ioctl: Unknown [%d/0x%X]", cmd, cmd);
+			break;			
+
+	}
+
+#if 1
+	for (ch_num=0; ch_num<CONFIG_FB_TCC_DEVS; ch_num++)
+	{
+		parm_lcdcid = MAIN_LCDC_ID;
+		parm_imgch = ch_num;
+		
+	#if defined(DEMO_LOADSHOW_LCD_HDMI) || defined(DEMO_LOADSHOW_LCD_LVDS)
+		if(ch_num == 2)
+		{
+			parm_lcdcid = 0;
+			parm_imgch  = 0;
+		}
+	#elif defined(DEMO_LOADSHOW_LCD_LVDSHDMI)
+		if(ch_num == 0)
+		{
+			parm_lcdcid = 0;
+			parm_imgch  = 0;
+		}
+	#endif
+
+		tca_lcdc_getimgchfmt(parm_lcdcid, parm_imgch, &curr_fmt[ch_num]);
+
+		if (prev_fmt[ch_num] != curr_fmt[ch_num])
+		{
+			if (fb_mem_vaddr[ch_num] != NULL)
+			{
+				memset(fb_mem_vaddr[ch_num], 0, fb_mem_size[ch_num]);
+			}
+		}
+	}
+#endif
+
+	return 0;
+}
+
+static void schedule_palette_update(struct tccfb_info *fbi,
+				    unsigned int regno, unsigned int val)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	local_irq_restore(flags);
+}
+
+/* from pxafb.c */
+static inline unsigned int chan_to_field(unsigned int chan, struct fb_bitfield *bf)
+{
+	chan &= 0xffff;
+	chan >>= 16 - bf->length;
+	return chan << bf->offset;
+}
+
+static int tccfb_setcolreg(unsigned regno,
+			       unsigned red, unsigned green, unsigned blue,
+			       unsigned transp, struct fb_info *info)
+{
+	struct tccfb_info *fbi = info->par;
+	unsigned int val;
+
+	/* dprintk("setcol: regno=%d, rgb=%d,%d,%d\n", regno, red, green, blue); */
+
+	switch (fbi->fb->fix.visual) {
+	case FB_VISUAL_TRUECOLOR:
+		/* true-colour, use pseuo-palette */
+
+		if (regno < 16) {
+			u32 *pal = fbi->fb->pseudo_palette;
+
+			val  = chan_to_field(red,   &fbi->fb->var.red);
+			val |= chan_to_field(green, &fbi->fb->var.green);
+			val |= chan_to_field(blue,  &fbi->fb->var.blue);
+
+			pal[regno] = val;
+		}
+		break;
+
+	case FB_VISUAL_PSEUDOCOLOR:
+		if (regno < 256) {
+			/* currently assume RGB 5-6-5 mode */
+
+			val  = ((red   >>  0) & 0xf800);
+			val |= ((green >>  5) & 0x07e0);
+			val |= ((blue  >> 11) & 0x001f);
+
+			//writel(val, S3C2410_TFTPAL(regno));
+			schedule_palette_update(fbi, regno, val);
+		}
+
+		break;
+
+	default:
+		return 1;   /* unknown type */
+	}
+
+	return 0;
+}
+
+
+/**
+ *      tccfb_blank
+ *	@blank_mode: the blank mode we want.
+ *	@info: frame buffer structure that represents a single frame buffer
+ *
+ *	Blank the screen if blank_mode != 0, else unblank. Return 0 if
+ *	blanking succeeded, != 0 if un-/blanking failed due to e.g. a
+ *	video mode which doesn't support it. Implements VESA suspend
+ *	and powerdown modes on hardware that supports disabling hsync/vsync:
+ *	blank_mode == 2: suspend vsync
+ *	blank_mode == 3: suspend hsync
+ *	blank_mode == 4: powerdown
+ *
+ *	Returns negative errno on error, or zero on success.
+ *
+ */
+static int tccfb_blank(int blank_mode, struct fb_info *info)
+{
+	dprintk("blank(mode=%d, info=%p)\n", blank_mode, info);
+
+	return 0;
+}
+
+static struct fb_ops tccfb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_check_var	= tccfb_check_var,
+	.fb_set_par	= tccfb_set_par,
+	.fb_blank	= tccfb_blank,
+	.fb_setcolreg	= tccfb_setcolreg,
+	.fb_fillrect	= cfb_fillrect,
+	.fb_copyarea	= cfb_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+	.fb_ioctl		= tccfb_ioctl,
+	.fb_pan_display = tccfb_pan_display,
+};
+
+
+/*
+ * tccfb_map_video_memory():
+ *	Allocates the DRAM memory for the frame buffer.  This buffer is
+ *	remapped into a non-cached, non-buffered, memory region to
+ *	allow palette and pixel writes to occur without flushing the
+ *	cache.  Once this area is remapped, all virtual memory
+ *	access to the video memory should occur at the new region.
+ */
+static int __init tccfb_map_video_memory(struct tccfb_info *fbi, int plane)
+{
+	dprintk("map_video_memory(fbi=%p), map_size:%08x\n", fbi, fbi->map_size);
+#if (0)
+//	if(plane==0)
+		fbi->map_size = PAGE_ALIGN(fbi->fb->fix.smem_len + PAGE_SIZE);
+//	else
+///		fbi->map_size = PAGE_ALIGN(fbi->fb->fix.smem_len*4 + PAGE_SIZE);
+	// allocate the memory space for frame buffer,
+	// fbi->map_cpu store the virtual address
+	// fbi->map_dma store the physical address
+	fbi->map_cpu  = dma_alloc_writecombine(fbi->dev, fbi->map_size,
+					       &fbi->map_dma, GFP_KERNEL);
+
+	fbi->map_size = fbi->fb->fix.smem_len;
+#else
+
+	fbi->map_dma  = 0;
+	fbi->map_size = 0;
+
+	if(request_mem_region(fb_reseved_mem_paddr[plane], fb_reseved_mem_size[plane], "tccfb"))
+	{
+		fbi->fb->fix.smem_start = fb_reseved_mem_paddr[plane];
+		fbi->fb->fix.smem_len   = fb_reseved_mem_size [plane];
+
+		fbi->map_dma  = fbi->fb->fix.smem_start;
+		fbi->map_size = fbi->fb->fix.smem_len;
+
+		fbi->map_cpu = ioremap(fbi->map_dma, fbi->map_size);
+
+		if (!fbi->map_cpu) {
+			printk("fb[%d]: failed ioremap::0x%08lX\n", (int)plane, (unsigned long)fbi->map_dma);
+		}
+	}
+	else
+	{
+		printk("fb[%d]: failed request_mem_region::0x%08lX\n", (int)plane, (unsigned long)fbi->map_dma);
+	}
+#endif
+
+	if (fbi->map_cpu) {
+		/* prevent initial garbage on screen */
+		dprintk("map_video_memory: clear %p:%08x\n",
+			fbi->map_cpu, fbi->map_size);
+		memset(fbi->map_cpu, 0x00, fbi->map_size);
+
+		fbi->screen_dma		= fbi->map_dma;
+		fbi->fb->screen_base	= fbi->map_cpu;
+		fbi->fb->fix.smem_start  = fbi->screen_dma;
+
+		// Set the LCD frame buffer start address
+		switch (plane)
+		{
+			case 2:	// IMG2
+		#if defined(DEMO_LOADSHOW_LCD_HDMI) || defined(DEMO_LOADSHOW_LCD_LVDS)
+				pLCDC0->LI0BA0 = fbi->map_dma;
+				fb_mem_vaddr[plane] = fbi->map_cpu;
+				fb_mem_size [plane] = fbi->map_size;
+		#else
+				pLCDC1->LI2BA0 = fbi->map_dma;
+				fb_mem_vaddr[plane] = fbi->map_cpu;
+				fb_mem_size [plane] = fbi->map_size;
+		#endif
+				break;
+			case 1:	// IMG1
+				pLCDC1->LI1BA0 = fbi->map_dma;
+				fb_mem_vaddr[plane] = fbi->map_cpu;
+				fb_mem_size [plane] = fbi->map_size;
+				break;
+			case 0:	// IMG0
+		#if defined(DEMO_LOADSHOW_LCD_LVDSHDMI)
+				pLCDC0->LI0BA0 = fbi->map_dma;
+				fb_mem_vaddr[plane] = fbi->map_cpu;
+				fb_mem_size [plane] = fbi->map_size;
+		#else
+				pLCDC1->LI0BA0 = fbi->map_dma;
+				fb_mem_vaddr[plane] = fbi->map_cpu;
+				fb_mem_size [plane] = fbi->map_size;
+		#endif
+				break;
+		}
+#if 0
+		dprintk("map_video_memory: dma=%08x cpu=%p size=%08x\n",
+			fbi->map_dma, fbi->map_cpu, fbi->fb->fix.smem_len);
+#else
+		printk("fb[%d]::map_video_memory: dma=%08x cpu=%p size=%08x\n",
+			plane, fbi->map_dma, fbi->map_cpu, fbi->fb->fix.smem_len);
+#endif
+	}
+
+	return fbi->map_cpu ? 0 : -ENOMEM;
+}
+
+static inline void tccfb_unmap_video_memory(struct tccfb_info *fbi)
+{
+#if (0)
+	dma_free_writecombine(fbi->dev,fbi->map_size,fbi->map_cpu, fbi->map_dma);
+#else
+	iounmap(fbi->map_cpu);
+	release_mem_region(fbi->map_dma, fbi->map_size);
+#endif
+
+	fb_mem_vaddr[fbi->imgch] = (u_char*)NULL;
+	fb_mem_size [fbi->imgch] = (u_int)NULL;
+}
+
+static irqreturn_t tcc_lcd_handler0(int irq, void *dev_id)
+{
+	if(pLCDC0->LSTATUS & Hw3)
+	{
+		tcc_lcdc_interrupt(0, 0);
+		
+		lcdc_struct[0].state = 1;
+		wake_up_interruptible(&lcdc_struct[0].waitq);
+
+	}
+    return IRQ_HANDLED;
+}
+
+static irqreturn_t tcc_lcd_handler(int irq, void *dev_id)
+{
+	if(pLCDC1->LSTATUS & Hw3)
+	{
+		tcc_lcdc_interrupt(1, 0);
+		
+		lcdc_struct[1].state = 1;
+		wake_up_interruptible(&lcdc_struct[1].waitq);
+
+	}
+    return IRQ_HANDLED;
+}
+
+static char tccfb_driver_name[]="tccfb";
+static int __init tccfb_probe(struct platform_device *pdev)
+{
+	struct tccfb_info *info;
+	struct fb_info *fbinfo;
+	int ret;
+	int plane = 0;
+//	unsigned int layer_en = 0;
+    unsigned int tmp_value= 0;
+
+	dprintk("+probe\n");
+
+	// LCD 3-Layer(RGB565) Enable
+	switch(CONFIG_FB_TCC_DEVS)
+	{
+		case 3:
+		#if defined(DEMO_LOADSHOW_LCD_HDMI) || defined(DEMO_LOADSHOW_LCD_LVDS)
+			pLCDC0->LI0S	= (fb_height[2] << 16) | (fb_width[2]); //Size
+			pLCDC0->LI0P	= 0|0; //	position
+			pLCDC0->LI0SR   = 0;
+    		tmp_value = pLCDC0->LI0C | (1<<28);    // | image enable
+			switch(default_scn_depth[2])
+			{
+				case 32:
+					pLCDC0->LI0C	= (tmp_value & 0xFFFFFFE0) | (0x000C);//RGB888
+                    pLCDC0->LI0O    = (fb_width[2]*4);
+					break;
+				case 16:
+				default:
+					pLCDC0->LI0C	= (tmp_value & 0xFFFFFFE0) | (0x000A);//RGB565
+					pLCDC0->LI0O    = (fb_width[2]*2);
+					break;
+			}
+			
+			pLCDC1->LI2C	= pLCDC1->LI2C & ~(1<<28);    // image disable
+		#else
+			//HwLI2BA0 =bakHwLI2BA0;
+			pLCDC1->LI2S	= (fb_height[2] << 16) | (fb_width[2]); //Size
+			pLCDC1->LI2P	= 0|0; //	position
+			pLCDC1->LI2SR   = 0;
+    		tmp_value = pLCDC1->LI2C | (1<<28);    // | image enable
+			switch(default_scn_depth[2])
+			{
+				case 32:
+					pLCDC1->LI2C	= (tmp_value & 0xFFFFFFE0) | (0x000C);//RGB888
+                    pLCDC1->LI2O    = (fb_width[2]*4);
+					break;
+				case 16:
+				default:
+					pLCDC1->LI2C	= (tmp_value & 0xFFFFFFE0) | (0x000A);//RGB565
+					pLCDC1->LI2O    = (fb_width[2]*2);
+					break;
+			}
+		#endif
+		case 2:
+			//HwLI1BA0 =bakHwLI1BA0;
+			pLCDC1->LI1S	= (fb_height[1] << 16) | (fb_width[1]); //Size
+			pLCDC1->LI1P	= 0|0; //	position
+			pLCDC1->LI1SR   = 0;
+
+		#if defined(DEMO_LOADSHOW_LCD_HDMI) || defined(DEMO_LOADSHOW_LCD_LVDS)
+			tmp_value = pLCDC1->LI1C & ~(1<<28);   // | image disable
+		#else
+    		tmp_value = pLCDC1->LI1C | (1<<28);    // | image enable
+   		#endif
+			switch(default_scn_depth[1])
+			{
+				case 32:
+					pLCDC1->LI1C	= (tmp_value & 0xFFFFFFE0) | (0x000C);//RGB888
+					pLCDC1->LI1O    = (fb_width[1]*4);
+					break;
+				case 16:
+				default:
+					pLCDC1->LI1C	= (tmp_value & 0xFFFFFFE0) | (0x000A);//RGB565
+					pLCDC1->LI1O    = (fb_width[1]*2);
+					break;
+			}
+		case 1:
+            if(CONFIG_FB_TCC_DEVS < 3)
+            {
+                tmp_value = pLCDC1->LI2C & ~(1<<28);
+                pLCDC1->LI2C = tmp_value;
+
+                if(CONFIG_FB_TCC_DEVS < 2)
+                {
+                    tmp_value = pLCDC1->LI1C & ~(1<<28);
+                    pLCDC1->LI1C = tmp_value;
+                }
+            }
+		#if defined(DEMO_LOADSHOW_LCD_LVDSHDMI)
+			//HwLI0BA0 =bakHwLI0BA0;
+			pLCDC0->LI0S	= (fb_height[0] << 16) | (fb_width[0]); //Size
+			pLCDC0->LI0P	= 0|0; //	position
+			pLCDC0->LI0SR   = 0;
+//		#if defined(DEMO_LOADSHOW_LCD_HDMI) || defined(DEMO_LOADSHOW_LCD_LVDS)
+//			tmp_value = pLCDC1->LI0C & ~(1<<28);   // | image disable
+//		#else
+    		tmp_value = pLCDC0->LI0C | (1<<28);    // | image enable
+//		#endif
+			switch(default_scn_depth[0])
+			{
+				case 32:
+					pLCDC0->LI0C	= (tmp_value & 0xFFFFFFE0) | (0x000C); //RGB888
+					pLCDC0->LI0O    = (fb_width[0]*4);
+					break;
+				case 16:
+				default:
+					pLCDC0->LI0C	= (tmp_value & 0xFFFFFFE0) | (0x000A); //RGB565
+					pLCDC0->LI0O    = (fb_width[0]*2);
+					break;
+			}
+		#else
+			//HwLI0BA0 =bakHwLI0BA0;
+			pLCDC1->LI0S	= (fb_height[0] << 16) | (fb_width[0]); //Size
+			pLCDC1->LI0P	= 0|0; //	position
+			pLCDC1->LI0SR   = 0;
+//		#if defined(DEMO_LOADSHOW_LCD_HDMI) || defined(DEMO_LOADSHOW_LCD_LVDS)
+//			tmp_value = pLCDC1->LI0C & ~(1<<28);   // | image disable
+//		#else
+    		tmp_value = pLCDC1->LI0C | (1<<28);    // | image enable
+//		#endif
+			switch(default_scn_depth[0])
+			{
+				case 32:
+					pLCDC1->LI0C	= (tmp_value & 0xFFFFFFE0) | (0x000C); //RGB888
+					pLCDC1->LI0O    = (fb_width[0]*4);
+					break;
+				case 16:
+				default:
+					pLCDC1->LI0C	= (tmp_value & 0xFFFFFFE0) | (0x000A); //RGB565
+					pLCDC1->LI0O    = (fb_width[0]*2);
+					break;
+			}
+		#endif
+			break;
+	}
+
+	/*mach_info = pdev->dev.platform_data;
+	if (mach_info == NULL) {
+		dev_err(&pdev->dev,"no platform data for lcd, cannot attach\n");
+		//return -EINVAL;
+	}
+    */
+	for (plane = 0; plane < CONFIG_FB_TCC_DEVS; plane++)
+	{
+		fbinfo = framebuffer_alloc(sizeof(struct tccfb_info), &pdev->dev);
+
+		info = fbinfo->par;
+		info->fb = fbinfo;
+		//platform_set_drvdata(pdev, fbinfo);
+
+		strcpy(fbinfo->fix.id, tccfb_driver_name);
+
+		//info->mach_info		    = pdev->dev.platform_data;
+
+		fbinfo->fix.type			= FB_TYPE_PACKED_PIXELS;
+		fbinfo->fix.type_aux		= 0;
+		fbinfo->fix.xpanstep		= 0;
+#ifdef TCC_FB_DOUBLE_
+		if(plane == 0)
+			fbinfo->fix.ypanstep	= 1;
+		else
+			fbinfo->fix.ypanstep	= 0;
+#else
+		fbinfo->fix.ypanstep		= 0;
+#endif
+		fbinfo->fix.ywrapstep		= 0;
+		fbinfo->fix.line_length		= fb_width[plane] * (default_scn_depth[plane]/8);
+		fbinfo->fix.accel			= FB_ACCEL_NONE;
+
+		fbinfo->var.nonstd			= 0;
+		fbinfo->var.activate		= FB_ACTIVATE_NOW;
+
+		fbinfo->var.height			= fb_height[plane];
+		fbinfo->var.width			= fb_width[plane];
+		fbinfo->var.accel_flags		= 0;
+		fbinfo->var.vmode			= FB_VMODE_NONINTERLACED;
+
+		fbinfo->fbops				= &tccfb_ops;
+		fbinfo->flags				= FBINFO_FLAG_DEFAULT;
+
+		fbinfo->var.xres			= fb_width[plane];
+		fbinfo->var.xres_virtual	= fb_width[plane];
+		fbinfo->var.yres			= fb_height[plane];
+#ifdef TCC_FB_DOUBLE_
+		if(plane == 0)
+			fbinfo->var.yres_virtual	= fb_height[plane] * 2;
+		else
+			fbinfo->var.yres_virtual	= fb_height[plane];
+#else
+		fbinfo->var.yres_virtual	= fb_height[plane];
+#endif
+		fbinfo->var.bits_per_pixel	= default_scn_depth[plane];
+
+		tccfb_check_var(&fbinfo->var, fbinfo);
+
+#if (0)
+		// the memory size that LCD should occupy
+#ifdef TCC_FB_DOUBLE_
+		fbinfo->fix.smem_len = fbinfo->var.xres *
+						fbinfo->var.yres *
+						SCREEN_DEPTH_MAX / 8 * 2;
+#else
+		fbinfo->fix.smem_len = fbinfo->var.xres *
+						fbinfo->var.yres *
+						SCREEN_DEPTH_MAX / 8;
+#endif
+#endif
+
+//#ifdef POST_SET
+		if (plane == 0)
+		{
+//            tca_ckc_setperi(PERI_LCD1,ENABLE,1560000,PCDIRECTPLL1);
+//			msleep(1);
+		}
+//#endif
+
+		info->imgch = plane;
+
+		/* Initialize video memory */
+		ret = tccfb_map_video_memory(info, plane);
+		if (ret) {
+			printk( KERN_ERR "Failed to allocate video RAM: %d\n", ret);
+			ret = -ENOMEM;
+		}
+
+		ret = register_framebuffer(fbinfo);
+		if (ret < 0) {
+			printk(KERN_ERR "Failed to register framebuffer device: %d\n", ret);
+			goto free_video_memory;
+		}
+
+		tccfb_set_par(fbinfo);
+		msleep(1);
+
+//		if (plane == (CONFIG_FB_TCC_DEVS-1))	// top layer
+			if (fb_prepare_logo(fbinfo,	FB_ROTATE_UR)) {
+			/* Start display and show logo on boot */
+			fb_set_cmap(&fbinfo->cmap, fbinfo);
+
+			dprintk("fb_show_logo\n");
+			fb_show_logo(fbinfo, FB_ROTATE_UR);
+        }
+
+		printk(KERN_INFO "fb%d: %s frame buffer device\n",
+			fbinfo->node, fbinfo->fix.id);
+	}
+
+	init_waitqueue_head(&lcdc_struct[0].waitq);
+	init_waitqueue_head(&lcdc_struct[1].waitq);
+
+#if 1
+    request_irq(IRQ_LCD1,
+                tcc_lcd_handler,
+                IRQF_SHARED,
+                "TCC_LCD",
+                tcc_lcd_handler);
+
+    request_irq(IRQ_LCD0,
+                tcc_lcd_handler0,
+                IRQF_SHARED,
+                "TCC_LCD",
+                tcc_lcd_handler0);
+
+#endif
+    /*
+    tcc_start_lcd_int_dd();
+    tcc_set_reg_for_int_dd();
+    */
+
+	dprintk("-probe\n");
+	return 0;
+
+free_video_memory:
+	tccfb_unmap_video_memory(info);
+	dprintk("-probe:Error\n");
+	return ret;
+}
+
+/* tccfb_stop_lcd
+ *
+ * shutdown the lcd controller
+*/
+
+static void tccfb_stop_lcd(struct tccfb_info *fbi)
+{
+	dprintk("stop_lcd\n");
+	return;
+}
+
+/*
+ *  Cleanup
+ */
+static int tccfb_remove(struct platform_device *pdev)
+{
+	struct fb_info	   *fbinfo = platform_get_drvdata(pdev);
+	struct tccfb_info *info = fbinfo->par;
+
+	dprintk("remove\n");
+
+    tcc_stop_lcd_int_dd();
+    free_irq(IRQ_LCD1, tcc_lcd_handler);
+
+	tccfb_stop_lcd(info);
+//    tca_ckc_setperi(PERI_LCD1,DISABLE,1560000,PCDIRECTPLL1);
+//	msleep(1);
+
+	tccfb_unmap_video_memory(info);
+
+	//release_mem_region((unsigned long)S3C24XX_VA_LCD, S3C24XX_SZ_LCD);
+	unregister_framebuffer(fbinfo);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+
+/* suspend and resume support for the lcd controller */
+
+static int tccfb_suspend(struct platform_device *dev, pm_message_t state)
+{
+	PTIMER vTimerAddr = (PTIMER)((unsigned int)&HwTMR_BASE);
+	PGPIO vGpioAddr = (PGPIO)((unsigned int)&HwGPIO_BASE);
+
+	tca_bkl_powerdown((unsigned int)vTimerAddr,(unsigned int)vGpioAddr);
+
+	//@tvo
+	#ifdef TV_OUT_INCLUDE
+	tvo_powerdown();
+	#endif
+
+	return 0;
+}
+
+static int tccfb_resume(struct platform_device *dev)
+{
+	PTIMER vTimerAddr = (PTIMER)((unsigned int)&HwTMR_BASE);
+	PGPIO vGpioAddr = (PGPIO)((unsigned int)&HwGPIO_BASE);
+
+	//@tvo
+	#ifdef TV_OUT_INCLUDE
+	tvo_powerup();
+	#endif
+	
+	tca_bkl_powerup((unsigned int)vTimerAddr,(unsigned int)vGpioAddr);
+
+	return 0;
+}
+
+static void tccfb_shutdown(struct platform_device *dev)
+{
+	pm_message_t state = {0};
+	tccfb_suspend(dev, state);
+}
+
+#else
+#define tccfb_suspend	NULL
+#define tccfb_resume	NULL
+#define tccfb_shutdown	NULL
+#endif
+
+static struct platform_driver tccfb_driver = {
+	.probe		= tccfb_probe,
+	.remove		= tccfb_remove,
+	.suspend	= tccfb_suspend,
+	.shutdown	= tccfb_shutdown,
+	.resume		= tccfb_resume,
+	.driver		= {
+		.name	= "tccxxx-lcd",
+		.owner	= THIS_MODULE,
+	},
+};
+
+//int __devinit tccfb_init(void)
+static int __init tccfb_init(void)
+{
+    dprintk("init\n");
+
+    tcc_regbase_init();
+
+	//@tvo
+	#ifdef TV_OUT_INCLUDE
+	tvo_init();
+	#endif
+	
+	return platform_driver_register(&tccfb_driver);
+}
+
+static void __exit tccfb_cleanup(void)
+{
+	//@tvo
+	#ifdef TV_OUT_INCLUDE
+	tvo_cleanup();
+	#endif
+	
+	platform_driver_unregister(&tccfb_driver);
+}
+
+
+module_init(tccfb_init);
+module_exit(tccfb_cleanup);
+
+MODULE_AUTHOR("linux <linux@telechips.com>");
+MODULE_DESCRIPTION("Telechips TCC Framebuffer driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.29/drivers/video/tccfb.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/video/tccfb.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,52 @@
+/*
+ * linux/drivers/video/tccfb.h
+ *
+ * Author: <linux@telechips.com>
+ * Created: June 10, 2008
+ * Description: TCC LCD Controller Frame Buffer Driver
+ *
+ * Copyright (C) 2008-2009 Telechips 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see the file COPYING, or write
+ * to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef __TCCFB_H
+#define __TCCFB_H
+
+struct tccfb_info {
+	struct fb_info		*fb;
+	struct device		*dev;
+
+	//struct tccfb_mach_info *mach_info;
+
+	/* raw memory addresses */
+	dma_addr_t		map_dma;	/* physical */
+	u_char *		map_cpu;	/* virtual */
+	u_int			map_size;
+
+	/* addresses of pieces placed in raw buffer */
+	u_char *		screen_cpu;	/* virtual address of buffer */
+	dma_addr_t		screen_dma;	/* physical address of buffer */
+
+	u_int			imgch;
+
+};
+
+#define PALETTE_BUFF_CLEAR (0x80000000)	/* entry is clear/invalid */
+
+//int tccfb_init(void);
+
+#endif
Index: linux-2.6.29/include/linux/device.h
===================================================================
--- linux-2.6.29.orig/include/linux/device.h	2010-04-07 12:29:32.000000000 -0400
+++ linux-2.6.29/include/linux/device.h	2010-04-07 12:29:36.000000000 -0400
@@ -404,7 +404,9 @@
 	struct device_dma_parameters *dma_parms;
 
 	struct list_head	dma_pools;	/* dma pools (if dma'ble) */
-
+#ifdef CONFIG_DPM
+        struct constraints  *constraints;
+#endif
 	struct dma_coherent_mem	*dma_mem; /* internal for coherent mem
 					     override */
 	/* arch specific additions */
Index: linux-2.6.29/include/linux/dpm-trace.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/include/linux/dpm-trace.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,63 @@
+/*
+ * include/linux/dpm.h  DPM policy management
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Copyright (C) 2002, International Business Machines Corporation
+ * All Rights Reserved
+ *
+ * Robert Paulsen
+ * IBM Linux Technology Center
+ * rpaulsen@us.ibm.com
+ * August, 2002
+ *
+ */
+
+#ifndef __DPM_TRACE_H_
+#define __DPM_TRACE_H_
+
+#ifdef CONFIG_DPM_TRACE
+
+#define DPM_TRACE_SET_OPT_ASYNC  0x00000001
+#define DPM_TRACE_SET_OPT_SYNC   0x00000002
+#define DPM_TRACE_RESYNC         0x00000004
+#define DPM_TRACE_UNLOCK         0x00000008
+#define DPM_TRACE_SET_OS         0x00000010
+#define DPM_TRACE_SET_POLICY     0x00000020
+#define DPM_TRACE_START          0x00000040
+#define DPM_TRACE_STOP           0x00000080
+#define DPM_TRACE_SET_TASK_STATE 0x00000100
+
+#define DPM_TRACE_ALL            0x000001ff
+
+void dpm_trace(unsigned event, ...);
+void dpm_trace_start(unsigned events);
+void dpm_trace_stop(void);
+void dpm_trace_reset(void);
+
+int
+read_proc_dpm_trace(char *page, char **start, off_t offset, 
+		    int count, int *eof, void *data);
+int 
+write_proc_dpm_trace(struct file *file, const char *buffer,
+		     unsigned long count, void *data);
+
+#else
+
+#define dpm_trace(args...) do {} while (0)
+
+#endif /* CONFIG_DPM_TRACE */
+
+#endif /*__DPM_TRACE_H_*/
Index: linux-2.6.29/include/linux/dpm.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/include/linux/dpm.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,410 @@
+/*
+ * include/linux/dpm.h  DPM policy management
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Copyright (C) 2002, International Business Machines Corporation
+ * All Rights Reserved
+ *
+ * Robert Paulsen
+ * IBM Linux Technology Center
+ * rpaulsen@us.ibm.com
+ * August, 2002
+ *
+ */
+
+#ifndef __DPM_H__
+#define __DPM_H__
+
+#include <linux/device.h>
+
+#define DPM_NO_STATE   -1
+
+#ifndef CONFIG_DPM
+
+/* The above and following constants must always be defined for the
+   benefit of the init task and system tasks, although they are
+   otherwise ignored if DPM is not configured. */
+
+#define DPM_TASK_STATE 0
+#define dpm_set_os(task_state) do {} while (0);
+
+#else /* CONFIG_DPM */
+
+#include <plat/dpm.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/unistd.h>
+#include <linux/notifier.h>
+
+/* max size of DPM names */
+enum {DPM_NAME_SIZE=256};
+
+#include <linux/dpm-trace.h>
+#include <linux/list.h>
+#include <linux/semaphore.h>
+#include <asm/atomic.h>
+
+/* statistics */
+struct dpm_stats {
+        unsigned long count;
+        unsigned long long total_time;
+        unsigned long long start_time;
+};
+
+extern struct dpm_stats dpm_state_stats[DPM_STATES];
+
+/* update statistics structures */
+extern unsigned long long dpm_update_stats(struct dpm_stats *new,
+					   struct dpm_stats *old);
+
+typedef int dpm_state_t;
+typedef int dpm_md_pp_t;
+
+/* A table of processor-dependent routines, must be initialized by
+   platform-dependent boot code.  None of the entries (that will actually be
+   called) are allowed to be NULL if DPM is enabled. */
+
+struct dpm_opt;
+
+struct dpm_md {
+	void	(*init)(void);
+	int	(*init_opt)(struct dpm_opt *opt);
+	int	(*set_opt)(struct dpm_opt *cur, struct dpm_opt *new);
+	int	(*get_opt)(struct dpm_opt *opt);
+	int	(*check_constraint)(struct constraint_param *param,
+				    struct dpm_opt *opt);
+	void	(*idle)(void);
+	void	(*startup)(void);
+	void	(*cleanup)(void);
+};
+	
+
+/*****************************************************************************
+ * Search a list looking for a named entity.
+ * A pointer to the found element is put in the variable named by the
+ * "answer" argument (or it is set to zero if not found).
+ * The structure's type name is given by the "element_type" argument.
+ * The name being looked for is given by the "find_me" argument.
+ * The name of the stand-alone list_head is given by the "list_name" argument.
+ * Assumes the proper semaphore is held.
+ * Assumes the structure's list_head is named "list".
+ * Assumes the structure's name is in a field called "name"
+ *****************************************************************************/
+#define list_find(answer,find_me,list_name,element_type)        \
+        do {                                                    \
+                element_type            *elm;                   \
+                struct list_head        *scan;                  \
+                (answer)=0;                                     \
+                for(scan=list_name.next;scan!=&list_name;       \
+                                scan=scan->next) {              \
+                        elm=list_entry(scan,element_type,list); \
+                        if (strncmp((find_me),elm->name,        \
+                                        DPM_NAME_SIZE)==0) {    \
+                                (answer)=elm;                   \
+                                break;                          \
+                        }                                       \
+                }                                               \
+        } while(0)
+
+/* internal representation of an operating point */
+
+#define DPM_OP_FORCE	0x0001
+#define DPM_OP_NOP	0x0002
+
+struct dpm_opt {
+	char			*name;          /* name */
+	struct list_head	list;		/* all installed op points */
+	dpm_md_pp_t             pp[DPM_PP_NBR]; /* initialization params */
+	struct dpm_md_opt	md_opt;         /* machine dependent part */
+	int			constrained;	/* is this opt constrained? */
+	struct kobject		kobj;		/* kobject */
+	struct dpm_stats        stats;          /* statistics */
+	int			flags;
+};
+
+/* internal representation of a class of op points (to be mapped to an
+ * operating state */
+struct dpm_class {
+	char			*name;          /* name */
+	struct list_head	list;		/* all installed classes */
+	unsigned		nops;		/* nbr ops in this class */
+	struct dpm_opt		**ops;		/* the ops in this class */
+	struct kobject		kobj;		/* kobject */
+	struct dpm_stats        stats;          /* statistics */
+};
+
+/*
+ * temporary support for policies to map operating points to either 
+ * operating pts or classes.  Only one field allowed to be set.
+ */
+
+struct dpm_classopt {
+	struct dpm_opt		*opt;
+	struct dpm_class	*class;
+};
+
+/* internal representation of an installed power policy */
+struct dpm_policy {
+	char			*name;          /* name */
+	struct list_head	list;		/* all installed policies */
+	struct dpm_classopt     classopt[DPM_STATES]; /* classes/op pts */
+	struct kobject		kobj;		/* kobject */
+	struct dpm_stats        stats;          /* statistics */
+};
+
+/*
+ * internal use utility functions for use by DPM
+ */
+
+/* DPM semaphore locking. To simplify future expansion, don't 'down' _dpm_lock
+   directly.  Also, _dpm_lock must be 'up'ed only by dpm_unlock(). */
+
+extern struct semaphore _dpm_lock;
+
+static inline void
+dpm_lock(void)
+{
+        down(&_dpm_lock);
+}
+
+static inline int
+dpm_lock_interruptible(void)
+{
+        if (down_interruptible(&_dpm_lock))
+                return -ERESTARTSYS;
+        return 0;
+}
+
+static inline int
+dpm_trylock(void)
+{
+        if (down_trylock(&_dpm_lock))
+                return -EBUSY;
+        return 0;
+}
+
+void dpm_unlock(void);
+void dpm_idle(void);
+
+/* set operating state */
+void dpm_set_os(dpm_state_t state);
+
+/*
+ * names of DPM stuff for userspace interfaces
+ */
+
+extern char *dpm_state_names[DPM_STATES];
+extern char *dpm_param_names[DPM_PP_NBR];
+
+/* initialize/terminate the DPM */
+int dynamicpower_init(void);
+int dynamicpower_terminate(void);
+
+/* (temporarily) disable the DPM */
+int dynamicpower_disable(void);
+
+/* re-enable the DPM */
+int dynamicpower_enable(void);
+
+/* suspend/resume DPM across a system shutdown */
+int dynamicpm_suspend(void);
+void dynamicpm_resume(void);
+
+/* create operating point */
+int dpm_create_opt(const char *name, const dpm_md_pp_t *pp, int npp);
+
+/* create class of operating points */
+int dpm_create_class(const char *name, char **op_names, unsigned nops);
+
+/* create policy */
+int dpm_create_policy(const char *name, char **opt_names, int nopts);
+int dpm_map_policy_state(struct dpm_policy *policy, int state, char *classopt);
+
+/* destroy policy */
+int dpm_destroy_policy(const char *name);
+
+/* activate a power policy */
+int dpm_set_policy(const char *name);
+
+/* get name of active power policy */
+int dpm_get_policy(char *name);
+
+/* set a raw operating state */
+int dpm_set_op_state(const char *name);
+int dpm_set_opt(struct dpm_opt *opt, unsigned flags);
+
+/* choose unconstrained operating point from policy */
+extern struct dpm_opt *dpm_choose_opt(struct dpm_policy *policy, int state);
+
+
+/* constraints */
+int dpm_check_constraints(struct dpm_opt *opt);
+int dpm_default_check_constraint(struct constraint_param *param, struct dpm_opt *opt);
+int dpm_show_opconstraints(struct dpm_opt *opt, char * buf);
+
+/* driver scale callbacks */
+void dpm_driver_scale(int level, struct dpm_opt *newop);
+void dpm_register_scale(struct notifier_block *nb, int level);
+void dpm_unregister_scale(struct notifier_block *nb, int level);
+
+
+/* utils */
+extern void dpm_udelay(unsigned uS);
+extern void dpm_udelay_from(u64 start, unsigned uS);
+extern unsigned long dpm_compute_lpj(unsigned long ref, u_int div, u_int mult);
+
+/*
+ * sysfs interface
+ */
+
+extern void dpm_sysfs_new_policy(struct dpm_policy *policy);
+extern void dpm_sysfs_destroy_policy(struct dpm_policy *policy);
+extern void dpm_sysfs_new_class(struct dpm_class *class);
+extern void dpm_sysfs_destroy_class(struct dpm_class *class);
+extern void dpm_sysfs_new_op(struct dpm_opt *opt);
+extern void dpm_sysfs_destroy_op(struct dpm_opt *opt);
+
+extern int proc_pid_dpm_read(struct task_struct*,char*);
+
+
+/*
+ * global data for power management system
+ */
+
+/* curently installed policies, classes and operating points */
+extern struct list_head		dpm_policies;
+extern struct list_head		dpm_classes;
+extern struct list_head		dpm_opts;
+extern struct semaphore		dpm_policy_sem;
+extern spinlock_t		dpm_policy_lock;
+
+/* the currently active policy, class, state, point */
+extern struct dpm_policy	*dpm_active_policy;
+extern struct dpm_class		*dpm_active_class;
+extern dpm_state_t		dpm_active_state;
+extern struct dpm_opt		*dpm_active_opt;
+
+/* is DPM initialized and enabled? */
+extern int			dpm_initialized;
+extern int			dpm_enabled;
+
+extern inline void
+dpm_quick_enter_state(int new_state)
+{
+#ifdef CONFIG_DPM_STATS
+	dpm_update_stats(new_state != DPM_NO_STATE ?
+			 &dpm_state_stats[new_state] : NULL,
+			 dpm_active_state != DPM_NO_STATE ?
+			 &dpm_state_stats[dpm_active_state] : NULL);
+#endif
+
+        dpm_active_state = new_state;
+}
+
+/* Flags for dpm_set_opt().  By default, dpm_set_op() is guaranteed not
+   to block the caller, and will arrange to complete asynchronously if
+   necessary. 
+
+   DPM_SYNC    The operating point is guaranteed to be set when the call
+               returns. The call may block.
+
+   DPM_UNLOCK  The caller requires dpm_md_set_opt() to unlock the DPM system
+               once the operating point is set.
+*/
+
+#define DPM_SYNC      0x01
+#define DPM_UNLOCK    0x02
+
+/*
+ * Common machine-dependent and board-dependent function wrappers.
+ */
+
+extern struct dpm_md dpm_md;
+
+static inline void
+dpm_md_startup(void)
+{
+    printk("dpm_md_startup\n");
+        if (dpm_md.startup)
+                dpm_md.startup();
+}
+
+
+static inline void
+dpm_md_cleanup(void)
+{
+        if (dpm_md.cleanup)
+                dpm_md.cleanup();
+}
+
+
+static inline void
+dpm_md_idle(void)
+{
+    printk("dpm_md_idle\n");
+        if (dpm_md.idle)
+                dpm_md.idle();
+}
+
+
+/* Machine-dependent operating point creating/query/setting */
+
+
+static inline int
+dpm_md_init_opt(struct dpm_opt *opt)
+{
+        if (dpm_md.init_opt)
+                return dpm_md.init_opt(opt);
+        return 0;
+}
+
+static inline int
+dpm_md_set_opt(struct dpm_opt *cur, struct dpm_opt *new)
+{
+        if (dpm_md.set_opt) 
+                return dpm_md.set_opt(cur, new);
+        return 0;
+}
+
+static inline int
+dpm_md_get_opt(struct dpm_opt *opt)
+{
+        if (dpm_md.get_opt)
+                return dpm_md.get_opt(opt);
+        return 0;
+}
+
+static inline int
+dpm_md_check_constraint(struct constraint_param *param, struct dpm_opt *opt)
+{
+        return dpm_md.check_constraint ? 
+		dpm_md.check_constraint(param, opt) : 1;
+}
+
+/*
+ * Helper functions
+ */
+
+static inline char *
+dpm_classopt_name(struct dpm_policy *policy, int state)
+{
+	return policy->classopt[state].opt ?
+		policy->classopt[state].opt->name :
+		policy->classopt[state].class->name;
+}
+
+#endif /* CONFIG_DPM */
+#endif /*__DPM_H__*/
Index: linux-2.6.29/include/linux/i2c-dev.h
===================================================================
--- linux-2.6.29.orig/include/linux/i2c-dev.h	2010-04-07 12:29:32.000000000 -0400
+++ linux-2.6.29/include/linux/i2c-dev.h	2010-04-07 12:29:36.000000000 -0400
@@ -50,6 +50,10 @@
 #define I2C_PEC		0x0708	/* != 0 to use PEC with SMBus */
 #define I2C_SMBUS	0x0720	/* SMBus transfer */
 
+/* for TCC DIBCOM module */
+#define I2C_SLAVE_DIBCOM	0x0730	/* DIBCOM DVB-T slave address */
+#define I2C_DIBCOM_WR_RD	0x0731	/* DIBCOM protocol */
+
 
 /* This is the structure as used in the I2C_SMBUS ioctl call */
 struct i2c_smbus_ioctl_data {
Index: linux-2.6.29/include/linux/i2c-id.h
===================================================================
--- linux-2.6.29.orig/include/linux/i2c-id.h	2010-04-07 12:29:32.000000000 -0400
+++ linux-2.6.29/include/linux/i2c-id.h	2010-04-07 13:00:44.000000000 -0400
@@ -72,6 +72,16 @@
 #define I2C_DRIVERID_M52790 	95      /* Mitsubishi M52790SP/FP AV switch */
 #define I2C_DRIVERID_CS5345	96	/* cs5345 audio processor	*/
 
+/*
+ *  @telechips --------------------
+ */
+#define I2C_DRIVERID_MT9D111	100
+#define I2C_DRIVERID_MT9D112	101
+#define I2C_DRIVERID_MT9P111	102
+#define I2C_DRIVERID_MV9317		103
+#define I2C_DRIVERID_S5K4BAFB	104
+
+
 #define I2C_DRIVERID_OV7670 1048	/* Omnivision 7670 camera */
 
 /*
Index: linux-2.6.29/include/linux/i2c.h
===================================================================
--- linux-2.6.29.orig/include/linux/i2c.h	2010-04-07 12:29:32.000000000 -0400
+++ linux-2.6.29/include/linux/i2c.h	2010-04-07 12:29:36.000000000 -0400
@@ -519,6 +519,9 @@
 #define I2C_M_IGNORE_NAK	0x1000	/* if I2C_FUNC_PROTOCOL_MANGLING */
 #define I2C_M_NO_RD_ACK		0x0800	/* if I2C_FUNC_PROTOCOL_MANGLING */
 #define I2C_M_RECV_LEN		0x0400	/* length will be first received byte */
+/* for TCC DIBCOM module */
+#define I2C_M_DIBCOM_MODE	0x0040	/* if slave is DIBCOM DVB-T chip */
+#define I2C_M_DIBCOM_WR_RD	0x0080	/* if write->read operation */
 	__u16 len;		/* msg length				*/
 	__u8 *buf;		/* pointer to msg data			*/
 };
Index: linux-2.6.29/include/linux/mmc/sdio_ids.h
===================================================================
--- linux-2.6.29.orig/include/linux/mmc/sdio_ids.h	2010-04-07 12:29:32.000000000 -0400
+++ linux-2.6.29/include/linux/mmc/sdio_ids.h	2010-04-07 12:29:36.000000000 -0400
@@ -26,4 +26,7 @@
 #define SDIO_VENDOR_ID_MARVELL			0x02df
 #define SDIO_DEVICE_ID_MARVELL_LIBERTAS		0x9103
 
+#define SDIO_VENDOR_ID_CSR		0x032a
+#define SDIO_DEVICE_ID_CSR_DEV	0x0001
+
 #endif
Index: linux-2.6.29/include/linux/pm.h
===================================================================
--- linux-2.6.29.orig/include/linux/pm.h	2010-04-07 12:29:32.000000000 -0400
+++ linux-2.6.29/include/linux/pm.h	2010-04-07 12:29:36.000000000 -0400
@@ -30,6 +30,39 @@
 extern void (*pm_power_off)(void);
 extern void (*pm_power_off_prepare)(void);
 
+#ifdef CONFIG_DPM
+struct device;
+
+struct constraint_param {
+   int id;
+   int min;
+   int max;
+};
+
+#define DPM_CONSTRAINT_PARAMS_MAX 20
+
+struct constraints {
+   int asserted;
+   int count;
+   int violations;
+   struct constraint_param param[DPM_CONSTRAINT_PARAMS_MAX];
+   struct list_head entry;
+};
+
+enum {
+   SCALE_PRECHANGE,
+   SCALE_POSTCHANGE,
+   SCALE_MAX
+};
+
+extern void assert_constraints(struct constraints *);
+extern void deassert_constraints(struct constraints *);
+extern void power_event(char *eventstr);
+extern void device_power_event(struct device * dev, char *eventstr);
+#endif
+
+
+
 /*
  * Device power management
  */
Index: linux-2.6.29/include/linux/sched.h
===================================================================
--- linux-2.6.29.orig/include/linux/sched.h	2010-04-07 12:29:32.000000000 -0400
+++ linux-2.6.29/include/linux/sched.h	2010-04-07 12:29:36.000000000 -0400
@@ -1118,6 +1118,9 @@
 	unsigned int flags;	/* per process flags, defined below */
 	unsigned int ptrace;
 
+    int     dpm_state; /* DPM operating state to use for this task */
+
+
 	int lock_depth;		/* BKL lock depth */
 
 #ifdef CONFIG_SMP
Index: linux-2.6.29/include/linux/serial_core.h
===================================================================
--- linux-2.6.29.orig/include/linux/serial_core.h	2010-04-07 12:29:31.000000000 -0400
+++ linux-2.6.29/include/linux/serial_core.h	2010-04-07 12:29:36.000000000 -0400
@@ -164,6 +164,10 @@
 /* NWPSERIAL */
 #define PORT_NWPSERIAL	85
 
+/* Telechips uart */
+#define PORT_TCC  84 
+
+
 #ifdef __KERNEL__
 
 #include <linux/compiler.h>
Index: linux-2.6.29/include/linux/spi/spi.h
===================================================================
--- linux-2.6.29.orig/include/linux/spi/spi.h	2010-04-07 12:29:31.000000000 -0400
+++ linux-2.6.29/include/linux/spi/spi.h	2010-04-07 12:29:36.000000000 -0400
@@ -266,6 +266,12 @@
 
 	/* called on release() to free memory provided by spi_master */
 	void			(*cleanup)(struct spi_device *spi);
+
+	/* Telechips spi hw open/close */
+	int			(*tcc_open)(struct spi_device *spi);
+	void		(*tcc_close)(struct spi_device *spi);
+	int			tcc_irq_no;
+	u32			tcc_reg_base;
 };
 
 static inline void *spi_master_get_devdata(struct spi_master *master)
@@ -573,6 +579,20 @@
 	return spi->master->transfer(spi, message);
 }
 
+/*
+ * Telechips spi hw open/close
+ */
+static inline int
+spi_tcc_open(struct spi_device *spi)
+{
+	return spi->master->tcc_open(spi);
+}
+static inline void
+spi_tcc_close(struct spi_device *spi)
+{
+	return spi->master->tcc_close(spi);
+}
+
 /*---------------------------------------------------------------------------*/
 
 /* All these synchronous SPI transfer routines are utilities layered
Index: linux-2.6.29/include/linux/spi/tcc_tsif.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/include/linux/spi/tcc_tsif.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,51 @@
+/*
+ * include/linux/spi/tcc_tsif.h
+ *
+ * Author:  <linux@telechips.com>
+ * Created: 1st April, 2009
+ * Description: Driver for Telechips SPI (GPSB) Controllers
+ *              SPI slave mode for DXB TSIF (Transport Stream Interface) modules
+ *
+ * Copyright (c) Telechips, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#ifndef __TCC_TSIF_H__
+#define __TCC_TSIF_H__
+
+/* Select GPSB channel */
+#define TSIF_SPI_NUM 1
+
+#define TSIF_DEV_MAJOR 252
+#define TSIF_DEV_NAME "tcc-tsif"
+
+#define TSIF_PACKET_SIZE 188
+#define PID_MATCH_TABLE_MAX_CNT 32
+
+
+struct tcc_tsif_param {
+    unsigned int ts_total_packet_cnt;
+    unsigned int ts_intr_packet_cnt;
+    unsigned int mode;
+	unsigned int dma_mode;	// DMACTR[MD]: DMA mode register
+#define DMA_NORMAL_MODE		0x00
+#define DMA_MPEG2TS_MODE	0x01
+};
+
+struct tcc_tsif_pid_param {
+    unsigned int pid_data[PID_MATCH_TABLE_MAX_CNT];
+    unsigned int valid_data_cnt;
+};
+
+
+#define IOCTL_TSIF_DMA_START        _IO(TSIF_DEV_MAJOR, 1)
+#define IOCTL_TSIF_DMA_STOP         _IO(TSIF_DEV_MAJOR, 2)
+#define IOCTL_TSIF_GET_MAX_DMA_SIZE _IO(TSIF_DEV_MAJOR, 3)
+#define IOCTL_TSIF_SET_PID          _IO(TSIF_DEV_MAJOR, 4)
+#define IOCTL_TSIF_DXB_POWER		_IO(TSIF_DEV_MAJOR, 5)
+
+
+#endif /*__TCC_TSIF_H__*/
Index: linux-2.6.29/include/linux/tcc_intr.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/include/linux/tcc_intr.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,41 @@
+/*
+ * include/linux/tcc_intr.c 
+ *
+ * Author:  <linux@telechips.com>
+ * Created: 31th March, 2009 
+ * Description: User-level interrupt Driver 
+ *
+ * Copyright (c) Telechips, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *-----------------------------------------------
+ * 1. TCC_INTR_DEV_VIDEO_CODEC
+ *    - dev node: tcc-intr-vc
+ *    - Video Codec interrupt handling
+ * 2. TCC_INTR_DEV_M2M_SCALER
+ *    - dev node: tcc-intr-sc, tcc-intr-sc1
+ *    - Mem-to-Mem scaler 0/1 interrupt handling
+ * 3. TCC_INTR_DEV_BROADCAST
+ *    - dev node: tcc-intr-bc
+ *    - Broadcasting (External Interrupt for DXB) interrupt handling
+ *
+ */
+#ifndef __TCC_INTR_H__
+#define __TCC_INTR_H__
+
+#define TCC_INTR_DEV_MAJOR			246
+#define TCC_INTR_DEV_TEST			"/dev/tcc-intr-test"
+
+#define TCC_INTR_DEV_VIDEO_CODEC	"/dev/tcc-intr-vc"
+#define TCC_INTR_DEV_M2M_SCALER		"/dev/tcc-intr-sc"
+#define TCC_INTR_DEV_M2M_SCALER1	"/dev/tcc-intr-sc1"
+#define TCC_INTR_DEV_BROADCAST		"/dev/tcc-intr-bc"
+
+#define IOCTL_INTR_SET		_IO(TCC_INTR_DEV_MAJOR, 1)
+#define IOCTL_INTR_GET		_IO(TCC_INTR_DEV_MAJOR, 2)
+#define IOCTL_INTR_TEST		_IO(TCC_INTR_DEV_MAJOR, 3)
+
+#endif	/*  __TCC_INTR_H__ */
Index: linux-2.6.29/include/linux/tcc_ioctl.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/include/linux/tcc_ioctl.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,83 @@
+/*
+ * File:        include/linux/tcc_ioctl.h
+ *
+ * Created:     June 10, 2008
+ * Copyright (C) 2008-2009 Telechips <linux@telechips.com>
+ * Description: header file of driver/char/tcc_ioctl.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see the file COPYING, or write
+ * to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef __TCC_IOCTL_H__
+#define __TCC_IOCTL_H__
+
+#include <mach/ioctl_ckcstr.h>
+
+#define MAJOR_NUM 247
+
+#define IOCTL_CKC_SET_PERI          _IO(MAJOR_NUM, 0)
+#define IOCTL_CKC_GET_PERI          _IO(MAJOR_NUM, 1)
+#define IOCTL_CKC_SET_PERIBUS       _IO(MAJOR_NUM, 2)
+#define IOCTL_CKC_GET_PERIBUS       _IO(MAJOR_NUM, 3)
+#define IOCTL_CKC_SET_PERISWRESET   _IO(MAJOR_NUM, 4)
+#define IOCTL_CKC_SET_CPU           _IO(MAJOR_NUM, 5) 
+#define IOCTL_CKC_SET_SMUI2C        _IO(MAJOR_NUM, 6) 
+#define IOCTL_CKC_GET_CPU           _IO(MAJOR_NUM, 7) 
+#define IOCTL_CKC_GET_BUS           _IO(MAJOR_NUM, 8) 
+
+#define IOCTL_CKC_GET_VALIDPLLINFO  _IO(MAJOR_NUM, 9)
+#define IOCTL_CKC_GET_CLOCKINFO     _IO(MAJOR_NUM, 10)
+
+#define IOCTL_CKC_SET_FBUS          _IO(MAJOR_NUM, 11)
+#define IOCTL_CKC_GET_FBUS          _IO(MAJOR_NUM, 12)
+#define IOCTL_CKC_SET_PMUPOWER      _IO(MAJOR_NUM, 13)
+#define IOCTL_CKC_GET_PMUPOWER      _IO(MAJOR_NUM, 14)
+
+#define IOCTL_CKC_SET_CHANGECPU     _IO(MAJOR_NUM, 15)
+#define IOCTL_CKC_SET_CHANGEMEM     _IO(MAJOR_NUM, 16)
+#define IOCTL_CKC_SET_CHANGEFBUS    _IO(MAJOR_NUM, 17)
+
+#define IOCTL_CKC_SET_FBUSSWRESET   _IO(MAJOR_NUM, 18)
+
+#define IOCTL_CKC_SET_DDIPWDN       _IO(MAJOR_NUM, 19)
+#define IOCTL_CKC_GET_DDIPWDN       _IO(MAJOR_NUM, 20)
+
+#define IOCTL_CKC_SET_ETCBLOCK      _IO(MAJOR_NUM, 21)
+
+#define IOCTL_BLK_SETPOWER          _IO(MAJOR_NUM, 22)
+#define IOCTL_BLK_GETPOWER          _IO(MAJOR_NUM, 23)
+
+
+
+struct ckc_ioctl{
+	stckcioctl  in_ckc;
+	stckcinfo   out_ckc;
+};
+
+//AlenOh
+struct storage_direct{
+	void *buf;
+	size_t count;
+	loff_t pos;
+	ssize_t actual;
+	unsigned int user_space;
+};
+ 
+#define IOCTL_STORAGE_DIRECT_READ   _IO(MAJOR_NUM, 100)
+#define IOCTL_STORAGE_DIRECT_WRITE  _IO(MAJOR_NUM, 101)
+#define IOCTL_STORAGE_PING          _IO(MAJOR_NUM, 102)
+
+
+#endif	/* __TCC_IOCTL_H__ */
Index: linux-2.6.29/include/linux/tcc_ll.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/include/linux/tcc_ll.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,53 @@
+
+#ifndef __TCC_LL_H__
+#define __TCC_LL_H__
+
+/* *****************************************
+ * void *: h_pri (private handle)
+ * int   : cmd   (power control command)
+ * *****************************************/
+typedef int (*power_control_t)(void *, int, void *);
+
+typedef struct data_node data_node_t;
+struct data_node {
+    unsigned int id;
+
+    /**** customer data ****/
+    power_control_t callback;
+    void *h_pri;
+    /***********************/
+
+    data_node_t *p_next;
+};
+
+typedef struct list_handle {
+    data_node_t *p_head;
+    data_node_t *p_tail;
+    data_node_t *p_pos;
+    unsigned int node_cnt;
+} list_handle_t;
+
+
+#if 0
+extern int init_ll(list_handle_t *h);
+extern int insert_ll(list_handle_t *h, data_node_t *p_node);
+extern int remove_ll(list_handle_t *h, unsigned int id);
+extern void remove_all_ll(list_handle_t *h);
+extern data_node_t *find_by_id(list_handle_t *h, unsigned int id);
+#endif
+
+#define set_next_node(p_node, p) ((p_node)->p_next = (p))
+#define get_next_node(p) ((p)->p_next)
+#define get_node_id(p) ((p)->id)
+#define get_node_cb(p) ((p)->callback)
+#define get_node_pri(p) ((p)->h_pri)
+
+extern int init_pwm_list(void);
+extern int insert_pwm_node(unsigned int id, power_control_t func, void *h_pri);
+extern int remove_pwm_node(unsigned int id);
+extern int callback_pwm_node(unsigned int id, unsigned int cmd, void *p_info);
+
+
+#endif /* __TCC_LL_H__ */
+
+
Index: linux-2.6.29/include/linux/tcc_pwm_ioctl.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/include/linux/tcc_pwm_ioctl.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,10 @@
+
+#ifndef __TCC_PWM_IOCTL_H__
+#define __TCC_PWM_IOCTL_H__
+
+#define TCC_PWM_DEV_MAJOR			248
+#define IOCTL_PWR_CONTROL		_IO(TCC_PWM_DEV_MAJOR, 1)
+
+#endif /* __TCC_PWM_IOCTL_H__ */
+
+
Index: linux-2.6.29/include/linux/tccfb_ioctl.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/include/linux/tccfb_ioctl.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,308 @@
+/****************************************************************************
+ *   FileName    : tccfb_ioctl.h
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+#ifndef __TCCFB_IOCTL_CODE_H_
+#define __TCCFB_IOCTL_CODE_H_
+
+//
+#define TCC_LCD_FB_IOCTL_DISP_ONOFF				0x10
+/*----------------------------------------------------------------------------------------
+ * [IN ]	unsigned int	[1]		- 0: Off, 1: On
+ *---------------------------------------------------------------------------------------*/
+ 
+
+#define TCC_LCD_FB_IOCTL_ALPHA_ONOFF			0x11
+/*----------------------------------------------------------------------------------------
+ * [IN ]	unsigned int	[1]		- 0: Off, 1: On
+ *---------------------------------------------------------------------------------------*/
+ 
+
+#define TCC_LCD_FB_IOCTL_ALPHA_SET				0x12
+/*----------------------------------------------------------------------------------------
+ * [IN ]	unsigned char	[1]		- Alpah value(0~0xFF)
+ *---------------------------------------------------------------------------------------*/
+ 
+
+#define TCC_LCD_FB_IOCTL_CHROMAKEY_ONOFF		0x13
+/*----------------------------------------------------------------------------------------
+ * [IN ]	unsigned int	[1]		- 0: Off, 1: On
+ *---------------------------------------------------------------------------------------*/
+ 
+
+#define TCC_LCD_FB_IOCTL_CHROMAKEY_SET_VALUE	0x14
+/*----------------------------------------------------------------------------------------
+ * [IN ]	unsigned char	[3]		- [0]: red
+ *									  [1]: green
+ *									  [2]: blue
+ *---------------------------------------------------------------------------------------*/
+
+
+#define TCC_LCD_FB_IOCTL_CHROMAKEY_SET_MASK		0x15
+/*----------------------------------------------------------------------------------------
+ * [IN ]	unsigned char	[3]		- [0]: red
+ *									  [1]: green
+ *									  [2]: blue
+ *---------------------------------------------------------------------------------------*/
+
+#define TCC_LCD_FB_IOCTL_ALPHA_SELECTION		0x16	
+/*----------------------------------------------------------------------------------------
+ * [IN ]	unsigned int	[1]		- 0 : A10 bits and A11 are used as alpha value
+ * 									  1 : Alpha bits in the pixel are used as alpha value.
+ *---------------------------------------------------------------------------------------*/
+
+
+#define TCC_LCD_FB_IOCTL_SET_FORMAT				0x17
+/*----------------------------------------------------------------------------------------
+ * [IN ]	unsigned int	[1]		- Ref to IMGCH_FMT_t Type
+ *---------------------------------------------------------------------------------------*/
+enum {
+	IMGFMT_1BPP		= 0,	// 1bpp indexed color
+	IMGFMT_2BPP		= 1,	// 2bpp indexed color
+	IMGFMT_4BPP		= 2,	// 4bpp indexed color
+	IMGFMT_8BPP		= 3,	// 8bpp indexed color
+	//...
+	IMGFMT_RGB332	= 8,	// RGB332 - 1bytes aligned - R[7:5],G[4:2],B[1:0]
+	IMGFMT_RGB444	= 9,	// RGB444 - 2bytes aligned - A[15:12],R[11:8],G[7:3],B[3:0]
+	IMGFMT_RGB565	= 10,	// RGB565 - 2bytes aligned - R[15:11],G[10:5],B[4:0]
+	IMGFMT_RGB555	= 11,	// RGB555 - 2bytes aligned - A[15],R[14:10],G[9:5],B[4:0]
+	IMGFMT_RGB888	= 12,	// RGB888 - 4bytes aligned - A[31:24],R[23:16],G[15:8],B[7:0]
+	IMGFMT_RGB666	= 13,	// RGB666 - 4bytes aligned - A[23:18],R[17:12],G[11:6],B[5:0]
+	//...
+	IMGFMT_YUV420	= 24,	// YCbCr 4:2:0 Separated format - Not Supported for Image 1 and 2
+	IMGFMT_YUV422	= 25,	// YCbCr 4:2:2 Separated format - Not Supported for Image 1 and 2
+	IMGFMT_YUV422P	= 26,	// YCbCr 4:2:2 Sequential format
+	//...
+	IMGFMT_YUV420I0	= 28,	// YCbCr 4:2:0 interleved type 0 format - Not Supported for Image 1 and 2
+	IMGFMT_YUV420I1	= 29,	// YCbCr 4:2:0 interleved type 1 format - Not Supported for Image 1 and 2
+	IMGFMT_YUV422I0	= 30,	// YCbCr 4:2:2 interleved type 0 format - Not Supported for Image 1 and 2
+	IMGFMT_YUV422I1	= 31,	// YCbCr 4:2:2 interleved type 1 format - Not Supported for Image 1 and 2
+
+} IMGCH_FMT_t;
+/*---------------------------------------------------------------------------------------*/
+
+
+#define TCC_LCD_FB_IOCTL_SET_BASEADDR			0x18
+/*----------------------------------------------------------------------------------------
+ * [IN ]	unsigned int	[3]		- [0]: base0 - IMGx base address. IMG0 Y base address.
+ *									  [1]: base1 -                    IMG0 U base address.
+ *									  [2]: base2 -                    IMG0 V base address. 
+ *---------------------------------------------------------------------------------------*/
+
+
+#define TCC_LCD_FB_IOCTL_GET_BASEADDR			0x19
+/*----------------------------------------------------------------------------------------
+ * [OUT]	unsigned int	[3]		- [0]: base0 - IMGx base address. IMG0 Y base address.
+ *									  [1]: base1 -                    IMG0 U base address.
+ *									  [2]: base2 -                    IMG0 V base address. 
+ *---------------------------------------------------------------------------------------*/
+
+
+#define TCC_LCD_FB_IOCTL_SET_ADDROFFSET			0x1A
+/*----------------------------------------------------------------------------------------
+ * [OUT]	unsigned int	[2]		- [0]: offset0 - Address Offset Y or RGB channel of FIFO(0)
+ *									  [1]: offset1 - Address Offset In U or V channel of FIFO(1,2)
+ *                                                   Invalid for Image1 and Image2
+ *---------------------------------------------------------------------------------------*/
+
+#define TCC_LCD_FB_IOCTL_SET_IMGWINDOW			0x1B
+/*----------------------------------------------------------------------------------------
+ * [IN ]	unsigned int	[4]		- [0]: Image start offset X
+ *									  [1]: Image start offset Y
+ *									  [2]: Image width
+ *									  [3]: Image height
+ *---------------------------------------------------------------------------------------*/
+
+#define TCC_LCD_FB_IOCTL_LCD_ONOFF				0x1C
+/*----------------------------------------------------------------------------------------
+ * [IN ]	unsigned int	[1]		- 0: Off, 1: On
+ *---------------------------------------------------------------------------------------*/
+
+
+
+#define TCC_LCD_FB_IOCTL_SET_R2YCONV_OPTION		0x30
+/*----------------------------------------------------------------------------------------
+ * [IN ]	unsigned int	[2]		- [0]: LCDC Index. (0 - LCDC0, 1 - LCDC1)
+                                    - [1]: Ref to RGB2YUV_CONV_OPTION_t Type
+ *---------------------------------------------------------------------------------------*/
+
+#define TCC_LCD_FB_IOCTL_GET_R2YCONV_OPTION		0x31
+/*----------------------------------------------------------------------------------------
+ * [IN/OUT]	unsigned int	[2]		- (IN ) [0]: LCDC Index. (0 - LCDC0, 1 - LCDC1)
+ *                                  - (OUT) [1]: Ref to RGB2YUV_CONV_OPTION_t Type
+ *---------------------------------------------------------------------------------------*/
+
+enum {
+	R2Y_CONV_OPTION_0 = 0,		// * Y = 0.299*R + 0.587G + 0.114B 
+								// * Cb = -0.172*R - 0.339*G + 0.511*B + 128 
+								// * Cr = 0.511*R - 0.428*G - 0.083*B + 128 
+								// The range for "RGB" is 16 ~ 235, "Studio Color". 
+								// The result is "Studio Color" - Normally SDTV. 
+
+	R2Y_CONV_OPTION_1 = 1,		// * Y = 0.257*R + 0.504*G + 0.098*B + 16 
+								// * Cb = -0.148*R - 0.291*G + 0.439*B + 128 
+								// * Cr = 0.439*R - 0.368*G - 0.071*B + 128 	
+								// The range for "RGB" is 0 ~ 255, "Computer System Color" 
+								// The result is "Studio Color" - Normally SDTV. 
+
+	R2Y_CONV_OPTION_2 = 2,		// * Y = 0.213*R + 0.715*G + 0.072*B 
+								// * Cb = -0.117*R - 0.394*G + 0.511*B + 128 
+								// * Cr = 0.511*R - 0.464*G - 0.047*B + 128 
+								// The range for "RGB" is 16 ~ 235, "Studio Color".. 
+								// The result is "Studio Color" - Normally HDTV. 
+
+	R2Y_CONV_OPTION_3 = 3,		// * Y = 0.183*R + 0.614*G + 0.062*B + 16 
+								// * Cb = -0.101*R - 0.338*G + 0.439*B + 128 
+								// * Cr = 0.439*R - 0.399*G - 0.040*B + 128
+								// The range for "RGB" is 0 ~ 255, "Computer System Color". 
+								// The result is "Studio Color" - Normally HDTV. 
+} RGB2YUV_CONV_OPTION_t;
+
+
+
+#define TCC_LCD_FB_IOCTL_SET_IMG_Y2RCONV_OPTION		0x32
+/*----------------------------------------------------------------------------------------
+ * [IN ]	unsigned int	[1]		- [1]: Ref to YUV2RGB_CONV_OPTION_t Type
+ *---------------------------------------------------------------------------------------*/
+
+#define TCC_LCD_FB_IOCTL_GET_IMG_Y2RCONV_OPTION		0x33
+/*----------------------------------------------------------------------------------------
+ * [OUT]	unsigned int	[1]		- [1]: Ref to YUV2RGB_CONV_OPTION_t Type
+ *---------------------------------------------------------------------------------------*/
+
+enum {
+	Y2R_CONV_OPTION_0 = 0,		// * R = Y + 1.371 * (Cr - 128) 
+								// * G = Y + 0.336 * (Cb - 128) - 0.698 * (Cr - 128) 
+								// * B = Y + 1.732 * (Cb - 128) 
+								// The range for "YCbCr" is 16 ~ 235, "Studio Color". 
+								// The result is "Studio Color" - Normally SDTV. 
+
+	Y2R_CONV_OPTION_1 = 1,		// * R = 1.164 * (Y - 16) + 1.596 * (Cr - 128) 
+								// * G = 1.164 * (Y - 16) - 0.391 * (Cb - 128) - 0.813 * (Cr - 128) 
+								// * B = 1.164 * (Y - 16) + 2.018 * (Cb - 128) 
+								// The range for "YCbCr" is 16 ~ 235, "Studio Color". 
+								// The result is "Computer System Color" - Normally SDTV. 
+
+	Y2R_CONV_OPTION_2 = 2,		// * R = Y + 1.540 * (Cr - 128) 
+								// * G = Y - 0.183 * (Cb - 128) - 0.459 * (Cr - 128) 
+								// * B = Y + 1.816 * (Cb - 128) 
+								// The range for "YCbCr" is 16 ~ 235, "Studio Color". 
+								// The result is "Studio Color" - Normally HDTV.
+
+	Y2R_CONV_OPTION_3 = 3,		// * R = 1.164 * (Y - 16) + 1.793 * (Cr - 128) 
+								// * G = 1.164 * (Y - 16) - 0.213 * (Cb - 128) - 0.534 * (Cr - 128) 
+								// * B = 1.164 * (Y - 16) + 2.115 * (Cb - 128) 
+								// The range for "YCbCr" is 16 ~ 235, "Studio Color". 
+								// The result is "Computer System Color" - Normally HDTV.
+
+} YUV2RGB_CONV_OPTION_t;
+
+
+#define TCC_LCD_FB_IOCTL_SET_COLOR_ENAHNCEMENT	0x20
+/*----------------------------------------------------------------------------------------
+ * [IN ]	unsigned int	[4]		- [0]: LCDC Index. (0 - LCDC0, 1 - LCDC1)
+ *									  [1]: Hue
+ *									  [2]: Brightness
+ *									  [3]: Contrast
+ *---------------------------------------------------------------------------------------*/
+
+#define TCC_LCD_FB_IOCTL_GET_COLOR_ENAHNCEMENT	0x21
+/*----------------------------------------------------------------------------------------
+ * [IN/OUT]	unsigned int	[4]		- (IN ) [0]: LCDC Index. (0 - LCDC0, 1 - LCDC1)
+ *									  (OUT) [1]: Hue
+ *									  (OUT) [2]: Brightness
+ *									  (OUT) [3]: Contrast
+ *---------------------------------------------------------------------------------------*/
+
+#define TCC_LCD_FB_IOCTL_SET_IMAGE_ENAHNCEMENT	0x22
+/*----------------------------------------------------------------------------------------
+ * [IN ]	unsigned int	[3]		- [0]: Hue
+ *									  [1]: Brightness
+ *									  [2]: Contrast
+ *---------------------------------------------------------------------------------------*/
+
+#define TCC_LCD_FB_IOCTL_GET_IMAGE_ENAHNCEMENT	0x23
+/*----------------------------------------------------------------------------------------
+ * [OUT]	unsigned int	[3]		- [0]: Hue
+ *									  [1]: Brightness
+ *									  [2]: Contrast
+ *---------------------------------------------------------------------------------------*/
+
+//	Hue Calibration Register - 2s complement signed value 
+//	* -30 ~ 30 degree 
+//	* 0x80 for -30 degree 
+//	* 0x00 for 0 degree for default value 
+//	* 0x7F for about 30 degree 
+
+//	Brightness Calibration Register - 2s complement signed value 
+//	* -128 ~ 128 value 
+//	* 0x80 for -128 offset 
+//	* 0x00 for 0 offset 
+//	* 0x7F for 127 offset
+
+//	Contrast Calibration Register - 2s complement signed value 
+//	* -4 ~ 4 
+//	* 0x80 for -4.0 value 
+//	* 0xFF for -1.0 value 
+//	* 0x20 for 1.0 value 
+//	* 0x7F for about 4.0 value 
+
+
+#define TCC_LCD_FB_IOCTL_SET_OVP				0x50
+/*----------------------------------------------------------------------------------------
+ * [IN ]	unsigned char	[1]		- [0]: ovp
+ *---------------------------------------------------------------------------------------*/
+
+#define TCC_LCD_FB_IOCTL_SET_M2M				0x51
+/*----------------------------------------------------------------------------------------
+ * [IN ]	unsigned int	[1]		- [0]: 0 - disable, 1 - enable
+ *
+ * !! M2M1 -->(On-the-Fly)-->LCDC1.IMG2
+ *---------------------------------------------------------------------------------------*/
+
+
+//TVOUT Controller IOCTL CODE
+#define TCC_LCD_FB_IOCTL_TVOUT_TYPE             0X60
+/*----------------------------------------------------------------------------------------
+ * [IN ]	unsigned int	[1]		- mode 
+ *---------------------------------------------------------------------------------------*/
+
+#define NTSC_M      0x0000
+#define NTSC_M_J    0x0001
+#define NTSC_N      0x0010
+#define NTSC_N_J    0x0011
+#define NTSC_443    0x0020
+#define PAL_M       0x0100
+#define PAL_N       0x0110
+#define PAL_B       0x0120
+#define PAL_G       0x0130
+#define PAL_H       0x0140
+#define PAL_I       0x0150
+#define PSEUDO_NTSC 0x1000
+#define PSEUDO_PAL  0x1010
+
+#define TCC_LCD_FB_IOCTL_TVOUT_OPEN             0x61
+/*----------------------------------------------------------------------------------------
+ * 
+ *---------------------------------------------------------------------------------------*/
+
+#define TCC_LCD_FB_IOCTL_TVOUT_CLOSE            0x62
+/*----------------------------------------------------------------------------------------
+ * 
+ *---------------------------------------------------------------------------------------*/
+
+#define TCC_LCD_FB_IOCTL_TVOUT_CONNECT_LCDC		0x63
+/*----------------------------------------------------------------------------------------
+ * 
+ *---------------------------------------------------------------------------------------*/
+
+
+#endif //__TCCFB_IOCTL_CODE_H_
+
+
Index: linux-2.6.29/init/initramfs.c
===================================================================
--- linux-2.6.29.orig/init/initramfs.c	2010-04-07 12:29:33.000000000 -0400
+++ linux-2.6.29/init/initramfs.c	2010-04-07 12:29:36.000000000 -0400
@@ -583,6 +583,7 @@
 	if (initrd_start) {
 #ifdef CONFIG_BLK_DEV_RAM
 		int fd;
+        printk(KERN_INFO "initrd_start:0x%lx, initrd_end:0x%lx\n", initrd_start, initrd_end);
 		printk(KERN_INFO "checking if image is initramfs...");
 		err = unpack_to_rootfs((char *)initrd_start,
 			initrd_end - initrd_start, 1);
Index: linux-2.6.29/initrd_tcc_mkrd.sh
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/initrd_tcc_mkrd.sh	2010-04-07 13:00:58.000000000 -0400
@@ -0,0 +1,31 @@
+#=======================================================================================
+#	FileName    : tcc_mkrd.sh
+#	Description : Make linux.rom
+#                 Mark linux.rom with CRC & ramdisk size
+#=======================================================================================
+#
+#	TCC Board Support Package
+#	Copyright (c) Telechips, Inc.
+#	ALL RIGHTS RESERVED
+#
+#=======================================================================================
+
+echo "======================================================"
+K_SIZE=4M
+if test $1; then
+    K_SIZE=$1;
+fi
+
+echo "dd if=arch/arm/boot/Image of=Img bs=$K_SIZE conv=sync"
+
+dd if=arch/arm/boot/Image of=Img bs=$K_SIZE conv=sync
+cat Img ../ramdisk/initrd_1.5M.rom > linux.img
+
+../../util/tcc_crc/tcc_crc -o linux.rom -v 1700 linux.img
+
+rm -f Img
+rm -f linux.img
+
+echo "======================================================"
+exit
+
Index: linux-2.6.29/sound/soc/Makefile
===================================================================
--- linux-2.6.29.orig/sound/soc/Makefile	2010-04-07 12:29:31.000000000 -0400
+++ linux-2.6.29/sound/soc/Makefile	2010-04-07 12:29:36.000000000 -0400
@@ -10,4 +10,5 @@
 obj-$(CONFIG_SND_SOC)	+= omap/
 obj-$(CONFIG_SND_SOC)	+= pxa/
 obj-$(CONFIG_SND_SOC)	+= s3c24xx/
+obj-$(CONFIG_SND_SOC)	+= tcc/
 obj-$(CONFIG_SND_SOC)	+= sh/
Index: linux-2.6.29/sound/soc/codecs/Kconfig
===================================================================
--- linux-2.6.29.orig/sound/soc/codecs/Kconfig	2010-04-07 12:29:31.000000000 -0400
+++ linux-2.6.29/sound/soc/codecs/Kconfig	2010-04-07 13:00:44.000000000 -0400
@@ -123,6 +123,9 @@
 config SND_SOC_WM8728
 	tristate
 
+config SND_SOC_WM8581
+	tristate
+
 config SND_SOC_WM8731
 	tristate
 
Index: linux-2.6.29/sound/soc/codecs/Makefile
===================================================================
--- linux-2.6.29.orig/sound/soc/codecs/Makefile	2010-04-07 12:29:31.000000000 -0400
+++ linux-2.6.29/sound/soc/codecs/Makefile	2010-04-07 13:00:44.000000000 -0400
@@ -15,6 +15,7 @@
 snd-soc-wm8350-objs := wm8350.o
 snd-soc-wm8510-objs := wm8510.o
 snd-soc-wm8580-objs := wm8580.o
+snd-soc-wm8581-objs := wm8581.o
 snd-soc-wm8728-objs := wm8728.o
 snd-soc-wm8731-objs := wm8731.o
 snd-soc-wm8750-objs := wm8750.o
@@ -42,6 +43,7 @@
 obj-$(CONFIG_SND_SOC_UDA1380)	+= snd-soc-uda1380.o
 obj-$(CONFIG_SND_SOC_WM8350)	+= snd-soc-wm8350.o
 obj-$(CONFIG_SND_SOC_WM8510)	+= snd-soc-wm8510.o
+obj-$(CONFIG_SND_SOC_WM8581)	+= snd-soc-wm8581.o
 obj-$(CONFIG_SND_SOC_WM8580)	+= snd-soc-wm8580.o
 obj-$(CONFIG_SND_SOC_WM8728)	+= snd-soc-wm8728.o
 obj-$(CONFIG_SND_SOC_WM8731)	+= snd-soc-wm8731.o
Index: linux-2.6.29/sound/soc/codecs/wm8581.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/sound/soc/codecs/wm8581.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,1296 @@
+/*
+ * wm8581.c  --  WM8581 ALSA Soc Audio driver
+ *
+ * Copyright 2008 Wolfson Microelectronics PLC.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ * Notes:
+ *  The WM8581 is a multichannel codec with S/PDIF support, featuring six
+ *  DAC channels and two ADC channels.
+ *
+ *  Currently only the primary audio interface is supported - S/PDIF and
+ *  the secondary audio interfaces are not.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/tlv.h>
+#include <sound/initval.h>
+#include <asm/div64.h>
+
+#include "wm8581.h"
+
+#define WM8581_VERSION "0.1"
+
+struct pll_state {
+	unsigned int in;
+	unsigned int out;
+};
+
+/* codec private data */
+struct wm8581_priv {
+	struct pll_state a;
+	struct pll_state b;
+};
+
+/* WM8581 register space */
+#define WM8581_PLLA1                         0x00
+#define WM8581_PLLA2                         0x01
+#define WM8581_PLLA3                         0x02
+#define WM8581_PLLA4                         0x03
+#define WM8581_PLLB1                         0x04
+#define WM8581_PLLB2                         0x05
+#define WM8581_PLLB3                         0x06
+#define WM8581_PLLB4                         0x07
+#define WM8581_CLKSEL                        0x08
+#define WM8581_PAIF1                         0x09
+#define WM8581_PAIF2                         0x0A
+#define WM8581_SAIF1                         0x0B
+#define WM8581_PAIF3                         0x0C
+#define WM8581_PAIF4                         0x0D
+#define WM8581_SAIF2                         0x0E
+#define WM8581_DAC_CONTROL1                  0x0F
+#define WM8581_DAC_CONTROL2                  0x10
+#define WM8581_DAC_CONTROL3                  0x11
+#define WM8581_DAC_CONTROL4                  0x12
+#define WM8581_DAC_CONTROL5                  0x13
+#define WM8581_DIGITAL_ATTENUATION_DACL1     0x14
+#define WM8581_DIGITAL_ATTENUATION_DACR1     0x15
+#define WM8581_DIGITAL_ATTENUATION_DACL2     0x16
+#define WM8581_DIGITAL_ATTENUATION_DACR2     0x17
+#define WM8581_DIGITAL_ATTENUATION_DACL3     0x18
+#define WM8581_DIGITAL_ATTENUATION_DACR3     0x19
+#define WM8581_DIGITAL_ATTENUATION_DACL4     0x1A
+#define WM8581_DIGITAL_ATTENUATION_DACR4     0x1B
+#define WM8581_MASTER_DIGITAL_ATTENUATION    0x1C
+#define WM8581_ADC_CONTROL1                  0x1D
+#define WM8581_SPDTXCHAN0                    0x1E
+#define WM8581_SPDTXCHAN1                    0x1F
+#define WM8581_SPDTXCHAN2                    0x20
+#define WM8581_SPDTXCHAN3                    0x21
+#define WM8581_SPDTXCHAN4                    0x22
+#define WM8581_SPDTXCHAN5                    0x23
+#define WM8581_SPDMODE                       0x24
+#define WM8581_INTMASK                       0x25
+#define WM8581_GPO1                          0x26
+#define WM8581_GPO2                          0x27
+#define WM8581_GPO3                          0x28
+#define WM8581_GPO4                          0x29
+#define WM8581_GPO5                          0x2A
+#define WM8581_INTSTAT                       0x2B
+#define WM8581_SPDRXCHAN1                    0x2C
+#define WM8581_SPDRXCHAN2                    0x2D
+#define WM8581_SPDRXCHAN3                    0x2E
+#define WM8581_SPDRXCHAN4                    0x2F
+#define WM8581_SPDRXCHAN5                    0x30
+#define WM8581_SPDSTAT                       0x31
+#define WM8581_PWRDN1                        0x32
+#define WM8581_PWRDN2                        0x33
+#define WM8581_READBACK                      0x34
+#define WM8581_RESET                         0x35
+
+/* PLLB4 (register 7h) */
+#define WM8581_PLLB4_MCLKOUTSRC_MASK   0x60
+#define WM8581_PLLB4_MCLKOUTSRC_PLLA   0x20
+#define WM8581_PLLB4_MCLKOUTSRC_PLLB   0x40
+#define WM8581_PLLB4_MCLKOUTSRC_OSC    0x60
+
+#define WM8581_PLLB4_CLKOUTSRC_MASK    0x180
+#define WM8581_PLLB4_CLKOUTSRC_PLLACLK 0x080
+#define WM8581_PLLB4_CLKOUTSRC_PLLBCLK 0x100
+#define WM8581_PLLB4_CLKOUTSRC_OSCCLK  0x180
+
+/* CLKSEL (register 8h) */
+#define WM8581_CLKSEL_DAC_CLKSEL_MASK 0x03
+#define WM8581_CLKSEL_DAC_CLKSEL_PLLA 0x01
+#define WM8581_CLKSEL_DAC_CLKSEL_PLLB 0x02
+
+/* AIF control 1 (registers 9h-bh) */
+#define WM8581_AIF_RATE_MASK       0x7
+#define WM8581_AIF_RATE_128        0x0
+#define WM8581_AIF_RATE_192        0x1
+#define WM8581_AIF_RATE_256        0x2
+#define WM8581_AIF_RATE_384        0x3
+#define WM8581_AIF_RATE_512        0x4
+#define WM8581_AIF_RATE_768        0x5
+#define WM8581_AIF_RATE_1152       0x6
+
+#define WM8581_AIF_BCLKSEL_MASK   0x18
+#define WM8581_AIF_BCLKSEL_64     0x00
+#define WM8581_AIF_BCLKSEL_128    0x08
+#define WM8581_AIF_BCLKSEL_256    0x10
+#define WM8581_AIF_BCLKSEL_SYSCLK 0x18
+
+#define WM8581_AIF_MS             0x20
+
+#define WM8581_AIF_CLKSRC_MASK    0xc0
+#define WM8581_AIF_CLKSRC_PLLA    0x40
+#define WM8581_AIF_CLKSRC_PLLB    0x40
+#define WM8581_AIF_CLKSRC_MCLK    0xc0
+
+/* AIF control 2 (registers ch-eh) */
+#define WM8581_AIF_FMT_MASK    0x03
+#define WM8581_AIF_FMT_RIGHTJ  0x00
+#define WM8581_AIF_FMT_LEFTJ   0x01
+#define WM8581_AIF_FMT_I2S     0x02
+#define WM8581_AIF_FMT_DSP     0x03
+
+#define WM8581_AIF_LENGTH_MASK   0x0c
+#define WM8581_AIF_LENGTH_16     0x00
+#define WM8581_AIF_LENGTH_20     0x04
+#define WM8581_AIF_LENGTH_24     0x08
+#define WM8581_AIF_LENGTH_32     0x0c
+
+#define WM8581_AIF_LRP         0x10
+#define WM8581_AIF_BCP         0x20
+
+/* Powerdown Register 1 (register 32h) */
+#define WM8581_PWRDN1_PWDN     0x001
+#define WM8581_PWRDN1_ALLDACPD 0x040
+
+/* Powerdown Register 2 (register 33h) */
+#define WM8581_PWRDN2_OSSCPD   0x001
+#define WM8581_PWRDN2_PLLAPD   0x002
+#define WM8581_PWRDN2_PLLBPD   0x004
+#define WM8581_PWRDN2_SPDIFPD  0x008
+#define WM8581_PWRDN2_SPDIFTXD 0x010
+#define WM8581_PWRDN2_SPDIFRXD 0x020
+
+#define WM8581_DAC_CONTROL5_MUTEALL 0x10
+
+/*
+ * wm8581 register cache
+ * We can't read the WM8581 register space when we
+ * are using 2 wire for device control, so we cache them instead.
+ */
+static const u16 wm8581_reg[] = {
+	0x0121, 0x017e, 0x007d, 0x0014, /*R3*/
+	0x0121, 0x017e, 0x007d, 0x0194, /*R7*/
+	0x001c, 0x0002, 0x0002, 0x00c2, /*R11*/
+	//0x0182, 0x0082, 0x000a, 0x0024, /*R15*/
+	0x0182, 0x0082, 0x000a, 0x00E4, /*R15*/
+	0x0009, 0x0000, 0x00ff, 0x0000, /*R19*/
+	0x00c8, 0x00c8, 0x00c8, 0x00c8, /*R23*/
+	0x00c8, 0x00c8, 0x00c8, 0x00c8, /*R27*/
+	0x01c8, 0x0040, 0x0000, 0x0000, /*R31(0x1F)*/
+	0x0000, 0x0000, 0x0031, 0x000b, /*R35*/
+	0x0039, 0x0000, 0x0010, 0x0032, /*R39*/
+	0x0054, 0x0076, 0x0098, 0x0000, /*R43(0x2B)*/
+	0x0000, 0x0000, 0x0000, 0x0000, /*R47*/
+	//0x0000, 0x0000, 0x005e, 0x003e, /*R51(0x33)*/
+	0x0000, 0x0000, 0x0002, 0x0000, /*R51(0x33)*/
+	0x0000, 0x0000 /*R53*/
+};
+
+/*
+ * read wm8581 register cache
+ */
+static inline unsigned int wm8581_read_reg_cache(struct snd_soc_codec *codec,
+	unsigned int reg)
+{
+	u16 *cache = codec->reg_cache;
+	BUG_ON(reg > ARRAY_SIZE(wm8581_reg));
+	return cache[reg];
+}
+
+/*
+ * write wm8581 register cache
+ */
+static inline void wm8581_write_reg_cache(struct snd_soc_codec *codec,
+	unsigned int reg, unsigned int value)
+{
+	u16 *cache = codec->reg_cache;
+
+	cache[reg] = value;
+}
+
+
+#if 0
+static void print_reg(unsigned int reg, unsigned int val)
+{
+    switch (reg) {
+    case 0x00:
+        printk("PLLA1  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x01:
+        printk("PLLA2  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x02:
+        printk("PLLA3  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x03:
+        printk("PLLA4  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x04:
+        printk("PLLB1  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x05:
+        printk("PLLB2  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x06:
+        printk("PLLB3  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x07:
+        printk("PLLB4  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x08:
+        printk("CLKSEL  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x09:
+        printk("PAIF1  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x0A:
+        printk("PAIF2  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x0B:
+        printk("SAIF1  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x0C:
+        printk("PAIF3  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x0D:
+        printk("PAIF4  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x0E:
+        printk("SAIF2  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x0F:
+        printk("DAC_CONTROL1  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x10:
+        printk("DAC_CONTROL2  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x11:
+        printk("DAC_CONTROL3  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x12:
+        printk("DAC_CONTROL4  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x13:
+        printk("DAC_CONTROL5  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x14:
+        printk("DIGITAL_ATTENUATION_DACL1  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x15:
+        printk("DIGITAL_ATTENUATION_DACR1  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x16:
+        printk("DIGITAL_ATTENUATION_DACL2  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x17:
+        printk("DIGITAL_ATTENUATION_DACR2  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x18:
+        printk("DIGITAL_ATTENUATION_DACL3  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x19:
+        printk("DIGITAL_ATTENUATION_DACR3  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x1C:
+        printk("MASTER_DIGITAL_ATTENUATION  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x1D:
+        printk("ADC_CONTROL1  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x1E:
+        printk("SPDTXCHAN0  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x1F:
+        printk("SPDTXCHAN1  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x20:
+        printk("SPDTXCHAN2  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x21:
+        printk("SPDTXCHAN3  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x22:
+        printk("SPDTXCHAN4  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x23:
+        printk("SPDTXCHAN5  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x24:
+        printk("SPDMODE  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x25:
+        printk("INTMASK  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x26:
+        printk("GPO1  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x27:
+        printk("GPO2  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x28:
+        printk("GPO3  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x29:
+        printk("GPO4  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x2A:
+        printk("GPO5  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x2B:
+        printk("INTSTAT  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x2C:
+        printk("SPDRXCHAN1  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x2D:
+        printk("SPDRXCHAN2  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x2E:
+        printk("SPDRXCHAN3  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x2F:
+        printk("SPDRXCHAN4  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x30:
+        printk("SPDRXCHAN5  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x31:
+        printk("SPDSTAT  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x32:
+        printk("PWRDN1  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x33:
+        printk("PWRDN2  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x34:
+        printk("READBACK  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    case 0x35:
+        printk("RESET  reg[0x%X], val[0x%X]\n", reg, val);
+        break;
+    }
+}
+#endif
+
+
+/*
+ * write to the WM8581 register space
+ */
+static int wm8581_write(struct snd_soc_codec *codec, unsigned int reg,
+	unsigned int value)
+{
+	u8 data[2];
+
+	BUG_ON(reg > ARRAY_SIZE(wm8581_reg));
+
+	/* Registers are 9 bits wide */
+	value &= 0x1ff;
+
+	switch (reg) {
+	case WM8581_RESET:
+		/* Uncached */
+		break;
+#if 0
+	default:
+		if (value == wm8581_read_reg_cache(codec, reg))
+			return 0;
+#endif
+	}
+
+	/* data is
+	 *   D15..D9 WM8581 register offset
+	 *   D8...D0 register data
+	 */
+	data[0] = (reg << 1) | ((value >> 8) & 0x0001);
+	data[1] = value & 0x00ff;
+
+	wm8581_write_reg_cache(codec, reg, value);
+
+    //print_reg(reg, value);
+
+	if (codec->hw_write(codec->control_data, data, 2) == 2)
+		return 0;
+	else
+		return -EIO;
+}
+
+static inline unsigned int wm8581_read(struct snd_soc_codec *codec,
+				       unsigned int reg)
+{
+	switch (reg) {
+	default:
+		return wm8581_read_reg_cache(codec, reg);
+	}
+}
+
+static const DECLARE_TLV_DB_SCALE(dac_tlv, -12750, 50, 1);
+
+static int wm8581_out_vu(struct snd_kcontrol *kcontrol,
+			 struct snd_ctl_elem_value *ucontrol)
+{
+#if 0
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int reg2 = (kcontrol->private_value >> 24) & 0xff;
+	int ret;
+	u16 val;
+
+	/* Clear the register cache so we write without VU set */
+	wm8581_write_reg_cache(codec, reg, 0);
+	wm8581_write_reg_cache(codec, reg2, 0);
+
+	ret = snd_soc_put_volsw_2r(kcontrol, ucontrol);
+	if (ret < 0)
+		return ret;
+
+	/* Now write again with the volume update bit set */
+	val = wm8581_read_reg_cache(codec, reg);
+	wm8581_write(codec, reg, val | 0x0100);
+
+	val = wm8581_read_reg_cache(codec, reg2);
+	wm8581_write(codec, reg2, val | 0x0100);
+#else
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	unsigned int reg = mc->reg;
+	unsigned int reg2 = mc->rreg;
+	int ret;
+	unsigned short val;
+
+	/* Clear the register cache so we write without VU set */
+	wm8581_write_reg_cache(codec, reg, 0);
+	wm8581_write_reg_cache(codec, reg2, 0);
+
+	ret = snd_soc_put_volsw_2r(kcontrol, ucontrol);
+	if (ret < 0)
+		return ret;
+
+	/* Now write again with the volume update bit set */
+	val = wm8581_read_reg_cache(codec, reg);
+	wm8581_write(codec, reg, val | 0x0100);
+
+	val = wm8581_read_reg_cache(codec, reg2);
+	wm8581_write(codec, reg2, val | 0x0100);
+#endif
+
+	return 0;
+}
+
+#if 0
+#define SOC_WM8581_OUT_DOUBLE_R_TLV(xname, reg_left, reg_right, shift, max, invert, tlv_array) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \
+	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\
+		SNDRV_CTL_ELEM_ACCESS_READWRITE,  \
+	.tlv.p = (tlv_array), \
+	.info = snd_soc_info_volsw_2r, \
+	.get = snd_soc_get_volsw_2r, .put = wm8581_out_vu, \
+	.private_value = (reg_left) | ((shift) << 8)  |		\
+		((max) << 12) | ((invert) << 20) | ((reg_right) << 24) }
+#else
+#define SOC_WM8581_OUT_DOUBLE_R_TLV(xname, reg_left, reg_right, xshift, xmax, xinvert, tlv_array) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),\
+	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\
+		 SNDRV_CTL_ELEM_ACCESS_READWRITE,\
+	.tlv.p = (tlv_array), \
+	.info = snd_soc_info_volsw_2r, \
+	.get = snd_soc_get_volsw_2r, .put = wm8581_out_vu, \
+	.private_value = (unsigned long)&(struct soc_mixer_control) \
+		{.reg = reg_left, .rreg = reg_right, .shift = xshift, \
+		.max = xmax, .invert = xinvert} }
+#endif
+
+static const struct snd_kcontrol_new wm8581_snd_controls[] = {
+#if 1
+SOC_WM8581_OUT_DOUBLE_R_TLV("DAC1 Playback Volume",
+			    WM8581_DIGITAL_ATTENUATION_DACL1,
+			    WM8581_DIGITAL_ATTENUATION_DACR1,
+			    0, 0xff, 0, dac_tlv),
+SOC_WM8581_OUT_DOUBLE_R_TLV("DAC2 Playback Volume",
+			    WM8581_DIGITAL_ATTENUATION_DACL2,
+			    WM8581_DIGITAL_ATTENUATION_DACR2,
+			    0, 0xff, 0, dac_tlv),
+SOC_WM8581_OUT_DOUBLE_R_TLV("DAC3 Playback Volume",
+			    WM8581_DIGITAL_ATTENUATION_DACL3,
+			    WM8581_DIGITAL_ATTENUATION_DACR3,
+			    0, 0xff, 0, dac_tlv),
+SOC_WM8581_OUT_DOUBLE_R_TLV("DAC4 Playback Volume",
+			    WM8581_DIGITAL_ATTENUATION_DACL4,
+			    WM8581_DIGITAL_ATTENUATION_DACR4,
+			    0, 0xff, 0, dac_tlv),
+#else
+SOC_SINGLE_TLV("DAC Master Volume", WM8581_MASTER_DIGITAL_ATTENUATION, 0, 0xFF, 0, dac_tlv),
+
+SOC_DOUBLE_R_TLV("DAC1 Playback Volume", WM8581_DIGITAL_ATTENUATION_DACL1, WM8581_DIGITAL_ATTENUATION_DACR1, 0, 0xFF, 0, dac_tlv),
+SOC_DOUBLE_R_TLV("DAC2 Playback Volume", WM8581_DIGITAL_ATTENUATION_DACL2, WM8581_DIGITAL_ATTENUATION_DACR2, 0, 0xFF, 0, dac_tlv),
+SOC_DOUBLE_R_TLV("DAC3 Playback Volume", WM8581_DIGITAL_ATTENUATION_DACL3, WM8581_DIGITAL_ATTENUATION_DACR3, 0, 0xFF, 0, dac_tlv),
+SOC_DOUBLE_R_TLV("DAC4 Playback Volume", WM8581_DIGITAL_ATTENUATION_DACL4, WM8581_DIGITAL_ATTENUATION_DACR4, 0, 0xFF, 0, dac_tlv),
+#endif
+
+SOC_SINGLE("DAC1 Deemphasis Switch", WM8581_DAC_CONTROL3, 0, 1, 0),
+SOC_SINGLE("DAC2 Deemphasis Switch", WM8581_DAC_CONTROL3, 1, 1, 0),
+SOC_SINGLE("DAC3 Deemphasis Switch", WM8581_DAC_CONTROL3, 2, 1, 0),
+SOC_SINGLE("DAC4 Deemphasis Switch", WM8581_DAC_CONTROL3, 3, 1, 0),
+
+SOC_DOUBLE("DAC1 Invert Switch", WM8581_DAC_CONTROL4,  0, 1, 1, 0),
+SOC_DOUBLE("DAC2 Invert Switch", WM8581_DAC_CONTROL4,  2, 3, 1, 0),
+SOC_DOUBLE("DAC3 Invert Switch", WM8581_DAC_CONTROL4,  4, 5, 1, 0),
+SOC_DOUBLE("DAC4 Invert Switch", WM8581_DAC_CONTROL4,  6, 7, 1, 0),
+
+SOC_SINGLE("DAC ZC Switch", WM8581_DAC_CONTROL5, 5, 1, 0),
+SOC_SINGLE("DAC1 Switch", WM8581_DAC_CONTROL5, 0, 1, 0),
+SOC_SINGLE("DAC2 Switch", WM8581_DAC_CONTROL5, 1, 1, 0),
+SOC_SINGLE("DAC3 Switch", WM8581_DAC_CONTROL5, 2, 1, 0),
+SOC_SINGLE("DAC4 Switch", WM8581_DAC_CONTROL5, 3, 1, 0),
+
+SOC_DOUBLE("ADC Mute Switch", WM8581_ADC_CONTROL1, 0, 1, 1, 0),
+SOC_SINGLE("ADC High-Pass Filter Switch", WM8581_ADC_CONTROL1, 4, 1, 0),
+};
+
+/* Add non-DAPM controls */
+static int wm8581_add_controls(struct snd_soc_codec *codec)
+{
+	int err, i;
+
+	for (i = 0; i < ARRAY_SIZE(wm8581_snd_controls); i++) {
+		err = snd_ctl_add(codec->card,
+				  snd_soc_cnew(&wm8581_snd_controls[i],
+					       codec, NULL));
+		if (err < 0)
+			return err;
+	}
+	return 0;
+}
+static const struct snd_soc_dapm_widget wm8581_dapm_widgets[] = {
+SND_SOC_DAPM_DAC("DAC1", "Playback", WM8581_PWRDN1, 2, 1),
+SND_SOC_DAPM_DAC("DAC2", "Playback", WM8581_PWRDN1, 3, 1),
+SND_SOC_DAPM_DAC("DAC3", "Playback", WM8581_PWRDN1, 4, 1),
+SND_SOC_DAPM_DAC("DAC4", "Playback", WM8581_PWRDN1, 5, 1),
+
+SND_SOC_DAPM_OUTPUT("VOUT1L"),
+SND_SOC_DAPM_OUTPUT("VOUT1R"),
+SND_SOC_DAPM_OUTPUT("VOUT2L"),
+SND_SOC_DAPM_OUTPUT("VOUT2R"),
+SND_SOC_DAPM_OUTPUT("VOUT3L"),
+SND_SOC_DAPM_OUTPUT("VOUT3R"),
+SND_SOC_DAPM_OUTPUT("VOUT4L"),
+SND_SOC_DAPM_OUTPUT("VOUT4R"),
+
+SND_SOC_DAPM_ADC("ADC", "Capture", WM8581_PWRDN1, 1, 1),
+
+SND_SOC_DAPM_INPUT("AINL"),
+SND_SOC_DAPM_INPUT("AINR"),
+};
+
+static const struct snd_soc_dapm_route audio_map[] = {
+	{ "VOUT1L", NULL, "DAC1" },
+	{ "VOUT1R", NULL, "DAC1" },
+
+	{ "VOUT2L", NULL, "DAC2" },
+	{ "VOUT2R", NULL, "DAC2" },
+
+	{ "VOUT3L", NULL, "DAC3" },
+	{ "VOUT3R", NULL, "DAC3" },
+
+	{ "VOUT4L", NULL, "DAC4" },
+	{ "VOUT4R", NULL, "DAC4" },
+
+	{ "ADC", NULL, "AINL" },
+	{ "ADC", NULL, "AINR" },
+};
+
+static int wm8581_add_widgets(struct snd_soc_codec *codec)
+{
+	snd_soc_dapm_new_controls(codec, wm8581_dapm_widgets,
+				  ARRAY_SIZE(wm8581_dapm_widgets));
+
+	snd_soc_dapm_add_routes(codec, audio_map, ARRAY_SIZE(audio_map));
+
+	snd_soc_dapm_new_widgets(codec);
+	return 0;
+}
+
+/* PLL divisors */
+struct _pll_div {
+	u32 prescale:1;
+	u32 postscale:1;
+	u32 freqmode:2;
+	u32 n:4;
+	u32 k:24;
+};
+
+/* The size in bits of the pll divide */
+#define FIXED_PLL_SIZE (1 << 22)
+
+/* PLL rate to output rate divisions */
+static struct {
+	unsigned int div;
+	unsigned int freqmode;
+	unsigned int postscale;
+} post_table[] = {
+	{  2,  0, 0 },
+	{  4,  0, 1 },
+	{  4,  1, 0 },
+	{  8,  1, 1 },
+	{  8,  2, 0 },
+	{ 16,  2, 1 },
+	{ 12,  3, 0 },
+	{ 24,  3, 1 }
+};
+
+static int pll_factors(struct _pll_div *pll_div, unsigned int target,
+		       unsigned int source)
+{
+	u64 Kpart;
+	unsigned int K, Ndiv, Nmod;
+	int i;
+
+	pr_debug("wm8581: PLL %dHz->%dHz\n", source, target);
+
+	/* Scale the output frequency up; the PLL should run in the
+	 * region of 90-100MHz.
+	 */
+	for (i = 0; i < ARRAY_SIZE(post_table); i++) {
+		if (target * post_table[i].div >=  90000000 &&
+		    target * post_table[i].div <= 100000000) {
+			pll_div->freqmode = post_table[i].freqmode;
+			pll_div->postscale = post_table[i].postscale;
+			target *= post_table[i].div;
+			break;
+		}
+	}
+
+	if (i == ARRAY_SIZE(post_table)) {
+		printk(KERN_ERR "wm8581: Unable to scale output frequency "
+		       "%u\n", target);
+		return -EINVAL;
+	}
+
+	Ndiv = target / source;
+
+	if (Ndiv < 5) {
+		source /= 2;
+		pll_div->prescale = 1;
+		Ndiv = target / source;
+	} else
+		pll_div->prescale = 0;
+
+	if ((Ndiv < 5) || (Ndiv > 13)) {
+		printk(KERN_ERR
+			"WM8581 N=%d outside supported range\n", Ndiv);
+		return -EINVAL;
+	}
+
+	pll_div->n = Ndiv;
+	Nmod = target % source;
+	Kpart = FIXED_PLL_SIZE * (long long)Nmod;
+
+	do_div(Kpart, source);
+
+	K = Kpart & 0xFFFFFFFF;
+
+	pll_div->k = K;
+
+	pr_debug("PLL %x.%x prescale %d freqmode %d postscale %d\n",
+		 pll_div->n, pll_div->k, pll_div->prescale, pll_div->freqmode,
+		 pll_div->postscale);
+
+	return 0;
+}
+
+static int wm8581_set_dai_pll(struct snd_soc_dai *codec_dai,
+		int pll_id, unsigned int freq_in, unsigned int freq_out)
+{
+	int offset;
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct wm8581_priv *wm8581 = codec->private_data;
+	struct pll_state *state;
+	struct _pll_div pll_div;
+	unsigned int reg;
+	unsigned int pwr_mask;
+	int ret;
+
+	/* GCC isn't able to work out the ifs below for initialising/using
+	 * pll_div so suppress warnings.
+	 */
+	memset(&pll_div, 0, sizeof(pll_div));
+
+	switch (pll_id) {
+	case WM8581_PLLA:
+		state = &wm8581->a;
+		offset = 0;
+		pwr_mask = WM8581_PWRDN2_PLLAPD;
+		break;
+	case WM8581_PLLB:
+		state = &wm8581->b;
+		offset = 4;
+		pwr_mask = WM8581_PWRDN2_PLLBPD;
+		break;
+	default:
+		return -ENODEV;
+	}
+
+	if (freq_in && freq_out) {
+		ret = pll_factors(&pll_div, freq_out, freq_in);
+		if (ret != 0)
+			return ret;
+	}
+
+	state->in = freq_in;
+	state->out = freq_out;
+
+	/* Always disable the PLL - it is not safe to leave it running
+	 * while reprogramming it.
+	 */
+	reg = wm8581_read(codec, WM8581_PWRDN2);
+	wm8581_write(codec, WM8581_PWRDN2, reg | pwr_mask);
+
+	if (!freq_in || !freq_out)
+		return 0;
+
+	wm8581_write(codec, WM8581_PLLA1 + offset, pll_div.k & 0x1ff);
+	wm8581_write(codec, WM8581_PLLA2 + offset, (pll_div.k >> 9) & 0xff);
+	wm8581_write(codec, WM8581_PLLA3 + offset,
+		     (pll_div.k >> 18 & 0xf) | (pll_div.n << 4));
+
+	reg = wm8581_read(codec, WM8581_PLLA4 + offset);
+	reg &= ~0x3f;
+	reg |= pll_div.prescale | pll_div.postscale << 1 |
+		pll_div.freqmode << 4;
+
+	wm8581_write(codec, WM8581_PLLA4 + offset, reg);
+
+	/* All done, turn it on */
+	reg = wm8581_read(codec, WM8581_PWRDN2);
+	wm8581_write(codec, WM8581_PWRDN2, reg & ~pwr_mask);
+
+	return 0;
+}
+
+/*
+ * Set PCM DAI bit size and sample rate.
+ */
+static int wm8581_paif_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai_link *dai = rtd->dai;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	u16 paifb = wm8581_read(codec, WM8581_PAIF3 + dai->codec_dai->id);
+
+	paifb &= ~WM8581_AIF_LENGTH_MASK;
+	/* bit size */
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		paifb |= WM8581_AIF_LENGTH_20;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		paifb |= WM8581_AIF_LENGTH_24;
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		paifb |= WM8581_AIF_LENGTH_24;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	wm8581_write(codec, WM8581_PAIF3 + dai->codec_dai->id, paifb);
+	return 0;
+}
+
+static int wm8581_set_paif_dai_fmt(struct snd_soc_dai *codec_dai,
+				      unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	unsigned int aifa;
+	unsigned int aifb;
+	int can_invert_lrclk;
+
+	aifa = wm8581_read(codec, WM8581_PAIF1 + codec_dai->id);
+	aifb = wm8581_read(codec, WM8581_PAIF3 + codec_dai->id);
+
+	aifb &= ~(WM8581_AIF_FMT_MASK | WM8581_AIF_LRP | WM8581_AIF_BCP);
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		aifa &= ~WM8581_AIF_MS;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFM:
+		aifa |= WM8581_AIF_MS;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		can_invert_lrclk = 1;
+		aifb |= WM8581_AIF_FMT_I2S;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		can_invert_lrclk = 1;
+		aifb |= WM8581_AIF_FMT_RIGHTJ;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		can_invert_lrclk = 1;
+		aifb |= WM8581_AIF_FMT_LEFTJ;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		can_invert_lrclk = 0;
+		aifb |= WM8581_AIF_FMT_DSP;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		can_invert_lrclk = 0;
+		aifb |= WM8581_AIF_FMT_DSP;
+		aifb |= WM8581_AIF_LRP;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+
+	case SND_SOC_DAIFMT_IB_IF:
+		if (!can_invert_lrclk)
+			return -EINVAL;
+		aifb |= WM8581_AIF_BCP;
+		aifb |= WM8581_AIF_LRP;
+		break;
+
+	case SND_SOC_DAIFMT_IB_NF:
+		aifb |= WM8581_AIF_BCP;
+		break;
+
+	case SND_SOC_DAIFMT_NB_IF:
+		if (!can_invert_lrclk)
+			return -EINVAL;
+		aifb |= WM8581_AIF_LRP;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	wm8581_write(codec, WM8581_PAIF1 + codec_dai->id, aifa);
+	wm8581_write(codec, WM8581_PAIF3 + codec_dai->id, aifb);
+
+	return 0;
+}
+
+static int wm8581_set_dai_clkdiv(struct snd_soc_dai *codec_dai,
+				 int div_id, int div)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	unsigned int reg;
+
+	switch (div_id) {
+	case WM8581_MCLK:
+		reg = wm8581_read(codec, WM8581_PLLB4);
+		reg &= ~WM8581_PLLB4_MCLKOUTSRC_MASK;
+
+		switch (div) {
+		case WM8581_CLKSRC_MCLK:
+			/* Input */
+			break;
+
+		case WM8581_CLKSRC_PLLA:
+			reg |= WM8581_PLLB4_MCLKOUTSRC_PLLA;
+			break;
+		case WM8581_CLKSRC_PLLB:
+			reg |= WM8581_PLLB4_MCLKOUTSRC_PLLB;
+			break;
+
+		case WM8581_CLKSRC_OSC:
+			reg |= WM8581_PLLB4_MCLKOUTSRC_OSC;
+			break;
+
+		default:
+			return -EINVAL;
+		}
+		wm8581_write(codec, WM8581_PLLB4, reg);
+		break;
+
+	case WM8581_DAC_CLKSEL:
+		reg = wm8581_read(codec, WM8581_CLKSEL);
+		reg &= ~WM8581_CLKSEL_DAC_CLKSEL_MASK;
+
+		switch (div) {
+		case WM8581_CLKSRC_MCLK:
+			break;
+
+		case WM8581_CLKSRC_PLLA:
+			reg |= WM8581_CLKSEL_DAC_CLKSEL_PLLA;
+			break;
+
+		case WM8581_CLKSRC_PLLB:
+			reg |= WM8581_CLKSEL_DAC_CLKSEL_PLLB;
+			break;
+
+		default:
+			return -EINVAL;
+		}
+		wm8581_write(codec, WM8581_CLKSEL, reg);
+		break;
+
+	case WM8581_CLKOUTSRC:
+		reg = wm8581_read(codec, WM8581_PLLB4);
+		reg &= ~WM8581_PLLB4_CLKOUTSRC_MASK;
+
+		switch (div) {
+		case WM8581_CLKSRC_NONE:
+			break;
+
+		case WM8581_CLKSRC_PLLA:
+			reg |= WM8581_PLLB4_CLKOUTSRC_PLLACLK;
+			break;
+
+		case WM8581_CLKSRC_PLLB:
+			reg |= WM8581_PLLB4_CLKOUTSRC_PLLBCLK;
+			break;
+
+		case WM8581_CLKSRC_OSC:
+			reg |= WM8581_PLLB4_CLKOUTSRC_OSCCLK;
+			break;
+
+		default:
+			return -EINVAL;
+		}
+		wm8581_write(codec, WM8581_PLLB4, reg);
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int wm8581_digital_mute(struct snd_soc_dai *codec_dai, int mute)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	unsigned int reg;
+
+	reg = wm8581_read(codec, WM8581_DAC_CONTROL5);
+
+	if (mute)
+		reg |= WM8581_DAC_CONTROL5_MUTEALL;
+	else
+		reg &= ~WM8581_DAC_CONTROL5_MUTEALL;
+
+	wm8581_write(codec, WM8581_DAC_CONTROL5, reg);
+
+	return 0;
+}
+
+static int wm8581_set_bias_level(struct snd_soc_codec *codec,
+	enum snd_soc_bias_level level)
+{
+	u16 reg;
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+	case SND_SOC_BIAS_PREPARE:
+	case SND_SOC_BIAS_STANDBY:
+		break;
+	case SND_SOC_BIAS_OFF:
+		reg = wm8581_read(codec, WM8581_PWRDN1);
+		wm8581_write(codec, WM8581_PWRDN1, reg | WM8581_PWRDN1_PWDN);
+		break;
+	}
+	codec->bias_level = level;
+	return 0;
+}
+
+#define WM8581_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\
+			SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+struct snd_soc_dai wm8581_dai[] = {
+	{
+		.name = "WM8581 PAIFRX",
+		.id = 0,
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = 1,
+			.channels_max = 8,
+			.rates = SNDRV_PCM_RATE_8000_192000,
+			.formats = WM8581_FORMATS,
+		},
+		.ops = {
+			 .hw_params = wm8581_paif_hw_params,
+		 },
+		.dai_ops = {
+			 .set_fmt = wm8581_set_paif_dai_fmt,
+			 .set_clkdiv = wm8581_set_dai_clkdiv,
+			 .set_pll = wm8581_set_dai_pll,
+			 .digital_mute = wm8581_digital_mute,
+		 },
+	},
+	{
+		.name = "WM8581 PAIFTX",
+		.id = 1,
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = 2,
+			.channels_max = 2,
+			.rates = SNDRV_PCM_RATE_8000_192000,
+			.formats = WM8581_FORMATS,
+		},
+		.ops = {
+			 .hw_params = wm8581_paif_hw_params,
+		 },
+		.dai_ops = {
+			 .set_fmt = wm8581_set_paif_dai_fmt,
+			 .set_clkdiv = wm8581_set_dai_clkdiv,
+			 .set_pll = wm8581_set_dai_pll,
+		 },
+	},
+};
+EXPORT_SYMBOL_GPL(wm8581_dai);
+
+/*
+ * initialise the WM8581 driver
+ * register the mixer and dsp interfaces with the kernel
+ */
+static int wm8581_init(struct snd_soc_device *socdev)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+	int ret = 0;
+
+	codec->name = "WM8581";
+	codec->owner = THIS_MODULE;
+	codec->read = wm8581_read_reg_cache;
+	codec->write = wm8581_write;
+	codec->set_bias_level = wm8581_set_bias_level;
+	codec->dai = wm8581_dai;
+	codec->num_dai = ARRAY_SIZE(wm8581_dai);
+	codec->reg_cache_size = ARRAY_SIZE(wm8581_reg);
+	codec->reg_cache = kmemdup(wm8581_reg, sizeof(wm8581_reg),
+				   GFP_KERNEL);
+
+	if (codec->reg_cache == NULL)
+		return -ENOMEM;
+
+	/* Get the codec into a known state */
+	wm8581_write(codec, WM8581_RESET, 0);
+
+	/* Power up and get individual control of the DACs */
+	wm8581_write(codec, WM8581_PWRDN1, wm8581_read(codec, WM8581_PWRDN1) &
+		     ~(WM8581_PWRDN1_PWDN | WM8581_PWRDN1_ALLDACPD));
+
+	/* Make VMID high impedence */
+	wm8581_write(codec, WM8581_ADC_CONTROL1,
+		     wm8581_read(codec,  WM8581_ADC_CONTROL1) & ~0x100);
+
+	/* register pcms */
+	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1,
+			       SNDRV_DEFAULT_STR1);
+	if (ret < 0) {
+		printk(KERN_ERR "wm8581: failed to create pcms\n");
+		goto pcm_err;
+	}
+
+	wm8581_add_controls(codec);
+	wm8581_add_widgets(codec);
+
+	ret = snd_soc_register_card(socdev);
+	if (ret < 0) {
+		printk(KERN_ERR "wm8581: failed to register card\n");
+		goto card_err;
+	}
+
+    {
+        int i = 0;
+        for (i = 0; i < WM8581_RESET; i++) {
+            wm8581_write(codec, i, wm8581_reg[i]);
+        }
+    }
+	return ret;
+
+card_err:
+	snd_soc_free_pcms(socdev);
+	snd_soc_dapm_free(socdev);
+pcm_err:
+	kfree(codec->reg_cache);
+	return ret;
+}
+
+/* If the i2c layer weren't so broken, we could pass this kind of data
+   around */
+static struct snd_soc_device *wm8581_socdev;
+
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
+
+static int wm8581_i2c_probe(struct i2c_client *i2c,
+			    const struct i2c_device_id *id)
+{
+	struct snd_soc_device *socdev = wm8581_socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	int ret;
+
+	i2c_set_clientdata(i2c, codec);
+	codec->control_data = i2c;
+
+	ret = wm8581_init(socdev);
+	if (ret < 0)
+		pr_err("failed to initialise WM8581\n");
+
+	return ret;
+}
+
+static int wm8581_i2c_remove(struct i2c_client *client)
+{
+	struct snd_soc_codec *codec = i2c_get_clientdata(client);
+	kfree(codec->reg_cache);
+	return 0;
+}
+
+static const struct i2c_device_id wm8581_i2c_id[] = {
+	{ "wm8581", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, wm8581_i2c_id);
+
+static struct i2c_driver wm8581_i2c_driver = {
+	.driver = {
+		.name = "WM8581 I2C Codec",
+		.owner = THIS_MODULE,
+	},
+	.probe =    wm8581_i2c_probe,
+	.remove =   wm8581_i2c_remove,
+	.id_table = wm8581_i2c_id,
+};
+
+static int wm8581_add_i2c_device(struct platform_device *pdev,
+				 const struct wm8581_setup_data *setup)
+{
+	struct i2c_board_info info;
+	struct i2c_adapter *adapter;
+	struct i2c_client *client;
+	int ret;
+
+	ret = i2c_add_driver(&wm8581_i2c_driver);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "can't add i2c driver\n");
+		return ret;
+	}
+
+	memset(&info, 0, sizeof(struct i2c_board_info));
+	info.addr = setup->i2c_address;
+	strlcpy(info.type, "wm8581", I2C_NAME_SIZE);
+
+	adapter = i2c_get_adapter(setup->i2c_bus);
+	if (!adapter) {
+		dev_err(&pdev->dev, "can't get i2c adapter %d\n",
+			setup->i2c_bus);
+		goto err_driver;
+	}
+
+	client = i2c_new_device(adapter, &info);
+	i2c_put_adapter(adapter);
+	if (!client) {
+		dev_err(&pdev->dev, "can't add i2c device at 0x%x\n",
+			(unsigned int)info.addr);
+		goto err_driver;
+	}
+
+	return 0;
+
+err_driver:
+	i2c_del_driver(&wm8581_i2c_driver);
+	return -ENODEV;
+}
+#endif
+
+static int wm8581_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct wm8581_setup_data *setup;
+	struct snd_soc_codec *codec;
+	struct wm8581_priv *wm8581;
+	int ret = 0;
+
+	pr_info("WM8581 Audio Codec %s\n", WM8581_VERSION);
+
+	setup = socdev->codec_data;
+	codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL);
+	if (codec == NULL)
+		return -ENOMEM;
+
+	wm8581 = kzalloc(sizeof(struct wm8581_priv), GFP_KERNEL);
+	if (wm8581 == NULL) {
+		kfree(codec);
+		return -ENOMEM;
+	}
+
+	codec->private_data = wm8581;
+	socdev->codec = codec;
+	mutex_init(&codec->mutex);
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+	wm8581_socdev = socdev;
+
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
+	if (setup->i2c_address) {
+#if 0
+		normal_i2c[0] = setup->i2c_address;
+		codec->hw_write = (hw_write_t)i2c_master_send;
+		ret = i2c_add_driver(&wm8581_i2c_driver);
+#else
+        printk("\n wm8581 i2c_address [0x%X]\n", setup->i2c_address);
+		codec->hw_write = (hw_write_t)i2c_master_send;
+		ret = wm8581_add_i2c_device(pdev, setup);
+#endif
+		if (ret != 0)
+			printk(KERN_ERR "can't add i2c driver");
+	}
+#else
+		/* Add other interfaces here */
+#endif
+	return ret;
+}
+
+/* power down chip */
+static int wm8581_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	if (codec->control_data)
+		wm8581_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	snd_soc_free_pcms(socdev);
+	snd_soc_dapm_free(socdev);
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
+    i2c_unregister_device(codec->control_data);
+	i2c_del_driver(&wm8581_i2c_driver);
+#endif
+	kfree(codec->private_data);
+	kfree(codec);
+
+	return 0;
+}
+
+struct snd_soc_codec_device soc_codec_dev_wm8581 = {
+	.probe = 	wm8581_probe,
+	.remove = 	wm8581_remove,
+};
+EXPORT_SYMBOL_GPL(soc_codec_dev_wm8581);
+
+MODULE_DESCRIPTION("ASoC WM8581 driver");
+MODULE_AUTHOR("Mark Brown <broonie@opensource.wolfsonmicro.com>");
+MODULE_LICENSE("GPL");
Index: linux-2.6.29/sound/soc/codecs/wm8581.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/sound/soc/codecs/wm8581.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,43 @@
+/*
+ * wm8581.h  --  audio driver for WM8581
+ *
+ * Copyright 2008 Wolfson Microelectronics PLC.
+ * Copyright (C) 2009 Telechips
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#ifndef _WM8581_H
+#define _WM8581_H
+
+#define WM8581_PLLA  1
+#define WM8581_PLLB  2
+
+#define WM8581_MCLK       1
+#define WM8581_DAC_CLKSEL 2
+#define WM8581_CLKOUTSRC  3
+
+#define WM8581_CLKSRC_MCLK 1
+#define WM8581_CLKSRC_PLLA 2
+#define WM8581_CLKSRC_PLLB 3
+#define WM8581_CLKSRC_OSC  4
+#define WM8581_CLKSRC_NONE 5
+
+struct wm8581_setup_data {
+	int            spi;
+	int            i2c_bus;
+	unsigned short i2c_address;
+};
+
+#define WM8581_DAI_PAIFRX 0
+#define WM8581_DAI_PAIFTX 1
+
+extern struct snd_soc_dai wm8581_dai[];
+extern struct snd_soc_codec_device soc_codec_dev_wm8581;
+
+#endif
+
Index: linux-2.6.29/sound/soc/codecs/wm8731.c
===================================================================
--- linux-2.6.29.orig/sound/soc/codecs/wm8731.c	2010-04-07 12:29:31.000000000 -0400
+++ linux-2.6.29/sound/soc/codecs/wm8731.c	2010-04-07 12:29:36.000000000 -0400
@@ -1,15 +1,29 @@
 /*
- * wm8731.c  --  WM8731 ALSA SoC Audio driver
- *
- * Copyright 2005 Openedhand Ltd.
+ * linux/sound/soc/codecs/wm8731.c 
  *
+ * Based on:  wm8753.c by Liam Girdwood
  * Author: Richard Purdie <richard@openedhand.com>
+ * Rewritten by:    <linux@telechips.com>
+ * Created: June 10, 2008
+ * Description: WM8731 ALSA SoC Audio driver
  *
- * Based on wm8753.c by Liam Girdwood
+ * Copyright 2005 Openedhand Ltd.
+ * Copyright (C) 2008-2009 Telechips 
  *
  * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see the file COPYING, or write
+ * to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
 #include <linux/module.h>
@@ -27,7 +41,9 @@
 #include <sound/soc-dapm.h>
 #include <sound/initval.h>
 
+
 #include "wm8731.h"
+#include "../tcc/tcc-pcm.h"
 
 #define WM8731_VERSION "0.13"
 
@@ -44,11 +60,19 @@
  * using 2 wire for device control, so we cache them instead.
  * There is no point in caching the reset register
  */
+#if 0
+static const u16 wm8731_reg[WM8731_CACHEREGNUM] = {
+    0x0097, 0x0097, 0x0064, 0x0064,
+    0x0090, 0x0008, 0x0061, 0x000a,
+    0x0000, 0x0000
+};
+#else
 static const u16 wm8731_reg[WM8731_CACHEREGNUM] = {
-    0x0097, 0x0097, 0x0079, 0x0079,
-    0x000a, 0x0008, 0x009f, 0x000a,
+    0x0017, 0x0017, 0x0064, 0x0064,
+    0x0090, 0x0008, 0x009f, 0x000a,
     0x0000, 0x0000
 };
+#endif
 
 /*
  * read wm8731 register cache
@@ -76,6 +100,40 @@
 	cache[reg] = value;
 }
 
+#ifdef _WM8731_REG_DEBUG_
+static char *get_wm8731_reg_name(unsigned int i)
+{
+    switch (i) {
+    case 0xF:
+        return "@ Reset Register                ";
+    case 0x0:
+        return "@ Left Line In                  ";
+    case 0x1:
+        return "@ Right Line In                 ";
+    case 0x2:
+        return "@ Left Headphone Out            ";
+    case 0x3:
+        return "@ Right Headphone Out           ";
+    case 0x4:
+        return "@ Analogue Audio Path Control   ";
+    case 0x5:
+        return "@ Digital Audio Path Control    ";
+    case 0x6:
+        return "@ Power Down Control            ";
+    case 0x7:
+        return "@ Digital Audio Interface Format";
+    case 0x8:
+        return "@ Sampling Control              ";
+    case 0x9:
+        return "@ Active Control                ";
+    default:
+        return "@ Unknown reg                   ";
+        break;
+    }
+    return NULL;
+}
+#endif
+
 /*
  * write to the WM8731 register space
  */
@@ -91,11 +149,24 @@
 	data[0] = (reg << 1) | ((value >> 8) & 0x0001);
 	data[1] = value & 0x00ff;
 
+#if 0
+    if ((reg == WM8731_PWR) && tcc_alsa_info.flag) {
+        data[1] &= ~(0x6F);
+    }
+#endif
+
+#ifdef _WM8731_REG_DEBUG_
+    printk(" ***** write reg  <%s>   data[%X:0x%X]\n",
+           get_wm8731_reg_name(data[0] >> 1), (data[0] & ~0x1), data[1]);
+#endif
+
+	//wm8731_write_reg_cache(codec, reg, value);
 	wm8731_write_reg_cache(codec, reg, value);
-	if (codec->hw_write(codec->control_data, data, 2) == 2)
+	if (codec->hw_write(codec->control_data, data, 2) == 2) {
 		return 0;
-	else
-		return -EIO;
+    }
+
+    return -EIO;
 }
 
 #define wm8731_reset(c)	wm8731_write(c, WM8731_RESET, 0)
@@ -270,13 +341,15 @@
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct snd_soc_device *socdev = rtd->socdev;
 	struct snd_soc_codec *codec = socdev->codec;
-	struct wm8731_priv *wm8731 = codec->private_data;
 	u16 iface = wm8731_read_reg_cache(codec, WM8731_IFACE) & 0xfff3;
+#if 0
+	struct wm8731_priv *wm8731 = codec->private_data;
 	int i = get_coeff(wm8731->sysclk, params_rate(params));
 	u16 srate = (coeff_div[i].sr << 2) |
 		(coeff_div[i].bosr << 1) | coeff_div[i].usb;
 
 	wm8731_write(codec, WM8731_SRATE, srate);
+#endif
 
 	/* bit size */
 	switch (params_format(params)) {
@@ -508,6 +581,7 @@
 {
 	struct snd_soc_codec *codec = socdev->codec;
 	int reg, ret = 0;
+    int i = 0;
 
 	codec->name = "WM8731";
 	codec->owner = THIS_MODULE;
@@ -530,18 +604,11 @@
 		goto pcm_err;
 	}
 
-	/* power on device */
-	wm8731_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
-
-	/* set the update bits */
-	reg = wm8731_read_reg_cache(codec, WM8731_LOUT1V);
-	wm8731_write(codec, WM8731_LOUT1V, reg & ~0x0100);
-	reg = wm8731_read_reg_cache(codec, WM8731_ROUT1V);
-	wm8731_write(codec, WM8731_ROUT1V, reg & ~0x0100);
-	reg = wm8731_read_reg_cache(codec, WM8731_LINVOL);
-	wm8731_write(codec, WM8731_LINVOL, reg & ~0x0100);
-	reg = wm8731_read_reg_cache(codec, WM8731_RINVOL);
-	wm8731_write(codec, WM8731_RINVOL, reg & ~0x0100);
+    wm8731_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+    for (i = 0; i <= WM8731_ACTIVE; i++) {
+        reg = wm8731_read_reg_cache(codec, i);
+        wm8731_write(codec, i, reg & ~0x0100);
+    }
 
 	wm8731_add_controls(codec);
 	wm8731_add_widgets(codec);
@@ -572,6 +639,35 @@
  *    high = 0x1b
  */
 
+#ifdef CONFIG_TCC_I2C_WM8731
+extern struct i2c_client *wm8731_i2c_client;
+static int wm8731_codec_probe(void)
+{
+    struct snd_soc_device *socdev = wm8731_socdev;
+    //struct wm8731_setup_data *setup = socdev->codec_data;
+    struct snd_soc_codec *codec = socdev->codec;
+    //struct i2c_client *i2c;
+    int ret;
+
+    if (!wm8731_i2c_client) {
+        printk("wm8731_i2c_client is NULL !!! \n");
+        return -1;
+    }
+    i2c_set_clientdata(wm8731_i2c_client, codec);
+    codec->control_data = wm8731_i2c_client;
+
+    ret = wm8731_init(socdev);
+    if (ret < 0) {
+        printk("failed to initialise WM8731\n");
+        goto err;
+    }
+    return ret;
+
+err:
+    kfree(codec);
+    return ret;
+}
+#else
 static int wm8731_i2c_probe(struct i2c_client *i2c,
 			    const struct i2c_device_id *id)
 {
@@ -652,6 +748,7 @@
 	return -ENODEV;
 }
 #endif
+#endif
 
 #if defined(CONFIG_SPI_MASTER)
 static int __devinit wm8731_spi_probe(struct spi_device *spi)
@@ -741,8 +838,15 @@
 
 #if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
 	if (setup->i2c_address) {
+        printk("\n wm8731 i2c_address [0x%X]\n", setup->i2c_address);
 		codec->hw_write = (hw_write_t)i2c_master_send;
+#ifdef CONFIG_TCC_I2C_WM8731
+        ret = wm8731_codec_probe();
+        if (ret != 0)
+            printk(KERN_ERR "can't add i2c driver");
+#else
 		ret = wm8731_add_i2c_device(pdev, setup);
+#endif
 	}
 #endif
 #if defined(CONFIG_SPI_MASTER)
@@ -766,18 +870,26 @@
 {
 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
 	struct snd_soc_codec *codec = socdev->codec;
+	struct wm8731_setup_data *setup;
 
 	if (codec->control_data)
 		wm8731_set_bias_level(codec, SND_SOC_BIAS_OFF);
 
+	setup = socdev->codec_data;
+
 	snd_soc_free_pcms(socdev);
 	snd_soc_dapm_free(socdev);
 #if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
-	i2c_unregister_device(codec->control_data);
+	/* i2c_unregister_device(codec->control_data); */
+#ifdef CONFIG_TCC_I2C_WM8731
+#else
 	i2c_del_driver(&wm8731_i2c_driver);
 #endif
+
+#endif
 #if defined(CONFIG_SPI_MASTER)
-	spi_unregister_driver(&wm8731_spi_driver);
+    if (setup->spi)
+        spi_unregister_driver(&wm8731_spi_driver);
 #endif
 	kfree(codec->private_data);
 	kfree(codec);
@@ -808,3 +920,4 @@
 MODULE_DESCRIPTION("ASoC WM8731 driver");
 MODULE_AUTHOR("Richard Purdie");
 MODULE_LICENSE("GPL");
+
Index: linux-2.6.29/sound/soc/tcc/Kconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/sound/soc/tcc/Kconfig	2010-04-07 13:00:44.000000000 -0400
@@ -0,0 +1,36 @@
+config SND_TCC_SOC
+	tristate "SoC Audio for the Telechips TCC chip"
+	depends on (MACH_TCC8900) && SND_SOC
+	help
+	  Say Y or M if you want to add support for codecs attached to
+	  the TCC I2S interface. You will also need
+	  to select the audio interfaces to support below.
+
+config SND_TCC_SOC_I2S
+	tristate
+
+choice
+    prompt "SoC Audio support for TCC Board"
+	depends on SND_TCC_SOC 
+    default SND_TCC_SOC_BOARD_WM8731
+    help
+        TCC  Audio Codec
+
+config SND_TCC_SOC_BOARD_WM8731
+	tristate "WM8731"
+	select SND_TCC_SOC_I2S
+	select SND_SOC_WM8731
+	help
+	  Say Y if you want to add support for SoC audio on Telechips
+	  TCC (WM8731).
+
+config SND_TCC_SOC_BOARD_WM8581
+	tristate "WM8581"
+	select SND_TCC_SOC_I2S
+	select SND_SOC_WM8581
+	help
+	  Say Y if you want to add support for SoC audio on Telechips
+	  TCC (WM8581).
+
+endchoice 
+
Index: linux-2.6.29/sound/soc/tcc/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/sound/soc/tcc/Makefile	2010-04-07 13:00:44.000000000 -0400
@@ -0,0 +1,17 @@
+# TCC Platform Support
+
+ifeq ($(CONFIG_ARCH_TCC),y)
+$(shell ln -fsn $(CONFIG_TCC_STRING) $(srctree)/sound/soc/tcc/tcc) 
+endif
+
+# TCC Machine Support
+#snd-soc-tcc-i2s-objs := tcc-pcm.o tcc-i2s.o
+
+snd-soc-tcc-board-objs := tcc_board.o
+snd-soc-tcc-i2s-objs := tcc-pcm.o tcc-i2s.o tcc/tca_tcchwcontrol.o
+snd-soc-tcc-board-wm8581-objs := tcc_board_wm8581.o
+
+obj-$(CONFIG_SND_TCC_SOC_I2S) += snd-soc-tcc-i2s.o
+obj-$(CONFIG_SND_TCC_SOC_BOARD_WM8731) += snd-soc-tcc-board.o 
+obj-$(CONFIG_SND_TCC_SOC_BOARD_WM8581) += snd-soc-tcc-board-wm8581.o
+
Index: linux-2.6.29/sound/soc/tcc/tcc-i2s.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/sound/soc/tcc/tcc-i2s.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,296 @@
+/*
+ * linux/sound/soc/tcc/tcc-i2s.c
+ *
+ * Based on:    linux/sound/soc/pxa/pxa2xx-i2s.h
+ * Author: Liam Girdwood<liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com>
+ * Rewritten by:    <linux@telechips.com>
+ * Created:     12th Aug 2005   Initial version.
+ * Modified:    Nov 25, 2008
+ * Description: ALSA PCM interface for the Intel PXA2xx chip
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Copyright (C) 2008-2009 Telechips 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see the file COPYING, or write
+ * to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include <bsp.h>
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+#include <mach/tca_ckc.h>
+
+#include "tcc-pcm.h"
+#include "tcc-i2s.h"
+#include "tcc/tca_tcchwcontrol.h"
+
+static struct tcc_pcm_dma_params tcc_i2s_pcm_stereo_out = {
+    .name		     = "I2S PCM Stereo out",
+    .dma_addr           = 0,
+    .channel             =0,
+    //       .dma_size
+
+};
+
+static struct tcc_pcm_dma_params tcc_i2s_pcm_stereo_in = {
+    .name                  = "I2S PCM Stereo in",
+    .dma_addr           = 0,
+    .channel               =1,
+    //        .dma_size	
+};
+
+static struct tcc_pcm_dma_params tcc_i2s_pcm_spdif_out = {
+    .name		     = "I2S PCM S/PDIF out",
+    .dma_addr           = 0,
+    .channel             =0,
+    //       .dma_size
+
+};
+
+int alsa_I2S_Init(void)
+{
+    volatile PADMADAI pADMA_DAI = (volatile PADMADAI)tcc_p2v(HwADMA_DAIBASE);
+    volatile PPIC pPIC = (volatile PPIC)tcc_p2v(HwPIC_BASE);
+	volatile ADMASPDIFTX *p_adma_spdif_tx_base = (volatile ADMASPDIFTX *)tcc_p2v(HwADMA_SPDIFTXBASE);
+
+    tca_i2s_dai_init(pADMA_DAI);
+
+	tca_ckc_setiobus(RB_SPDIFTXCONTROLLER, 1);
+    tca_ckc_setiobus(RB_DAICDIFCONTROLLER, 1);
+    tca_ckc_setiobus(RB_ADMACONTROLLER, 1);
+
+    tca_ckc_set_iobus_swreset(RB_ADMACONTROLLER, 0);
+    tca_ckc_set_iobus_swreset(RB_ADMACONTROLLER, 1);
+
+    //Clear DAI TX INT
+    //BITCLR(HwCLR, HwCLR_DAITX);
+    //BITCLR(HwCLR, HwCLR_DAIRX);
+
+    //Config DMA Interrupt
+    BITSET(pPIC->SEL1, 1 << (INT_ADMA - 32));
+    BITSET(pPIC->MODE1, 1 << (INT_ADMA - 32));
+    BITCLR(pPIC->POL1, 1 << (INT_ADMA - 32));
+
+    tca_i2s_stop((void *)pADMA_DAI, (void *)p_adma_spdif_tx_base, 0);
+    tca_i2s_stop((void *)pADMA_DAI, (void *)p_adma_spdif_tx_base, 1);
+
+    return 1;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+Function:		StartI2SClock()
+
+Description:	Enables the I2S clock that drives the audio codec chip.
+
+Returns:		N/A
+-------------------------------------------------------------------*/
+static int tcc_i2s_startup(struct snd_pcm_substream *substream)
+{
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+
+    if (!cpu_dai->active) {
+        //alsa_I2S_Init();
+    }
+
+    return 0;
+}
+
+static int tcc_i2s_set_dai_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)
+{
+    switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+    case SND_SOC_DAIFMT_CBS_CFS:
+        break;
+    case SND_SOC_DAIFMT_CBM_CFS:
+        break;
+    default:
+        break;
+    }
+
+
+    /* interface format */
+    switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+    case SND_SOC_DAIFMT_I2S:
+        break;
+    case SND_SOC_DAIFMT_LEFT_J:
+        break;
+    }
+    return 0;
+}
+
+static int tcc_i2s_set_dai_sysclk(struct snd_soc_dai *cpu_dai,
+                                      int clk_id, unsigned int freq, int dir)
+{
+    if (clk_id != TCC_I2S_SYSCLK)
+        return -ENODEV;  
+
+    return 0;
+}
+static int tcc_i2s_hw_params(struct snd_pcm_substream *substream,
+                                 struct snd_pcm_hw_params *params)
+{
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+
+    if (substream->pcm->device == __SPDIF_DEV_NUM__) {
+        cpu_dai->dma_data = &tcc_i2s_pcm_spdif_out;
+        tea_spdif_setclock(params_rate(params));
+    } else {
+        cpu_dai->dma_data = ((substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+                             ?  &tcc_i2s_pcm_stereo_out : &tcc_i2s_pcm_stereo_in);
+        tea_i2s_setclock(params_rate(params));
+    }
+    return 0;
+}
+
+
+static int tcc_i2s_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+    int ret = 0;
+    volatile PADMADAI pDAI = (volatile PADMADAI)tcc_p2v(HwADMA_DAIBASE);
+
+    switch (cmd) {
+    case SNDRV_PCM_TRIGGER_START:
+    case SNDRV_PCM_TRIGGER_RESUME:
+    case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+        //tca_i2s_start(substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? 0 : 1);
+        BITSET(pDAI->DAMR, Hw15);
+        break;
+
+    case SNDRV_PCM_TRIGGER_STOP:
+    case SNDRV_PCM_TRIGGER_SUSPEND:
+    case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+        //tca_i2s_stop(substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? 0 : 1);
+        //mutex_lock(&(tcc_alsa_info.mutex));
+        if (!(tcc_alsa_info.flag)) {
+            BITCLR(pDAI->DAMR, Hw15);
+        }
+        //mutex_unlock(&(tcc_alsa_info.mutex));
+        break;
+
+    default:
+        ret = -EINVAL;
+    }
+    return ret;
+}
+
+static void tcc_i2s_shutdown(struct snd_pcm_substream *substream)
+{
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {        
+    } else {        
+    }
+
+    //mutex_lock(&(tcc_alsa_info.mutex));
+    if (!(tcc_alsa_info.flag)) {
+        //BITCLR(HwPCLKCFG7, HwPCLKCFG7_DCLK1_EN_ON);
+    }
+    //mutex_unlock(&(tcc_alsa_info.mutex));
+}
+
+#ifdef CONFIG_PM
+static int tcc_i2s_suspend(struct platform_device *dev, struct snd_soc_dai *dai)
+{
+#if 0
+    if (!dai->active)
+        return 0;
+
+    /* deactivate link */
+    HwDAMR &= ~HwDAMR_EN_ON;
+
+    dev->dev.power.power_state = PMSG_SUSPEND;
+#endif
+
+    return 0;
+}
+
+static int tcc_i2s_resume(struct platform_device *pdev, struct snd_soc_dai *dai)
+{
+#if 0
+    if (!dai->active)
+        return 0;
+
+    alsa_I2S_Init();     
+#endif
+
+    return 0;
+}
+#else
+
+#define tcc_i2s_suspend	NULL
+#define tcc_i2s_resume	NULL
+
+#endif
+
+#define TCC89XX_I2S_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |\
+                           SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 |\
+                           SNDRV_PCM_RATE_32000 |SNDRV_PCM_RATE_44100 |\
+                           SNDRV_PCM_RATE_48000 )
+
+int tcc_i2s_probe(struct platform_device *pdev, struct snd_soc_dai *dai)
+{
+    ((void)(dai));
+    alsa_I2S_Init();
+    tea_i2s_setclock(44100);
+    return 0;
+}
+
+struct snd_soc_dai tcc_i2s_dai = {
+    .name = "tcc-i2s",
+    .id = 0,
+    .type = SND_SOC_DAI_I2S,
+    .suspend = tcc_i2s_suspend,
+    .resume = tcc_i2s_resume,
+    .playback = {
+        .channels_min = 2,
+#if defined(CONFIG_SND_SOC_WM8581) || defined(CONFIG_SND_SOC_WM8581_MODULE)
+        .channels_max = 8,
+#else
+        .channels_max = 2,
+#endif
+        .rates = TCC89XX_I2S_RATES,
+        .formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE,},  //should be change? phys:32 width:16
+    .capture = {
+        .channels_min = 2,
+        .channels_max = 2,
+        .rates = TCC89XX_I2S_RATES,
+        .formats = SNDRV_PCM_FMTBIT_S16_LE,}, //should be change? phys:32 width:16
+    .ops = {
+        .startup = tcc_i2s_startup,
+        .shutdown = tcc_i2s_shutdown,
+        .trigger = tcc_i2s_trigger,
+        .hw_params = tcc_i2s_hw_params,},
+    .dai_ops = {
+        .set_fmt = tcc_i2s_set_dai_fmt,
+        .set_sysclk = tcc_i2s_set_dai_sysclk,
+    },
+    .probe = tcc_i2s_probe,
+};
+
+EXPORT_SYMBOL_GPL(tcc_i2s_dai);
+
+/* Module information */
+MODULE_AUTHOR("linux <linux@telechips.com>");
+MODULE_DESCRIPTION("Telechips TCC I2S SoC Interface");
+MODULE_LICENSE("GPL");
+
Index: linux-2.6.29/sound/soc/tcc/tcc-i2s.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/sound/soc/tcc/tcc-i2s.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,133 @@
+/*
+ * linux/sound/soc/tcc/tcc-i2s.h
+ *
+ * Based on:    linux/sound/soc/pxa/pxa2xx-i2s.h
+ * Author:  <linux@telechips.com>
+ * Created:    Nov 25, 2008
+ * Description: ALSA PCM interface for the Intel PXA2xx chip
+ *
+ * Copyright (C) 2008-2009 Telechips 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see the file COPYING, or write
+ * to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _TCC_I2S_H
+#define _TCC_I2S_H
+
+/* pxa2xx DAI ID's */
+#define TCC_DAI_I2S			0
+
+/* I2S clock */
+#define TCC_I2S_SYSCLK		0
+
+extern struct snd_soc_dai tcc_i2s_dai;
+
+//=============================================================================
+#define AUDIO_DMA_PAGE_NUMBER   (2)                     // Number of DMA Buffer
+#define AUDIO_DMA_OUT_PAGE_SIZE (1024)                  // Size in bytes        
+#define AUDIO_DMA_IN_PAGE_SIZE  (1024)                  // Size in bytes        
+#define AUDIO_DMA_OUT_BUF_SIZE  (AUDIO_DMA_PAGE_NUMBER * AUDIO_DMA_OUT_PAGE_SIZE)
+#define AUDIO_DMA_IN_BUF_SIZE   (AUDIO_DMA_PAGE_NUMBER * AUDIO_DMA_IN_PAGE_SIZE)
+
+//===================== Register Configuration Constants ======================
+
+#define IIS_INTERNAL_CLOCK_ENABLE       (1<<17)                 // Enable CPU clock to IIS controller
+
+//----- GPIO Configuration Masks -----
+#define ENABLE_I2SSDO                   0x00000200
+#define ENABLE_I2SSDI                   0x00000080
+#define ENABLE_I2SCDCLK                 0x00000020
+#define ENABLE_I2SSCLK                  0x00000008
+#define ENABLE_I2SLRCLK                 0x00000002
+#define DISABLE_I2S_PULLUPS             0x0000001F
+
+//----- Register definitions for IISCON control register (global config register) -----
+#define LR_CHANNEL_INDEX                0x00000100              // Left/right channel index         (read-only)     
+#define TRANSMIT_FIFO_READY             0x00000080              // Indicates transmit FIFO is ready (read-only)
+#define RECEIVE_FIFO_READY              0x00000040              // Indicates receive FIFO is ready  (read-only)
+#define TRANSMIT_DMA_REQUEST_ENABLE     0x00000020              // Enables transmit DMA request
+#define RECEIVE_DMA_REQUEST_ENABLE      0x00000010              // Enables receive DMA request
+#define TRANSMIT_IDLE_CMD               0x00000008              // Pauses transmit
+#define RECEIVE_IDLE_CMD                0x00000004              // Pauses receive
+#define IIS_PRESCALER_ENABLE            0x00000002              // Enables clock prescaler
+#define IIS_INTERFACE_ENABLE            0x00000001              // Enables IIS controller
+
+//----- Register definitions for IISMOD status register (global status register) -----
+#define IIS_MASTER_MODE                 0x00000000              // Selects master/slave mode
+#define IIS_SLAVE_MODE                  0x00000100              
+#define IIS_NOTRANSFER_MODE             0x00000000              // Selects transfer mode
+#define IIS_RECEIVE_MODE                0x00000040
+#define IIS_TRANSMIT_MODE               0x00000080
+#define IIS_TRANSMIT_RECEIVE_MODE       0x000000C0
+#define ACTIVE_CHANNEL_LEFT             0x00000000              // Selects active channel
+#define ACTIVE_CHANNEL_RIGHT            0x00000020
+#define SERIAL_INTERFACE_IIS_COMPAT     0x00000000              // Selects serial interface format
+#define SERIAL_INTERFACE_MSBL_COMPAT    0x00000010
+#define DATA_8_BITS_PER_CHANNEL         0x00000000              // Selects # of data bits per channel
+#define DATA_16_BITS_PER_CHANNEL        0x00000008              
+#define MASTER_CLOCK_FREQ_256fs         0x00000000              // Selects master clock frequency
+#define MASTER_CLOCK_FREQ_384fs         0x00000004              
+#define SERIAL_BIT_CLOCK_FREQ_16fs      0x00000000              // Selects serial data bit clock frequency
+#define SERIAL_BIT_CLOCK_FREQ_32fs      0x00000001              
+#define SERIAL_BIT_CLOCK_FREQ_48fs      0x00000002              
+
+
+//----- Register definitions for IISPSR control register (global config register) -----
+//      FORMAT:         bits[9:5] - Prescaler Control A
+//                      bits[4:0] - Prescaler Control B
+//
+//                      Range: 0-31 and the division factor is N+1 (a.k.a. 1-32)
+//
+//      The I2SLRCLK frequency is determined as follows:
+//
+//              I2SLRCLK = CODECLK / I2SCDCLK       and     (prescaler+1) = PCLK / CODECLK
+//
+//      Thus, rearranging the equations a bit we can see that:
+//
+//              prescaler = (PCLK / CODECLK) - 1 
+//      or
+//              prescaler = ((PCLK / (IS2LRCLK * IS2CDCLK)) - 1
+//      
+// Here are some popular values for IS2LRCLK:
+//      
+#define IS2LRCLK_800                    800
+#define IS2LRCLK_11025                  11025
+#define IS2LRCLK_16000                  16000
+#define IS2LRCLK_22050                  22050
+#define IS2LRCLK_32000                  32000
+#define IS2LRCLK_44100                  44100
+#define IS2LRCLK_48000                  48000
+#define IS2LRCLK_64000                  64000
+#define IS2LRCLK_88200                  88200
+#define IS2LRCLK_96000                  96000
+    
+
+//----- Register definitions for IISFCON control register (global config register) -----
+#define TRANSMIT_FIFO_ACCESS_NORMAL     0x00000000              // Selects the transmit FIFO access mode
+#define TRANSMIT_FIFO_ACCESS_DMA        0x00008000              
+#define RECEIVE_FIFO_ACCESS_NORMAL      0x00000000              // Selects the receive FIFO access mode
+#define RECEIVE_FIFO_ACCESS_DMA         0x00004000              
+#define TRANSMIT_FIFO_ENABLE            0x00002000              // Enables transmit FIFO
+#define RECEIVE_FIFO_ENABLE             0x00001000              // Enables receive FIFO
+//
+// READ-ONLY Fields:    bits[11:6] - Transmit FIFO datacount
+//                      bits[5:0]  - Receive FIFO datacount
+
+//----- Register definitions for IISFIFO control register (global config register) -----
+//      NOTE: This register is used to access the transmit/receive FIFO
+#define MAX_TRANSMIT_FIFO_ENTRIES       24
+#define MAX_RECEIVE_FIFO_ENTRIES        24
+
+#endif
Index: linux-2.6.29/sound/soc/tcc/tcc-loopback.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/sound/soc/tcc/tcc-loopback.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,177 @@
+/*
+ * linux/sound/soc/tcc/tcc-loopback.c
+ *
+ * Author:  <linux@telechips.com>
+ * Created:     Nov 25, 2008
+ * Description: ALSA loopback driver
+ *
+ * Copyright (C) 2008-2009 Telechips 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see the file COPYING, or write
+ * to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+#include <linux/delay.h>
+#include <linux/poll.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+
+#include "tcc-loopback.h"
+
+/* static function */
+static void alb_lock(tcc_alsa_lb_handle_t *h)
+{
+    mutex_lock(&(h->alb_mutex));
+}
+
+static void alb_unlock(tcc_alsa_lb_handle_t *h)
+{
+    mutex_unlock(&(h->alb_mutex));
+}
+
+static int alb_init(tcc_alsa_lb_handle_t *h)
+{
+    if (h) {
+        init_waitqueue_head(&(h->wait_q));
+        mutex_init(&(h->alb_mutex));
+        return 0;
+    }
+    return -1;
+}
+
+static int alb_get_pop_size(tcc_alsa_lb_handle_t *h)
+{
+    if (h) {
+        if (h->top != h->bottom) {
+            return ((h->top > h->bottom)
+                    ? h->top - h->bottom : h->top + (h->lb_buf_size - h->bottom));
+        }
+    }
+    return 0;
+}
+
+static int alb_pop_user(tcc_alsa_lb_handle_t *h, char *p_buf, int buf_size)
+{
+    if (h && p_buf) {
+        int pop_size = alb_get_pop_size(h);
+
+        if (pop_size > buf_size) {
+            pop_size = buf_size;
+        }
+
+        if (pop_size > 0) {
+            if ((h->lb_buf_size - h->bottom) < pop_size) {
+                /* end of buffer */
+                int first_copy_size = h->lb_buf_size - h->bottom;
+                copy_to_user(p_buf, h->p_lb_buf + h->bottom, first_copy_size);
+                copy_to_user(p_buf + first_copy_size, h->p_lb_buf, pop_size - first_copy_size);
+                h->bottom = pop_size - first_copy_size;
+
+            } else {
+                copy_to_user(p_buf, h->p_lb_buf + h->bottom, pop_size);
+                h->bottom += pop_size;
+                if (h->bottom >= h->lb_buf_size) {
+                    h->bottom = 0;
+                }
+            }
+            return pop_size;
+        }
+        return 0;
+    }
+    return -1;
+}
+
+static int alb_push(tcc_alsa_lb_handle_t *h, char *p_buf, int buf_size)
+{
+    if (h && p_buf) {
+        if (h->lb_buf_size > buf_size) {
+            if ((h->lb_buf_size - h->top) < buf_size) {
+                /* end of buffer */
+                int first_copy_size = h->lb_buf_size - h->top;
+                memcpy(h->p_lb_buf + h->top, p_buf, first_copy_size);
+                memcpy(h->p_lb_buf, p_buf + first_copy_size, buf_size - first_copy_size);
+                h->top = buf_size - first_copy_size;
+            } else {
+                memcpy(h->p_lb_buf + h->top, p_buf, buf_size);
+                h->top += buf_size;
+                if (h->top >= h->lb_buf_size) {
+                    h->top = 0;
+                }
+            }
+        }
+    }
+    return -1;
+}
+
+static void alb_set_dma_info(tcc_alsa_lb_handle_t *h,
+                             unsigned int cur_dma_addr,
+                             unsigned int dma_addr,
+                             unsigned int dma_size,
+                             char *v_addr)
+{
+    h->cur_dma_addr = cur_dma_addr;
+    h->dma_addr = dma_addr;
+    h->dma_size = dma_size;
+    h->v_addr = v_addr;
+}
+
+/* extern function */
+tcc_alsa_lb_handle_t *new_alsa_lb(int dma_buf_size)
+{
+    tcc_alsa_lb_handle_t *handle = NULL;
+
+    handle = (struct tcc_alsa_lb_handle *)kmalloc(sizeof(tcc_alsa_lb_handle_t), GFP_KERNEL);
+    if (handle && dma_buf_size >= 1024) {
+        memset(handle, 0, sizeof(tcc_alsa_lb_handle_t));
+        handle->p_lb_buf = (char *)kmalloc(dma_buf_size, GFP_KERNEL);
+        if (handle->p_lb_buf) {
+            handle->lb_buf_size = dma_buf_size;
+            handle->init = alb_init;
+            handle->get_pop_size = alb_get_pop_size;
+            handle->pop_user = alb_pop_user;
+            handle->push = alb_push;
+
+            handle->lock = alb_lock;
+            handle->unlock = alb_unlock;
+
+            handle->set_dma_info = alb_set_dma_info;
+        } else {
+            printk("[%s:%d] cannot allocate memory !!!\n", __func__, __LINE__);
+            handle = delete_alsa_lb(handle);
+        }
+    }
+    return handle;
+}
+
+tcc_alsa_lb_handle_t *delete_alsa_lb(tcc_alsa_lb_handle_t *h)
+{
+    if (h) {
+        if (h->p_lb_buf) {
+            kfree(h->p_lb_buf);
+            h->p_lb_buf = NULL;
+        }
+        kfree(h);
+    }
+    return NULL;
+}
+
+
Index: linux-2.6.29/sound/soc/tcc/tcc-loopback.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/sound/soc/tcc/tcc-loopback.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,74 @@
+/*
+ * linux/sound/soc/tcc/tcc-loopback.h
+ *
+ * Author:  <linux@telechips.com>
+ * Created:     Nov 25, 2008
+ * Description: ALSA loopback driver
+ *
+ * Copyright (C) 2008-2009 Telechips 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see the file COPYING, or write
+ * to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#ifndef __TCC_LOOPBACK_H__
+#define __TCC_LOOPBACK_H__
+
+#define LOOPBACK_MAJOR_NUM 245
+#define DEVICE_NAME	"tcc_alsa_loopback"
+
+typedef struct tcc_alsa_lb_handle tcc_alsa_lb_handle_t;
+struct tcc_alsa_lb_handle {
+    int open_cnt;
+	wait_queue_head_t wait_q;
+
+    /* queue */
+    int top, bottom;
+    int lb_buf_size;
+    char *p_lb_buf;
+
+    /* dam */
+    unsigned int cur_dma_addr;
+    unsigned int dma_addr;
+    unsigned int dma_size;
+    char *v_addr;
+
+    struct mutex alb_mutex;
+
+    int (*init)(tcc_alsa_lb_handle_t *h);
+    int (*get_pop_size)(tcc_alsa_lb_handle_t *h);
+    int (*pop_user)(tcc_alsa_lb_handle_t *h, char *p_buf, int buf_size);
+    int (*push)(tcc_alsa_lb_handle_t *h, char *p_buf, int buf_size);
+    void (*lock)(tcc_alsa_lb_handle_t *h);
+    void (*unlock)(tcc_alsa_lb_handle_t *h);
+    void (*set_dma_info)(tcc_alsa_lb_handle_t *h,
+                         unsigned int cur_dma_addr,
+                         unsigned int dma_addr,
+                         unsigned int dma_size,
+                         char *v_addr);
+
+
+};
+
+extern tcc_alsa_lb_handle_t *new_alsa_lb(int dma_buf_size);
+extern tcc_alsa_lb_handle_t *delete_alsa_lb(tcc_alsa_lb_handle_t *h);
+
+#define ALB_START(H) do { if ((H)) { (H)->open_cnt++; } } while (0)
+#define ALB_STOP(H) do { if ((H)) { if ((H)->open_cnt > 0) (H)->open_cnt--; } } while (0)
+
+
+#endif /* __TCC_LOOPBACK_H__ */
+
Index: linux-2.6.29/sound/soc/tcc/tcc-pcm.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/sound/soc/tcc/tcc-pcm.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,918 @@
+/*
+ * linux/sound/soc/tcc/tcc-pcm.c  
+ *
+ * Based on:    linux/sound/arm/pxa2xx-pcm.c
+ * Author:  <linux@telechips.com>
+ * Created: Nov 30, 2004
+ * Modified:    Nov 25, 2008
+ * Description: ALSA PCM interface for the Intel PXA2xx chip
+ *
+ * Copyright:	MontaVista Software, Inc.
+ * Copyright (C) 2008-2009 Telechips 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see the file COPYING, or write
+ * to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+
+#include <linux/delay.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include <bsp.h>
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+#include <mach/tca_ckc.h>
+
+#include "tcc-i2s.h"
+#include "tcc-pcm.h"
+
+#include "tcc/tca_tcchwcontrol.h"
+
+#define alsa_dbg(f, a...)  printk("== alsa-debug == " f, ##a)
+//#define alsa_dbg(f, a...)
+
+tcc_interrupt_info_x tcc_alsa_info;
+EXPORT_SYMBOL(tcc_alsa_info);
+
+static const struct snd_pcm_hardware tcc_pcm_hardware_play = {
+    .info = (SNDRV_PCM_INFO_MMAP
+             | SNDRV_PCM_INFO_MMAP_VALID
+             | SNDRV_PCM_INFO_INTERLEAVED
+             | SNDRV_PCM_INFO_BLOCK_TRANSFER
+             | SNDRV_PCM_INFO_PAUSE
+             | SNDRV_PCM_INFO_RESUME),
+
+    .formats = (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE),
+    .rates      = SNDRV_PCM_RATE_8000_48000,
+    .rate_min   = 8000,
+    .rate_max   = 48000, 
+    .channels_min = 2,
+#if defined(CONFIG_SND_SOC_WM8581) || defined(CONFIG_SND_SOC_WM8581_MODULE)
+    .channels_max = 8,                                
+#else
+    .channels_max = 2,                                
+#endif
+
+#if 1
+    .period_bytes_min = __play_buf_size,
+    .period_bytes_max = __play_buf_size,
+    .periods_min = __play_buf_cnt,
+    .periods_max = __play_buf_cnt,
+    .buffer_bytes_max = __play_buf_cnt * __play_buf_size,
+    .fifo_size = 16,  //ignored
+#else
+    .period_bytes_min = 128,
+    .period_bytes_max = __play_buf_cnt * __play_buf_size,
+    .periods_min = 1,
+    .periods_max = __play_buf_cnt,
+    .buffer_bytes_max = __play_buf_cnt * __play_buf_size,
+    .fifo_size = 16,  //ignored
+#endif
+};
+
+static const struct snd_pcm_hardware tcc_pcm_hardware_capture = {
+    .info = (SNDRV_PCM_INFO_MMAP
+             | SNDRV_PCM_INFO_MMAP_VALID
+             | SNDRV_PCM_INFO_INTERLEAVED
+             | SNDRV_PCM_INFO_BLOCK_TRANSFER
+             | SNDRV_PCM_INFO_PAUSE
+             | SNDRV_PCM_INFO_RESUME),
+
+    .formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,
+    .rates      = SNDRV_PCM_RATE_8000_48000,
+    .rate_min   = 8000,
+    .rate_max   = 48000, 
+    .channels_min = 2,
+    .channels_max = 2,                                
+
+#if 1
+    .period_bytes_min = __cap_buf_size,
+    .period_bytes_max = __cap_buf_size,
+    .periods_min = __cap_buf_cnt,
+    .periods_max = __cap_buf_cnt,
+    .buffer_bytes_max = __cap_buf_cnt * __cap_buf_size,
+    .fifo_size = 16, //ignored
+#else
+    .period_bytes_min = 128,
+    .period_bytes_max = __cap_buf_cnt * __cap_buf_size,
+    .periods_min = 1,
+    .periods_max = __cap_buf_cnt,
+    .buffer_bytes_max = __cap_buf_cnt * __cap_buf_size,
+    .fifo_size = 16, //ignored
+#endif
+};
+
+/*** tea module ***/
+static unsigned int io_ckc_get_dai_clock(unsigned int freq)
+{
+    switch (freq) {
+    default:
+    case 44100: return ((441 * 256) / 10);
+    case 22000: return (((22050 * 256) / 100) / 10);
+    case 11000: return (((11025 * 256) / 100) / 10);
+    case 22050:
+    case 11025:
+    case 48000:
+    case 24000:
+    case 12000:
+    case  8000:
+    case 32000:
+    case 16000: return (((freq * 256) / 100) / 10);
+    }
+    return 0;
+}
+
+static int alsa_get_intr_num(struct snd_pcm_substream *substream)
+{
+    if (substream) {
+        return IRQ_ADMA;
+    }
+    return -1;
+}
+
+void tea_i2s_setclock(unsigned int clock_rate)
+{
+    unsigned int ckc = 0;
+    ckc = io_ckc_get_dai_clock(clock_rate);
+    tca_ckc_setperi(PERI_DAI, 1, ckc * 10, DIRECTPLL2);
+}
+EXPORT_SYMBOL(tea_i2s_setclock);
+
+void tea_spdif_setclock(unsigned int clock_rate)
+{
+    unsigned int daihz = 0;
+    unsigned tmpCfg, tmpStatus;	
+    volatile ADMASPDIFTX *p_adma_spdif_tx_base = (volatile ADMASPDIFTX *)tcc_p2v(HwADMA_SPDIFTXBASE);
+
+    daihz = ((clock_rate * 512) / 100);
+    tca_ckc_setperi(PERI_SPDIF, ENABLE, daihz, DIRECTPLL2);
+
+    tmpCfg = p_adma_spdif_tx_base->TxConfig;
+    tmpStatus = p_adma_spdif_tx_base->TxChStat;
+
+    if (clock_rate == 44100) { /* 44.1KHz */
+        p_adma_spdif_tx_base->TxConfig = ((tmpCfg & 0xFFFF00FF) | (2 << 8));
+        p_adma_spdif_tx_base->TxChStat = ((tmpStatus & 0xFFFFFF3F) | (0/*FREQ_44_1KHz*/ << 6));
+    } else if (clock_rate == 48000) { /* 48KHz */
+        p_adma_spdif_tx_base->TxConfig = ((tmpCfg & 0xFFFF00FF) | (2 << 8));
+        p_adma_spdif_tx_base->TxChStat = ((tmpStatus & 0xFFFFFF3F) | (1/*FREQ_48KHz*/ << 6));
+    } else if (clock_rate == 32000) { /* 32KHz */
+        p_adma_spdif_tx_base->TxConfig = ((tmpCfg & 0xFFFF00FF) | (2 << 8));
+        p_adma_spdif_tx_base->TxChStat = ((tmpStatus & 0xFFFFFF3F) | (2/*FREQ_32KHz*/ << 6));
+    } else { /* Sampling Rate Converter */
+        p_adma_spdif_tx_base->TxConfig = ((tmpCfg & 0xFFFF00FF) | (2 << 8));
+        p_adma_spdif_tx_base->TxChStat = ((tmpStatus & 0xFFFFFF3F) | (3/*FREQ_SRC*/ << 6));
+    }
+}
+EXPORT_SYMBOL(tea_spdif_setclock);
+
+
+static void set_dma_outbuffer(unsigned int addr, unsigned int length, unsigned int period)
+{
+    volatile PADMA pADMA = (volatile PADMA)tcc_p2v(HwADMA_BASE);
+    unsigned long dma_buffer = 0;
+
+    alsa_dbg("%s, addr[0x%08X], len[%u], period[%u]\n", __func__, addr, length, period);
+    BITCLR(pADMA->ChCtrl, Hw28);
+
+    dma_buffer = 0xFFFFFF00 / (((tcc_pcm_hardware_play.buffer_bytes_max) >> 4) << 8);
+    dma_buffer = dma_buffer * (((tcc_pcm_hardware_play.buffer_bytes_max) >> 4) << 8);
+
+    pADMA->TxDaParam = dma_buffer | 4;
+
+    // generate interrupt when half of buffer was played
+    pADMA->TxDaTCnt = (period >> 0x04) - 1;
+
+    alsa_dbg("[%s] HwTxDaParam [0x%X]\n", __func__, (int)(dma_buffer | 4));
+    alsa_dbg("[%s] HwTxDaTCnt [%d]\n", __func__, ((period) >> 0x04) - 1);
+    pADMA->TxDaSar = addr;
+
+    pADMA->TransCtrl |= (Hw28 | Hw16 | Hw9 | (Hw0 | Hw1) | Hw24);
+
+    pADMA->RptCtrl = 0;
+    BITCLR(pADMA->RptCtrl, Hw31);
+    if (length < tcc_pcm_hardware_play.buffer_bytes_max) {
+        BITSET(pADMA->RptCtrl, (length / period) - 1);
+    }
+
+    pADMA->ChCtrl |= (Hw28 | Hw12 | Hw0);
+}
+
+static void set_dma_spdif_outbuffer(unsigned int addr, unsigned int length, unsigned int period)
+{
+    volatile PADMA pADMA = (volatile PADMA)tcc_p2v(HwADMA_BASE);
+	volatile ADMASPDIFTX *p_adma_spdif_tx_base = (volatile ADMASPDIFTX *)tcc_p2v(HwADMA_SPDIFTXBASE);
+    unsigned long dma_buffer = 0;
+
+    alsa_dbg("%s, addr[0x%08X], len[%u], period[%u]\n", __func__, addr, length, period);
+    BITCLR(pADMA->ChCtrl, Hw29);
+
+	memset((void *)p_adma_spdif_tx_base->UserData, 0, 24);
+	memset((void *)p_adma_spdif_tx_base->ChStatus, 0, 24);
+	memset((void *)p_adma_spdif_tx_base->TxBuffer, 0, 128);
+
+    dma_buffer = 0xFFFFFF00 / (((tcc_pcm_hardware_play.buffer_bytes_max) >> 4) << 8);
+    dma_buffer = dma_buffer * (((tcc_pcm_hardware_play.buffer_bytes_max) >> 4) << 8);
+
+    pADMA->TxSpParam = dma_buffer | 4;
+
+    // generate interrupt when half of buffer was played
+    pADMA->TxSpTCnt = (period >> 0x04) - 1;
+
+    alsa_dbg("[%s] HwTxDaParam [0x%X]\n", __func__, (int)(dma_buffer | 4));
+    alsa_dbg("[%s] HwTxDaTCnt [%d]\n", __func__, ((period) >> 0x04) - 1);
+    pADMA->TxSpSar = addr;
+
+    pADMA->TransCtrl |= (Hw28 | Hw17 | Hw11 | (Hw3 | Hw2));
+
+    pADMA->RptCtrl = 0;
+    BITCLR(pADMA->RptCtrl, Hw31);
+    if (length < tcc_pcm_hardware_play.buffer_bytes_max) {
+        BITSET(pADMA->RptCtrl, (length / period) - 1);
+    }
+
+    //pADMA->ChCtrl |= (Hw29 | Hw13 | Hw1);
+    //pADMA->ChCtrl |= (Hw29 | Hw13);
+
+
+    {
+        //unsigned int bitSet = 0x0;
+
+        p_adma_spdif_tx_base->TxConfig = HwZERO
+            //16bits 
+            |Hw9|Hw8 //Clock Divider Ratio is 2(384*fs to default)
+            //| Hw7 | Hw6 //User Data Enalbe Bits is set reserved
+            //| Hw5 | Hw4 //Channel Status Enalbe Bits is set reserved
+            //| Hw2 //interrupt output enable
+            | Hw1 //data being valid
+            //| Hw0 //enable the transmission
+            ;
+        //Set SPDIF Transmit Channel Status
+        p_adma_spdif_tx_base->TxChStat |= HwZERO
+            //| 0x00000400 // Store Channel Status bit
+            //| 0x00000200 // Store User Data bit
+            //| 0x00000100 // Store Validity bit
+            //44.1kHz
+            //| Hw3 //Original/Commercially Pre-recored data
+            //| Hw2 //Pre-emphasis is 50/15us
+            //| Hw1 //Copy permitted
+            //Audio format
+            ;		
+
+        //p_adma_spdif_tx_base->TxIntMask = HwZERO
+        //	| Hw2//Higher Data buffer is empty
+        //	| Hw1//Lower Data buffer is empty
+        //	;
+
+        p_adma_spdif_tx_base->DMACFG = Hw7;
+        msleep(100);
+
+        p_adma_spdif_tx_base->DMACFG = HwZERO
+            //| Hw14	//Swap Sample Enable
+            | Hw13 	//Read Address 16bit Mode
+            | Hw11	//DMA Request enable for user data buffer
+            | Hw10	//DMA Request enable for sample data buffer
+            //| Hw8	//Enable address
+            //| Hw3	//FIFO Threshold for DMA request
+            | Hw1| Hw0	// [3:0] FIFO Threshold for DMA Request
+            ;
+
+        /* Initialize Sample Data Buffer */
+        //while(p_adma_spdif_tx_base->DMACFG & 0x00300000) p_adma_spdif_tx_base->TxBuffer[0] = 0;
+        p_adma_spdif_tx_base->TxBuffer[0] = 0;
+
+        p_adma_spdif_tx_base->TxConfig |= HwZERO
+            //| Hw2 //interrupt output enable
+            | Hw1 //data being valid
+            | Hw0 //enable the transmission
+            ;
+
+#if 0
+        while((p_adma_spdif_tx_base->DMACFG & 0x00100000)); /* Wait until first data TX */
+        while((p_adma_spdif_tx_base->DMACFG & 0x001F0000) > 0x00080000);
+
+        while(!(p_adma_spdif_tx_base->TxIntStat & Hw1));	/* Wait for Interrupt Status */
+#endif
+
+        p_adma_spdif_tx_base->TxIntStat = 0x1E; /* Clear Interrupt Status */
+
+#if 0
+        p_adma_spdif_tx_base->TxConfig |= HwZERO
+            | Hw2 //interrupt output enable
+            | Hw1 //data being valid
+            //| Hw0 //enable the transmission
+            ;
+
+        // Tx channel Control Register Setting	
+        //Start DMA
+        bitSet = ( HwZERO
+                   |Hw1 //Interrupt Enable of SPDIF Tx	
+                 );
+
+        pADMA->ChCtrl |= bitSet;
+#endif
+    }
+
+    alsa_dbg("%s, spdif current addr[0x%08X] \n", __func__, pADMA->TxSpCsar);
+    pADMA->ChCtrl |= (Hw13);
+}
+
+static void set_dma_inbuffer(unsigned int addr, unsigned int length, unsigned int period)
+{
+    volatile PADMA pADMA = (volatile PADMA)tcc_p2v(HwADMA_BASE);
+    unsigned long dma_buffer = 0;
+
+    alsa_dbg("%s, addr[0x%08X], len[%d]\n", __func__, addr, length);
+
+    BITCLR(pADMA->ChCtrl, Hw30);
+
+    dma_buffer = 0xFFFFFF00 / (((tcc_pcm_hardware_capture.buffer_bytes_max) >> 4) << 8);
+    dma_buffer = dma_buffer * (((tcc_pcm_hardware_capture.buffer_bytes_max) >> 4) << 8);
+
+    //dma_buffer = 0xFFFFF8000;
+    pADMA->RxDaParam = dma_buffer | 4;
+
+    // generate interrupt when half of buffer was filled
+    pADMA->RxDaTCnt = (period >> 0x04) - 1;
+
+    alsa_dbg("[%s] HwRxDaParam [0x%X]\n", __func__, (int)dma_buffer | 4);
+    alsa_dbg("[%s] HwRxDaTCnt [%d]\n", __func__, ((period) >> 0x04) - 1);
+    pADMA->RxDaDar = addr;
+
+    pADMA->TransCtrl |= (Hw29 | Hw18 | Hw13 | (Hw4 | Hw5) | Hw26);
+
+    //pADMA->RptCtrl = 0;
+    BITCLR(pADMA->RptCtrl, Hw31);
+    if (length<tcc_pcm_hardware_capture.buffer_bytes_max) {
+        BITSET(pADMA->RptCtrl, (length / period) - 1);
+    }
+
+    pADMA->ChCtrl |= (Hw30 | Hw14 | Hw2);
+}
+
+static irqreturn_t tcc_dma_done_handler(int irq, void *dev_id)
+{
+    volatile PADMA pADMA = (volatile PADMA)tcc_p2v(HwADMA_BASE);
+    struct snd_pcm_runtime *runtime;
+    struct tcc_runtime_data *prtd;
+    dma_addr_t cur_ptr;
+    int dmaInterruptSource = 0;
+
+    unsigned long reg_temp = 0;                 
+
+    if (pADMA->IntStatus & (Hw4 | Hw0)) {
+        dmaInterruptSource |= DMA_CH_OUT;
+        reg_temp |= Hw4 | Hw0;
+    }
+    if (pADMA->IntStatus & (Hw6 | Hw2)) {
+        dmaInterruptSource |= DMA_CH_IN;
+        reg_temp |= Hw6 | Hw2;
+    }
+    if (pADMA->IntStatus & (Hw5 | Hw1)) {
+        dmaInterruptSource |= DMA_CH_SPDIF;
+        reg_temp |= Hw5 | Hw1;
+    }
+
+    if (reg_temp) { 
+        pADMA->IntStatus |= reg_temp;
+    }
+
+    if ((dmaInterruptSource & DMA_CH_SPDIF)
+        && (tcc_alsa_info.flag & TCC_RUNNING_SPDIF)) {
+
+        snd_pcm_period_elapsed(tcc_alsa_info.spdif_ptr);
+
+        runtime = tcc_alsa_info.spdif_ptr->runtime;
+        prtd = (struct tcc_runtime_data *)runtime->private_data;
+
+        cur_ptr = pADMA->TxSpCsar; 
+        if (prtd->dma_buffer_end <= cur_ptr) {           
+            BITSET(pADMA->ChCtrl, Hw29);
+        }
+    }
+
+    if ((dmaInterruptSource & DMA_CH_OUT)
+        && (tcc_alsa_info.flag & TCC_RUNNING_PLAY)) {
+        snd_pcm_period_elapsed(tcc_alsa_info.play_ptr);
+
+        runtime = tcc_alsa_info.play_ptr->runtime;
+        prtd = (struct tcc_runtime_data *) runtime->private_data;
+
+        cur_ptr = pADMA->TxDaCsar; 
+        if (prtd->dma_buffer_end <= cur_ptr) {           
+            BITSET(pADMA->ChCtrl, Hw28);
+        }
+    }
+    if ((dmaInterruptSource & DMA_CH_IN)
+        && (tcc_alsa_info.flag & TCC_RUNNING_CAPTURE)) {
+        snd_pcm_period_elapsed(tcc_alsa_info.cap_ptr);
+
+        runtime = tcc_alsa_info.cap_ptr->runtime;
+        prtd = (struct tcc_runtime_data *)runtime->private_data;
+
+        cur_ptr = pADMA->RxDaCdar; 
+        if (prtd->dma_buffer_end <= cur_ptr) {           
+            BITSET(pADMA->ChCtrl, Hw30);
+        }       
+    }
+
+    return IRQ_HANDLED;
+}
+
+static int tcc_pcm_hw_params(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params)
+{
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    struct tcc_runtime_data *prtd = runtime->private_data;
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    struct tcc_pcm_dma_params *dma = rtd->dai->cpu_dai->dma_data;
+    size_t totsize = params_buffer_bytes(params);
+    //size_t period = params_period_bytes(params); 
+    size_t period_bytes = params_period_bytes(params); 
+    int chs = params_channels(params);
+    int ret = 0;
+
+    /* return if this is a bufferless transfer e.g.
+     * codec <--> BT codec or GSM modem -- lg FIXME */
+    if (!dma)
+        return 0;      
+
+    /* this may get called several times by oss emulation
+     * with different params */
+    if (prtd->params == NULL) {
+        prtd->params = dma;
+
+        mutex_lock(&(tcc_alsa_info.mutex));
+        if (!(tcc_alsa_info.flag & TCC_INTERRUPT_REQUESTED)) {
+            ret = request_irq(alsa_get_intr_num(substream),
+                              tcc_dma_done_handler,
+                              IRQF_SHARED,
+                              "alsa-audio",
+                              &tcc_alsa_info);
+            if (ret < 0) {
+                mutex_unlock(&(tcc_alsa_info.mutex));
+                return -EBUSY;
+            }
+            tcc_alsa_info.flag |= TCC_INTERRUPT_REQUESTED;
+        }
+        mutex_unlock(&(tcc_alsa_info.mutex));
+
+        if (substream->pcm->device == __SPDIF_DEV_NUM__) {
+            prtd->dma_ch = DMA_CH_SPDIF;
+        } else {
+            prtd->dma_ch = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? DMA_CH_OUT : DMA_CH_IN;
+        }
+    } else {
+        /* should works more? */
+    }        
+
+    //DMA  
+    //DMA     
+
+    //printk("ssssssssssssssssssssssubstream addr [%p]\n", substream);
+    snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);        
+    runtime->dma_bytes = totsize;
+
+    prtd->dma_buffer_end = runtime->dma_addr + totsize;
+    prtd->dma_buffer = runtime->dma_addr;
+    alsa_dbg("\n totsize=0x%X period=0x%X  period num=%d\n", totsize, period_bytes, params_periods(params));
+
+
+    if (substream->pcm->device == __SPDIF_DEV_NUM__) {
+        if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+            set_dma_spdif_outbuffer(substream->dma_buffer.addr, totsize, period_bytes);
+        } else {
+            printk("cannot support S/PDIF capture !!!!!\n");
+            return -1;
+        }
+    } else {
+        if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+            set_dma_outbuffer(substream->dma_buffer.addr, totsize, period_bytes);
+        } else {
+            set_dma_inbuffer(substream->dma_buffer.addr, totsize, period_bytes);
+        }
+    }
+
+    {
+        volatile PADMA pADMA = (volatile PADMA)tcc_p2v(HwADMA_BASE);
+        volatile PADMADAI pADMA_DAI = (volatile PADMADAI)tcc_p2v(HwADMA_DAIBASE);
+        if (chs > 2) {
+            pADMA_DAI->DAMR |= (Hw29 | Hw28);
+            pADMA->RptCtrl |= (Hw26 | Hw25 | Hw24);
+            pADMA->ChCtrl |= (Hw24 | Hw21 | Hw20);
+        } else {
+            BITCLR(pADMA_DAI->DAMR, (Hw29 | Hw28));
+            BITCLR(pADMA->RptCtrl, (Hw26 | Hw25 | Hw24));
+            BITCLR(pADMA->ChCtrl,(Hw24 | Hw21 | Hw20));
+        }
+    }
+    printk("======================================\n");
+    printk("    set [%d] channels\n", chs);
+    printk("======================================\n");
+    return ret;
+}
+
+static int tcc_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+    struct tcc_runtime_data *prtd = substream->runtime->private_data;
+
+    if (prtd->dma_ch) {
+        snd_pcm_set_runtime_buffer(substream, NULL);
+        //   ??
+    }
+
+    return 0;
+}
+
+static int tcc_pcm_prepare(struct snd_pcm_substream *substream)
+{
+    struct snd_pcm_runtime *runtime = substream->runtime;
+
+    //DMA initialize
+
+    /* Disable Noise */
+    //memset((void *)(&HwDADO_L0), 0, 32);
+
+#if 0
+    if (substream->pcm->device == __SPDIF_DEV_NUM__) {
+        volatile PADMA pADMA = (volatile PADMA)tcc_p2v(HwADMA_BASE);
+        printk("---------------------------------\n");
+        printk("* spdif current addr [0x%X] - prepare\n", pADMA->TxSpCsar);
+        printk("---------------------------------\n");
+    }
+#endif
+
+    memset(runtime->dma_area, 0x00, runtime->dma_bytes);
+
+    return 0;
+}
+
+static int tcc_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+    //struct tcc_runtime_data *prtd = substream->runtime->private_data;
+    //    audio_stream_t *s = &output_stream;        
+    int ret = 0;
+    volatile PADMADAI pDAI = (volatile PADMADAI)tcc_p2v(HwADMA_DAIBASE);
+    volatile PADMA pADMA = (volatile PADMA)tcc_p2v(HwADMA_BASE);
+	volatile ADMASPDIFTX *p_adma_spdif_tx_base = (volatile ADMASPDIFTX *)tcc_p2v(HwADMA_SPDIFTXBASE);
+
+    switch (cmd) {
+    case SNDRV_PCM_TRIGGER_START:
+    case SNDRV_PCM_TRIGGER_RESUME:        
+    case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+        if (substream->pcm->device == __SPDIF_DEV_NUM__) {
+#if 0
+            //tca_i2s_start(pDAI, p_adma_spdif_tx_base, 0);
+            p_adma_spdif_tx_base->TxIntStat = 0x1E;		/* Clear Interrupt Status */
+            p_adma_spdif_tx_base->TxConfig |= HwZERO | Hw0;
+            BITSET(pADMA->ChCtrl, Hw1 | Hw29);
+#else
+            p_adma_spdif_tx_base->TxConfig |= HwZERO | Hw0 | Hw2 | Hw1;
+            BITSET(pADMA->ChCtrl, Hw1 | Hw29);
+#endif
+        } else {
+            if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+                //tca_i2s_start(pDAI, p_adma_spdif_tx_base, 0);
+                pDAI->DAMR |= Hw14;
+                BITSET(pADMA->ChCtrl, Hw0 | Hw28);
+            } else {
+                //tca_i2s_start(pDAI, p_adma_spdif_tx_base, 1);
+                pDAI->DAMR |= Hw13;
+                BITSET(pADMA->ChCtrl, Hw2 | Hw30);
+            }
+        }
+        break;
+
+    case SNDRV_PCM_TRIGGER_STOP:
+    case SNDRV_PCM_TRIGGER_SUSPEND:
+    case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+        if (substream->pcm->device == __SPDIF_DEV_NUM__) {
+#if 0
+            //tca_i2s_stop(pDAI, p_adma_spdif_tx_base, 0);
+            p_adma_spdif_tx_base->TxConfig &= ~Hw0;
+            BITCLR(pADMA->ChCtrl, Hw1);
+#else
+            p_adma_spdif_tx_base->TxConfig &= ~(Hw0 | Hw2 | Hw1);
+            BITCLR(pADMA->ChCtrl, Hw1 | Hw29);
+#endif
+        } else {
+            if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+                //tca_i2s_stop(pDAI, p_adma_spdif_tx_base, 0);
+                pDAI->DAMR &= ~Hw14;
+                BITCLR(pADMA->ChCtrl, Hw0);
+            } else {
+                //tca_i2s_stop(pDAI, p_adma_spdif_tx_base, 1);
+                pDAI->DAMR &= ~Hw13;
+                BITCLR(pADMA->ChCtrl, Hw2);
+            }
+        }
+        if (!(tcc_alsa_info.flag)) {
+            BITCLR(pADMA->ChCtrl, Hw28);
+        }
+        break;
+
+    default:
+        ret = -EINVAL;
+    }
+    return ret;
+}
+
+
+//buffer point update
+//current position   range 0-(buffer_size-1)
+static snd_pcm_uframes_t tcc_pcm_pointer(struct snd_pcm_substream *substream)
+{
+    volatile PADMA pADMA = (volatile PADMA)tcc_p2v(HwADMA_BASE);
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    //struct tcc_runtime_data *prtd = runtime->private_data;
+    snd_pcm_uframes_t x;
+    dma_addr_t ptr = 0;
+
+    if (substream->pcm->device == __SPDIF_DEV_NUM__) {
+        ptr = pADMA->TxSpCsar;
+    } else {
+        ptr = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? pADMA->TxDaCsar : pADMA->RxDaCdar;
+    }
+
+    x = bytes_to_frames(runtime, ptr - runtime->dma_addr);
+
+    if (x < runtime->buffer_size) {
+        return x;
+    }
+    return 0;
+}
+
+static int tcc_pcm_open(struct snd_pcm_substream *substream)
+{
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    struct tcc_runtime_data *prtd;
+    int ret;
+
+    mutex_lock(&(tcc_alsa_info.mutex));
+    if (substream->pcm->device == __SPDIF_DEV_NUM__) {
+        if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+            tcc_alsa_info.flag |= TCC_RUNNING_SPDIF;
+            tcc_alsa_info.spdif_ptr = substream;
+            snd_soc_set_runtime_hwparams(substream, &tcc_pcm_hardware_play);
+        } else {
+            printk("cannot support S/PDIF capture !!!!!\n");
+            return -1;
+        }
+    } else {
+        if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {  
+            tcc_alsa_info.flag |= TCC_RUNNING_PLAY;
+            tcc_alsa_info.play_ptr = substream;
+            snd_soc_set_runtime_hwparams(substream, &tcc_pcm_hardware_play);
+        } else {
+            tcc_alsa_info.flag |= TCC_RUNNING_CAPTURE;
+            tcc_alsa_info.cap_ptr = substream;
+            snd_soc_set_runtime_hwparams(substream, &tcc_pcm_hardware_capture);
+        }
+    }
+    mutex_unlock(&(tcc_alsa_info.mutex));
+
+    prtd = kzalloc(sizeof(struct tcc_runtime_data), GFP_KERNEL);
+
+    if (prtd == NULL) {
+        ret = -ENOMEM;
+        goto out;
+    }
+    runtime->private_data = prtd;
+
+    return 0;
+    kfree(prtd);
+out:
+    return ret;
+}
+
+static int tcc_pcm_close(struct snd_pcm_substream *substream)
+{
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    struct tcc_runtime_data *prtd = runtime->private_data;
+    volatile PADMADAI pDAI = (volatile PADMADAI)tcc_p2v(HwADMA_DAIBASE);
+	volatile ADMASPDIFTX *p_adma_spdif_tx_base = (volatile ADMASPDIFTX *)tcc_p2v(HwADMA_SPDIFTXBASE);
+
+    mutex_lock(&(tcc_alsa_info.mutex));
+    if (substream->pcm->device == __SPDIF_DEV_NUM__) {
+            tcc_alsa_info.flag &= ~TCC_RUNNING_SPDIF;
+            //tca_i2s_stop(pDAI, p_adma_spdif_tx_base, 0);
+            p_adma_spdif_tx_base->TxConfig &= ~Hw0;
+
+#if 0
+            {
+                volatile PADMA pADMA = (volatile PADMA)tcc_p2v(HwADMA_BASE);
+                printk("---------------------------------\n");
+                printk("# spdif current addr [0x%X] - close\n", pADMA->TxSpCsar);
+                printk("---------------------------------\n");
+            }
+#endif
+
+    } else {
+        if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+            tcc_alsa_info.flag &= ~TCC_RUNNING_PLAY;
+            //tca_i2s_stop(pDAI, p_adma_spdif_tx_base, 0);
+            pDAI->DAMR &= ~Hw14;
+        } else {
+            tcc_alsa_info.flag &= ~TCC_RUNNING_CAPTURE;
+            //tca_i2s_stop(pDAI, p_adma_spdif_tx_base, 1);
+            pDAI->DAMR &= ~Hw13;
+        }
+    }
+    // dma_free_writecombine(substream->pcm->card->dev, PAGE_SIZE,); 
+
+    if (prtd) {
+        kfree(prtd);
+    }
+
+    if (tcc_alsa_info.flag & TCC_INTERRUPT_REQUESTED) {
+        if (!(tcc_alsa_info.flag & (TCC_RUNNING_SPDIF | TCC_RUNNING_PLAY | TCC_RUNNING_CAPTURE))) {
+            free_irq(alsa_get_intr_num(substream), &tcc_alsa_info);
+            tcc_alsa_info.flag &= ~TCC_INTERRUPT_REQUESTED;
+        }
+    }
+    mutex_unlock(&(tcc_alsa_info.mutex));
+
+    return 0;
+}
+
+static int tcc_pcm_mmap(struct snd_pcm_substream *substream, struct vm_area_struct *vma)
+{
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    return dma_mmap_writecombine(substream->pcm->card->dev,
+                                 vma,
+                                 runtime->dma_area,
+                                 runtime->dma_addr,
+                                 runtime->dma_bytes);
+}
+
+struct snd_pcm_ops tcc_pcm_ops = {
+    .open  = tcc_pcm_open,
+    .close  = tcc_pcm_close,
+    .ioctl  = snd_pcm_lib_ioctl,
+    .hw_params = tcc_pcm_hw_params,
+    .hw_free = tcc_pcm_hw_free,
+    .prepare = tcc_pcm_prepare,
+    .trigger = tcc_pcm_trigger,
+    .pointer = tcc_pcm_pointer,
+    .mmap = tcc_pcm_mmap,
+};
+
+static int tcc_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+    struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+    struct snd_dma_buffer *buf = &substream->dma_buffer;
+    size_t size = 0;
+
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        size = tcc_pcm_hardware_play.buffer_bytes_max;
+    } else {
+        size = tcc_pcm_hardware_capture.buffer_bytes_max;
+    }
+
+    buf->dev.type = SNDRV_DMA_TYPE_DEV;
+    buf->dev.dev = pcm->card->dev;
+    buf->private_data = NULL;
+
+    alsa_dbg("tcc_pcm_preallocate_dma_buffer size [%d]\n", size);
+    buf->area = dma_alloc_writecombine(pcm->card->dev, size, &buf->addr, GFP_KERNEL);
+    if (!buf->area) {
+        return -ENOMEM;
+    }
+
+    buf->bytes = size;
+
+    return 0;
+}
+
+
+static void tcc_pcm_free_dma_buffers(struct snd_pcm *pcm)
+{
+    struct snd_pcm_substream *substream;
+    struct snd_dma_buffer *buf;
+    int stream;
+
+    for (stream = 0; stream < 2; stream++) {
+        substream = pcm->streams[stream].substream;
+        if (!substream) { continue; }
+
+        buf = &substream->dma_buffer;
+        if (!buf->area) { continue; }
+
+        dma_free_writecombine(pcm->card->dev, buf->bytes, buf->area, buf->addr);
+        buf->area = NULL;
+    }
+    mutex_init(&(tcc_alsa_info.mutex));
+}
+
+static u64 tcc_pcm_dmamask = DMA_32BIT_MASK;
+
+int tcc_pcm_new(struct snd_card *card, struct snd_soc_dai *dai, struct snd_pcm *pcm)
+{
+    int ret = 0;
+
+    memset(&tcc_alsa_info, 0, sizeof(tcc_interrupt_info_x));
+    mutex_init(&(tcc_alsa_info.mutex));
+
+    if (!card->dev->dma_mask) {
+        card->dev->dma_mask = &tcc_pcm_dmamask;
+    }
+    if (!card->dev->coherent_dma_mask) {
+        card->dev->coherent_dma_mask = DMA_32BIT_MASK;
+    }
+    if (dai->playback.channels_min) {
+        ret = tcc_pcm_preallocate_dma_buffer(pcm,SNDRV_PCM_STREAM_PLAYBACK);
+        if (ret) { goto out; }
+    }
+
+    if (dai->capture.channels_min) {
+        ret = tcc_pcm_preallocate_dma_buffer(pcm,SNDRV_PCM_STREAM_CAPTURE);
+        if (ret) { goto out; }
+    } 
+out:
+    return ret;
+}
+
+#if 0
+int tcc_pcm_suspend(struct platform_device *pdev, struct snd_soc_cpu_dai *cpu_dai)
+{
+    return 0;
+}
+
+int tcc_pcm_resume(struct platform_device *pdev, struct snd_soc_cpu_dai *cpu_dai)
+{
+    return 0;
+}
+#endif
+
+struct snd_soc_platform tcc_soc_platform = {
+    .name  = "tcc-audio",
+    .pcm_ops  = &tcc_pcm_ops,
+    .pcm_new = tcc_pcm_new,
+    .pcm_free = tcc_pcm_free_dma_buffers,
+#if 0
+    .suspend = tcc_pcm_suspend,
+    .resume = tcc_pcm_resume,
+#endif
+};
+
+EXPORT_SYMBOL_GPL(tcc_soc_platform);
+
+
+/************************************************************************
+ * Dummy function for S/PDIF. This is a codec part.
+************************************************************************/
+static int iec958_pcm_prepare(struct snd_pcm_substream *substream) { return 0; }
+static int iec958_hw_params(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params) { return 0; }
+static void iec958_shutdown(struct snd_pcm_substream *substream) { }
+static int iec958_mute(struct snd_soc_dai *dai, int mute) { return 0; }
+static int iec958_set_dai_sysclk(struct snd_soc_dai *codec_dai, int clk_id, unsigned int freq, int dir) { return 0; }
+static int iec958_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt) { return 0; }
+
+struct snd_soc_dai iec958_dai = {
+	.name = "IEC958",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+        .rates = (SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000),
+		.formats = (SNDRV_PCM_FMTBIT_S16_LE),},
+	.ops = {
+		.prepare = iec958_pcm_prepare,
+		.hw_params = iec958_hw_params,
+		.shutdown = iec958_shutdown,
+	},
+	.dai_ops = {
+		.digital_mute = iec958_mute,
+		.set_sysclk = iec958_set_dai_sysclk,
+		.set_fmt = iec958_set_dai_fmt,
+	}
+};
+EXPORT_SYMBOL_GPL(iec958_dai);
+/***********************************************************************/
+
+
+MODULE_AUTHOR("Telechips");
+MODULE_DESCRIPTION("Telechips TCC PCM DMA module");
+MODULE_LICENSE("GPL");
+
Index: linux-2.6.29/sound/soc/tcc/tcc-pcm.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/sound/soc/tcc/tcc-pcm.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,119 @@
+/*
+ * linux/sound/soc/tcc/tcc-pcm.h   
+ *
+ * Based on:    linux/sound/arm/pxa2xx-pcm.h
+ * Author:  <linux@telechips.com>
+ * Created: Nov 30, 2004
+ * Modified:    Nov 25, 2008
+ * Description: ALSA PCM interface for the Intel PXA2xx chip
+ *
+ * Copyright:	MontaVista Software, Inc.
+ * Copyright (C) 2008-2009 Telechips 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see the file COPYING, or write
+ * to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _tcc_PCM_H
+#define _tcc_PCM_H
+
+#include <mach/hardware.h>
+
+#define __play_buf_size 16384
+#define __play_buf_cnt  4
+
+#define __cap_buf_size 4096
+#define __cap_buf_cnt  16
+
+#define DMA_CH_OUT 0x0001
+#define DMA_CH_IN  0x0002
+#define DMA_CH_SPDIF  0x0004
+
+#define TCC_INTERRUPT_REQUESTED 0x0001
+#define TCC_RUNNING_PLAY        0x0002
+#define TCC_RUNNING_CAPTURE     0x0004
+#define TCC_RUNNING_SPDIF        0x0008
+
+#define TCC_TX_INTERRUPT_REQUESTED 0x0010
+#define TCC_RX_INTERRUPT_REQUESTED 0x0020
+
+#define __SPDIF_DEV_NUM__ 1
+
+#define NEXT_BUF(_s_,_b_) { \
+    (_s_)->_b_##_idx++; \
+    (_s_)->_b_##_idx %= (_s_)->nbfrags; \
+    (_s_)->_b_ = (_s_)->buffers + (_s_)->_b_##_idx; }
+
+typedef struct _tcc_interrupt_info_x {
+    struct snd_pcm_substream *play_ptr;
+    struct snd_pcm_substream *cap_ptr;
+    struct snd_pcm_substream *spdif_ptr;
+    struct mutex mutex;
+    unsigned int flag;
+} tcc_interrupt_info_x;
+
+extern tcc_interrupt_info_x tcc_alsa_info;
+
+struct tcc_pcm_dma_params {
+    char *name; /* stream identifier */
+    int channel;
+    dma_addr_t dma_addr;
+    int dma_size; /* Size of the DMA transfer */
+};
+
+struct tcc_runtime_data {
+    int dma_ch;
+    struct tcc_pcm_dma_params *params;
+    dma_addr_t dma_buffer;          /* physical address of dma buffer */
+    dma_addr_t dma_buffer_end;      /* first address beyond DMA buffer */
+    size_t period_size;
+    size_t nperiod;     
+    dma_addr_t period_ptr;          /* physical address of next period */
+};
+
+typedef struct {
+    int size;       /* buffer size */
+    char *start;        /* point to actual buffer */
+    dma_addr_t dma_addr;    /* physical buffer address */
+    struct semaphore sem;    /* down before touching the buffer */
+    int master;     /* owner for buffer allocation, contain size when true */
+    int dma_size;
+} audio_buf_t;
+
+typedef struct {
+    audio_buf_t *buffers;   /* pointer to audio buffer structures */
+    audio_buf_t *buf;   /* current buffer used by read/write */
+    u_int buf_idx;      /* index for the pointer above */
+    u_int play_idx;     /* the current buffer that playing */
+    u_int fragsize;     /* fragment i.e. buffer size */
+    u_int nbfrags;      /* nbr of fragments */
+} audio_stream_t;
+
+typedef struct {
+    char *addr;
+    dma_addr_t dma_addr;
+    int  buf_size;  // total size of DMA
+    int  page_size; // size of each page
+    int  dma_half;  // 0 or 1, mark the next available buffer
+}dma_buf_t;
+
+extern void tea_i2s_setclock(unsigned int clock_rate);
+extern void tea_spdif_setclock(unsigned int clock_rate);
+extern struct snd_soc_dai iec958_dai;
+
+/* platform data */
+//extern struct snd_soc_platform tcc_soc_platform;
+
+#endif
Index: linux-2.6.29/sound/soc/tcc/tcc8900/tca_tcchwcontrol.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/sound/soc/tcc/tcc8900/tca_tcchwcontrol.c	2010-04-07 13:00:58.000000000 -0400
@@ -0,0 +1,633 @@
+
+/****************************************************************************
+ *   FileName    : tca_tcchwcontrol.c
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+/*****************************************************************************
+*
+* includes
+*
+******************************************************************************/
+#include <bsp.h>
+#include "tca_tcchwcontrol.h"
+#if defined(SPDIF_2CH_ONLY)	
+unsigned int OutputADMIntStatusForSPDIF = 0;
+int OutputADMADAITxIntCnt = 0, OutputADMASPDIFTxIntCnt = 0;
+#endif
+/*****************************************************************************
+* Function Name : tca_dma_clrstatus()
+******************************************************************************
+* Desription    :
+* Parameter     : 
+* Return        : success(SUCCESS) 
+******************************************************************************/
+unsigned int tca_dma_clrstatus(void *pADMABaseAddr, unsigned int nDmanum)
+{
+	ADMA *pStrADMABaseReg = (ADMA *)pADMABaseAddr;
+	if (nDmanum) {
+		//If you use this register to write, set interrupt status is cleared.
+        pStrADMABaseReg->IntStatus |= (Hw6 | Hw2);
+    } 
+	else 
+	{
+#if defined(SPDIF_2CH_ONLY)	
+		pStrADMABaseReg->IntStatus |= (Hw5 | Hw1);
+#else
+		//If you use this register to write, set interrupt status is cleared.
+        pStrADMABaseReg->IntStatus |= (Hw4 | Hw0);		
+#endif
+    }
+
+	return 0/*SUCCESS*/;
+}
+
+/*****************************************************************************
+* Function Name : tca_irq_getnumber()
+******************************************************************************
+* Desription    :
+* Parameter     : 
+* Return        : DMA number 
+******************************************************************************/
+unsigned int tca_irq_getnumber(void)
+{
+	return IRQ_ADMA;  // audio output interrupt.
+}
+
+/*****************************************************************************
+* Function Name : tca_dma_getstatus()
+******************************************************************************
+* Desription    : dma status check
+* Parameter     : 
+* Return        :  
+******************************************************************************/
+unsigned int tca_dma_getstatus(void *pADMABaseAddr, unsigned int nDmanum)
+{
+	ADMA *pStrADMABaseReg = (ADMA *)pADMABaseAddr;
+#if defined(SPDIF_2CH_ONLY)	
+	return nDmanum ? (pStrADMABaseReg->IntStatus & (Hw6 | Hw2)) : (pStrADMABaseReg->IntStatus & (Hw5 | Hw1));
+#else
+    return nDmanum ? (pStrADMABaseReg->IntStatus & (Hw6 | Hw2)) : (pStrADMABaseReg->IntStatus & (Hw4 | Hw0));
+#endif
+}
+
+/*****************************************************************************
+* Function Name : tca_tcc_initport()
+******************************************************************************
+* Desription    : GPIO port init
+* Parameter     : 
+* Return        :  
+******************************************************************************/
+unsigned int tca_tcc_initport(void *pGPIOBaseAddr)
+{
+	GPIO *pStrGPIOBaseReg = (GPIO *)pGPIOBaseAddr;
+
+	//Set GPIO for Audio
+	pStrGPIOBaseReg->GPDFN0 |= 0
+		| Hw0	//BCLK(1)
+		| Hw4	//LRCLK(1)
+		| Hw8	//MCLK(1)
+		| Hw12	//DAO0(1)
+		| Hw16	//DAI0(1)
+		| Hw20	//DAO1(1)
+		| Hw24	//DAI1(1)
+		| Hw28	//DAO2(1)
+		;
+	pStrGPIOBaseReg->GPDFN1 |= 0
+		| Hw0	//DAI2(1)
+		| Hw4	//DAO3(1)
+		| Hw8	//DAI3(1)
+#if defined(SPDIF_2CH_ONLY)	
+		| Hw12	//SPD_TX(1)
+#endif		
+		;
+	return 0/*SUCCESS*/;
+}
+
+/*****************************************************************************
+* Function Name : tca_dma_setsrcaddr()
+******************************************************************************
+* Desription    : dma set source address
+* Parameter     : dma number
+* Return        : address
+******************************************************************************/
+unsigned int tca_dma_setsrcaddr(void *pADMABaseAddr, unsigned int DADONum, unsigned int nDmanum, unsigned int nAddr)	
+{
+	ADMA *pStrADMABaseReg = (ADMA *)pADMABaseAddr;
+
+	switch(DADONum)
+	{
+    	case 0:
+			pStrADMABaseReg->TxDaSar = nAddr;
+			break;
+		case 1:
+			pStrADMABaseReg->TxDaSar1 = nAddr;
+			break;
+		case 2:
+			pStrADMABaseReg->TxDaSar2 = nAddr;
+			break;
+		case 3:
+			pStrADMABaseReg->TxDaSar3 = nAddr;
+			break;
+#if defined(SPDIF_2CH_ONLY)				
+		case 4:
+			pStrADMABaseReg->TxSpSar = nAddr;
+#endif			
+		default:
+			break;
+	}
+	
+	return 0/*SUCCESS*/;
+}
+
+/*****************************************************************************
+* Function Name : tca_dma_setdestaddr()
+******************************************************************************
+* Desription	: set dest address
+* Parameter 	: dma number, dest address
+* Return		: SUCCESS 
+******************************************************************************/
+unsigned int tca_dma_setdestaddr(void *pADMABaseAddr, unsigned int DADINum, unsigned int nDmanum, unsigned int nAddr)	
+{
+	ADMA *pStrADMABaseReg = (ADMA *)pADMABaseAddr;	
+	
+	switch(DADINum)
+	{
+		case 0:
+			pStrADMABaseReg->RxDaDar = nAddr;
+			break;
+		case 1:
+			pStrADMABaseReg->RxDaDar1 = nAddr;
+			break;
+		case 2:
+			pStrADMABaseReg->RxDaDar2 = nAddr;
+			break;
+		case 3:
+			pStrADMABaseReg->RxDaDar3 = nAddr;
+			break;
+		default:
+			break;
+	}
+	return 0/*SUCCESS*/;
+}
+
+/*****************************************************************************
+* Function Name : tca_dma_control()
+******************************************************************************
+* Desription    : dma input control
+* Parameter     : mode 1: on, 0:off
+* Return        : success(SUCCESS) 
+******************************************************************************/
+unsigned int tca_dma_control(void *pADMABaseAddr, void *pADMADAIBaseAddr, void *pADMASPDIFTXBaseAddr,
+	unsigned int nMode, unsigned int nDmanum, unsigned int nInMode)				
+{  
+	ADMA *pStrADMABaseReg = (ADMA *)pADMABaseAddr;
+	//ADMADAI *pStrADMADAIBaseReg = (ADMADAI *)pADMADAIBaseAddr; 
+	ADMASPDIFTX *pStrADMASPDIFTxBaseReg = (ADMASPDIFTX *)pADMASPDIFTXBaseAddr;
+	
+    if(nMode) 
+	{ //run
+        tca_i2s_start(pADMADAIBaseAddr, pADMASPDIFTXBaseAddr, nInMode);
+#if defined(_MULTIL_DAO_INCLUDE_)		
+		pStrADMABaseReg->RptCtrl = Hw26|Hw25|Hw24;//DAI Buffer Threshod is set Multi-Port
+#else
+		pStrADMABaseReg->RptCtrl = 0;//Initialize repeat control register
+#endif
+		if(nInMode)//input
+		{
+			pStrADMABaseReg->ChCtrl |= 0
+				| Hw30 //DMA Channel enable of DAI Rx
+#if defined(_MULTIL_DAO_INCLUDE_)
+				| Hw25 //DMA Multi Channel Mode of DAI Rx
+				| Hw23 | Hw22//DMA Multi channel select : DAO0, DAO1, DAO2, DAO3
+#endif				
+				| Hw14 //Width of Audio Data of DAI Rx 16bites
+				| Hw2; //Interrupt enable of DAI Rx
+		}
+		else//output
+		{
+			pStrADMABaseReg->ChCtrl |= 0
+#if defined(SPDIF_2CH_ONLY)
+				| Hw29 //DMA Channel enable of SPDIF Tx
+#endif
+				| Hw28 //DMA Channel enable of DAI Tx
+#if defined(_MULTIL_DAO_INCLUDE_)
+				| Hw24 //DMA Multi Channel Mode of DAI Tx
+				| Hw21 | Hw20//DMA Multi channel select : DAI0, DAI1, DAI2, DAI3
+#endif
+#if defined(SPDIF_2CH_ONLY)
+				| Hw13	//Width of Audio Data of SPDIF Tx 16bites
+#endif
+				| Hw12	//Width of Audio Data of DAI Tx 16bites
+#if defined(SPDIF_2CH_ONLY)
+				| Hw1	//Interrupt enable of SPDIF Tx
+#endif
+				
+				| Hw0; //Interrupt enable of DAI Tx
+#if defined(_MULTIL_DAO_INCLUDE_)		
+/*
+			pStrADMADAIBaseReg->MCCR0 |= 0
+				| Hw13|Hw21//Disable BCLK Divider Select of TDM
+				;				
+				*/
+#endif				
+		}
+    }
+	else 
+	{
+        tca_i2s_stop(pADMADAIBaseAddr, pStrADMASPDIFTxBaseReg, nInMode);
+		if(nInMode)//input
+		{
+			pStrADMABaseReg->ChCtrl &= ~Hw30; //DMA Channel disable of DAI Rx
+		}
+		else//output
+		{
+#if defined(SPDIF_2CH_ONLY)
+			pStrADMABaseReg->ChCtrl &= ~(Hw29|Hw28); //DMA Channel disable of SPDIF Tx, DAI Tx
+#else
+			pStrADMABaseReg->ChCtrl &= ~Hw28; //DMA Channel disable of DAI Tx
+#endif
+			
+		}
+    }
+	return 0/*SUCCESS*/;
+}
+
+/*****************************************************************************
+* Function Name : tca_i2s_setregister()
+******************************************************************************
+* Desription    : set dai register
+* Parameter     : 
+* Return        : success(SUCCESS) 
+******************************************************************************/
+unsigned int tca_i2s_setregister(void *pADMADAIBaseAddr, unsigned int nRegval)
+{
+	ADMADAI*pStrADMADAIBaseReg = (ADMADAI *)pADMADAIBaseAddr;
+	pStrADMADAIBaseReg->DAMR = nRegval;
+	return 0;
+}
+
+/*****************************************************************************
+* Function Name : tca_i2s_getregister()
+******************************************************************************
+* Desription    : get dai register
+* Parameter     : 
+* Return        : success(SUCCESS) 
+******************************************************************************/
+unsigned int tca_i2s_getregister(void *pADMADAIBaseAddr)
+{
+	ADMADAI *pStrADMADAIBaseReg = (ADMADAI *)pADMADAIBaseAddr;
+	return (pStrADMADAIBaseReg->DAMR);
+}
+
+/*****************************************************************************
+* Function Name : tca_i2s_dai_init()
+******************************************************************************
+* Desription    : i2s init
+* Parameter     : 
+* Return        : success(SUCCESS) 
+******************************************************************************/
+unsigned int tca_i2s_dai_init(void *pADMADAIBaseAddr)
+{
+	ADMADAI *pStrADMADAIBaseReg = (ADMADAI *)pADMADAIBaseAddr;
+	
+ 	//Not used volume control
+	pStrADMADAIBaseReg->DAVC = 0;
+	
+	pStrADMADAIBaseReg->DAMR = 0
+		| Hw31 	//BCLK direct at master mode
+		| Hw30 	//LRCLK direct at master mode	
+#if defined(_MULTIL_DAO_INCLUDE_)
+		| Hw29	//DAI Buffer Threshold Enable
+		| Hw28	//Multi-Port Enable
+		//| Hw17	//Loop back test
+#endif
+		| Hw21| Hw20 //DAI Rx shift Bit-pack LSB and 16bit mode
+		| Hw19| Hw18 //DAI Tx shift Bit-pack LSB and 16bit mode
+		| Hw15	//DAI Master enable
+		| Hw11 	//DAI System Clock master select
+		| Hw10 	//DAI Bit Clock master select
+		| Hw9	//DAI Frame clock(LRCLK) master selcet 
+		| Hw5	//DAI LRCLK(64fs->fs)
+		;
+
+    return(0);
+}
+
+/*****************************************************************************
+* Function Name : tca_i2s_initoutput()
+******************************************************************************
+* Desription    : i2s init output
+* Parameter     : 
+* Return        : success(SUCCESS) 
+******************************************************************************/
+void tca_i2s_initoutput(void *pADMABaseAddr, unsigned int nOutputDma, unsigned int AUDIO_DMA_PAGE_SIZE, unsigned int SAMPLERATE )
+{
+	ADMA *pStrADMABaseReg = (ADMA *)pADMABaseAddr;
+	unsigned int bitSet=0x0;
+	unsigned uSize;
+    unsigned int DMABuffer = 0;
+
+	//DMA Channel enable of DAI Tx
+    pStrADMABaseReg->ChCtrl &= ~Hw28;
+
+	DMABuffer = 0xFFFFFF00 / (((AUDIO_DMA_PAGE_SIZE*2) >> 4)<<8);
+	DMABuffer = DMABuffer * (((AUDIO_DMA_PAGE_SIZE*2) >> 4)<<8);
+
+	uSize = AUDIO_DMA_PAGE_SIZE*2;
+		
+	// DAI Tx (Right) Source Address
+	pStrADMABaseReg->TxDaParam = DMABuffer | 4; //(4|0xFFFFFE00);	
+
+	// ADMA Count Reginster setting
+	pStrADMABaseReg->TxDaTCnt = (((AUDIO_DMA_PAGE_SIZE)>>0x2)>>0x2) - 1;
+		
+	// Tx Transfer Control Refister Setting	
+	bitSet = ( HwZERO
+		//Tx Trigger Type is edge-trigger
+		|Hw28 //DMA transfer begins from current source/destination address
+		//|Hw24 //Issue Locked Transfer of DAI Tx DMA
+		|Hw16 //Enable repeat mode control of DAI Tx DMA
+		|Hw9/*|Hw8*/ //Burst size of DAI Tx DMA is 4 cycle
+		|Hw1|Hw0 //Word size of DAI Tx DMA is 32bit
+		);
+	
+	pStrADMABaseReg->TransCtrl |= bitSet;
+#if defined(_MULTIL_DAO_INCLUDE_)		
+	pStrADMABaseReg->RptCtrl = Hw26|Hw25|Hw24;//DAI Buffer Threshod is set Multi-Port
+#else
+    pStrADMABaseReg->RptCtrl = 0;
+#endif
+
+	/* ADMA Repeat register setting */
+	//	BITCLR(HwRptCtrl,HwRptCtrl_DRI_EN);	//DMA Interrupt is occurred when the end of each Repeated DMAoperation.
+	
+	// Tx channel Control Register Setting	
+	//Start DMA
+	bitSet = ( HwZERO
+		|Hw0 //Interrupt Enable of DAI Tx	
+		);
+  
+	pStrADMABaseReg->ChCtrl |= bitSet;
+}
+
+#if defined(SPDIF_2CH_ONLY)
+void tca_i2s_initoutputbyspdif(void *pADMABaseAddr, void *pADMASPDIFTXBaseAddr, 
+	unsigned int nOutputDma, unsigned int AUDIO_DMA_PAGE_SIZE_SPIDF, unsigned int SAMPLERATE )
+{
+	ADMA *pStrADMABaseReg = (ADMA *)pADMABaseAddr;
+	ADMASPDIFTX *pStrADMASPDIFTXBaseReg = pADMASPDIFTXBaseAddr;
+	unsigned int bitSet=0x0;
+	unsigned uSize;
+	unsigned int DMABuffer = 0;
+	
+	memset((void *)pStrADMASPDIFTXBaseReg->UserData, 0, 24);
+	memset((void *)pStrADMASPDIFTXBaseReg->ChStatus, 0, 24);
+	memset((void *)pStrADMASPDIFTXBaseReg->TxBuffer, 0, 128);
+
+	//DMA Channel enable of SPDIF Tx
+	pStrADMABaseReg->ChCtrl &= ~Hw29;
+
+	DMABuffer = 0xFFFFFF00 / (((AUDIO_DMA_PAGE_SIZE_SPIDF*2) >> 4)<<8);
+	DMABuffer = DMABuffer * (((AUDIO_DMA_PAGE_SIZE_SPIDF*2) >> 4)<<8);
+
+	uSize = AUDIO_DMA_PAGE_SIZE_SPIDF*2;
+		
+	// SPDIF Tx (Right) Source Address
+	pStrADMABaseReg->TxSpParam = DMABuffer | 4; //(4|0xFFFFFE00);	
+
+	// ADMA Count Reginster setting
+	pStrADMABaseReg->TxSpTCnt = (((AUDIO_DMA_PAGE_SIZE_SPIDF)>>0x2)>>0x2) - 1;
+		
+	// Tx Transfer Control Refister Setting 
+	bitSet |= (HwZERO
+		//Tx Trigger Type is edge-trigger
+		|Hw28 //DMA transfer begins from current source/destination address
+		//|Hw25 //Issue Locked Transfer of SPDIF Tx DMA
+		|Hw17 //Enable repeat mode control of SPDIF Tx DMA
+		|Hw11/*|Hw10*/ //Burst size of SPDIF Tx DMA is 4 cycle
+		|Hw3|Hw2 //Word size of SPDIF Tx DMA is 32bit
+		);
+
+	pStrADMABaseReg->TransCtrl |= bitSet;
+
+#if defined(_MULTIL_DAO_INCLUDE_)		
+	pStrADMABaseReg->RptCtrl = Hw26|Hw25|Hw24;//DAI Buffer Threshod is set Multi-Port
+#else
+	pStrADMABaseReg->RptCtrl = 0;
+#endif
+
+	/* ADMA Repeat register setting */
+	//	BITCLR(HwRptCtrl,HwRptCtrl_DRI_EN); //DMA Interrupt is occurred when the end of each Repeated DMAoperation.
+
+	//Set SPDIF Transmit Configuration
+	pStrADMASPDIFTXBaseReg->TxConfig = HwZERO
+		//16bits 
+		|Hw9|Hw8 //Clock Divider Ratio is 2(384*fs to default)
+		//| Hw7 | Hw6 //User Data Enalbe Bits is set reserved
+		//| Hw5 | Hw4 //Channel Status Enalbe Bits is set reserved
+		//| Hw2 //interrupt output enable
+		| Hw1 //data being valid
+		//| Hw0 //enable the transmission
+		;
+	//Set SPDIF Transmit Channel Status
+	pStrADMASPDIFTXBaseReg->TxChStat |= HwZERO
+		//| 0x00000400 // Store Channel Status bit
+		//| 0x00000200 // Store User Data bit
+		//| 0x00000100 // Store Validity bit
+		//44.1kHz
+		//| Hw3 //Original/Commercially Pre-recored data
+		//| Hw2 //Pre-emphasis is 50/15us
+		//| Hw1 //Copy permitted
+		//Audio format
+		;		
+	
+	//pStrADMASPDIFTXBaseReg->TxIntMask = HwZERO
+	//	| Hw2//Higher Data buffer is empty
+	//	| Hw1//Lower Data buffer is empty
+	//	;
+
+	pStrADMASPDIFTXBaseReg->DMACFG = HwZERO
+		//| Hw14	//Swap Sample Enable
+		| Hw13 	//Read Address 16bit Mode
+		| Hw11	//DMA Request enable for user data buffer
+		| Hw10	//DMA Request enable for sample data buffer
+		| Hw8	//Enable address
+		//| Hw3	//FIFO Threshold for DMA request
+		| Hw1| Hw0	// [3:0] FIFO Threshold for DMA Request
+		;
+
+	/* Initialize Sample Data Buffer */
+	while(pStrADMASPDIFTXBaseReg->DMACFG & 0x00300000) pStrADMASPDIFTXBaseReg->TxBuffer[0] = 0;
+	
+	pStrADMASPDIFTXBaseReg->TxConfig |= HwZERO
+		//| Hw2 //interrupt output enable
+		| Hw1 //data being valid
+		| Hw0 //enable the transmission
+		;
+
+	while((pStrADMASPDIFTXBaseReg->DMACFG & 0x00100000)); /* Wait until first data TX */
+	while((pStrADMASPDIFTXBaseReg->DMACFG & 0x001F0000) > 0x00080000);
+
+	while(!(pStrADMASPDIFTXBaseReg->TxIntStat & Hw1));	/* Wait for Interrupt Status */
+
+	pStrADMASPDIFTXBaseReg->TxIntStat = 0x1E; /* Clear Interrupt Status */
+
+	pStrADMASPDIFTXBaseReg->TxConfig |= HwZERO
+		| Hw2 //interrupt output enable
+		| Hw1 //data being valid
+		//| Hw0 //enable the transmission
+		;
+		
+	// Tx channel Control Register Setting	
+	//Start DMA
+	bitSet = ( HwZERO
+		|Hw1 //Interrupt Enable of SPDIF Tx	
+		);
+  
+	pStrADMABaseReg->ChCtrl |= bitSet;
+}
+#endif
+
+/*****************************************************************************
+* Function Name : tca_i2s_deinit()
+******************************************************************************
+* Desription    : i2s deinit
+* Parameter     : 
+* Return        : success(SUCCESS) 
+******************************************************************************/
+
+unsigned int tca_i2s_deinit(void *pADMADAIBaseAddr, void *pADMASPDIFTXBaseAddr)
+{
+    //----- 1. Stop the I2S clocks -----
+    tca_i2s_stop(pADMADAIBaseAddr, pADMASPDIFTXBaseAddr, 0);
+	tca_i2s_stop(pADMADAIBaseAddr, pADMASPDIFTXBaseAddr, 1);
+
+	return 0/*SUCCESS*/;
+}
+
+
+/*****************************************************************************
+* Function Name : tca_i2s_start()
+******************************************************************************
+* Desription    :
+* Parameter     : 
+* Return        : success(SUCCESS) 
+******************************************************************************/
+void tca_i2s_start(void *pADMADAIBaseAddr, void *pADMASPDIFTXBaseAddr, unsigned int nMode)
+{
+	ADMADAI *pStrADMADAIBaseReg = (ADMADAI *)pADMADAIBaseAddr;
+#if defined(SPDIF_2CH_ONLY)
+	ADMASPDIFTX *pStrADMASPDIFTXBaseReg = pADMASPDIFTXBaseAddr;
+#endif
+	
+	if(nMode) //input
+	{
+		//ADMADAI Receiver enable
+		pStrADMADAIBaseReg->DAMR |= Hw13;
+	}
+	else
+	{
+		//ADMADAI Transmitter enable
+		pStrADMADAIBaseReg->DAMR |= Hw14;
+#if defined(SPDIF_2CH_ONLY)
+		pStrADMASPDIFTXBaseReg->TxIntStat = 0x1E;		/* Clear Interrupt Status */
+		pStrADMASPDIFTXBaseReg->TxConfig |= HwZERO
+			|Hw0
+			;
+#endif
+	}
+}
+
+
+/*****************************************************************************
+* Function Name : tca_i2s_stop()
+******************************************************************************
+* Desription    :
+* Parameter     : 
+* Return        : success(SUCCESS) 
+******************************************************************************/
+void tca_i2s_stop(void *pADMADAIBaseAddr, void *pADMASPDIFTXBaseAddr, unsigned int nMode)
+{
+	ADMADAI *pStrADMADAIBaseReg = (ADMADAI *)pADMADAIBaseAddr;
+#if defined(SPDIF_2CH_ONLY)
+	ADMASPDIFTX *pStrADMASPDIFTXBaseReg = (ADMASPDIFTX *)pADMASPDIFTXBaseAddr;
+#endif
+	
+	if(nMode)
+	{
+		//DAI Receiver disable
+		pStrADMADAIBaseReg->DAMR &= ~Hw13;
+	}
+	else
+	{
+		//DAI Transmitter disable
+		pStrADMADAIBaseReg->DAMR &= ~Hw14;
+#if defined(SPDIF_2CH_ONLY)
+		pStrADMASPDIFTXBaseReg->TxConfig &= ~Hw0;
+#endif
+	}
+
+}
+
+/*****************************************************************************
+* Function Name : tca_i2s_initinput()
+******************************************************************************
+* Desription    :
+* Parameter     : 
+* Return        : success(SUCCESS) 
+******************************************************************************/
+void tca_i2s_initinput(void *pADMABaseAddr, unsigned int nInputDma, unsigned int AUDIO_DMA_IN_PAGE_SIZE, unsigned int SAMPLERATE)
+{
+	ADMA *pStrADMABaseReg = (ADMA *)pADMABaseAddr;	
+	unsigned int bitSet=0x0;
+	unsigned uSize;
+	unsigned int DMABuffer = 0;
+
+	//DMA Channel enable of DAI Rx
+	pStrADMABaseReg->ChCtrl &= ~Hw30;//
+
+	DMABuffer = 0xFFFFFF00 / (((AUDIO_DMA_IN_PAGE_SIZE*2) >> 4)<<8);
+	DMABuffer = DMABuffer * (((AUDIO_DMA_IN_PAGE_SIZE*2) >> 4)<<8);
+
+	uSize = AUDIO_DMA_IN_PAGE_SIZE*2;
+		
+	// DAI Rx (Right) Source Address
+	pStrADMABaseReg->RxDaParam = DMABuffer | 4; //(4|0xFFFFFE00);	
+
+	// ADMA Count Reginster setting
+	pStrADMABaseReg->RxDaTCnt = (((AUDIO_DMA_IN_PAGE_SIZE)>>0x02)>>0x02) - 1;
+
+	//Rx Transfer Control Refister Setting 
+	bitSet = ( HwZERO
+		//Rx Trigger Type is edge-trigger
+		|Hw29 //DMA transfer begins from current source/destination address
+		//|Hw26 //Issue Locked Transfer of DAI Rx DMA
+		|Hw18 //Enable repeat mode control of DAI Rx DMA
+		|Hw13 //Burst size of DAI Rx DMA is 4 cycle
+		|(Hw5|Hw4) //Word size of DAI Rx DMA is 32bit
+		);
+
+	pStrADMABaseReg->TransCtrl |= bitSet;
+#if defined(_MULTIL_DAO_INCLUDE_)		
+	pStrADMABaseReg->RptCtrl = Hw26|Hw25|Hw24;//DAI Buffer Threshod is set Multi-Port
+#else
+	pStrADMABaseReg->RptCtrl = 0;
+#endif
+
+	/* ADMA Repeat register setting */
+	//BITCLR(HwRptCtrl,HwRptCtrl_DRI_EN); //DMA Interrupt is occurred when the end of each Repeated DMAoperation.
+	
+	// Rx channel Control Register Setting	
+	//Start DMA
+	bitSet = ( HwZERO
+		|Hw2//Interrupt Enable of DAI Rx	
+		);
+
+	pStrADMABaseReg->ChCtrl |= bitSet; 
+}
Index: linux-2.6.29/sound/soc/tcc/tcc8900/tca_tcchwcontrol.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/sound/soc/tcc/tcc8900/tca_tcchwcontrol.h	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,60 @@
+/****************************************************************************
+ *   FileName    : tca_tcchwcontrol.h
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+#ifndef __TCA_TCCHWCONTROL_H__
+#define __TCA_TCCHWCONTROL_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*****************************************************************************
+*
+* Defines
+*
+******************************************************************************/
+
+//#define	AUDIO_DMA_PAGE_SIZE		(256)					// Size in bytes
+//#define	AUDIO_DMA_IN_PAGE_SIZE	(256)					// Size in bytes
+
+//i2s control api
+extern unsigned int tca_i2s_dai_init(void *pADMADAIBaseAddr);
+extern unsigned int tca_i2s_deinit(void *pADMADAIBaseAddr, void *pADMASPDIFTXBaseAddr);
+extern unsigned int tca_i2s_setregister(void *pADMADAIBaseAddr, unsigned int nRegval);
+extern unsigned int tca_i2s_getregister(void *pADMADAIBaseAddr);
+
+extern void tca_i2s_start(void *pADMADAIBaseAddr, void *pADMASPDIFTXBaseAddr, unsigned int nMode);
+extern void tca_i2s_stop(void *pADMADAIBaseAddr, void *pADMASPDIFTXBaseAddr, unsigned int nMode);
+
+extern void tca_i2s_initoutput(void *pADMABaseAddr, unsigned int,unsigned int,unsigned int);
+#if defined(SPDIF_2CH_ONLY)
+void tca_i2s_initoutputbyspdif(void *pADMABaseAddr, void *pADMASPDIFTXBaseAddr, 
+	unsigned int nOutputDma, unsigned int AUDIO_DMA_PAGE_SIZE_SPIDF, unsigned int SAMPLERATE );
+#endif
+extern void tca_i2s_initinput(void *pADMABaseAddr, unsigned int,unsigned int,unsigned int);
+
+//Get IRQ GetNumber
+extern unsigned int tca_irq_getnumber(void);
+
+//dma control api
+extern unsigned int tca_dma_clrstatus(void *pADMABaseAddr, unsigned int nDmanum);
+extern unsigned int tca_dma_getstatus(void *pADMABaseAddr, unsigned int nDmanum);
+extern unsigned int tca_dma_control(void *pADMABaseAddr, void *pADMADAIBaseAddr, void *pADMASPDIFTXBaseAddr,
+	unsigned int nMode, unsigned int nDmanum, unsigned int nInMode);
+extern unsigned int tca_dma_setsrcaddr(void *pADMABaseAddr, unsigned int DADONum, unsigned int nDmanum, unsigned int nAddr);
+extern unsigned int tca_dma_setdestaddr(void *pADMABaseAddr, unsigned int DADINum, unsigned int nDmanum, unsigned int nAddr);
+
+//GPIO port INIT
+extern unsigned int tca_tcc_initport(void *pGPIOBaseAddr);
+#ifdef __cplusplus
+}
+#endif
+#endif
+
Index: linux-2.6.29/sound/soc/tcc/tcc_board.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/sound/soc/tcc/tcc_board.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,444 @@
+/*
+ * linux/sound/soc/tcc/tcc_board.c
+ *
+ * Author:  <linux@telechips.com>
+ * Created: Nov 30, 2007
+ * Description: SoC audio for TCCxx
+ *
+ * Copyright (C) 2008-2009 Telechips 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see the file COPYING, or write
+ * to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/moduleparam.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <bsp.h>
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+#include <mach/tca_ckc.h>
+#include <mach/tcc_pca953x.h>
+
+
+#include "tcc/tca_tcchwcontrol.h"
+#include "../codecs/wm8731.h"
+#include "tcc-pcm.h"
+#include "tcc-i2s.h"
+
+#define TCC_HP        0
+#define TCC_MIC       1
+#define TCC_LINE      2
+#define TCC_HEADSET   3
+#define TCC_HP_OFF    4
+#define TCC_SPK_ON    0
+#define TCC_SPK_OFF   1
+
+// /* audio clock in Hz - rounded from 12.235MHz */
+//#define TCC83X_AUDIO_CLOCK 12288000
+
+static int tcc_jack_func;
+static int tcc_spk_func;
+
+static void tcc_ext_control(struct snd_soc_codec *codec)
+{
+	int spk = 0, mic = 0, line = 0, hp = 0, hs = 0;
+
+	/* set up jack connection */
+	switch (tcc_jack_func) {
+	case TCC_HP:
+		hp = 1;
+		/* set = unmute headphone */
+//		set_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_L);
+//		set_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_R);
+		break;
+	case TCC_MIC:
+		mic = 1;
+		/* reset = mute headphone */
+//		reset_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_L);
+//		reset_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_R);
+		break;
+	case TCC_LINE:
+		line = 1;
+//		reset_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_L);
+//		reset_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_R);
+		break;
+	case TCC_HEADSET:
+		hs = 1;
+		mic = 1;
+//		reset_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_L);
+//		set_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_R);
+		break;
+	}
+
+	if (tcc_spk_func == TCC_SPK_ON)
+		spk = 1;
+
+	/* set the enpoints to their new connetion states */
+	//snd_soc_dapm_set_endpoint(codec, "Ext Spk", spk);
+    snd_soc_dapm_enable_pin(codec, "Ext Spk");
+	//snd_soc_dapm_set_endpoint(codec, "Mic Jack", mic);
+	snd_soc_dapm_enable_pin(codec, "Mic Jack");
+	//snd_soc_dapm_set_endpoint(codec, "Line Jack", line);
+	snd_soc_dapm_enable_pin(codec, "Line Jack");
+	//snd_soc_dapm_set_endpoint(codec, "Headphone Jack", hp);
+	snd_soc_dapm_enable_pin(codec, "Headphone Jack");
+	//snd_soc_dapm_set_endpoint(codec, "Headset Jack", hs);
+    snd_soc_dapm_enable_pin(codec, "Headphone Jack");
+
+	/* signal a DAPM event */
+	//snd_soc_dapm_sync_endpoints(codec);
+	snd_soc_dapm_sync(codec);
+}
+
+static int tcc_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec *codec = rtd->socdev->codec;
+
+	/* check the jack status at stream startup */
+	tcc_ext_control(codec);
+	return 0;
+}
+
+/* we need to unmute the HP at shutdown as the mute burns power on tcc83x */
+static void tcc_shutdown(struct snd_pcm_substream *substream)
+{
+	//struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	//struct snd_soc_codec *codec = rtd->socdev->codec;
+
+	/* set = unmute headphone */
+//	set_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_L);
+//	set_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_R);
+	//return 0;
+}
+
+static int tcc_hw_params(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+	unsigned int clk = 0;
+	int ret = 0;
+
+	switch (params_rate(params)) {
+	case 8000:
+	case 16000:
+	case 48000:
+	case 96000:
+		clk = 12288000;
+		break;
+	case 11025:
+	case 22050:
+    case 32000:
+	case 44100:
+		clk = 11289600;
+		break;
+	}
+ 
+	/* set codec DAI configuration */
+    /*
+	ret = codec_dai->dai_ops.set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+		SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+        */
+	ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+		SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	if (ret < 0)
+		return ret;
+
+	/* set cpu DAI configuration */
+    /*
+	ret = cpu_dai->dai_ops.set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+		SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+        */
+	ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+		SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	if (ret < 0)
+		return ret;
+
+	/* set the codec system clock for DAC and ADC */
+    /*
+	ret = codec_dai->dai_ops.set_sysclk(codec_dai, WM8731_SYSCLK, clk,
+		SND_SOC_CLOCK_IN);
+        */
+	ret = snd_soc_dai_set_sysclk(codec_dai, WM8731_SYSCLK, clk,
+		SND_SOC_CLOCK_IN);
+	if (ret < 0)
+		return ret;
+
+	/* set the I2S system clock as input (unused) */
+//       ret = cpu_dai->dai_ops.set_sysclk(cpu_dai, PXA2XX_I2S_SYSCLK, 0,SND_SOC_CLOCK_IN);    
+    //	ret = cpu_dai->dai_ops.set_sysclk(cpu_dai, 0, 0, SND_SOC_CLOCK_IN);
+	ret = snd_soc_dai_set_sysclk(cpu_dai, 0, 0, SND_SOC_CLOCK_IN);
+	if (ret < 0)
+		return ret;
+ 
+	return 0;
+}
+
+static struct snd_soc_ops tcc_ops = {
+	.startup = tcc_startup,
+	.hw_params = tcc_hw_params,
+	.shutdown = tcc_shutdown,
+};
+
+static int tcc_get_jack(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = tcc_jack_func;
+	return 0;
+}
+
+static int tcc_set_jack(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+
+	if (tcc_jack_func == ucontrol->value.integer.value[0])
+		return 0;
+
+	tcc_jack_func = ucontrol->value.integer.value[0];
+	tcc_ext_control(codec);
+	return 1;
+}
+
+static int tcc_get_spk(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = tcc_spk_func;
+	return 0;
+}
+
+static int tcc_set_spk(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec =  snd_kcontrol_chip(kcontrol);
+
+	if (tcc_spk_func == ucontrol->value.integer.value[0])
+		return 0;
+
+	tcc_spk_func = ucontrol->value.integer.value[0];
+	tcc_ext_control(codec);
+	return 1;
+}
+
+static int tcc_amp_event(struct snd_soc_dapm_widget *w, struct snd_kcontrol *control, int event)
+{
+
+#if 0
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		set_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_APM_ON);
+	else
+		reset_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_APM_ON);
+#endif
+
+	return 0;
+}
+
+static int tcc_mic_event(struct snd_soc_dapm_widget *w, struct snd_kcontrol *control, int event)
+{
+#if 0
+	if (SND_SOC_DAPM_EVENT_ON(event))
+//		set_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MIC_BIAS);
+	else
+//		reset_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MIC_BIAS);
+#endif
+
+	return 0;
+
+}
+
+/* tcc machine dapm widgets */
+static const struct snd_soc_dapm_widget wm8731_dapm_widgets[] = {
+SND_SOC_DAPM_HP("Headphone Jack", NULL),
+SND_SOC_DAPM_MIC("Mic Jack", tcc_mic_event),
+SND_SOC_DAPM_SPK("Ext Spk", tcc_amp_event),
+SND_SOC_DAPM_LINE("Line Jack", NULL),
+SND_SOC_DAPM_HP("Headset Jack", NULL),
+};
+
+/* tcc machine audio map (connections to the codec pins) */
+static const struct snd_soc_dapm_route audio_map[] = {
+
+
+	/* headset Jack  - in = micin, out = LHPOUT*/
+	{"Headset Jack", NULL, "LHPOUT"},
+
+	/* headphone connected to LHPOUT1, RHPOUT1 */
+	{"Headphone Jack", NULL, "LHPOUT"},
+	{"Headphone Jack", NULL, "RHPOUT"},
+
+	/* speaker connected to LOUT, ROUT */
+	{"Ext Spk", NULL, "ROUT"},
+	{"Ext Spk", NULL, "LOUT"},
+
+	/* mic is connected to MICIN (via right channel of headphone jack) */
+	{"MICIN", NULL, "Mic Jack"},
+
+	/* Same as the above but no mic bias for line signals */
+	{"MICIN", NULL, "Line Jack"},
+};
+
+static const char *jack_function[] = {"Headphone", "Mic", "Line", "Headset",
+	"Off"};
+static const char *spk_function[] = {"On", "Off"};
+static const struct soc_enum tcc_enum[] = {
+	SOC_ENUM_SINGLE_EXT(5, jack_function),
+	SOC_ENUM_SINGLE_EXT(2, spk_function),
+};
+
+static const struct snd_kcontrol_new wm8731_tcc_controls[] = {
+	SOC_ENUM_EXT("Jack Function", tcc_enum[0], tcc_get_jack,
+		tcc_set_jack),
+	SOC_ENUM_EXT("Speaker Function", tcc_enum[1], tcc_get_spk,
+		tcc_set_spk),
+};
+
+/*
+ * Logic for a wm8731 as connected on a Sharp SL-C7x0 Device
+ */
+static int tcc_wm8731_init(struct snd_soc_codec *codec)
+{
+	int i, err;
+
+	//snd_soc_dapm_nc_pin(codec, "LLINEIN");
+	//snd_soc_dapm_nc_pin(codec, "RLINEIN");
+	snd_soc_dapm_enable_pin(codec, "MICIN");
+
+	/* Add tcc specific controls */
+	for (i = 0; i < ARRAY_SIZE(wm8731_tcc_controls); i++) {
+		err = snd_ctl_add(codec->card,
+			snd_soc_cnew(&wm8731_tcc_controls[i],codec, NULL));
+		if (err < 0)
+			return err;
+	}
+
+	/* Add tcc specific widgets */
+    snd_soc_dapm_new_controls(codec, wm8731_dapm_widgets, 
+                               ARRAY_SIZE(wm8731_dapm_widgets));
+
+	/* Set up tcc specific audio path audio_map */
+	snd_soc_dapm_add_routes(codec, audio_map, ARRAY_SIZE(audio_map));
+
+	snd_soc_dapm_sync(codec);
+	return 0;
+}
+
+static int tcc_iec958_dummy_init(struct snd_soc_codec *codec)
+{
+    return 0;
+}
+
+/* tcc digital audio interface glue - connects codec <--> CPU */
+static struct snd_soc_dai_link tcc_dai[] = {
+    {
+        .name = "WM8731",
+        .stream_name = "WM8731",
+        .cpu_dai = &tcc_i2s_dai,
+        .codec_dai = &wm8731_dai,
+        .init = tcc_wm8731_init,
+        .ops = &tcc_ops,
+    },
+    {
+        .name = "TCC",
+        .stream_name = "IEC958",
+        .cpu_dai = &tcc_i2s_dai,
+        .codec_dai = &iec958_dai,
+        .init = tcc_iec958_dummy_init,
+        .ops = &tcc_ops,
+    }
+};
+
+static int tcc_board_probe(struct platform_device *pdev)
+{
+    GPIO *pStrGPIOBaseReg = (GPIO *)tcc_p2v(HwGPIO_BASE);
+    printk("TCC Board probe [%s]\n", __FUNCTION__);
+
+    tca_tcc_initport(pStrGPIOBaseReg);
+    /* For S/PDIF setting */
+	pStrGPIOBaseReg->GPDFN1 |= Hw12;	//SPD_TX(1)
+   // tca_ckc_com_setperibus(RB_DAI, 1);
+    tca_ckc_setiobus(RB_DAICDIFCONTROLLER, ENABLE);
+    return 0;
+}
+
+/* tcc audio machine driver */
+static struct snd_soc_machine snd_soc_machine_tcc = {
+	.name = "tccx_board",
+    .probe = tcc_board_probe,
+	.dai_link = tcc_dai,
+	.num_links = 2,
+};
+
+
+/* tcc audio private data */
+static struct wm8731_setup_data tcc_wm8731_setup = {
+    .i2c_bus = 0,
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	.i2c_address = 0x1a,  
+#else
+	.i2c_address = 0x34,		
+#endif
+};
+
+/* tcc audio subsystem */
+extern struct snd_soc_platform tcc_soc_platform;
+static struct snd_soc_device tcc_snd_devdata = {
+	.machine = &snd_soc_machine_tcc,
+	.platform = &tcc_soc_platform,
+	.codec_dev = &soc_codec_dev_wm8731,
+	.codec_data = &tcc_wm8731_setup,
+};
+
+static struct platform_device *tcc_snd_device;
+
+static int __init tcc_init(void)
+{
+	int ret;
+
+    tcc_pca953x_setup(PCA9539_U3_SLAVE_ADDR, CODEC_ON, OUTPUT, HIGH, SET_DIRECTION | SET_VALUE);
+    tcc_pca953x_setup(PCA9539_U2_SLAVE_ADDR, MUTE_CTL, OUTPUT, HIGH, SET_DIRECTION | SET_VALUE);
+    
+	tcc_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!tcc_snd_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(tcc_snd_device, &tcc_snd_devdata);
+	tcc_snd_devdata.dev = &tcc_snd_device->dev;
+	ret = platform_device_add(tcc_snd_device);
+
+	if (ret)
+		platform_device_put(tcc_snd_device);
+
+	return ret;
+}
+
+static void __exit tcc_exit(void)
+{
+	platform_device_unregister(tcc_snd_device);
+}
+
+module_init(tcc_init);
+module_exit(tcc_exit);
+
+/* Module information */
+MODULE_AUTHOR("linux <linux@telechips.com>");
+MODULE_DESCRIPTION("ALSA SoC TCCxx Board");
+MODULE_LICENSE("GPL");
Index: linux-2.6.29/sound/soc/tcc/tcc_board_wm8581.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/sound/soc/tcc/tcc_board_wm8581.c	2010-04-07 12:29:36.000000000 -0400
@@ -0,0 +1,456 @@
+/*
+ * linux/sound/soc/tcc/tcc_board.c
+ *
+ * Author:  <linux@telechips.com>
+ * Created: Nov 30, 2007
+ * Description: SoC audio for TCCxx
+ *
+ * Copyright (C) 2008-2009 Telechips 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see the file COPYING, or write
+ * to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/moduleparam.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <bsp.h>
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+#include <mach/tca_ckc.h>
+#include <mach/tcc_pca953x.h>
+
+#include "tcc/tca_tcchwcontrol.h"
+#include "../codecs/wm8581.h"
+#include "tcc-pcm.h"
+#include "tcc-i2s.h"
+
+#define TCC_HP        0
+#define TCC_MIC       1
+#define TCC_LINE      2
+#define TCC_HEADSET   3
+#define TCC_HP_OFF    4
+#define TCC_SPK_ON    0
+#define TCC_SPK_OFF   1
+
+// /* audio clock in Hz - rounded from 12.235MHz */
+//#define TCC83X_AUDIO_CLOCK 12288000
+
+static int tcc_jack_func;
+static int tcc_spk_func;
+
+static void tcc_ext_control(struct snd_soc_codec *codec)
+{
+	int spk = 0, mic = 0, line = 0, hp = 0, hs = 0;
+
+	/* set up jack connection */
+	switch (tcc_jack_func) {
+	case TCC_HP:
+		hp = 1;
+		/* set = unmute headphone */
+//		set_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_L);
+//		set_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_R);
+		break;
+	case TCC_MIC:
+		mic = 1;
+		/* reset = mute headphone */
+//		reset_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_L);
+//		reset_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_R);
+		break;
+	case TCC_LINE:
+		line = 1;
+//		reset_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_L);
+//		reset_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_R);
+		break;
+	case TCC_HEADSET:
+		hs = 1;
+		mic = 1;
+//		reset_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_L);
+//		set_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_R);
+		break;
+	}
+
+	if (tcc_spk_func == TCC_SPK_ON)
+		spk = 1;
+
+	/* set the enpoints to their new connetion states */
+	//snd_soc_dapm_set_endpoint(codec, "Ext Spk", spk);
+    snd_soc_dapm_enable_pin(codec, "Ext Spk");
+	//snd_soc_dapm_set_endpoint(codec, "Mic Jack", mic);
+	snd_soc_dapm_enable_pin(codec, "Mic Jack");
+	//snd_soc_dapm_set_endpoint(codec, "Line Jack", line);
+	snd_soc_dapm_enable_pin(codec, "Line Jack");
+	//snd_soc_dapm_set_endpoint(codec, "Headphone Jack", hp);
+	snd_soc_dapm_enable_pin(codec, "Headphone Jack");
+	//snd_soc_dapm_set_endpoint(codec, "Headset Jack", hs);
+    snd_soc_dapm_enable_pin(codec, "Headphone Jack");
+
+	/* signal a DAPM event */
+	//snd_soc_dapm_sync_endpoints(codec);
+	snd_soc_dapm_sync(codec);
+}
+
+static int tcc_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec *codec = rtd->socdev->codec;
+
+	/* check the jack status at stream startup */
+	tcc_ext_control(codec);
+	return 0;
+}
+
+/* we need to unmute the HP at shutdown as the mute burns power on tcc83x */
+static void tcc_shutdown(struct snd_pcm_substream *substream)
+{
+	//struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	//struct snd_soc_codec *codec = rtd->socdev->codec;
+
+	/* set = unmute headphone */
+//	set_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_L);
+//	set_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_R);
+	//return 0;
+}
+
+static int tcc_hw_params(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+	unsigned int clk = 0;
+	int ret = 0;
+
+	switch (params_rate(params)) {
+	case 8000:
+	case 16000:
+	case 48000:
+	case 96000:
+		clk = 12288000;
+		break;
+	case 11025:
+	case 22050:
+    case 32000:
+	case 44100:
+		clk = 11289600;
+		break;
+	}
+ 
+	/* set codec DAI configuration */
+    /*
+	ret = codec_dai->dai_ops.set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+		SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+        */
+	ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+		SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	if (ret < 0)
+		return ret;
+
+	/* set cpu DAI configuration */
+    /*
+	ret = cpu_dai->dai_ops.set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+		SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+        */
+	ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+		SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	if (ret < 0)
+		return ret;
+
+	/* set the codec system clock for DAC and ADC */
+    /*
+	ret = codec_dai->dai_ops.set_sysclk(codec_dai, WM8581_SYSCLK, clk,
+		SND_SOC_CLOCK_IN);
+        */
+#if 0
+	ret = snd_soc_dai_set_sysclk(codec_dai, WM8581_SYSCLK, clk,
+		SND_SOC_CLOCK_IN);
+	if (ret < 0)
+		return ret;
+#endif
+
+	/* set the I2S system clock as input (unused) */
+//       ret = cpu_dai->dai_ops.set_sysclk(cpu_dai, PXA2XX_I2S_SYSCLK, 0,SND_SOC_CLOCK_IN);    
+    //	ret = cpu_dai->dai_ops.set_sysclk(cpu_dai, 0, 0, SND_SOC_CLOCK_IN);
+	ret = snd_soc_dai_set_sysclk(cpu_dai, 0, 0, SND_SOC_CLOCK_IN);
+	if (ret < 0)
+		return ret;
+ 
+	return 0;
+}
+
+static struct snd_soc_ops tcc_ops = {
+	.startup = tcc_startup,
+	.hw_params = tcc_hw_params,
+	.shutdown = tcc_shutdown,
+};
+
+static int tcc_get_jack(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = tcc_jack_func;
+	return 0;
+}
+
+static int tcc_set_jack(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+
+	if (tcc_jack_func == ucontrol->value.integer.value[0])
+		return 0;
+
+	tcc_jack_func = ucontrol->value.integer.value[0];
+	tcc_ext_control(codec);
+	return 1;
+}
+
+static int tcc_get_spk(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = tcc_spk_func;
+	return 0;
+}
+
+static int tcc_set_spk(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec =  snd_kcontrol_chip(kcontrol);
+
+	if (tcc_spk_func == ucontrol->value.integer.value[0])
+		return 0;
+
+	tcc_spk_func = ucontrol->value.integer.value[0];
+	tcc_ext_control(codec);
+	return 1;
+}
+
+static int tcc_amp_event(struct snd_soc_dapm_widget *w, struct snd_kcontrol *control, int event)
+{
+
+#if 0
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		set_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_APM_ON);
+	else
+		reset_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_APM_ON);
+#endif
+
+	return 0;
+}
+
+static int tcc_mic_event(struct snd_soc_dapm_widget *w, struct snd_kcontrol *control, int event)
+{
+#if 0
+	if (SND_SOC_DAPM_EVENT_ON(event))
+//		set_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MIC_BIAS);
+	else
+//		reset_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MIC_BIAS);
+#endif
+
+	return 0;
+
+}
+
+#if 1
+/* tcc machine dapm widgets */
+static const struct snd_soc_dapm_widget wm8581_dapm_widgets[] = {
+SND_SOC_DAPM_HP("Headphone Jack", NULL),
+SND_SOC_DAPM_MIC("Mic Jack", tcc_mic_event),
+SND_SOC_DAPM_SPK("Ext Spk", tcc_amp_event),
+SND_SOC_DAPM_LINE("Line Jack", NULL),
+SND_SOC_DAPM_HP("Headset Jack", NULL),
+};
+
+/* tcc machine audio map (connections to the codec pins) */
+static const struct snd_soc_dapm_route audio_map[] = {
+
+
+	/* headset Jack  - in = micin, out = LHPOUT*/
+	{"Headset Jack", NULL, "LHPOUT"},
+
+	/* headphone connected to LHPOUT1, RHPOUT1 */
+	{"Headphone Jack", NULL, "LHPOUT"},
+	{"Headphone Jack", NULL, "RHPOUT"},
+
+	/* speaker connected to LOUT, ROUT */
+	{"Ext Spk", NULL, "ROUT"},
+	{"Ext Spk", NULL, "LOUT"},
+
+	/* mic is connected to MICIN (via right channel of headphone jack) */
+	{"MICIN", NULL, "Mic Jack"},
+
+	/* Same as the above but no mic bias for line signals */
+	{"MICIN", NULL, "Line Jack"},
+};
+
+static const char *jack_function[] = {"Headphone", "Mic", "Line", "Headset",
+	"Off"};
+static const char *spk_function[] = {"On", "Off"};
+static const struct soc_enum tcc_enum[] = {
+	SOC_ENUM_SINGLE_EXT(5, jack_function),
+	SOC_ENUM_SINGLE_EXT(2, spk_function),
+};
+
+static const struct snd_kcontrol_new wm8581_tcc_controls[] = {
+	SOC_ENUM_EXT("Jack Function", tcc_enum[0], tcc_get_jack,
+		tcc_set_jack),
+	SOC_ENUM_EXT("Speaker Function", tcc_enum[1], tcc_get_spk,
+		tcc_set_spk),
+};
+#endif
+
+/*
+ * Logic for a wm8581 as connected on a Sharp SL-C7x0 Device
+ */
+static int tcc_wm8581_init(struct snd_soc_codec *codec)
+{
+#if 1
+	int i, err;
+
+	//snd_soc_dapm_nc_pin(codec, "LLINEIN");
+	//snd_soc_dapm_nc_pin(codec, "RLINEIN");
+	//snd_soc_dapm_enable_pin(codec, "MICIN");
+
+	/* Add tcc specific controls */
+	for (i = 0; i < ARRAY_SIZE(wm8581_tcc_controls); i++) {
+		err = snd_ctl_add(codec->card,
+			snd_soc_cnew(&wm8581_tcc_controls[i], codec, NULL));
+		if (err < 0)
+			return err;
+	}
+
+	/* Add tcc specific widgets */
+    snd_soc_dapm_new_controls(codec, wm8581_dapm_widgets, 
+                               ARRAY_SIZE(wm8581_dapm_widgets));
+
+#if 0
+	/* Set up tcc specific audio path audio_map */
+	snd_soc_dapm_add_routes(codec, audio_map, ARRAY_SIZE(audio_map));
+#endif
+
+#endif
+
+	snd_soc_dapm_sync(codec);
+	return 0;
+}
+
+static int tcc_wm8581_dummy_init(struct snd_soc_codec *codec)
+{
+    return 0;
+}
+
+
+extern struct snd_soc_platform tcc_soc_platform;
+
+/* tcc digital audio interface glue - connects codec <--> CPU */
+static struct snd_soc_dai_link tcc_dai[] = {
+    {
+        .name = "WM8581",
+        .stream_name = "WM8581",
+        .cpu_dai = &tcc_i2s_dai,
+        .codec_dai = &(wm8581_dai[0]),
+        .init = tcc_wm8581_init,
+        .ops = &tcc_ops,
+    },
+    {
+        .name = "TCC",
+        .stream_name = "IEC958",
+        .cpu_dai = &tcc_i2s_dai,
+        .codec_dai = &(wm8581_dai[0]),
+        .init = tcc_wm8581_dummy_init,
+        .ops = &tcc_ops,
+    },
+};
+
+static int tcc_board_probe(struct platform_device *pdev)
+{
+    GPIO *pStrGPIOBaseReg = (GPIO *)tcc_p2v(HwGPIO_BASE);
+    printk("TCC Board probe [%s]\n", __FUNCTION__);
+
+    tca_tcc_initport(pStrGPIOBaseReg);
+    /* For S/PDIF setting */
+	pStrGPIOBaseReg->GPDFN1 |= Hw12;	//SPD_TX(1)
+
+   // tca_ckc_com_setperibus(RB_DAI, 1);
+    tca_ckc_setiobus(RB_DAICDIFCONTROLLER, ENABLE);
+    return 0;
+}
+
+/* tcc audio machine driver */
+static struct snd_soc_machine snd_soc_machine_tcc = {
+	.name = "tccx_board",
+    .probe = tcc_board_probe,
+	.dai_link = tcc_dai,
+	.num_links = 2,
+};
+
+
+/* tcc audio private data */
+static struct wm8581_setup_data tcc_wm8581_setup = {
+    .i2c_bus = 0,
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	.i2c_address = 0x1B,  
+#else
+	.i2c_address = 0x34,		
+#endif
+};
+
+/* tcc audio subsystem */
+static struct snd_soc_device tcc_snd_devdata = {
+	.machine = &snd_soc_machine_tcc,
+	.platform = &tcc_soc_platform,
+	.codec_dev = &soc_codec_dev_wm8581,
+	.codec_data = &tcc_wm8581_setup,
+};
+
+static struct platform_device *tcc_snd_device;
+
+static int __init tcc_init(void)
+{
+	int ret;
+
+    tcc_pca953x_setup(PCA9539_U3_SLAVE_ADDR, CODEC_ON, OUTPUT, HIGH, SET_DIRECTION | SET_VALUE);
+    tcc_pca953x_setup(PCA9539_U2_SLAVE_ADDR, MUTE_CTL, OUTPUT, LOW, SET_DIRECTION | SET_VALUE);
+
+	tcc_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!tcc_snd_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(tcc_snd_device, &tcc_snd_devdata);
+	tcc_snd_devdata.dev = &tcc_snd_device->dev;
+	ret = platform_device_add(tcc_snd_device);
+
+	if (ret)
+		platform_device_put(tcc_snd_device);
+
+	return ret;
+}
+
+static void __exit tcc_exit(void)
+{
+	platform_device_unregister(tcc_snd_device);
+}
+
+module_init(tcc_init);
+module_exit(tcc_exit);
+
+/* Module information */
+MODULE_AUTHOR("linux <linux@telechips.com>");
+MODULE_DESCRIPTION("ALSA SoC TCCxx Board");
+MODULE_LICENSE("GPL");
+
Index: linux-2.6.29/tcc_mkrd.sh
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/tcc_mkrd.sh	2010-04-07 13:00:58.000000000 -0400
@@ -0,0 +1,42 @@
+#=======================================================================================
+#	FileName    : tcc_mkrd.sh
+#	Description : Make linux.rom
+#                 Mark linux.rom with CRC & ramdisk size
+#=======================================================================================
+#
+#	TCC Board Support Package
+#	Copyright (c) Telechips, Inc.
+#	ALL RIGHTS RESERVED
+#
+#=======================================================================================
+
+source .config
+
+#
+# ramdisk.rom size (MByte)
+#
+RAMDISK_SIZE=16
+
+echo
+echo "======================================================"
+if test $CONFIG_ARCH_TCC; then
+echo -e "[\x1b[1;33mTelechips TCC8900\x1b[0m]"
+fi
+
+# make linux.img
+echo
+echo -e "[\x1b[1;33mMAKE\x1b[0m] \x1b[1;31mlinux.rom\x1b[0m"
+dd if=arch/arm/boot/Image of=linux.img bs=4M conv=sync
+
+# insert CRC & ramdisk.rom size
+echo
+echo -e "[\x1b[1;33mMARK\x1b[0m] CRC & ramdisk size \x1b[1;31m$RAMDISK_SIZE\x1b[0m Mbyte"
+../../util/tcc_crc/tcc_crc -o linux.rom -v 1700 -r $RAMDISK_SIZE linux.img
+
+
+# remove Img, linux.img
+rm -f linux.img
+echo "======================================================"
+echo
+
+exit
Index: linux-2.6.29/arch/arm/mm/Kconfig
===================================================================
--- linux-2.6.29.orig/arch/arm/mm/Kconfig	2010-04-07 12:29:33.000000000 -0400
+++ linux-2.6.29/arch/arm/mm/Kconfig	2010-04-07 12:29:36.000000000 -0400
@@ -362,7 +362,8 @@
 
 # ARMv6
 config CPU_V6
-	bool "Support ARM V6 processor" if ARCH_INTEGRATOR || MACH_REALVIEW_EB
+	bool "Support ARM V6 processor" if ARCH_INTEGRATOR || MACH_REALVIEW_EB || MACH_TCC8900 || MACH_TCC9200
+	default y if ARCH_TCC
 	select CPU_32v6
 	select CPU_ABRT_EV6
 	select CPU_PABRT_NOIFAR
Index: linux-2.6.29/arch/arm/tools/mach-types
===================================================================
--- linux-2.6.29.orig/arch/arm/tools/mach-types	2010-04-07 12:29:33.000000000 -0400
+++ linux-2.6.29/arch/arm/tools/mach-types	2010-04-07 12:29:36.000000000 -0400
@@ -1902,6 +1902,9 @@
 sygdg2			MACH_SYGDG2		SYGDG2			1912
 seoul			MACH_SEOUL		SEOUL			1913
 salerno			MACH_SALERNO		SALERNO			1914
+tcc8900			MACH_TCC8900		TCC8900			4000
+tcc9100			MACH_TCC9100		TCC9100			4001
+tcc9200			MACH_TCC9200		TCC9200			4002
 ucn_s3c64xx		MACH_UCN_S3C64XX	UCN_S3C64XX		1915
 msm7201a		MACH_MSM7201A		MSM7201A		1916
 lpr1			MACH_LPR1		LPR1			1917
Index: linux-2.6.29/drivers/Kconfig
===================================================================
--- linux-2.6.29.orig/drivers/Kconfig	2010-04-07 12:29:34.000000000 -0400
+++ linux-2.6.29/drivers/Kconfig	2010-04-07 12:29:36.000000000 -0400
@@ -108,5 +108,7 @@
 
 source "drivers/staging/Kconfig"
 
+source "drivers/dpm/Kconfig"
+
 source "drivers/platform/Kconfig"
 endmenu
Index: linux-2.6.29/drivers/i2c/chips/Makefile
===================================================================
--- linux-2.6.29.orig/drivers/i2c/chips/Makefile	2010-04-07 12:29:33.000000000 -0400
+++ linux-2.6.29/drivers/i2c/chips/Makefile	2010-04-07 12:29:36.000000000 -0400
@@ -17,6 +17,8 @@
 obj-$(CONFIG_PCF8575)		+= pcf8575.o
 obj-$(CONFIG_SENSORS_PCF8591)	+= pcf8591.o
 obj-$(CONFIG_SENSORS_TSL2550)	+= tsl2550.o
+obj-$(CONFIG_TCC_I2C_WM8731)	+= tcc_wm8731.o
+obj-$(CONFIG_TCC_I2C_PCA953X)	+= tcc_pca953x.o
 
 ifeq ($(CONFIG_I2C_DEBUG_CHIP),y)
 EXTRA_CFLAGS += -DDEBUG
Index: linux-2.6.29/drivers/video/logo/logo_linux_clut224.ppm
===================================================================
--- linux-2.6.29.orig/drivers/video/logo/logo_linux_clut224.ppm	2010-04-07 12:29:33.000000000 -0400
+++ linux-2.6.29/drivers/video/logo/logo_linux_clut224.ppm	2010-04-07 12:29:36.000000000 -0400
@@ -1,2828 +1,2828 @@
-P3
-145 113
-255
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  3 4 4  6 7 7
-8 10 10  8 10 10  6 8 8  6 7 7  3 4 4  2 2 2
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  4 5 5  17 18 17
-27 29 28  35 37 36  40 43 41  43 45 43  40 43 41  37 39 37
-32 34 33  27 30 29  23 25 24  17 21 21  15 18 18  12 15 15
-11 13 13  8 10 10  6 7 7  3 4 4  1 1 1  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  13 13 13  32 34 33  49 51 48  60 60 56  58 59 55
-55 57 54  55 56 53  49 51 48  43 45 43  39 40 39  33 37 35
-28 31 30  23 27 26  20 23 23  17 20 20  14 17 17  13 16 16
-11 14 14  10 13 13  10 12 12  9 11 11  8 10 10  6 7 7
-2 3 3  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  6 7 7  12 15 15
-12 15 15  8 9 9  2 3 3  0 0 0  1 1 1  25 27 26
-55 56 53  68 70 65  65 66 61  65 66 61  63 64 60  63 64 60
-58 59 55  51 52 50  47 48 46  41 42 42  35 37 36  30 32 31
-26 28 27  20 24 24  18 22 22  16 19 19  14 17 17  13 16 16
-12 15 15  11 14 14  10 13 13  10 12 12  9 11 11  8 10 10
-8 9 9  6 8 8  3 3 3  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  6 7 7  20 24 24  23 27 26
-23 27 26  18 22 22  11 13 13  23 24 24  61 63 57  72 73 67
-72 73 67  68 70 65  68 70 65  68 70 65  63 64 60  58 59 55
-55 56 53  47 48 46  41 42 42  35 37 36  30 32 31  26 28 27
-20 24 24  18 22 22  16 20 20  15 19 19  14 17 17  13 16 16
-12 15 15  12 15 15  11 14 14  10 13 13  10 12 12  9 11 11
-8 10 10  8 9 9  7 9 9  6 7 7  1 2 2  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  1 1 1  4 5 5  5 6 5  4 5 5
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  15 19 19  40 41 39  53 55 47
-33 36 34  27 30 29  51 52 50  72 73 67  72 73 67  72 73 67
-72 73 67  68 70 65  68 70 65  63 64 60  58 59 55  51 52 50
-47 48 46  40 43 41  33 37 35  30 32 31  26 28 27  20 24 24
-18 22 22  17 21 21  16 19 19  14 18 18  14 17 17  13 17 17
-13 16 16  12 15 15  12 15 15  11 14 14  10 13 13  10 12 12
-9 11 11  8 10 10  8 9 9  7 9 9  6 8 8  3 4 4
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-2 2 2  6 8 8  10 12 12  10 12 12  10 12 12  10 12 12
-6 8 8  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  20 23 23  71 71 57  131 127 93
-115 113 82  63 64 60  72 73 67  72 73 67  72 73 67  72 73 67
-68 70 65  65 66 61  61 63 57  55 57 54  49 51 48  43 45 43
-39 40 39  33 36 34  28 31 30  23 27 26  20 24 24  20 23 23
-17 21 21  16 20 20  15 19 19  15 18 18  14 18 18  14 17 17
-13 17 17  13 16 16  12 15 15  12 15 15  11 14 14  10 13 13
-10 12 12  9 11 11  8 10 10  7 9 9  7 9 9  6 8 8
-4 5 5  0 0 0  0 0 0  0 0 0  1 1 1  6 7 7
-10 12 12  10 12 12  10 12 12  10 12 12  10 12 12  10 12 12
-10 12 12  3 4 4  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  18 22 22  71 71 57  144 139 99
-84 83 72  68 70 65  72 73 67  72 73 67  68 70 65  65 66 61
-63 64 60  55 57 54  51 52 50  47 48 46  40 43 41  35 37 36
-30 32 31  27 29 28  23 27 26  20 24 24  18 22 22  17 21 21
-16 20 20  15 19 19  15 19 19  15 19 19  15 18 18  14 18 18
-14 17 17  13 17 17  13 16 16  12 15 15  12 15 15  11 14 14
-10 13 13  9 12 12  9 11 11  8 10 10  7 9 9  6 8 8
-6 8 8  3 4 4  0 0 0  2 2 2  8 10 10  10 12 12
-10 12 12  10 12 12  11 13 13  36 38 35  61 61 53  48 49 45
-10 12 12  7 9 9  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  15 19 19  61 61 53  84 83 72
-68 70 65  72 73 67  68 70 65  68 70 65  63 64 60  58 59 55
-51 52 50  47 48 46  41 42 42  37 39 37  32 35 33  28 31 30
-23 27 26  20 24 24  20 23 23  18 22 22  17 21 21  17 21 21
-17 21 21  17 21 21  17 20 20  16 20 20  16 20 20  16 19 19
-15 18 18  14 18 18  13 17 17  13 16 16  12 15 15  12 15 15
-11 14 14  10 13 13  9 12 12  9 11 11  8 10 10  7 9 9
-6 8 8  6 8 8  5 6 5  9 11 11  10 12 12  10 12 12
-19 20 18  82 81 62  149 145 103  160 154 106  142 137 94  96 95 69
-10 12 12  10 12 12  1 1 1  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  10 12 12  44 46 43  68 70 65
-72 73 67  68 70 65  68 70 65  63 64 60  55 57 54  49 51 48
-43 45 43  39 40 39  33 37 35  30 32 31  26 28 27  23 27 26
-20 24 24  18 22 22  18 22 22  18 22 22  18 22 22  20 23 23
-20 24 24  23 25 24  23 25 24  22 24 23  20 23 23  18 22 22
-17 20 20  15 19 19  15 18 18  14 17 17  13 16 16  12 15 15
-11 14 14  11 13 13  10 12 12  9 11 11  8 10 10  8 9 9
-7 9 9  7 9 9  10 12 12  10 12 12  10 12 12  71 71 57
-164 159 111  186 182 128  186 182 128  171 165 117  151 147 98  96 95 69
-10 12 12  10 12 12  3 3 3  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  8 10 10  63 64 60  68 70 65
-72 73 67  68 70 65  63 64 60  55 57 54  47 48 46  40 43 41
-33 37 35  30 32 31  27 29 28  23 27 26  20 24 24  20 23 23
-18 22 22  18 22 22  20 23 22  21 25 23  23 27 26  27 29 28
-28 31 30  31 33 31  31 33 31  31 33 31  28 31 30  26 28 27
-23 25 24  20 23 22  16 20 20  15 18 18  14 17 17  13 16 16
-12 15 15  11 14 14  10 13 13  10 12 12  9 11 11  8 10 10
-10 12 12  10 13 13  10 12 12  12 14 14  96 95 69  165 161 109
-186 182 128  192 187 134  192 187 134  176 171 126  160 154 106  103 101 77
-10 12 12  10 12 12  5 6 5  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  35 37 36  68 70 65  72 73 67
-68 70 65  65 66 61  58 59 55  49 51 48  40 43 41  33 37 35
-28 31 30  23 27 26  20 24 24  20 23 23  18 22 22  18 22 22
-18 22 22  20 23 23  23 27 26  27 30 29  32 35 33  37 39 37
-40 43 41  44 46 43  46 47 43  44 46 43  40 43 41  36 38 35
-31 33 31  27 29 28  22 24 23  17 21 21  15 18 18  14 17 17
-13 16 16  12 15 15  11 14 14  11 14 14  11 13 13  13 16 16
-13 16 16  11 14 14  10 12 12  79 78 62  142 137 94  164 159 111
-178 174 128  192 187 134  192 187 134  176 171 126  160 154 106  96 95 69
-10 12 12  10 12 12  6 7 7  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  55 57 54  68 70 65  72 73 67
-68 70 65  63 64 60  55 56 53  43 45 43  35 37 36  28 31 30
-23 27 26  20 24 24  18 22 22  17 21 21  17 21 21  17 21 21
-20 24 24  25 27 26  31 33 31  38 39 37  46 47 43  53 55 47
-61 61 53  66 65 55  66 65 55  66 65 55  61 61 53  53 55 47
-46 47 43  37 39 37  30 33 30  24 26 24  17 21 21  15 18 18
-13 17 17  12 15 15  12 15 15  13 16 16  14 18 18  14 18 18
-14 17 17  12 15 15  30 31 28  118 116 76  134 131 96  160 154 106
-174 170 121  178 174 128  178 174 128  171 165 117  151 147 98  96 95 69
-10 12 12  10 12 12  6 8 8  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  63 64 60  68 70 65  68 70 65
-65 66 61  58 59 55  49 51 48  39 40 39  30 32 31  23 27 26
-20 24 24  18 22 22  17 21 21  16 20 20  17 21 21  20 23 23
-25 27 26  32 35 33  43 44 41  53 55 47  66 65 55  75 75 61
-82 81 62  84 83 72  87 86 72  87 86 72  82 81 62  75 75 61
-66 65 55  53 55 47  40 41 39  31 33 31  23 25 24  17 20 20
-14 18 18  13 16 16  12 15 15  12 15 15  13 17 17  14 18 18
-14 18 18  13 16 16  46 47 43  96 95 69  125 122 87  142 137 94
-160 154 106  165 161 109  164 159 111  155 149 109  142 137 94  75 75 61
-10 12 12  10 12 12  6 8 8  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  60 60 56  68 70 65  68 70 65
-63 64 60  55 57 54  46 47 45  35 37 36  27 30 29  23 25 24
-18 22 22  17 21 21  16 20 20  17 21 21  18 22 22  23 27 26
-31 33 31  43 44 41  55 56 53  71 71 57  84 83 72  92 91 72
-103 101 77  92 91 72  82 81 62  82 81 62  87 86 72  92 91 72
-84 83 72  71 71 57  55 56 53  43 44 41  30 33 30  22 24 23
-16 19 19  14 17 17  12 15 15  12 15 15  13 16 16  14 18 18
-14 18 18  14 17 17  43 44 41  82 81 62  118 116 76  125 122 87
-142 137 94  144 139 99  144 139 99  134 131 96  118 116 76  53 55 47
-10 12 12  10 12 12  6 8 8  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  47 48 46  63 64 60  63 64 60
-55 57 54  49 51 48  40 43 41  32 34 33  26 28 27  20 24 24
-18 22 22  16 20 20  16 20 20  17 21 21  20 24 24  28 31 30
-40 41 39  53 55 47  75 75 61  90 89 73  87 86 72  48 49 45
-14 14 13  2 2 2  1 2 2  1 1 1  1 1 1  2 2 2
-19 20 18  43 44 41  66 65 55  53 55 47  38 39 37  26 28 27
-18 22 22  14 18 18  13 16 16  12 15 15  12 15 15  13 17 17
-14 18 18  14 18 18  30 31 28  66 65 55  96 95 69  103 101 77
-118 116 76  118 116 76  118 116 76  118 116 76  103 101 77  36 38 35
-10 12 12  10 12 12  6 7 7  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  28 31 30  55 57 54  51 52 50
-49 51 48  41 42 42  35 37 36  28 31 30  23 27 26  20 23 23
-17 21 21  16 20 20  16 20 20  18 22 22  23 27 26  33 36 34
-48 49 45  71 71 57  82 81 62  43 44 41  8 9 9  6 7 7
-6 7 7  6 7 7  6 7 7  5 6 5  4 5 5  3 4 4
-2 3 3  1 2 2  4 5 4  36 38 35  48 49 45  32 35 33
-21 25 23  16 19 19  13 17 17  12 15 15  12 15 15  13 16 16
-14 18 18  14 18 18  16 18 16  36 38 35  61 61 53  82 81 62
-96 95 69  96 95 69  96 95 69  96 95 69  79 78 62  19 20 18
-10 12 12  10 12 12  4 5 5  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  13 13 13  46 47 45  43 45 43
-40 43 41  35 37 36  30 32 31  23 27 26  20 24 24  18 22 22
-17 21 21  16 20 20  17 21 21  20 23 23  27 30 29  40 41 39
-61 61 53  53 55 47  16 17 16  9 11 11  10 12 12  10 12 12
-10 12 12  10 12 12  10 12 12  9 11 11  8 10 10  8 9 9
-6 8 8  5 6 5  4 5 5  2 3 3  19 20 18  38 39 37
-26 28 27  17 21 21  14 17 17  13 16 16  12 15 15  12 15 15
-13 17 17  14 18 18  12 15 15  13 12 7  30 31 28  46 47 43
-53 55 47  66 65 55  66 65 55  53 55 47  36 38 35  10 12 12
-10 12 12  10 12 12  2 3 3  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  1 1 1  33 37 35  35 37 36
-32 35 33  28 31 30  23 27 26  20 24 24  18 22 22  17 21 21
-16 20 20  16 20 20  17 21 21  21 25 23  31 33 31  44 46 43
-31 33 31  11 13 13  12 14 14  12 15 15  13 16 16  14 17 17
-14 17 17  14 17 17  14 17 17  13 16 16  12 15 15  12 14 14
-11 13 13  9 11 11  8 10 10  6 8 8  4 5 5  17 18 17
-30 33 30  20 23 22  15 18 18  13 16 16  12 15 15  12 14 14
-13 16 16  14 17 17  14 18 18  11 12 11  7 7 5  16 17 12
-21 22 20  30 31 28  25 27 25  21 22 20  14 14 13  10 12 12
-10 12 12  9 11 11  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  18 22 22  27 30 29
-27 29 28  40 41 39  53 55 47  53 55 47  53 55 47  46 47 43
-25 27 25  16 20 20  17 21 21  23 25 24  31 33 31  20 20 20
-12 15 15  14 17 17  15 19 19  16 20 20  17 21 21  18 22 22
-18 22 22  18 22 22  18 22 22  17 21 21  17 21 21  16 19 19
-15 18 18  13 16 16  12 15 15  10 12 12  8 10 10  6 8 8
-21 22 21  22 24 23  15 19 19  13 17 17  13 16 16  12 15 15
-12 15 15  13 17 17  14 18 18  14 18 18  13 15 14  10 9 6
-7 7 5  7 7 5  7 7 5  9 11 11  10 12 12  10 12 12
-10 12 12  6 7 7  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  16 17 12  82 81 62
-118 116 76  118 116 76  161 156 96  161 156 96  161 156 96  118 116 76
-118 116 76  96 95 69  53 55 47  22 24 23  14 17 17  13 16 16
-15 19 19  17 21 21  18 22 22  20 24 24  20 24 24  23 27 26
-23 27 26  23 27 26  23 27 26  23 27 26  23 27 26  20 24 24
-20 23 23  17 21 21  16 19 19  14 17 17  12 15 15  10 12 12
-9 11 11  20 23 22  16 19 19  14 17 17  13 16 16  12 15 15
-11 14 14  13 16 16  14 17 17  14 18 18  14 17 17  12 15 15
-10 12 12  10 12 12  10 12 12  10 12 12  10 12 12  10 12 12
-9 11 11  1 1 1  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  53 55 47  161 156 96
-161 156 96  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  161 156 96  118 116 76  96 95 69  21 22 20  16 19 19
-18 22 22  20 24 24  23 27 26  23 27 26  26 28 27  27 30 29
-27 30 29  18 22 22  12 14 14  8 10 10  9 11 11  17 21 21
-23 27 26  23 27 26  20 24 24  18 22 22  16 20 20  14 17 17
-12 14 14  14 17 17  16 20 20  14 17 17  13 17 17  13 16 16
-12 15 15  12 15 15  13 17 17  14 18 18  14 17 17  13 16 16
-11 13 13  10 12 12  10 12 12  10 12 12  10 12 12  10 12 12
-4 5 5  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  13 12 7  118 116 76  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  161 156 96  118 116 76  30 31 28
-20 24 24  23 27 26  27 30 29  28 31 30  30 32 31  23 27 26
-16 19 19  17 21 21  12 15 15  9 11 11  10 12 12  9 11 11
-20 24 24  28 31 30  26 28 27  23 27 26  20 24 24  17 21 21
-15 19 19  13 16 16  16 19 19  14 18 18  14 17 17  13 16 16
-12 15 15  11 14 14  13 16 16  14 17 17  14 18 18  14 17 17
-12 15 15  10 12 12  10 12 12  10 12 12  10 12 12  8 9 9
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  82 81 62  161 156 96  230 229 82
-230 229 82  233 233 100  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  161 156 96  118 116 76
-27 29 28  27 30 29  30 32 31  30 32 31  23 27 26  20 24 24
-26 28 27  17 21 21  6 7 7  72 73 67  145 141 105  15 15 15
-14 17 17  33 37 35  30 32 31  28 31 30  26 28 27  23 27 26
-20 23 23  16 20 20  15 19 19  14 18 18  14 17 17  13 16 16
-12 15 15  11 14 14  12 15 15  13 17 17  14 18 18  14 17 17
-13 16 16  11 13 13  10 12 12  10 12 12  9 11 11  1 1 1
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  16 17 12  161 156 96  230 229 82  230 229 82
-243 242 120  235 234 117  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  161 156 96
-82 81 62  28 31 30  28 31 30  27 30 29  28 31 30  30 32 31
-33 37 35  13 16 16  3 3 3  105 104 92  210 208 158  12 14 14
-17 21 21  33 37 35  33 37 35  32 35 33  30 32 31  27 30 29
-23 27 26  20 23 23  17 20 20  15 18 18  14 18 18  13 17 17
-13 16 16  12 15 15  11 14 14  13 16 16  14 17 17  14 18 18
-13 17 17  12 15 15  10 12 12  10 12 12  3 4 4  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  96 95 69  230 229 82  230 229 82  244 244 132
-241 241 143  243 242 120  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-161 156 96  46 47 43  32 35 33  33 37 35  33 37 35  33 37 35
-40 43 41  23 27 26  1 1 1  2 2 2  24 26 24  14 17 17
-23 27 26  33 37 35  33 37 35  33 37 35  33 37 35  30 32 31
-27 30 29  23 27 26  20 23 23  15 18 18  14 18 18  14 17 17
-13 16 16  12 15 15  11 14 14  12 15 15  13 17 17  14 17 17
-14 17 17  13 16 16  11 13 13  6 8 8  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  16 17 12  161 156 96  230 229 82  235 234 117  239 239 170
-239 239 170  236 236 101  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  118 116 76  33 37 35  33 37 35  37 39 37  37 39 37
-43 45 43  49 51 48  20 24 24  8 10 10  17 20 20  35 37 36
-33 37 35  40 43 41  37 39 37  35 37 36  33 37 35  33 37 35
-30 32 31  27 30 29  23 27 26  15 19 19  14 18 18  14 17 17
-13 17 17  13 16 16  12 15 15  11 14 14  13 16 16  14 17 17
-14 17 17  13 17 17  11 14 14  4 5 5  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  96 95 69  230 229 82  230 229 82  239 239 170  251 251 187
-241 241 143  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  161 156 96  36 38 35  33 37 35  33 37 35  33 37 35
-37 39 37  47 48 46  55 57 54  55 57 54  49 51 48  43 45 43
-43 45 43  43 45 43  40 43 41  40 43 41  37 39 37  33 37 35
-33 37 35  28 31 30  26 28 27  16 20 20  15 18 18  14 18 18
-14 17 17  13 16 16  12 15 15  11 14 14  12 15 15  13 17 17
-14 17 17  14 17 17  8 10 10  5 7 7  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-16 17 12  230 229 82  230 229 82  243 242 120  251 251 187  251 251 187
-246 246 123  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  230 229 82  66 65 55  30 32 31  32 35 33  33 37 35
-33 37 35  37 39 37  40 43 41  47 48 46  49 51 48  51 52 50
-55 57 54  55 57 54  51 52 50  47 48 46  43 45 43  39 40 39
-33 37 35  30 32 31  26 28 27  17 21 21  15 19 19  14 18 18
-14 17 17  13 16 16  12 15 15  12 14 14  11 14 14  13 16 16
-14 17 17  12 15 15  7 9 9  6 8 8  1 1 1  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-96 95 69  230 229 82  230 229 82  239 239 170  251 251 187  239 239 170
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  230 229 82  96 95 69  27 30 29  28 31 30  30 32 31
-33 37 35  40 43 41  46 47 45  55 57 54  63 64 60  72 73 67
-72 73 67  72 73 67  72 73 67  65 66 61  55 57 54  47 48 46
-39 40 39  32 35 33  27 30 29  17 21 21  15 19 19  15 18 18
-14 18 18  13 17 17  13 16 16  12 15 15  11 14 14  12 14 14
-13 16 16  9 11 11  7 9 9  9 11 11  66 65 55  115 113 82
-21 22 20  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  13 12 7
-230 229 82  230 229 82  236 236 101  251 251 187  251 251 187  246 246 123
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  230 229 82  118 116 76  23 27 26  26 28 27  32 35 33
-51 52 50  90 89 73  110 109 94  145 141 105  168 163 120  177 172 135
-177 172 135  188 184 146  188 184 146  181 176 137  194 191 148  188 184 146
-184 179 149  188 184 146  188 184 146  156 151 111  177 172 135  181 176 137
-177 172 135  168 163 120  168 163 120  158 153 112  156 151 111  158 153 112
-156 151 111  158 153 112  177 172 135  188 184 146  188 184 146  194 189 146
-36 38 35  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  82 81 62
-230 229 82  230 229 82  244 244 132  251 251 187  244 244 132  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  161 156 96  82 81 62
-96 95 69  230 229 82  181 178 103  110 109 94  156 151 111  188 184 146
-188 184 146  197 193 154  188 184 146  184 181 136  188 184 146  168 163 120
-168 163 120  178 174 128  156 151 111  158 153 112  174 170 121  156 151 111
-156 151 111  158 153 112  156 151 111  168 163 120  178 174 128  181 176 137
-176 171 126  178 174 128  184 181 136  176 171 126  178 174 128  184 181 136
-176 171 126  178 174 128  184 181 136  164 159 111  155 149 109  96 95 69
-1 1 1  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  2 2 1  161 156 96
-230 229 82  230 229 82  244 244 132  244 244 132  236 236 101  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  46 47 43  82 81 62
-158 153 112  197 193 154  194 189 146  184 181 136  188 184 146  168 163 120
-156 151 111  137 133 100  131 127 93  137 133 100  137 133 100  158 153 112
-121 119 87  137 133 100  156 151 111  145 141 105  99 98 80  84 83 72
-63 64 60  52 53 49  40 43 41  33 36 34  36 38 35  36 38 35
-38 39 37  43 44 41  43 44 41  46 47 43  48 49 45  48 49 45
-46 47 43  36 38 35  30 31 28  19 20 18  6 7 7  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  36 38 35  230 229 82
-230 229 82  230 229 82  246 246 123  236 236 101  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  53 55 47  121 119 87
-176 171 126  171 165 117  161 156 96  82 81 62  53 55 47  33 37 35
-39 40 39  63 64 60  99 98 80  121 119 87  137 133 100  177 172 135
-176 171 126  184 181 136  131 127 93  131 127 93  110 109 94  84 83 72
-51 52 50  39 40 39  27 29 28  18 22 22  16 19 19  15 19 19
-15 19 19  14 18 18  14 17 17  13 16 16  12 15 15  11 14 14
-10 13 13  9 12 12  9 11 11  8 9 9  7 9 9  1 1 1
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  118 116 76  230 229 82
-230 229 82  230 229 82  236 236 101  230 229 82  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  96 95 69  71 71 57
-36 38 35  118 116 76  118 116 76  12 15 15  15 18 18  20 24 24
-33 37 35  55 56 53  84 83 72  110 109 94  145 141 105  110 109 94
-168 163 120  121 119 87  156 151 111  131 127 93  87 86 72  61 63 57
-47 48 46  28 31 30  18 22 22  15 19 19  15 18 18  15 19 19
-15 19 19  14 18 18  14 17 17  13 17 17  13 16 16  12 15 15
-11 13 13  10 12 12  9 11 11  8 10 10  7 9 9  3 3 3
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  1 1 0  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  161 156 96
-161 156 96  230 229 82  118 116 76  11 14 14  14 17 17  18 22 22
-27 30 29  40 43 41  60 60 56  84 83 72  105 104 92  110 109 94
-110 109 94  110 109 94  99 98 80  90 89 73  68 70 65  47 48 46
-32 34 33  23 25 24  20 23 23  17 21 21  15 19 19  14 17 17
-15 19 19  15 18 18  14 18 18  13 17 17  13 16 16  12 15 15
-11 14 14  10 12 12  9 11 11  8 10 10  7 9 9  4 5 5
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  16 17 12  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  161 156 96  118 116 76  11 13 13  13 16 16  15 19 19
-20 24 24  30 32 31  40 43 41  51 52 50  63 64 60  72 73 67
-65 66 61  65 66 61  65 66 61  55 57 54  46 47 45  33 37 35
-27 29 28  20 24 24  17 21 21  16 20 20  16 20 20  15 19 19
-15 19 19  15 19 19  14 18 18  14 17 17  13 16 16  12 15 15
-11 14 14  10 13 13  9 12 12  8 10 10  7 9 9  6 7 7
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  53 55 47  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-161 156 96  118 116 76  53 55 47  10 13 13  12 15 15  14 17 17
-17 20 20  20 24 24  27 29 28  32 34 33  37 39 37  40 43 41
-43 45 43  41 42 42  35 37 36  30 32 31  28 31 30  23 27 26
-20 23 23  17 21 21  16 20 20  16 20 20  16 20 20  16 19 19
-15 19 19  15 19 19  14 18 18  14 17 17  13 16 16  12 15 15
-11 14 14  10 13 13  9 12 12  9 11 11  8 10 10  10 12 12
-1 1 1  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  82 81 62  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  161 156 96  161 156 96
-118 116 76  82 81 62  13 14 12  10 13 13  12 15 15  13 17 17
-15 19 19  16 20 20  20 23 23  20 24 24  23 27 26  26 28 27
-26 28 27  26 28 27  23 27 26  18 22 22  20 23 23  17 21 21
-17 21 21  16 20 20  16 20 20  16 20 20  16 20 20  16 19 19
-15 19 19  15 19 19  15 18 18  14 17 17  13 17 17  13 16 16
-12 15 15  12 14 14  12 14 14  12 14 14  12 14 14  23 24 24
-6 8 8  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  118 116 76  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  161 156 96  161 156 96  118 116 76
-71 71 57  13 14 12  9 12 12  10 13 13  12 15 15  13 17 17
-15 18 18  15 19 19  16 20 20  17 21 21  17 21 21  18 22 22
-18 22 22  18 22 22  17 21 21  16 19 19  15 18 18  14 18 18
-16 19 19  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
-15 19 19  15 19 19  15 18 18  14 18 18  16 20 20  23 25 24
-17 21 21  25 27 26  47 48 46  47 48 46  51 52 50  72 73 67
-33 36 34  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  118 116 76  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  230 229 82  161 156 96  118 116 76  118 116 76  46 47 43
-9 11 11  9 11 11  10 12 12  11 13 13  12 15 15  14 17 17
-15 18 18  15 19 19  16 20 20  16 20 20  16 20 20  16 20 20
-16 20 20  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
-15 19 19  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
-15 19 19  16 20 20  20 24 24  55 56 53  32 34 33  84 83 72
-90 89 73  110 109 94  110 109 94  105 104 92  110 109 94  110 109 94
-72 73 67  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  96 95 69  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  161 156 96  118 116 76  82 81 62  16 17 12  9 11 11
-9 11 11  9 12 12  10 13 13  12 14 14  13 16 16  14 18 18
-15 19 19  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
-16 20 20  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
-16 20 20  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
-16 19 19  33 36 34  99 98 80  156 151 111  145 141 105  184 179 149
-168 163 120  184 179 149  177 172 135  156 151 111  145 141 105  110 109 94
-90 89 73  2 2 2  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  71 71 57  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
-230 229 82  161 156 96  230 229 82  230 229 82  230 229 82  161 156 96
-118 116 76  82 81 62  30 31 28  9 11 11  9 11 11  9 11 11
-10 12 12  10 13 13  11 14 14  13 16 16  14 17 17  15 18 18
-15 19 19  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
-16 20 20  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
-16 20 20  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
-18 22 22  58 59 55  137 133 100  197 193 154  214 212 158  210 208 158
-197 193 154  184 179 149  184 179 149  137 133 100  110 109 94  99 98 80
-84 83 72  10 10 9  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  16 17 12  230 229 82  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  161 156 96
-161 156 96  161 156 96  161 156 96  161 156 96  118 116 76  71 71 57
-21 22 20  12 14 14  11 13 13  10 12 12  10 12 12  10 13 13
-11 13 13  12 15 15  13 16 16  14 17 17  14 18 18  15 19 19
-16 20 20  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
-16 20 20  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
-16 20 20  16 20 20  16 20 20  16 20 20  16 20 20  17 21 21
-23 27 26  84 83 72  184 179 149  251 251 187  210 208 158  184 179 149
-184 179 149  156 151 111  110 109 94  84 83 72  63 64 60  51 52 50
-18 22 22  6 8 8  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  118 116 76  230 229 82
-230 229 82  230 229 82  230 229 82  230 229 82  161 156 96  161 156 96
-161 156 96  161 156 96  118 116 76  53 55 47  20 23 22  16 19 19
-13 16 16  12 15 15  12 14 14  11 14 14  11 14 14  11 14 14
-12 15 15  13 16 16  14 17 17  15 19 19  16 20 20  17 21 21
-23 27 26  18 22 22  20 24 24  23 27 26  30 32 31  17 21 21
-16 20 20  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
-16 20 20  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
-23 27 26  33 37 35  137 133 100  156 151 111  158 153 112  105 104 92
-105 104 92  68 70 65  39 40 39  18 22 22  12 14 14  12 15 15
-9 11 11  4 5 5  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  16 17 12  230 229 82
-230 229 82  230 229 82  230 229 82  161 156 96  118 116 76  118 116 76
-118 116 76  66 65 55  43 45 43  32 34 33  25 27 26  20 23 22
-17 20 20  15 18 18  14 17 17  15 18 18  13 16 16  14 17 17
-14 18 18  16 20 20  32 34 33  55 57 54  58 59 55  72 73 67
-105 104 92  55 57 54  65 66 61  63 64 60  40 43 41  33 37 35
-41 42 42  20 24 24  16 20 20  16 20 20  16 20 20  16 20 20
-16 20 20  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
-17 21 21  26 28 27  30 32 31  35 37 36  68 70 65  39 40 39
-23 27 26  15 18 18  13 16 16  11 14 14  9 12 12  8 10 10
-7 9 9  6 7 7  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  36 38 35
-230 229 82  230 229 82  230 229 82  96 95 69  30 31 28  49 51 48
-90 89 73  68 70 65  55 57 54  47 48 46  47 48 46  43 45 43
-32 34 33  43 45 43  43 45 43  23 27 26  25 27 26  40 43 41
-40 43 41  90 89 73  110 109 94  145 141 105  156 151 111  156 151 111
-184 179 149  184 179 149  177 172 135  184 179 149  137 133 100  84 83 72
-105 104 92  63 64 60  49 51 48  47 48 46  28 31 30  18 22 22
-16 20 20  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
-16 20 20  15 19 19  15 19 19  15 19 19  18 22 22  15 19 19
-13 16 16  12 15 15  11 14 14  10 13 13  9 12 12  9 11 11
-8 10 10  6 8 8  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-30 31 28  230 229 82  71 71 57  2 2 1  0 0 0  58 59 55
-105 104 92  84 83 72  65 66 61  84 83 72  110 109 94  110 109 94
-145 141 105  105 104 92  110 109 94  110 109 94  84 83 72  110 109 94
-158 153 112  197 193 154  197 193 154  239 239 170  251 251 187  251 251 187
-251 251 187  251 251 187  251 251 187  251 251 187  210 208 158  197 193 154
-197 193 154  184 179 149  145 141 105  137 133 100  105 104 92  47 48 46
-20 23 23  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
-16 20 20  16 19 19  15 19 19  15 19 19  14 18 18  14 17 17
-13 17 17  13 16 16  12 14 14  12 14 14  13 13 13  13 13 13
-13 13 13  12 12 12  10 10 9  6 7 7  2 2 2  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  1 1 0  0 0 0  0 0 0  65 66 61
-105 104 92  84 83 72  84 83 72  110 109 94  184 179 149  210 208 158
-210 208 158  210 208 158  214 212 158  197 193 154  214 212 158  210 208 158
-251 251 187  251 251 187  251 251 187  251 251 187  251 251 187  251 251 187
-251 251 187  251 251 187  251 251 187  251 251 187  251 251 187  251 251 187
-251 251 187  251 251 187  239 239 170  251 251 187  184 179 149  84 83 72
-26 28 27  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
-16 20 20  16 20 20  15 19 19  15 19 19  15 18 18  14 18 18
-13 17 17  13 16 16  15 15 15  14 14 13  14 14 13  14 14 13
-13 13 13  13 13 13  12 12 12  12 12 12  12 12 12  3 4 4
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  72 73 67
-105 104 92  99 98 80  84 83 72  99 98 80  177 172 135  197 193 154
-251 251 187  251 251 187  251 251 187  251 251 187  251 251 187  251 251 187
-251 251 187  251 251 187  251 251 187  251 251 187  251 251 187  251 251 187
-251 251 187  251 251 187  251 251 187  251 251 187  251 251 187  251 251 187
-251 251 187  251 251 187  251 251 187  214 212 158  197 193 154  99 98 80
-23 27 26  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
-16 20 20  16 20 20  15 19 19  15 19 19  15 18 18  14 18 18
-14 17 17  16 16 16  16 16 16  16 16 16  15 15 15  14 14 13
-14 14 13  13 13 13  13 13 13  12 12 12  12 12 12  12 12 12
-3 3 3  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  84 83 72
-110 109 94  99 98 80  72 73 67  63 64 60  99 98 80  177 172 135
-184 179 149  210 208 158  251 251 187  251 251 187  251 251 187  251 251 187
-251 251 187  251 251 187  251 251 187  251 251 187  251 251 187  251 251 187
-251 251 187  251 251 187  251 251 187  251 251 187  251 251 187  251 251 187
-251 251 187  210 208 158  184 179 149  177 172 135  110 109 94  33 37 35
-17 21 21  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
-16 20 20  16 20 20  15 19 19  15 19 19  15 19 19  14 18 18
-15 18 18  18 19 18  18 19 18  17 17 17  16 16 16  15 15 15
-14 14 13  13 13 13  13 13 13  12 12 12  12 12 12  12 12 12
-10 10 9  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  2 2 2  105 104 92
-108 107 93  99 98 80  72 73 67  63 64 60  51 52 50  87 86 72
-105 104 92  110 109 94  108 107 93  156 151 111  184 179 149  184 179 149
-197 193 154  197 193 154  197 193 154  184 179 149  184 179 149  177 172 135
-197 193 154  156 151 111  177 172 135  184 179 149  168 163 120  137 133 100
-145 141 105  110 109 94  99 98 80  47 48 46  55 57 54  15 19 19
-16 19 19  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
-17 20 20  17 21 21  16 20 20  16 19 19  15 19 19  16 19 19
-20 20 20  21 22 21  20 20 20  19 20 19  18 19 18  16 16 16
-15 15 15  14 14 13  13 13 13  13 13 13  12 12 12  12 12 12
-12 12 12  4 5 5  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  58 59 55  110 109 94
-105 104 92  90 89 73  72 73 67  55 57 54  43 45 43  39 40 39
-43 45 43  46 47 45  43 45 43  68 70 65  65 66 61  63 64 60
-108 107 93  72 73 67  105 104 92  90 89 73  72 73 67  40 43 41
-72 73 67  68 70 65  68 70 65  58 59 55  63 64 60  49 51 48
-43 45 43  33 36 34  27 30 29  20 24 24  16 20 20  15 19 19
-15 19 19  15 19 19  15 19 19  16 19 19  16 20 20  16 20 20
-17 21 21  20 24 24  20 23 22  17 21 21  17 20 20  20 20 20
-21 22 21  21 22 21  21 22 21  21 22 21  20 20 20  18 19 18
-16 16 16  15 15 15  13 13 13  13 13 13  12 12 12  12 12 12
-12 12 12  10 10 9  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  21 22 21  110 109 94  110 109 94
-105 104 92  84 83 72  68 70 65  51 52 50  41 42 42  33 37 35
-28 31 30  23 27 26  20 23 23  18 22 22  17 20 20  25 27 26
-26 28 27  27 30 29  25 27 26  20 23 23  23 27 26  30 32 31
-20 24 24  17 21 21  18 22 22  15 19 19  26 28 27  20 23 23
-14 18 18  15 19 19  15 18 18  15 19 19  15 19 19  15 19 19
-15 19 19  15 19 19  15 19 19  15 19 19  15 19 19  16 19 19
-16 20 20  22 24 23  24 26 24  22 24 23  20 23 22  22 24 23
-24 26 24  24 26 24  23 24 24  22 24 23  21 22 21  19 20 19
-17 17 17  15 15 15  14 14 13  13 13 13  12 12 12  12 12 12
-12 12 12  12 12 12  2 2 2  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  2 2 2  99 98 80  110 109 94  108 107 93
-105 104 92  84 83 72  63 64 60  49 51 48  39 40 39  32 34 33
-27 30 29  23 25 24  20 23 23  17 20 20  15 19 19  14 18 18
-14 17 17  13 17 17  13 17 17  13 17 17  13 17 17  13 17 17
-14 17 17  14 17 17  14 17 17  14 17 17  14 17 17  14 17 17
-14 18 18  14 18 18  14 18 18  14 18 18  15 18 18  15 19 19
-15 19 19  15 19 19  15 19 19  15 19 19  15 19 19  15 19 19
-15 19 19  17 21 21  27 29 28  26 28 27  25 27 26  25 27 26
-27 29 28  27 29 28  26 28 27  24 26 24  21 22 21  20 20 20
-18 19 18  16 16 16  14 14 13  13 13 13  12 12 12  12 12 12
-12 12 12  12 12 12  4 5 5  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  51 52 50  110 109 94  110 109 94  105 104 92
-90 89 73  72 73 67  55 57 54  43 45 43  35 37 36  30 32 31
-26 28 27  20 24 24  17 21 21  16 19 19  15 18 18  14 17 17
-13 16 16  13 16 16  13 16 16  13 16 16  13 16 16  13 16 16
-13 16 16  13 16 16  13 16 16  13 17 17  13 17 17  14 17 17
-14 17 17  14 17 17  14 17 17  14 18 18  14 18 18  14 18 18
-15 18 18  15 18 18  15 19 19  15 19 19  15 19 19  15 19 19
-15 19 19  15 19 19  27 29 28  32 34 33  28 31 30  27 29 28
-30 32 31  30 32 31  30 31 28  26 28 27  23 24 24  21 22 21
-19 20 19  16 16 16  14 14 13  13 13 13  12 12 12  12 12 12
-12 12 12  12 12 12  6 7 7  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  3 3 3  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  10 10 9  108 107 93  110 109 94  108 107 93  99 98 80
-84 83 72  63 64 60  49 51 48  40 43 41  33 36 34  27 30 29
-23 27 26  18 22 22  17 20 20  15 18 18  14 17 17  13 16 16
-13 16 16  13 16 16  12 15 15  12 15 15  12 15 15  12 15 15
-13 16 16  13 16 16  13 16 16  13 16 16  13 16 16  13 16 16
-13 17 17  13 17 17  14 17 17  14 17 17  14 17 17  14 18 18
-14 18 18  14 18 18  15 18 18  15 18 18  15 19 19  15 19 19
-15 19 19  15 19 19  17 21 21  33 36 34  32 34 33  31 33 31
-33 36 34  33 36 34  31 33 31  27 29 28  25 27 26  21 22 21
-19 20 19  17 17 17  15 15 15  13 13 13  12 12 12  12 12 12
-12 12 12  12 12 12  8 8 7  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  63 64 60  137 133 100  43 45 43  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  68 70 65  110 109 94  110 109 94  105 104 92  84 83 72
-68 70 65  55 57 54  43 45 43  35 37 36  30 32 31  26 28 27
-20 24 24  17 21 21  16 19 19  14 17 17  13 16 16  12 15 15
-12 15 15  12 15 15  12 15 15  12 15 15  12 15 15  12 15 15
-12 15 15  12 15 15  12 15 15  12 15 15  12 15 15  13 16 16
-13 16 16  13 16 16  13 16 16  13 17 17  13 17 17  14 17 17
-14 17 17  14 17 17  14 18 18  14 18 18  14 18 18  15 18 18
-15 19 19  15 19 19  15 19 19  20 24 24  32 34 33  35 37 36
-37 39 37  35 37 36  33 36 34  30 32 31  26 28 27  22 24 23
-20 20 20  17 17 17  15 15 15  13 13 13  12 12 12  12 12 12
-12 12 12  12 12 12  8 8 7  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-1 1 1  99 98 80  184 179 149  184 179 149  68 70 65  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-15 15 15  110 109 94  110 109 94  108 107 93  99 98 80  72 73 67
-61 63 57  49 51 48  39 40 39  33 36 34  27 30 29  23 25 24
-18 22 22  16 19 19  14 17 17  13 16 16  12 15 15  12 15 15
-11 14 14  11 14 14  11 14 14  11 14 14  11 14 14  11 14 14
-11 14 14  11 14 14  12 14 14  12 15 15  12 15 15  12 15 15
-12 15 15  13 16 16  13 16 16  13 16 16  13 16 16  13 16 16
-13 17 17  14 17 17  14 17 17  14 17 17  14 18 18  14 18 18
-14 18 18  15 18 18  15 19 19  15 19 19  30 32 31  38 39 37
-39 40 39  39 40 39  35 37 36  31 33 31  27 29 28  22 24 23
-20 20 20  17 17 17  15 15 15  13 13 13  12 12 12  12 12 12
-12 12 12  12 12 12  8 8 7  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  3 3 3
-110 109 94  197 193 154  210 208 158  184 179 149  68 70 65  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-68 70 65  110 109 94  110 109 94  105 104 92  84 83 72  65 66 61
-51 52 50  43 45 43  35 37 36  30 32 31  25 27 26  20 23 23
-17 20 20  15 18 18  13 16 16  12 15 15  12 15 15  11 14 14
-11 14 14  11 14 14  11 13 13  11 13 13  11 13 13  11 13 13
-11 14 14  11 14 14  11 14 14  11 14 14  11 14 14  11 14 14
-12 15 15  12 15 15  12 15 15  12 15 15  13 16 16  13 16 16
-13 16 16  13 16 16  13 17 17  13 17 17  14 17 17  14 17 17
-14 18 18  14 18 18  14 18 18  16 19 19  37 39 37  41 42 42
-41 42 42  41 42 42  38 39 37  32 34 33  27 29 28  23 24 24
-21 22 21  17 17 17  15 15 15  13 13 13  12 12 12  12 12 12
-12 12 12  12 12 12  8 8 7  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  11 11 11  137 133 100
-197 193 154  251 251 187  239 239 170  184 179 149  31 33 31  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  12 12 12
-110 109 94  110 109 94  105 104 92  90 89 73  72 73 67  58 59 55
-46 47 45  37 39 37  31 33 31  26 28 27  20 24 24  17 21 21
-15 18 18  13 16 16  12 15 15  12 14 14  11 13 13  11 13 13
-10 13 13  10 13 13  10 13 13  10 13 13  10 13 13  10 13 13
-10 13 13  10 13 13  11 13 13  11 13 13  11 14 14  11 14 14
-11 14 14  11 14 14  12 14 14  12 15 15  12 15 15  12 15 15
-13 16 16  13 16 16  13 16 16  13 16 16  13 17 17  13 17 17
-14 17 17  14 17 17  14 18 18  23 27 26  41 42 42  41 42 42
-43 45 43  41 42 42  39 40 39  33 36 34  27 29 28  23 24 24
-21 22 21  17 17 17  15 15 15  13 13 13  12 12 12  12 12 12
-12 12 12  12 12 12  6 7 7  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  27 29 28  168 163 120  210 208 158
-251 251 187  251 251 187  210 208 158  137 133 100  1 1 1  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  60 60 56
-110 109 94  105 104 92  105 104 92  84 83 72  65 66 61  51 52 50
-40 43 41  33 36 34  27 30 29  23 25 24  18 22 22  16 19 19
-14 17 17  12 15 15  11 14 14  11 14 14  10 13 13  10 13 13
-10 13 13  10 12 12  10 12 12  10 12 12  10 12 12  10 12 12
-10 12 12  10 12 12  10 13 13  10 13 13  10 13 13  11 13 13
-11 13 13  11 14 14  11 14 14  11 14 14  11 14 14  12 15 15
-12 15 15  12 15 15  12 15 15  13 16 16  13 16 16  13 16 16
-13 17 17  13 17 17  14 17 17  32 34 33  43 45 43  43 45 43
-43 45 43  43 45 43  39 40 39  33 36 34  27 29 28  23 24 24
-21 22 21  17 17 17  15 15 15  13 13 13  12 12 12  12 12 12
-12 12 12  12 12 12  6 7 7  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  1 1 1  68 70 65  184 179 149  210 208 158  251 251 187
-251 251 187  214 212 158  184 179 149  37 39 37  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  6 7 7  105 104 92
-105 104 92  105 104 92  99 98 80  72 73 67  58 59 55  46 47 45
-35 37 36  30 32 31  25 27 26  20 23 23  16 19 19  14 17 17
-12 15 15  12 14 14  11 13 13  10 13 13  10 12 12  10 12 12
-10 12 12  10 12 12  9 12 12  9 12 12  9 12 12  9 12 12
-10 12 12  10 12 12  10 12 12  10 12 12  10 12 12  10 13 13
-10 13 13  10 13 13  11 13 13  11 13 13  11 14 14  11 14 14
-11 14 14  12 15 15  12 15 15  12 15 15  12 15 15  13 16 16
-13 16 16  13 16 16  17 20 20  41 42 42  46 47 45  46 47 45
-46 47 45  43 45 43  40 41 39  33 36 34  27 29 28  23 24 24
-20 20 20  17 17 17  15 15 15  13 13 13  12 12 12  12 12 12
-12 12 12  12 12 12  4 5 5  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-15 15 15  110 109 94  197 193 154  214 212 158  251 251 187  251 251 187
-239 239 170  184 179 149  84 83 72  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  47 48 46  105 104 92
-105 104 92  99 98 80  84 83 72  68 70 65  51 52 50  40 43 41
-32 34 33  27 29 28  22 24 23  17 21 21  15 18 18  13 16 16
-12 15 15  11 13 13  10 13 13  10 12 12  9 12 12  9 12 12
-9 12 12  9 12 12  9 11 11  9 11 11  9 11 11  9 11 11
-9 12 12  9 12 12  9 12 12  9 12 12  10 12 12  10 12 12
-10 12 12  10 12 12  10 13 13  10 13 13  10 13 13  11 13 13
-11 14 14  11 14 14  11 14 14  12 14 14  12 15 15  12 15 15
-12 15 15  13 16 16  28 31 30  43 45 43  47 48 46  47 48 46
-47 48 46  43 45 43  40 41 39  33 36 34  27 29 28  22 24 23
-20 20 20  17 17 17  15 15 15  13 13 13  12 12 12  12 12 12
-12 12 12  12 12 12  3 4 4  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  1 1 1  60 60 56
-177 172 135  197 193 154  251 251 187  251 251 187  251 251 187  251 251 187
-184 179 149  110 109 94  3 4 4  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  1 1 1  99 98 80  105 104 92
-99 98 80  87 86 72  84 83 72  63 64 60  46 47 45  35 37 36
-30 32 31  25 27 26  18 22 22  16 19 19  14 17 17  12 15 15
-11 14 14  10 13 13  9 12 12  9 12 12  9 11 11  9 11 11
-9 11 11  9 11 11  9 11 11  9 11 11  9 11 11  9 11 11
-9 11 11  9 11 11  9 11 11  9 11 11  9 12 12  9 12 12
-9 12 12  10 12 12  10 12 12  10 12 12  10 13 13  10 13 13
-10 13 13  11 13 13  11 14 14  11 14 14  11 14 14  12 15 15
-12 15 15  14 17 17  41 42 42  47 48 46  49 51 48  51 52 50
-47 48 46  43 45 43  40 41 39  33 36 34  27 29 28  22 24 23
-19 20 19  16 16 16  14 14 13  13 13 13  12 12 12  12 12 12
-12 12 12  12 12 12  2 2 2  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  23 24 24  137 133 100  184 179 149
-210 208 158  251 251 187  251 251 187  251 251 187  251 251 187  184 179 149
-110 109 94  13 13 13  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  30 32 31  105 104 92  99 98 80
-84 83 72  84 83 72  72 73 67  55 57 54  41 42 42  32 34 33
-27 29 28  20 24 24  17 20 20  14 17 17  13 16 16  12 14 14
-10 13 13  10 12 12  9 11 11  9 11 11  9 11 11  9 11 11
-9 11 11  9 11 11  9 11 11  9 11 11  9 11 11  9 11 11
-9 11 11  9 11 11  9 11 11  9 11 11  9 11 11  9 11 11
-9 11 11  9 12 12  9 12 12  10 12 12  10 12 12  10 12 12
-10 13 13  10 13 13  10 13 13  11 13 13  11 14 14  11 14 14
-11 14 14  27 29 28  55 56 53  72 73 67  51 52 50  51 52 50
-49 51 48  43 45 43  39 40 39  32 34 33  26 28 27  21 22 21
-19 20 19  16 16 16  18 19 17  13 13 13  12 12 12  12 12 12
-12 12 12  12 12 12  1 1 1  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  8 8 7  84 83 72  184 179 149  197 193 154  251 251 187
-251 251 187  251 251 187  251 251 187  251 251 187  184 179 149  145 141 105
-19 20 19  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  14 14 13  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  72 73 67  105 104 92  84 83 72
-72 73 67  84 83 72  68 70 65  49 51 48  39 40 39  30 32 31
-25 27 26  18 22 22  15 18 18  13 16 16  12 15 15  11 13 13
-10 12 12  9 11 11  9 11 11  9 11 11  9 11 11  9 11 11
-9 11 11  9 11 11  9 11 11  9 11 11  9 11 11  9 11 11
-9 11 11  9 11 11  9 11 11  9 11 11  9 11 11  9 11 11
-9 11 11  9 11 11  9 11 11  9 12 12  9 12 12  9 12 12
-10 12 12  10 12 12  10 12 12  10 13 13  10 13 13  11 13 13
-13 16 16  41 42 42  99 98 80  158 153 112  65 66 61  51 52 50
-49 51 48  43 45 43  39 40 39  31 33 31  25 27 26  21 22 21
-21 22 21  68 70 65  55 56 53  13 13 13  12 12 12  12 12 12
-12 12 12  11 11 11  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  3 3 3
-63 64 60  158 153 112  184 179 149  210 208 158  251 251 187  251 251 187
-251 251 187  251 251 187  251 251 187  184 179 149  137 133 100  27 29 28
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-21 22 21  110 109 94  5 6 5  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  13 13 13  105 104 92  90 89 73  72 73 67
-68 70 65  84 83 72  63 64 60  46 47 45  35 37 36  27 29 28
-22 24 23  17 20 20  14 17 17  12 15 15  11 14 14  10 12 12
-10 12 12  9 11 11  9 11 11  9 11 11  9 11 11  9 11 11
-9 11 11  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  9 11 11  9 11 11  9 11 11  9 11 11  9 11 11
-9 11 11  9 11 11  9 11 11  9 11 11  9 11 11  9 11 11
-9 12 12  9 12 12  10 12 12  10 12 12  10 13 13  10 13 13
-30 32 31  47 48 46  177 172 135  210 208 158  137 133 100  55 56 53
-49 51 48  43 45 43  38 39 37  31 33 31  25 27 26  22 24 23
-110 109 94  184 179 149  63 64 60  13 13 13  12 12 12  12 12 12
-12 12 12  8 9 9  0 0 0  1 1 1  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  21 22 21  105 104 92
-184 179 149  210 208 158  251 251 187  251 251 187  251 251 187  251 251 187
-251 251 187  251 251 187  184 179 149  145 141 105  23 24 24  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-68 70 65  184 179 149  105 104 92  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  51 52 50  99 98 80  84 83 72  63 64 60
-68 70 65  72 73 67  55 57 54  41 42 42  32 34 33  25 27 26
-20 23 23  16 19 19  13 16 16  12 14 14  10 13 13  10 12 12
-9 11 11  9 11 11  9 11 11  9 11 11  9 11 11  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  9 11 11  9 11 11
-9 11 11  9 11 11  9 11 11  9 11 11  9 11 11  9 11 11
-9 11 11  9 11 11  9 12 12  9 12 12  10 12 12  17 20 20
-46 47 45  72 73 67  210 208 158  251 251 187  210 208 158  63 64 60
-49 51 48  43 45 43  37 39 37  30 32 31  24 26 24  105 104 92
-210 208 158  197 193 154  47 48 46  13 13 13  12 12 12  12 12 12
-12 12 12  6 7 7  33 36 34  48 49 45  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  8 8 7  23 24 24  55 56 53  110 109 94
-210 208 158  251 251 187  251 251 187  251 251 187  251 251 187  251 251 187
-251 251 187  184 179 149  110 109 94  20 20 20  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-110 109 94  251 251 187  210 208 158  47 48 46  0 0 0  0 0 0
-0 0 0  1 1 1  90 89 73  90 89 73  72 73 67  55 56 53
-72 73 67  68 70 65  51 52 50  37 39 37  28 31 30  23 25 24
-17 21 21  15 18 18  12 15 15  11 14 14  10 13 13  9 12 12
-9 11 11  9 11 11  9 11 11  8 10 10  8 10 10  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  9 11 11  9 11 11  9 11 11  9 11 11  9 11 11
-9 11 11  9 11 11  9 11 11  9 12 12  13 16 16  41 42 42
-49 51 48  110 109 94  251 251 187  251 251 187  251 251 187  105 104 92
-49 51 48  43 45 43  35 37 36  30 31 28  47 48 46  197 193 154
-251 251 187  197 193 154  31 33 31  12 12 12  12 12 12  12 12 12
-12 12 12  51 52 50  184 179 149  72 73 67  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  2 2 2
-11 11 11  21 22 21  30 32 31  40 41 39  60 60 56  145 141 105
-251 251 187  251 251 187  251 251 187  251 251 187  251 251 187  214 212 158
-184 179 149  110 109 94  13 13 13  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  4 5 4  61 61 53  48 49 45  3 4 3
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-156 151 111  251 251 187  251 251 187  184 179 149  11 11 11  0 0 0
-0 0 0  26 28 27  99 98 80  84 83 72  60 60 56  43 45 43
-72 73 67  65 66 61  49 51 48  35 37 36  27 29 28  20 24 24
-17 20 20  14 17 17  12 15 15  11 13 13  10 12 12  9 11 11
-9 11 11  9 11 11  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  9 11 11  9 11 11
-9 11 11  9 11 11  9 11 11  11 13 13  37 39 37  47 48 46
-51 52 50  184 179 149  251 251 187  251 251 187  251 251 187  145 141 105
-47 48 46  41 42 42  35 37 36  27 29 28  137 133 100  251 251 187
-251 251 187  197 193 154  19 20 19  12 12 12  12 12 12  12 12 12
-27 29 28  184 179 149  214 212 158  63 64 60  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  1 1 1  6 7 7  16 16 16  24 26 24
-30 32 31  38 39 37  47 48 46  55 57 54  68 70 65  110 109 94
-197 193 154  251 251 187  251 251 187  251 251 187  210 208 158  184 179 149
-105 104 92  8 8 7  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  65 66 61  184 179 149  156 151 111
-30 32 31  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-168 163 120  251 251 187  251 251 187  251 251 187  110 109 94  0 0 0
-0 0 0  60 60 56  84 83 72  68 70 65  51 52 50  38 39 37
-84 83 72  63 64 60  43 45 43  33 36 34  25 27 26  20 23 22
-15 18 18  13 16 16  12 14 14  10 13 13  9 12 12  9 11 11
-9 11 11  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-9 11 11  9 11 11  10 12 12  33 36 34  46 47 45  51 52 50
-72 73 67  210 208 158  251 251 187  251 251 187  251 251 187  177 172 135
-47 48 46  41 42 42  35 37 36  37 39 37  184 179 149  251 251 187
-251 251 187  197 193 154  13 13 13  12 12 12  12 12 12  12 12 12
-110 109 94  251 251 187  251 251 187  37 39 37  0 0 0  0 0 0
-0 0 0  21 22 20  2 2 1  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-4 5 5  12 12 12  21 22 21  25 27 26  30 32 31  38 39 37
-46 47 45  55 56 53  60 60 56  65 66 61  68 70 65  105 104 92
-110 109 94  197 193 154  210 208 158  197 193 154  184 179 149  84 83 72
-2 2 2  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  13 13 13  184 179 149  251 251 187
-197 193 154  43 44 41  0 0 0  0 0 0  0 0 0  0 0 0
-145 141 105  251 251 187  251 251 187  251 251 187  214 212 158  43 45 43
-2 2 2  84 83 72  72 73 67  58 59 55  41 42 42  38 39 37
-72 73 67  58 59 55  41 42 42  31 33 31  25 27 26  18 22 22
-14 17 17  12 15 15  12 14 14  10 12 12  9 12 12  9 11 11
-9 11 11  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  9 12 12  31 33 31  43 45 43  49 51 48  55 56 53
-110 109 94  251 251 187  251 251 187  251 251 187  251 251 187  168 163 120
-47 48 46  41 42 42  33 36 34  63 64 60  197 193 154  251 251 187
-251 251 187  184 179 149  13 13 13  12 12 12  12 12 12  16 16 16
-197 193 154  251 251 187  239 239 170  20 20 20  0 0 0  2 2 1
-108 107 93  110 109 94  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  1 1 1  4 5 5  11 11 11  18 19 18
-22 24 23  26 28 27  32 34 33  39 40 39  46 47 45  51 52 50
-55 57 54  60 60 56  63 64 60  63 64 60  63 64 60  58 59 55
-63 64 60  99 98 80  145 141 105  137 133 100  43 45 43  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  3 4 3  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  110 109 94  251 251 187
-251 251 187  184 179 149  25 27 26  0 0 0  0 0 0  0 0 0
-99 98 80  251 251 187  251 251 187  251 251 187  251 251 187  156 151 111
-25 27 26  84 83 72  65 66 61  47 48 46  32 34 33  39 40 39
-72 73 67  55 57 54  40 41 39  30 32 31  23 25 24  18 22 22
-14 17 17  12 15 15  11 13 13  10 12 12  9 11 11  9 11 11
-9 11 11  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-9 11 11  28 31 30  41 42 42  47 48 46  55 56 53  58 59 55
-137 133 100  251 251 187  251 251 187  251 251 187  210 208 158  137 133 100
-47 48 46  40 41 39  32 34 33  75 75 61  184 179 149  239 239 170
-251 251 187  177 172 135  13 13 13  12 12 12  12 12 12  43 44 41
-197 193 154  251 251 187  210 208 158  10 10 9  0 0 0  84 83 72
-251 251 187  84 83 72  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  1 1 1
-6 7 7  11 11 11  17 17 17  20 20 20  23 24 24  27 29 28
-32 34 33  38 39 37  43 45 43  47 48 46  51 52 50  55 56 53
-58 59 55  58 59 55  55 57 54  55 56 53  47 48 46  41 42 42
-35 37 36  31 33 31  47 48 46  14 14 13  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  66 65 55  99 98 80  20 20 20
-0 0 0  0 0 0  0 0 0  0 0 0  43 45 43  214 212 158
-251 251 187  251 251 187  145 141 105  3 3 3  0 0 0  0 0 0
-48 49 45  184 179 149  239 239 170  251 251 187  239 239 170  177 172 135
-84 83 72  72 73 67  55 56 53  39 40 39  26 28 27  39 40 39
-68 70 65  51 52 50  39 40 39  28 31 30  22 24 23  17 20 20
-14 17 17  12 14 14  10 13 13  9 11 11  9 11 11  9 11 11
-8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-27 29 28  40 41 39  46 47 45  51 52 50  55 57 54  63 64 60
-131 127 93  197 193 154  210 208 158  197 193 154  168 163 120  96 95 69
-47 48 46  40 41 39  32 34 33  71 71 57  145 141 105  184 179 149
-184 179 149  131 127 93  13 13 13  12 12 12  12 12 12  48 49 45
-168 163 120  184 179 149  156 151 111  6 7 7  14 14 13  177 172 135
-239 239 170  40 41 39  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  3 3 3  6 7 7  11 11 11  16 16 16
-18 19 18  21 22 21  23 24 24  27 29 28  32 34 33  37 39 37
-41 42 42  43 45 43  47 48 46  51 52 50  51 52 50  51 52 50
-51 52 50  49 51 48  46 47 45  40 41 39  32 34 33  25 27 26
-20 20 20  14 14 13  2 2 2  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  33 36 34  197 193 154  184 179 149
-41 42 42  0 0 0  0 0 0  0 0 0  3 3 3  184 179 149
-251 251 187  251 251 187  184 179 149  48 49 45  0 0 0  0 0 0
-16 17 12  121 119 87  177 172 135  194 189 146  188 184 146  145 141 105
-82 81 62  63 64 60  46 47 45  31 33 31  21 22 21  35 37 36
-68 70 65  51 52 50  37 39 37  27 30 29  22 24 23  17 20 20
-13 16 16  12 14 14  10 13 13  9 11 11  8 10 10  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  25 27 26
-38 39 37  43 45 43  51 52 50  55 56 53  60 60 56  63 64 60
-92 91 72  158 153 112  176 171 126  171 165 117  149 143 98  82 81 62
-44 46 43  38 39 37  30 32 31  71 71 57  131 127 93  160 154 106
-149 143 98  82 81 62  13 13 13  12 12 12  12 12 12  46 47 43
-121 119 87  134 131 96  96 95 69  7 7 6  38 39 37  131 127 93
-145 141 105  12 13 12  0 0 0  1 1 1  3 3 3  6 7 7
-10 10 9  12 12 12  14 14 13  16 16 16  18 19 18  21 22 21
-22 24 23  26 28 27  30 31 28  33 36 34  37 39 37  40 41 39
-41 42 42  43 45 43  46 47 45  46 47 45  46 47 45  43 45 43
-41 42 42  37 39 37  31 33 31  26 28 27  21 22 21  16 16 16
-6 7 7  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  177 172 135  251 251 187
-197 193 154  27 29 28  0 0 0  0 0 0  0 0 0  110 109 94
-239 239 170  239 239 170  184 179 149  87 86 72  2 2 1  0 0 0
-1 1 1  82 81 62  142 137 94  165 161 109  165 161 109  131 127 93
-75 75 61  55 56 53  37 39 37  25 27 26  19 20 19  32 34 33
-65 66 61  49 51 48  35 37 36  27 29 28  20 23 23  16 19 19
-13 16 16  13 13 13  10 12 12  9 11 11  8 10 10  8 10 10
-8 9 9  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  22 24 23  35 37 36
-41 42 42  47 48 46  55 56 53  58 59 55  63 64 60  65 66 61
-71 71 57  131 127 93  160 154 106  160 154 106  142 137 94  82 81 62
-46 47 43  40 41 39  33 36 34  66 65 55  125 122 87  149 143 98
-142 137 94  82 81 62  17 17 17  18 19 17  14 14 13  46 47 43
-118 116 76  125 122 87  96 95 69  16 17 12  71 71 57  103 101 77
-82 81 62  11 11 11  11 11 11  13 13 13  14 14 13  14 14 13
-15 15 15  16 16 16  17 17 17  19 20 19  21 22 21  23 24 24
-26 28 27  27 29 28  31 33 31  33 36 34  35 37 36  38 39 37
-39 40 39  39 40 39  38 39 37  37 39 37  35 37 36  31 33 31
-27 29 28  24 26 24  21 22 21  17 17 17  12 12 12  2 2 2
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  68 70 65  251 251 187
-251 251 187  156 151 111  2 2 1  0 0 0  0 0 0  43 44 41
-177 172 135  184 179 149  158 153 112  103 101 77  19 20 18  0 0 0
-0 0 0  46 47 43  131 127 93  160 154 106  160 154 106  131 127 93
-71 71 57  43 45 43  30 32 31  21 22 21  16 16 16  26 28 27
-63 64 60  47 48 46  35 37 36  26 28 27  20 23 23  16 19 19
-13 16 16  13 13 13  10 12 12  9 11 11  8 10 10  8 10 10
-7 9 9  7 9 9  8 9 9  8 10 10  8 10 10  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  8 10 10  8 10 10  20 20 20  33 36 34  40 41 39
-46 47 45  51 52 50  55 57 54  60 60 56  63 64 60  65 66 61
-66 65 55  118 116 76  151 147 98  165 161 109  151 147 98  121 119 87
-96 95 69  96 95 69  96 95 69  103 101 77  142 137 94  151 147 98
-142 137 94  103 101 77  82 81 62  82 81 62  82 81 62  96 95 69
-131 127 93  142 137 94  103 101 77  46 47 43  96 95 69  118 116 76
-71 71 57  14 14 13  14 14 13  15 15 15  15 15 15  16 16 16
-16 16 16  17 17 17  18 19 18  20 20 20  21 22 21  23 24 24
-25 27 26  27 29 28  30 31 28  30 32 31  31 33 31  31 33 31
-31 33 31  31 33 31  30 31 28  27 29 28  25 27 26  22 24 23
-20 20 20  16 16 16  13 13 13  6 7 7  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-58 59 55  68 70 65  8 8 7  0 0 0  10 10 9  210 208 158
-251 251 187  184 179 149  38 39 37  0 0 0  0 0 0  8 8 7
-103 101 77  149 143 98  149 143 98  118 116 76  40 41 39  25 27 25
-53 55 47  82 81 62  144 139 99  165 161 109  165 161 109  142 137 94
-71 71 57  35 37 36  24 26 24  18 19 18  15 15 15  22 24 23
-63 64 60  46 47 45  33 36 34  26 28 27  20 23 22  17 18 17
-12 15 15  11 13 13  10 12 12  9 11 11  8 10 10  8 10 10
-7 9 9  7 9 9  7 9 9  7 9 9  8 9 9  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  8 10 10  16 16 16  30 31 28  35 37 36  41 42 42
-47 48 46  55 56 53  58 59 55  63 64 60  65 66 61  65 66 61
-61 61 53  103 101 77  151 147 98  171 165 117  171 165 117  168 163 120
-158 153 112  158 153 112  155 149 109  151 147 98  151 147 98  160 154 106
-151 147 98  149 143 98  142 137 94  149 143 98  149 143 98  149 143 98
-155 149 109  151 147 98  131 127 93  103 101 77  125 122 87  118 116 76
-71 71 57  16 16 16  16 16 16  16 16 16  17 17 17  17 17 17
-17 17 17  17 17 17  18 19 18  19 20 19  20 20 20  21 22 21
-23 24 24  24 26 24  25 27 26  26 28 27  26 28 27  26 28 27
-25 27 26  24 26 24  22 24 23  21 22 21  19 20 19  16 16 16
-14 14 13  8 8 7  1 1 1  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-20 20 20  184 179 149  168 163 120  21 22 21  0 0 0  105 104 92
-177 172 135  145 141 105  71 71 57  0 0 0  0 0 0  0 0 0
-66 65 55  131 127 93  151 147 98  142 137 94  118 116 76  121 119 87
-145 141 105  158 153 112  176 171 126  178 174 128  176 171 126  149 145 103
-96 95 69  31 33 31  21 22 21  16 16 16  14 14 13  18 19 18
-60 60 56  46 47 45  33 36 34  25 27 26  21 22 21  15 18 18
-12 15 15  11 13 13  9 11 11  8 10 10  8 10 10  8 9 9
-7 9 9  7 9 9  7 9 9  7 9 9  7 9 9  8 9 9
-8 9 9  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  10 12 12  26 28 27  31 33 31  38 39 37  43 45 43
-51 52 50  55 56 53  60 60 56  63 64 60  65 66 61  68 70 65
-63 64 60  96 95 69  158 153 112  178 174 128  188 184 146  194 189 146
-194 189 146  188 184 146  184 181 136  176 171 126  171 165 117  173 167 111
-173 167 111  165 161 109  171 165 117  174 170 121  176 171 126  178 174 128
-178 174 128  174 170 121  160 154 106  149 143 98  149 143 98  125 122 87
-71 71 57  16 16 16  16 16 16  17 17 17  17 17 17  17 17 17
-17 17 17  17 17 17  17 17 17  18 19 18  19 20 19  20 20 20
-21 22 21  21 22 21  21 22 21  22 24 23  21 22 21  21 22 21
-21 22 21  19 20 19  18 19 18  16 16 16  14 14 13  11 11 11
-3 3 3  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  105 104 92  197 193 154  110 109 94  9 9 8  36 38 35
-121 119 87  131 127 93  96 95 69  18 19 17  30 31 28  66 65 55
-96 95 69  142 137 94  160 154 106  160 154 106  160 154 106  168 163 120
-184 181 136  194 191 148  197 193 154  197 193 154  194 189 146  168 163 120
-125 122 87  46 47 43  18 19 18  15 15 15  13 13 13  14 14 13
-55 57 54  43 45 43  32 34 33  25 27 26  18 22 22  17 17 17
-12 14 14  10 12 12  9 11 11  8 10 10  8 9 9  7 9 9
-6 8 8  7 9 9  7 9 9  7 9 9  7 9 9  7 9 9
-7 9 9  8 9 9  8 9 9  8 10 10  8 10 10  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  32 34 33  41 42 42  35 37 36  39 40 39  37 39 37
-35 37 36  55 57 54  60 60 56  63 64 60  65 66 61  65 66 61
-61 63 57  115 113 82  168 163 120  194 191 148  204 201 155  210 208 158
-210 208 158  210 208 158  197 193 154  194 189 146  186 182 128  176 171 126
-174 170 121  176 171 126  186 182 128  190 186 136  194 191 148  197 193 154
-197 193 154  188 184 146  181 176 137  174 170 121  165 161 109  142 137 94
-82 81 62  24 26 24  16 16 16  16 16 16  16 16 16  16 16 16
-17 17 17  17 17 17  17 17 17  17 17 17  18 19 18  19 20 19
-19 20 19  19 20 19  20 20 20  19 20 19  19 20 19  18 19 18
-17 17 17  15 15 15  13 13 13  12 12 12  6 7 7  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  17 18 17  137 133 100  115 113 82  53 55 47  19 20 18
-103 101 77  144 139 99  137 133 100  115 113 82  137 133 100  156 151 111
-158 153 112  164 159 111  171 165 117  174 170 121  178 174 128  194 189 146
-204 201 155  214 212 158  214 212 158  214 212 158  210 208 158  188 184 146
-158 153 112  87 86 72  17 17 17  13 13 13  13 13 13  15 15 15
-55 56 53  43 45 43  32 34 33  24 26 24  17 20 20  16 16 16
-12 14 14  10 12 12  8 10 10  8 10 10  7 9 9  6 8 8
-6 8 8  6 8 8  6 8 8  7 9 9  7 9 9  7 9 9
-7 9 9  7 9 9  7 9 9  7 9 9  8 9 9  8 10 10
-8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
-8 10 10  110 109 94  84 83 72  49 51 48  26 28 27  8 10 10
-8 9 9  51 52 50  58 59 55  63 64 60  63 64 60  63 64 60
-66 65 55  134 131 96  181 176 137  210 208 158  214 212 158  239 239 170
-239 239 170  224 223 159  210 208 158  204 201 155  194 189 146  186 182 128
-186 182 128  184 181 136  194 189 146  204 201 155  210 208 158  210 208 158
-210 208 158  210 208 158  197 193 154  190 186 136  176 171 126  155 149 109
-118 116 76  36 38 35  15 15 15  16 16 16  16 16 16  16 16 16
-16 16 16  16 16 16  16 16 16  16 16 16  16 16 16  17 17 17
-17 17 17  17 17 17  17 17 17  16 16 16  16 16 16  15 15 15
-13 13 13  12 12 12  8 8 7  2 2 2  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  53 55 47  103 101 77  96 95 69  53 55 47
-103 101 77  158 153 112  177 172 135  184 179 149  188 184 146  197 193 154
-194 189 146  190 186 136  184 181 136  184 181 136  194 189 146  210 208 158
-214 212 158  239 239 170  251 251 187  251 251 187  224 223 159  204 201 155
-177 172 135  121 119 87  30 31 28  13 13 13  12 12 12  39 40 39
-60 60 56  43 45 43  32 34 33  23 25 24  18 19 18  13 16 16
-13 13 13  9 11 11  8 10 10  8 9 9  6 8 8  6 8 8
-6 8 8  6 8 8  6 8 8  6 8 8  6 8 8  7 9 9
-7 9 9  7 9 9  7 9 9  7 9 9  7 9 9  7 9 9
-7 9 9  8 9 9  8 9 9  8 10 10  8 10 10  8 10 10
-14 17 17  197 193 154  158 153 112  55 57 54  7 9 9  7 9 9
-8 10 10  51 52 50  58 59 55  60 60 56  63 64 60  63 64 60
-71 71 57  155 149 109  194 191 148  214 212 158  251 251 187  251 251 187
-251 251 187  251 251 187  239 239 170  210 208 158  197 193 154  190 186 136
-190 186 136  194 189 146  204 201 155  210 208 158  224 223 159  239 239 170
-239 239 170  224 223 159  210 208 158  204 201 155  190 186 136  164 159 111
-125 122 87  40 41 39  15 15 15  15 15 15  15 15 15  15 15 15
-16 16 16  16 16 16  16 16 16  16 16 16  16 16 16  16 16 16
-16 16 16  16 16 16  15 15 15  14 14 13  13 13 13  12 12 12
-8 9 9  3 3 3  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  21 22 20  96 95 69  125 122 87  121 119 87
-144 139 99  177 172 135  197 193 154  210 208 158  214 212 158  214 212 158
-210 208 158  204 201 155  194 191 148  194 189 146  204 201 155  214 212 158
-239 239 170  251 251 187  251 251 187  251 251 187  251 251 187  214 212 158
-188 184 146  145 141 105  53 55 47  12 12 12  15 15 15  63 64 60
-63 64 60  41 42 42  31 33 31  23 24 24  17 18 17  12 15 15
-11 13 13  9 11 11  8 9 9  7 9 9  6 8 8  6 8 8
-6 7 7  6 7 7  6 8 8  6 8 8  6 8 8  6 8 8
-6 8 8  7 9 9  7 9 9  7 9 9  7 9 9  7 9 9
-7 9 9  7 9 9  7 9 9  7 9 9  7 9 9  8 8 7
-43 45 43  251 251 187  156 151 111  8 10 10  7 9 9  7 9 9
-21 22 21  51 52 50  55 56 53  55 57 54  58 59 55  58 59 55
-75 75 61  158 153 112  197 193 154  224 223 159  251 251 187  251 251 187
-251 251 187  251 251 187  251 251 187  214 212 158  204 201 155  194 189 146
-190 186 136  197 193 154  210 208 158  224 223 159  251 251 187  251 251 187
-251 251 187  251 251 187  239 239 170  210 208 158  197 193 154  176 171 126
-125 122 87  36 38 35  14 14 13  14 14 13  15 15 15  15 15 15
-15 15 15  15 15 15  15 15 15  15 15 15  15 15 15  15 15 15
-15 15 15  14 14 13  13 13 13  12 12 12  10 10 9  3 4 4
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  7 7 5  71 71 57  131 127 93  158 153 112
-177 172 135  197 193 154  214 212 158  239 239 170  251 251 187  251 251 187
-238 237 168  210 208 158  204 201 155  197 193 154  204 201 155  214 212 158
-251 251 187  251 251 187  251 251 187  251 251 187  251 251 187  214 212 158
-197 193 154  156 151 111  66 65 55  12 12 12  37 39 37  58 59 55
-58 59 55  41 42 42  31 33 31  22 24 23  17 17 17  12 14 14
-10 12 12  8 10 10  6 8 8  6 8 8  6 7 7  6 7 7
-6 7 7  5 7 7  6 7 7  6 7 7  6 8 8  6 8 8
-6 8 8  6 8 8  6 8 8  7 9 9  7 9 9  7 9 9
-7 9 9  6 8 8  6 8 8  6 8 8  6 8 8  6 8 8
-61 63 57  197 193 154  16 19 19  6 8 8  6 8 8  8 9 9
-41 42 42  47 48 46  51 52 50  51 52 50  55 56 53  55 56 53
-71 71 57  158 153 112  197 193 154  224 223 159  251 251 187  251 251 187
-251 251 187  251 251 187  239 239 170  214 212 158  204 201 155  194 189 146
-190 186 136  197 193 154  210 208 158  239 239 170  251 251 187  251 251 187
-251 251 187  251 251 187  251 251 187  224 223 159  204 201 155  177 172 135
-121 119 87  30 31 28  13 13 13  14 14 13  14 14 13  14 14 13
-14 14 13  14 14 13  15 15 15  15 15 15  14 14 13  13 13 13
-12 12 12  12 12 12  10 10 9  4 5 5  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  48 49 45  131 127 93  174 170 121
-194 189 146  210 208 158  239 239 170  251 251 187  251 251 187  251 251 187
-251 251 187  214 212 158  204 201 155  197 193 154  204 201 155  210 208 158
-239 239 170  251 251 187  251 251 187  251 251 187  239 239 170  214 212 158
-194 191 148  156 151 111  71 71 57  19 20 19  51 52 50  51 52 50
-51 52 50  41 42 42  30 32 31  21 22 21  17 17 17  13 13 13
-9 11 11  8 9 9  6 8 8  6 7 7  6 7 7  5 7 7
-5 6 5  5 6 5  5 7 7  5 7 7  6 7 7  6 7 7
-6 8 8  6 8 8  6 8 8  6 7 7  6 7 7  6 7 7
-6 7 7  6 8 8  6 8 8  6 8 8  6 8 8  6 8 8
-55 56 53  43 45 43  6 8 8  6 8 8  6 8 8  47 48 46
-60 60 56  47 48 46  46 47 45  47 48 46  38 39 37  10 12 12
-66 65 55  145 141 105  197 193 154  214 212 158  251 251 187  251 251 187
-251 251 187  251 251 187  224 223 159  210 208 158  194 191 148  184 181 136
-184 181 136  194 189 146  204 201 155  224 223 159  251 251 187  251 251 187
-251 251 187  251 251 187  251 251 187  239 239 170  210 208 158  181 176 137
+  P3
+  145 113
+  255
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  3 4 4  6 7 7
+ 8 10 10  8 10 10  6 8 8  6 7 7  3 4 4  2 2 2
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  4 5 5  17 18 17
+ 27 29 28  35 37 36  40 43 41  43 45 43  40 43 41  37 39 37
+ 32 34 33  27 30 29  23 25 24  17 21 21  15 18 18  12 15 15
+ 11 13 13  8 10 10  6 7 7  3 4 4  1 1 1  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  13 13 13  32 34 33  49 51 48  60 60 56  58 59 55
+ 55 57 54  55 56 53  49 51 48  43 45 43  39 40 39  33 37 35
+ 28 31 30  23 27 26  20 23 23  17 20 20  14 17 17  13 16 16
+ 11 14 14  10 13 13  10 12 12  9 11 11  8 10 10  6 7 7
+ 2 3 3  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  6 7 7  12 15 15
+ 12 15 15  8 9 9  2 3 3  0 0 0  1 1 1  25 27 26
+ 55 56 53  68 70 65  65 66 61  65 66 61  63 64 60  63 64 60
+ 58 59 55  51 52 50  47 48 46  41 42 42  35 37 36  30 32 31
+ 26 28 27  20 24 24  18 22 22  16 19 19  14 17 17  13 16 16
+ 12 15 15  11 14 14  10 13 13  10 12 12  9 11 11  8 10 10
+ 8 9 9  6 8 8  3 3 3  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  6 7 7  20 24 24  23 27 26
+ 23 27 26  18 22 22  11 13 13  23 24 24  61 63 57  72 73 67
+ 72 73 67  68 70 65  68 70 65  68 70 65  63 64 60  58 59 55
+ 55 56 53  47 48 46  41 42 42  35 37 36  30 32 31  26 28 27
+ 20 24 24  18 22 22  16 20 20  15 19 19  14 17 17  13 16 16
+ 12 15 15  12 15 15  11 14 14  10 13 13  10 12 12  9 11 11
+ 8 10 10  8 9 9  7 9 9  6 7 7  1 2 2  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  1 1 1  4 5 5  5 6 5  4 5 5
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  15 19 19  40 41 39  53 55 47
+ 33 36 34  27 30 29  51 52 50  72 73 67  72 73 67  72 73 67
+ 72 73 67  68 70 65  68 70 65  63 64 60  58 59 55  51 52 50
+ 47 48 46  40 43 41  33 37 35  30 32 31  26 28 27  20 24 24
+ 18 22 22  17 21 21  16 19 19  14 18 18  14 17 17  13 17 17
+ 13 16 16  12 15 15  12 15 15  11 14 14  10 13 13  10 12 12
+ 9 11 11  8 10 10  8 9 9  7 9 9  6 8 8  3 4 4
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 2 2 2  6 8 8  10 12 12  10 12 12  10 12 12  10 12 12
+ 6 8 8  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  20 23 23  71 71 57  131 127 93
+ 115 113 82  63 64 60  72 73 67  72 73 67  72 73 67  72 73 67
+ 68 70 65  65 66 61  61 63 57  55 57 54  49 51 48  43 45 43
+ 39 40 39  33 36 34  28 31 30  23 27 26  20 24 24  20 23 23
+ 17 21 21  16 20 20  15 19 19  15 18 18  14 18 18  14 17 17
+ 13 17 17  13 16 16  12 15 15  12 15 15  11 14 14  10 13 13
+ 10 12 12  9 11 11  8 10 10  7 9 9  7 9 9  6 8 8
+ 4 5 5  0 0 0  0 0 0  0 0 0  1 1 1  6 7 7
+ 10 12 12  10 12 12  10 12 12  10 12 12  10 12 12  10 12 12
+ 10 12 12  3 4 4  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  18 22 22  71 71 57  144 139 99
+ 84 83 72  68 70 65  72 73 67  72 73 67  68 70 65  65 66 61
+ 63 64 60  55 57 54  51 52 50  47 48 46  40 43 41  35 37 36
+ 30 32 31  27 29 28  23 27 26  20 24 24  18 22 22  17 21 21
+ 16 20 20  15 19 19  15 19 19  15 19 19  15 18 18  14 18 18
+ 14 17 17  13 17 17  13 16 16  12 15 15  12 15 15  11 14 14
+ 10 13 13  9 12 12  9 11 11  8 10 10  7 9 9  6 8 8
+ 6 8 8  3 4 4  0 0 0  2 2 2  8 10 10  10 12 12
+ 10 12 12  10 12 12  11 13 13  36 38 35  61 61 53  48 49 45
+ 10 12 12  7 9 9  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  15 19 19  61 61 53  84 83 72
+ 68 70 65  72 73 67  68 70 65  68 70 65  63 64 60  58 59 55
+ 51 52 50  47 48 46  41 42 42  37 39 37  32 35 33  28 31 30
+ 23 27 26  20 24 24  20 23 23  18 22 22  17 21 21  17 21 21
+ 17 21 21  17 21 21  17 20 20  16 20 20  16 20 20  16 19 19
+ 15 18 18  14 18 18  13 17 17  13 16 16  12 15 15  12 15 15
+ 11 14 14  10 13 13  9 12 12  9 11 11  8 10 10  7 9 9
+ 6 8 8  6 8 8  5 6 5  9 11 11  10 12 12  10 12 12
+ 19 20 18  82 81 62  149 145 103  160 154 106  142 137 94  96 95 69
+ 10 12 12  10 12 12  1 1 1  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  10 12 12  44 46 43  68 70 65
+ 72 73 67  68 70 65  68 70 65  63 64 60  55 57 54  49 51 48
+ 43 45 43  39 40 39  33 37 35  30 32 31  26 28 27  23 27 26
+ 20 24 24  18 22 22  18 22 22  18 22 22  18 22 22  20 23 23
+ 20 24 24  23 25 24  23 25 24  22 24 23  20 23 23  18 22 22
+ 17 20 20  15 19 19  15 18 18  14 17 17  13 16 16  12 15 15
+ 11 14 14  11 13 13  10 12 12  9 11 11  8 10 10  8 9 9
+ 7 9 9  7 9 9  10 12 12  10 12 12  10 12 12  71 71 57
+ 164 159 111  186 182 128  186 182 128  171 165 117  151 147 98  96 95 69
+ 10 12 12  10 12 12  3 3 3  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  8 10 10  63 64 60  68 70 65
+ 72 73 67  68 70 65  63 64 60  55 57 54  47 48 46  40 43 41
+ 33 37 35  30 32 31  27 29 28  23 27 26  20 24 24  20 23 23
+ 18 22 22  18 22 22  20 23 22  21 25 23  23 27 26  27 29 28
+ 28 31 30  31 33 31  31 33 31  31 33 31  28 31 30  26 28 27
+ 23 25 24  20 23 22  16 20 20  15 18 18  14 17 17  13 16 16
+ 12 15 15  11 14 14  10 13 13  10 12 12  9 11 11  8 10 10
+ 10 12 12  10 13 13  10 12 12  12 14 14  96 95 69  165 161 109
+ 186 182 128  192 187 134  192 187 134  176 171 126  160 154 106  103 101 77
+ 10 12 12  10 12 12  5 6 5  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  35 37 36  68 70 65  72 73 67
+ 68 70 65  65 66 61  58 59 55  49 51 48  40 43 41  33 37 35
+ 28 31 30  23 27 26  20 24 24  20 23 23  18 22 22  18 22 22
+ 18 22 22  20 23 23  23 27 26  27 30 29  32 35 33  37 39 37
+ 40 43 41  44 46 43  46 47 43  44 46 43  40 43 41  36 38 35
+ 31 33 31  27 29 28  22 24 23  17 21 21  15 18 18  14 17 17
+ 13 16 16  12 15 15  11 14 14  11 14 14  11 13 13  13 16 16
+ 13 16 16  11 14 14  10 12 12  79 78 62  142 137 94  164 159 111
+ 178 174 128  192 187 134  192 187 134  176 171 126  160 154 106  96 95 69
+ 10 12 12  10 12 12  6 7 7  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  55 57 54  68 70 65  72 73 67
+ 68 70 65  63 64 60  55 56 53  43 45 43  35 37 36  28 31 30
+ 23 27 26  20 24 24  18 22 22  17 21 21  17 21 21  17 21 21
+ 20 24 24  25 27 26  31 33 31  38 39 37  46 47 43  53 55 47
+ 61 61 53  66 65 55  66 65 55  66 65 55  61 61 53  53 55 47
+ 46 47 43  37 39 37  30 33 30  24 26 24  17 21 21  15 18 18
+ 13 17 17  12 15 15  12 15 15  13 16 16  14 18 18  14 18 18
+ 14 17 17  12 15 15  30 31 28  118 116 76  134 131 96  160 154 106
+ 174 170 121  178 174 128  178 174 128  171 165 117  151 147 98  96 95 69
+ 10 12 12  10 12 12  6 8 8  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  63 64 60  68 70 65  68 70 65
+ 65 66 61  58 59 55  49 51 48  39 40 39  30 32 31  23 27 26
+ 20 24 24  18 22 22  17 21 21  16 20 20  17 21 21  20 23 23
+ 25 27 26  32 35 33  43 44 41  53 55 47  66 65 55  75 75 61
+ 82 81 62  84 83 72  87 86 72  87 86 72  82 81 62  75 75 61
+ 66 65 55  53 55 47  40 41 39  31 33 31  23 25 24  17 20 20
+ 14 18 18  13 16 16  12 15 15  12 15 15  13 17 17  14 18 18
+ 14 18 18  13 16 16  46 47 43  96 95 69  125 122 87  142 137 94
+ 160 154 106  165 161 109  164 159 111  155 149 109  142 137 94  75 75 61
+ 10 12 12  10 12 12  6 8 8  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  60 60 56  68 70 65  68 70 65
+ 63 64 60  55 57 54  46 47 45  35 37 36  27 30 29  23 25 24
+ 18 22 22  17 21 21  16 20 20  17 21 21  18 22 22  23 27 26
+ 31 33 31  43 44 41  55 56 53  71 71 57  84 83 72  92 91 72
+ 103 101 77  92 91 72  82 81 62  82 81 62  87 86 72  92 91 72
+ 84 83 72  71 71 57  55 56 53  43 44 41  30 33 30  22 24 23
+ 16 19 19  14 17 17  12 15 15  12 15 15  13 16 16  14 18 18
+ 14 18 18  14 17 17  43 44 41  82 81 62  118 116 76  125 122 87
+ 142 137 94  144 139 99  144 139 99  134 131 96  118 116 76  53 55 47
+ 10 12 12  10 12 12  6 8 8  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  47 48 46  63 64 60  63 64 60
+ 55 57 54  49 51 48  40 43 41  32 34 33  26 28 27  20 24 24
+ 18 22 22  16 20 20  16 20 20  17 21 21  20 24 24  28 31 30
+ 40 41 39  53 55 47  75 75 61  90 89 73  87 86 72  48 49 45
+ 14 14 13  2 2 2  1 2 2  1 1 1  1 1 1  2 2 2
+ 19 20 18  43 44 41  66 65 55  53 55 47  38 39 37  26 28 27
+ 18 22 22  14 18 18  13 16 16  12 15 15  12 15 15  13 17 17
+ 14 18 18  14 18 18  30 31 28  66 65 55  96 95 69  103 101 77
+ 118 116 76  118 116 76  118 116 76  118 116 76  103 101 77  36 38 35
+ 10 12 12  10 12 12  6 7 7  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  28 31 30  55 57 54  51 52 50
+ 49 51 48  41 42 42  35 37 36  28 31 30  23 27 26  20 23 23
+ 17 21 21  16 20 20  16 20 20  18 22 22  23 27 26  33 36 34
+ 48 49 45  71 71 57  82 81 62  43 44 41  8 9 9  6 7 7
+ 6 7 7  6 7 7  6 7 7  5 6 5  4 5 5  3 4 4
+ 2 3 3  1 2 2  4 5 4  36 38 35  48 49 45  32 35 33
+ 21 25 23  16 19 19  13 17 17  12 15 15  12 15 15  13 16 16
+ 14 18 18  14 18 18  16 18 16  36 38 35  61 61 53  82 81 62
+ 96 95 69  96 95 69  96 95 69  96 95 69  79 78 62  19 20 18
+ 10 12 12  10 12 12  4 5 5  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  13 13 13  46 47 45  43 45 43
+ 40 43 41  35 37 36  30 32 31  23 27 26  20 24 24  18 22 22
+ 17 21 21  16 20 20  17 21 21  20 23 23  27 30 29  40 41 39
+ 61 61 53  53 55 47  16 17 16  9 11 11  10 12 12  10 12 12
+ 10 12 12  10 12 12  10 12 12  9 11 11  8 10 10  8 9 9
+ 6 8 8  5 6 5  4 5 5  2 3 3  19 20 18  38 39 37
+ 26 28 27  17 21 21  14 17 17  13 16 16  12 15 15  12 15 15
+ 13 17 17  14 18 18  12 15 15  13 12 7  30 31 28  46 47 43
+ 53 55 47  66 65 55  66 65 55  53 55 47  36 38 35  10 12 12
+ 10 12 12  10 12 12  2 3 3  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  1 1 1  33 37 35  35 37 36
+ 32 35 33  28 31 30  23 27 26  20 24 24  18 22 22  17 21 21
+ 16 20 20  16 20 20  17 21 21  21 25 23  31 33 31  44 46 43
+ 31 33 31  11 13 13  12 14 14  12 15 15  13 16 16  14 17 17
+ 14 17 17  14 17 17  14 17 17  13 16 16  12 15 15  12 14 14
+ 11 13 13  9 11 11  8 10 10  6 8 8  4 5 5  17 18 17
+ 30 33 30  20 23 22  15 18 18  13 16 16  12 15 15  12 14 14
+ 13 16 16  14 17 17  14 18 18  11 12 11  7 7 5  16 17 12
+ 21 22 20  30 31 28  25 27 25  21 22 20  14 14 13  10 12 12
+ 10 12 12  9 11 11  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  18 22 22  27 30 29
+ 27 29 28  40 41 39  53 55 47  53 55 47  53 55 47  46 47 43
+ 25 27 25  16 20 20  17 21 21  23 25 24  31 33 31  20 20 20
+ 12 15 15  14 17 17  15 19 19  16 20 20  17 21 21  18 22 22
+ 18 22 22  18 22 22  18 22 22  17 21 21  17 21 21  16 19 19
+ 15 18 18  13 16 16  12 15 15  10 12 12  8 10 10  6 8 8
+ 21 22 21  22 24 23  15 19 19  13 17 17  13 16 16  12 15 15
+ 12 15 15  13 17 17  14 18 18  14 18 18  13 15 14  10 9 6
+ 7 7 5  7 7 5  7 7 5  9 11 11  10 12 12  10 12 12
+ 10 12 12  6 7 7  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  16 17 12  82 81 62
+ 118 116 76  118 116 76  161 156 96  161 156 96  161 156 96  118 116 76
+ 118 116 76  96 95 69  53 55 47  22 24 23  14 17 17  13 16 16
+ 15 19 19  17 21 21  18 22 22  20 24 24  20 24 24  23 27 26
+ 23 27 26  23 27 26  23 27 26  23 27 26  23 27 26  20 24 24
+ 20 23 23  17 21 21  16 19 19  14 17 17  12 15 15  10 12 12
+ 9 11 11  20 23 22  16 19 19  14 17 17  13 16 16  12 15 15
+ 11 14 14  13 16 16  14 17 17  14 18 18  14 17 17  12 15 15
+ 10 12 12  10 12 12  10 12 12  10 12 12  10 12 12  10 12 12
+ 9 11 11  1 1 1  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  53 55 47  161 156 96
+ 161 156 96  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  161 156 96  118 116 76  96 95 69  21 22 20  16 19 19
+ 18 22 22  20 24 24  23 27 26  23 27 26  26 28 27  27 30 29
+ 27 30 29  18 22 22  12 14 14  8 10 10  9 11 11  17 21 21
+ 23 27 26  23 27 26  20 24 24  18 22 22  16 20 20  14 17 17
+ 12 14 14  14 17 17  16 20 20  14 17 17  13 17 17  13 16 16
+ 12 15 15  12 15 15  13 17 17  14 18 18  14 17 17  13 16 16
+ 11 13 13  10 12 12  10 12 12  10 12 12  10 12 12  10 12 12
+ 4 5 5  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  13 12 7  118 116 76  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  161 156 96  118 116 76  30 31 28
+ 20 24 24  23 27 26  27 30 29  28 31 30  30 32 31  23 27 26
+ 16 19 19  17 21 21  12 15 15  9 11 11  10 12 12  9 11 11
+ 20 24 24  28 31 30  26 28 27  23 27 26  20 24 24  17 21 21
+ 15 19 19  13 16 16  16 19 19  14 18 18  14 17 17  13 16 16
+ 12 15 15  11 14 14  13 16 16  14 17 17  14 18 18  14 17 17
+ 12 15 15  10 12 12  10 12 12  10 12 12  10 12 12  8 9 9
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  82 81 62  161 156 96  230 229 82
+ 230 229 82  233 233 100  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  161 156 96  118 116 76
+ 27 29 28  27 30 29  30 32 31  30 32 31  23 27 26  20 24 24
+ 26 28 27  17 21 21  6 7 7  72 73 67  145 141 105  15 15 15
+ 14 17 17  33 37 35  30 32 31  28 31 30  26 28 27  23 27 26
+ 20 23 23  16 20 20  15 19 19  14 18 18  14 17 17  13 16 16
+ 12 15 15  11 14 14  12 15 15  13 17 17  14 18 18  14 17 17
+ 13 16 16  11 13 13  10 12 12  10 12 12  9 11 11  1 1 1
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  16 17 12  161 156 96  230 229 82  230 229 82
+ 243 242 120  235 234 117  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  161 156 96
+ 82 81 62  28 31 30  28 31 30  27 30 29  28 31 30  30 32 31
+ 33 37 35  13 16 16  3 3 3  105 104 92  210 208 158  12 14 14
+ 17 21 21  33 37 35  33 37 35  32 35 33  30 32 31  27 30 29
+ 23 27 26  20 23 23  17 20 20  15 18 18  14 18 18  13 17 17
+ 13 16 16  12 15 15  11 14 14  13 16 16  14 17 17  14 18 18
+ 13 17 17  12 15 15  10 12 12  10 12 12  3 4 4  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  96 95 69  230 229 82  230 229 82  244 244 132
+ 241 241 143  243 242 120  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 161 156 96  46 47 43  32 35 33  33 37 35  33 37 35  33 37 35
+ 40 43 41  23 27 26  1 1 1  2 2 2  24 26 24  14 17 17
+ 23 27 26  33 37 35  33 37 35  33 37 35  33 37 35  30 32 31
+ 27 30 29  23 27 26  20 23 23  15 18 18  14 18 18  14 17 17
+ 13 16 16  12 15 15  11 14 14  12 15 15  13 17 17  14 17 17
+ 14 17 17  13 16 16  11 13 13  6 8 8  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  16 17 12  161 156 96  230 229 82  235 234 117  239 239 170
+ 239 239 170  236 236 101  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  118 116 76  33 37 35  33 37 35  37 39 37  37 39 37
+ 43 45 43  49 51 48  20 24 24  8 10 10  17 20 20  35 37 36
+ 33 37 35  40 43 41  37 39 37  35 37 36  33 37 35  33 37 35
+ 30 32 31  27 30 29  23 27 26  15 19 19  14 18 18  14 17 17
+ 13 17 17  13 16 16  12 15 15  11 14 14  13 16 16  14 17 17
+ 14 17 17  13 17 17  11 14 14  4 5 5  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  96 95 69  230 229 82  230 229 82  239 239 170  251 251 187
+ 241 241 143  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  161 156 96  36 38 35  33 37 35  33 37 35  33 37 35
+ 37 39 37  47 48 46  55 57 54  55 57 54  49 51 48  43 45 43
+ 43 45 43  43 45 43  40 43 41  40 43 41  37 39 37  33 37 35
+ 33 37 35  28 31 30  26 28 27  16 20 20  15 18 18  14 18 18
+ 14 17 17  13 16 16  12 15 15  11 14 14  12 15 15  13 17 17
+ 14 17 17  14 17 17  8 10 10  5 7 7  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 16 17 12  230 229 82  230 229 82  243 242 120  251 251 187  251 251 187
+ 246 246 123  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  230 229 82  66 65 55  30 32 31  32 35 33  33 37 35
+ 33 37 35  37 39 37  40 43 41  47 48 46  49 51 48  51 52 50
+ 55 57 54  55 57 54  51 52 50  47 48 46  43 45 43  39 40 39
+ 33 37 35  30 32 31  26 28 27  17 21 21  15 19 19  14 18 18
+ 14 17 17  13 16 16  12 15 15  12 14 14  11 14 14  13 16 16
+ 14 17 17  12 15 15  7 9 9  6 8 8  1 1 1  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 96 95 69  230 229 82  230 229 82  239 239 170  251 251 187  239 239 170
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  230 229 82  96 95 69  27 30 29  28 31 30  30 32 31
+ 33 37 35  40 43 41  46 47 45  55 57 54  63 64 60  72 73 67
+ 72 73 67  72 73 67  72 73 67  65 66 61  55 57 54  47 48 46
+ 39 40 39  32 35 33  27 30 29  17 21 21  15 19 19  15 18 18
+ 14 18 18  13 17 17  13 16 16  12 15 15  11 14 14  12 14 14
+ 13 16 16  9 11 11  7 9 9  9 11 11  66 65 55  115 113 82
+ 21 22 20  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  13 12 7
+ 230 229 82  230 229 82  236 236 101  251 251 187  251 251 187  246 246 123
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  230 229 82  118 116 76  23 27 26  26 28 27  32 35 33
+ 51 52 50  90 89 73  110 109 94  145 141 105  168 163 120  177 172 135
+ 177 172 135  188 184 146  188 184 146  181 176 137  194 191 148  188 184 146
+ 184 179 149  188 184 146  188 184 146  156 151 111  177 172 135  181 176 137
+ 177 172 135  168 163 120  168 163 120  158 153 112  156 151 111  158 153 112
+ 156 151 111  158 153 112  177 172 135  188 184 146  188 184 146  194 189 146
+ 36 38 35  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  82 81 62
+ 230 229 82  230 229 82  244 244 132  251 251 187  244 244 132  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  161 156 96  82 81 62
+ 96 95 69  230 229 82  181 178 103  110 109 94  156 151 111  188 184 146
+ 188 184 146  197 193 154  188 184 146  184 181 136  188 184 146  168 163 120
+ 168 163 120  178 174 128  156 151 111  158 153 112  174 170 121  156 151 111
+ 156 151 111  158 153 112  156 151 111  168 163 120  178 174 128  181 176 137
+ 176 171 126  178 174 128  184 181 136  176 171 126  178 174 128  184 181 136
+ 176 171 126  178 174 128  184 181 136  164 159 111  155 149 109  96 95 69
+ 1 1 1  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  2 2 1  161 156 96
+ 230 229 82  230 229 82  244 244 132  244 244 132  236 236 101  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  46 47 43  82 81 62
+ 158 153 112  197 193 154  194 189 146  184 181 136  188 184 146  168 163 120
+ 156 151 111  137 133 100  131 127 93  137 133 100  137 133 100  158 153 112
+ 121 119 87  137 133 100  156 151 111  145 141 105  99 98 80  84 83 72
+ 63 64 60  52 53 49  40 43 41  33 36 34  36 38 35  36 38 35
+ 38 39 37  43 44 41  43 44 41  46 47 43  48 49 45  48 49 45
+ 46 47 43  36 38 35  30 31 28  19 20 18  6 7 7  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  36 38 35  230 229 82
+ 230 229 82  230 229 82  246 246 123  236 236 101  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  53 55 47  121 119 87
+ 176 171 126  171 165 117  161 156 96  82 81 62  53 55 47  33 37 35
+ 39 40 39  63 64 60  99 98 80  121 119 87  137 133 100  177 172 135
+ 176 171 126  184 181 136  131 127 93  131 127 93  110 109 94  84 83 72
+ 51 52 50  39 40 39  27 29 28  18 22 22  16 19 19  15 19 19
+ 15 19 19  14 18 18  14 17 17  13 16 16  12 15 15  11 14 14
+ 10 13 13  9 12 12  9 11 11  8 9 9  7 9 9  1 1 1
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  118 116 76  230 229 82
+ 230 229 82  230 229 82  236 236 101  230 229 82  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  96 95 69  71 71 57
+ 36 38 35  118 116 76  118 116 76  12 15 15  15 18 18  20 24 24
+ 33 37 35  55 56 53  84 83 72  110 109 94  145 141 105  110 109 94
+ 168 163 120  121 119 87  156 151 111  131 127 93  87 86 72  61 63 57
+ 47 48 46  28 31 30  18 22 22  15 19 19  15 18 18  15 19 19
+ 15 19 19  14 18 18  14 17 17  13 17 17  13 16 16  12 15 15
+ 11 13 13  10 12 12  9 11 11  8 10 10  7 9 9  3 3 3
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  1 1 0  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  161 156 96
+ 161 156 96  230 229 82  118 116 76  11 14 14  14 17 17  18 22 22
+ 27 30 29  40 43 41  60 60 56  84 83 72  105 104 92  110 109 94
+ 110 109 94  110 109 94  99 98 80  90 89 73  68 70 65  47 48 46
+ 32 34 33  23 25 24  20 23 23  17 21 21  15 19 19  14 17 17
+ 15 19 19  15 18 18  14 18 18  13 17 17  13 16 16  12 15 15
+ 11 14 14  10 12 12  9 11 11  8 10 10  7 9 9  4 5 5
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  16 17 12  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  161 156 96  118 116 76  11 13 13  13 16 16  15 19 19
+ 20 24 24  30 32 31  40 43 41  51 52 50  63 64 60  72 73 67
+ 65 66 61  65 66 61  65 66 61  55 57 54  46 47 45  33 37 35
+ 27 29 28  20 24 24  17 21 21  16 20 20  16 20 20  15 19 19
+ 15 19 19  15 19 19  14 18 18  14 17 17  13 16 16  12 15 15
+ 11 14 14  10 13 13  9 12 12  8 10 10  7 9 9  6 7 7
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  53 55 47  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 161 156 96  118 116 76  53 55 47  10 13 13  12 15 15  14 17 17
+ 17 20 20  20 24 24  27 29 28  32 34 33  37 39 37  40 43 41
+ 43 45 43  41 42 42  35 37 36  30 32 31  28 31 30  23 27 26
+ 20 23 23  17 21 21  16 20 20  16 20 20  16 20 20  16 19 19
+ 15 19 19  15 19 19  14 18 18  14 17 17  13 16 16  12 15 15
+ 11 14 14  10 13 13  9 12 12  9 11 11  8 10 10  10 12 12
+ 1 1 1  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  82 81 62  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  161 156 96  161 156 96
+ 118 116 76  82 81 62  13 14 12  10 13 13  12 15 15  13 17 17
+ 15 19 19  16 20 20  20 23 23  20 24 24  23 27 26  26 28 27
+ 26 28 27  26 28 27  23 27 26  18 22 22  20 23 23  17 21 21
+ 17 21 21  16 20 20  16 20 20  16 20 20  16 20 20  16 19 19
+ 15 19 19  15 19 19  15 18 18  14 17 17  13 17 17  13 16 16
+ 12 15 15  12 14 14  12 14 14  12 14 14  12 14 14  23 24 24
+ 6 8 8  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  118 116 76  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  161 156 96  161 156 96  118 116 76
+ 71 71 57  13 14 12  9 12 12  10 13 13  12 15 15  13 17 17
+ 15 18 18  15 19 19  16 20 20  17 21 21  17 21 21  18 22 22
+ 18 22 22  18 22 22  17 21 21  16 19 19  15 18 18  14 18 18
+ 16 19 19  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
+ 15 19 19  15 19 19  15 18 18  14 18 18  16 20 20  23 25 24
+ 17 21 21  25 27 26  47 48 46  47 48 46  51 52 50  72 73 67
+ 33 36 34  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  118 116 76  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  230 229 82  161 156 96  118 116 76  118 116 76  46 47 43
+ 9 11 11  9 11 11  10 12 12  11 13 13  12 15 15  14 17 17
+ 15 18 18  15 19 19  16 20 20  16 20 20  16 20 20  16 20 20
+ 16 20 20  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
+ 15 19 19  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
+ 15 19 19  16 20 20  20 24 24  55 56 53  32 34 33  84 83 72
+ 90 89 73  110 109 94  110 109 94  105 104 92  110 109 94  110 109 94
+ 72 73 67  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  96 95 69  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  161 156 96  118 116 76  82 81 62  16 17 12  9 11 11
+ 9 11 11  9 12 12  10 13 13  12 14 14  13 16 16  14 18 18
+ 15 19 19  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
+ 16 20 20  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
+ 16 20 20  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
+ 16 19 19  33 36 34  99 98 80  156 151 111  145 141 105  184 179 149
+ 168 163 120  184 179 149  177 172 135  156 151 111  145 141 105  110 109 94
+ 90 89 73  2 2 2  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  71 71 57  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  230 229 82
+ 230 229 82  161 156 96  230 229 82  230 229 82  230 229 82  161 156 96
+ 118 116 76  82 81 62  30 31 28  9 11 11  9 11 11  9 11 11
+ 10 12 12  10 13 13  11 14 14  13 16 16  14 17 17  15 18 18
+ 15 19 19  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
+ 16 20 20  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
+ 16 20 20  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
+ 18 22 22  58 59 55  137 133 100  197 193 154  214 212 158  210 208 158
+ 197 193 154  184 179 149  184 179 149  137 133 100  110 109 94  99 98 80
+ 84 83 72  10 10 9  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  16 17 12  230 229 82  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  230 229 82  161 156 96
+ 161 156 96  161 156 96  161 156 96  161 156 96  118 116 76  71 71 57
+ 21 22 20  12 14 14  11 13 13  10 12 12  10 12 12  10 13 13
+ 11 13 13  12 15 15  13 16 16  14 17 17  14 18 18  15 19 19
+ 16 20 20  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
+ 16 20 20  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
+ 16 20 20  16 20 20  16 20 20  16 20 20  16 20 20  17 21 21
+ 23 27 26  84 83 72  184 179 149  251 251 187  210 208 158  184 179 149
+ 184 179 149  156 151 111  110 109 94  84 83 72  63 64 60  51 52 50
+ 18 22 22  6 8 8  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  118 116 76  230 229 82
+ 230 229 82  230 229 82  230 229 82  230 229 82  161 156 96  161 156 96
+ 161 156 96  161 156 96  118 116 76  53 55 47  20 23 22  16 19 19
+ 13 16 16  12 15 15  12 14 14  11 14 14  11 14 14  11 14 14
+ 12 15 15  13 16 16  14 17 17  15 19 19  16 20 20  17 21 21
+ 23 27 26  18 22 22  20 24 24  23 27 26  30 32 31  17 21 21
+ 16 20 20  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
+ 16 20 20  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
+ 23 27 26  33 37 35  137 133 100  156 151 111  158 153 112  105 104 92
+ 105 104 92  68 70 65  39 40 39  18 22 22  12 14 14  12 15 15
+ 9 11 11  4 5 5  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  16 17 12  230 229 82
+ 230 229 82  230 229 82  230 229 82  161 156 96  118 116 76  118 116 76
+ 118 116 76  66 65 55  43 45 43  32 34 33  25 27 26  20 23 22
+ 17 20 20  15 18 18  14 17 17  15 18 18  13 16 16  14 17 17
+ 14 18 18  16 20 20  32 34 33  55 57 54  58 59 55  72 73 67
+ 105 104 92  55 57 54  65 66 61  63 64 60  40 43 41  33 37 35
+ 41 42 42  20 24 24  16 20 20  16 20 20  16 20 20  16 20 20
+ 16 20 20  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
+ 17 21 21  26 28 27  30 32 31  35 37 36  68 70 65  39 40 39
+ 23 27 26  15 18 18  13 16 16  11 14 14  9 12 12  8 10 10
+ 7 9 9  6 7 7  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  36 38 35
+ 230 229 82  230 229 82  230 229 82  96 95 69  30 31 28  49 51 48
+ 90 89 73  68 70 65  55 57 54  47 48 46  47 48 46  43 45 43
+ 32 34 33  43 45 43  43 45 43  23 27 26  25 27 26  40 43 41
+ 40 43 41  90 89 73  110 109 94  145 141 105  156 151 111  156 151 111
+ 184 179 149  184 179 149  177 172 135  184 179 149  137 133 100  84 83 72
+ 105 104 92  63 64 60  49 51 48  47 48 46  28 31 30  18 22 22
+ 16 20 20  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
+ 16 20 20  15 19 19  15 19 19  15 19 19  18 22 22  15 19 19
+ 13 16 16  12 15 15  11 14 14  10 13 13  9 12 12  9 11 11
+ 8 10 10  6 8 8  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 30 31 28  230 229 82  71 71 57  2 2 1  0 0 0  58 59 55
+ 105 104 92  84 83 72  65 66 61  84 83 72  110 109 94  110 109 94
+ 145 141 105  105 104 92  110 109 94  110 109 94  84 83 72  110 109 94
+ 158 153 112  197 193 154  197 193 154  239 239 170  251 251 187  251 251 187
+ 251 251 187  251 251 187  251 251 187  251 251 187  210 208 158  197 193 154
+ 197 193 154  184 179 149  145 141 105  137 133 100  105 104 92  47 48 46
+ 20 23 23  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
+ 16 20 20  16 19 19  15 19 19  15 19 19  14 18 18  14 17 17
+ 13 17 17  13 16 16  12 14 14  12 14 14  13 13 13  13 13 13
+ 13 13 13  12 12 12  10 10 9  6 7 7  2 2 2  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  1 1 0  0 0 0  0 0 0  65 66 61
+ 105 104 92  84 83 72  84 83 72  110 109 94  184 179 149  210 208 158
+ 210 208 158  210 208 158  214 212 158  197 193 154  214 212 158  210 208 158
+ 251 251 187  251 251 187  251 251 187  251 251 187  251 251 187  251 251 187
+ 251 251 187  251 251 187  251 251 187  251 251 187  251 251 187  251 251 187
+ 251 251 187  251 251 187  239 239 170  251 251 187  184 179 149  84 83 72
+ 26 28 27  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
+ 16 20 20  16 20 20  15 19 19  15 19 19  15 18 18  14 18 18
+ 13 17 17  13 16 16  15 15 15  14 14 13  14 14 13  14 14 13
+ 13 13 13  13 13 13  12 12 12  12 12 12  12 12 12  3 4 4
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  72 73 67
+ 105 104 92  99 98 80  84 83 72  99 98 80  177 172 135  197 193 154
+ 251 251 187  251 251 187  251 251 187  251 251 187  251 251 187  251 251 187
+ 251 251 187  251 251 187  251 251 187  251 251 187  251 251 187  251 251 187
+ 251 251 187  251 251 187  251 251 187  251 251 187  251 251 187  251 251 187
+ 251 251 187  251 251 187  251 251 187  214 212 158  197 193 154  99 98 80
+ 23 27 26  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
+ 16 20 20  16 20 20  15 19 19  15 19 19  15 18 18  14 18 18
+ 14 17 17  16 16 16  16 16 16  16 16 16  15 15 15  14 14 13
+ 14 14 13  13 13 13  13 13 13  12 12 12  12 12 12  12 12 12
+ 3 3 3  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  84 83 72
+ 110 109 94  99 98 80  72 73 67  63 64 60  99 98 80  177 172 135
+ 184 179 149  210 208 158  251 251 187  251 251 187  251 251 187  251 251 187
+ 251 251 187  251 251 187  251 251 187  251 251 187  251 251 187  251 251 187
+ 251 251 187  251 251 187  251 251 187  251 251 187  251 251 187  251 251 187
+ 251 251 187  210 208 158  184 179 149  177 172 135  110 109 94  33 37 35
+ 17 21 21  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
+ 16 20 20  16 20 20  15 19 19  15 19 19  15 19 19  14 18 18
+ 15 18 18  18 19 18  18 19 18  17 17 17  16 16 16  15 15 15
+ 14 14 13  13 13 13  13 13 13  12 12 12  12 12 12  12 12 12
+ 10 10 9  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  2 2 2  105 104 92
+ 108 107 93  99 98 80  72 73 67  63 64 60  51 52 50  87 86 72
+ 105 104 92  110 109 94  108 107 93  156 151 111  184 179 149  184 179 149
+ 197 193 154  197 193 154  197 193 154  184 179 149  184 179 149  177 172 135
+ 197 193 154  156 151 111  177 172 135  184 179 149  168 163 120  137 133 100
+ 145 141 105  110 109 94  99 98 80  47 48 46  55 57 54  15 19 19
+ 16 19 19  16 20 20  16 20 20  16 20 20  16 20 20  16 20 20
+ 17 20 20  17 21 21  16 20 20  16 19 19  15 19 19  16 19 19
+ 20 20 20  21 22 21  20 20 20  19 20 19  18 19 18  16 16 16
+ 15 15 15  14 14 13  13 13 13  13 13 13  12 12 12  12 12 12
+ 12 12 12  4 5 5  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  58 59 55  110 109 94
+ 105 104 92  90 89 73  72 73 67  55 57 54  43 45 43  39 40 39
+ 43 45 43  46 47 45  43 45 43  68 70 65  65 66 61  63 64 60
+ 108 107 93  72 73 67  105 104 92  90 89 73  72 73 67  40 43 41
+ 72 73 67  68 70 65  68 70 65  58 59 55  63 64 60  49 51 48
+ 43 45 43  33 36 34  27 30 29  20 24 24  16 20 20  15 19 19
+ 15 19 19  15 19 19  15 19 19  16 19 19  16 20 20  16 20 20
+ 17 21 21  20 24 24  20 23 22  17 21 21  17 20 20  20 20 20
+ 21 22 21  21 22 21  21 22 21  21 22 21  20 20 20  18 19 18
+ 16 16 16  15 15 15  13 13 13  13 13 13  12 12 12  12 12 12
+ 12 12 12  10 10 9  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  21 22 21  110 109 94  110 109 94
+ 105 104 92  84 83 72  68 70 65  51 52 50  41 42 42  33 37 35
+ 28 31 30  23 27 26  20 23 23  18 22 22  17 20 20  25 27 26
+ 26 28 27  27 30 29  25 27 26  20 23 23  23 27 26  30 32 31
+ 20 24 24  17 21 21  18 22 22  15 19 19  26 28 27  20 23 23
+ 14 18 18  15 19 19  15 18 18  15 19 19  15 19 19  15 19 19
+ 15 19 19  15 19 19  15 19 19  15 19 19  15 19 19  16 19 19
+ 16 20 20  22 24 23  24 26 24  22 24 23  20 23 22  22 24 23
+ 24 26 24  24 26 24  23 24 24  22 24 23  21 22 21  19 20 19
+ 17 17 17  15 15 15  14 14 13  13 13 13  12 12 12  12 12 12
+ 12 12 12  12 12 12  2 2 2  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  2 2 2  99 98 80  110 109 94  108 107 93
+ 105 104 92  84 83 72  63 64 60  49 51 48  39 40 39  32 34 33
+ 27 30 29  23 25 24  20 23 23  17 20 20  15 19 19  14 18 18
+ 14 17 17  13 17 17  13 17 17  13 17 17  13 17 17  13 17 17
+ 14 17 17  14 17 17  14 17 17  14 17 17  14 17 17  14 17 17
+ 14 18 18  14 18 18  14 18 18  14 18 18  15 18 18  15 19 19
+ 15 19 19  15 19 19  15 19 19  15 19 19  15 19 19  15 19 19
+ 15 19 19  17 21 21  27 29 28  26 28 27  25 27 26  25 27 26
+ 27 29 28  27 29 28  26 28 27  24 26 24  21 22 21  20 20 20
+ 18 19 18  16 16 16  14 14 13  13 13 13  12 12 12  12 12 12
+ 12 12 12  12 12 12  4 5 5  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  51 52 50  110 109 94  110 109 94  105 104 92
+ 90 89 73  72 73 67  55 57 54  43 45 43  35 37 36  30 32 31
+ 26 28 27  20 24 24  17 21 21  16 19 19  15 18 18  14 17 17
+ 13 16 16  13 16 16  13 16 16  13 16 16  13 16 16  13 16 16
+ 13 16 16  13 16 16  13 16 16  13 17 17  13 17 17  14 17 17
+ 14 17 17  14 17 17  14 17 17  14 18 18  14 18 18  14 18 18
+ 15 18 18  15 18 18  15 19 19  15 19 19  15 19 19  15 19 19
+ 15 19 19  15 19 19  27 29 28  32 34 33  28 31 30  27 29 28
+ 30 32 31  30 32 31  30 31 28  26 28 27  23 24 24  21 22 21
+ 19 20 19  16 16 16  14 14 13  13 13 13  12 12 12  12 12 12
+ 12 12 12  12 12 12  6 7 7  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  3 3 3  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  10 10 9  108 107 93  110 109 94  108 107 93  99 98 80
+ 84 83 72  63 64 60  49 51 48  40 43 41  33 36 34  27 30 29
+ 23 27 26  18 22 22  17 20 20  15 18 18  14 17 17  13 16 16
+ 13 16 16  13 16 16  12 15 15  12 15 15  12 15 15  12 15 15
+ 13 16 16  13 16 16  13 16 16  13 16 16  13 16 16  13 16 16
+ 13 17 17  13 17 17  14 17 17  14 17 17  14 17 17  14 18 18
+ 14 18 18  14 18 18  15 18 18  15 18 18  15 19 19  15 19 19
+ 15 19 19  15 19 19  17 21 21  33 36 34  32 34 33  31 33 31
+ 33 36 34  33 36 34  31 33 31  27 29 28  25 27 26  21 22 21
+ 19 20 19  17 17 17  15 15 15  13 13 13  12 12 12  12 12 12
+ 12 12 12  12 12 12  8 8 7  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  63 64 60  137 133 100  43 45 43  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  68 70 65  110 109 94  110 109 94  105 104 92  84 83 72
+ 68 70 65  55 57 54  43 45 43  35 37 36  30 32 31  26 28 27
+ 20 24 24  17 21 21  16 19 19  14 17 17  13 16 16  12 15 15
+ 12 15 15  12 15 15  12 15 15  12 15 15  12 15 15  12 15 15
+ 12 15 15  12 15 15  12 15 15  12 15 15  12 15 15  13 16 16
+ 13 16 16  13 16 16  13 16 16  13 17 17  13 17 17  14 17 17
+ 14 17 17  14 17 17  14 18 18  14 18 18  14 18 18  15 18 18
+ 15 19 19  15 19 19  15 19 19  20 24 24  32 34 33  35 37 36
+ 37 39 37  35 37 36  33 36 34  30 32 31  26 28 27  22 24 23
+ 20 20 20  17 17 17  15 15 15  13 13 13  12 12 12  12 12 12
+ 12 12 12  12 12 12  8 8 7  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 1 1 1  99 98 80  184 179 149  184 179 149  68 70 65  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 15 15 15  110 109 94  110 109 94  108 107 93  99 98 80  72 73 67
+ 61 63 57  49 51 48  39 40 39  33 36 34  27 30 29  23 25 24
+ 18 22 22  16 19 19  14 17 17  13 16 16  12 15 15  12 15 15
+ 11 14 14  11 14 14  11 14 14  11 14 14  11 14 14  11 14 14
+ 11 14 14  11 14 14  12 14 14  12 15 15  12 15 15  12 15 15
+ 12 15 15  13 16 16  13 16 16  13 16 16  13 16 16  13 16 16
+ 13 17 17  14 17 17  14 17 17  14 17 17  14 18 18  14 18 18
+ 14 18 18  15 18 18  15 19 19  15 19 19  30 32 31  38 39 37
+ 39 40 39  39 40 39  35 37 36  31 33 31  27 29 28  22 24 23
+ 20 20 20  17 17 17  15 15 15  13 13 13  12 12 12  12 12 12
+ 12 12 12  12 12 12  8 8 7  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  3 3 3
+ 110 109 94  197 193 154  210 208 158  184 179 149  68 70 65  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 68 70 65  110 109 94  110 109 94  105 104 92  84 83 72  65 66 61
+ 51 52 50  43 45 43  35 37 36  30 32 31  25 27 26  20 23 23
+ 17 20 20  15 18 18  13 16 16  12 15 15  12 15 15  11 14 14
+ 11 14 14  11 14 14  11 13 13  11 13 13  11 13 13  11 13 13
+ 11 14 14  11 14 14  11 14 14  11 14 14  11 14 14  11 14 14
+ 12 15 15  12 15 15  12 15 15  12 15 15  13 16 16  13 16 16
+ 13 16 16  13 16 16  13 17 17  13 17 17  14 17 17  14 17 17
+ 14 18 18  14 18 18  14 18 18  16 19 19  37 39 37  41 42 42
+ 41 42 42  41 42 42  38 39 37  32 34 33  27 29 28  23 24 24
+ 21 22 21  17 17 17  15 15 15  13 13 13  12 12 12  12 12 12
+ 12 12 12  12 12 12  8 8 7  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  11 11 11  137 133 100
+ 197 193 154  251 251 187  239 239 170  184 179 149  31 33 31  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  12 12 12
+ 110 109 94  110 109 94  105 104 92  90 89 73  72 73 67  58 59 55
+ 46 47 45  37 39 37  31 33 31  26 28 27  20 24 24  17 21 21
+ 15 18 18  13 16 16  12 15 15  12 14 14  11 13 13  11 13 13
+ 10 13 13  10 13 13  10 13 13  10 13 13  10 13 13  10 13 13
+ 10 13 13  10 13 13  11 13 13  11 13 13  11 14 14  11 14 14
+ 11 14 14  11 14 14  12 14 14  12 15 15  12 15 15  12 15 15
+ 13 16 16  13 16 16  13 16 16  13 16 16  13 17 17  13 17 17
+ 14 17 17  14 17 17  14 18 18  23 27 26  41 42 42  41 42 42
+ 43 45 43  41 42 42  39 40 39  33 36 34  27 29 28  23 24 24
+ 21 22 21  17 17 17  15 15 15  13 13 13  12 12 12  12 12 12
+ 12 12 12  12 12 12  6 7 7  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  27 29 28  168 163 120  210 208 158
+ 251 251 187  251 251 187  210 208 158  137 133 100  1 1 1  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  60 60 56
+ 110 109 94  105 104 92  105 104 92  84 83 72  65 66 61  51 52 50
+ 40 43 41  33 36 34  27 30 29  23 25 24  18 22 22  16 19 19
+ 14 17 17  12 15 15  11 14 14  11 14 14  10 13 13  10 13 13
+ 10 13 13  10 12 12  10 12 12  10 12 12  10 12 12  10 12 12
+ 10 12 12  10 12 12  10 13 13  10 13 13  10 13 13  11 13 13
+ 11 13 13  11 14 14  11 14 14  11 14 14  11 14 14  12 15 15
+ 12 15 15  12 15 15  12 15 15  13 16 16  13 16 16  13 16 16
+ 13 17 17  13 17 17  14 17 17  32 34 33  43 45 43  43 45 43
+ 43 45 43  43 45 43  39 40 39  33 36 34  27 29 28  23 24 24
+ 21 22 21  17 17 17  15 15 15  13 13 13  12 12 12  12 12 12
+ 12 12 12  12 12 12  6 7 7  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  1 1 1  68 70 65  184 179 149  210 208 158  251 251 187
+ 251 251 187  214 212 158  184 179 149  37 39 37  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  6 7 7  105 104 92
+ 105 104 92  105 104 92  99 98 80  72 73 67  58 59 55  46 47 45
+ 35 37 36  30 32 31  25 27 26  20 23 23  16 19 19  14 17 17
+ 12 15 15  12 14 14  11 13 13  10 13 13  10 12 12  10 12 12
+ 10 12 12  10 12 12  9 12 12  9 12 12  9 12 12  9 12 12
+ 10 12 12  10 12 12  10 12 12  10 12 12  10 12 12  10 13 13
+ 10 13 13  10 13 13  11 13 13  11 13 13  11 14 14  11 14 14
+ 11 14 14  12 15 15  12 15 15  12 15 15  12 15 15  13 16 16
+ 13 16 16  13 16 16  17 20 20  41 42 42  46 47 45  46 47 45
+ 46 47 45  43 45 43  40 41 39  33 36 34  27 29 28  23 24 24
+ 20 20 20  17 17 17  15 15 15  13 13 13  12 12 12  12 12 12
+ 12 12 12  12 12 12  4 5 5  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 15 15 15  110 109 94  197 193 154  214 212 158  251 251 187  251 251 187
+ 239 239 170  184 179 149  84 83 72  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  47 48 46  105 104 92
+ 105 104 92  99 98 80  84 83 72  68 70 65  51 52 50  40 43 41
+ 32 34 33  27 29 28  22 24 23  17 21 21  15 18 18  13 16 16
+ 12 15 15  11 13 13  10 13 13  10 12 12  9 12 12  9 12 12
+ 9 12 12  9 12 12  9 11 11  9 11 11  9 11 11  9 11 11
+ 9 12 12  9 12 12  9 12 12  9 12 12  10 12 12  10 12 12
+ 10 12 12  10 12 12  10 13 13  10 13 13  10 13 13  11 13 13
+ 11 14 14  11 14 14  11 14 14  12 14 14  12 15 15  12 15 15
+ 12 15 15  13 16 16  28 31 30  43 45 43  47 48 46  47 48 46
+ 47 48 46  43 45 43  40 41 39  33 36 34  27 29 28  22 24 23
+ 20 20 20  17 17 17  15 15 15  13 13 13  12 12 12  12 12 12
+ 12 12 12  12 12 12  3 4 4  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  1 1 1  60 60 56
+ 177 172 135  197 193 154  251 251 187  251 251 187  251 251 187  251 251 187
+ 184 179 149  110 109 94  3 4 4  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  1 1 1  99 98 80  105 104 92
+ 99 98 80  87 86 72  84 83 72  63 64 60  46 47 45  35 37 36
+ 30 32 31  25 27 26  18 22 22  16 19 19  14 17 17  12 15 15
+ 11 14 14  10 13 13  9 12 12  9 12 12  9 11 11  9 11 11
+ 9 11 11  9 11 11  9 11 11  9 11 11  9 11 11  9 11 11
+ 9 11 11  9 11 11  9 11 11  9 11 11  9 12 12  9 12 12
+ 9 12 12  10 12 12  10 12 12  10 12 12  10 13 13  10 13 13
+ 10 13 13  11 13 13  11 14 14  11 14 14  11 14 14  12 15 15
+ 12 15 15  14 17 17  41 42 42  47 48 46  49 51 48  51 52 50
+ 47 48 46  43 45 43  40 41 39  33 36 34  27 29 28  22 24 23
+ 19 20 19  16 16 16  14 14 13  13 13 13  12 12 12  12 12 12
+ 12 12 12  12 12 12  2 2 2  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  23 24 24  137 133 100  184 179 149
+ 210 208 158  251 251 187  251 251 187  251 251 187  251 251 187  184 179 149
+ 110 109 94  13 13 13  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  30 32 31  105 104 92  99 98 80
+ 84 83 72  84 83 72  72 73 67  55 57 54  41 42 42  32 34 33
+ 27 29 28  20 24 24  17 20 20  14 17 17  13 16 16  12 14 14
+ 10 13 13  10 12 12  9 11 11  9 11 11  9 11 11  9 11 11
+ 9 11 11  9 11 11  9 11 11  9 11 11  9 11 11  9 11 11
+ 9 11 11  9 11 11  9 11 11  9 11 11  9 11 11  9 11 11
+ 9 11 11  9 12 12  9 12 12  10 12 12  10 12 12  10 12 12
+ 10 13 13  10 13 13  10 13 13  11 13 13  11 14 14  11 14 14
+ 11 14 14  27 29 28  55 56 53  72 73 67  51 52 50  51 52 50
+ 49 51 48  43 45 43  39 40 39  32 34 33  26 28 27  21 22 21
+ 19 20 19  16 16 16  18 19 17  13 13 13  12 12 12  12 12 12
+ 12 12 12  12 12 12  1 1 1  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  8 8 7  84 83 72  184 179 149  197 193 154  251 251 187
+ 251 251 187  251 251 187  251 251 187  251 251 187  184 179 149  145 141 105
+ 19 20 19  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  14 14 13  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  72 73 67  105 104 92  84 83 72
+ 72 73 67  84 83 72  68 70 65  49 51 48  39 40 39  30 32 31
+ 25 27 26  18 22 22  15 18 18  13 16 16  12 15 15  11 13 13
+ 10 12 12  9 11 11  9 11 11  9 11 11  9 11 11  9 11 11
+ 9 11 11  9 11 11  9 11 11  9 11 11  9 11 11  9 11 11
+ 9 11 11  9 11 11  9 11 11  9 11 11  9 11 11  9 11 11
+ 9 11 11  9 11 11  9 11 11  9 12 12  9 12 12  9 12 12
+ 10 12 12  10 12 12  10 12 12  10 13 13  10 13 13  11 13 13
+ 13 16 16  41 42 42  99 98 80  158 153 112  65 66 61  51 52 50
+ 49 51 48  43 45 43  39 40 39  31 33 31  25 27 26  21 22 21
+ 21 22 21  68 70 65  55 56 53  13 13 13  12 12 12  12 12 12
+ 12 12 12  11 11 11  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  3 3 3
+ 63 64 60  158 153 112  184 179 149  210 208 158  251 251 187  251 251 187
+ 251 251 187  251 251 187  251 251 187  184 179 149  137 133 100  27 29 28
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 21 22 21  110 109 94  5 6 5  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  13 13 13  105 104 92  90 89 73  72 73 67
+ 68 70 65  84 83 72  63 64 60  46 47 45  35 37 36  27 29 28
+ 22 24 23  17 20 20  14 17 17  12 15 15  11 14 14  10 12 12
+ 10 12 12  9 11 11  9 11 11  9 11 11  9 11 11  9 11 11
+ 9 11 11  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  9 11 11  9 11 11  9 11 11  9 11 11  9 11 11
+ 9 11 11  9 11 11  9 11 11  9 11 11  9 11 11  9 11 11
+ 9 12 12  9 12 12  10 12 12  10 12 12  10 13 13  10 13 13
+ 30 32 31  47 48 46  177 172 135  210 208 158  137 133 100  55 56 53
+ 49 51 48  43 45 43  38 39 37  31 33 31  25 27 26  22 24 23
+ 110 109 94  184 179 149  63 64 60  13 13 13  12 12 12  12 12 12
+ 12 12 12  8 9 9  0 0 0  1 1 1  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  21 22 21  105 104 92
+ 184 179 149  210 208 158  251 251 187  251 251 187  251 251 187  251 251 187
+ 251 251 187  251 251 187  184 179 149  145 141 105  23 24 24  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 68 70 65  184 179 149  105 104 92  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  51 52 50  99 98 80  84 83 72  63 64 60
+ 68 70 65  72 73 67  55 57 54  41 42 42  32 34 33  25 27 26
+ 20 23 23  16 19 19  13 16 16  12 14 14  10 13 13  10 12 12
+ 9 11 11  9 11 11  9 11 11  9 11 11  9 11 11  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  9 11 11  9 11 11
+ 9 11 11  9 11 11  9 11 11  9 11 11  9 11 11  9 11 11
+ 9 11 11  9 11 11  9 12 12  9 12 12  10 12 12  17 20 20
+ 46 47 45  72 73 67  210 208 158  251 251 187  210 208 158  63 64 60
+ 49 51 48  43 45 43  37 39 37  30 32 31  24 26 24  105 104 92
+ 210 208 158  197 193 154  47 48 46  13 13 13  12 12 12  12 12 12
+ 12 12 12  6 7 7  33 36 34  48 49 45  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  8 8 7  23 24 24  55 56 53  110 109 94
+ 210 208 158  251 251 187  251 251 187  251 251 187  251 251 187  251 251 187
+ 251 251 187  184 179 149  110 109 94  20 20 20  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 110 109 94  251 251 187  210 208 158  47 48 46  0 0 0  0 0 0
+ 0 0 0  1 1 1  90 89 73  90 89 73  72 73 67  55 56 53
+ 72 73 67  68 70 65  51 52 50  37 39 37  28 31 30  23 25 24
+ 17 21 21  15 18 18  12 15 15  11 14 14  10 13 13  9 12 12
+ 9 11 11  9 11 11  9 11 11  8 10 10  8 10 10  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  9 11 11  9 11 11  9 11 11  9 11 11  9 11 11
+ 9 11 11  9 11 11  9 11 11  9 12 12  13 16 16  41 42 42
+ 49 51 48  110 109 94  251 251 187  251 251 187  251 251 187  105 104 92
+ 49 51 48  43 45 43  35 37 36  30 31 28  47 48 46  197 193 154
+ 251 251 187  197 193 154  31 33 31  12 12 12  12 12 12  12 12 12
+ 12 12 12  51 52 50  184 179 149  72 73 67  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  2 2 2
+ 11 11 11  21 22 21  30 32 31  40 41 39  60 60 56  145 141 105
+ 251 251 187  251 251 187  251 251 187  251 251 187  251 251 187  214 212 158
+ 184 179 149  110 109 94  13 13 13  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  4 5 4  61 61 53  48 49 45  3 4 3
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 156 151 111  251 251 187  251 251 187  184 179 149  11 11 11  0 0 0
+ 0 0 0  26 28 27  99 98 80  84 83 72  60 60 56  43 45 43
+ 72 73 67  65 66 61  49 51 48  35 37 36  27 29 28  20 24 24
+ 17 20 20  14 17 17  12 15 15  11 13 13  10 12 12  9 11 11
+ 9 11 11  9 11 11  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  9 11 11  9 11 11
+ 9 11 11  9 11 11  9 11 11  11 13 13  37 39 37  47 48 46
+ 51 52 50  184 179 149  251 251 187  251 251 187  251 251 187  145 141 105
+ 47 48 46  41 42 42  35 37 36  27 29 28  137 133 100  251 251 187
+ 251 251 187  197 193 154  19 20 19  12 12 12  12 12 12  12 12 12
+ 27 29 28  184 179 149  214 212 158  63 64 60  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  1 1 1  6 7 7  16 16 16  24 26 24
+ 30 32 31  38 39 37  47 48 46  55 57 54  68 70 65  110 109 94
+ 197 193 154  251 251 187  251 251 187  251 251 187  210 208 158  184 179 149
+ 105 104 92  8 8 7  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  65 66 61  184 179 149  156 151 111
+ 30 32 31  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 168 163 120  251 251 187  251 251 187  251 251 187  110 109 94  0 0 0
+ 0 0 0  60 60 56  84 83 72  68 70 65  51 52 50  38 39 37
+ 84 83 72  63 64 60  43 45 43  33 36 34  25 27 26  20 23 22
+ 15 18 18  13 16 16  12 14 14  10 13 13  9 12 12  9 11 11
+ 9 11 11  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 9 11 11  9 11 11  10 12 12  33 36 34  46 47 45  51 52 50
+ 72 73 67  210 208 158  251 251 187  251 251 187  251 251 187  177 172 135
+ 47 48 46  41 42 42  35 37 36  37 39 37  184 179 149  251 251 187
+ 251 251 187  197 193 154  13 13 13  12 12 12  12 12 12  12 12 12
+ 110 109 94  251 251 187  251 251 187  37 39 37  0 0 0  0 0 0
+ 0 0 0  21 22 20  2 2 1  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 4 5 5  12 12 12  21 22 21  25 27 26  30 32 31  38 39 37
+ 46 47 45  55 56 53  60 60 56  65 66 61  68 70 65  105 104 92
+ 110 109 94  197 193 154  210 208 158  197 193 154  184 179 149  84 83 72
+ 2 2 2  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  13 13 13  184 179 149  251 251 187
+ 197 193 154  43 44 41  0 0 0  0 0 0  0 0 0  0 0 0
+ 145 141 105  251 251 187  251 251 187  251 251 187  214 212 158  43 45 43
+ 2 2 2  84 83 72  72 73 67  58 59 55  41 42 42  38 39 37
+ 72 73 67  58 59 55  41 42 42  31 33 31  25 27 26  18 22 22
+ 14 17 17  12 15 15  12 14 14  10 12 12  9 12 12  9 11 11
+ 9 11 11  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  9 12 12  31 33 31  43 45 43  49 51 48  55 56 53
+ 110 109 94  251 251 187  251 251 187  251 251 187  251 251 187  168 163 120
+ 47 48 46  41 42 42  33 36 34  63 64 60  197 193 154  251 251 187
+ 251 251 187  184 179 149  13 13 13  12 12 12  12 12 12  16 16 16
+ 197 193 154  251 251 187  239 239 170  20 20 20  0 0 0  2 2 1
+ 108 107 93  110 109 94  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  1 1 1  4 5 5  11 11 11  18 19 18
+ 22 24 23  26 28 27  32 34 33  39 40 39  46 47 45  51 52 50
+ 55 57 54  60 60 56  63 64 60  63 64 60  63 64 60  58 59 55
+ 63 64 60  99 98 80  145 141 105  137 133 100  43 45 43  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  3 4 3  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  110 109 94  251 251 187
+ 251 251 187  184 179 149  25 27 26  0 0 0  0 0 0  0 0 0
+ 99 98 80  251 251 187  251 251 187  251 251 187  251 251 187  156 151 111
+ 25 27 26  84 83 72  65 66 61  47 48 46  32 34 33  39 40 39
+ 72 73 67  55 57 54  40 41 39  30 32 31  23 25 24  18 22 22
+ 14 17 17  12 15 15  11 13 13  10 12 12  9 11 11  9 11 11
+ 9 11 11  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 9 11 11  28 31 30  41 42 42  47 48 46  55 56 53  58 59 55
+ 137 133 100  251 251 187  251 251 187  251 251 187  210 208 158  137 133 100
+ 47 48 46  40 41 39  32 34 33  75 75 61  184 179 149  239 239 170
+ 251 251 187  177 172 135  13 13 13  12 12 12  12 12 12  43 44 41
+ 197 193 154  251 251 187  210 208 158  10 10 9  0 0 0  84 83 72
+ 251 251 187  84 83 72  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  1 1 1
+ 6 7 7  11 11 11  17 17 17  20 20 20  23 24 24  27 29 28
+ 32 34 33  38 39 37  43 45 43  47 48 46  51 52 50  55 56 53
+ 58 59 55  58 59 55  55 57 54  55 56 53  47 48 46  41 42 42
+ 35 37 36  31 33 31  47 48 46  14 14 13  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  66 65 55  99 98 80  20 20 20
+ 0 0 0  0 0 0  0 0 0  0 0 0  43 45 43  214 212 158
+ 251 251 187  251 251 187  145 141 105  3 3 3  0 0 0  0 0 0
+ 48 49 45  184 179 149  239 239 170  251 251 187  239 239 170  177 172 135
+ 84 83 72  72 73 67  55 56 53  39 40 39  26 28 27  39 40 39
+ 68 70 65  51 52 50  39 40 39  28 31 30  22 24 23  17 20 20
+ 14 17 17  12 14 14  10 13 13  9 11 11  9 11 11  9 11 11
+ 8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 27 29 28  40 41 39  46 47 45  51 52 50  55 57 54  63 64 60
+ 131 127 93  197 193 154  210 208 158  197 193 154  168 163 120  96 95 69
+ 47 48 46  40 41 39  32 34 33  71 71 57  145 141 105  184 179 149
+ 184 179 149  131 127 93  13 13 13  12 12 12  12 12 12  48 49 45
+ 168 163 120  184 179 149  156 151 111  6 7 7  14 14 13  177 172 135
+ 239 239 170  40 41 39  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  3 3 3  6 7 7  11 11 11  16 16 16
+ 18 19 18  21 22 21  23 24 24  27 29 28  32 34 33  37 39 37
+ 41 42 42  43 45 43  47 48 46  51 52 50  51 52 50  51 52 50
+ 51 52 50  49 51 48  46 47 45  40 41 39  32 34 33  25 27 26
+ 20 20 20  14 14 13  2 2 2  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  33 36 34  197 193 154  184 179 149
+ 41 42 42  0 0 0  0 0 0  0 0 0  3 3 3  184 179 149
+ 251 251 187  251 251 187  184 179 149  48 49 45  0 0 0  0 0 0
+ 16 17 12  121 119 87  177 172 135  194 189 146  188 184 146  145 141 105
+ 82 81 62  63 64 60  46 47 45  31 33 31  21 22 21  35 37 36
+ 68 70 65  51 52 50  37 39 37  27 30 29  22 24 23  17 20 20
+ 13 16 16  12 14 14  10 13 13  9 11 11  8 10 10  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  25 27 26
+ 38 39 37  43 45 43  51 52 50  55 56 53  60 60 56  63 64 60
+ 92 91 72  158 153 112  176 171 126  171 165 117  149 143 98  82 81 62
+ 44 46 43  38 39 37  30 32 31  71 71 57  131 127 93  160 154 106
+ 149 143 98  82 81 62  13 13 13  12 12 12  12 12 12  46 47 43
+ 121 119 87  134 131 96  96 95 69  7 7 6  38 39 37  131 127 93
+ 145 141 105  12 13 12  0 0 0  1 1 1  3 3 3  6 7 7
+ 10 10 9  12 12 12  14 14 13  16 16 16  18 19 18  21 22 21
+ 22 24 23  26 28 27  30 31 28  33 36 34  37 39 37  40 41 39
+ 41 42 42  43 45 43  46 47 45  46 47 45  46 47 45  43 45 43
+ 41 42 42  37 39 37  31 33 31  26 28 27  21 22 21  16 16 16
+ 6 7 7  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  177 172 135  251 251 187
+ 197 193 154  27 29 28  0 0 0  0 0 0  0 0 0  110 109 94
+ 239 239 170  239 239 170  184 179 149  87 86 72  2 2 1  0 0 0
+ 1 1 1  82 81 62  142 137 94  165 161 109  165 161 109  131 127 93
+ 75 75 61  55 56 53  37 39 37  25 27 26  19 20 19  32 34 33
+ 65 66 61  49 51 48  35 37 36  27 29 28  20 23 23  16 19 19
+ 13 16 16  13 13 13  10 12 12  9 11 11  8 10 10  8 10 10
+ 8 9 9  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  22 24 23  35 37 36
+ 41 42 42  47 48 46  55 56 53  58 59 55  63 64 60  65 66 61
+ 71 71 57  131 127 93  160 154 106  160 154 106  142 137 94  82 81 62
+ 46 47 43  40 41 39  33 36 34  66 65 55  125 122 87  149 143 98
+ 142 137 94  82 81 62  17 17 17  18 19 17  14 14 13  46 47 43
+ 118 116 76  125 122 87  96 95 69  16 17 12  71 71 57  103 101 77
+ 82 81 62  11 11 11  11 11 11  13 13 13  14 14 13  14 14 13
+ 15 15 15  16 16 16  17 17 17  19 20 19  21 22 21  23 24 24
+ 26 28 27  27 29 28  31 33 31  33 36 34  35 37 36  38 39 37
+ 39 40 39  39 40 39  38 39 37  37 39 37  35 37 36  31 33 31
+ 27 29 28  24 26 24  21 22 21  17 17 17  12 12 12  2 2 2
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  68 70 65  251 251 187
+ 251 251 187  156 151 111  2 2 1  0 0 0  0 0 0  43 44 41
+ 177 172 135  184 179 149  158 153 112  103 101 77  19 20 18  0 0 0
+ 0 0 0  46 47 43  131 127 93  160 154 106  160 154 106  131 127 93
+ 71 71 57  43 45 43  30 32 31  21 22 21  16 16 16  26 28 27
+ 63 64 60  47 48 46  35 37 36  26 28 27  20 23 23  16 19 19
+ 13 16 16  13 13 13  10 12 12  9 11 11  8 10 10  8 10 10
+ 7 9 9  7 9 9  8 9 9  8 10 10  8 10 10  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  8 10 10  8 10 10  20 20 20  33 36 34  40 41 39
+ 46 47 45  51 52 50  55 57 54  60 60 56  63 64 60  65 66 61
+ 66 65 55  118 116 76  151 147 98  165 161 109  151 147 98  121 119 87
+ 96 95 69  96 95 69  96 95 69  103 101 77  142 137 94  151 147 98
+ 142 137 94  103 101 77  82 81 62  82 81 62  82 81 62  96 95 69
+ 131 127 93  142 137 94  103 101 77  46 47 43  96 95 69  118 116 76
+ 71 71 57  14 14 13  14 14 13  15 15 15  15 15 15  16 16 16
+ 16 16 16  17 17 17  18 19 18  20 20 20  21 22 21  23 24 24
+ 25 27 26  27 29 28  30 31 28  30 32 31  31 33 31  31 33 31
+ 31 33 31  31 33 31  30 31 28  27 29 28  25 27 26  22 24 23
+ 20 20 20  16 16 16  13 13 13  6 7 7  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 58 59 55  68 70 65  8 8 7  0 0 0  10 10 9  210 208 158
+ 251 251 187  184 179 149  38 39 37  0 0 0  0 0 0  8 8 7
+ 103 101 77  149 143 98  149 143 98  118 116 76  40 41 39  25 27 25
+ 53 55 47  82 81 62  144 139 99  165 161 109  165 161 109  142 137 94
+ 71 71 57  35 37 36  24 26 24  18 19 18  15 15 15  22 24 23
+ 63 64 60  46 47 45  33 36 34  26 28 27  20 23 22  17 18 17
+ 12 15 15  11 13 13  10 12 12  9 11 11  8 10 10  8 10 10
+ 7 9 9  7 9 9  7 9 9  7 9 9  8 9 9  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  8 10 10  16 16 16  30 31 28  35 37 36  41 42 42
+ 47 48 46  55 56 53  58 59 55  63 64 60  65 66 61  65 66 61
+ 61 61 53  103 101 77  151 147 98  171 165 117  171 165 117  168 163 120
+ 158 153 112  158 153 112  155 149 109  151 147 98  151 147 98  160 154 106
+ 151 147 98  149 143 98  142 137 94  149 143 98  149 143 98  149 143 98
+ 155 149 109  151 147 98  131 127 93  103 101 77  125 122 87  118 116 76
+ 71 71 57  16 16 16  16 16 16  16 16 16  17 17 17  17 17 17
+ 17 17 17  17 17 17  18 19 18  19 20 19  20 20 20  21 22 21
+ 23 24 24  24 26 24  25 27 26  26 28 27  26 28 27  26 28 27
+ 25 27 26  24 26 24  22 24 23  21 22 21  19 20 19  16 16 16
+ 14 14 13  8 8 7  1 1 1  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 20 20 20  184 179 149  168 163 120  21 22 21  0 0 0  105 104 92
+ 177 172 135  145 141 105  71 71 57  0 0 0  0 0 0  0 0 0
+ 66 65 55  131 127 93  151 147 98  142 137 94  118 116 76  121 119 87
+ 145 141 105  158 153 112  176 171 126  178 174 128  176 171 126  149 145 103
+ 96 95 69  31 33 31  21 22 21  16 16 16  14 14 13  18 19 18
+ 60 60 56  46 47 45  33 36 34  25 27 26  21 22 21  15 18 18
+ 12 15 15  11 13 13  9 11 11  8 10 10  8 10 10  8 9 9
+ 7 9 9  7 9 9  7 9 9  7 9 9  7 9 9  8 9 9
+ 8 9 9  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  10 12 12  26 28 27  31 33 31  38 39 37  43 45 43
+ 51 52 50  55 56 53  60 60 56  63 64 60  65 66 61  68 70 65
+ 63 64 60  96 95 69  158 153 112  178 174 128  188 184 146  194 189 146
+ 194 189 146  188 184 146  184 181 136  176 171 126  171 165 117  173 167 111
+ 173 167 111  165 161 109  171 165 117  174 170 121  176 171 126  178 174 128
+ 178 174 128  174 170 121  160 154 106  149 143 98  149 143 98  125 122 87
+ 71 71 57  16 16 16  16 16 16  17 17 17  17 17 17  17 17 17
+ 17 17 17  17 17 17  17 17 17  18 19 18  19 20 19  20 20 20
+ 21 22 21  21 22 21  21 22 21  22 24 23  21 22 21  21 22 21
+ 21 22 21  19 20 19  18 19 18  16 16 16  14 14 13  11 11 11
+ 3 3 3  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  105 104 92  197 193 154  110 109 94  9 9 8  36 38 35
+ 121 119 87  131 127 93  96 95 69  18 19 17  30 31 28  66 65 55
+ 96 95 69  142 137 94  160 154 106  160 154 106  160 154 106  168 163 120
+ 184 181 136  194 191 148  197 193 154  197 193 154  194 189 146  168 163 120
+ 125 122 87  46 47 43  18 19 18  15 15 15  13 13 13  14 14 13
+ 55 57 54  43 45 43  32 34 33  25 27 26  18 22 22  17 17 17
+ 12 14 14  10 12 12  9 11 11  8 10 10  8 9 9  7 9 9
+ 6 8 8  7 9 9  7 9 9  7 9 9  7 9 9  7 9 9
+ 7 9 9  8 9 9  8 9 9  8 10 10  8 10 10  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  32 34 33  41 42 42  35 37 36  39 40 39  37 39 37
+ 35 37 36  55 57 54  60 60 56  63 64 60  65 66 61  65 66 61
+ 61 63 57  115 113 82  168 163 120  194 191 148  204 201 155  210 208 158
+ 210 208 158  210 208 158  197 193 154  194 189 146  186 182 128  176 171 126
+ 174 170 121  176 171 126  186 182 128  190 186 136  194 191 148  197 193 154
+ 197 193 154  188 184 146  181 176 137  174 170 121  165 161 109  142 137 94
+ 82 81 62  24 26 24  16 16 16  16 16 16  16 16 16  16 16 16
+ 17 17 17  17 17 17  17 17 17  17 17 17  18 19 18  19 20 19
+ 19 20 19  19 20 19  20 20 20  19 20 19  19 20 19  18 19 18
+ 17 17 17  15 15 15  13 13 13  12 12 12  6 7 7  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  17 18 17  137 133 100  115 113 82  53 55 47  19 20 18
+ 103 101 77  144 139 99  137 133 100  115 113 82  137 133 100  156 151 111
+ 158 153 112  164 159 111  171 165 117  174 170 121  178 174 128  194 189 146
+ 204 201 155  214 212 158  214 212 158  214 212 158  210 208 158  188 184 146
+ 158 153 112  87 86 72  17 17 17  13 13 13  13 13 13  15 15 15
+ 55 56 53  43 45 43  32 34 33  24 26 24  17 20 20  16 16 16
+ 12 14 14  10 12 12  8 10 10  8 10 10  7 9 9  6 8 8
+ 6 8 8  6 8 8  6 8 8  7 9 9  7 9 9  7 9 9
+ 7 9 9  7 9 9  7 9 9  7 9 9  8 9 9  8 10 10
+ 8 10 10  8 10 10  8 10 10  8 10 10  8 10 10  8 10 10
+ 8 10 10  110 109 94  84 83 72  49 51 48  26 28 27  8 10 10
+ 8 9 9  51 52 50  58 59 55  63 64 60  63 64 60  63 64 60
+ 66 65 55  134 131 96  181 176 137  210 208 158  214 212 158  239 239 170
+ 239 239 170  224 223 159  210 208 158  204 201 155  194 189 146  186 182 128
+ 186 182 128  184 181 136  194 189 146  204 201 155  210 208 158  210 208 158
+ 210 208 158  210 208 158  197 193 154  190 186 136  176 171 126  155 149 109
+ 118 116 76  36 38 35  15 15 15  16 16 16  16 16 16  16 16 16
+ 16 16 16  16 16 16  16 16 16  16 16 16  16 16 16  17 17 17
+ 17 17 17  17 17 17  17 17 17  16 16 16  16 16 16  15 15 15
+ 13 13 13  12 12 12  8 8 7  2 2 2  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  53 55 47  103 101 77  96 95 69  53 55 47
+ 103 101 77  158 153 112  177 172 135  184 179 149  188 184 146  197 193 154
+ 194 189 146  190 186 136  184 181 136  184 181 136  194 189 146  210 208 158
+ 214 212 158  239 239 170  251 251 187  251 251 187  224 223 159  204 201 155
+ 177 172 135  121 119 87  30 31 28  13 13 13  12 12 12  39 40 39
+ 60 60 56  43 45 43  32 34 33  23 25 24  18 19 18  13 16 16
+ 13 13 13  9 11 11  8 10 10  8 9 9  6 8 8  6 8 8
+ 6 8 8  6 8 8  6 8 8  6 8 8  6 8 8  7 9 9
+ 7 9 9  7 9 9  7 9 9  7 9 9  7 9 9  7 9 9
+ 7 9 9  8 9 9  8 9 9  8 10 10  8 10 10  8 10 10
+ 14 17 17  197 193 154  158 153 112  55 57 54  7 9 9  7 9 9
+ 8 10 10  51 52 50  58 59 55  60 60 56  63 64 60  63 64 60
+ 71 71 57  155 149 109  194 191 148  214 212 158  251 251 187  251 251 187
+ 251 251 187  251 251 187  239 239 170  210 208 158  197 193 154  190 186 136
+ 190 186 136  194 189 146  204 201 155  210 208 158  224 223 159  239 239 170
+ 239 239 170  224 223 159  210 208 158  204 201 155  190 186 136  164 159 111
+ 125 122 87  40 41 39  15 15 15  15 15 15  15 15 15  15 15 15
+ 16 16 16  16 16 16  16 16 16  16 16 16  16 16 16  16 16 16
+ 16 16 16  16 16 16  15 15 15  14 14 13  13 13 13  12 12 12
+ 8 9 9  3 3 3  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  21 22 20  96 95 69  125 122 87  121 119 87
+ 144 139 99  177 172 135  197 193 154  210 208 158  214 212 158  214 212 158
+ 210 208 158  204 201 155  194 191 148  194 189 146  204 201 155  214 212 158
+ 239 239 170  251 251 187  251 251 187  251 251 187  251 251 187  214 212 158
+ 188 184 146  145 141 105  53 55 47  12 12 12  15 15 15  63 64 60
+ 63 64 60  41 42 42  31 33 31  23 24 24  17 18 17  12 15 15
+ 11 13 13  9 11 11  8 9 9  7 9 9  6 8 8  6 8 8
+ 6 7 7  6 7 7  6 8 8  6 8 8  6 8 8  6 8 8
+ 6 8 8  7 9 9  7 9 9  7 9 9  7 9 9  7 9 9
+ 7 9 9  7 9 9  7 9 9  7 9 9  7 9 9  8 8 7
+ 43 45 43  251 251 187  156 151 111  8 10 10  7 9 9  7 9 9
+ 21 22 21  51 52 50  55 56 53  55 57 54  58 59 55  58 59 55
+ 75 75 61  158 153 112  197 193 154  224 223 159  251 251 187  251 251 187
+ 251 251 187  251 251 187  251 251 187  214 212 158  204 201 155  194 189 146
+ 190 186 136  197 193 154  210 208 158  224 223 159  251 251 187  251 251 187
+ 251 251 187  251 251 187  239 239 170  210 208 158  197 193 154  176 171 126
+ 125 122 87  36 38 35  14 14 13  14 14 13  15 15 15  15 15 15
+ 15 15 15  15 15 15  15 15 15  15 15 15  15 15 15  15 15 15
+ 15 15 15  14 14 13  13 13 13  12 12 12  10 10 9  3 4 4
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  7 7 5  71 71 57  131 127 93  158 153 112
+ 177 172 135  197 193 154  214 212 158  239 239 170  251 251 187  251 251 187
+ 238 237 168  210 208 158  204 201 155  197 193 154  204 201 155  214 212 158
+ 251 251 187  251 251 187  251 251 187  251 251 187  251 251 187  214 212 158
+ 197 193 154  156 151 111  66 65 55  12 12 12  37 39 37  58 59 55
+ 58 59 55  41 42 42  31 33 31  22 24 23  17 17 17  12 14 14
+ 10 12 12  8 10 10  6 8 8  6 8 8  6 7 7  6 7 7
+ 6 7 7  5 7 7  6 7 7  6 7 7  6 8 8  6 8 8
+ 6 8 8  6 8 8  6 8 8  7 9 9  7 9 9  7 9 9
+ 7 9 9  6 8 8  6 8 8  6 8 8  6 8 8  6 8 8
+ 61 63 57  197 193 154  16 19 19  6 8 8  6 8 8  8 9 9
+ 41 42 42  47 48 46  51 52 50  51 52 50  55 56 53  55 56 53
+ 71 71 57  158 153 112  197 193 154  224 223 159  251 251 187  251 251 187
+ 251 251 187  251 251 187  239 239 170  214 212 158  204 201 155  194 189 146
+ 190 186 136  197 193 154  210 208 158  239 239 170  251 251 187  251 251 187
+ 251 251 187  251 251 187  251 251 187  224 223 159  204 201 155  177 172 135
+ 121 119 87  30 31 28  13 13 13  14 14 13  14 14 13  14 14 13
+ 14 14 13  14 14 13  15 15 15  15 15 15  14 14 13  13 13 13
+ 12 12 12  12 12 12  10 10 9  4 5 5  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  48 49 45  131 127 93  174 170 121
+ 194 189 146  210 208 158  239 239 170  251 251 187  251 251 187  251 251 187
+ 251 251 187  214 212 158  204 201 155  197 193 154  204 201 155  210 208 158
+ 239 239 170  251 251 187  251 251 187  251 251 187  239 239 170  214 212 158
+ 194 191 148  156 151 111  71 71 57  19 20 19  51 52 50  51 52 50
+ 51 52 50  41 42 42  30 32 31  21 22 21  17 17 17  13 13 13
+ 9 11 11  8 9 9  6 8 8  6 7 7  6 7 7  5 7 7
+ 5 6 5  5 6 5  5 7 7  5 7 7  6 7 7  6 7 7
+ 6 8 8  6 8 8  6 8 8  6 7 7  6 7 7  6 7 7
+ 6 7 7  6 8 8  6 8 8  6 8 8  6 8 8  6 8 8
+ 55 56 53  43 45 43  6 8 8  6 8 8  6 8 8  47 48 46
+ 60 60 56  47 48 46  46 47 45  47 48 46  38 39 37  10 12 12
+ 66 65 55  145 141 105  197 193 154  214 212 158  251 251 187  251 251 187
+ 251 251 187  251 251 187  224 223 159  210 208 158  194 191 148  184 181 136
+ 184 181 136  194 189 146  204 201 155  224 223 159  251 251 187  251 251 187
+ 251 251 187  251 251 187  251 251 187  239 239 170  210 208 158  181 176 137
 115 113 82  21 22 20  13 13 13  13 13 13  13 13 13  13 13 13
-14 14 13  13 13 13  13 13 13  13 13 13  12 12 12  11 11 11
-10 10 9  6 7 7  1 1 1  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  2 2 1  66 65 55  144 139 99  178 174 128
-204 201 155  214 212 158  251 251 187  251 251 187  251 251 187  251 251 187
-251 251 187  214 212 158  204 201 155  194 191 148  197 193 154  204 201 155
-214 212 158  239 239 170  239 239 170  239 239 170  214 212 158  210 208 158
-184 181 136  149 145 103  66 65 55  41 42 42  47 48 46  46 47 45
-43 45 43  39 40 39  28 31 30  21 22 21  16 16 16  10 12 12
-8 10 10  6 8 8  6 7 7  6 7 7  5 6 5  5 6 5
-5 6 5  5 6 5  5 6 5  5 6 5  5 7 7  5 7 7
-6 7 7  6 7 7  6 7 7  5 7 7  5 7 7  5 7 7
-5 7 7  6 7 7  6 7 7  6 7 7  6 7 7  6 8 8
-6 8 8  6 8 8  6 7 7  6 7 7  46 47 45  156 151 111
-105 104 92  58 59 55  43 45 43  32 34 33  6 8 8  6 8 8
-49 51 48  125 122 87  181 176 137  204 201 155  214 212 158  239 239 170
-239 239 170  214 212 158  210 208 158  197 193 154  181 176 137  176 171 126
-176 171 126  184 181 136  197 193 154  210 208 158  239 239 170  251 251 187
-251 251 187  251 251 187  251 251 187  251 251 187  210 208 158  177 172 135
-99 98 80  13 13 13  12 12 12  12 12 12  13 13 13  12 12 12
+ 14 14 13  13 13 13  13 13 13  13 13 13  12 12 12  11 11 11
+ 10 10 9  6 7 7  1 1 1  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  2 2 1  66 65 55  144 139 99  178 174 128
+ 204 201 155  214 212 158  251 251 187  251 251 187  251 251 187  251 251 187
+ 251 251 187  214 212 158  204 201 155  194 191 148  197 193 154  204 201 155
+ 214 212 158  239 239 170  239 239 170  239 239 170  214 212 158  210 208 158
+ 184 181 136  149 145 103  66 65 55  41 42 42  47 48 46  46 47 45
+ 43 45 43  39 40 39  28 31 30  21 22 21  16 16 16  10 12 12
+ 8 10 10  6 8 8  6 7 7  6 7 7  5 6 5  5 6 5
+ 5 6 5  5 6 5  5 6 5  5 6 5  5 7 7  5 7 7
+ 6 7 7  6 7 7  6 7 7  5 7 7  5 7 7  5 7 7
+ 5 7 7  6 7 7  6 7 7  6 7 7  6 7 7  6 8 8
+ 6 8 8  6 8 8  6 7 7  6 7 7  46 47 45  156 151 111
+ 105 104 92  58 59 55  43 45 43  32 34 33  6 8 8  6 8 8
+ 49 51 48  125 122 87  181 176 137  204 201 155  214 212 158  239 239 170
+ 239 239 170  214 212 158  210 208 158  197 193 154  181 176 137  176 171 126
+ 176 171 126  184 181 136  197 193 154  210 208 158  239 239 170  251 251 187
+ 251 251 187  251 251 187  251 251 187  251 251 187  210 208 158  177 172 135
+ 99 98 80  13 13 13  12 12 12  12 12 12  13 13 13  12 12 12
 12 12 12  12 12 12  11 11 11  11 11 11  8 9 9  4 5 5
-1 1 1  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  1 1 0  61 61 53  142 137 94  181 176 137
-204 201 155  224 223 159  251 251 187  251 251 187  251 251 187  251 251 187
-251 251 187  214 212 158  197 193 154  190 186 136  184 181 136  188 184 146
-197 193 154  204 201 155  210 208 158  210 208 158  204 201 155  194 189 146
-176 171 126  134 131 96  66 65 55  43 45 43  41 42 42  39 40 39
-35 37 36  33 36 34  27 29 28  20 20 20  15 15 15  9 11 11
-8 9 9  6 7 7  5 6 5  5 6 5  4 5 5  4 5 5
-4 5 5  4 5 5  4 5 5  4 5 5  5 6 5  4 5 5
-4 5 5  5 6 5  4 5 5  5 6 5  5 6 5  5 6 5
-5 7 7  5 7 7  5 7 7  5 7 7  5 7 7  5 7 7
-6 7 7  6 7 7  6 7 7  28 31 30  184 179 149  184 179 149
-145 141 105  84 83 72  27 29 28  5 7 7  5 6 5  16 16 16
-43 44 41  96 95 69  158 153 112  188 184 146  204 201 155  210 208 158
-204 201 155  197 193 154  184 179 149  177 172 135  168 163 120  164 159 111
-164 159 111  174 170 121  184 181 136  197 193 154  214 212 158  251 251 187
-251 251 187  251 251 187  251 251 187  251 251 187  210 208 158  177 172 135
-71 71 57  11 11 11  12 12 12  11 11 11  11 11 11  11 11 11
-10 10 9  10 10 9  8 8 7  3 4 4  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  31 33 31  121 119 87  176 171 126
-197 193 154  214 212 158  251 251 187  251 251 187  251 251 187  251 251 187
-239 239 170  210 208 158  194 189 146  178 174 128  174 170 121  176 171 126
-177 172 135  181 176 137  184 179 149  184 179 149  181 176 137  178 174 128
-158 153 112  121 119 87  53 55 47  37 39 37  33 36 34  30 32 31
-27 29 28  25 27 26  24 26 24  19 20 19  13 13 13  8 10 10
-6 8 8  6 7 7  5 6 5  4 5 5  4 5 5  4 5 5
-4 5 5  4 5 5  4 5 5  3 4 4  3 4 4  4 5 5
-4 5 5  4 5 5  4 5 5  4 5 5  4 5 5  4 5 5
-5 6 5  5 6 5  5 6 5  5 6 5  5 6 5  5 6 5
-5 6 5  5 6 5  12 14 14  145 141 105  184 179 149  177 172 135
-90 89 73  21 22 21  5 6 5  5 6 5  4 5 5  37 39 37
-38 39 37  61 61 53  134 131 96  168 163 120  184 181 136  188 184 146
-184 179 149  177 172 135  168 163 120  164 159 111  155 149 109  151 147 98
-151 147 98  164 159 111  176 171 126  184 179 149  210 208 158  239 239 170
-251 251 187  251 251 187  251 251 187  239 239 170  210 208 158  158 153 112
-46 47 43  10 10 9  10 10 9  10 10 9  8 9 9  8 9 9
-6 7 7  3 3 3  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  13 12 7  82 81 62  158 153 112
-188 184 146  210 208 158  239 239 170  251 251 187  251 251 187  251 251 187
-224 223 159  204 201 155  184 181 136  171 165 117  164 159 111  160 154 106
-158 153 112  164 159 111  168 163 120  168 163 120  168 163 120  164 159 111
-142 137 94  96 95 69  43 44 41  27 29 28  26 28 27  23 24 24
-21 22 21  18 19 18  17 17 17  18 19 18  13 13 13  8 8 7
-6 7 7  5 6 5  4 5 5  3 4 4  3 4 4  3 4 4
-3 4 4  3 4 4  3 3 3  3 3 3  3 4 4  3 4 4
-3 4 4  3 4 4  4 5 5  4 5 5  4 5 5  4 5 5
-4 5 5  4 5 5  4 5 5  4 5 5  4 5 5  4 5 5
-4 5 5  4 5 5  4 5 5  4 5 5  4 5 5  4 5 5
-4 5 5  4 5 5  4 5 5  4 5 5  31 33 31  65 66 61
-37 39 37  38 39 37  96 95 69  144 139 99  168 163 120  174 170 121
-168 163 120  164 159 111  155 149 109  149 145 103  149 143 98  142 137 94
-149 143 98  151 147 98  164 159 111  177 172 135  197 193 154  210 208 158
-251 251 187  251 251 187  251 251 187  239 239 170  197 193 154  137 133 100
-24 26 24  8 9 9  8 9 9  8 8 7  6 7 7  2 2 2
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  46 47 43  125 122 87
-176 171 126  197 193 154  210 208 158  239 239 170  251 251 187  239 239 170
-214 212 158  197 193 154  181 176 137  164 159 111  151 147 98  149 143 98
-149 143 98  149 143 98  149 145 103  155 149 109  160 154 106  149 143 98
-118 116 76  82 81 62  30 31 28  21 22 21  19 20 19  17 17 17
-14 14 13  12 12 12  10 10 9  12 12 12  10 12 12  6 8 8
-4 5 5  3 4 4  3 4 4  3 4 4  3 3 3  3 3 3
-3 3 3  3 3 3  3 3 3  3 3 3  2 3 3  2 3 3
-3 4 4  3 4 4  3 4 4  3 4 4  3 4 4  4 5 5
-4 5 5  3 4 4  3 4 4  3 4 4  3 4 4  3 4 4
-4 5 5  4 5 5  4 5 5  4 5 5  4 5 5  4 5 5
-4 5 5  3 4 4  3 4 4  23 24 24  110 109 94  72 73 67
-39 40 39  22 24 23  46 47 43  103 101 77  142 137 94  155 149 109
-160 154 106  155 149 109  149 143 98  142 137 94  142 137 94  142 137 94
-142 137 94  149 143 98  155 149 109  176 171 126  184 179 149  210 208 158
-239 239 170  251 251 187  251 251 187  214 212 158  184 179 149  105 104 92
-10 10 9  6 7 7  3 4 4  1 1 1  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  12 12 9  82 81 62
-149 145 103  181 176 137  197 193 154  210 208 158  214 212 158  214 212 158
-210 208 158  197 193 154  177 172 135  158 153 112  149 143 98  142 137 94
-142 137 94  142 137 94  149 143 98  151 147 98  151 147 98  131 127 93
-103 101 77  71 71 57  22 24 23  15 15 15  13 13 13  11 11 11
-8 9 9  6 7 7  6 7 7  4 5 5  8 9 9  6 7 7
-4 5 5  3 3 3  3 3 3  3 3 3  3 3 3  2 2 2
-2 2 2  2 2 2  2 2 2  2 2 2  2 2 2  2 3 3
-2 3 3  2 3 3  2 3 3  3 4 4  3 4 4  3 4 4
-3 4 4  3 4 4  3 3 3  3 4 4  3 4 4  3 4 4
-3 4 4  3 4 4  3 4 4  3 4 4  3 4 4  3 4 4
-3 4 4  3 4 4  21 22 21  145 141 105  145 141 105  72 73 67
-17 18 17  3 4 4  21 22 20  66 65 55  118 116 76  142 137 94
-149 143 98  151 147 98  149 143 98  142 137 94  142 137 94  142 137 94
-142 137 94  149 143 98  155 149 109  168 163 120  184 179 149  210 208 158
-239 239 170  251 251 187  251 251 187  210 208 158  177 172 135  71 71 57
-3 3 3  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  36 38 35
-115 113 82  158 153 112  181 176 137  197 193 154  204 201 155  210 208 158
-204 201 155  188 184 146  177 172 135  164 159 111  149 145 103  142 137 94
-142 137 94  142 137 94  149 143 98  151 147 98  149 143 98  125 122 87
-96 95 69  61 61 53  16 17 12  8 9 9  8 8 7  6 7 7
-4 5 5  3 4 4  3 3 3  3 3 3  3 3 3  5 6 5
-3 4 4  2 3 3  2 2 2  2 2 2  2 2 2  2 2 2
-2 2 2  2 2 2  2 2 2  2 2 2  2 2 2  1 2 2
-2 2 2  2 2 2  2 3 3  2 3 3  2 3 3  2 3 3
-3 3 3  3 3 3  3 3 3  3 3 3  3 3 3  3 3 3
-3 3 3  2 3 3  2 3 3  3 4 4  3 4 4  3 4 4
-3 4 4  3 4 4  3 4 4  8 9 9  8 8 7  3 3 3
-3 3 3  3 3 3  9 9 8  36 38 35  82 81 62  118 116 76
-142 137 94  151 147 98  151 147 98  151 147 98  149 143 98  149 143 98
-149 143 98  151 147 98  160 154 106  176 171 126  188 184 146  210 208 158
-239 239 170  251 251 187  239 239 170  210 208 158  156 151 111  31 33 31
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  7 7 5
-66 65 55  125 122 87  158 153 112  181 176 137  194 189 146  197 193 154
-197 193 154  184 179 149  177 172 135  168 163 120  156 151 111  151 147 98
-151 147 98  151 147 98  151 147 98  161 156 96  149 143 98  118 116 76
-82 81 62  53 55 47  12 12 9  4 5 5  3 4 4  3 3 3
-3 3 3  3 3 3  2 2 2  2 2 2  1 1 1  1 2 2
-3 3 3  2 2 2  2 2 2  2 2 2  2 2 2  2 2 2
-1 1 1  1 1 1  1 1 1  1 1 1  1 2 2  1 2 2
-1 2 2  1 2 2  1 2 2  2 2 2  2 2 2  2 3 3
-2 3 3  2 3 3  2 3 3  2 3 3  2 2 2  2 2 2
-2 3 3  2 3 3  2 3 3  2 3 3  2 3 3  2 3 3
-2 3 3  2 3 3  2 3 3  2 3 3  2 3 3  3 3 3
-3 3 3  3 3 3  72 73 67  61 61 53  53 55 47  96 95 69
-131 127 93  151 147 98  161 156 96  161 156 96  151 147 98  151 147 98
-161 156 96  160 154 106  164 159 111  177 172 135  197 193 154  210 208 158
-239 239 170  251 251 187  224 223 159  197 193 154  131 127 93  9 9 8
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-24 26 24  82 81 62  131 127 93  164 159 111  178 174 128  188 184 146
-188 184 146  188 184 146  181 176 137  176 171 126  168 163 120  164 159 111
-160 154 106  160 154 106  160 154 106  160 154 106  151 147 98  125 122 87
-82 81 62  61 61 53  12 12 9  3 3 3  3 3 3  2 2 2
-2 2 2  1 1 1  1 1 1  1 1 1  0 0 0  0 0 0
-0 0 0  2 2 2  1 1 1  1 1 1  1 1 1  1 1 1
-1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
-1 1 1  1 1 1  1 2 2  1 2 2  1 2 2  1 2 2
-1 2 2  2 2 2  2 2 2  2 2 2  2 2 2  2 2 2
-2 2 2  2 2 2  2 2 2  2 2 2  2 2 2  2 2 2
-2 3 3  2 3 3  2 3 3  2 3 3  2 3 3  2 3 3
-2 3 3  30 32 31  72 73 67  31 33 31  36 38 35  82 81 62
-118 116 76  149 143 98  161 156 96  161 156 96  161 156 96  160 154 106
-165 161 109  165 161 109  176 171 126  188 184 146  204 201 155  214 212 158
-239 239 170  239 239 170  214 212 158  184 179 149  82 81 62  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-2 2 2  43 44 41  96 95 69  131 127 93  160 154 106  176 171 126
-184 181 136  184 181 136  184 181 136  181 176 137  178 174 128  174 170 121
-171 165 117  173 167 111  173 167 111  173 167 111  160 154 106  131 127 93
-96 95 69  66 65 55  16 17 12  2 2 2  1 1 1  1 1 1
-1 1 1  1 1 1  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  1 1 1  1 1 1  1 1 1  1 1 1
-1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
-1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
-1 2 2  1 2 2  1 2 2  1 2 2  1 2 2  2 2 2
-2 2 2  2 2 2  2 2 2  2 2 2  2 2 2  2 2 2
-2 2 2  2 2 2  2 2 2  2 2 2  2 2 2  2 2 2
-2 2 2  2 2 2  2 2 2  10 9 6  30 31 28  71 71 57
-118 116 76  149 143 98  165 161 109  165 161 109  165 161 109  173 167 111
-173 167 111  176 171 126  184 181 136  197 193 154  210 208 158  224 223 159
-251 251 187  239 239 170  210 208 158  168 163 120  40 41 39  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  13 12 7  61 61 53  96 95 69  131 127 93  160 154 106
-176 171 126  184 181 136  184 181 136  188 184 146  184 181 136  184 181 136
-184 181 136  186 182 128  186 182 128  178 174 128  174 170 121  149 145 103
-118 116 76  82 81 62  21 22 20  1 1 1  1 1 1  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  1 1 1  1 1 1
-1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
-1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
-1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 2 2
-1 2 2  1 2 2  1 2 2  1 2 2  1 2 2  2 2 2
-2 2 2  2 2 2  2 2 2  2 2 2  2 2 2  2 2 2
-2 2 2  2 2 2  2 2 2  3 3 3  30 31 28  66 65 55
-118 116 76  149 143 98  165 161 109  173 167 111  173 167 111  174 170 121
-186 182 128  190 186 136  197 193 154  210 208 158  224 223 159  251 251 187
-251 251 187  239 239 170  197 193 154  137 133 100  12 12 9  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  30 31 28  71 71 57  103 101 77  134 131 96
+ 1 1 1  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  1 1 0  61 61 53  142 137 94  181 176 137
+ 204 201 155  224 223 159  251 251 187  251 251 187  251 251 187  251 251 187
+ 251 251 187  214 212 158  197 193 154  190 186 136  184 181 136  188 184 146
+ 197 193 154  204 201 155  210 208 158  210 208 158  204 201 155  194 189 146
+ 176 171 126  134 131 96  66 65 55  43 45 43  41 42 42  39 40 39
+ 35 37 36  33 36 34  27 29 28  20 20 20  15 15 15  9 11 11
+ 8 9 9  6 7 7  5 6 5  5 6 5  4 5 5  4 5 5
+ 4 5 5  4 5 5  4 5 5  4 5 5  5 6 5  4 5 5
+ 4 5 5  5 6 5  4 5 5  5 6 5  5 6 5  5 6 5
+ 5 7 7  5 7 7  5 7 7  5 7 7  5 7 7  5 7 7
+ 6 7 7  6 7 7  6 7 7  28 31 30  184 179 149  184 179 149
+ 145 141 105  84 83 72  27 29 28  5 7 7  5 6 5  16 16 16
+ 43 44 41  96 95 69  158 153 112  188 184 146  204 201 155  210 208 158
+ 204 201 155  197 193 154  184 179 149  177 172 135  168 163 120  164 159 111
+ 164 159 111  174 170 121  184 181 136  197 193 154  214 212 158  251 251 187
+ 251 251 187  251 251 187  251 251 187  251 251 187  210 208 158  177 172 135
+ 71 71 57  11 11 11  12 12 12  11 11 11  11 11 11  11 11 11
+ 10 10 9  10 10 9  8 8 7  3 4 4  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  31 33 31  121 119 87  176 171 126
+ 197 193 154  214 212 158  251 251 187  251 251 187  251 251 187  251 251 187
+ 239 239 170  210 208 158  194 189 146  178 174 128  174 170 121  176 171 126
+ 177 172 135  181 176 137  184 179 149  184 179 149  181 176 137  178 174 128
+ 158 153 112  121 119 87  53 55 47  37 39 37  33 36 34  30 32 31
+ 27 29 28  25 27 26  24 26 24  19 20 19  13 13 13  8 10 10
+ 6 8 8  6 7 7  5 6 5  4 5 5  4 5 5  4 5 5
+ 4 5 5  4 5 5  4 5 5  3 4 4  3 4 4  4 5 5
+ 4 5 5  4 5 5  4 5 5  4 5 5  4 5 5  4 5 5
+ 5 6 5  5 6 5  5 6 5  5 6 5  5 6 5  5 6 5
+ 5 6 5  5 6 5  12 14 14  145 141 105  184 179 149  177 172 135
+ 90 89 73  21 22 21  5 6 5  5 6 5  4 5 5  37 39 37
+ 38 39 37  61 61 53  134 131 96  168 163 120  184 181 136  188 184 146
+ 184 179 149  177 172 135  168 163 120  164 159 111  155 149 109  151 147 98
+ 151 147 98  164 159 111  176 171 126  184 179 149  210 208 158  239 239 170
+ 251 251 187  251 251 187  251 251 187  239 239 170  210 208 158  158 153 112
+ 46 47 43  10 10 9  10 10 9  10 10 9  8 9 9  8 9 9
+ 6 7 7  3 3 3  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  13 12 7  82 81 62  158 153 112
+ 188 184 146  210 208 158  239 239 170  251 251 187  251 251 187  251 251 187
+ 224 223 159  204 201 155  184 181 136  171 165 117  164 159 111  160 154 106
+ 158 153 112  164 159 111  168 163 120  168 163 120  168 163 120  164 159 111
+ 142 137 94  96 95 69  43 44 41  27 29 28  26 28 27  23 24 24
+ 21 22 21  18 19 18  17 17 17  18 19 18  13 13 13  8 8 7
+ 6 7 7  5 6 5  4 5 5  3 4 4  3 4 4  3 4 4
+ 3 4 4  3 4 4  3 3 3  3 3 3  3 4 4  3 4 4
+ 3 4 4  3 4 4  4 5 5  4 5 5  4 5 5  4 5 5
+ 4 5 5  4 5 5  4 5 5  4 5 5  4 5 5  4 5 5
+ 4 5 5  4 5 5  4 5 5  4 5 5  4 5 5  4 5 5
+ 4 5 5  4 5 5  4 5 5  4 5 5  31 33 31  65 66 61
+ 37 39 37  38 39 37  96 95 69  144 139 99  168 163 120  174 170 121
+ 168 163 120  164 159 111  155 149 109  149 145 103  149 143 98  142 137 94
+ 149 143 98  151 147 98  164 159 111  177 172 135  197 193 154  210 208 158
+ 251 251 187  251 251 187  251 251 187  239 239 170  197 193 154  137 133 100
+ 24 26 24  8 9 9  8 9 9  8 8 7  6 7 7  2 2 2
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  46 47 43  125 122 87
+ 176 171 126  197 193 154  210 208 158  239 239 170  251 251 187  239 239 170
+ 214 212 158  197 193 154  181 176 137  164 159 111  151 147 98  149 143 98
+ 149 143 98  149 143 98  149 145 103  155 149 109  160 154 106  149 143 98
+ 118 116 76  82 81 62  30 31 28  21 22 21  19 20 19  17 17 17
+ 14 14 13  12 12 12  10 10 9  12 12 12  10 12 12  6 8 8
+ 4 5 5  3 4 4  3 4 4  3 4 4  3 3 3  3 3 3
+ 3 3 3  3 3 3  3 3 3  3 3 3  2 3 3  2 3 3
+ 3 4 4  3 4 4  3 4 4  3 4 4  3 4 4  4 5 5
+ 4 5 5  3 4 4  3 4 4  3 4 4  3 4 4  3 4 4
+ 4 5 5  4 5 5  4 5 5  4 5 5  4 5 5  4 5 5
+ 4 5 5  3 4 4  3 4 4  23 24 24  110 109 94  72 73 67
+ 39 40 39  22 24 23  46 47 43  103 101 77  142 137 94  155 149 109
+ 160 154 106  155 149 109  149 143 98  142 137 94  142 137 94  142 137 94
+ 142 137 94  149 143 98  155 149 109  176 171 126  184 179 149  210 208 158
+ 239 239 170  251 251 187  251 251 187  214 212 158  184 179 149  105 104 92
+ 10 10 9  6 7 7  3 4 4  1 1 1  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  12 12 9  82 81 62
+ 149 145 103  181 176 137  197 193 154  210 208 158  214 212 158  214 212 158
+ 210 208 158  197 193 154  177 172 135  158 153 112  149 143 98  142 137 94
+ 142 137 94  142 137 94  149 143 98  151 147 98  151 147 98  131 127 93
+ 103 101 77  71 71 57  22 24 23  15 15 15  13 13 13  11 11 11
+ 8 9 9  6 7 7  6 7 7  4 5 5  8 9 9  6 7 7
+ 4 5 5  3 3 3  3 3 3  3 3 3  3 3 3  2 2 2
+ 2 2 2  2 2 2  2 2 2  2 2 2  2 2 2  2 3 3
+ 2 3 3  2 3 3  2 3 3  3 4 4  3 4 4  3 4 4
+ 3 4 4  3 4 4  3 3 3  3 4 4  3 4 4  3 4 4
+ 3 4 4  3 4 4  3 4 4  3 4 4  3 4 4  3 4 4
+ 3 4 4  3 4 4  21 22 21  145 141 105  145 141 105  72 73 67
+ 17 18 17  3 4 4  21 22 20  66 65 55  118 116 76  142 137 94
+ 149 143 98  151 147 98  149 143 98  142 137 94  142 137 94  142 137 94
+ 142 137 94  149 143 98  155 149 109  168 163 120  184 179 149  210 208 158
+ 239 239 170  251 251 187  251 251 187  210 208 158  177 172 135  71 71 57
+ 3 3 3  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  36 38 35
+ 115 113 82  158 153 112  181 176 137  197 193 154  204 201 155  210 208 158
+ 204 201 155  188 184 146  177 172 135  164 159 111  149 145 103  142 137 94
+ 142 137 94  142 137 94  149 143 98  151 147 98  149 143 98  125 122 87
+ 96 95 69  61 61 53  16 17 12  8 9 9  8 8 7  6 7 7
+ 4 5 5  3 4 4  3 3 3  3 3 3  3 3 3  5 6 5
+ 3 4 4  2 3 3  2 2 2  2 2 2  2 2 2  2 2 2
+ 2 2 2  2 2 2  2 2 2  2 2 2  2 2 2  1 2 2
+ 2 2 2  2 2 2  2 3 3  2 3 3  2 3 3  2 3 3
+ 3 3 3  3 3 3  3 3 3  3 3 3  3 3 3  3 3 3
+ 3 3 3  2 3 3  2 3 3  3 4 4  3 4 4  3 4 4
+ 3 4 4  3 4 4  3 4 4  8 9 9  8 8 7  3 3 3
+ 3 3 3  3 3 3  9 9 8  36 38 35  82 81 62  118 116 76
+ 142 137 94  151 147 98  151 147 98  151 147 98  149 143 98  149 143 98
+ 149 143 98  151 147 98  160 154 106  176 171 126  188 184 146  210 208 158
+ 239 239 170  251 251 187  239 239 170  210 208 158  156 151 111  31 33 31
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  7 7 5
+ 66 65 55  125 122 87  158 153 112  181 176 137  194 189 146  197 193 154
+ 197 193 154  184 179 149  177 172 135  168 163 120  156 151 111  151 147 98
+ 151 147 98  151 147 98  151 147 98  161 156 96  149 143 98  118 116 76
+ 82 81 62  53 55 47  12 12 9  4 5 5  3 4 4  3 3 3
+ 3 3 3  3 3 3  2 2 2  2 2 2  1 1 1  1 2 2
+ 3 3 3  2 2 2  2 2 2  2 2 2  2 2 2  2 2 2
+ 1 1 1  1 1 1  1 1 1  1 1 1  1 2 2  1 2 2
+ 1 2 2  1 2 2  1 2 2  2 2 2  2 2 2  2 3 3
+ 2 3 3  2 3 3  2 3 3  2 3 3  2 2 2  2 2 2
+ 2 3 3  2 3 3  2 3 3  2 3 3  2 3 3  2 3 3
+ 2 3 3  2 3 3  2 3 3  2 3 3  2 3 3  3 3 3
+ 3 3 3  3 3 3  72 73 67  61 61 53  53 55 47  96 95 69
+ 131 127 93  151 147 98  161 156 96  161 156 96  151 147 98  151 147 98
+ 161 156 96  160 154 106  164 159 111  177 172 135  197 193 154  210 208 158
+ 239 239 170  251 251 187  224 223 159  197 193 154  131 127 93  9 9 8
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 24 26 24  82 81 62  131 127 93  164 159 111  178 174 128  188 184 146
+ 188 184 146  188 184 146  181 176 137  176 171 126  168 163 120  164 159 111
+ 160 154 106  160 154 106  160 154 106  160 154 106  151 147 98  125 122 87
+ 82 81 62  61 61 53  12 12 9  3 3 3  3 3 3  2 2 2
+ 2 2 2  1 1 1  1 1 1  1 1 1  0 0 0  0 0 0
+ 0 0 0  2 2 2  1 1 1  1 1 1  1 1 1  1 1 1
+ 1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
+ 1 1 1  1 1 1  1 2 2  1 2 2  1 2 2  1 2 2
+ 1 2 2  2 2 2  2 2 2  2 2 2  2 2 2  2 2 2
+ 2 2 2  2 2 2  2 2 2  2 2 2  2 2 2  2 2 2
+ 2 3 3  2 3 3  2 3 3  2 3 3  2 3 3  2 3 3
+ 2 3 3  30 32 31  72 73 67  31 33 31  36 38 35  82 81 62
+ 118 116 76  149 143 98  161 156 96  161 156 96  161 156 96  160 154 106
+ 165 161 109  165 161 109  176 171 126  188 184 146  204 201 155  214 212 158
+ 239 239 170  239 239 170  214 212 158  184 179 149  82 81 62  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 2 2 2  43 44 41  96 95 69  131 127 93  160 154 106  176 171 126
+ 184 181 136  184 181 136  184 181 136  181 176 137  178 174 128  174 170 121
+ 171 165 117  173 167 111  173 167 111  173 167 111  160 154 106  131 127 93
+ 96 95 69  66 65 55  16 17 12  2 2 2  1 1 1  1 1 1
+ 1 1 1  1 1 1  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  1 1 1  1 1 1  1 1 1  1 1 1
+ 1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
+ 1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
+ 1 2 2  1 2 2  1 2 2  1 2 2  1 2 2  2 2 2
+ 2 2 2  2 2 2  2 2 2  2 2 2  2 2 2  2 2 2
+ 2 2 2  2 2 2  2 2 2  2 2 2  2 2 2  2 2 2
+ 2 2 2  2 2 2  2 2 2  10 9 6  30 31 28  71 71 57
+ 118 116 76  149 143 98  165 161 109  165 161 109  165 161 109  173 167 111
+ 173 167 111  176 171 126  184 181 136  197 193 154  210 208 158  224 223 159
+ 251 251 187  239 239 170  210 208 158  168 163 120  40 41 39  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  13 12 7  61 61 53  96 95 69  131 127 93  160 154 106
+ 176 171 126  184 181 136  184 181 136  188 184 146  184 181 136  184 181 136
+ 184 181 136  186 182 128  186 182 128  178 174 128  174 170 121  149 145 103
+ 118 116 76  82 81 62  21 22 20  1 1 1  1 1 1  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  1 1 1  1 1 1
+ 1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
+ 1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
+ 1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 2 2
+ 1 2 2  1 2 2  1 2 2  1 2 2  1 2 2  2 2 2
+ 2 2 2  2 2 2  2 2 2  2 2 2  2 2 2  2 2 2
+ 2 2 2  2 2 2  2 2 2  3 3 3  30 31 28  66 65 55
+ 118 116 76  149 143 98  165 161 109  173 167 111  173 167 111  174 170 121
+ 186 182 128  190 186 136  197 193 154  210 208 158  224 223 159  251 251 187
+ 251 251 187  239 239 170  197 193 154  137 133 100  12 12 9  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  30 31 28  71 71 57  103 101 77  134 131 96
 164 159 111  176 171 126  184 181 136  188 184 146  194 189 146  197 193 154
-197 193 154  197 193 154  194 191 148  194 189 146  190 186 136  176 171 126
-145 141 105  103 101 77  40 41 39  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
-1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
-1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
-1 1 1  1 1 1  1 1 1  1 1 1  1 2 2  1 2 2
-1 2 2  1 2 2  1 2 2  1 2 2  1 2 2  1 2 2
-1 2 2  1 2 2  1 2 2  1 2 2  30 31 28  71 71 57
-118 116 76  160 154 106  173 167 111  178 174 128  186 182 128  190 186 136
-194 191 148  204 201 155  210 208 158  224 223 159  251 251 187  251 251 187
-251 251 187  214 212 158  184 179 149  84 83 72  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  5 5 3  43 44 41  82 81 62  103 101 77
-142 137 94  165 161 109  178 174 128  190 186 136  197 193 154  204 201 155
+ 197 193 154  197 193 154  194 191 148  194 189 146  190 186 136  176 171 126
+ 145 141 105  103 101 77  40 41 39  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
+ 1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
+ 1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
+ 1 1 1  1 1 1  1 1 1  1 1 1  1 2 2  1 2 2
+ 1 2 2  1 2 2  1 2 2  1 2 2  1 2 2  1 2 2
+ 1 2 2  1 2 2  1 2 2  1 2 2  30 31 28  71 71 57
+ 118 116 76  160 154 106  173 167 111  178 174 128  186 182 128  190 186 136
+ 194 191 148  204 201 155  210 208 158  224 223 159  251 251 187  251 251 187
+ 251 251 187  214 212 158  184 179 149  84 83 72  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  5 5 3  43 44 41  82 81 62  103 101 77
+ 142 137 94  165 161 109  178 174 128  190 186 136  197 193 154  204 201 155
 210 208 158  210 208 158  210 208 158  210 208 158  210 208 158  197 193 154
-177 172 135  145 141 105  79 78 62  5 4 3  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  1 1 1  1 1 1  1 1 1  1 1 1
-1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
-1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
-1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
-1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
-1 1 1  1 1 1  1 2 2  1 2 2  30 31 28  82 81 62
-142 137 94  165 161 109  178 174 128  190 186 136  194 191 148  204 201 155
-210 208 158  214 212 158  239 239 170  251 251 187  251 251 187  251 251 187
-251 251 187  210 208 158  168 163 120  36 38 35  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  16 17 12  53 55 47  82 81 62
-118 116 76  151 147 98  171 165 117  184 181 136  194 191 148  210 208 158
-214 212 158  224 223 159  239 239 170  239 239 170  224 223 159  214 212 158
+ 177 172 135  145 141 105  79 78 62  5 4 3  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  1 1 1  1 1 1  1 1 1  1 1 1
+ 1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
+ 1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
+ 1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
+ 1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
+ 1 1 1  1 1 1  1 2 2  1 2 2  30 31 28  82 81 62
+ 142 137 94  165 161 109  178 174 128  190 186 136  194 191 148  204 201 155
+ 210 208 158  214 212 158  239 239 170  251 251 187  251 251 187  251 251 187
+ 251 251 187  210 208 158  168 163 120  36 38 35  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  16 17 12  53 55 47  82 81 62
+ 118 116 76  151 147 98  171 165 117  184 181 136  194 191 148  210 208 158
+ 214 212 158  224 223 159  239 239 170  239 239 170  224 223 159  214 212 158
 197 193 154  176 171 126  115 113 82  24 26 24  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  1 1 1  1 1 1
-1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
-1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
-1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
-1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
-1 1 1  1 1 1  1 1 1  1 1 1  40 41 39  103 101 77
-151 147 98  176 171 126  190 186 136  197 193 154  210 208 158  214 212 158
-239 239 170  251 251 187  251 251 187  251 251 187  251 251 187  251 251 187
-239 239 170  197 193 154  110 109 94  3 4 3  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  30 31 28  66 65 55
-96 95 69  125 122 87  160 154 106  178 174 128  194 189 146  204 201 155
-214 212 158  239 239 170  251 251 187  251 251 187  251 251 187  239 239 170
-210 208 158  188 184 146  149 145 103  61 61 53  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
-1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
-1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
-1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
-1 1 1  1 1 1  1 1 1  1 1 1  61 61 53  131 127 93
-164 159 111  184 181 136  197 193 154  210 208 158  224 223 159  251 251 187
-251 251 187  251 251 187  251 251 187  251 251 187  251 251 187  251 251 187
-210 208 158  168 163 120  43 44 41  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  4 3 2  36 38 35
-71 71 57  96 95 69  142 137 94  165 161 109  184 181 136  197 193 154
-210 208 158  239 239 170  251 251 187  251 251 187  251 251 187  251 251 187
-214 212 158  197 193 154  168 163 120  103 101 77  7 7 5  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  1 1 1
-1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
-1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
-1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
-1 1 1  0 0 0  0 0 0  0 0 0  82 81 62  142 137 94
-174 170 121  194 189 146  210 208 158  224 223 159  251 251 187  251 251 187
-251 251 187  251 251 187  251 251 187  251 251 187  251 251 187  224 223 159
-184 179 149  99 98 80  3 3 3  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  7 7 5
-43 44 41  82 81 62  118 116 76  142 137 94  171 165 117  190 186 136
-204 201 155  224 223 159  251 251 187  251 251 187  251 251 187  251 251 187
-214 212 158  197 193 154  174 170 121  125 122 87  30 31 28  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  1 1 1
-1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  3 4 3  82 81 62  149 143 98
-176 171 126  194 191 148  210 208 158  239 239 170  251 251 187  251 251 187
-251 251 187  251 251 187  251 251 187  251 251 187  239 239 170  204 201 155
-145 141 105  30 31 28  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-10 9 6  46 47 43  82 81 62  118 116 76  149 143 98  174 170 121
-194 189 146  210 208 158  224 223 159  251 251 187  251 251 187  224 223 159
-210 208 158  194 191 148  174 170 121  134 131 96  53 55 47  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  7 7 5  96 95 69  149 143 98
-176 171 126  194 191 148  210 208 158  239 239 170  251 251 187  251 251 187
-251 251 187  251 251 187  251 251 187  239 239 170  210 208 158  177 172 135
-75 75 61  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  10 9 6  46 47 43  82 81 62  118 116 76  149 143 98
-176 171 126  194 191 148  210 208 158  214 212 158  214 212 158  210 208 158
-197 193 154  184 181 136  164 159 111  131 127 93  53 55 47  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  7 7 5  96 95 69  149 143 98
-174 170 121  194 189 146  204 201 155  214 212 158  239 239 170  251 251 187
-251 251 187  251 251 187  239 239 170  210 208 158  184 179 149  110 109 94
-12 12 9  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  10 9 6  43 44 41  82 81 62  115 113 82
-144 139 99  168 163 120  188 184 146  197 193 154  197 193 154  194 189 146
-184 181 136  174 170 121  151 147 98  118 116 76  36 38 35  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  4 3 2  82 81 62  142 137 94
-171 165 117  186 182 128  194 191 148  210 208 158  214 212 158  224 223 159
-239 239 170  224 223 159  210 208 158  184 179 149  137 133 100  36 38 35
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  7 7 5  36 38 35  71 71 57
-103 101 77  131 127 93  155 149 109  168 163 120  168 163 120  168 163 120
-164 159 111  149 143 98  125 122 87  82 81 62  13 12 7  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  61 61 53  125 122 87
-160 154 106  174 170 121  184 181 136  194 189 146  204 201 155  210 208 158
-210 208 158  204 201 155  184 179 149  145 141 105  61 61 53  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  3 3 2  30 31 28
-61 61 53  82 81 62  103 101 77  121 119 87  125 122 87  125 122 87
-118 116 76  103 101 77  79 78 62  24 26 24  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  25 27 25  96 95 69
-142 137 94  160 154 106  171 165 117  178 174 128  184 181 136  184 181 136
-181 176 137  177 172 135  145 141 105  75 75 61  5 5 3  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-16 17 12  40 41 39  61 61 53  71 71 57  71 71 57  71 71 57
-66 65 55  43 44 41  12 12 9  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  1 1 1  46 47 43
-96 95 69  125 122 87  142 137 94  149 145 103  155 149 109  155 149 109
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  1 1 1  1 1 1
+ 1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
+ 1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
+ 1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
+ 1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
+ 1 1 1  1 1 1  1 1 1  1 1 1  40 41 39  103 101 77
+ 151 147 98  176 171 126  190 186 136  197 193 154  210 208 158  214 212 158
+ 239 239 170  251 251 187  251 251 187  251 251 187  251 251 187  251 251 187
+ 239 239 170  197 193 154  110 109 94  3 4 3  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  30 31 28  66 65 55
+ 96 95 69  125 122 87  160 154 106  178 174 128  194 189 146  204 201 155
+ 214 212 158  239 239 170  251 251 187  251 251 187  251 251 187  239 239 170
+ 210 208 158  188 184 146  149 145 103  61 61 53  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
+ 1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
+ 1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
+ 1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
+ 1 1 1  1 1 1  1 1 1  1 1 1  61 61 53  131 127 93
+ 164 159 111  184 181 136  197 193 154  210 208 158  224 223 159  251 251 187
+ 251 251 187  251 251 187  251 251 187  251 251 187  251 251 187  251 251 187
+ 210 208 158  168 163 120  43 44 41  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  4 3 2  36 38 35
+ 71 71 57  96 95 69  142 137 94  165 161 109  184 181 136  197 193 154
+ 210 208 158  239 239 170  251 251 187  251 251 187  251 251 187  251 251 187
+ 214 212 158  197 193 154  168 163 120  103 101 77  7 7 5  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  1 1 1
+ 1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
+ 1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
+ 1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
+ 1 1 1  0 0 0  0 0 0  0 0 0  82 81 62  142 137 94
+ 174 170 121  194 189 146  210 208 158  224 223 159  251 251 187  251 251 187
+ 251 251 187  251 251 187  251 251 187  251 251 187  251 251 187  224 223 159
+ 184 179 149  99 98 80  3 3 3  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  7 7 5
+ 43 44 41  82 81 62  118 116 76  142 137 94  171 165 117  190 186 136
+ 204 201 155  224 223 159  251 251 187  251 251 187  251 251 187  251 251 187
+ 214 212 158  197 193 154  174 170 121  125 122 87  30 31 28  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  1 1 1
+ 1 1 1  1 1 1  1 1 1  1 1 1  1 1 1  1 1 1
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  3 4 3  82 81 62  149 143 98
+ 176 171 126  194 191 148  210 208 158  239 239 170  251 251 187  251 251 187
+ 251 251 187  251 251 187  251 251 187  251 251 187  239 239 170  204 201 155
+ 145 141 105  30 31 28  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 10 9 6  46 47 43  82 81 62  118 116 76  149 143 98  174 170 121
+ 194 189 146  210 208 158  224 223 159  251 251 187  251 251 187  224 223 159
+ 210 208 158  194 191 148  174 170 121  134 131 96  53 55 47  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  7 7 5  96 95 69  149 143 98
+ 176 171 126  194 191 148  210 208 158  239 239 170  251 251 187  251 251 187
+ 251 251 187  251 251 187  251 251 187  239 239 170  210 208 158  177 172 135
+ 75 75 61  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  10 9 6  46 47 43  82 81 62  118 116 76  149 143 98
+ 176 171 126  194 191 148  210 208 158  214 212 158  214 212 158  210 208 158
+ 197 193 154  184 181 136  164 159 111  131 127 93  53 55 47  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  7 7 5  96 95 69  149 143 98
+ 174 170 121  194 189 146  204 201 155  214 212 158  239 239 170  251 251 187
+ 251 251 187  251 251 187  239 239 170  210 208 158  184 179 149  110 109 94
+ 12 12 9  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  10 9 6  43 44 41  82 81 62  115 113 82
+ 144 139 99  168 163 120  188 184 146  197 193 154  197 193 154  194 189 146
+ 184 181 136  174 170 121  151 147 98  118 116 76  36 38 35  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  4 3 2  82 81 62  142 137 94
+ 171 165 117  186 182 128  194 191 148  210 208 158  214 212 158  224 223 159
+ 239 239 170  224 223 159  210 208 158  184 179 149  137 133 100  36 38 35
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  7 7 5  36 38 35  71 71 57
+ 103 101 77  131 127 93  155 149 109  168 163 120  168 163 120  168 163 120
+ 164 159 111  149 143 98  125 122 87  82 81 62  13 12 7  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  61 61 53  125 122 87
+ 160 154 106  174 170 121  184 181 136  194 189 146  204 201 155  210 208 158
+ 210 208 158  204 201 155  184 179 149  145 141 105  61 61 53  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  3 3 2  30 31 28
+ 61 61 53  82 81 62  103 101 77  121 119 87  125 122 87  125 122 87
+ 118 116 76  103 101 77  79 78 62  24 26 24  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  25 27 25  96 95 69
+ 142 137 94  160 154 106  171 165 117  178 174 128  184 181 136  184 181 136
+ 181 176 137  177 172 135  145 141 105  75 75 61  5 5 3  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 16 17 12  40 41 39  61 61 53  71 71 57  71 71 57  71 71 57
+ 66 65 55  43 44 41  12 12 9  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  1 1 1  46 47 43
+ 96 95 69  125 122 87  142 137 94  149 145 103  155 149 109  155 149 109
 145 141 105  121 119 87  66 65 55  7 7 5  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  1 1 1  16 17 12  24 26 24  25 27 25  19 20 18
-7 7 5  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  2 2 1
-25 27 25  61 61 53  82 81 62  96 95 69  96 95 69  82 81 62
-61 61 53  25 27 25  2 2 1  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  5 6 5  13 12 7  10 9 6  3 4 3
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
-0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  1 1 1  16 17 12  24 26 24  25 27 25  19 20 18
+ 7 7 5  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  2 2 1
+ 25 27 25  61 61 53  82 81 62  96 95 69  96 95 69  82 81 62
+ 61 61 53  25 27 25  2 2 1  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  5 6 5  13 12 7  10 9 6  3 4 3
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+ 0 0 0
