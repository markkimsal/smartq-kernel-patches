From facb7bcdaae1ec5a003e4c2b7716674fd0538807 Mon Sep 17 00:00:00 2001
From: YouSheng <david.ysh@gmail.com>
Date: Wed, 12 Aug 2009 14:54:14 +0800
Subject: [PATCH] Merge telechip nand driver to kernel V7003

---
 drivers/block/Kconfig                              |    2 +
 drivers/block/Makefile                             |    3 +
 drivers/block/tcc/Kconfig                          |   13 +
 drivers/block/tcc/Makefile                         |   33 +
 drivers/block/tcc/fwupgrade.c                      |  598 +
 drivers/block/tcc/inc/common.h                     |   23 +
 drivers/block/tcc/inc/config.h                     |   56 +
 drivers/block/tcc/inc/def_tcc.h                    |    6 +
 drivers/block/tcc/inc/fwdn/Disk.h                  |  313 +
 drivers/block/tcc/inc/fwdn/FSAPP.h                 |  125 +
 drivers/block/tcc/inc/fwdn/KFSutils.h              |   23 +
 drivers/block/tcc/inc/fwdn/TC_File.h               |  164 +
 drivers/block/tcc/inc/fwdn/browse.h                |  455 +
 drivers/block/tcc/inc/fwdn/fat.h                   |  739 +
 drivers/block/tcc/inc/fwdn/file.h                  |  284 +
 drivers/block/tcc/inc/fwdn/fwdn_drv_v3.h           |  153 +
 drivers/block/tcc/inc/fwdn/fwdn_protocol_v3.h      |  116 +
 drivers/block/tcc/inc/fwdn/fwupgrade.h             |  178 +
 drivers/block/tcc/inc/fwdn/fwupgrade_NAND_v6.h     |  160 +
 drivers/block/tcc/inc/tnftl/IO_TCCXXX.h            | 3872 +++++
 drivers/block/tcc/inc/tnftl/TC_DRV.h               | 1700 +++
 drivers/block/tcc/inc/tnftl/Typedefine.h           |   52 +
 drivers/block/tcc/inc/tnftl/nand_drv.h             |  283 +
 drivers/block/tcc/inc/tnftl/nand_io_v6.h           |  828 +
 drivers/block/tcc/inc/tnftl/nand_io_v7.h           |  842 ++
 drivers/block/tcc/inc/tnftl/tnftl_v6.h             |  614 +
 drivers/block/tcc/inc/tnftl/tnftl_v7.h             |  656 +
 drivers/block/tcc/init_ddr2.c                      | 1008 ++
 drivers/block/tcc/init_mddr.c                      |  761 +
 drivers/block/tcc/kernel_nand_drv.c                |  685 +
 .../tcc/libtnftl/libtnftl_V6005_TCC8900.o_shipped  |  Bin 0 -> 198915 bytes
 .../tcc/libtnftl/libtnftl_V7003_TCC8900.o_shipped  |  Bin 0 -> 202508 bytes
 drivers/block/tcc/nand_buffer.c                    |   40 +
 drivers/block/tcc/nand_crc.c                       |  193 +
 drivers/block/tcc/nand_drv.c                       | 2117 +++
 drivers/block/tcc/nand_drv_v7.c                    | 2096 +++
 drivers/block/tcc/nand_io_v6.c                     |15833 ++++++++++++++++++++
 drivers/block/tcc/nand_io_v7.c                     |13049 ++++++++++++++++
 drivers/video/tccfb.c                              |    2 +-
 39 files changed, 48074 insertions(+), 1 deletions(-)
 create mode 100644 drivers/block/tcc/Kconfig
 create mode 100644 drivers/block/tcc/Makefile
 create mode 100644 drivers/block/tcc/fwupgrade.c
 create mode 100644 drivers/block/tcc/inc/common.h
 create mode 100644 drivers/block/tcc/inc/config.h
 create mode 100644 drivers/block/tcc/inc/def_tcc.h
 create mode 100644 drivers/block/tcc/inc/fwdn/Disk.h
 create mode 100644 drivers/block/tcc/inc/fwdn/FSAPP.h
 create mode 100644 drivers/block/tcc/inc/fwdn/KFSutils.h
 create mode 100644 drivers/block/tcc/inc/fwdn/TC_File.h
 create mode 100644 drivers/block/tcc/inc/fwdn/browse.h
 create mode 100644 drivers/block/tcc/inc/fwdn/fat.h
 create mode 100644 drivers/block/tcc/inc/fwdn/file.h
 create mode 100644 drivers/block/tcc/inc/fwdn/fwdn_drv_v3.h
 create mode 100644 drivers/block/tcc/inc/fwdn/fwdn_protocol_v3.h
 create mode 100644 drivers/block/tcc/inc/fwdn/fwupgrade.h
 create mode 100644 drivers/block/tcc/inc/fwdn/fwupgrade_NAND_v6.h
 create mode 100644 drivers/block/tcc/inc/tnftl/IO_TCCXXX.h
 create mode 100644 drivers/block/tcc/inc/tnftl/TC_DRV.h
 create mode 100644 drivers/block/tcc/inc/tnftl/Typedefine.h
 create mode 100644 drivers/block/tcc/inc/tnftl/nand_drv.h
 create mode 100644 drivers/block/tcc/inc/tnftl/nand_io_v6.h
 create mode 100644 drivers/block/tcc/inc/tnftl/nand_io_v7.h
 create mode 100644 drivers/block/tcc/inc/tnftl/tnftl_v6.h
 create mode 100644 drivers/block/tcc/inc/tnftl/tnftl_v7.h
 create mode 100644 drivers/block/tcc/init_ddr2.c
 create mode 100644 drivers/block/tcc/init_mddr.c
 create mode 100644 drivers/block/tcc/kernel_nand_drv.c
 create mode 100644 drivers/block/tcc/libtnftl/libtnftl_V6005_TCC8900.o_shipped
 create mode 100644 drivers/block/tcc/libtnftl/libtnftl_V7003_TCC8900.o_shipped
 create mode 100644 drivers/block/tcc/nand_buffer.c
 create mode 100644 drivers/block/tcc/nand_crc.c
 create mode 100644 drivers/block/tcc/nand_drv.c
 create mode 100644 drivers/block/tcc/nand_drv_v7.c
 create mode 100644 drivers/block/tcc/nand_io_v6.c
 create mode 100644 drivers/block/tcc/nand_io_v7.c

diff --git a/drivers/block/Kconfig b/drivers/block/Kconfig
index 0344a8a..6aa4cd5 100644
--- a/drivers/block/Kconfig
+++ b/drivers/block/Kconfig
@@ -446,4 +446,6 @@ config BLK_DEV_HD
 
 	  If unsure, say N.
 
+source "drivers/block/tcc/Kconfig"
+
 endif # BLK_DEV
diff --git a/drivers/block/Makefile b/drivers/block/Makefile
index 204332b..98b42f4 100644
--- a/drivers/block/Makefile
+++ b/drivers/block/Makefile
@@ -32,3 +32,6 @@ obj-$(CONFIG_BLK_DEV_UB)	+= ub.o
 obj-$(CONFIG_BLK_DEV_HD)	+= hd.o
 
 obj-$(CONFIG_XEN_BLKDEV_FRONTEND)	+= xen-blkfront.o
+
+obj-$(CONFIG_TCC_NAND_V6)		+= tcc/
+obj-$(CONFIG_TCC_NAND_V7)		+= tcc/
diff --git a/drivers/block/tcc/Kconfig b/drivers/block/tcc/Kconfig
new file mode 100644
index 0000000..6c3b059
--- /dev/null
+++ b/drivers/block/tcc/Kconfig
@@ -0,0 +1,13 @@
+choice
+	prompt "TCC nand flash support"
+	depends on ARCH_TCC
+	default TCC_NAND_V7
+	---help---
+
+config TCC_NAND_V6
+	tristate "TCC nand flash driver V6"
+
+config TCC_NAND_V7
+	tristate "TCC nand flash driver V7"
+
+endchoice
diff --git a/drivers/block/tcc/Makefile b/drivers/block/tcc/Makefile
new file mode 100644
index 0000000..a30fd89
--- /dev/null
+++ b/drivers/block/tcc/Makefile
@@ -0,0 +1,33 @@
+DEF_NAND := -D_LINUX_
+DEF_NAND += -DUSE_V_ADDRESS
+DEF_NAND += -DNAND_INCLUDE
+DEF_NAND += -DNAND_BOOT_INCLUDE
+DEF_NAND += -D_NAND_DEVICE_CONFIG_
+DEF_NAND += -DINTERNAL_HIDDEN_STORAGE_INCLUDE
+DEF_NAND += -DECC_TEST
+
+ifeq ($(CONFIG_ARCH_TCC8900), y)
+DEF_NAND += -DTCC89XX -DTCC89X -DTCC8900
+TCC_ARCH = TCC8900
+endif
+
+ifneq ($(CONFIG_TCC_NAND_V6),)
+NAND_VER := V6005
+obj-$(CONFIG_TCC_NAND_V6) := $(TCC_ARCH)_nand.o
+$(TCC_ARCH)_nand-objs := nand_drv.o nand_io_v6.o
+endif
+
+ifneq ($(CONFIG_TCC_NAND_V7),)
+NAND_VER := V7003
+DEF_NAND += -DNAND_BOOT_REV
+obj-$(CONFIG_TCC_NAND_V7) := $(TCC_ARCH)_nand.o
+$(TCC_ARCH)_nand-objs := nand_drv_v7.o nand_io_v7.o
+endif
+
+NAND_INC = drivers/block/tcc/inc
+EXTRA_CFLAGS += $(DEF_NAND) -I$(NAND_INC) -I$(NAND_INC)/fwdn -I$(NAND_INC)/tnftl
+
+LIBS = libtnftl/libtnftl_$(NAND_VER)_$(TCC_ARCH).o
+
+$(TCC_ARCH)_nand-objs += kernel_nand_drv.o nand_crc.o nand_buffer.o fwupgrade.o init_ddr2.o init_mddr.o $(LIBS)
+
diff --git a/drivers/block/tcc/fwupgrade.c b/drivers/block/tcc/fwupgrade.c
new file mode 100644
index 0000000..31f893a
--- /dev/null
+++ b/drivers/block/tcc/fwupgrade.c
@@ -0,0 +1,598 @@
+/****************************************************************************
+ *   FileName    : Fwupgrade.c
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+
+#if defined(_LINUX_) || defined(_WINCE_)
+#include <mach/globals.h>
+#include "IO_TCCXXX.h"
+#include "TC_File.h"
+#include "browse.h"
+//#include "fwdn_protocol.h"
+#include "fwupgrade.h"
+//#include "usb.h"
+#include "FSAPP.h"
+#include "nand_drv.h"
+#endif
+
+#if defined (NKUSE)
+#include "windows.h"
+#include "stdlib.h"
+#elif defined (__KERNEL__)
+#include <linux/string.h>
+#endif
+
+//unsigned int	gMAX_ROMSIZE;	//twkwon: Initialize????
+
+#if 0
+const unsigned int CRC32_TABLE[256] = {
+	0x00000000,	0x90910101,	0x91210201,	0x01B00300,
+	0x92410401,	0x02D00500,	0x03600600,	0x93F10701,
+	0x94810801,	0x04100900,	0x05A00A00,	0x95310B01,
+	0x06C00C00,	0x96510D01,	0x97E10E01,	0x07700F00,
+	0x99011001,	0x09901100,	0x08201200,	0x98B11301,
+	0x0B401400,	0x9BD11501,	0x9A611601,	0x0AF01700,
+	0x0D801800,	0x9D111901,	0x9CA11A01,	0x0C301B00,
+	0x9FC11C01,	0x0F501D00,	0x0EE01E00,	0x9E711F01,
+	0x82012001,	0x12902100,	0x13202200,	0x83B12301,
+	0x10402400,	0x80D12501,	0x81612601,	0x11F02700,
+	0x16802800,	0x86112901,	0x87A12A01,	0x17302B00,
+	0x84C12C01,	0x14502D00,	0x15E02E00,	0x85712F01,
+	0x1B003000,	0x8B913101,	0x8A213201,	0x1AB03300,
+	0x89413401,	0x19D03500,	0x18603600,	0x88F13701,
+	0x8F813801,	0x1F103900,	0x1EA03A00,	0x8E313B01,
+	0x1DC03C00,	0x8D513D01,	0x8CE13E01,	0x1C703F00,
+	0xB4014001,	0x24904100,	0x25204200,	0xB5B14301,
+	0x26404400,	0xB6D14501,	0xB7614601,	0x27F04700,
+	0x20804800,	0xB0114901,	0xB1A14A01,	0x21304B00,
+	0xB2C14C01,	0x22504D00,	0x23E04E00,	0xB3714F01,
+	0x2D005000,	0xBD915101,	0xBC215201,	0x2CB05300,
+	0xBF415401,	0x2FD05500,	0x2E605600,	0xBEF15701,
+	0xB9815801,	0x29105900,	0x28A05A00,	0xB8315B01,
+	0x2BC05C00,	0xBB515D01,	0xBAE15E01,	0x2A705F00,
+	0x36006000,	0xA6916101,	0xA7216201,	0x37B06300,
+	0xA4416401,	0x34D06500,	0x35606600,	0xA5F16701,
+	0xA2816801,	0x32106900,	0x33A06A00,	0xA3316B01,
+	0x30C06C00,	0xA0516D01,	0xA1E16E01,	0x31706F00,
+	0xAF017001,	0x3F907100,	0x3E207200,	0xAEB17301,
+	0x3D407400,	0xADD17501,	0xAC617601,	0x3CF07700,
+	0x3B807800,	0xAB117901,	0xAAA17A01,	0x3A307B00,
+	0xA9C17C01,	0x39507D00,	0x38E07E00,	0xA8717F01,
+	0xD8018001,	0x48908100,	0x49208200,	0xD9B18301,
+	0x4A408400,	0xDAD18501,	0xDB618601,	0x4BF08700,
+	0x4C808800,	0xDC118901,	0xDDA18A01,	0x4D308B00,
+	0xDEC18C01,	0x4E508D00,	0x4FE08E00,	0xDF718F01,
+	0x41009000,	0xD1919101,	0xD0219201,	0x40B09300,
+	0xD3419401,	0x43D09500,	0x42609600,	0xD2F19701,
+	0xD5819801,	0x45109900,	0x44A09A00,	0xD4319B01,
+	0x47C09C00,	0xD7519D01,	0xD6E19E01,	0x46709F00,
+	0x5A00A000,	0xCA91A101,	0xCB21A201,	0x5BB0A300,
+	0xC841A401,	0x58D0A500,	0x5960A600,	0xC9F1A701,
+	0xCE81A801,	0x5E10A900,	0x5FA0AA00,	0xCF31AB01,
+	0x5CC0AC00,	0xCC51AD01,	0xCDE1AE01,	0x5D70AF00,
+	0xC301B001,	0x5390B100,	0x5220B200,	0xC2B1B301,
+	0x5140B400,	0xC1D1B501,	0xC061B601,	0x50F0B700,
+	0x5780B800,	0xC711B901,	0xC6A1BA01,	0x5630BB00,
+	0xC5C1BC01,	0x5550BD00,	0x54E0BE00,	0xC471BF01,
+	0x6C00C000,	0xFC91C101,	0xFD21C201,	0x6DB0C300,
+	0xFE41C401,	0x6ED0C500,	0x6F60C600,	0xFFF1C701,
+	0xF881C801,	0x6810C900,	0x69A0CA00,	0xF931CB01,
+	0x6AC0CC00,	0xFA51CD01,	0xFBE1CE01,	0x6B70CF00,
+	0xF501D001,	0x6590D100,	0x6420D200,	0xF4B1D301,
+	0x6740D400,	0xF7D1D501,	0xF661D601,	0x66F0D700,
+	0x6180D800,	0xF111D901,	0xF0A1DA01,	0x6030DB00,
+	0xF3C1DC01,	0x6350DD00,	0x62E0DE00,	0xF271DF01,
+	0xEE01E001,	0x7E90E100,	0x7F20E200,	0xEFB1E301,
+	0x7C40E400,	0xECD1E501,	0xED61E601,	0x7DF0E700,
+	0x7A80E800,	0xEA11E901,	0xEBA1EA01,	0x7B30EB00,
+	0xE8C1EC01,	0x7850ED00,	0x79E0EE00,	0xE971EF01,
+	0x7700F000,	0xE791F101,	0xE621F201,	0x76B0F300,
+	0xE541F401,	0x75D0F500,	0x7460F600,	0xE4F1F701,
+	0xE381F801,	0x7310F900,	0x72A0FA00,	0xE231FB01,
+	0x71C0FC00,	0xE151FD01,	0xE0E1FE01,	0x7070FF00
+};
+#else
+extern const unsigned CRC32_TABLE[];
+#endif
+
+typedef void 	ROM_Upgrade(unsigned char *, unsigned int, unsigned int, unsigned char *); 
+ROM_Upgrade   	*pROMUpgradeFunc;
+
+extern int TCDB_SaveDBHeader(unsigned char ucAssociation, int iPartID);    
+extern void ResetSystem(void);
+
+
+#define		MAXBUFFSIZE 8*1024 // 
+
+extern int		gSDUpgrading;
+
+unsigned char gBuffer[MAXBUFFSIZE];
+
+#if defined(_WINCE_) || defined(_LINUX_)
+///////////////////////////////////////////////////////////////////////////////////
+//
+// Function    : FWUG_GetTempBuffer()
+//
+// Description : Get temporary buffer to store data
+// 
+///////////////////////////////////////////////////////////////////////////////////
+char *FWUG_GetTempBuffer(unsigned int *uiBufSize)
+{
+#if defined (NKUSE) || defined(__KERNEL__)
+	*uiBufSize = MAXBUFFSIZE;
+	return gBuffer;
+#else
+	if (gSDUpgrading == 1)
+	{
+		*uiBufSize = MAXBUFFSIZE;
+		return gBuffer;
+	}
+	else
+	{
+	*uiBufSize	= FSAPP_GetMaxCopySize();
+	return FSAPP_GetFileBuffer();
+	}
+#endif
+}
+
+///////////////////////////////////////////////////////////////////////////////////
+//
+// Function    : FWUG_CheckBattery
+//
+// Description : Check Battery
+// 
+///////////////////////////////////////////////////////////////////////////////////
+int FWUG_CheckBattery()
+{
+#ifdef BATTERY_INCLUDE
+	unsigned int batteryValue = 0;
+	unsigned int Emergencycount = 0;
+	int i;
+	
+	for(i=0; i<20; i++)
+	{
+		batteryValue = BATTERY_GetBatteryVoltage();		
+		if(batteryValue < 110)
+			Emergencycount++;			
+		
+		if(Emergencycount > 10)
+		{
+			SerialWriteString("BAT too low!!");
+			CAPP_ReturnSetClock();	// 20041207
+			return 0;
+		}
+		
+		TC_TimeDly(10);
+	}
+#endif
+	return 1;
+}
+
+#if !defined(__KERNEL__)
+/**************************************************************************
+*  FUNCTION NAME : 
+*      unsigned int		FWUG_CheckROMFileCRC
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*  
+*  OUTPUT:
+*
+*  REMARK  :	
+**************************************************************************/
+unsigned int	FWUG_CheckROMFileCRC(int iFilehandle, unsigned char *buf, unsigned int uiBufSize)
+{
+	unsigned int	i;
+	unsigned int	uiROMFileSize;
+	unsigned int	uiVerifyCRC;
+	unsigned int	uiTempCRC;
+	unsigned int	uiCRCSize;
+	unsigned int	uiCnt;
+	unsigned int	uiMode;
+
+	uiROMFileSize =  0x00;
+	uiVerifyCRC = 0x00;
+	uiTempCRC = 0x00;	
+
+	memset( buf, 0x00, uiBufSize );
+	TC_Read( iFilehandle, buf, 32 );	//header size		
+
+	uiTempCRC |= ( buf[27] & 0x000000FF) << 24;
+	uiTempCRC |= ( buf[26] & 0x000000FF) << 16;
+	uiTempCRC |= ( buf[25] & 0x000000FF) << 8;
+	uiTempCRC |= ( buf[24] & 0x000000FF) ;
+	
+	uiROMFileSize |= ( buf[31] & 0x000000FF) << 24;
+	uiROMFileSize |= ( buf[30] & 0x000000FF) << 16;
+	uiROMFileSize |= ( buf[29] & 0x000000FF) << 8;
+	uiROMFileSize |= ( buf[28] & 0x000000FF) ;		
+
+	TC_Seek( iFilehandle, 0, TC_SEEK_SET );
+	
+	if (uiBufSize < uiROMFileSize )
+	{
+		uiCnt = ( uiROMFileSize + ( uiBufSize - 1)) / uiBufSize;
+		for ( i = 0; i < uiCnt ; i++ )
+		{
+			if ( i == (uiCnt -1 ))
+				uiCRCSize = ( uiROMFileSize  - uiBufSize * (uiCnt - 1));
+			else
+				uiCRCSize = uiBufSize;			
+			
+			TC_Read( iFilehandle, buf, uiCRCSize );
+			
+			if ( i == 0 )
+				uiMode = 1;
+			else
+				uiMode = 2;
+			
+			uiVerifyCRC = CalCRC_ROMFile(buf, uiCRCSize, uiVerifyCRC, uiMode);				
+			
+		}
+	}
+	else
+	{
+		TC_Read( iFilehandle, buf, uiROMFileSize );
+
+		uiMode = 1;
+		uiVerifyCRC = CalCRC_ROMFile( buf, uiROMFileSize, uiVerifyCRC, uiMode);
+	}
+
+	TC_Seek( iFilehandle, 0, TC_SEEK_SET );
+
+	if ( uiTempCRC != uiVerifyCRC ) 
+		return 1;
+	else
+		return SUCCESS;	
+}
+#endif
+
+///////////////////////////////////////////////////////////////////////////////////
+//
+// Function    : FWUG_MainFunc
+//
+// Description : Main function to upgrade Firmware
+// 
+///////////////////////////////////////////////////////////////////////////////////
+#if !defined(__KERNEL__)
+int FWUG_MainFunc(int hFile, int iFileSize)
+#else
+/* if Linux Kernel */
+int FWUG_MainFunc(char *rom_buf, unsigned int uiROMFileSize)
+#endif
+{
+	unsigned int	iRev;	
+	unsigned int   	uiBufSize;
+	unsigned char 	*buf;	
+
+	unsigned int	i;
+	unsigned int	uRemainSize, uReadSize;
+	unsigned int 	dwBlockOffSet, dwPageOffSet;
+	unsigned int 	nStBlockOffSet, nStPageOffSet;
+	unsigned char	GMC_Num;
+	unsigned char	FlagofNewSizeBigger;
+	unsigned int	nSecureMode = DISABLE;
+
+#if !defined(__KERNEL__)
+	unsigned int	uiROMFileSize;
+	unsigned int iFilehandle;
+	#if defined(NKUSE)
+	iFilehandle = TC_Open((char*)hFile, NULL, NULL, NULL);
+#else
+	    iFilehandle = hFile;
+	#endif
+#else
+	unsigned int	rom_offset;
+#endif
+
+	//===============================================================
+	//	Check condition for FW Upgrade
+	//===============================================================
+	if((buf = FWUG_GetTempBuffer(&uiBufSize))==0)
+	{
+		return ERR_FWUG_NOT_EXISTMEMORY;
+	}
+
+#if !defined(__KERNEL__)
+/* if Linux Kernel, already crc checked in tccbox */
+	iRev = FWUG_CheckROMFileCRC( iFilehandle, buf, uiBufSize );
+	if ( iRev != SUCCESS )
+	{
+		return -1;
+	}		
+#endif
+
+	if(!FWUG_CheckBattery())
+	{
+		return ERR_FWUG_FAIL_BATCHECK;
+	}
+
+	//===============================================================
+	//	UPGRADE - NANDFLASH
+	//===============================================================
+
+	/* Setting Intial Parameters */
+#if !defined(__KERNEL__)
+	uiROMFileSize = TC_Length(iFilehandle);
+#endif
+	
+	#ifdef TNFTL_V7_INCLUDE
+	FWUG_NAND_SetEnableNandBootOnlyMode( ENABLE );
+	FWUG_NAND_SetNBAreaEndPBAdd(TNFTL_MAX_BLOCK_NUM_OF_NBAREA);		// Physical Block Num
+	#endif
+
+	#if defined(FWUG_V2_INCLUDE)
+	nSecureMode		= FWUG_NAND_GetFlagOfUseSecureMode();
+	#endif
+
+	/* PreProcess before write code */
+	if (( iRev = FWUG_NAND_PreProcess( uiROMFileSize, &FlagofNewSizeBigger )) != SUCCESS )
+	{
+		goto FWUG_FAIL;
+	}
+
+
+	/* Write CODE Data */
+	for ( i = 0 ; i < 2; ++i )
+	{
+		uRemainSize = uiROMFileSize;
+#if !defined(__KERNEL__)
+		TC_Seek( iFilehandle, 0, TC_SEEK_SET );
+#else
+		rom_offset = 0;
+#endif
+
+		if ( FlagofNewSizeBigger == TRUE )
+			GMC_Num = ( i == 0 ) ? FIRST : SECOND;
+		else
+			GMC_Num = ( i == 0 ) ? SECOND : FIRST;
+
+		#if defined(FWUG_V1_INCLUDE)
+		if (( iRev = FWUG_NAND_WriteCodePreProcess( GMC_Num, uiROMFileSize, &nStBlockOffSet, &nStPageOffSet )) != SUCCESS )
+		#elif defined(FWUG_V2_INCLUDE)
+		if (( iRev = FWUG_NAND_WriteCodePreProcess( GMC_Num, uiROMFileSize, &nStBlockOffSet, &nStPageOffSet, nSecureMode )) != SUCCESS )
+		#endif
+		{
+			goto FWUG_FAIL;
+		}
+
+		while ((int)uRemainSize > 0)
+		{
+			uReadSize = ( uRemainSize >= uiBufSize ) ? uiBufSize : uRemainSize;
+#if !defined(__KERNEL__)
+			uReadSize = TC_Read( iFilehandle, buf, uReadSize );
+#else
+			memcpy(buf, rom_buf + rom_offset, uReadSize);
+			rom_offset += uReadSize;
+#endif
+			
+#ifdef TNFTL_V7_INCLUDE
+			if (( iRev = FWUG_NAND_WriteCodeNAND( GMC_Num, nStBlockOffSet, nStPageOffSet, buf, uReadSize, &dwBlockOffSet, &dwPageOffSet, nSecureMode )) != SUCCESS )
+#else
+			if (( iRev = FWUG_NAND_WriteCodeNAND( nStBlockOffSet, nStPageOffSet, buf, uReadSize, &dwBlockOffSet, &dwPageOffSet, nSecureMode )) != SUCCESS )
+#endif
+			{
+				goto FWUG_FAIL;
+			}
+			nStBlockOffSet = dwBlockOffSet;
+			nStPageOffSet  = dwPageOffSet;
+			uRemainSize	-= uReadSize;
+		}
+
+		if (( iRev = FWUG_NAND_WriteCodePostProcess( GMC_Num, nStBlockOffSet, nStPageOffSet )) != SUCCESS )
+		{
+			goto FWUG_FAIL;
+		}
+	}
+
+	/* PostProcess after write code */
+	if (( iRev = FWUG_NAND_PostProcess((void*)0, TRUE, nSecureMode )) != SUCCESS )
+	{
+		goto FWUG_FAIL;
+	}
+
+	//===============================================================
+	//	CLOSE
+	//===============================================================
+#if !defined(__KERNEL__)
+#if defined(NKUSE)
+	TC_Close(iFilehandle);
+#endif
+#endif
+
+	if (TC_ISERR(iRev))
+	{
+		return -1;
+	}
+
+	return SUCCESS;
+
+FWUG_FAIL:
+	return iRev;
+}
+
+#endif
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      unsigned int FWUG_CalcCrc(unsigned int *base, unsigned int length, unsigned int *crctable);
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			base	= 
+*			crctable	= 
+*			length	= 
+*  
+*  OUTPUT:	int - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+unsigned int FWUG_CalcCrc(unsigned int *base, unsigned int length, unsigned int *crctable)
+{
+	unsigned int crcout = 0;
+	unsigned int cnt, i, code, tmp;
+	
+	for(cnt=0; cnt<length; cnt++)
+	{
+		code = base[cnt];
+		for(i=0; i<4; i++)
+		{
+			tmp = code^crcout;
+			crcout = (crcout>>8)^crctable[tmp&0xFF];
+			code = code >> 8;
+		}
+	}
+	return crcout;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      unsigned int FWUG_CalcCrc8(unsigned char *base, unsigned int length, unsigned int *crctable);
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			base	= 
+*			crctable	= 
+*			length	= 
+*  
+*  OUTPUT:	int - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+unsigned int FWUG_CalcCrc8(unsigned char *base, unsigned int length, const unsigned int *crctable)
+{
+	unsigned int crcout = 0;
+	unsigned int cnt; 
+	unsigned char	code, tmp;
+	
+	for(cnt=0; cnt<length; cnt++)
+	{
+		code = base[cnt];
+		tmp = code^crcout;
+		crcout = (crcout>>8)^crctable[tmp&0xFF];
+	}
+	return crcout;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      unsigned int FWUG_CalcCrcI(unsigned uCRCIN, unsigned *base, unsigned int length, unsigned int *crctable);
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			base	= 
+*			crctable	= 
+*			length	= 
+*  
+*  OUTPUT:	int - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+unsigned int FWUG_CalcCrcI(unsigned uCRCIN, unsigned *base, unsigned int length, unsigned int *crctable)
+{
+	unsigned int crcout = uCRCIN;
+	unsigned int cnt, i, code, tmp;
+
+	for(cnt=0; cnt<length; cnt++)
+	{
+		code = base[cnt];
+		for(i=0; i<4; i++)
+		{
+			tmp = code^crcout;
+			crcout = (crcout>>8)^crctable[tmp&0xFF];
+			code = code >> 8;
+		}
+	}
+	return crcout;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      unsigned int FWUG_CalcCrc8I(unsigned uCRCIN, unsigned char *base, unsigned int length, unsigned int *crctable);
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			base	= 
+*			crctable	= 
+*			length	= 
+*  
+*  OUTPUT:	int - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+unsigned int FWUG_CalcCrc8I(unsigned uCRCIN, unsigned char *base, unsigned int length, unsigned int *crctable)
+{
+	unsigned int crcout = uCRCIN;
+	unsigned int cnt; 
+	unsigned char	code, tmp;
+
+	for(cnt=0; cnt<length; cnt++)
+	{
+		code = base[cnt];
+		tmp = code^crcout;
+		crcout = (crcout>>8)^crctable[tmp&0xFF];
+	}
+	return crcout;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      unsigned int CalCRC_ROMFile(unsigned int *pBuffer,unsigned int size,unsigned int crcout, unsigned int mode);
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			crcout	= 
+*			mode	= 
+*			pBuffer	= 
+*			size	= 
+*  
+*  OUTPUT:	int - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+unsigned int CalCRC_ROMFile(unsigned int *pBuffer,unsigned int size,unsigned int crcout, unsigned int mode)
+{
+
+	unsigned int cnt, i, code, tmp;
+	unsigned int CrcRegion;
+
+
+	CrcRegion = (size>>2);
+
+	for(cnt=0; cnt<CrcRegion; cnt++)
+	{
+		code = pBuffer[cnt];
+		if(mode==0 || mode==1)
+		{
+			if(cnt == 4 || cnt == 5)
+			{
+				continue;
+			}
+		}
+		if(mode==1)
+		{
+			if(cnt==6)
+			{
+				code = 0x00000000;
+			}
+		}
+		
+	
+		for(i=0; i<4; i++)
+		{
+			tmp = code^crcout;
+			crcout = (crcout>>8)^CRC32_TABLE[tmp&0xFF];
+			code = code >> 8;
+		}
+	}
+	
+	return crcout;
+} 
+
+/************* end of file *************************************************************/
diff --git a/drivers/block/tcc/inc/common.h b/drivers/block/tcc/inc/common.h
new file mode 100644
index 0000000..d15bfd8
--- /dev/null
+++ b/drivers/block/tcc/inc/common.h
@@ -0,0 +1,23 @@
+#ifndef __COMMON_H__
+#define __COMMON_H__
+
+#include <config.h>
+
+#if defined(TCC8900)
+#include <mach/TCC89x_Physical.h>
+#include <mach/TCC89x_Structures.h>
+#else
+#error "Not defined Chips..."
+#endif
+
+#include <mach/globals.h>
+
+/*
+ * Macro
+ */
+#define read_reg(a)         (*(volatile unsigned long *)a)
+#define write_reg(v, a)     (*(volatile unsigned long *)a = v)
+
+
+#endif	/* __COMMON_H__ */
+
diff --git a/drivers/block/tcc/inc/config.h b/drivers/block/tcc/inc/config.h
new file mode 100644
index 0000000..fd48ceb
--- /dev/null
+++ b/drivers/block/tcc/inc/config.h
@@ -0,0 +1,56 @@
+/***************************************************************************************
+*	FileName    : config.h
+*	Description : NAND Configuration File
+****************************************************************************************
+*
+*	TCC Board Support Package
+*	Copyright (c) Telechips, Inc.
+*	ALL RIGHTS RESERVED
+*
+****************************************************************************************/
+
+
+#ifndef __CONFIG_H__
+#define __CONFIG_H__
+
+#include <def_tcc.h>
+#include <mach/ddr.h>
+
+/***************************************************************************************
+* TCC8900 specific config
+****************************************************************************************/
+#if defined(TCC8900)
+
+#define TCC_ARCH "TCC8900"
+
+#if defined(_BOARD_VERSION_TCC8900_WINCE_LINUX_DEMO_V01_)
+#define TCC_BOARD "TCC8900_WINCE_LINUX_DEMO_V0.1"
+#endif
+
+/***************************************************************************************
+* ERROR: Undefined target
+****************************************************************************************/
+#else
+	#error "Undefined Target"
+#endif
+
+
+/***************************************************************************************
+* ETC.
+****************************************************************************************/
+/*---------------------------------
+ * DRIVER TYPE
+ *---------------------------------
+ */
+#define KERNEL_DRIVER				/* kernel module driver */
+
+
+/*---------------------------------
+ * Default
+ *---------------------------------
+ */
+#define PRINTF printk
+
+
+#endif	/* __CONFIG_H__ */
+/************* end of file *************************************************************/
diff --git a/drivers/block/tcc/inc/def_tcc.h b/drivers/block/tcc/inc/def_tcc.h
new file mode 100644
index 0000000..b0e5d0d
--- /dev/null
+++ b/drivers/block/tcc/inc/def_tcc.h
@@ -0,0 +1,6 @@
+#ifdef NAND_BOOT_REV
+#define NAND_VER "V7003"
+#else
+#define NAND_VER "V6005"
+#endif
+
diff --git a/drivers/block/tcc/inc/fwdn/Disk.h b/drivers/block/tcc/inc/fwdn/Disk.h
new file mode 100644
index 0000000..4bff8ef
--- /dev/null
+++ b/drivers/block/tcc/inc/fwdn/Disk.h
@@ -0,0 +1,313 @@
+/****************************************************************************
+ *   FileName    : Disk.h
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+#ifndef __DISK_H__
+#define __DISK_H__
+
+/*******************************************************************************
+ * DISK Interface Error Code Macro
+ ******************************************************************************/
+#define 	_ERR(x)			(0x80000000 | (x))
+#define		ENOTSUPPORT		_ERR(0x10)		// Function does not support
+#define		EINITFAIL 		_ERR(0x11)		// Device Initialization Failed
+
+/*****************************************************************************
+ *	disk device type enumeration value
+ *****************************************************************************/
+typedef enum
+{
+	DISK_DEVICE_HDD=0,
+	DISK_DEVICE_NAND,
+	DISK_DEVICE_NAND_HD,
+	DISK_DEVICE_UHP,
+	DISK_DEVICE_TRIFLASH,
+	DISK_DEVICE_MMC,
+	DISK_DEVICE_MS,
+	DISK_DEVICE_TRIFLASH_HD,
+	#ifdef EXTERNAL_HIDDEN_STORAGE_INCLUDE
+		DISK_DEVICE_MMC_HD,
+	#endif
+	MAX_DEVICE_NUM
+}DISK_DEVICE;
+
+#define DISK_DEVICE_INTERNAL 1
+
+/*****************************************************************************
+ *	disk device property and sub-property enumeration value
+ *****************************************************************************/
+typedef enum
+{
+	DISK_DEVICE_UNLOCK=0,
+	DISK_DEVICE_LOCK
+}DISK_LOCK_FLAG;
+
+typedef enum
+{
+	DISK_STATE_NOTMOUNTED,
+	DISK_STATE_MOUNTSUCCEED,
+	DISK_STATE_MOUNTERR
+}DISK_MOUNT_STATE;
+
+typedef enum	
+{
+	DISK_STATE_FREE,
+	DISK_STATE_BUSY
+}DISK_BUSY_STATE;
+
+typedef enum	
+{
+	DISK_STATE_INIT,
+	DISK_STATE_POWERON,
+	DISK_STATE_POWEROFF,
+	DISK_STATE_STANDBY,
+	DISK_STATE_IDLE,
+	DISK_STATE_SLEEP,
+	DISK_STATE_RESET
+}DISK_POWER_STATE;
+
+typedef enum
+{
+	DISK_MSC_DRV_NOT_SUPPORT,
+	DISK_MSC_DRV_SUPPORT
+}DISK_MSC_DRV_STATE;
+
+typedef enum
+{
+	DISK_MOUNT_TYPE_INTERNAL,
+	DISK_MOUNT_TYPE_EXTERNAL,
+	DISK_MOUNT_TYPE_MAXIUM
+}DISK_MOUNT_TYPE_STATE;
+
+typedef	struct
+{
+	const char				*Name;
+	DISK_LOCK_FLAG			LockFlag;
+	DISK_DEVICE				DiskType;
+	DISK_MOUNT_STATE		MountState;
+	DISK_BUSY_STATE			BusyState;
+	DISK_MSC_DRV_STATE		MSCDrvSupport;
+	DISK_MOUNT_TYPE_STATE	DrvMountType;
+	int						PartitionIndex;
+}DISK_PROPERTY;
+
+/*******************************************************************************
+ * DISK Interface Function Type Definitions
+ ******************************************************************************/
+typedef int (*tDeviceRwFunctions)(int, unsigned long, unsigned short, void *);
+
+typedef int (*tDeviceWriteMultiStartFunctions)(unsigned long, unsigned long);
+typedef int (*tDeviceWriteMultiFunctions)(int, unsigned long, unsigned short, void *);
+typedef int (*tDeviceWriteMultiStopFunctions)(void);
+
+typedef int (*tDeviceReadMultiStartFunctions)(unsigned long, unsigned long);
+typedef int (*tDeviceReadMultiFunctions)(int, unsigned long, unsigned short, void *);
+typedef int (*tDeviceReadMultiStopFunctions)(void);
+
+typedef unsigned long (*tDeviceHiddenRWFunctions)(unsigned long , unsigned short, unsigned char *);
+typedef int (*tDeviceHiddenClearPageFunctions)(unsigned long , unsigned long);
+
+typedef int (*tDeviceIoctlFunctions)(int, void *);
+
+/*******************************************************************************
+ * DISK Interface Function Definitions
+ ******************************************************************************/
+typedef struct DeviceDriverStruct
+{
+	DISK_PROPERTY						Property;
+	tDeviceRwFunctions 					ReadSector;
+	tDeviceRwFunctions 					WriteSector;
+	tDeviceReadMultiStartFunctions		ReadMultiStart;
+	tDeviceReadMultiFunctions			ReadMultiSector;
+	tDeviceReadMultiStopFunctions		ReadMultiStop;
+	tDeviceWriteMultiStartFunctions		WriteMultiStart;
+	tDeviceWriteMultiFunctions			WriteMultiSector;
+	tDeviceWriteMultiStopFunctions		WriteMultiStop;
+	tDeviceHiddenRWFunctions			HDReadSector;
+	tDeviceHiddenRWFunctions			HDWriteSector;
+	tDeviceHiddenClearPageFunctions		HDClearSector;
+	tDeviceIoctlFunctions 				Ioctl;
+}tDeviceDriver;
+
+/*******************************************************************************
+ * DISK Ioctl Function List ( Enumeration Value )
+ *
+ * 		DEV_INITIALIZE
+ * 		Initialize Variable , Register and Hardware
+ *
+ * 		DEV_GET_DISKINFO
+ * 		Get the environmant variables like head, cylinder, sector ...
+ *
+ * 		DEV_FORMAT_DISK
+ * 		low level format command ( if it necessary )
+ * 		
+ * 		DEV_ERASE_INIT
+ * 		prepare erasing command
+ *
+ * 		DEV_ERASE_BLOCK
+ * 		erase sector command
+ *
+ * 		DEV_ERASE_CLOSE
+ * 		finish erasing command
+ *
+ * 		DEV_WRITEBACK_ON_IDLE
+ * 		flush data cache command while system is in idle state
+ ******************************************************************************/
+
+#define	YES					1
+#define	NO					0
+
+#define	TC_LOWLEVEL_YES		1
+#define	TC_LOWLEVEL_NO		0
+
+/*******************************************************************************
+ * DISK Ioctl DEV_GET_DISKINFO Function Parameter structure
+ ******************************************************************************/
+typedef struct ioctl_diskinfo_t
+{
+	unsigned short	head;
+	unsigned short	cylinder;
+	unsigned short	sector;
+	unsigned short	sector_size;
+	unsigned int	Total_sectors;	
+}ioctl_diskinfo_t;
+
+/*******************************************************************************
+ * DISK Ioctl DEV_ERASE_INIT Function Parameter structure
+ ******************************************************************************/
+typedef struct ioctl_diskeraseinit_t
+{
+	unsigned short		sector_per_cluster;
+	unsigned long		data_start_sector;
+}ioctl_diskeraseinit_t;
+
+/*******************************************************************************
+ * DISK Ioctl DEV_ERASE_BLOCK Function Parameter structure
+ ******************************************************************************/
+typedef struct ioctl_diskerase_t
+{
+	unsigned long	current_cluster;
+	unsigned long	content_fat;
+}ioctl_diskerase_t;
+
+/*******************************************************************************
+ * DISK Ioctl DEV_HIDDEN_CLEAR_PAGE Function Parameter structure
+ ******************************************************************************/
+// typedef struct ioctl_diskhdclear_t {
+// 	unsigned long	start_page;
+// 	unsigned long	end_page;
+// }ioctl_diskhdclear_t;
+
+/*******************************************************************************
+ * DISK Ioctl DEV_HIDDEN_READ/WRITE_PAGE Function Parameter structure
+ ******************************************************************************/
+typedef struct ioctl_diskhdread4_t
+{
+	unsigned long	start_page;
+	unsigned long	page_offset;
+	unsigned long	read_size;
+	unsigned char	*buff;
+}ioctl_diskhdread4_t;
+
+/*******************************************************************************
+ * DISK Ioctl DEV_BOOTCODE_READ/WRITE_PAGE Function Parameter structure
+ ******************************************************************************/
+typedef struct ioctl_diskrwpage_t
+{
+	unsigned long	start_page;
+	unsigned long	rw_size;
+	unsigned char	*buff;
+}ioctl_diskrwpage_t;
+
+
+
+
+/*******************************************************************************
+ * DISK Interface Function Definitions
+ ******************************************************************************/
+
+int		DISK_FindDisk(int drv_type);
+int		DISK_ReadSector(int drv_type, int lun, unsigned long lba_addr, unsigned short nSector, void *buff);
+int		DISK_WriteSector(int drv_type, int lun, unsigned long lba_addr, unsigned short nSector, void *buff);
+
+int		DISK_ReadMultiStart(int drv_type, int lba_addr, int size);
+int		DISK_ReadMultiSector(int drv_type, int lun, unsigned long lba_addr, unsigned short nSector, void *buff);
+int		DISK_ReadMultiStop(int drv_type);
+
+int		DISK_WriteMultiStart(int drv_type, int lba_addr, int size);
+int		DISK_WriteMultiSector(int drv_type, int lun, unsigned long lba_addr, unsigned short nSector, void *buff);
+int		DISK_WriteMultiStop(int drv_type);
+
+int		DISK_HDReadSector(unsigned int drv_type, unsigned long page_addr, unsigned short count, unsigned char *buff);
+int		DISK_HDWriteSector(unsigned int drv_type,  unsigned long page_addr, unsigned short count, unsigned char *buff);
+int		DISK_HDClearSector(unsigned int drv_type, unsigned long start_page_addr, unsigned long end_page_addr);
+
+int		DISK_Ioctl(unsigned int drv_type, int function, void *param);
+int		DISK_GetTotalDiskCount(void);
+int 	DISK_GetDiskType(int index);
+int 	DISK_GetDiskTypeByPartID(int PartID );
+int		DISK_GetSupportMSCDrive(int index );
+int		DISK_GetDiskMountType(int index );
+int		DISK_SetState(DISK_DEVICE disk,	DISK_MOUNT_STATE state);
+int		DISK_GetState(DISK_DEVICE disk);
+int		DISK_SetDiskPartitionIndex(DISK_DEVICE disk, int index);
+int		DISK_GetDiskPartitionIndex(DISK_DEVICE disk);
+int		DISK_SetBusyState(DISK_DEVICE disk, DISK_BUSY_STATE busyFlag);
+int		DISK_GetBusyState(DISK_DEVICE disk);
+
+extern unsigned char *DISK_GetDeviceName(DISK_DEVICE disk);
+extern unsigned int DISK_GetDeviceStatus(int iDeviceNum,int iUSBMode,int iExtDevice);
+
+
+/*******************************************************************************
+ * DISK List Array pre-definition ( in disk.c)
+ ******************************************************************************/
+extern tDeviceDriver DiskList[];
+extern const unsigned int DISK_DefaultDriveType;
+
+typedef enum
+{
+	/* Do Not Change below functions*/
+	DEV_INITIALIZE	=	0,
+	DEV_MOUNT,
+	DEV_GET_DISKINFO,
+	DEV_FORMAT_DISK,
+	DEV_ERASE_INIT,
+	DEV_ERASE_BLOCK,
+	DEV_ERASE_CLOSE,
+	DEV_WRITEBACK_ON_IDLE,
+	/* You can add new function from here */
+	DEV_HIDDEN_READ_PAGE_4,
+	DEV_GET_MAXMULTISECTOR,
+	DEV_SET_POWER,
+	DEV_GET_POWER,
+	DEV_BOOTCODE_READ_PAGE,
+	DEV_BOOTCODE_WRITE_PAGE,
+	DEV_SERIAL_PROCESS,
+	DEV_GET_MAX_SECTOR_PER_BLOCK,
+	DEV_GET_INSERTED,
+	DEV_GET_INITED,
+	DEV_GET_WRITE_PROTECT,
+	DEV_SET_REMOVED,
+	DEV_GET_PREV_STATUS,
+	DEV_GET_PLAYABLE_STATUS,
+	DEV_STOP_TRANSFER,
+	DEV_TELL_DATASTARTSECTOR,
+	DEV_CHECK_CRC_NANDBOOT_IMAGE_ROM,
+	DEV_GET_HIDDEN_SIZE,
+	DEV_GET_SUPPORT_FAT_FORMAT,		/* [1429] */
+	DEV_FORCE_FLUSH_CACHE_DATA,
+	DEV_SET_ALIGEN_CACHE,
+	DEV_SET_MULTISECTOR,			// twkwon: Han DR
+	DEV_END_OF_FUNCTION
+}IOCTL_FUNCTIONS;
+
+#endif	// __DISK_H__
+/* end of file */
+
diff --git a/drivers/block/tcc/inc/fwdn/FSAPP.h b/drivers/block/tcc/inc/fwdn/FSAPP.h
new file mode 100644
index 0000000..a5c871f
--- /dev/null
+++ b/drivers/block/tcc/inc/fwdn/FSAPP.h
@@ -0,0 +1,125 @@
+/*****************************************************************************/
+// File System refer for K-FileSystem
+//	FSAPP.C
+//	Copyright	2003				Telechips, Inc.
+//
+// 2004. 06. 4
+/*****************************************************************************/
+#ifndef __FSAPP_H__
+#define __FSAPP_H__
+
+#if defined(_LINUX_)
+#include <fwdn/file.h>
+#include <fwdn/Disk.h>
+#elif defined(_WINCE_)
+#include "file.h"
+#include "Disk.h"
+#endif
+
+#ifndef CLEAR
+#define CLEAR				0
+#endif
+#ifndef DIRTY
+#define DIRTY				1
+#endif
+
+//=============================================================================
+//*
+//*
+//*                       [ EXTERNAL DEFINATION ]
+//*
+//*
+//=============================================================================
+#define					_NOTMUSICFILE				-1
+//	DEFINITION FOR MAXIMUM HANDLE OF FILES OR DIRECTORIES
+#define					MAX_HANDLE					5
+#define					MAX_FD						MAX_HANDLE
+#define					MAX_DIR						2
+//	DEFAULT FILE FORMAT
+#define					DEFAULT_ROOT_ENTRY_COUNT	512		// normal number of the root entry count
+#define					HIDDEN_SIZE					31		// NAND, UFD etc... But NOT HDD
+
+#define					ENTRY_SIZE					32    // 1 entry size [byte]
+#define					ENTRY_CHUNK					11
+#define					ENTRY_BUFFER_SIZE			(ENTRY_CHUNK * ENTRY_SIZE)
+
+#define					FSAPP_MAX_PART_NUMBER		10		//driveInfo[FSAPP_MAX_PART_NUMBER] / physicalDrvType[FSAPP_MAX_PART_NUMBER]
+
+//=============================================================================
+//*
+//*
+//*                       [ EXTERNAL VARIABLE DEFINE ]
+//*
+//*
+//=============================================================================
+
+extern int				totalHdlr;
+extern int				gDiskIdleTime;
+
+extern FDstruc			fd[MAX_FD];
+extern HANDLERstruc		fhandler[MAX_HANDLE];
+extern FDIRENTstruc		fdir[MAX_DIR];
+extern unsigned char	physicalDrvType[FSAPP_MAX_PART_NUMBER];
+
+//=============================================================================
+//*
+//*
+//*                       [ FUCTIONS DEFINE ]
+//*
+//*
+//=============================================================================
+extern void				FAT_InitDriveInfo( void );
+extern int				FAT_InitFS( void );
+extern void				FAT_InitVariable( void );
+extern int				FAT_MountDrive(int drvTypeID, unsigned int lun);
+extern int				FAT_UnmountDrive(int drvTypeID);
+extern void				FAT_InitializeForFlexibility(unsigned char valueOfHandle, unsigned char *entryBufferPointer, HANDLERstruc *fhandlerStruc,
+													unsigned char valueOfFd, FDstruc *fdStruc, unsigned char valueOfDir, FDIRENTstruc *fdirStruc);
+
+extern int 				FSAPP_InitDiskDevice( int DeviceID );
+extern int  			FSAPP_GetMaxCopySize( void );
+extern unsigned char 	*FSAPP_GetFileBuffer( void );
+extern void				FSAPP_InitializeFS( void );
+extern unsigned long	FSAPP_GetDiskSector( unsigned char drvType, DISKINFOstruc *disk );
+
+extern int				FSAPP_Get_part_id(unsigned char drvType, unsigned char mount);
+
+extern int				FSAPP_disk_RWsector(int drvTypeID, unsigned char drv_num,unsigned long LBA_addr, unsigned short nSector, void *buff, unsigned char RWflag);
+extern int				FSAPP_diskIoctl_DEV_GET_MAXMULTISECTOR(int drvTypeID, unsigned short *nSector);
+extern int				FSAPP_diskIoctl_DEV_ERASE_INIT(int drvTypeID, unsigned char secPerClus, unsigned long dataStartSec);
+extern int				FSAPP_diskIoctl_DEV_ERASE_BLOCK(int drvTypeID, unsigned long currCluster, unsigned long contentFAT);
+extern int				FSAPP_diskIoctl_DEV_ERASE_CLOSE(int drvTypeID);
+extern int				FSAPP_diskIoctl_DEV_SET_MULTISECTOR(int drvTypeID, unsigned short *max_multi_sector);
+extern int				FSAPP_diskIoctl_DEV_TELL_DATASTARTSECTOR(int drvTypeID, unsigned long int data_start_sector);
+extern int				FSAPP_diskIoctl_DEV_GET_MAX_SECTOR_PER_BLOCK(int drvTypeID, unsigned short int *SpB);
+extern int				FSAPP_diskIoctl_DEV_STOP_TRANSFER(int drvTypeID);
+
+extern int				FSAPP_DISK_WriteMultiStart(int drvTypeID, int lba_addr, int size);
+extern int				FSAPP_DISK_WriteMultiSector(int drvTypeID, int lun, unsigned long lba_addr, unsigned short nSector, void *buff);
+extern int				FSAPP_DISK_ReadMultiStart(int drvTypeID, int lba_addr, int size);
+extern int				FSAPP_DISK_ReadMultiSector(int drvTypeID, int lun, unsigned long lba_addr, unsigned short nSector, void *buff);
+extern int				FSAPP_DISK_ReadMultiStop(int drvTypeID);
+extern int				FSAPP_DISK_WriteMultiStop(int drvTypeID);
+
+extern int				FSAPP_physicalStorage_HDD(int drvTypeID);
+
+extern int				FSAPP_ReadSector_Common(int drvTypeID, int lun, unsigned long lba_addr, unsigned short nSector, void *buff);
+extern int				FSAPP_WriteSector_Common(int drvTypeID, int lun, unsigned long lba_addr, unsigned short nSector, void *buff, unsigned char FormatFlag);
+
+extern int				FSAPP_getUsedClus_PS(int drvTypeID, int partID, unsigned FAT1_PhySector, unsigned short nSector);
+extern int				FSAPP_cleanFATcache_PS(int drvTypeID, int partID, unsigned long FAT2_PhySector, unsigned long FAT_Sector, unsigned char *sbuffer);
+extern int				FSAPP_changeFATcache_PS(int drvTypeID, int partID, unsigned long FAT1_PhySector, unsigned int Offset_Sector, unsigned char *fatBuff);
+extern int				FSAPP_fatWriteClus_PS(int drvTypeID, unsigned short nCount, unsigned long sector_addr, unsigned short nSector, unsigned short multi_sector, int multi_byte, unsigned char *temp_buff);
+extern unsigned int		FSAPP_FormatClear_PS(int drvTypeID, unsigned long sectorPerFAT, unsigned int nSector, unsigned char *pBuff, void *SecBuff);
+extern unsigned int		FSAPP_FormatDrive( DISK_DEVICE diskDevice, unsigned int *multiPartition_SectorSize);
+extern int				FSAPP_FormatRootEntry_PS(int drvTypeID, int halfEntryNum, unsigned nSector, unsigned char writeVolume, void *pBuff, unsigned char *BS_VolLab);
+extern unsigned int		FSAPP_decide_MakeMBR(int drvTypeID, unsigned char SecPerClus, unsigned int *Partition, void *pBuff, struct _DISK_INFO *disk);
+extern unsigned char	FSAPP_decide_DrvNum(int drvTypeID);
+extern int				Initialize_FileSystem(DISK_DEVICE mDeviceNum, int partID);
+
+
+
+extern unsigned char	*FSAPP_SetVolumeLabel(unsigned int partID, void* VolLab);
+extern unsigned char	*FSAPP_GetVolumeLabel(unsigned int partID);
+
+#endif
diff --git a/drivers/block/tcc/inc/fwdn/KFSutils.h b/drivers/block/tcc/inc/fwdn/KFSutils.h
new file mode 100644
index 0000000..9dd3f77
--- /dev/null
+++ b/drivers/block/tcc/inc/fwdn/KFSutils.h
@@ -0,0 +1,23 @@
+
+/****************************************************************************
+ *   FileName    : KFSutils.h
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/   
+
+
+extern char upperChar(char ch);
+extern char lowerChar(char ch);
+extern int printNum(char *sNum, int value);
+extern int str_cmp(void *sA, void *sB);
+extern int str_cmp16(void *sA, void *sB);
+extern int str_len(void *pStr);
+extern int mem_cmp(void *sA, void *sB, int len);
+extern void* mem_cpy(void *pDes, void *pSrc, long size);
+extern void* mem_cpyw(void *pDes, void *pSrc, long size);
+extern void* mem_set(void *pDes, unsigned char value, long size);
diff --git a/drivers/block/tcc/inc/fwdn/TC_File.h b/drivers/block/tcc/inc/fwdn/TC_File.h
new file mode 100644
index 0000000..9c4d7b2
--- /dev/null
+++ b/drivers/block/tcc/inc/fwdn/TC_File.h
@@ -0,0 +1,164 @@
+/****************************************************************************
+ *   FileName    : TC_File.h
+ *   Description : File System Abstraction Layer
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+
+#ifndef	__TC_File_H__
+#define	__TC_File_H__ 
+
+#if defined(_LINUX_)
+	#include <fwdn/file.h>
+	#include <fwdn/Disk.h>
+#elif defined(_WINCE_)
+	#include "file.h"
+	#include "Disk.h"
+#endif
+
+#ifndef _UINT8_
+	#define _UINT8_
+	typedef unsigned char UINT8;
+#endif
+
+typedef	int	TC_STAT;
+typedef	unsigned long long	TC_U64;
+typedef	unsigned int		TC_U32;
+typedef	unsigned short		TC_U16;
+typedef	unsigned char		TC_U8;
+
+typedef	signed long long	TC_S64;
+typedef	signed int			TC_S32;
+typedef	signed short		TC_S16;
+typedef	signed char			TC_S8;
+
+typedef	char *			TC_STR8;
+#ifndef _CHAR_
+	#define _CHAR_
+	typedef char CHAR;
+#endif
+
+typedef struct {
+	unsigned char	second;
+	unsigned char	minute;
+	unsigned char	hour;
+	unsigned char	day;
+	unsigned char	date;
+	unsigned char	month;
+	unsigned short	year;
+} TC_DATETIME;
+
+
+typedef unsigned long		_dev_t;
+typedef unsigned short		_ino_t;
+typedef long				_off_t;
+typedef unsigned long		_mode_t;
+typedef unsigned long		_time_t;
+
+typedef struct// _stat
+{
+	_dev_t			st_dev;			/* device */
+	_ino_t			st_ino;			/* inode */
+	_mode_t			st_mode;		/* protection */
+	short			st_nlink;		/* number of hard links */
+	short			st_uid;			/* user ID of owner */
+	short			st_gid;			/* group ID of owner */
+	_dev_t			st_rdev;		/* device type (if inode device) */
+	_off_t			st_size;		/* total size, in bytes */
+	_time_t			st_atime;		/* time of last access */
+	_time_t			st_mtime;		/* time of last modification */
+	_time_t			st_ctime;		/* time of last change */
+} stat;
+
+ 	#define	TC_O_RDONLY	0x0000
+	#define	TC_O_WRONLY	0x0001
+	#define	TC_O_RDWR	0x0002
+	#define	TC_O_APPEND	0x0008
+	#define	TC_O_CREAT	0x0100
+	#define	TC_O_TRUNC	0x0200
+
+/* File creation permissions for open */
+/* Note: OCTAL */
+	#define	TC_A_READ		0000400	/* Write permitted      */
+	#define	TC_A_WRITE		0000200 	/* Read permitted. (Always true anyway)*/
+	#define 	TC_SUCCESS		0
+	typedef	TC_S32		TC_DRIVE;
+	typedef	int			TC_DIR;
+	typedef	int			TC_PDIR;
+	typedef	FDIRENTstruc TC_DS;
+	typedef	DIRENTstruc	TC_DENTRY;
+
+	#define	TC_ISDIRSP(X)		(0)
+
+	#define	TC_StartDrive		1/* DISK_DEVICE_INTERNAL */
+	#define	TC_DriveNum			uNDRIVES
+
+	#define	TC_INTERNAL_DRIVE(X)	(0)
+
+	#define	TC_UFD_DEVICE		DISK_DEVICE_UHP
+	#define	TC_HDD_DEVICE		DISK_DEVICE_HDD
+	#define	TC_NAND_DEVICE		DISK_DEVICE_NAND
+	#define	TC_TRIFLASH_DEVICE	DISK_DEVICE_TRIFLASH
+	#define	TC_SDMMC_DEVICE	DISK_DEVICE_MMC
+	#define	TC_ISINTDRIVE(X)		((X) == TC_StartDrive)
+
+	#define	TC_Set_Drive(X, Y)	((X) = (Y))
+	#define	TC_Inc_Drive(X, Y)	((X) += (Y))
+	#define	TC_Get_DriveNo(X)	((X))
+
+	#define	TC_Get_Attribute(X)	((X)->type)
+	#define	TC_Get_Cluster(X, Y)	((X)->startCluster)
+	#define	TC_Get_Size(X, Y)		((X)->fileSize)
+	#define	TC_Get_LFN(X)		((X)->lFileName)
+	#define	TC_Get_SFName(X)	((X)->sFileName)
+	#define	TC_Get_SFext(X)		((X)->sFileName+9)
+
+	#define	TC_A_RDONLY	    FILE_READ_ONLY
+	#define	TC_A_HIDDEN	    FILE_HIDDEN
+	#define	TC_A_SYSTEM	    FILE_SYSTEM
+	#define	TC_A_VOLUME	    FILE_VOLUME_ID
+	#define	TC_A_DIRENT		FILE_DIRECTORY
+	#define	TC_A_ARCHIVE	FILE_ARCHIVE
+	#define	TC_A_NORMAL	    FILE_NORMAL
+
+	#define	TC_MAX_PATH		255
+	#define	TC_MAX_DIR			MAX_DIR
+
+#define	TC_ISERR(X)			((signed)(X) < 0)
+#define	TC_ISOK(X)			((signed)(X) >= 0)
+
+#define	TC_ISHERR(X)		((signed)(X) < 0)
+#define	TC_ISHOK(X)			((signed)(X) >= 0)
+
+#define	TC_ISRWERR(X)		((signed)(X) <= 0)
+
+#define	TC_SEEK_SET		0
+#define	TC_SEEK_CUR	1
+#define	TC_SEEK_END	2
+
+#define	TC_LOWLEVEL_YES	1
+#define	TC_LOWLEVEL_NO		0
+
+#define UNDEFINED_HANDLE    (-1)
+
+TC_STAT TC_Open(char *name, TC_U32 uFlag, TC_U32 uMode, TC_U32 uDirNum);
+TC_S32	TC_Read(TC_S32 iHandle, void *pBuff, TC_S32 iCount);
+TC_S32	TC_Write(TC_S32 iHandle, void *pBuff, TC_S32 iCount);
+TC_S32	TC_Seek(TC_S32 iHandle, TC_S32 iOffset, TC_S32 iOrigin);
+TC_STAT	TC_Close(TC_S32 iHandle);
+TC_S32	TC_Length(TC_S32 iHandle);
+TC_STAT	TC_DeleteIndex(TC_U32 uIndex, TC_U32 uDirNum);
+TC_STAT	TC_Make_Dir(TC_STR8 pName, TC_U32 uDirNum);
+TC_STAT	TC_SyncDrives(TC_S32 uDriveNo, TC_U32 uNum);
+TC_U32	TC_Get_FileIndex(TC_S32 iHandle, TC_U32 uDirNum);
+TC_STAT	TC_Set_Current_Dir(TC_S32 iPartID, TC_STR8 pPath, TC_U32 uDirNum);
+TC_STAT	TC_CloseNGetFileProperty(TC_S32 iHandle, unsigned int *iFileProperty);
+
+//ENHANCED_DELETION_SPEED
+
+ #endif
+/* end of file */
diff --git a/drivers/block/tcc/inc/fwdn/browse.h b/drivers/block/tcc/inc/fwdn/browse.h
new file mode 100644
index 0000000..f87724f
--- /dev/null
+++ b/drivers/block/tcc/inc/fwdn/browse.h
@@ -0,0 +1,455 @@
+/*******************************************************************************			
+***                                                                          
+***   TELECHIPS.                                     
+***                                                                          
+***                                                                           
+***                                                                          
+*******************************************************************************/
+#ifndef _BROWSE_H_
+#define _BROWSE_H_
+
+#if defined(_LINUX_)
+#include <common.h>
+#endif
+
+//#ifndef _MAIN_H_
+//	#include "main.h"
+//#endif
+
+#define 	ROOTDIR		0
+#define 	_MUSICFILE 		1
+#define 	_NOTMUSICFILE	-1
+
+#define 	WITHNULL 		0
+
+#define 	_DIR			0
+#define 	_FILE			1
+//#define _DONOTUSE	2
+
+#ifndef KILO
+#define KILO	1024
+#endif
+
+// Error Message 
+enum {
+	BRWS_NO_ERROR = 0,
+	BRWS_ERROR_NODIR,
+	BRWS_ERROR_NOFILE,
+	BRWS_ERROR_CANTGO,
+	BRWS_ERROR_UNDEF_ATTR,
+	BRWS_ERROR_INVALID_INDEX,
+	BRWS_ERROR_FAILE_DELETE,
+	BRWS_ERROR_UHP_BUSY,
+	BRWS_UNDEF_ERROR
+};
+
+enum{
+BRWS_EXT_MP3,
+#ifdef MTX_INCLUDE	
+BRWS_EXT_MTX,
+#endif
+#ifdef WMA_INCLUDE
+BRWS_EXT_WMA,
+#ifdef TRUSTED_FLASH_INCLUDE
+BRWS_EXT_SMA,
+#endif
+#endif
+#ifdef MP2_INCLUDE
+BRWS_EXT_MP2,
+#endif
+#ifdef OGG_INCLUDE
+BRWS_EXT_OGG,
+#endif
+#ifdef	EAACPlus_INCLUDE
+BRWS_EXT_EAACPlus_AAC,
+BRWS_EXT_EAACPlus_M4A,
+BRWS_EXT_EAACPlus_MP4,
+BRWS_EXT_EAACPlus_ADIF,
+BRWS_EXT_EAACPlus_ADTS,
+BRWS_EXT_EAACPlus_3GP,
+#endif	
+#ifdef WAV_INCLUDE
+BRWS_EXT_WAV,
+#endif
+#ifdef MP4_INCLUDE
+BRWS_EXT_MP4,
+#endif
+#ifdef WMV_INCLUDE
+BRWS_EXT_WMV,
+#ifdef TRUSTED_FLASH_INCLUDE
+BRWS_EXT_SMV,
+#endif
+#endif
+#if defined(JPG_INCLUDE) || defined (MULTI_CODEC_INCLUDE)
+BRWS_EXT_JPG,
+#endif
+#if defined(PNG_INCLUDE) 
+BRWS_EXT_PNG,
+#endif
+#if defined(BMP_INCLUDE) 
+BRWS_EXT_BMP,
+#endif
+#if defined(GIF_INCLUDE) 
+BRWS_EXT_GIF,
+#endif
+#ifdef AUDIBLE_INCLUDE
+BRWS_EXT_AA,
+#endif
+#if defined (MULTI_CODEC_INCLUDE)
+BRWS_EXT_TXT,
+#endif
+#ifdef M3U_INCLUDE
+BRWS_EXT_M3U,
+#endif
+#if defined(MTP_CUSTOM_IMAGE_INCLUDE)
+BRWS_EXT_FIL,
+#endif
+#ifdef RHAPSODY_INCLUDE
+BRWS_EXT_XML,
+#endif
+BRWS_EXT_MAX
+};
+
+/* Start - skott 's  code */
+#define 	MAX_PLAYLIST_NUM			1*KILO
+	
+// 2M Buffer config
+#ifdef BRWS_STR_NAND_INCLUDE
+#define BRWS_NAME_BUFFER_SIZE	(4096)
+#elif defined(MTP_INCLUDE)
+#define BRWS_NAME_BUFFER_SIZE	(256)
+#else
+#define BRWS_NAME_BUFFER_SIZE	(KILO*KILO*2)
+#endif
+#define MAX_INDEX_LIST_NUM		1*KILO
+
+#ifdef MTP_INCLUDE
+#define	MAX_FOLDER_NUM			MTPDB_DEVICE_FOLDER_MAX
+#define	MAX_MUSICFILE_NUM		MTPDB_DEVICE_FILE_MAX
+#else
+#define	MAX_FOLDER_NUM			2*KILO
+#define	MAX_MUSICFILE_NUM		1*KILO
+#endif
+
+
+typedef enum
+{
+	DB_NOT_USED =0,
+	DB_USED
+#ifdef MTP_INCLUDE
+	,DB_BE_DELETED
+#endif
+}DB_USAGE_TYPE;
+
+
+
+/*			Status Define
+==================================================================
+|B7			|  B6  		| B5			| B4			| B3	/ B2		| B1  	     	| B0		|
+==================================================================
+|reserved	| Reference	| Reference	| AlbumJacket	| Protection	|  Protection	Status		|
+|			| Flag 		| member flag| Exist Flag	| Status		| 			 			|
+==================================================================
+*/
+typedef struct{
+	unsigned int	ucMotherIndex;
+	unsigned int	ucFileIndex;
+	unsigned char 	ucAttr;
+	unsigned char 	ucPartition_ID;
+	unsigned char 	ucStatus;
+	unsigned char 	ucCodec;
+#ifndef MTP_INCLUDE
+	unsigned int 	ucShortFileName;
+	unsigned int 	ucLongFileName;
+	unsigned char 	fLfn;
+	unsigned char 	dummy[3];
+#else
+	unsigned long	ulCluster;			//start cluster in FAT
+	unsigned short	usCRC16FileName;	//verify filename
+//MTPDB2DB-->
+	unsigned short	usPacketOffset;
+//<--MTPDB2DB
+#ifdef	VIDEOART_INCLUDE
+	unsigned int	AlbumArtIndex;
+#else
+	unsigned short	AlbumArtIndex;
+#endif
+	unsigned short	ObjectFormat; 
+
+#ifdef MEDIA_RESUME_INCLUDE
+	unsigned short	usLastTimeSec; 
+#endif
+
+#endif
+}_FILE_LIST_TYPE,*pFILE_LIST_TYPE;
+
+typedef struct{
+	unsigned short	ucFileCount;    	// Total File Number
+	unsigned short	ucFolderCount;		// Total Folder Number
+	unsigned int	ucMotherIndex;		// Mother Index Number
+	unsigned int	ucFolderIndex;		// The order of folder in entry field like 1st, 2nd ..
+	unsigned long	ulCluster;			// Start Cluster in FAT
+	unsigned char 	ucPartition_ID;		// Partition ID
+	unsigned char 	fUsed;				// Used or Not used
+#ifndef MTP_INCLUDE
+	unsigned int 	ucShortFolderName;	
+	unsigned int 	ucLongFolderName;	
+	unsigned char 	fLfn;			
+	unsigned char 	dummy[3];		
+#else
+	unsigned short	usCRC16FileName;	//verify filename
+//MTPDB2DB-->
+	unsigned short 	usPacketOffset;
+//<--MTPDB2DB
+	unsigned char 	ucStatus;
+	unsigned char		ReferenceCount;
+#endif
+}_FOLDER_LIST_TYPE,*pFOLDER_LIST_TYPE;
+
+
+typedef struct{
+	unsigned char 		ucName[9];			// Disk name
+	unsigned char 		ucUsed;				// Used or not
+	unsigned char 		ucDeviceType;		// Device type from enum DISK_DEVICE
+	unsigned char 		ucPartID;			// Partition ID
+	unsigned int		uiFolderNum;		// Total folder number in disk
+	unsigned int		uiFileNum;			// Total file number in disk
+	unsigned int		uiRootIndex;		// Root index at stTotalFolderList[]	
+//	unsigned char 		dummy;
+}_DEVICE_TYPE_INFO;
+
+#define 	BRWS_MAKE_LIST_OF_FOLDER	0x01
+#define 	BRWS_MAKE_LIST_OF_FILE		0x02
+#define 	BRWS_MAKE_LIST_OF_ALL		BRWS_MAKE_LIST_OF_FOLDER | BRWS_MAKE_LIST_OF_FILE
+
+#define 	BRWS_MAKE_PLAY_LIST_ALL		0x80
+#define 	BRWS_MAKE_PLAY_LIST_SIMAGE	0x40
+#define 	BRWS_MAKE_PLAY_LIST_TEXT	0x20
+#define 	BRWS_MAKE_PLAY_LIST_MPG4	0x10
+#define 	BRWS_MAKE_PLAY_LIST_AUDIO	0x08
+#define	BRWS_MAKE_PLAY_LIST_M3U		0x04
+
+#define 	BRWS_SEARCH_ALL_FOLDER		-1
+
+#define		BRWS_NAME_AREA_SIZE		 	4096
+
+enum
+{
+	FOLDER_RECORD = 10,
+#ifdef _RECORD_SUB_FOLDER_INCLUDE_
+	#ifdef _RECORD_SUB_FOLDER_LINEIN_INCLUDE_
+		FOLDER_RECORD_LINEIN,
+	#endif
+	#ifdef _RECORD_SUB_FOLDER_FM_INCLUDE_
+		FOLDER_RECORD_FM,
+	#endif
+	#ifdef _RECORD_SUB_FOLDER_VOICE_INCLUDE_
+		FOLDER_RECORD_VOICE,
+	#endif
+	#ifdef _RECORD_SUB_FOLDER_CAM_INCLUDE_
+		FOLDER_RECORD_CAM,
+	#endif
+	#ifdef _RECORD_SUB_FOLDER_TV_INCLUDE_
+		FOLDER_RECORD_TV,
+	#endif
+#endif
+	FOLDER_PHOTO,
+	FOLDER_AUDIBLE,
+	FOLDER_CONFIG,
+	FOLDER_ROOT,
+	FOLDER_DEFAULT,
+	FOLDER_UNKNOWN
+};
+
+#ifdef _RECORD_SUB_FOLDER_INCLUDE_
+typedef enum
+{
+#ifdef _RECORD_SUB_FOLDER_LINEIN_INCLUDE_
+	RECORD_FOLDER_LINEIN,
+#endif
+#ifdef _RECORD_SUB_FOLDER_FM_INCLUDE_
+	RECORD_FOLDER_FM,
+#endif
+#ifdef _RECORD_SUB_FOLDER_VOICE_INCLUDE_
+	RECORD_FOLDER_VOICE,
+#endif
+#ifdef _RECORD_SUB_FOLDER_CAM_INCLUDE_
+	RECORD_FOLDER_CAM,
+#endif
+#ifdef _RECORD_SUB_FOLDER_TV_INCLUDE_
+	RECORD_FOLDER_TV,
+#endif
+	RECORD_SUB_FOLDER_UNKNOWN,
+	RECORD_SUB_FOLDER_MAX = RECORD_SUB_FOLDER_UNKNOWN
+}RECORD_SUB_FOLDER_TYPE;
+#endif
+
+
+/*--------------------------------------------------------------
+ Folder Index Function 
+----------------------------------------------------------------*/
+extern unsigned int  BRWS_GetRecordFileIndex(void);
+extern unsigned int  BRWS_GetRecordFolderIndex(void);
+extern unsigned int  BRWS_GetRecordFolderCluster(void);
+#ifdef _RECORD_SUB_FOLDER_INCLUDE_
+extern unsigned int  BRWS_GetRecordSubFolderIndex(unsigned int rec_sub_type);
+extern unsigned int  BRWS_GetRecordSubFolderCluster(unsigned int rec_sub_type);
+#endif
+extern unsigned int  BRWS_GetCurrFolderIndex(void);
+extern void BRWS_SaveFolderIndex(unsigned int iIndex);
+
+
+/*--------------------------------------------------------------
+ Functions for making File List
+
+ name : BRWS_MakePlayList
+----------------------------------------------------------------*/
+extern unsigned int BRWS_MakePlayList(int uiTotalIndex, unsigned short *ptrList, unsigned char ucMode );
+
+extern unsigned int BRWS_FindFileNumInPlayList(int uiTotalIndex, unsigned int uiDBIndex, unsigned char ucMode );
+
+
+/*--------------------------------------------------------------
+Get Count Value Function 
+----------------------------------------------------------------*/
+extern unsigned 	int BRWS_GetTotalFolderNum( void );
+extern unsigned 	int BRWS_GetTotalFileCount( void );
+
+/*--------------------------------------------------------------
+utility Function
+----------------------------------------------------------------*/
+extern int BRWS_FindMusicFile(const char *filename, int mode);
+extern int BRWS_CorrectDirName(char *path);
+extern void BRWS_CharCopy(const char *input, char *output, int num);
+extern int BRWS_CharNICmp(const char *src1, const char *src2, int cmplen);
+extern int BRWS_IsReadOnly(int attr);
+
+/*--------------------------------------------------------------
+Check the main device if config folder is existed. if not existing config folder, create it.
+----------------------------------------------------------------*/
+extern int BRWS_CheckConfigFolderIs(int iPartID, int dir_num);
+
+/*--------------------------------------------------------------
+Audible function 
+----------------------------------------------------------------*/
+#ifdef AUDIBLE_INCLUDE
+extern int BRWS_CheckAudibleFolderIs(int);
+#endif
+/*--------------------------------------------------------------
+Recoding function 
+----------------------------------------------------------------*/
+extern int BRWS_CheckRecodingFolderIs(int);
+extern int BRWS_ChangeRecodingFolder(void);
+extern int BRWS_UpdateRecodingDB(void);
+
+/*--------------------------------------------------------------
+Check File Attrive Function
+----------------------------------------------------------------*/
+extern int BRWS_CheckFileAttrive(unsigned int uiFileIdx);
+
+
+/*--------------------------------------------------------------
+Format Drive Function
+
+----------------------------------------------------------------*/
+extern int BRWS_FormatDrive(unsigned short mode, int iPartID);
+
+
+/*--------------------------------------------------------------
+Delete File Function
+----------------------------------------------------------------*/
+extern int BRWS_DeleteFile(unsigned int uiCurrFileNum, unsigned int uiFolderIdx);
+
+/*---------------------------------------------------------------------
+	BRWS_ReProfilingMTPUIDB
+-----------------------------------------------------------------------*/
+extern int BRWS_ReProfilingMTPUIDB(void);
+
+/*--------------------------------------------------------------
+Copy File Function
+----------------------------------------------------------------*/
+extern int	BRWS_CopyFile(unsigned int uiSrcFileIndex, unsigned int uiDstFolderIndex);
+
+/*--------------------------------------------------------------
+Check Disk WP Status
+----------------------------------------------------------------*/
+extern int BRWS_CheckWPStatus(int part_ID);
+
+/*--------------------------------------------------------------
+Check CRC of Image on NAND Disk
+----------------------------------------------------------------*/
+#ifdef NAND_BOOT_INCLUDE
+extern int BRWS_CheckCRCOfNANDBOOT( void );
+#endif
+
+/*--------------------------------------------------------------
+	Change Folder  usign cluster 
+----------------------------------------------------------------*/
+extern int	BRWS_CheckIsFolderRoot( unsigned int uiIndex );
+
+extern int BRWS_ChangeBackgroundFolder( unsigned int uiTotalIndex );
+
+extern int BRWS_ChangeFolder( unsigned int uiTotalIndex );
+
+extern int	BRWS_InitializeCurrFolderList(unsigned int uiTotalIndex, unsigned short *ptrList, unsigned char ucMode );
+
+extern int	BRWS_InitializeDeviceList(unsigned short *ptrList);
+
+/*--------------------------------------------------------------
+Folder Name Function 
+----------------------------------------------------------------*/
+extern unsigned char *BRWS_GetFolderName( unsigned int uiIndex, unsigned char *fLfn);
+extern unsigned char *BRWS_GetFileName( unsigned int uiFileIndex, unsigned char *fLfn);
+
+/*--------------------------------------------------------------
+	Search all file and folder in Selected Folder 
+----------------------------------------------------------------*/
+
+extern int BRWS_SearchFolder(int iPartID, unsigned int uiTotalIndex);
+
+/*--------------------------------------------------------------
+	Make Folder and File List DataBase
+		: using BRWS_SearchFolder();
+
+----------------------------------------------------------------*/
+extern void BRWS_InitializeFolderDB( void );
+
+extern int BRWS_AddDevice( unsigned char *ucName,  unsigned char ucType );
+extern int BRWS_RefreshMainDevice( void );
+
+extern int BRWS_SaveBRWSDB(void);
+extern int BRWS_LoadBRWSDB(void);
+extern int BRWS_DelBRWSDB(void);
+
+#ifdef BRWS_STR_NAND_INCLUDE
+extern unsigned char *BRWS_GetNameString(unsigned int Offset);
+extern void BRWS_InitNameStringArea(unsigned int uiStartAddr,unsigned int uiSectorSize);
+extern void BRWS_CleanNameString(unsigned char *ucSrcString,unsigned int uiOffset);
+#endif
+extern void BRWS_PutNameString(unsigned char *ucSrcString,unsigned int uiOffset,unsigned char ucNameChar);
+extern unsigned char BRWS_GetDeviceStatus(unsigned int uiIndex);
+extern unsigned int  BRWS_GetDefaultDevice(void);
+extern void  		 BRWS_SetDefaultDevice(unsigned int uiDefaultDevice);
+extern unsigned int  BRWS_GetDeviceCount(void);
+extern unsigned int  BRWS_GetTotalDeviceCount(void);
+extern void 		 BRWS_RemoveDevice(unsigned char ucDeviceType);
+extern unsigned char BRWS_GetFilePartID(unsigned int uiFileIndex);
+/* End - skott 's  code */
+
+ extern  int BRWS_CHeckFFREWSeekStatus(void);
+
+extern int BRWS_IsTAGJPGCodec(int iCurrentCodec);
+extern int BRWS_IsMP3MP2Codec(int iCurrentCodec);
+extern int BRWS_IsAudibleCodec(int iCurrentCodec);
+extern int BRWS_IsImageCodec(int iCurrentCodec);
+extern int BRWS_IsBackgroundImageCodec(unsigned int uiBackgroundCodec);
+extern int BRWS_IsEAACPlusCodec(int iCurrentCodec);
+extern int BRWS_IsVideoCodec(int iCurrentCodec);  
+extern int BRWS_IsWMVVideoCodec(int iCurrentCodec);  
+extern int BRWS_IsDrmCodec(int iCurrentCodec); 
+extern void BRWS_FILE_OpenDir(int iCurrentCodec, unsigned int uiTotalIndex) ;
+extern void	BRWS_DisplayProgressFile(int iStartIndex, unsigned int Count,unsigned int  MaxFileNum);
+extern unsigned long BRWS_GetFileCluster(int index);
+
+#endif
+ 
diff --git a/drivers/block/tcc/inc/fwdn/fat.h b/drivers/block/tcc/inc/fwdn/fat.h
new file mode 100644
index 0000000..fbff0fb
--- /dev/null
+++ b/drivers/block/tcc/inc/fwdn/fat.h
@@ -0,0 +1,739 @@
+/*****************************************************************************/
+// 
+// Definition for FAT Application using Telechips Software.
+//
+//	Copyright	2008				Telechips, Inc.
+//
+/*****************************************************************************/
+
+#include "FSAPP.h"
+
+#ifndef __FAT_H__
+#define __FAT_H__
+
+//=============================================================================
+//*
+//*
+//*                       [ ERROR CODE ENUMERATION ]
+//*
+//*
+//=============================================================================
+enum 
+{
+	FS_SUCCESS = 0,
+	FS_FAIL,	
+
+	ERR_FS_NOT_VALID_MBR,
+	ERR_FS_NOT_READ_MBR,
+	ERR_FS_NOT_FORMATTED,
+	ERR_FS_NOT_DELETE_FILE,
+	ERR_FS_NOT_DELETE_DIR,
+	ERR_FS_NOT_FIND_PARTITION_INFO,
+	ERR_FS_NOT_VALID_FAT_TYPE,
+	ERR_FS_NOT_VALID_READ_BOOTSECTOR,
+	ERR_FS_INVALID_SECTOR_SIZE,
+	ERR_FS_NOT_VALID_CLUSTER_PARAMETER,
+	ERR_FS_NOT_READ_SECTOR,
+	ERR_FS_NOT_WRITE_SECTOR,	
+	ERR_FS_NOT_GET_LOGDRV_INFO,	
+	ERR_FS_NOT_GET_PREVIOUS_DIR,
+	ERR_FS_NOT_GET_NEXT_CLUSTER,
+	ERR_FS_NOT_GET_PREV_CLUSTER,
+	ERR_FS_NOT_GET_EMPTY_CLUSTER,	
+	ERR_FS_NOT_GET_INFO_FILEORDIR,
+	ERR_FS_NOT_GET_TOTAL_FILEORDIR,
+	ERR_FS_NOT_GET_PARENT_DIR_CLUSTER,	
+	ERR_FS_NOT_FIND_DIR_CLUSTER_WITHDIRNAME,
+	ERR_FS_NOT_CREATE_DIRECTORY,
+	ERR_FS_NOT_DIRECTORY_CLUSTER,
+	ERR_FS_NOT_UPDATE_ENTRY,
+	ERR_FS_NOT_GET_FILEINFO_WITHFILENAME,
+	ERR_FS_NOT_OPEN_FAT_CHCHE,
+	ERR_FS_NOT_FLUSH_FAT_CACHE,
+	ERR_FS_NOT_SAME_FAT1_FAT2,
+	ERR_FS_NOT_READY_VIRTUAL_FAT1_FORSMC,
+	ERR_FS_NOT_READ_FROM_VIRTUAL_FAT1_FORSMC,
+	ERR_FS_NOT_WRITE_FAT_CONTENT_TO_VIRTUAL_FAT1_FORSMC,
+	ERR_FS_FAILED_READ_SECTOR,
+	ERR_FS_FAILED_FORMAT,
+	ERR_FS_PARAMETER_GET_DRV_PARTITON,
+	ERR_FS_NOT_VALID_PARAMETER
+};
+
+
+//=============================================================================
+//*
+//*
+//*                       [ EXTERNAL DEFINATION ]
+//*
+//*
+//=============================================================================
+#define		FAT_BOOTSIG		0xAA55
+
+// Some useful cluster numbers
+#define			FAT_MSDOSFSROOT				0	/* cluster 0 means the root dir */
+#define			FAT_CLUST_FREE				0	/* cluster 0 also means a free cluster */
+#define			FAT_CLUST_RSRVD				0xfffffff6	/* reserved cluster range */
+#define 		FAT_CLUST_BAD				0xfffffff7	/* a cluster with a defect */
+#define 		FAT_CLUST_EOFS				0xfffffff8	/* start of eof cluster range */
+#define 		FAT_CLUST_EOFE				0xffffffff	/* end of eof cluster range */
+
+#define 		FAT12_MASK					0x00000fff	/* mask for 12 bit cluster numbers */
+#define 		FAT16_MASK					0x0000ffff	/* mask for 16 bit cluster numbers */
+#define 		FAT32_MASK					0x0fffffff	/* mask for FAT32 cluster numbers */
+
+#define 		FAT12_EOFS					0x0FF8
+#define 		FAT16_EOFS					0xFFF8
+#define 		FAT32_EOFS					0x0FFFFFF8
+// Partition Type used in the partition record
+#define			PART_TYPE_UNKNOWN			0x00
+#define			PART_TYPE_FAT12				0x01
+#define			PART_TYPE_DOSFAT16			0x04
+#define			PART_TYPE_EXTDOS			0x05
+#define			PART_TYPE_FAT16				0x06
+#define			PART_TYPE_FAT32				0x0B
+#define			PART_TYPE_FAT32LBA			0x0C
+#define			PART_TYPE_FAT16LBA			0x0E
+#define			PART_TYPE_EXTDOSLBA			0x0F
+
+#define			FS_MAX_SHIFT_FACTOR			17
+
+#define			DRIVE0						0
+#define			MAX_MULTI_SECTOR			32		// 32 SECTORS
+#define			MAX_MULTI_BYTE				16384	// 16 [Kbyte] = 512[byte] * 32
+#define			MAX_SECTOR_SIZE				4096	// [byte] = maximum bytes per sector
+#define			MAX_CLUSTER_SIZE			65536	// 512(byte) * 128(sec)
+
+#define			FAT_BOOTSIG					0xAA55
+#define			EXTENDED_BOOTSIG			0x29
+
+#define			FAT12						2
+#define			FAT16						1
+#define			FAT32						0
+
+#define			FAT_DIR_EMPTY				0x00	// directory entry is free. never been used.
+#define			FAT_DIR_E5					0x05	// value for 0xE5. because 0xE5 is a real char in KANJI
+#define			FAT_DIR_DELETED				0xE5	// this directory entry is free.
+
+#define			ATTR_NORMAL					0x00	// normal file
+#define			ATTR_READ_ONLY				0x01	// file is read only
+#define			ATTR_HIDDEN					0x02	// file is hidden
+#define			ATTR_SYSTEM					0x04	// file is a system file
+#define			ATTR_VOLUME_ID				0x08	// entry is a volume label
+#define			ATTR_DIRECTORY				0x10	// entry is a directory name
+#define			ATTR_ARCHIVE				0x20	// file is new or modified
+#define			ATTR_LONG_NAME				0x0F	// this is a long file name entry
+
+#define			LCASE_BASE					0x08	// filename base in lower case
+#define			LCASE_EXT					0x10	// filename extension in lower case
+
+#define			DIR_ENTRY_PER_SECTOR		0x10	// 16 = 512/32
+
+#define			LAST_LONG_ENTRY				0x40	// mask for the last dir entry
+#define			LDIR_ORD_MAX				0x3F	// Max. count of LDIR_Ord
+
+#define			LDIR_CHAR_PER_ENTRY			13		// Number of character of a long dir entry.
+#define			LDIR_MAX_CHAR				255		// max. number of character of the long file name
+#define			MAX_ROOT_ENTRY_COUNT		1024	// max. number of the root entry count
+
+#define			FAT_CACHE_SECTOR			3		// 3 sectors = 512 * 3 [byte]
+
+// LOCK FLAG OF THE FILE SYSTEM TEMPORARY BUFFER
+#define			LOCK_BUFF					0x0001
+#define			UNLOCK_BUFF					0x0000
+#define			DIRTY_BIT					0x0100
+
+//	MAXIMUM NUMBER OF PARTITIONS
+#define			FS_MAX_PART_NUMBER			FSAPP_MAX_PART_NUMBER
+
+#define			START_YEAR					1980	// Year 1980
+
+#define			FILE_OP_WRITE				0x00010000	// write file
+#define			FILE_OP_OPEN				0x00000001	// opened file
+#define			FILE_OP_CH_SIZE				0x00020000	// changed file size
+#define			FILE_OP_UP_ENT				0x00100000   // update short entry. else create new entry
+
+#define			ADDITION					1
+#define			SUBTRACTION					2
+// special option
+#define _NEW_WRITE_ENTRY
+
+
+//=============================================================================
+//*
+//*
+//*                       [ STRUCT DEFINE ]
+//*
+//*
+//=============================================================================
+
+///////////////////////////////////////////////////////////////////////////////
+/////////////////////////    MBR    ///////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+// FOR EACH PARTITION ENTRY INFORMATION(16 BYTES) STRUCTURE
+#if defined(_WINCE_)
+#pragma pack(1)
+typedef struct _PARTITION_INFO			// length 16 bytes partion entry information
+#elif defined(_LINUX_)
+typedef struct _PARTITION_INFO			// length 16 bytes partion entry information
+#endif
+{
+
+ 	unsigned char		boot_id;					// Bootable? 0=no , 128(0x80) = yes
+ 	unsigned char		begin_head;					// beginning head number
+ 	unsigned char		begin_sector;				// beginning sector number
+ 	unsigned short		begin_cylinder;				// 10bit number [high 2bit], with high 2bits put in begin sector
+ 	unsigned char		system_id;					// Operating System type indicator code
+ 	unsigned char		end_head;					// ending head number
+	unsigned char		end_sector;					// ending sector numer
+ 	unsigned short		end_cylinder;				// 10bit number [high 2bit] , with high 2bits put in end sector
+ 	unsigned long		relative_first_sector;		// first sector relative to start of disk
+ 	unsigned long		number_sector_partition;	// number of sectors in partion	
+
+ 	
+#if defined(_WINCE_)
+}PARTINFOstruc;
+#pragma pack()
+#elif defined(_LINUX_)
+} __attribute__((packed)) PARTINFOstruc;
+#endif
+
+
+
+// FOR EACH PARTITION AREA ALL DATA STRUCTURE
+#if defined(_WINCE_)
+#pragma pack(1)
+struct _MBR_INFO
+#elif defined(_LINUX_)
+struct _MBR_INFO
+#endif
+{
+
+	PARTINFOstruc		parts[4];
+	unsigned short		signature;					// two signature bytes (2 bytes)
+
+	
+#if defined(_WINCE_)
+};
+#pragma pack()
+#elif defined(_LINUX_)
+} __attribute__((packed));
+#endif
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+
+
+
+
+///////////////////////////////////////////////////////////////////////////////
+/////////////////////////    PBR    ///////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+// COMMON BPB SPEC. FOR FAT16/32.	(36 BYTES)
+#if defined(_WINCE_)
+#pragma pack(1)
+struct _BPB
+#elif defined(_LINUX_)
+struct _BPB	
+#endif
+{
+
+	unsigned char		BS_jmpBoot[3];				// jump instruction to boot code. 0xE9xxx or 0xEBxx90
+	char				BS_OEMName[8];				// OEM name and version
+	unsigned short		BPB_BytsPerSec;				// Count of bytes per sector. default 512
+	unsigned char		BPB_SecPerClus;				// Number of sectors per cluster
+	unsigned short		BPB_RsvdSecCnt;				// Number of reserved sectors
+	unsigned char		BPB_NumFATs;				// Count of FAT data on the volume. default 2
+	unsigned short		BPB_RootEntCnt;				// Number of the Root directory entries. FAT32 = 0
+	unsigned short		BPB_TotSec16;				// 16 bit total count of sector < 65536. FAT32 = 0
+	unsigned char		BPB_Media;					// media discriptor. 0xF8 --> "Fixed Disk"
+	unsigned short		BPB_FATSz16;				// Number of sectors per FAT
+	unsigned short		BPB_SecPerTrk;				// sector per track
+	unsigned short		BPB_NumHeads;				// Number of heads
+	unsigned long		BPB_HiddSec;				// count of hidden sectors
+	unsigned long		BPB_TotSec32;				// total count of sectors on the volume.
+
+	
+#if defined(_WINCE_)
+};
+#pragma pack()
+#elif defined(_LINUX_)
+} __attribute__((packed));
+#endif
+
+
+
+// EXTENDED BS(BOOT SECTOR) SPEC. FOR FAT16/32.		(26 BYTES)
+#if defined(_WINCE_)
+#pragma pack(1)
+struct _EXTENDED_BS
+#elif defined(_LINUX_)
+struct _EXTENDED_BS
+#endif
+{
+
+	unsigned char		BS_DrvNum;					// drive number : HDD(0x80), FDD(0x00)
+	unsigned char		BS_Reserved1;				// reserved(used by Windows NT)
+	unsigned char		BS_BootSig;					// Extended boot signature (0x29)
+	unsigned char		BS_VolID[4];				// Volume serial number
+	char				BS_VolLab[11];				// Volume label
+	char				BS_FilSysType[8];			// FS type string "FAT12","FAT16","FAT"
+
+	
+#if defined(_WINCE_)
+};
+#pragma pack()
+#elif defined(_LINUX_)
+} __attribute__((packed));
+#endif
+
+
+
+// BPB SPEC. FOR FAT32 ONLY.		(54 BYTES)
+#if defined(_WINCE_)
+#pragma pack(1)
+struct _BPB_FAT32
+#elif defined(_LINUX_)
+struct _BPB_FAT32
+#endif
+{
+
+	unsigned long		BPB_FATSz32;				// Number of sectors per FAT for FAT32
+	unsigned short		BPB_ExtFlags;				// extended flags
+	unsigned short		BPB_FSVer;					// FAT file system version.
+	unsigned long		BPB_RootClus;				// starting cluster number of the root directory.
+	unsigned short		BPB_FSInfo;					// sector number of FSINFO structure. Usually 1.
+	unsigned short		BPB_BkBootSec;				// backup boot sector. Usually 6.
+	unsigned char		BPB_Reserved[12];			// reserved for future expansion. Must be all zero.
+	unsigned char		BS_DrvNum;
+	unsigned char		BS_Reserved1;
+	unsigned char		BS_BootSig;
+	unsigned char		BS_VolID[4];
+	char				BS_VolLab[11];				// Volume label
+	char				BS_FilSysType[8];			// Reserved 12 bytes for future expansion. all zeros.
+
+	
+#if defined(_WINCE_)
+};
+#pragma pack()
+#elif defined(_LINUX_)
+} __attribute__((packed));
+#endif
+
+
+
+// BS(BOOT SECTOR) AND BPB(BIOS PARAMETER BLOCK) STRUCTURE FOR FAT32
+#if defined(_WINCE_)
+#pragma pack(1)
+typedef struct _BSBPB_INFO
+#elif defined(_LINUX_)
+typedef struct _BSBPB_INFO
+#endif
+{
+
+	struct _BPB			BPB_data;					// Common BPB data (25 bytes)
+	struct _BPB_FAT32	BPB_FAT32;					// Extended BPB Info. for FAT32 only. (28 bytes)
+	struct _EXTENDED_BS	BS_extended; 				// Extended BS for FAT12/16  (26 bytes)
+
+
+#if defined(_WINCE_)
+}BSBPBstruc;
+#pragma pack()
+#elif defined(_LINUX_)
+} __attribute__((packed)) BSBPBstruc;
+#endif
+
+
+
+// BS(BOOT SECTOR) AND BPB(BIOS PARAMETER BLOCK) STRUCTURE FOR FAT12/16
+#if defined(_WINCE_)
+#pragma pack(1)
+typedef struct _BSBPB1216_INFO
+#elif defined(_LINUX_)
+typedef struct _BSBPB1216_INFO
+#endif
+{
+
+	struct _BPB			BPB_data;					// Common BPB data (25 bytes)
+	struct _EXTENDED_BS	BS_extended;	 			// Extended BS for FAT12/16  (26 bytes)
+
+
+#if defined(_WINCE_)
+}BSBPB1216struc;
+#pragma pack()
+#elif defined(_LINUX_)
+} __attribute__((packed)) BSBPB1216struc;
+#endif
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+
+
+
+
+///////////////////////////////////////////////////////////////////////////////
+/////////////////////    Reserved Area(FSInfo)    /////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+// FAT32 FSINFO SECTOR STRUCTURE & BACKUP BOOT SECTOR.
+#if defined(_WINCE_)
+#pragma pack(1)
+typedef struct _FSINFO_SECTOR				// for FAT32 FSInfo
+#elif defined(_LINUX_)
+typedef struct _FSINFO_SECTOR				// for FAT32 FSInfo
+#endif
+{
+
+
+	unsigned long		FSI_LeadSig;				// lead signature for FSInfo. Usually 0x41615252
+	unsigned char		FSI_Reserved1[480];			// reserved field. initial value is all zeros.
+	unsigned long		FSI_StrucSig;				// usually 0x61417272 in spec.
+	unsigned long		FSI_Free_Count;				// (free cluster count on the volume) <= (volume cluster count)
+	unsigned long		FSI_Nxt_Free;				// next available cluster number. typically last cluster no.
+	unsigned char		FSI_Reserved2[12];			// reserved for future expansion. all zeros.
+	unsigned long		FSI_TrailSig;				// trail signature = 0xAA550000 for FSInfo Sector.
+
+
+#if defined(_WINCE_)
+}FSINFOstruc;
+#pragma pack()
+#elif defined(_LINUX_)
+} __attribute__((packed)) FSINFOstruc;
+#endif
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+
+
+
+
+///////////////////////////////////////////////////////////////////////////////
+/////////////////////    Logical Drv Structure    /////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+#if defined(_WINCE_)
+#pragma pack(1)
+typedef struct _DRIVE_INFO
+#elif defined(_LINUX_)
+typedef struct _DRIVE_INFO
+#endif
+{
+
+	struct _PARTITION_INFO	part;					// partition info : 18 Bytes
+	struct _BSBPB_INFO		BS;
+
+	unsigned char		Drv_Type;					// 0: HDD, 1: MMC/SD, 2: USB_DRV, 3: NAND_DRV	
+	unsigned char		FAT_Type;					// 0: FAT32	1: FAT16	2:FAT32
+	unsigned short		LUN;						// logical unit number	
+	unsigned short		part_index;					// logical partition or drive index(number).
+	unsigned long		nCluster;					// Temporary Variable for Disk Size
+	unsigned long		FAT1StartSector;			// FAT1 Start Sector
+	unsigned long		FAT2StartSector;			// FAT2 Start Sector
+	unsigned long		FATSize;					// FAT Size
+	unsigned long		FirstDataSector;			// Cluster Start Sector	2TH CLUSTER
+	unsigned long		DirStartSector;				// Root Start Sector
+	unsigned long		DataSec;					// Total Data Sector
+	unsigned long		CountofClusters;			// Total Count of clusters
+	unsigned long		ClusterSize;				// Cluster Byte Size
+	unsigned short		ClusterShift;				// Cluster Shift Factor Size	
+	unsigned short		BytsPerSecShift;			// Sector Bytes Shift Factor Size	
+	unsigned short		SecPerClusShift;			// Sectors Per Cluster Shift Factor Size
+	unsigned long		UsedClusters;				// Used total data capacity [byte]
+
+	
+#if defined(_WINCE_)
+}DRIVE_INFOstruc;
+#pragma pack()
+#elif defined(_LINUX_)
+} __attribute__((packed)) DRIVE_INFOstruc;
+#endif
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+
+
+
+
+///////////////////////////////////////////////////////////////////////////////
+//////////////////////    File Entry Structure    /////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+// FAT DIRECTORY ENTRY STRUCTURE(32 BYTES DATA).
+#if defined(_WINCE_)
+#pragma pack(1)
+typedef struct _FAT_DIR_ENTRY				// FAT 32 bytes for directory entry
+#elif defined(_LINUX_)
+typedef struct _FAT_DIR_ENTRY				// FAT 32 bytes for directory entry
+#endif
+{
+
+	unsigned char		Name[8];					// file name field
+	unsigned char		Extension[3];				// file extension field
+	unsigned char		Attr;						// File attributes
+	unsigned char		NTRes;						// reserved for Windows NT VFAT lower case flags.
+	unsigned char		CrtTimeTenth;				// Millisecond stamp at file creation time. 0-199/(2 sec)
+	unsigned short		CrtTime;					// Time file was created.
+	unsigned short		CrtDate;					// Date file was created.
+	unsigned short		LstAccDate;					// Last access date.
+	unsigned short		FstClusHI;					// High word of this entry's first cluster number. zero for FAT12/16.
+	unsigned short		WrtTime;					// Time of last write.
+	unsigned short		WrtDate;					// Date of last write.
+	unsigned short		FstClusLO;					// Low word of this entry's first cluster number.
+	unsigned long		FileSize;					// this file's size in bytes.
+
+	
+#if defined(_WINCE_)
+}ENTRY_INFO;
+#pragma pack()
+#elif defined(_LINUX_)
+} __attribute__((packed)) ENTRY_INFO;
+#endif
+
+
+
+// FAT LONG DIRECTORY ENTRY STRUCTURE.
+#if defined(_WINCE_)
+#pragma pack(1)
+typedef struct _FAT_LONG_DIR_ENTRY			// FAT 32 bytes for long directory entry
+#elif defined(_LINUX_)
+typedef struct _FAT_LONG_DIR_ENTRY			// FAT 32 bytes for long directory entry
+#endif
+{
+
+	unsigned char		LDIR_Ord;					// order of this entry in the sequence of long dir entries.
+	char				LDIR_Name1[10];				// char 1-5 of the long-name sub-component
+	unsigned char		LDIR_Attr;					// Attributes - must be ATTR_LONG_NAME(0x0F)
+	unsigned char		LDIR_Type;					// If zero, this entry is a sub-component of a long name.
+	unsigned char		LDIR_Chksum;				// checksum of name in the short dir entry
+	char				LDIR_Name2[12];				// char 6-11 of the long-name sub-component
+	unsigned short		LDIR_FstClusLO;				// must be zero.
+	char				LDIR_Name3[4];				// char 12-13 of the long-name sub-component
+
+	
+#if defined(_WINCE_)
+}FAT_LDIR;
+#pragma pack()
+#elif defined(_LINUX_)
+} __attribute__((packed)) FAT_LDIR;
+#endif
+
+
+
+// FAT32 DIRECTORY ENTRY.
+typedef struct _FAT32DIRENT
+{
+	union
+	{
+		ENTRY_INFO		s;
+		FAT_LDIR		l;
+	}entry;
+}FAT32DIRENTstruc;
+
+
+
+//	FILE OR DIRECTORY ENTRY POSITION STRUCTURE
+#if defined(_WINCE_)
+#pragma pack(1)
+typedef struct _FAT_ENTRY_POS
+#elif defined(_LINUX_)
+typedef struct _FAT_ENTRY_POS
+#endif
+{
+
+	int					entryOffset;
+	int					entrySectorOffset;
+	unsigned long		dirCluster;
+	short				entryCount;
+
+
+#if defined(_WINCE_)
+}ENTPOSstruc;
+#pragma pack()
+#elif defined(_LINUX_)
+} __attribute__((packed)) ENTPOSstruc;
+#endif
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+
+
+
+
+///////////////////////////////////////////////////////////////////////////////
+//////////////////////    FAT Cache Structure    //////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+// FAT CACHE CONTROL
+#if defined(_WINCE_)
+#pragma pack(1)
+typedef struct _FAT_CACHE
+#elif defined(_LINUX_)
+typedef struct _FAT_CACHE
+#endif
+{
+
+	unsigned int		InCache;
+	int					drvTypeID;
+	int					partID;
+	unsigned short		status;
+
+	
+#if defined(_WINCE_)
+}FATCACHEstruc;
+#pragma pack()
+#elif defined(_LINUX_)
+} __attribute__((packed)) FATCACHEstruc;
+#endif
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+
+
+
+
+///////////////////////////////////////////////////////////////////////////////
+////////     Lock/Unlock struc. of Entry Sector bufferEntry     ///////////////
+///////////////////////////////////////////////////////////////////////////////
+// ENTRY SECTOR BUFFER CONTROL
+#if defined(_WINCE_)
+#pragma pack(1)
+typedef struct _SECTOR_BUFF
+#elif defined(_LINUX_)
+typedef struct _SECTOR_BUFF
+#endif
+{
+
+	unsigned int		InSector;					// sector buffer address
+	int					part_id;					// partition index
+	unsigned short		status;						// lock or dirty bit
+
+
+#if defined(_WINCE_)
+}SECBUFFstruc;
+#pragma pack()
+#elif defined(_LINUX_)
+} __attribute__((packed)) SECBUFFstruc;
+#endif
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+
+
+
+struct _FDIRENT;
+struct _FD;
+struct _DISK_INFO;
+
+//=============================================================================
+//*
+//*
+//*                       [ EXTERNAL VARIABLE DEFINE ]
+//*
+//*
+//=============================================================================
+//FAT File System Global Variables.
+extern int						fat_total_partition;							// total partition counter
+extern unsigned short			fat_valid_partition;							// primary & logical partition counter.
+
+extern unsigned char			max_handle;
+extern unsigned char			max_fd;
+extern unsigned char			max_dir;
+extern HANDLERstruc				*fHandler;
+extern FDstruc					*fD;
+extern FDIRENTstruc				*fDir;
+
+extern unsigned int				fat_sbuffer[];
+extern unsigned short			fat_cache[(512 * FAT_CACHE_SECTOR) >> 1];		// fat cache buffer = 512 bytes * 3
+
+extern DRIVE_INFOstruc			driveInfo[FS_MAX_PART_NUMBER];					// current drive information
+extern FATCACHEstruc			fatCache;
+extern SECBUFFstruc				secBuffer;
+ 
+extern unsigned char			*entry_buffer;								// entry chunk buffer
+
+// FILE DATE & TIME DEFINITION
+extern volatile unsigned short	file_year;										// initial value = 1980
+extern volatile unsigned char	file_month;										// initial value = 1
+extern volatile unsigned char	file_day;										// initial value = 1
+extern volatile unsigned char	file_hours;										// initial value = 0
+extern volatile unsigned char	file_min;										// initial value = 0
+extern volatile unsigned char	file_sec;										// initial value = 0
+
+
+//=============================================================================
+//*
+//*
+//*                       [ FUCTIONS DEFINE ]
+//*
+//*
+//=============================================================================
+extern int				FAT_GetNextCluster(int drvTypeID, int partID, unsigned long curr_cluster, unsigned long *next_cluster, void *fat_buff);
+extern int				FAT_SetNextCluster(int drvTypeID, int partID, unsigned long curr_cluster, unsigned long next_cluster, void *fat_buff);
+extern unsigned long	FAT_ReadEntrySector(int drvTypeID, int partID, unsigned long dir_cluster, unsigned long SectorIndex, void *buff);
+extern unsigned long	FAT_ReadDirSector(int drvTypeID, int partID, unsigned long dir_cluster, unsigned long SectorIndex, void *buff, int *preSkip);
+extern int				FAT_FindFileEntryWithID(int drvTypeID, unsigned long dirCluster, int file_id, struct _FDIRENT *pFDir);
+extern int				FAT_FindFileEntryWithEntryOffset(int drvTypeID, int partID, unsigned long dirCluster, int file_id, struct _FDIRENT *pFDir);
+extern int				FAT_FindDirEntryWithID(int drvTypeID, unsigned long dirCluster, int dir_id, struct _FDIRENT *pFDir);
+extern int				FAT_FindDirEntryWithEntryOffset(int drvTypeID, int partID, unsigned long dirCluster, int dir_id, struct _FDIRENT *pDir);
+extern int				FAT_GetDirContents(int drvTypeID, int partID, unsigned long start_cluster, int *file_count, int *subdir_count); // 0923
+extern int				FAT_GetParentDirEntry(int drvTypeID, int partID, struct _FDIRENT *pDir, unsigned long dir_cluster);
+extern int				FAT_FindDirEntryWithCluster(int drvTypeID, int partID, unsigned long start_cluster, unsigned long dir_cluster, struct _FDIRENT *pDir);
+extern int				FAT_ReadCluster(int drvTypeID, int partID, unsigned short nSector, unsigned long currCluster, unsigned long offset, unsigned char *pBuff, int nRead, int clusterSize);
+extern int				FAT_WriteCluster(int drvTypeID, int partID, unsigned short nSector, unsigned long currCluster, unsigned long offset, unsigned char *pBuff, int nWrite, int clusterSize);
+extern int				FAT_GetEmptyCluster(int drvTypeID, int partID, unsigned long curr_cluster, unsigned long *Empty_Clus, void *fat_buff);
+extern int				FAT_MakeSubDir(int drvTypeID, int partID, char *pName, unsigned long dirCluster, int option);
+extern int				FAT_GetFreeEntryCount(int drvTypeID, int partID, unsigned long dirCluster, int *entryOffset,
+												int *entrySectorOffset, unsigned long *entryCluster, int entryNeeds );
+extern unsigned long	FAT_GetFileStartCluster(int drvTypeID, int partID, unsigned long curr_cluster);
+extern int				FAT_WriteEntrySector(int drvTypeID, int partID, unsigned long dir_cluster, int entrySectorOffset, void *buff);
+extern unsigned long	FAT_WriteSector(int drvTypeID, int partID, unsigned long dir_cluster, int SectorIndex, void *buff);
+extern int				FAT_ClearFileCluster(int drvTypeID, int partID, unsigned long curr_cluster, void *buff);
+extern int				FAT_DeleteFileEntry(int drvTypeID, int partID, unsigned long dir_cluster, int sector_offset, int entry_offset, void *pBuff);
+extern int				FAT_UpdateFATCache(void *buff);
+extern int				FAT_MakeEmptyEntry(int drvTypeID, int partID, unsigned long uwStrCluster, int *npEntryOffset, int *npEntrySecOffset, unsigned long *lpEntryCluster, int entryNeeds );
+extern int				FAT_MakeNewFD(int drvTypeID, struct _FDIRENT *pDir, char *pName, struct _FD *pFD);
+extern int				FAT_MountDrive(int drvTypeID, unsigned int lun);
+extern int				FAT_UnmountDrive(int drvTypeID);
+
+extern int				FAT_MakeShortEntryFile(int drvTypeID, int partID, struct _FD *pFD, unsigned char *dir_ent);
+extern int				FAT_FindShortFile(int drvTypeID, int partID, unsigned long dir_cluster, char *pName, struct _FDIRENT *pFDir);
+extern int 				FAT_readdir(int drvTypeID, int partID, unsigned long dir_cluster, struct _FDIRENT *pFDir, int mode, void *entry_buff);
+extern int 				FAT_GetEntryData(int drvTypeID, int partID, ENTPOSstruc *pEntPos, void *pBuff);
+extern unsigned char 	FAT_ChkSum(unsigned char *pFcbName);
+extern int				FAT_FormatFAT(int drvTypeID, unsigned int partID, unsigned char SecPerClus,
+										void *SecBuff, struct _DISK_INFO *disk, unsigned char writeVolume);
+extern int				FAT_FormatFAT32(int drvTypeID, unsigned int partID, unsigned char SecPerClus,
+										void *SecBuff, struct _DISK_INFO *disk, unsigned char writeVolume);					
+extern void				FAT_InitVariable(void);
+extern void				FAT_InitDriveInfo(void);
+extern unsigned long	FAT_ArithmeticOperationForCluster(int partID, int nCluster, char arithOperator);
+extern int				FAT_UpdateEntryCountToCache(int drvTypeID, unsigned long dir_cluster, int nCount);
+extern void				FAT_SetReservedSector(unsigned long sector_addr);
+extern unsigned long	FAT_ReadTotalSectorFromHidden(unsigned long *);
+extern int				FAT_GetUsedClusters(int drvTypeID, int partID);
+extern int				FAT_MakeDotEntry(int drvTypeID, int partID, unsigned long start_cluster, unsigned long parent_cluster);
+extern int				FAT_ClearCluster(int drvTypeID, int partID, unsigned long curr_cluster);
+extern unsigned long	FAT_ReadSector(int drvTypeID, int partID, unsigned long dir_cluster, unsigned long SectorIndex, void *buff);
+
+extern int				_FAT_MakeNewFD(struct _FDIRENT *pDir, char *pName, struct _FD *pFD);
+
+
+extern int 				drv_WriteSector(int drvTypeID, unsigned long LBA_addr, unsigned short nSector, void *buff);
+extern int 				drv_ReadSector(int drvTypeID, unsigned long LBA_addr, unsigned short nSector, void *buff);
+extern void 			lockSecBuff(void);
+extern void 			unlockSecBuff(void);
+extern void				lockFATBuff(void);
+extern void				unlockFATBuff(void);
+extern unsigned short	makeWrtDate(unsigned short year, unsigned char month, unsigned char day);
+extern unsigned short 	makeWrtTime(unsigned char hours, unsigned char min, unsigned char sec);
+
+extern int				check_free_entry(int drvTypeID, int partID, unsigned long dir_cluster, int *entryOffset, int *entrySectorOffset, unsigned long *entryCluster, int nEntry);
+extern int				str_cmpu(void *sA, void *sB);
+extern int				str_len16(void *pString);
+extern int 				find_DirEntry(int drvTypeID, int partID, unsigned long startCluster, unsigned char *pFileName);
+extern int				makeShortName(void *pN, void *sN, int num_tail, unsigned short type);
+extern int				makeDirEntry(void *sName, unsigned char attr, unsigned long entry_cluster, unsigned char *dir_ent);
+
+extern int				FAT_getUsedClus_Common(int drvTypeID, int partID, unsigned short nSector, unsigned long FAT1_PhySector);
+extern int				FAT_fatCache_Common(int drvTypeID, int partID, unsigned long FAT2_PhySector, unsigned long FAT_Sector, unsigned short nSector, unsigned char *sbuffer, unsigned char RWflag);
+extern unsigned int		FAT_Format_ClearCommon(int drvTypeID, int sectorPerFAT, unsigned long nSector, unsigned char *pBuff, void *SecBuff, unsigned char multiFlag);
+extern int				FAT_FormatRE_Common(int drvTypeID, int halfEntryNum, unsigned nSector, unsigned char writeVolume, void *pBuff, unsigned char *BS_VolLab);
+						
+extern unsigned int		FAT_makeMBR(int drvTypeID, unsigned long numOfSecPR1, unsigned long numOfSecPR2, unsigned long numOfSecPR3, 
+									unsigned long numOfSecPR4, unsigned char SecPerClus, void *pBuff, struct _DISK_INFO *disk);
+
+extern int				FAT_CheckDirContentsExist(int drvTypeID, int partID, unsigned long start_cluster, int *file_count, int *subdir_count);
+extern short			getLongEntryName(int drvTypeID, int partID, struct _FDIRENT *pFDir, unsigned long sector_offset, int entry_offset, struct _FAT_LONG_DIR_ENTRY *entry, void *buff);
+extern unsigned long	cluster2sector(int partID, unsigned long cluster);
+
+
+#endif	// __FAT_H__
diff --git a/drivers/block/tcc/inc/fwdn/file.h b/drivers/block/tcc/inc/fwdn/file.h
new file mode 100644
index 0000000..2123845
--- /dev/null
+++ b/drivers/block/tcc/inc/fwdn/file.h
@@ -0,0 +1,284 @@
+/*****************************************************************************/
+// File Defition for Telechips Software.
+//
+//	Copyright	2008				Telechips, Inc.
+//
+/*****************************************************************************/
+
+#ifndef __FILE_H__
+#define __FILE_H__
+
+//=============================================================================
+//*
+//*
+//*                       [ EXTERNAL DEFINATION ]
+//*
+//*
+//=============================================================================
+#define					ROOT_DIR_ID						0xFFFF0000
+
+// FILE ACCESS MODE
+#define					FILE_ACCESSMASK					0x07
+#define					FILE_READ						0x00			/* File Read Only */
+#define					FILE_WRITE						0x01			/* File Write Only */
+#define					FILE_REWRITE					0x02			/* File Read/Write */
+#define					FILE_COPY						0x10
+
+#define					FILE_OEXIST						0x00010000		/* Open Existing File */
+#define					FILE_OTRUNC						0x00020000		/* Truncate Existing File */
+#define					FILE_OAPPEND					0x00040000		/* Open Exisging File at EOF */
+#define					FILE_OCREAT						0x00100000		/* Create Unexisting File */
+
+// FILE ATTRIBUTE
+#define					FILE_NORMAL						0x00
+#define					FILE_READ_ONLY					0x01
+#define					FILE_HIDDEN						0x02
+#define					FILE_SYSTEM						0x04
+#define					FILE_VOLUME_ID					0x08
+#define					FILE_DIRECTORY					0x10
+#define					FILE_ARCHIVE					0x20
+
+// FILE CREATE OPTION
+#define					FILE_NO_TILDE					0x0100			/* do not make file with numeric-tail */
+#define					FILE_NO_CMP						0x0200
+
+// REFERENCE POINT OF FILE POINTER.
+#define					FSEEK_SET						0	// file beginning
+#define					FSEEK_CUR						1	// current FP position
+#define					FSEEK_END						2	// file ending
+
+#define					FILE_FIND_FIRST					0x00
+#define					FILE_FIND_NEXT					0x01
+#define					FILE_SKIP_LFN					0x02
+#define					FILE_SAVE_S_ENTRY				0x04
+
+//=============================================================================
+//*
+//*
+//*                       [ ERROR CODE ENUMERATION ]
+//*
+//*
+//=============================================================================
+typedef enum
+{
+	ERR_FS_FAIL					=		-1,
+	ERR_FS_FULL_ROOT_ENTRY		=		-2
+} FS_ERROR;
+
+//=============================================================================
+//*
+//*
+//*                       [ STRUCT DEFINE ]
+//*
+//*
+//=============================================================================
+typedef struct _HANDLER	// FILE HANDLER STRUCTURE.
+{
+	int					lock;				// used handle
+	unsigned long		usage;				// Usage of this handle. Read, Write, Copy etc...
+	unsigned char		*pEntry;			// entry chunk pointer
+	short				nEntry;				// number of entry in entry chunk data. 32 [byte]
+}HANDLERstruc;
+
+typedef struct _FD	// FILE DESCRIPTOR STRUCTURE.
+{
+	int					part_id;			// current partition index
+	int					file_id;			// file id in a parent directory. NOT used anymore.
+	unsigned long		dirCluster;			// number of the start cluster of a parent directory
+
+	char				lFileName[258];		// long file or dir name
+	char				sFileName[13];		// short file or dir name
+	long				fileSize;			// file size [byte].
+	unsigned long		startCluster;		// number of the start cluster of a file or directory
+
+ 	int					pre_clusterCnt;
+	 unsigned long		cntCluster;
+
+	int					entryOffset;		// short entry offset(slot) in current sector
+	int					entrySectorOffset;	// current sector number in current directory
+	unsigned long		entryCluster;		// just debugging
+	
+	unsigned long		clusterSize;		// cluster size of the current partition [byte]
+	unsigned short		type;				// file type or attribute. (READ ONLY, HIDDEN, SYSTEM, DIRECTORY, ARCHIVE) 
+	unsigned long		mode;				// Access Mode of file. (READ, WRITE, REWRITE)
+	unsigned long		offset;				// file pointer [byte]
+	int					refCnt;				// referenct flag. lower 16 bit : referenct count, upper 16 bit : dirty bit
+}FDstruc;
+
+typedef struct _FDIRENT	// FILE OR DIRECTORY ENTRY STRUCTURE.
+{
+	char				lFileName[258];		// long file name
+	char				sFileName[13];		// short file name
+	unsigned char		ref;
+	long				fileSize;			// file size [byte]
+	unsigned short		type;				// file attribute.
+	
+	unsigned long		startCluster;		// cluster of the current file or directory
+	unsigned long		parentCluster;		// cluster of the parent directory
+	
+	int					entryOffset;		// short entry offset(slot) in current sector
+	int					entrySectorOffset;	// current sector number in current directory
+	unsigned long		entryCluster;		// just debugging
+	
+	int					file_cnt;			// file count. only valid when FILE_Refresh() was excuted.
+	int					subdir_cnt;			// sub-directory(folder) count. only valid when FILE_Refresh() was excuted.
+	int					part_id;			// current partition index
+	short				entryCount;			// total entry count
+}FDIRENTstruc;
+
+// SHORT DIRECTORY ENTRY STRUCTURE(32 BYTES DATA).
+#if defined(_WINCE_)
+#pragma pack(1)
+typedef struct _SFN_DIR_ENTRY		// FAT 32 bytes for directory entry
+#elif defined(_LINUX_)
+typedef struct _SFN_DIR_ENTRY		// FAT 32 bytes for directory entry
+#endif
+{
+	unsigned char		Name[8];
+	unsigned char		Extension[3];
+	unsigned char		Attr;
+	unsigned char		NTRes;
+	unsigned char		CrtTimeTenth;
+	unsigned short		CrtTime;
+	unsigned short		CrtDate;
+	unsigned short		LstAccDate;
+	unsigned short		FstClusHI;
+	unsigned short		WrtTime;
+	unsigned short		WrtDate;
+	unsigned short		FstClusLO;
+	unsigned long		FileSize;
+#if defined(_WINCE_)
+}SFN_INFO;
+#pragma pack()
+#elif defined(_LINUX_)
+} __attribute__((packed)) SFN_INFO;
+#endif
+
+
+#if defined(_WINCE_)
+#pragma pack()
+typedef struct _DIRENT	// FILE OR DIRECTORY ENTRY STRUCTURE. - for FILE_ReadDir()
+#elif defined(_LINUX_)
+typedef struct _DIRENT	// FILE OR DIRECTORY ENTRY STRUCTURE. - for FILE_ReadDir()
+#endif
+{
+	SFN_INFO			sEntry;				// short entry slot
+	char				*lFileName;			// pointer of the long file name
+	char				*sFileName;			// pointer of the short file name
+	unsigned char		LFNflag;			// 0: no LFN, 1: has LFN
+	unsigned short		type;				// file attribute. file or directory
+	unsigned long		startCluster;		// cluster of the directory or file
+	unsigned int		offset;
+	int					part_id;			// current partition index
+#if defined(_WINCE_)
+}DIRENTstruc;
+#pragma pack()
+#elif defined(_LINUX_)
+}DIRENTstruc;
+#endif
+
+#ifndef _DISKINFOstruc_
+#define _DISKINFOstruc_
+#if defined(_WINCE_)
+#pragma pack(1)
+typedef struct _DISK_INFO	// DISK INFORMATION STRUCTURE. - for File_Format()
+#elif defined(_LINUX_)
+typedef struct _DISK_INFO	// DISK INFORMATION STRUCTURE. - for File_Format()
+#endif
+{
+	unsigned short		head;
+	unsigned short		cylinder;
+	unsigned short		sector;
+	unsigned short		sector_size;
+#if defined(_WINCE_)
+}DISKINFOstruc;
+#pragma pack()
+#elif defined(_LINUX_)
+} __attribute__((packed)) DISKINFOstruc;
+#endif
+#endif //#ifndef _DISKINFOstruc_
+
+
+#if defined(_WINCE_)
+#pragma pack(1)
+typedef struct _DRV_INFO	// PARTITION (OR DRIVE) SIMPLE INFORMATION
+#elif defined(_LINUX_)
+typedef struct _DRV_INFO	// PARTITION (OR DRIVE) SIMPLE INFORMATION
+#endif
+{
+	unsigned char		Drv_Type;			// HDD_DRV, MMC_DRV, USB_DRV, NAND_DRV	
+	unsigned char		FAT_Type;			// FAT32, FAT16, FAT32
+	unsigned short		part_id;			// logical partition or drive index(number).
+	unsigned short		BytsPerSec;			// Count of bytes per sector. normally 512
+	unsigned long		ClusterSize;		// Cluster Byte Size
+	unsigned long		CountofClusters;	// total number of clusters
+	unsigned long		UsedClusters;		// Used total data capacity [byte]
+#if defined(_WINCE_)
+}DRVINFOstruc;
+#pragma pack()
+#elif defined(_LINUX_)
+} __attribute__((packed)) DRVINFOstruc;
+#endif
+
+//=============================================================================
+//*
+//*
+//*                       [ FUCTIONS DEFINE ]
+//*
+//*
+//=============================================================================
+extern FDstruc			*FILE_pGetFD(int nFD);
+extern FDIRENTstruc		*FILE_pGetDIR(int dir_num);
+extern FDIRENTstruc		*FILE_pGetFDir(int nFDir);
+extern int				FILE_InitSystem(void);
+extern int				FILE_Write(int nHandle, void *pBuff, int size);									// write a file
+extern int				FILE_OpenDirByEntryId(int drvTypeID, int partID, int dir_id, int dir_num);	// open directory.
+extern int				FILE_MakeDir(char *pName, int dir_num);											// make sub-directory
+extern int				FILE_MakeDirWithHDAttr(char *pName, int dir_num);								// make sub-directory with HIDDEN attribute
+extern int				FILE_MakeHideDir(char *pName, int dir_num);
+extern int				FILE_Create(char *pName, unsigned short type, int dir_num);						// create a file.
+extern int				FILE_CreateLFN(void *pName, unsigned short type, int dir_num);					// create a file that name has unicode
+extern int				FILE_RemoveByEntryId(int dir_num, int file_id);									// remove a file
+extern int				FILE_Change2ParentDir(int dir_num);												//change directory to parent directory
+extern int				FILE_Refresh(int dir_num);														// reload current directory information
+extern unsigned long	FILE_TotalDiskCluster(int drvTypeID);
+extern unsigned long	FILE_AvailableDiskCluster(int drvTypeID);										// get free size of the current drive
+extern unsigned long	FILE_GetClusterSize(int drvTypeID);
+extern int				FILE_OpenName(char *pName, char *mode, int dir_num);
+extern int				FILE_OpenDirName(char *pName, char *mode, int dir_num);
+extern int				FILE_ReadDir(int mode, int dir_num, FDIRENTstruc *pFDir, DIRENTstruc *pEnt);
+extern void				FILE_InitFDIRstruc(FDIRENTstruc *pFDir);
+extern int				FILE_OpenDirWithCluster(int partID, unsigned long dir_cluster, int dir_num);
+extern int				FILE_Copy(int dir_num, int sHandle, long *copy_status);
+extern int				FILE_Format(int drvTypeID, int partID, unsigned char writeVolume,
+									unsigned char SecPerClus, unsigned int CntOfClus, struct _DISK_INFO *disk);
+extern int				FILE_FormatMBR(int drvTypeID, unsigned char writeVolume,
+										unsigned char SecPerClus, unsigned int *Partition, struct _DISK_INFO *disk);
+									
+
+extern int				FILE_DiskInfo(int partID, DRVINFOstruc *pDrive);
+extern int				FILE_GetValidPartNum(void);
+extern int				FILE_RemoveDirByEntryId(int dir_num, int dir_id);
+extern int				FILE_RemoveWithHandle(int dir_num, int nHandle);
+extern void				FILE_UpdateDate(unsigned short year, unsigned char month, unsigned char day);
+extern void				FILE_UpdateTime(unsigned char hours, unsigned char min, unsigned char sec);
+extern int				FILE_CheckRootDir(int dir_num);
+extern int				FILE_GetUsedClusters(int drvTypeID);
+extern int				FILE_RenameLFN(int nHandle, void *pName, int dir_num);
+extern int				FILE_OpenDirOnlySearch(int partID, unsigned long dir_cluster, int dir_num);
+
+
+#ifdef NED_INCLUDE
+#include "NED/NED_FS.H"
+#else
+extern int				FILE_OpenByEntryId(int file_id, unsigned long mode, int dir_num);		// open a file. get handle
+extern int				FILE_Close(int nHandle);												// close a file. return handle
+extern int				FILE_Read(int nHandle, void *pBuff, int size);							// read a file
+extern int				FILE_Seek(int nHandle, long offset, int whence);						// move file pointer.
+extern int				FILE_Read_bs(int nHandle, void *pBuff, int size);						// special function
+extern long				FILE_Tell(int nHandle);													// get a current file pointer
+extern int				FILE_Length(int nHandle);												// get a current file size
+#endif
+
+#endif
+
diff --git a/drivers/block/tcc/inc/fwdn/fwdn_drv_v3.h b/drivers/block/tcc/inc/fwdn/fwdn_drv_v3.h
new file mode 100644
index 0000000..229a220
--- /dev/null
+++ b/drivers/block/tcc/inc/fwdn/fwdn_drv_v3.h
@@ -0,0 +1,153 @@
+/****************************************************************************
+ *   FileName    : Fwdn_drv_v3.h
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+
+#ifndef _FWDN_DRV_V3_H_
+#define _FWDN_DRV_V3_H_
+
+#if defined(_LINUX_)
+#include <tnftl/nand_drv.h>
+#elif defined(_WINCE_)
+#include "nand_drv.h"
+#endif
+
+enum
+{
+	ERR_FWDN_DRV_WRONG_PARAMETER = 0x10000000,
+	ERR_FWDN_DRV_DISK_IOCTRL_DEV_INITIALIZE,
+	ERR_FWDN_DRV_DISK_WRITE_COMPARE,
+	ERR_FWDN_DRV_DISK_WRITE,
+	ERR_FWDN_DRV_DISK_READ,
+};
+
+enum
+{
+	FWDN_DRV_TARGET_NAND = 1,
+	FWDN_DRV_TARGET_NOR,
+	FWDN_DRV_TARGET_TRIFLASH,
+	FWDN_DRV_TARGET_EEPROM,
+	FWDN_DRV_TARGET_SFLASH,
+	FWDN_DRV_TARGET_HDD
+};
+
+enum
+{
+	FWDN_DISK_NONE,
+	FWDN_DISK_HDD,
+	FWDN_DISK_MMC,
+	FWDN_DISK_UHP,
+	FWDN_DISK_NAND,
+	FWDN_DISK_TRIFLASH,
+	FWDN_DISK_NOR,
+	FWDN_DISK_SFLASH,
+	FWDN_DISK_MAX
+};
+
+enum
+{
+	SN_NOT_EXIST = 0,
+	SN_VALID_16,
+	SN_INVALID_16,
+	SN_VALID_32,
+	SN_INVALID_32
+};
+
+
+typedef int (*fpFWDN_DRV_FirmwareWrite_ReadFromHost)(unsigned char *buff, unsigned int size, unsigned int srcAddr, unsigned int percent);
+typedef unsigned int (*FXN_FWDN_DRV_ReadFromHost)(void *buff, unsigned int size);
+typedef unsigned int (*FXN_FWDN_DRV_SendToHost)(void *buff, unsigned int size);
+
+typedef struct	 _tag_DeviceInfoType {
+	unsigned int		DefaultDiskType;		// Default Disk Type. nand, tri-flash, hdd ...
+	unsigned int		DevSerialNumberType;	// Device Serial Number type SN_NOT_EXIST..
+	unsigned char		DevSerialNumber[32];
+} FWDN_DEVICE_INFORMATION, *pFWDN_DEVICE_INFORMATION;
+
+typedef struct	 _tag_NAND_HiddenSizeInfo {
+	unsigned int				HiddenPageSize;			// Default Hidden Area Pages
+	unsigned int				MultiHiddenAreaNum;		// Multi Hidden Num	
+	unsigned int 				MultiHiddenSize[8];		// Multi Hidden Configuration
+	unsigned int				ROAreaSize;
+} NAND_HIDDEN_INFO, *pNAND_HIDDEN_INFO;
+
+typedef struct _tag_NAND_DISK_INFO_T {
+	unsigned int	bootSize_MB;
+	unsigned int	totalSize_MB;
+	unsigned int	multiHiddenSystemSize_MB;
+} NAND_DISK_INFO_T;
+
+typedef	struct	__NAND_DeviceInfo {
+	unsigned short int  		PBpV;				// Physical all Block Number
+	unsigned short int  		PpB;				// Page Number Per Block
+	unsigned short int  		PageSize;			// Page Size
+	unsigned short int  		SpareSize;			// Spare Size
+	unsigned short int			MediaNums;			// Media Number of NANDFLASH
+} NAND_DEVICE_INFO, *pNAND_DEVICE_INFO;
+
+//==============================================================
+//
+//		Global Variables
+//
+//==============================================================
+extern FWDN_DEVICE_INFORMATION		FWDN_DeviceInformation;
+extern unsigned int					gFWDN_DRV_ErrorCode;
+
+#define FWDN_DRV_GetErrorCode()		gFWDN_DRV_ErrorCode
+#define FWDN_DRV_ClearErrorCode()	gFWDN_DRV_ErrorCode = 0
+#define FWDN_DRV_SetErrorCode(a)	gFWDN_DRV_ErrorCode = a
+
+//==============================================================
+//
+//		Function Prototypes
+//
+//==============================================================
+void						initSourcePosition(void);
+int							setSourcePosition(int offset);
+
+void						FWDN_InitCACHE(void);
+void						FWDN_SetRWSize(unsigned long uSize);
+
+void						FWDN_DRV_SaveSdCfg(unsigned int sdCfg);
+unsigned int				FWDN_DRV_GetSdCfg(void);
+pFWDN_DEVICE_INFORMATION	FWDN_DRV_GetDeviceInfo(void);
+int							FWDN_DRV_SerialNumberWrite(unsigned char *serial, unsigned int overwrite);
+int							FWDN_DRV_FirmwareWrite(unsigned int fwSize, unsigned int TargetMemType, fpFWDN_DRV_FirmwareWrite_ReadFromHost fFWDN_DRV_FirmwareWrite_ReadFromHost);
+int							FWDN_DRV_FirmwareWrite_Read(unsigned char *buff, unsigned int size, unsigned int percent);
+
+void						FWDN_DRV_DISK_Select(unsigned char fwdnDiskType);
+int							FWDN_DRV_DISK_Init(TNFTL_CALLBACK_HANDLER pCallBackHandler, unsigned int stage, void *pInfo, unsigned short infoSize);
+void						FWDN_DRV_DISK_InfoRead(void *pDiskInfo, unsigned char *pSize);
+
+int							FWDN_DRV_DISK_Read(unsigned int lba, unsigned int size, FXN_FWDN_DRV_SendToHost fxnFwdnDrvSendToHost);
+int							FWDN_DRV_DISK_Write(unsigned int lba, unsigned int size, FXN_FWDN_DRV_ReadFromHost fxnFwdnDrvReadFromHost);
+
+void						FWDN_DRV_DISK_Hidden_InfoRead(void *pInfo, unsigned char *pSize);
+int							FWDN_DRV_DISK_Hidden_Clean(void);
+int							FWDN_DRV_DISK_Hidden_Write(unsigned int startpage, unsigned int sizebyte, FXN_FWDN_DRV_ReadFromHost fxnFwdnDrvReadFromHost);
+int							FWDN_DRV_DISK_MTD_Write(unsigned int startpage, unsigned int sizebyte, FXN_FWDN_DRV_ReadFromHost fxnFwdnDrvReadFromHost);
+
+int							FWDN_DRV_DISK_FS_Partition(void *pMultiPartitionSizeArray, unsigned int length);
+int							FWDN_DRV_DISK_FS_Mount(unsigned int partID);
+int							FWDN_DRV_DISK_FS_Format(void *pMultiPartitionSizeArray, unsigned int length);
+int							FWDN_DRV_DISK_FS_MkDir(unsigned char *name);
+int							FWDN_DRV_DISK_FS_ChDir(unsigned char *name);
+int							FWDN_DRV_DISK_FS_FileWrite(unsigned char *name, unsigned int size, FXN_FWDN_DRV_ReadFromHost fxnFwdnDrvReadFromHost);
+
+unsigned char				FWDN_DRV_DISK_DUMP_InfoRead(unsigned char *pBuf);
+int							FWDN_DRV_DISK_DUMP_BlockRead(unsigned int Param0, unsigned int Param1, unsigned int Param2, FXN_FWDN_DRV_SendToHost fxnFwdnDrvSendToHost);
+
+unsigned int				FWDN_FNT_SetSN(unsigned char* ucTempData, unsigned int uiSNOffset);
+void						FWDN_FNT_VerifySN(unsigned char* ucTempData, unsigned int uiSNOffset);
+void						FWDN_FNT_InsertSN(unsigned char *pSerialNumber);
+unsigned char				FWDN_DRV_FirmwareMemoryType(void);
+#endif	// _FWDN_DRV_H_
+
+/* end of file */
+
diff --git a/drivers/block/tcc/inc/fwdn/fwdn_protocol_v3.h b/drivers/block/tcc/inc/fwdn/fwdn_protocol_v3.h
new file mode 100644
index 0000000..b0ffbae
--- /dev/null
+++ b/drivers/block/tcc/inc/fwdn/fwdn_protocol_v3.h
@@ -0,0 +1,116 @@
+#ifndef __FWDN_PROTOCOL_V2__
+#define __FWDN_PROTOCOL_V2__
+
+////////////////////////////////////////////////////////////////////////////
+//
+//				FWDN Protocol V3
+//
+////////////////////////////////////////////////////////////////////////////
+
+////////////////////////////////////////////////////////////////////////////
+//		FWDN Command
+////////////////////////////////////////////////////////////////////////////
+#define FWDN_CMD_NONE						0x0000
+#define FWDN_CMD_UBS_PING					0x0001
+#define FWDN_CMD_UBS_INITCODE_LOAD			0x0002
+#define FWDN_CMD_UBS_ROM_LOAD				0x0003
+
+#define FWDN_CMD_PING						0x0100
+#define FWDN_CMD_DEVICE_RESET				0x0101
+#define FWDN_CMD_DEVICE_SETTING				0x0102
+#define FWDN_CMD_DEVICE_INFO_READ			0x0103
+#define FWDN_CMD_SERIAL_NUMBER_WRITE		0x0104
+#define FWDN_CMD_FIRMWARE_WRITE				0x0105
+#define FWDN_CMD_SESSION_START				0x0106
+#define FWDN_CMD_SESSION_END				0x0107
+
+#define FWDN_CMD_DISK_SELECT				0x0200
+#define FWDN_CMD_DISK_INIT					0x0201
+#define FWDN_CMD_DISK_INFO_READ				0x0202
+
+#define FWDN_CMD_DISK_HIDDEN_INFO_READ		0x0210
+#define FWDN_CMD_DISK_HIDDEN_CLEAN			0x0211
+#define FWDN_CMD_DISK_HIDDEN_WRITE			0x0212
+
+#define FWDN_CMD_DISK_MTD_WRITE				0x0214
+
+#define FWDN_CMD_DISK_READ					0x0220
+#define FWDN_CMD_DISK_WRITE					0x0221
+
+#define FWDN_CMD_DISK_FS_PARTITION			0x0230
+#define FWDN_CMD_DISK_FS_MOUNT				0x0231
+#define FWDN_CMD_DISK_FS_FORMAT				0x0232
+#define FWDN_CMD_DISK_FS_MKDIR				0x0233
+#define FWDN_CMD_DISK_FS_CHDIR				0x0234
+#define FWDN_CMD_DISK_FS_FILE_WRITE			0x0235
+
+#define FWDN_CMD_DISK_DUMP_INFO_READ		0x0240
+#define FWDN_CMD_DISK_DUMP_BLOCK_READ		0x0241
+
+#define	FWDN_CMD_TEST_SEND					0x0300
+#define FWDN_CMD_TEST_RECEIVE				0x0301
+
+#define FWDN_CMD_TNFTL_V5_DEBUG				0x0F00
+
+
+////////////////////////////////////////////////////////////////////////////
+//		FWDN Response Ack Type
+////////////////////////////////////////////////////////////////////////////
+#define FWDN_RSP_NACK						0x00
+#define FWDN_RSP_ACK						0x01
+#define FWDN_RSP_NYET						0x02
+
+
+////////////////////////////////////////////////////////////////////////////
+//		FWDN Command / Response Signatures
+////////////////////////////////////////////////////////////////////////////
+#define FWDN_COMMAND_SIGNATURE				0x43445746L		//"FWDC" ; FWDn Command
+#define FWDN_RESPONSE_SIGNATURE				0x52445746L		//"FWDR" ; FWDn Response
+
+
+#define FWDN_EXTRA_RSP_MAX_SIZE				0xFF
+
+#if defined(_WINCE_)
+#pragma pack(push, 1)
+#endif
+
+typedef struct _tag_FWDN_COMMAND_T
+{
+	unsigned long	Signature;
+	unsigned short	CmdType;
+	unsigned short	ExtraCmdSize;
+	unsigned long	DataSize;
+	unsigned long	Param0;
+	unsigned long	Param1;
+	unsigned long	Param2;
+
+#if defined(_LINUX_)
+} __attribute__((packed)) FWDN_COMMAND_T;
+#else
+} FWDN_COMMAND_T;
+#endif
+
+typedef struct _tag_FWDN_RESPONSE_T
+{
+	unsigned long	Signature;
+	unsigned short	CmdType;
+	unsigned char	AckType;
+	unsigned char	ExtraRspSize;
+	unsigned long	DataSize;
+	unsigned long	Param0;
+	unsigned long	Param1;
+	unsigned long	Param2;
+
+#if defined(_LINUX_)
+} __attribute__((packed)) FWDN_RESPONSE_T;
+#else
+} FWDN_RESPONSE_T;
+#endif
+
+#if defined(_WINCE_)
+#pragma pack(pop)
+#endif
+
+void FWDN_PROT_CheckCommand(void);
+
+#endif //__FWDN_PROTOCOL_V2__
diff --git a/drivers/block/tcc/inc/fwdn/fwupgrade.h b/drivers/block/tcc/inc/fwdn/fwupgrade.h
new file mode 100644
index 0000000..dfa4ff0
--- /dev/null
+++ b/drivers/block/tcc/inc/fwdn/fwupgrade.h
@@ -0,0 +1,178 @@
+/****************************************************************************
+ *   FileName    : fwupgrade.h
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+#ifndef _FWUPGRADE_H_
+#define _FWUPGRADE_H_
+
+#if defined(_LINUX_)
+#include <common.h>
+//#include <fwdn/main.h>
+#elif defined(_WINCE_)
+//#include "main.h"
+#endif
+
+//**********************************************************************
+//*		Define FWUG Library version for ChipSet
+//**********************************************************************
+#if 0
+#if defined(NU_FILE_INCLUDE)
+	#if defined(TCC78X)
+	#define FWUG_V1_INCLUDE
+	#else
+	#define FWUG_V2_INCLUDE
+	#endif
+#else	/* K-FILESYSTEM */
+#define FWUG_V1_INCLUDE
+#endif
+#else
+	#define FWUG_V2_INCLUDE		//twkwon
+#endif
+
+//*****************************************************************************
+//*
+//*
+//*                       [ General DEFINE & TYPEDEF ]
+//*
+//*
+//*****************************************************************************
+#ifndef ON
+#define ON							0x01
+#endif
+#ifndef OFF
+#define OFF 						0x00
+#endif
+#ifndef DISABLE
+#define DISABLE						0
+#endif
+#ifndef ENABLE
+#define	ENABLE						1
+#endif
+#ifndef FALSE
+#define FALSE 	          			0
+#endif
+#ifndef TRUE
+#define	TRUE						(!FALSE)
+#endif
+#ifndef NULL
+#define	NULL						(0)
+#endif
+
+#if 0
+#ifndef U8
+typedef unsigned char				U8;
+#endif
+#ifndef U16
+typedef unsigned short int			U16;
+#endif
+#ifndef U32
+typedef unsigned int				U32;
+#endif
+#endif
+
+enum
+{
+	FIRST = 0,
+	SECOND,
+	REPETITIONNUM	
+};
+
+//*****************************************************************************
+//*
+//*
+//*                         [ ERROR CODE ENUMERATION ]
+//*
+//*
+//*****************************************************************************
+#ifndef SUCCESS
+#define	SUCCESS  0
+#endif
+
+typedef enum
+{
+	ERR_FWUG_NOT_EXISTMEMORY = 0x1000,
+	ERR_FWUG_FAIL_OPENROMFILE,
+	ERR_FWUG_FAIL_CLOSEROMFILE,	
+	ERR_FWUG_FAIL_READROMFILE,
+	ERR_FWUG_CANCEL_FWUPGRADE,
+	ERR_FWUG_FAIL_BATCHECK,
+	ERR_FWUG_FAIL_ROMFILESIZEBIG,
+	ERR_FWUG_FAIL_GETGOODBLOCKLIST,
+	ERR_FWUG_NOT_EXISTSERIALNUM,
+	ERR_FWUG_FAIL_GMCDATAWRITE,
+	ERR_FWUG_FAIL_GMCSPAREWRITE,
+	ERR_FWUG_FAIL_CODEDATAWRITE,
+	ERR_FWUG_FAIL_CODESPAREWRITE,
+	ERR_FWUG_FAIL_MCDATAWRITE,
+	ERR_FWUG_FAIL_MCSPAREWRITE,
+	ERR_FWUG_FAIL_FWUPGRADE,
+	ERR_FWUG_FAIL_CHECK_TFLASH,
+	ERR_FWUG_FAIL_SCAN_TFLASH,
+	ERR_FWUG_FAIL_CODEWRITETFLASH,
+	ERR_FWUG_FAIL_CODEREADTFLASH,
+	ERR_FWUG_FAIL_HEADERWRITETFLASH,
+	ERR_FWUG_FAIL_HEADERREADTFLASH,
+	ERR_FWUG_FAIL
+} FWUG_ERROR;
+
+typedef	int (*fFWUG_ReadDATA)(unsigned int uDest, unsigned int uSize, unsigned int percent);
+
+extern const unsigned int CRC32_TABLE[];
+
+//*****************************************************************************
+//*
+//*
+//*                       [ EXTERNAL FUCTIONS DEFINE ]
+//*
+//*
+//*****************************************************************************
+extern unsigned char			gFW_FirmwareDevice, gFW_SerialNumberDevice;
+
+extern char						*FWUG_GetTempBuffer(unsigned int *uiBufSize);
+extern int						FWUG_ReadDATA(unsigned int uDest, void *uHandler, unsigned int uSize, unsigned int percent);
+extern unsigned int				CalCRC_ROMFile(unsigned int *pBuffer,unsigned int size,unsigned int crcout, unsigned int mode);
+extern int						FWUG_VerifySerialNumber(unsigned char* ucBuf, unsigned int uiOffset);
+
+extern unsigned int				FWUG_CalcCrc(unsigned int *base, unsigned int length, unsigned int *crctable);
+extern unsigned int				FWUG_CalcCrc8(unsigned char *base, unsigned int length, const unsigned int *crctable);
+extern unsigned int				FWUG_CalcCrcI(unsigned uCRCIN, unsigned *base, unsigned int length, unsigned int *crctable);
+extern unsigned int				FWUG_CalcCrc8I(unsigned uCRCIN, unsigned char *base, unsigned int length, unsigned int *crctable);
+
+/* TFLASH */
+extern unsigned int				FwdnReadTriflashFirmware(unsigned int master);
+extern int						FwdnWriteTriflashFirmware(unsigned uFWSize);
+extern int						FwdnGetTriflashSerial(void);
+extern int						FwdnSetTriflashSerial(unsigned char *ucData, unsigned int overwrite);
+extern int						FwdnClearTriflashHiddenArea(void);
+/* HDD */
+extern int						FwdnClearHddHiddenArea(void);
+/* NOR */
+extern unsigned int				FwdnReadNorFlashFirmware(unsigned int master);
+extern int						FwdnWriteNorFlashFirmware(unsigned uFWSize);
+extern int						FwdnGetNorSerial(void);
+extern int						FwdnSetNorSerial(unsigned char *ucData, unsigned int overwrite);
+/* NAND */
+extern unsigned int 			FwdnReadNandFirmware(unsigned int master);
+extern int						FwdnWriteNandFirmware(unsigned uFWSize);
+extern int						FwdnGetNandSerial(void);
+extern int 						FwdnSetNandSerial(unsigned char *ucData, unsigned int overwrite);
+extern int						FwdnClearNandHiddenArea(unsigned int start, unsigned int pagesize);
+extern void 					FWDN_FNT_VerifySN(unsigned char* ucTempData, unsigned int uiSNOffset);
+/* SFLASH */
+extern unsigned int				FwdnReadSFlashFirmware(unsigned int master);
+extern int						FwdnWriteSFlashFirmware(unsigned uSFBase, unsigned uFWBase, unsigned int uiROMFileSize);
+extern int						FwdnGetSFlashSerial(void);
+extern int						FwdnSetSFlashSerial(unsigned char *ucData, unsigned int overwrite);
+/* EEPROM */
+extern int						FwdnWriteEEPROMFirmware(unsigned uFWSize);
+
+#endif	// _FWUPGRADE_H_
+
+/* end of file */
+
diff --git a/drivers/block/tcc/inc/fwdn/fwupgrade_NAND_v6.h b/drivers/block/tcc/inc/fwdn/fwupgrade_NAND_v6.h
new file mode 100644
index 0000000..c33a459
--- /dev/null
+++ b/drivers/block/tcc/inc/fwdn/fwupgrade_NAND_v6.h
@@ -0,0 +1,160 @@
+/****************************************************************************
+ *   FileName    : fwupgrade_NAND.h
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+#ifndef _FWUPGRADE_NAND_H_
+#define _FWUPGRADE_NAND_H_
+
+#if defined(NAND_BOOT_REV)
+	#if defined(_LINUX_)
+	#include <tnftl/tnftl_v7.h>
+	#elif defined(_WINCE_)
+	#include "tnftl_v7.h"
+	#else
+	#include "tnftl_v7.h"
+	#endif
+#else
+    #if defined(_LINUX_)
+    #include <tnftl/tnftl_v6.h>
+    #elif defined(_WINCE_)
+    #include "tnftl_v6.h"
+    #else
+    #include "tnftl_v6.h"
+    #endif
+#endif
+
+//*****************************************************************************
+//*
+//*
+//*                       [ General DEFINE & TYPEDEF ]
+//*
+//*
+//*****************************************************************************
+#ifndef ON
+#define ON									0x01
+#endif
+#ifndef OFF
+#define OFF 								0x00
+#endif
+#ifndef DISABLE
+#define DISABLE								0
+#endif
+#ifndef ENABLE
+#define	ENABLE								1
+#endif
+#ifndef FALSE
+#define FALSE 	          					0
+#endif
+#ifndef TRUE
+#define TRUE            					1
+#endif
+#ifndef NAND_TYPE_PURE_NAND
+#define NAND_TYPE_PURE_NAND					0
+#endif
+#ifndef NAND_TYPE_LBA_NAND
+#define NAND_TYPE_LBA_NAND					1
+#endif
+
+//*****************************************************************************
+//*
+//*
+//*                       [ EXTERNAL GLOBAL VARIABLE DEFINE ]
+//*
+//*
+//*****************************************************************************
+#define	BIG										0x04
+#define	SMALL									0x00
+#define	PARALLEL								0x08
+#define	SERIAL									0x00
+
+#define EXTENDED_PAGE							0x80
+#define NORMAL_PAGE								0x00
+#define WIDE_SPARE								0x08
+#define NORMAL_SPARE							0x00
+
+#define MAX_GOOD_BLOCK_LIST_LEN					(759*2)
+
+#if defined(TNFTL_V5_INCLUDE) || defined(TNFTL_V6_INCLUDE)
+#define FWUG_NAND_IO_READPAGE					NAND_IO_ReadNBPage
+#define FWUG_NAND_IO_WRITEPAGE					NAND_IO_WriteNBPage
+#else
+#define FWUG_NAND_IO_READPAGE					NAND_IO_ReadPage
+#define FWUG_NAND_IO_WRITEPAGE					NAND_IO_WritePage
+#endif
+
+//*****************************************************************************
+//*
+//*
+//*                         [ ERROR CODE ENUMERATION ]
+//*
+//*
+//*****************************************************************************
+#ifndef SUCCESS
+#define	SUCCESS  0
+#endif
+
+typedef enum
+{
+	ERR_FWUG_NAND_WRONG_PARAMETER = 0x0C000000,
+	ERR_FWUG_NAND_FAILED_GET_INFO_GMC,
+	ERR_FWUG_NAND_FAILED_GET_SDCFG_FROM_MC,
+	ERR_FWUG_NAND_FAILED_READY_NB_AREA,
+	ERR_FWUG_NAND_FAILED_COPY_IMAGE,
+	ERR_FWUG_NAND_FAILED_SET_START_ADDRESS_IN_GMC,
+	ERR_FWUG_NAND_FAILED_WRITE_MASTER_CLUSTER,
+	ERR_FWUG_NAND_FAILED_ROMFILESIZE_OVER,
+	ERR_FWUG_NAND_FAILED_CHECK_CRC_ROMCODE,
+	ERR_FWUG_NAND_FAILED_WRITE_CODE_DATA,
+	ERR_FWUG_NAND_FAILED_WRITE_MC_DATA,
+	ERR_FWUG_NAND_FAILED_WRITE_GMC_DATA,
+	ERR_FWUG_NAND_FAILED_NO_BMP,
+	ERR_FWUG_NAND_FAILED_NOT_EXIST_NANDBOOT_AREA,
+	ERR_FWUG_NAND_FAILED_CHECK_CRC_MC,
+	ERR_FWUG_NAND_FAILED_NOT_EXIST_NANDBOOT_SIG,
+	ERR_FWUG_NAND_FAILED_NOT_EXIST_MC_DATA,
+	ERR_FWUG_NAND_FAILED_MEM_INITCODESIZE_OVER
+} FWUG_NAND_ERROR;
+
+//*****************************************************************************
+//*
+//*
+//*                       [ EXTERNAL FUCTIONS DEFINE ]
+//*
+//*
+//*****************************************************************************
+extern void					FWUG_NAND_SetParameterForMC( U32 uiSDRAMConfig, U32 uiStExeAddr );
+extern void					FWUG_NAND_SetFlagOfUseSecureMode( U32 nValue );
+extern U32					FWUG_NAND_GetFlagOfUseSecureMode( void );
+extern U8    				FWUG_NAND_GetCurrentNANDType( void );
+extern FWUG_NAND_ERROR 		FWUG_NAND_ClearHDArea( void );
+extern FWUG_NAND_ERROR		FWUG_NAND_PreProcess( U32 uiROMFileSize, U8* pFlagNewBig );
+extern FWUG_NAND_ERROR		FWUG_NAND_PostProcess( U8* nSNBuf, U32 nSNMode, U32 nSecureMode );
+extern FWUG_NAND_ERROR		FWUG_NAND_WriteCodePreProcess( U8 ucNum, U32 uiROMFileSize, U32 *rStBlockOffSet, U32 *rStPageOffSet, U32 nSecureMode );
+#ifdef TNFTL_V7_INCLUDE
+extern FWUG_NAND_ERROR		FWUG_NAND_WriteCodeNAND( U16 nRomNum, U32 nStBlockOffSet, U32 nStPageOffSet, U8 *WriteBufAddr, U32 iBufSize, U32 *rBlockOffSet, U32 *rPageOffSet, U32 nSecureMode );
+#else
+extern FWUG_NAND_ERROR		FWUG_NAND_WriteCodeNAND( U32 nStBlockOffSet, U32 nStPageOffSet, U8* WriteBufAddr, U32 iBufSize, U32 *rBlockOffSet, U32 *rPageOffSet, U32 nSecureMode );
+#endif
+extern FWUG_NAND_ERROR		FWUG_NAND_WriteCodePostProcess( U8 ucNum, U32 nStBlockOffSet, U32 nStPageOffSet );
+extern FWUG_NAND_ERROR		FWUG_NAND_GetSerialNumberNAND( U8* nSID );
+extern unsigned int			FWUG_NAND_CRCUpdate(unsigned char * pBuffer, unsigned int nBufferSize, unsigned int StCRCout, unsigned int nMode, unsigned int nRemainSize);
+
+extern FWUG_NAND_ERROR		FWUG_NAND_LBA_GetSerialNumberNAND( U8* nSID );
+extern void					FWUG_NAND_LBA_InitVariable(U32 nCrc128k, U32 nCrc256k);
+extern FWUG_NAND_ERROR		FWUG_NAND_LBA_WriteCodePreProcess(U8 ucNum, U32 uiROMFileSize, U32 * rStBlockOffSet, U32 * rStPageOffSet, U32 nSecureMode);
+extern FWUG_NAND_ERROR		FWUG_NAND_LBA_WriteCodeNAND(U32 nStBlockOffSet, U32 nStPageOffSet, U8 * WriteBufAddr, U32 iBufSize, U32 * rBlockOffSet, U32 * rPageOffSet, U32 nSecureMode);
+extern FWUG_NAND_ERROR		FWUG_NAND_LBA_WriteMC(unsigned char ucNum);
+extern FWUG_NAND_ERROR 	 	FWUG_NAND_LBA_WriteGMC(U8 * nSNBuf, U32 nSNMode, U32 nSecureMode);
+extern FWUG_NAND_ERROR		FWUG_NAND_LBA_WriteCodetoVFP(U32 nSectorAddr, U8 * WriteBufAddr, U32 iBufSize, U32 * rSectorAddr, U32 nSecureMode);
+extern FWUG_NAND_ERROR		FWUG_NAND_LBA_PostProcess(U8 nMode);
+
+#endif	// _FWUPGRADE_NAND_H_
+
+/* end of file */
+
diff --git a/drivers/block/tcc/inc/tnftl/IO_TCCXXX.h b/drivers/block/tcc/inc/tnftl/IO_TCCXXX.h
new file mode 100644
index 0000000..cb049bd
--- /dev/null
+++ b/drivers/block/tcc/inc/tnftl/IO_TCCXXX.h
@@ -0,0 +1,3872 @@
+/************************************************************************
+*	TELECHIPS Digital Audio Player
+*	------------------------------------------------
+*
+*	FUNCTION	:
+*	MODEL		: TCCXXX
+*	CPU NAME	: TCCXXX
+*	SOURCE		: IO_TCCXXX.h
+*
+*	START DATE	: FEB. 16. 2009
+*	MODIFY DATE	: FEB. 16. 2009
+*	DEVISION	: DEPT. SYSTEM 3 GROUP
+*				: TELECHIPS, INC.
+************************************************************************/
+
+
+/****************************************************************************
+  Revision History
+ ****************************************************************************
+
+ 2009/02/16		: .
+
+ ****************************************************************************/
+
+
+#ifndef	__IO_TCCXXX_H
+#define	__IO_TCCXXX_H
+
+#if defined(_LINUX_) 
+#include <common.h>      
+#endif  
+
+//#define	USE_IO_DEBUG
+
+#if (defined(SDRAM_SIZE) && (SDRAM_SIZE > 0x200000))
+#define	DBG_MAXSTR_TX	0x100000
+#else
+#define	DBG_MAXSTR_TX	0x10
+#endif
+#define	DBG_BUFMASK_TX	(DBG_MAXSTR_TX - 1)
+#define	DBG_MAXSTR_RX	0x10
+
+//#define	USE_DOMEASURE
+//#define	CHECK_SPEED
+#define	LOW_FREQ_PLL_INCLUDE
+
+// Select EHI Slave System among the followings.
+	//#define	EHIS_TCC77X
+	#define	EHIS_TCC75X
+
+//#include "main.h"
+
+#ifdef TCC92XX
+#include "TCC92xx_Physical.h"
+#include "TCC92xx_Structures.h"
+#elif defined(TCC89XX)
+#if defined(_LINUX_)
+#include <mach/TCC89x_Physical.h>
+#include <mach/TCC89x_Structures.h>
+#elif defined(_WINCE_)
+#include "TCC89x_Physical.h"
+#include "TCC89x_Structures.h"
+#endif
+#elif defined(TCC79XX)
+#include "TCC79xx.h"
+#else
+#error "--  Not defined chip models --"
+#endif
+
+
+#ifdef TCC79XX
+	#define	HwSDR_FIX		0x07282000
+	#define	HwSDR_RFR		0
+	#define	HwSDCFG_P0		HwSDCFG
+	#define	HwSDCFG_P1		HwSDCFG
+#elif defined(TCC92XX) || defined(TCC89XX)
+	#define	HwSDR_FIX		0x07282000
+	#define	HwSDR_RFR		0
+	#define	HwSDCFG_P0		HwSDCFG
+	#define	HwSDCFG_P1		HwSDCFG
+#endif
+
+#define	HwSDR_RBC		HwSDCFG_AM_RBC
+
+#define	HwSDR_CL3		HwSDCFG_CL
+
+// SDRAM BusWidth
+#define	HwSDR_X16		Hw30
+#define	HwSDR_X32		HwZERO
+
+// SDRAM Size (Col, Row Address bus width)
+#define	HwSDR_2MB		(HwSDCFG_CW8 + HwSDCFG_RW11)
+#define	HwSDR_4MB		(HwSDCFG_CW8 + HwSDCFG_RW11)
+#define	HwSDR_8MB		(HwSDCFG_CW8 + HwSDCFG_RW12)
+#define	HwSDR_16MB		(HwSDCFG_CW9 + HwSDCFG_RW12)
+#define	HwSDR_32MB		(HwSDCFG_CW9 + HwSDCFG_RW13)
+#define	HwSDR_64MB		(HwSDCFG_CW10 + HwSDCFG_RW13)
+
+
+#if (defined(TELECHIPS_SV) && !defined(USE_IO_DEBUG))
+	//#define	USE_IO_DEBUG
+#endif
+
+#ifndef SET
+	#define	SET			1
+#endif
+#ifndef CLR
+	#define	CLR			0
+#endif
+
+#if defined(_LINUX_)
+#ifndef _U32_
+#define _U32_
+	typedef unsigned int U32;
+#endif
+#ifndef _U16_
+#define _U16_
+	typedef unsigned short U16;
+#endif
+#ifndef _U8_
+#define _U8_
+	typedef unsigned char U8;
+#endif
+#ifndef WINVER
+	#ifndef _BOOL_
+    #define _BOOL_
+		typedef unsigned int BOOL;
+	#endif
+#endif
+#else 
+#ifndef U32
+	typedef unsigned int U32;
+#endif
+#ifndef U16
+	typedef unsigned short U16;
+#endif
+#ifndef U8
+	typedef unsigned char U8;
+#endif
+
+#ifndef WINVER
+	#ifndef BOOL
+		typedef unsigned int BOOL;
+	#endif
+#endif
+#endif
+
+#ifndef S32
+	typedef signed int S32;
+#endif
+#ifndef S16
+	typedef signed short S16;
+#endif
+#ifndef S8
+	typedef signed char S8;
+#endif
+
+typedef	int (*ICallBack)(int num);
+
+/* =============================
+   General Bit Operator
+   ============================= */
+// Bit manipulation macro that is modifying its argument. (task type)
+#ifndef BITSET
+#define	BITSET(X, MASK)				( (X) |= (U32)(MASK) )
+#endif
+#ifndef BITSCLR
+#define	BITSCLR(X, SMASK, CMASK)	( (X) = ((((U32)(X)) | ((U32)(SMASK))) & ~((U32)(CMASK))) )
+#endif
+#ifndef BITCSET
+#define	BITCSET(X, CMASK, SMASK)	( (X) = ((((U32)(X)) & ~((U32)(CMASK))) | ((U32)(SMASK))) )
+#endif
+#ifndef BITCLR
+#define	BITCLR(X, MASK)				( (X) &= ~((U32)(MASK)) )
+#endif
+#ifndef BITXOR
+#define	BITXOR(X, MASK)				( (X) ^= (U32)(MASK) )
+#endif
+
+// Bit manipulation macro that is not modifying its argument. (function type)
+#ifndef fBITSET
+#define	fBITSET(X, MASK)			( (X) | (U32)(MASK) )
+#endif
+#ifndef fBITSCLR
+#define	fBITSCLR(X, SMASK, CMASK)	( ((((U32)(X)) | ((U32)(SMASK))) & ~((U32)(CMASK))) )
+#endif
+#ifndef fBITCSET
+#define	fBITCSET(X, CMASK, SMASK)	( ((((U32)(X)) & ~((U32)(CMASK))) | ((U32)(SMASK))) )
+#endif
+#ifndef fBITCLR
+#define	fBITCLR(X, MASK)			( (X) & ~((U32)(MASK)) )
+#endif
+#ifndef fBITXOR
+#define	fBITXOR(X, MASK)			( (X) ^ (U32)(MASK) )
+#endif
+
+#ifndef ISSET
+#define	ISSET(X, MASK)				( (U32)(X) & ((U32)(MASK)) )
+#endif
+#ifndef IS
+#define	IS(X, MASK)					( (U32)(X) & ((U32)(MASK)) )
+#endif
+#ifndef ISONE
+#define	ISONE(X, MASK)				( (U32)(X) & ((U32)(MASK)) )
+#endif
+
+#ifndef ISALLONE
+#define	ISALLONE(X, MASK)			( ((U32)(X) & ((U32)(MASK))) == ((U32)(MASK)) )
+#endif
+
+#ifndef ISCLR
+#define	ISCLR(X, MASK)				(  !(((U32)(X)) & ((U32)(MASK))) )
+#endif
+#ifndef ISZERO
+#define	ISZERO(X, MASK)				(  !(((U32)(X)) & ((U32)(MASK))) )
+#endif
+#ifndef ISNOT
+#define	ISNOT(X, MASK)				(  !(((U32)(X)) & ((U32)(MASK))) )
+#endif
+
+#ifndef BYTE_OF
+#define	BYTE_OF(X)					( *(volatile unsigned char *)(&(X)) )
+#endif
+#ifndef SHORT_OF
+#define	SHORT_OF(X)					( *(volatile short *)(&(X)) )
+#endif
+#ifndef HWORD_OF
+#define	HWORD_OF(X)					( *(volatile unsigned short *)(&(X)) )
+#endif
+#ifndef WORD_OF
+#define	WORD_OF(X)					( *(volatile unsigned int *)(&(X)) )
+#endif
+
+#ifndef byte_of
+#define	byte_of(X)					( *(volatile unsigned char *)((X)) )
+#endif
+#ifndef short_of
+#define	short_of(X)					( *(volatile short *)((X)) )
+#endif
+#ifndef hword_of
+#define	hword_of(X)					( *(volatile unsigned short *)((X)) )
+#endif
+#ifndef word_of
+#define	word_of(X)					( *(volatile unsigned int *)((X)) )
+#endif
+
+#define	CkWaitPLLLOCK()				{ while (ISCLR(HwPLLMODE, Hw20)); }
+
+#define	SBase(X)					Load$$ ## X ## $$Base
+#define	DBase(X)					Image$$ ## X ## $$Base
+#define	SSize(X)					Image$$ ## X ## $$Length
+#define	ZIBase(X)					Image$$ ## X ## $$ZI$$Base
+#define	ZISize(X)					Image$$ ## X ## $$ZI$$Length
+#define	Region(X)					&SBase(X), &DBase(X), &SSize(X), &ZIBase(X), &ZISize(X)
+#define	ExternRegion(X)				SBase(X), DBase(X), SSize(X), ZIBase(X), ZISize(X)
+
+
+/************************************************************************
+*	Clock Controller
+************************************************************************/
+typedef struct {
+	unsigned			uFpll;
+	unsigned char		P, M, S, dummy;
+} sPLL;
+
+
+enum {
+	XIN_FREQ_120000,
+	XIN_FREQ_480000
+};
+
+enum {
+	IO_CKC_Ftimerx	= 0,
+	IO_CKC_Ftimert,
+	IO_CKC_Ftimerz,
+	IO_CKC_Flcd0,
+	IO_CKC_Flcd1,
+	IO_CKC_Flcdsi,		// 5
+	IO_CKC_Fcifmc,
+	IO_CKC_Fcifsc,
+	IO_CKC_Fout0,
+	IO_CKC_Fout1,
+	IO_CKC_Fhdmi,		// 10
+	IO_CKC_Fdummy,
+	IO_CKC_Fsdmmc0,
+	IO_CKC_Fmstick,
+	IO_CKC_Fi2c,
+	IO_CKC_Fuart0,		// 15
+	IO_CKC_Fuart1,
+	IO_CKC_Fuart2,
+	IO_CKC_Fuart3,
+	IO_CKC_Fuart4,
+	IO_CKC_Fuart5,		// 20
+	IO_CKC_Fgpsb0,
+	IO_CKC_Fgpsb1,
+	IO_CKC_Fgpsb2,
+	IO_CKC_Fgpsb3,
+	IO_CKC_Fgpsb4,		// 25
+	IO_CKC_Fgpsb5,
+	IO_CKC_Fadc,
+	IO_CKC_Fspdif,
+	IO_CKC_Fehi0,
+	IO_CKC_Fehi1,		// 30
+	IO_CKC_Faud,
+	IO_CKC_Fdummy1,
+	IO_CKC_Fdummy2,
+	IO_CKC_Fsdmmc1,
+	IO_CKC_Fdummy3,		// 35
+	IO_CKC_Fdai,
+
+	IO_CKC_Flast
+};
+
+
+/**********************************************************
+*	void IO_CKC_WaitPLL(void);
+*	Input		:
+*	Return		:
+*	Description	: Loop waiting PLL locked.
+**********************************************************/
+#define	IO_CKC_WaitPLL()			{ int i; for (i=0; i<0x1000; i++); }
+
+
+/**********************************************************
+*	void IO_CKC_EnableBUS(unsigned X);
+*	Input		: X = Bitmap dedicated to each peripheral
+*	Return		:
+*	Description	: Enable(1) the bus clock fed to each peripheral.
+*				  The other bus clocks are not influenced.
+**********************************************************/
+#define	IO_CKC_EnableBUS(X)			(BITSET(HwIOBUSCFG->HCLKEN0, (X)))
+#define	IO_CKC_EnableBUS1(X)		(BITSET(HwIOBUSCFG->HCLKEN1, (X)))
+
+/**********************************************************
+*	Derivatives of IO_CKC_EnableBUS() function.
+*	Input		:
+*	Return		:
+*	Description	: Enable the bus clock fed to each peripheral.
+**********************************************************/
+#define IO_CKC_EnableBUS_USB()		(BITSET(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_USB))
+#define IO_CKC_EnableBUS_IDE()		(BITSET(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_IDE))
+#define IO_CKC_EnableBUS_DMA()		(BITSET(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_DMA))
+#define IO_CKC_EnableBUS_SDC()		(BITSET(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_SD))
+#define IO_CKC_EnableBUS_MS()		(BITSET(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_MS))
+#define IO_CKC_EnableBUS_I2C()		(BITSET(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_I2C))
+#define IO_CKC_EnableBUS_NFC()		(BITSET(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_NFC))
+#define IO_CKC_EnableBUS_EHI0()		(BITSET(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_EHI0))
+#define IO_CKC_EnableBUS_EHI1()		(BITSET(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_EHI1))
+#define IO_CKC_EnableBUS_UART0()	(BITSET(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_UART0))
+#define IO_CKC_EnableBUS_UART1()	(BITSET(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_UART1))
+#define IO_CKC_EnableBUS_UART2()	(BITSET(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_UART2))
+#define IO_CKC_EnableBUS_UART3()	(BITSET(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_UART3))
+#define IO_CKC_EnableBUS_UART4()	(BITSET(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_UART4))
+#define IO_CKC_EnableBUS_UART5()	(BITSET(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_UART5))
+#define IO_CKC_EnableBUS_GPSB0()	(BITSET(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_GPSB0))
+#define IO_CKC_EnableBUS_GPSB1()	(BITSET(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_GPSB1))
+#define IO_CKC_EnableBUS_GPSB2()	(BITSET(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_GPSB2))
+#define IO_CKC_EnableBUS_GPSB3()	(BITSET(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_GPSB3))
+#define IO_CKC_EnableBUS_GPSB4()	(BITSET(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_GPSB4))
+#define IO_CKC_EnableBUS_GPSB5()	(BITSET(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_GPSB5))
+#define IO_CKC_EnableBUS_DAI()		(BITSET(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_DAI))
+#define IO_CKC_EnableBUS_ECC()		(BITSET(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_ECC))
+#define IO_CKC_EnableBUS_SPDIF()	(BITSET(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_SPDIF))
+#define IO_CKC_EnableBUS_RTC()		(BITSET(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_RTC))
+#define IO_CKC_EnableBUS_TSADC()	(BITSET(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_TSADC))
+#define IO_CKC_EnableBUS_GPS()		(BITSET(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_GPS))
+#define IO_CKC_EnableBUS_ADMA()		(BITSET(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_ADMA))
+#define IO_CKC_EnableBUS_MPE()		(BITSET(HwIOBUSCFG->HCLKEN1, HwIOBUSCFG_MPE))
+#define IO_CKC_EnableBUS_TSIF()		(BITSET(HwIOBUSCFG->HCLKEN1, HwIOBUSCFG_TSIF))
+#define IO_CKC_EnableBUS_SRAM()		(BITSET(HwIOBUSCFG->HCLKEN1, HwIOBUSCFG_SRAM))
+
+
+/**********************************************************
+*	void IO_CKC_DisableBUS(unsigned X);
+*	Input		: X = Bitmap dedicated to each peripheral
+*	Return		:
+*	Description	: Disable(1) the bus clock fed to each peripheral.
+*				  The other bus clocks are not influenced.
+**********************************************************/
+#define	IO_CKC_DisableBUS(X)		(BITCLR(HwIOBUSCFG->HCLKEN0, X))
+#define	IO_CKC_DisableBUS1(X)		(BITCLR(HwIOBUSCFG->HCLKEN1, (X)))
+
+/**********************************************************
+*	Derivatives of IO_CKC_DisableBUS() function.
+*	Input		:
+*	Return		:
+*	Description	: Disable the bus clock fed to each peripheral.
+**********************************************************/
+#define IO_CKC_DisableBUS_USB()		(BITCLR(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_USB))
+#define IO_CKC_DisableBUS_IDE()		(BITCLR(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_IDE))
+#define IO_CKC_DisableBUS_DMA()		(BITCLR(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_DMA))
+#define IO_CKC_DisableBUS_SDC()		(BITCLR(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_SD))
+#define IO_CKC_DisableBUS_MS()		(BITCLR(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_MS))
+#define IO_CKC_DisableBUS_I2C()		(BITCLR(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_I2C))
+#define IO_CKC_DisableBUS_NFC()		(BITCLR(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_NFC))
+#define IO_CKC_DisableBUS_EHI0()	(BITCLR(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_EHI0))
+#define IO_CKC_DisableBUS_EHI1()	(BITCLR(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_EHI1))
+#define IO_CKC_DisableBUS_UART0()	(BITCLR(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_UART0))
+#define IO_CKC_DisableBUS_UART1()	(BITCLR(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_UART1))
+#define IO_CKC_DisableBUS_UART2()	(BITCLR(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_UART2))
+#define IO_CKC_DisableBUS_UART3()	(BITCLR(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_UART3))
+#define IO_CKC_DisableBUS_UART4()	(BITCLR(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_UART4))
+#define IO_CKC_DisableBUS_UART5()	(BITCLR(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_UART5))
+#define IO_CKC_DisableBUS_GPSB0()	(BITCLR(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_GPSB0))
+#define IO_CKC_DisableBUS_GPSB1()	(BITCLR(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_GPSB1))
+#define IO_CKC_DisableBUS_GPSB2()	(BITCLR(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_GPSB2))
+#define IO_CKC_DisableBUS_GPSB3()	(BITCLR(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_GPSB3))
+#define IO_CKC_DisableBUS_GPSB4()	(BITCLR(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_GPSB4))
+#define IO_CKC_DisableBUS_GPSB5()	(BITCLR(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_GPSB5))
+#define IO_CKC_DisableBUS_DAI()		(BITCLR(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_DAI))
+#define IO_CKC_DisableBUS_ECC()		(BITCLR(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_ECC))
+#define IO_CKC_DisableBUS_SPDIF()	(BITCLR(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_SPDIF))
+#define IO_CKC_DisableBUS_RTC()		(BITCLR(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_RTC))
+#define IO_CKC_DisableBUS_TSADC()	(BITCLR(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_TSADC))
+#define IO_CKC_DisableBUS_GPS()		(BITCLR(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_GPS))
+#define IO_CKC_DisableBUS_ADMA()	(BITCLR(HwIOBUSCFG->HCLKEN0, HwIOBUSCFG_ADMA))
+#define IO_CKC_DisableBUS_MPE()		(BITCLR(HwIOBUSCFG->HCLKEN1, HwIOBUSCFG_MPE))
+#define IO_CKC_DisableBUS_TSIF()	(BITCLR(HwIOBUSCFG->HCLKEN1, HwIOBUSCFG_TSIF))
+#define IO_CKC_DisableBUS_SRAM()	(BITCLR(HwIOBUSCFG->HCLKEN1, HwIOBUSCFG_SRAM))
+
+// IOBUS AHB 0
+#define IO_CKC_BUS_USB				HwIOBUSCFG_USB
+#define IO_CKC_BUS_IDE				HwIOBUSCFG_IDE
+#define IO_CKC_BUS_DMA				HwIOBUSCFG_DMA
+#define IO_CKC_BUS_SD				HwIOBUSCFG_SD
+#define IO_CKC_BUS_MS				HwIOBUSCFG_MS
+#define IO_CKC_BUS_I2C				HwIOBUSCFG_I2C
+#define IO_CKC_BUS_NFC				HwIOBUSCFG_NFC
+#define IO_CKC_BUS_EHI0				HwIOBUSCFG_EHI0
+#define IO_CKC_BUS_EHI1				HwIOBUSCFG_EHI1
+#define IO_CKC_BUS_UART0			HwIOBUSCFG_UART0
+#define IO_CKC_BUS_UART1			HwIOBUSCFG_UART1
+#define IO_CKC_BUS_UART2			HwIOBUSCFG_UART2
+#define IO_CKC_BUS_UART3			HwIOBUSCFG_UART3
+#define IO_CKC_BUS_UART4			HwIOBUSCFG_UART4
+#define IO_CKC_BUS_UART5			HwIOBUSCFG_UART5
+#define IO_CKC_BUS_GPSB0			HwIOBUSCFG_GPSB0
+#define IO_CKC_BUS_GPSB1			HwIOBUSCFG_GPSB1
+#define IO_CKC_BUS_GPSB2			HwIOBUSCFG_GPSB2
+#define IO_CKC_BUS_GPSB3			HwIOBUSCFG_GPSB3
+#define IO_CKC_BUS_GPSB4			HwIOBUSCFG_GPSB4
+#define IO_CKC_BUS_GPSB5			HwIOBUSCFG_GPSB5
+#define IO_CKC_BUS_DAI				HwIOBUSCFG_DAI
+#define IO_CKC_BUS_ECC				HwIOBUSCFG_ECC
+#define IO_CKC_BUS_SPDIF			HwIOBUSCFG_SPDIF
+#define IO_CKC_BUS_RTC				HwIOBUSCFG_RTC
+#define IO_CKC_BUS_TSADC			HwIOBUSCFG_TSADC
+#define IO_CKC_BUS_GPS				HwIOBUSCFG_GPS
+#define IO_CKC_BUS_ADMA				HwIOBUSCFG_ADMA
+
+// IOBUS AHB 1
+#define IO_CKC_BUS_MPE				HwIOBUSCFG_MPE
+#define IO_CKC_BUS_TSIF				HwIOBUSCFG_TSIF
+#define IO_CKC_BUS_SRAM				HwIOBUSCFG_SRAM
+
+
+/**********************************************************
+*	void IO_CKC_SWRST(unsigned X);
+*	Input		: X = Bitmap dedicated to each peripheral
+*	Return		:
+*	Description	: Make a reset signal for each peripheral.
+*				  Set a corresponding bit field to make a reset signal to each peripheral.
+**********************************************************/
+#ifdef TCC92XX
+#else  /* TCC92XX */
+#define	IO_CKC_SWRST(X)				(HwSWRESET	= (X))
+#endif /* TCC92XX */
+
+#ifndef _LINUX_
+#pragma warning( push )
+#pragma warning( disable: 4341 )		// enum --> unsigned longlong...X
+#pragma warning( disable: 4309 )
+#endif
+enum {
+	IO_CKC_TMRX		= Hw0,
+	IO_CKC_TMRT		= Hw1,
+	IO_CKC_TMRZ		= Hw2,
+	IO_CKC_LCD0		= Hw3,
+	IO_CKC_LCD1		= Hw4,
+	IO_CKC_LCDSI	= Hw5,
+	IO_CKC_CIFMC	= Hw6,
+	IO_CKC_CIFSC	= Hw7,
+	IO_CKC_OUT0		= Hw8,
+	IO_CKC_OUT1		= Hw9,
+	IO_CKC_HDMI		= Hw10,
+	IO_CKC_SDMMC0	= Hw12,
+	IO_CKC_MSTICK	= Hw13,
+	IO_CKC_I2C		= Hw14,
+	IO_CKC_UART0	= Hw15,
+	IO_CKC_UART1	= Hw16,
+	IO_CKC_UART2	= Hw17,
+	IO_CKC_UART3	= Hw18,
+	IO_CKC_UART4	= Hw19,
+	IO_CKC_UART5	= Hw20,
+	IO_CKC_GPSB0	= Hw21,
+	IO_CKC_GPSB1	= Hw22,
+	IO_CKC_GPSB2	= Hw23,
+	IO_CKC_GPSB3	= Hw24,
+	IO_CKC_GPSB4	= Hw25,
+	IO_CKC_GPSB5	= Hw26,
+	IO_CKC_ADC		= Hw27,		// PCK_YYY
+	IO_CKC_SPDIF	= Hw28,		// PCK_YYY
+	IO_CKC_EHI0		= Hw29,
+	IO_CKC_EHI1		= Hw30,
+	IO_CKC_AUD		= Hw31,		// PCK_YYY
+	IO_CKC_SDMMC1	= Hw34,
+	IO_CKC_DAI		= Hw36		// PCK_YYY
+};
+#ifndef _LINUX_
+#pragma warning( pop )
+#endif
+
+#define	IO_CKC_EnableClock(x)									\
+{																\
+	if ((x) & IO_CKC_TMRX)										\
+		BITSET(HwCKC->PCLK_TCX, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_TMRT)										\
+		BITSET(HwCKC->PCLK_TCT, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_TMRZ)					\
+		BITSET(HwCKC->PCLK_TCZ, HwPCK_EN_EN);		\
+	if ((x) & IO_CKC_LCD0)					\
+		BITSET(HwCKC->PCLK_LCD0, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_LCD1)					\
+		BITSET(HwCKC->PCLK_LCD1, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_LCDSI)					\
+		BITSET(HwCKC->PCLK_LCDSI, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_CIFMC)					\
+		BITSET(HwCKC->PCLK_CIFMC, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_CIFSC)					\
+		BITSET(HwCKC->PCLK_CIFSC, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_OUT0)					\
+		BITSET(HwCKC->PCLK_OUT0, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_OUT1)					\
+		BITSET(HwCKC->PCLK_OUT1, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_HDMI)					\
+		BITSET(HwCKC->PCLK_HDMI, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_SDMMC0)				\
+		BITSET(HwCKC->PCLK_SDMMC0, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_MSTICK)				\
+		BITSET(HwCKC->PCLK_MSTICK, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_I2C)					\
+		BITSET(HwCKC->PCLK_I2C, HwPCK_EN_EN);		\
+	if ((x) & IO_CKC_UART0)					\
+		BITSET(HwCKC->PCLK_UART0, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_UART1)					\
+		BITSET(HwCKC->PCLK_UART1, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_UART2)					\
+		BITSET(HwCKC->PCLK_UART2, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_UART3)					\
+		BITSET(HwCKC->PCLK_UART3, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_UART4)					\
+		BITSET(HwCKC->PCLK_UART4, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_UART5)					\
+		BITSET(HwCKC->PCLK_UART5, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_GPSB0)					\
+		BITSET(HwCKC->PCLK_GPSB0, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_GPSB1)					\
+		BITSET(HwCKC->PCLK_GPSB1, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_GPSB2)					\
+		BITSET(HwCKC->PCLK_GPSB2, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_GPSB3)					\
+		BITSET(HwCKC->PCLK_GPSB3, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_GPSB4)					\
+		BITSET(HwCKC->PCLK_GPSB4, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_GPSB5)					\
+		BITSET(HwCKC->PCLK_GPSB5, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_ADC)					\
+		BITSET(HwCKC->PCLK_ADC, HwPCK_EN_EN);		\
+	if ((x) & IO_CKC_SPDIF)					\
+		BITSET(HwCKC->PCLK_SPDIF, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_EHI0)					\
+		BITSET(HwCKC->PCLK_EHI0, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_EHI1)					\
+		BITSET(HwCKC->PCLK_EHI1, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_AUD)					\
+		BITSET(HwCKC->PCLK_AUD, HwPCK_EN_EN);		\
+	if ((x) & IO_CKC_SDMMC1)				\
+		BITSET(HwCKC->PCLK_SDMMC1, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_DAI)					\
+		BITSET(HwCKC->PCLK_DAI, HwPCK_EN_EN);		\
+}
+
+#define	IO_CKC_DisableClock(x)				\
+{											\
+	if ((x) & IO_CKC_TMRX)					\
+		BITCLR(HwCKC->PCLK_TCX, HwPCK_EN_EN);		\
+	if ((x) & IO_CKC_TMRT)					\
+		BITCLR(HwCKC->PCLK_TCT, HwPCK_EN_EN);		\
+	if ((x) & IO_CKC_TMRZ)					\
+		BITCLR(HwCKC->PCLK_TCZ, HwPCK_EN_EN);		\
+	if ((x) & IO_CKC_LCD0)					\
+		BITCLR(HwCKC->PCLK_LCD0, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_LCD1)					\
+		BITCLR(HwCKC->PCLK_LCD1, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_LCDSI)					\
+		BITCLR(HwCKC->PCLK_LCDSI, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_CIFMC)					\
+		BITCLR(HwCKC->PCLK_CIFMC, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_CIFSC)					\
+		BITCLR(HwCKC->PCLK_CIFSC, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_OUT0)					\
+		BITCLR(HwCKC->PCLK_OUT0, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_OUT1)					\
+		BITCLR(HwCKC->PCLK_OUT1, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_HDMI)					\
+		BITCLR(HwCKC->PCLK_HDMI, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_SDMMC0)				\
+		BITCLR(HwCKC->PCLK_SDMMC0, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_MSTICK)				\
+		BITCLR(HwCKC->PCLK_MSTICK, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_I2C)					\
+		BITCLR(HwCKC->PCLK_I2C, HwPCK_EN_EN);		\
+	if ((x) & IO_CKC_UART0)					\
+		BITCLR(HwCKC->PCLK_UART0, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_UART1)					\
+		BITCLR(HwCKC->PCLK_UART1, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_UART2)					\
+		BITCLR(HwCKC->PCLK_UART2, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_UART3)					\
+		BITCLR(HwCKC->PCLK_UART3, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_UART4)					\
+		BITCLR(HwCKC->PCLK_UART4, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_UART5)					\
+		BITCLR(HwCKC->PCLK_UART5, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_GPSB0)					\
+		BITCLR(HwCKC->PCLK_GPSB0, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_GPSB1)					\
+		BITCLR(HwCKC->PCLK_GPSB1, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_GPSB2)					\
+		BITCLR(HwCKC->PCLK_GPSB2, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_GPSB3)					\
+		BITCLR(HwCKC->PCLK_GPSB3, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_GPSB4)					\
+		BITCLR(HwCKC->PCLK_GPSB4, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_GPSB5)					\
+		BITCLR(HwCKC->PCLK_GPSB5, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_ADC)					\
+		BITCLR(HwCKC->PCLK_ADC, HwPCK_EN_EN);		\
+	if ((x) & IO_CKC_SPDIF)					\
+		BITCLR(HwCKC->PCLK_SPDIF, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_EHI0)					\
+		BITCLR(HwCKC->PCLK_EHI0, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_EHI1)					\
+		BITCLR(HwCKC->PCLK_EHI1, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_AUD)					\
+		BITCLR(HwCKC->PCLK_AUD, HwPCK_EN_EN);		\
+	if ((x) & IO_CKC_SDMMC1)				\
+		BITCLR(HwCKC->PCLK_SDMMC1, HwPCK_EN_EN);	\
+	if ((x) & IO_CKC_DAI)					\
+		BITCLR(HwCKC->PCLK_DAI, HwPCK_EN_EN);		\
+}
+
+
+/************************************************************************
+*	Function Declaration (Clock Controller)
+************************************************************************/
+/**********************************************************
+*	void IO_CKC_EnterStandbyInt(unsigned uMode)
+*
+*	Input		: uMode = wake-up event selection
+*				     0 : using XIN clock (that means program stops here until wake-up event is occurred.)
+*					In this mode, only external interrupt can wake up system. but may be unstable while waking up.
+*					NOT RECOMMENDED.
+*				     non-zero : using XTIN clock.
+*					In this mode, program continues but polling predefined wake-up interrupt.
+*					the wake-up interrupt can be defined by this value of 'uMode'
+*					this represents bitmap of wake-up interrupt sources.
+*	Return		:
+*	Description	: Enter Standby Mode (All clocks except XTIN are stopped.)
+*				  This function is located in IO_LIB_INT area and
+*				  it should be located in the internal SRAM.
+*********************************************************/
+void IO_CKC_EnterStandbyInt(unsigned uMode);
+
+enum
+{
+	SPEED_MODE_0	= 0,
+	#ifdef SPEED_MODE_INCLUDE
+		SPEED_MODE_1,
+		SPEED_MODE_2,
+		SPEED_MODE_3,
+	#endif
+	MAX_SPEED_MODE
+};
+
+typedef struct {
+	unsigned	uFmaxpll;
+	unsigned	uFmaxcpu;
+	unsigned	uFmaxbus;
+	unsigned	uFpll[3];		// for 32KHz, 44.1KHz, 48KHz
+
+	/*for chaning max clock by speed mode
+	*/
+	unsigned        uHighpll; //unit : 100hz
+	unsigned short	uHighcpu; //unit : Mhz
+	unsigned short	uHighbus; //unit : Mhz	
+} sIO_CKC_SPD_MODE;
+
+/**********************************************************
+*	void IO_CKC_InitVariable(int iFmax, int iHmax);
+*
+*	Input		: iFmax = Maximum frequency of CPU clock (100Hz unit)
+*				  iHmax = Maximum frequency of BUS clock (100Hz unit)
+*	Return		:
+*	Description	: Initialize Global Variables for Clock Driver
+**********************************************************/
+#if defined(TCC79XX) || defined(TCC92XX) || defined(TCC89XX)
+	#define	IO_CKC_Fmaxcpu		PLL_FREQ
+	#define	IO_CKC_Fmaxbus		(PLL_FREQ/2)
+
+	#define	IO_CKC_Fxin			120000
+
+	#define	IO_CKC_Fpll_32KHz	PLL_FREQ
+	#define	IO_CKC_Fpll_44KHz	PLL_FREQ
+	#define	IO_CKC_Fpll_48KHz	PLL_FREQ
+#endif
+
+/**********************************************************
+*	void IO_CKC_InitDRV(void);
+*
+*	Input		: 
+*	Output		:
+*	Return		:
+*
+*	Description	: Initialize Global Variables for Clock Driver
+**********************************************************/
+void IO_CKC_InitDRV(void);
+
+/**********************************************************
+*	void IO_CKC_DisablePLL(unsigned uCH)
+*
+*	Input		: uCH = Channel of PLL (0 or 1)
+*	Output		:
+*	Return		:
+*
+*	Description	: 
+*
+**********************************************************/
+void IO_CKC_DisablePLL(unsigned uCH);
+
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      int IO_CKC_SelectSpeedMode(unsigned uSpeedMode);
+*  
+*  DESCRIPTION : Select System Speed Mode (Supported only by pull-up the supply voltage for CORE)
+*  
+*  INPUT:
+*			uSpeedMode = Index of Speed Mode. (Refer sIO_CKC_SpeedMode[] Table)
+*  
+*  OUTPUT:	int - Return Type
+*  			= -1 : Requested Speed Mode is not supported.
+*			= 0 : Mode change successful.
+*  
+*  REMARK:	created on 2007/6/28    22:31:46
+**************************************************************************/
+int IO_CKC_SelectSpeedMode(unsigned uSpeedMode);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      unsigned IO_CKC_CalcBUS4CYCLE(unsigned uNewBusFreq);
+*  
+*  DESCRIPTION : Map real bus clock frequency to reference bus clock frequency
+*			Reference bus clock frequency should be always higher or equal than real bus clock
+*			to insert marginal cycles for stability.
+*  
+*  INPUT:
+*			uNewBusFreq	= Real bus frequency
+*  
+*  OUTPUT:	unsigned - Return Type
+*  			= Reference bus frequency
+*  
+**************************************************************************/
+unsigned IO_CKC_CalcBUS4CYCLE(unsigned uNewBusFreq);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      unsigned IO_CKC_SetCYCLE(unsigned uNewBusFreq, unsigned uPosition);
+*  
+*  DESCRIPTION : Set Cycle Parameter for Peripherals which use Bus Clock.
+*  
+*  INPUT:
+*			uNewBusFreq	= New Bus Clock Frequency (100 Hz unit)
+*			uPosition	= Indicate position of calling this function
+*					  1 : Before changing Bus Clock, 2 : After changing Bus Clock
+*  
+*  OUTPUT:	unsigned - Return Type
+*  			= Old Bus Clock Frequency 
+*			  (not real bus clock but reference bus clock for calculating cycle parameters)
+*  
+**************************************************************************/
+unsigned IO_CKC_SetCYCLE(unsigned uNewBusFreq, unsigned uPosition);
+
+/**********************************************************
+*      void IO_CKC_AdjustClock(int Fmax, int Vmax, int Hmax, int Fmin, int Vmin, int Hmin, int iFclk, int iVclk, int iHclk);
+*
+*	Description	: Increasing/Decreasing System Clock (CPU, VCORE, BUS)
+*				  (iFclk, iVclk, iHclk) means division/multiplication factor (not frequency)
+*
+*  INPUT:
+*			Fmax	= Maximum Frequency for CPU clock
+*			Vmax	= Maximum Frequency for VCORE clock
+*			Hmax	= Maximum Frequency for BUS clock
+*			Fmin	= Minimum Frequency for CPU clock
+*			Vmin	= Minimum Frequency for VCORE clock
+*			Hmin	= Minimum Frequency for BUS clock
+*			iFclk	= CPU clock delta index (1~15 for increasing clock, -1~-15 for decreasing clock, 0 for holding)
+*			iVclk	= VCore clock delta index (1~15 for increasing clock, -1~-15 for decreasing clock, 0 for holding)
+*			iHclk	= BUS clock delta index (1~31 for increasing clock, -1~-31 for decreasing clock, 0 for holding)
+*
+*	Assumption	: Source clock (XIN or PLL) must be alive.
+*	Output		:
+*	Return		:
+*
+**********************************************************/
+void IO_CKC_AdjustClock(int Fmax, int Vmax, int Hmax, int Fmin, int Vmin, int Hmin, int iFclk, int iVclk, int iHclk);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      unsigned IO_CKC_GetCurrentBUSClock4Cycle(void);
+*  
+*  DESCRIPTION : Returns current reference bus clock frequency
+*				All the peripherals (like NAND, NOR, HDD, etc.) use bus clock 
+*				should refer this value to calculate cycle parameters.
+*  
+*  INPUT:
+*			None
+*  
+*  OUTPUT:	unsigned - Return Type
+*  			= current reference bus clock frequency
+*  
+**************************************************************************/
+unsigned IO_CKC_GetCurrentBUSClock4Cycle(void);
+
+/**********************************************************
+*	void IO_CKC_InitPLL(unsigned uCH, unsigned uPLL);
+*
+*	Input		: uPLL = target frequency of PLL (100Hz unit)
+*	Return		:
+*	Description	: call IO_CKC_SetPLL() according to frequency value
+*				  currently supported frequency. (default = 240MHz)
+*					240MHz, 120MHz, 248.5714MHz, 203.1428MHz
+*					221.1428MHz, 196.5MHz
+*
+*				  After PLL set, it is tryed to maintain the frequencies of all clocks.
+*				  If certain clock is not possible to be maintained,
+*					the clock frequency is set as close as previous one.
+**********************************************************/
+void IO_CKC_InitPLL(unsigned uCH, unsigned uPLL);
+
+/**********************************************************
+*	void IO_CKC_SetPLL(unsigned uCH, int iP, int iM, int iS);
+*
+*	Input		: iP, iM, iS
+*	Return		:
+*	Description	: Set PLL according to PMS value, and wait until PLL is stable.
+*					Fpll = Fxin * (iM + 8) / ((iP + 2) * 2^iS)
+*				  (The combination of (P, M, S) should be confirmed before used)
+*
+*				  After PLL set, It is tryed to maintain the frequencies of all clocks.
+*				  If certain clock is not possible to be maintained,
+*					the clock frequency is set as close as previous one.
+**********************************************************/
+void IO_CKC_SetPLL(unsigned uCH, int iP, int iM, int iS);
+
+/**********************************************************
+*	void IO_CKC_SetClock(unsigned uPLLCH, unsigned uCKCCH, int iFclk)
+*
+*	Input		: uPLLCH = PLL channel index
+*				  uCKCCH = Clock channel index
+*				  iFclk = Freq. of uCKCCH Unit., 100Hz unit
+*	Assumption	: Source clock (XIN or PLL) must be alive.
+*				  (If XTIN is currently used, make sure XIN or PLL alive before calling this function)
+*	Return		:
+*	Description	: Set System Clock
+*				  If target frequency exceeds its own max frequency (gCKC_Fmax]),
+*				  the uIO_CKC_error flag is incremented, and system clock is not changed.
+*				  If the frequency requested can not be set exactly,
+*					this function set the frequency as close as possible.
+*					(refer to the datasheet for possible system clock relationship.)
+*				  The system clock source is selected according to the following rule.
+*					1) if (Fclk >= Fpll) PLL is selected.
+*					2) if (Fclk > Fxin) PLL divider is selected.
+*					3) if (Fclk == Fxin) XIN is selected.
+*					4) if (Fclk > Fxtin) XIN divider is selected.
+*					5) if (Fclk == Fxtin) XTIN is selected.
+*					6) other case, XTIN divider is selected.
+**********************************************************/
+void IO_CKC_SetClock(unsigned uPLLCH, unsigned uCKCCH, int iFclk);
+
+/**********************************************************
+*	void void IO_CKC_SetClockMul(unsigned uPLLCH, unsigned uCKCCH, int iSdiv, int iFdiv, int iSrc)
+*
+*	Input		: uPLLCH = PLL channel index
+*				  uCKCCH = Clock channel index
+*				  iSdiv = System clock division (= Fpll / Fsys)
+*				  iFdiv = Fsys / Fclk (can be one of 2~32)
+*				  iSrc = Fsys clock source selection
+*	Assumption	: Source clock (XIN/XTIN/PLL) must be alive.
+*	Output		:
+*	Return		:
+*
+*	Description	: Set Clock.
+**********************************************************/
+void IO_CKC_SetClockMul(unsigned uPLLCH, unsigned uCKCCH, int iSdiv, int iFdiv, int iSrc);
+
+/**********************************************************
+*	unsigned IO_CKC_GetMinimumBusClock(unsigned uLCTRL);
+*
+*	Input		: LCDC LCTRL value ( register or variable )
+*	Assumption	: 
+*	Output		:
+*	Return		: minimum bus clock frequency (100 Hz unit)
+*
+*	Description	: Get minimum bus clock frequency.
+**********************************************************/
+unsigned IO_CKC_GetMinimumBusClock(unsigned uLCTRL);
+
+/**********************************************************
+*	void IO_CKC_SetClockDiv(int iFclk, int iHclk, int iSrc);
+*
+*	Input		: iFclk = Division Factor for CPU clock (acquired by Fsrc / Fcpu)
+*				  iHclk = Division Factor for BUS clock (acquired by Fcpu / Fbus)
+*				  iSrc = Clock source definition (same as CKSEL[2:0] of HwCLKCTRL register)
+*	Assumption	: Source clock (XIN/PLL/XTIN) must be alive.
+*				  (If XTIN is currently used, make sure XIN or PLL alive before calling this function)
+*	Return		:
+*	Description	: Set System Clock (CPU, BUS) as follows.
+*				  Frequency of CPU clock (Fcpu) = Fsrc / iFclk. (Fsrc = Frequency of source clock selected by iSrc parameter)
+*				  Frequency of BUS clock (Fbus) = Fcpu / iHclk.
+**********************************************************/
+#ifdef CPU_CLOCK_DIV_USED
+void IO_CKC_SetClockDiv(int iFdiv, int iHdiv, int iCCKdiv, int iSrc);
+#else
+void IO_CKC_SetClockDiv(int iFdiv, int iHdiv, int iSrc);
+#endif
+
+/**********************************************************
+*	unsigned IO_CKC_GetCurrentBUSClock(void);
+*
+*	Input		:
+*	Return		: Frequency of Current BUS Clock (100Hz unit)
+*	Description	: Return the current bus clock frequency
+**********************************************************/
+unsigned IO_CKC_GetCurrentBUSClock(void);
+
+/**********************************************************
+*	void IO_CKC_EnterHalt(unsigned uSDEN);
+*
+*	Input		: uSDEN = option for SDRAM control
+*					0 = don't touch sdram
+*					1 = control SDRAM, (enter self-refresh mode during halt)
+*	Return		:
+*	Description	: Enter Halt Mode
+*				  In Halt mode, only CPU halts until interrupt request occurred.
+************************************************************/
+void IO_CKC_EnterHalt(unsigned uSDEN);
+void IO_CKC_EnterHalt_Main(void);
+void IO_CKC_EnterHalt_End(void);
+
+/**********************************************************
+*	void IO_CKC_SetRefreshClock(int iFreq);
+*
+*	Input		: iFreq = Frequency of Refresh Clock, 100Hz unit
+*				  Clock disabled if iFreq == 0.
+*	Return		:
+*	Description	: Set Refresh clock frequency and Enable refresh clock
+*				  It is assumed that the BUS clock freq is larger than half of XIN frequency.
+*				  The refresh clock is implicitely driven by XIN clock.
+***********************************************************/
+void IO_CKC_SetRefreshClock(int iFreq);
+
+/**********************************************************
+*	void IO_CKC_SetUSBHostClock(void);
+*
+*	Input		:
+*	Return		:
+*	Description	: Enable USB Host Clock, it is fixed to use XIN as USB Host clock
+***********************************************************/
+void IO_CKC_SetUSBHostClock(void);
+
+/**********************************************************
+*	void IO_CKC_SetI2CClock(int iFreq);
+*
+*	Input		: iFreq = Frequency of I2C Main Clock, 100Hz unit
+*				  Clock disabled if iFreq == 0.
+*	Return		:
+*	Description	: Set frequency and Enable I2C main Clock
+*				  The real I2C clock (SCL) frequency is determined by prescale register of I2C block.
+*				  The I2C main clock is implicitely driven by XIN clock.
+***********************************************************/
+void IO_CKC_SetI2CClock(int iFreq);
+
+/**********************************************************
+*	void IO_CKC_SetMSCClock(int iFreq);
+*
+*	Input		: iFreq = Frequency of MemoryStic Controller clock, 100Hz unit
+*				  Clock disabled if iFreq == 0.
+*	Return		:
+*	Description	: Set frequency and Enable Memory Stick Controller Clock
+*				  The memory stic controller clock is implicitely driven by PLL clock.
+***********************************************************/
+void IO_CKC_SetMSCClock(int iFreq);
+
+/**********************************************************
+*	void IO_CKC_SetUA0Clock(int iFreq);
+*	void IO_CKC_SetUA1Clock(int iFreq);
+*	void IO_CKC_SetUA2Clock(int iFreq);
+*	void IO_CKC_SetUA3Clock(int iFreq);
+*
+*	Input		: iFreq = Frequency of UART clock, 100Hz unit
+*				  Clock disabled if iFreq == 0.
+*	Return		:
+*	Description	: Set frequency and Enable UART Clock
+*				  The baud rate of UART is determined by DL register of UART block
+*				  The UART clock is implicitely driven by PLL clock.
+***********************************************************/
+void IO_CKC_SetUartClock(int iCH, int iFreq);
+void IO_CKC_SetUA0Clock(int iFreq);
+void IO_CKC_SetUA1Clock(int iFreq);
+void IO_CKC_SetUA2Clock(int iFreq);
+void IO_CKC_SetUA3Clock(int iFreq);
+
+/**********************************************************
+*	void IO_CKC_SetTimerTClock(int iFreq);
+*
+*	Input		: iFreq = Frequency of Timer-T clock, 100Hz unit
+*				  Clock disabled if iFreq == 0.
+*	Return		:
+*	Description	: Set frequency and Enable Timer-T Clock
+*				  The timer-T clock manages 6 timer/counters
+*				  (refer to datasheet)
+*				  The Timer-T clock is implicitely driven by XIN clock.
+***********************************************************/
+void IO_CKC_SetTimerTClock(int iFreq);
+
+/**********************************************************
+*	void IO_CKC_SetGSIOClock(int iFreq);
+*
+*	Input		: iFreq = Frequency of GSIO base clock, 100Hz unit
+*				  Clock disabled if iFreq == 0.
+*	Return		:
+*	Description	: Set frequency and Enable GSIO base clock
+*				  The real GSIO clock (SCK) is determined by speed control field of GSCRx register.
+*				  (refer to datasheet)
+***********************************************************/
+void IO_CKC_SetGSIOClock(int iFreq);
+
+
+/**********************************************************
+*	void IO_TC32_SetTIMER(unsigned uCTRL, unsigned uFreq, unsigned uLOADVAL, unsigned uCMP0, unsigned uCMP1);
+*
+*	Input		: uCTRL = TC32 Control Register (HwTC32EN) value except Pre-scale value.
+*				  uICTRL = TC32 Interrupt Control Register (HwTC32IRQ) value.
+*				  uFreq = TC32 counting frequency to set up pre-scale value. (TC32 clock should be set ahead)
+*				  uLOADVAL = load value (HwTC32LDV)
+*				  uCMP0 = Match value 0 (HwTC32CMP0).
+*				  uCMP1 = Match value 1 (HwTC32CMP1).
+*	Return		:
+*	Description	: Set TC32 timer (timer is enabled if uFreq > 0, or timer is disabled)
+*				  If uFreq < Freq(TimerZ clock), then TC32 is counted by TimerZ clock directly.
+**********************************************************/
+void IO_TC32_SetTIMER(unsigned uCTRL, unsigned uICTRL, unsigned uFreq, unsigned uLOADVAL, unsigned uCMP0, unsigned uCMP1);
+
+/**********************************************************
+*	void IO_CKC_SetTimerZClock(int iFreq);
+*
+*	Input		: iFreq = Frequency of Timer-Z clock, 100Hz unit
+*				  Clock disabled if iFreq == 0.
+*	Return		:
+*	Description	: Set frequency and Enable Timer-Z Clock
+*				  The timer-Z clock manages TC32 counter block
+*				  (refer to datasheet)
+*				  The Timer-Z clock is implicitely driven by XTIN clock.
+***********************************************************/
+void IO_CKC_SetTimerZClock(int iFreq);
+
+/**********************************************************
+*	void IO_CKC_SetTimerXClock(int iFreq);
+*
+*	Input		: iFreq = Frequency of Timer-X clock, 100Hz unit
+*				  Clock disabled if iFreq == 0.
+*	Return		:
+*	Description	: Set frequency and Enable Timer-X Clock
+*				  The timer-X clock manages watchdog counter block
+*				  (refer to datasheet)
+*				  The Timer-X clock is implicitely driven by XIN clock.
+***********************************************************/
+void IO_CKC_SetTimerXClock(int iFreq);
+
+/**********************************************************
+*	void IO_CKC_SetDAIClock(int iFreq);
+*
+*	Input		: iFreq = Frequency of DAI Main Clock (100Hz unit)
+*				  Clock disabled if iFreq == 0.
+*	Return		:
+*	Description	: Set frequency and Enable DAI Clock
+*				  The DAI clock should be set appropriately according to audio sampling rate.
+***********************************************************/
+void IO_CKC_SetDAIClock(int iFreq);
+
+/**********************************************************
+*	unsigned IO_CKC_GetPLLClock(int iFreq);
+*
+*	Input		: iFreq = Frequency of Audio Sampling Clock (Hz unit)
+*	Return		: Frequency of PLL (100Hz unit)
+*	Description	: Get frequency of PLL that is capable to generate iFreq.
+*				  Unsupported audio sampling rate is regarded as 44100 Hz.
+*				Audio Sampling Rate	PLL frequency
+*				=========================
+*				44100 Hz	& related		203.1428 MHz
+*				48000 Hz	& related		221.1428 MHz
+*				32000 Hz	& related		196.5000 MHz
+***********************************************************/
+unsigned IO_CKC_GetPLLClock(int iFreq);
+
+/**********************************************************
+*	unsigned IO_CKC_GetDAIClock(int iFreq, int iOSR);
+*
+*	Input		: iFreq = Frequency of Audio Sampling Clock (Hz unit)
+*				  iOSR = Over Sampling Rate. (ex. 256, 384)
+*	Return		: Frequency of DAI Clock (100Hz unit)
+*	Description	: Get frequency of DAI clock that is fit to iFreq audio frequency.
+***********************************************************/
+unsigned IO_CKC_GetDAIClock(int iFreq, int iOSR);
+
+/**********************************************************
+*	void IO_CKC_SetADCClock(int iFreq);
+*
+*	Input		: iFreq = Frequency of ADC Clock, 100Hz unit
+*				  Clock disabled if iFreq == 0.
+*	Return		:
+*	Description	: Set frequency and Enable ADC Clock
+*				  The ADC clock is implicitely driven by XIN clock.
+***********************************************************/
+void IO_CKC_SetADCClock(int iFreq);
+
+/**********************************************************
+*	void IO_CKC_SetSDMMCClock(int iCH, int iFreq);
+*
+*	Input		: iCH = SD/MMC channel index
+*				  iFreq = Frequency of SDMMC Clock, 100Hz unit
+*				  Clock disabled if iFreq == 0.
+*	Output		:
+*	Return		:
+*
+*	Description	: Set frequency and Enable Clock
+***********************************************************/
+//void IO_CKC_SetSDMMCClock(int iCH, int iFreq);
+
+/**********************************************************
+*	void IO_CKC_SetLCDClock(int iCH, int iFreq)
+*
+*	Input		: iCH = LCD channel index
+*				  iFreq = Frequency of LCD Clock, 100Hz unit
+*				  Clock disabled if iFreq == 0.
+*	Output		:
+*	Return		:
+*
+*	Description	: Set frequency and Enable Clock
+***********************************************************/
+void IO_CKC_SetLCDClock(int iCH, int iFreq);
+
+/**********************************************************
+*	void IO_CKC_SetEHIClock(int iFreq, int iCS);
+*
+*	Input		: iFreq = Frequency of EHI Clock, 100Hz unit
+*				          Clock disabled if iFreq == 0.
+*                 iCS = EHI Channel ( 0 or 1 )
+*	Output		:
+*	Return		:
+*
+*	Description	: Set frequency and Enable Clock
+***********************************************************/
+void IO_CKC_SetEHIClock(int iFreq, int iCS);
+
+
+#ifdef CAMERA_INCLUDE
+/**********************************************************
+*	void IO_CKC_SetCAMClock(int iFreq);
+*
+*	Input		: iFreq = Frequency of CAM Clock, 100Hz unit
+*				  Clock disabled if iFreq == 0.
+*	Output		:
+*	Return		:
+*
+*	Description	: Set frequency and Enable Clock
+***********************************************************/
+void IO_CKC_SetCAMClock(int iFreq);
+
+/**********************************************************
+*	void IO_CKC_SetCAMScalerClock(int iFreq);
+*
+*	Input		: iFreq = Frequency of CAM Scaler Clock, 100Hz unit
+*				  Clock disabled if iFreq == 0.
+*	Output		:
+*	Return		:
+*
+*	Description	: Set frequency and Enable Clock
+***********************************************************/
+void IO_CKC_SetCAMScalerClock(int iFreq);
+#endif
+
+/**********************************************************
+*	void IO_CKC_SetSPDIFClock(int iFreq);
+*
+*	Input		: iFreq = Frequency of SPDIF Clock, 100Hz unit
+*				  Clock disabled if iFreq == 0.
+*	Output		:
+*	Return		:
+*
+*	Description	: Set frequency and Enable Clock
+***********************************************************/
+void IO_CKC_SetSPDIFClock(int iFreq);
+
+/**********************************************************
+*	void IO_CKC_SetSPI0Clock(int iFreq);
+*	void IO_CKC_SetSPI1Clock(int iFreq);
+*	void IO_CKC_SetSPI2Clock(int iFreq);
+*	void IO_CKC_SetSPI3Clock(int iFreq);
+*
+*	Input		: iFreq = Frequency of SPIS Clock, 100Hz unit
+*				  Clock disabled if iFreq == 0.
+*	Output		:
+*	Return		:
+*
+*	Description	: Set frequency and Enable Clock
+***********************************************************/
+void IO_CKC_SetSPI0Clock(int iFreq);
+void IO_CKC_SetSPI1Clock(int iFreq);
+void IO_CKC_SetSPI2Clock(int iFreq);
+void IO_CKC_SetSPI3Clock(int iFreq);
+
+/**********************************************************
+*	void IO_CKC_UpdateFPERI(unsigned uPeri, unsigned uFperi);
+*
+*	Input		: uPeri = Index of peripheral clock frequency table.
+*				  uFperi = New Frequency value.
+*	Output		:
+*	Return		:
+*
+*	Description	: updates pIO_CKC_Fpll table with new frequency.
+***********************************************************/
+void IO_CKC_UpdateFPERI(unsigned uPeri, unsigned uFperi);
+
+
+extern unsigned		uIO_CKC_Fpll[];			// Current PLL Frequency, 100Hz unit
+extern unsigned		uIO_CKC_Fsys[];
+extern unsigned		uIO_CKC_Fclk[];			// Current Frequency, 100Hz unit
+extern unsigned		uTMODE0;				// image of HwTMODE register.
+extern unsigned		uTMODE1;				// image of HwTMODE register.
+extern unsigned		pIO_CKC_Fperi[];		// Current Peripheral Frequency, 100Hz unit
+extern const sPLL	pIO_CKC_PLL[];			// PLL Setting (PMS) Table
+extern unsigned		uIO_CKC_FrzClk;			// Freeze CPU, BUS Clock
+extern unsigned		uIO_CKC_Fmax[];			// Fclk Max Frequency, 100Hz unit
+extern unsigned		uIO_CKC_CurSpeedSet;	// Current Speed Mode
+extern unsigned		uIO_CKC_Fbus4cycle;		// Reference Bus Frequency & Period for calculating cycle parameter	
+
+/************************************************************************
+*	ARM
+************************************************************************/
+/**********************************************************
+*	unsigned IO_ARM_DrainWBInt(void);
+*
+*	Input		: none
+*	Return		: 0
+*	Description	: Drain Write Buffer
+*				  This function is located in IO_LIB_INT area and
+*				  it should be located in the internal SRAM.
+**********************************************************/
+unsigned IO_ARM_DrainWBInt(void);
+
+/**********************************************************
+*	unsigned IO_ARM_CleanCACHEInt(unsigned uDrainWB);
+*
+*	Input		: uDrainWB = Write Buffer control
+*					1 = Execute Drain Write Buffer
+*	Return		: 0
+*	Description	: Clean Data cache and/or Drain Write Buffer
+*				  This function is located in IO_LIB_INT area and
+*				  it should be located in the internal SRAM.
+**********************************************************/
+unsigned IO_ARM_CleanCACHEInt(unsigned uDrainWB);
+
+/**********************************************************
+*	int IO_ARM_LockICACHE(void *pFPTRstart, void *pFPTRend);
+*
+*	Input		: pFPTRstart = function start address for locking
+*				  pFPTRend   = function end address for locking
+*	Return		: -1 = if error
+*				    n = lock index (n >= 0)
+*	Description	: Lock the object function into I cache
+*				  The locked region
+*					starts from (pFPTRstart & ~0x7F) and and at (pFPTRend | 0x7F).
+**********************************************************/
+int IO_ARM_LockICACHE(void *pFPTRstart, void *pFPTRend);
+
+/**********************************************************
+*	unsigned IO_ARM_DrainWB(void);
+*
+*	Input		: none
+*	Return		: 0
+*	Description	: Drain Write Buffer
+**********************************************************/
+unsigned IO_ARM_DrainWB(void);
+
+/**********************************************************
+*	unsigned IO_ARM_CleanCACHE(unsigned uDrainWB);
+*
+*	Input		: uDrainWB = Write Buffer control
+*					1 = Drain write buffer
+*					0 = Don't drain write buffer
+*	Return		: 0
+*	Description	: Clean Data cache (and Drain Write Buffer)
+**********************************************************/
+unsigned IO_ARM_CleanCACHE(unsigned uDrainWB);
+
+/**********************************************************
+*	unsigned IO_ARM_SetMMU(unsigned uMMU);
+*
+*	Input		: uMMU = MMU control register value
+*					Hw16 = DTCM control (1 = to enable)
+*					Hw12 = ICache control (1 = to enable)
+*					Hw2   = DCache control (1 = to enable)
+*					Hw0   = Protection control (1 = to enable)
+*	Return		: same as input
+*	Description	: Set MMU control register
+**********************************************************/
+unsigned IO_ARM_SetMMU(unsigned);
+
+/**********************************************************
+*	unsigned IO_ARM_GetMMU(void);
+*
+*	Input		: None
+*	Return		: current MMU control register (C1 register) value
+*					Hw16 = DTCM control (1 = enabled)
+*					Hw12 = ICache control (1 = enabled)
+*					Hw2   = DCache control (1 = enabled)
+*					Hw0   = Protection control (1 = enabled)
+*	Description	: Get current MMU control register (C1 register)
+**********************************************************/
+unsigned IO_ARM_GetMMU(void);
+
+/**********************************************************
+*	unsigned IO_ARM_ClearMMU(unsigned);
+*
+*	Input		: Flag for MMU control
+*					Hw16 = DTCM control (1 = to disable)
+*					Hw12 = ICache control (1 = to disable)
+*					Hw2   = DCache control (1 = to disable)
+*					Hw0   = Protection control (1 = to disable)
+*	Return		: MMU Settings before modifying
+*	Description	: Clear MMU control flags according to argument
+**********************************************************/
+unsigned IO_ARM_ClearMMU(unsigned);
+
+/**********************************************************
+*	unsigned IO_ARM_FlushCACHE(void);
+*
+*	Input		: None
+*	Return		: 0
+*	Description	: Flush Data & Instruction Cache
+**********************************************************/
+unsigned IO_ARM_FlushCACHE(void);
+
+/**********************************************************
+*	unsigned IO_ARM_FlushICACHE(void);
+*
+*	Input		: None
+*	Return		: 0
+*	Description	: Flush Instruction Cache
+**********************************************************/
+unsigned IO_ARM_FlushICACHE(void);
+
+/**********************************************************
+*	unsigned IO_ARM_FlushDCACHE(void);
+*
+*	Input		: None
+*	Return		: 0
+*	Description	: Flush Data Cache
+**********************************************************/
+unsigned IO_ARM_FlushDCACHE(void);
+
+/**********************************************************
+*	unsigned IO_ARM_GetICACHE(void);
+*
+*	Input		: None
+*	Return		: Current region flags for Inst Cache
+*					HwX : Region X flag (1 = instruction cache enabled)
+*	Description	: Set Region flags for Inst Cache
+**********************************************************/
+unsigned IO_ARM_GetICACHE(void);
+
+/**********************************************************
+*	unsigned IO_ARM_GetDCACHE(void);
+*
+*	Input		: None
+*	Return		: Current region flags for Data Cache
+*					HwX : Region X flag (1 = data cache enabled)
+*	Description	: Set Region flags for Data Cache
+**********************************************************/
+unsigned IO_ARM_GetDCACHE(void);
+
+/**********************************************************
+*	unsigned IO_ARM_GetWB(void);
+*
+*	Input		: None
+*	Return		: Current region flags for Write Buffering
+*					HwX : Region X flag (1 = write buffer enabled)
+*	Description	: Get Region flags for Write Buffering
+**********************************************************/
+unsigned IO_ARM_GetWB(void);
+
+/**********************************************************
+*	unsigned IO_ARM_SetCPSR(unsigned uCPSR);
+*
+*	Input		: uCPSR = value for new CPSR
+*	Return		: same as uCPSR
+*	Description	: Set the CPSR as uCPSR value
+**********************************************************/
+unsigned IO_ARM_SetCPSR(unsigned uCPSR);
+
+/**********************************************************
+*	unsigned IO_ARM_GetCPSR(void);
+*
+*	Input		: None
+*	Return		: the CPSR register value
+*	Description	: Get the CPSR register value
+**********************************************************/
+unsigned IO_ARM_GetCPSR(void);
+
+/**********************************************************
+*	unsigned IO_ARM_SetINT(unsigned uCPSR);
+*
+*	Description	: same as IO_ARM_SetCPSR()
+**********************************************************/
+unsigned IO_ARM_SetINT(unsigned uCPSR);
+
+/**********************************************************
+*	unsigned IO_ARM_GetINT(void);
+*
+*	Description	: same as IO_ARM_GetCPSR()
+**********************************************************/
+unsigned IO_ARM_GetINT(void);
+
+/**********************************************************
+*	unsigned IO_ARM_EnableFIQ(void);
+*
+*	Input		: None
+*	Return		: old CPSR (before FIQ enabled)
+*	Description	: Enable FIQ
+**********************************************************/
+unsigned IO_ARM_EnableFIQ(void);
+
+/**********************************************************
+*	unsigned IO_ARM_DisableFIQ(void);
+*
+*	Input		: None
+*	Return		: old CPSR (before FIQ disabled)
+*	Description	: Disable FIQ
+**********************************************************/
+unsigned IO_ARM_DisableFIQ(void);
+
+/**********************************************************
+*	unsigned IO_ARM_EnableIRQ(void);
+*
+*	Input		: None
+*	Return		: old CPSR (before IRQ enabled)
+*	Description	: Enable IRQ
+**********************************************************/
+unsigned IO_ARM_EnableIRQ(void);
+
+/**********************************************************
+*	unsigned IO_ARM_DisableIRQ(void);
+*
+*	Input		: None
+*	Return		: old CPSR (before IRQ disabled)
+*	Description	: Disable IRQ
+**********************************************************/
+unsigned IO_ARM_DisableIRQ(void);
+
+/**********************************************************
+*	unsigned IO_ARM_EnableINT(void);
+*
+*	Input		: None
+*	Return		: old CPSR (before Interrupt enabled)
+*	Description	: Enable IRQ/FIQ Interrupt
+**********************************************************/
+unsigned IO_ARM_EnableINT(void);
+
+/**********************************************************
+*	unsigned IO_ARM_DisableINT(void);
+*
+*	Input		: None
+*	Return		: old CPSR (before Interrupt disabled)
+*	Description	: Disable IRQ/FIQ Interrupt
+**********************************************************/
+unsigned IO_ARM_DisableINT(void);
+
+/************************************************************************
+*	Interrupt Controller
+************************************************************************/
+extern void IOS_INT_HandleIRQ0(int inum);
+extern void IOS_INT_HandleIRQ1(int inum);
+extern void IOS_INT_HandleIRQ2(int inum);
+extern void IOS_INT_HandleIRQ3(int inum);
+extern void IOS_INT_HandleIRQ4(int inum);
+extern void IOS_INT_HandleIRQ5(int inum);
+extern void IOS_INT_HandleIRQ6(int inum);
+extern void IOS_INT_HandleIRQ7(int inum);
+extern void IOS_INT_HandleIRQ8(int inum);
+extern void IOS_INT_HandleIRQ9(int inum);
+extern void IOS_INT_HandleIRQ10(int inum);
+extern void IOS_INT_HandleIRQ11(int inum);
+extern void IOS_INT_HandleIRQ12(int inum);
+extern void IOS_INT_HandleIRQ13(int inum);
+extern void IOS_INT_HandleIRQ14(int inum);
+extern void IOS_INT_HandleIRQ15(int inum);
+extern void IOS_INT_HandleIRQ16(int inum);
+extern void IOS_INT_HandleIRQ17(int inum);
+extern void IOS_INT_HandleIRQ18(int inum);
+extern void IOS_INT_HandleIRQ19(int inum);
+extern void IOS_INT_HandleIRQ20(int inum);
+extern void IOS_INT_HandleIRQ21(int inum);
+extern void IOS_INT_HandleIRQ22(int inum);
+extern void IOS_INT_HandleIRQ23(int inum);
+extern void IOS_INT_HandleIRQ24(int inum);
+extern void IOS_INT_HandleIRQ25(int inum);
+extern void IOS_INT_HandleIRQ26(int inum);
+extern void IOS_INT_HandleIRQ27(int inum);
+extern void IOS_INT_HandleIRQ28(int inum);
+extern void IOS_INT_HandleIRQ29(int inum);
+extern void IOS_INT_HandleIRQ30(int inum);
+extern void IOS_INT_HandleIRQ31(int inum);
+
+/**********************************************************
+;	unsigned IO_INT_EnableINT(void)
+;
+;	Input		: None
+;	Return		: HwALLMSK before Interrupt Enabled
+;
+;	Description	: Enable IRQ/FIQ Interrupt
+**********************************************************/
+unsigned IO_INT_EnableINT(void);
+
+/**********************************************************
+;	unsigned IO_INT_EnableIRQ(void)
+;
+;	Input		: None
+;	Return		: HwALLMSK before Interrupt Enabled
+;
+;	Description	: Enable IRQ Interrupt
+**********************************************************/
+unsigned IO_INT_EnableIRQ(void);
+
+/**********************************************************
+;	unsigned IO_INT_EnableFIQ(void)
+;
+;	Input		: None
+;	Return		: HwALLMSK before Interrupt Enabled
+;
+;	Description	: Enable FIQ Interrupt
+**********************************************************/
+unsigned IO_INT_EnableFIQ(void);
+
+/**********************************************************
+;	unsigned IO_INT_DisableINT(void)
+;
+;	Input		: None
+;	Return		: HwALLMSK before Interrupt Disabled
+;
+;	Description	: Disable IRQ/FIQ Interrupt
+**********************************************************/
+unsigned IO_INT_DisableINT(void);
+
+/**********************************************************
+;	unsigned IO_INT_DisableIRQ(void)
+;
+;	Input		: None
+;	Return		: HwALLMSK before Interrupt Disabled
+;
+;	Description	: Disable IRQ Interrupt
+**********************************************************/
+unsigned IO_INT_DisableIRQ(void);
+
+/**********************************************************
+;	unsigned IO_INT_DisableFIQ(void)
+;
+;	Input		: None
+;	Return		: HwALLMSK before Interrupt Disabled
+;
+;	Description	: Disable FIQ Interrupt
+**********************************************************/
+unsigned IO_INT_DisableFIQ(void);
+
+/**********************************************************
+;	unsigned IO_INT_RestoreINT(unsigned uMSK)
+;
+;	Input		: uMSK = Mask value for HwALLMSK
+;	Return		: uMSK
+;
+;	Description	: Restore IRQ/FIQ Interrupt
+**********************************************************/
+unsigned IO_INT_RestoreINT(unsigned uMSK);
+
+/************************************************************************
+*	Memory Controller
+************************************************************************/
+/**********************************************************
+*	void IO_MC_SetCFGInt(unsigned uCS, unsigned uValue);
+*
+*	Input		: uCS = 0~4
+*				  uValue = register value for corresponding chip select
+*	Return		:
+*	Description	: Set the corresponding memory configuration register (HwCSCFG0~3, HwSDCFG)
+*				  This function is located in IO_LIB_INT area and
+*				  it should be located in the internal SRAM.
+**********************************************************/
+void IO_MC_SetCFGInt(unsigned uCS, unsigned uValue);
+
+/************************************************************************
+*	DMA Controller
+************************************************************************/
+enum { 
+	IO_DMA_CH0, 
+	IO_DMA_CH1, 
+	IO_DMA_CH2,
+	IO_DMA_CH3,
+	IO_DMA_CH4,
+	IO_DMA_CH5,
+	IO_DMA_CH6,
+	IO_DMA_CH7,
+	IO_DMA_CH8,
+	IO_DMA_CH9,
+	IO_DMA_CH10,
+	IO_DMA_CH11,
+	IO_DMA_CH_MAX
+};
+
+#if defined(TCC79XX) || defined(TCC92XX) || defined(TCC89XX)
+	#define	IO_DMA_PORTCFG_NFC_READ		0
+	#define	IO_DMA_PORTCFG_NFC_WRITE	0
+#endif
+
+#define	IO_DMA_EnableDMA(X)		{ BITSET(((sHwDMA *)(X))->CHCTRL, HwCHCTRL_EN_EN); }
+#define	IO_DMA_DisableDMA(X)	{ BITSET(((sHwDMA *)(X))->CHCTRL, HwCHCTRL_EN_EN); }
+
+/**********************************************************
+*	void IO_DMA_SetCTRL(unsigned uCH, unsigned	uCHCTRL);
+*
+*	Input		: uCH = Channel number (0~2)
+*				  uValue = DMA control register value of corresponding channel
+*	Return		:
+*	Description	: Set the corresponding DMA control register (HwCHCTRL0~1 in General DMA, HwCHCTRL0 in Storage DMA)
+**********************************************************/
+PGDMACTRL IO_DMA_SetCTRL(unsigned uCH, unsigned	uCHCTRL);
+
+/**********************************************************
+*	void IO_DMA_SetDMA(unsigned uCH, void *pSRC, unsigned uSPARAM,
+*						void *pDST, unsigned uDPARAM,
+*						unsigned	uCHCTRL, unsigned uSize);
+*	Input		: uCH = Channel number (0~2)
+*				  pSRC = source address
+*				  uSPARAM = source parameter
+*				  pDST = destination address
+*				  uDPARAM = destination parameter
+*				  uCHCTRL = DMA control register
+*				  uSize = Transfer size (in byte unit)
+*	Return		:
+*	Description	: Set the DMA (and start to transfer)
+**********************************************************/
+#ifdef TCC79XX
+sHwDMA *IO_DMA_SetDMA(
+	unsigned uCH,
+	void *pSRC, unsigned uSPARAM,
+	void *pDST, unsigned uDPARAM,
+	unsigned	uCHCTRL,
+	unsigned 	uREQSRC,  // added for TCC83XX 2007.9.13
+	unsigned uSize
+	);
+
+sHwDMA *IO_DMA_SetDMA_NAND(
+	unsigned uCH,
+	void *pSRC, unsigned uSPARAM,
+	void *pDST, unsigned uDPARAM,
+	unsigned	uCHCTRL,
+	unsigned uEXTREQ,
+	unsigned uSize	
+);
+#endif
+
+
+#define	HwCHCTRL_CONT_C				Hw15				// DMA transfer begins from C_SADR/C_DADR Address. It must be used after the former transfer has been executed, so that C_SADR and C_DADR contain a meaningful value.
+#define	HwCHCTRL_CONT_ST				(0)					// DMA trnaster begins from ST_SADR/ST_DADR Address
+#define	HwCHCTRL_DTM_EN				Hw14				// Differential Transfer Mode Enable
+#define	HwCHCTRL_DTM_ON				Hw14				// Differential Transfer Mode Enable
+#define	HwCHCTRL_DTM_OFF				(0)					// Differential Transfer Mode Disable
+#define	HwCHCTRL_SYNC_ON				Hw13				// Synchronize HardWare Request
+#define	HwCHCTRL_SYNC_OFF			(0)					// Do not Synchronize HardWare Request
+#define 	HwCHCTRL_SYNC_EN				Hw13				// Synchronize Hardware Request
+#define	HwCHCTRL_HRD_W				Hw12				// ACK/EOT signals are issued When DMA-Write Operation
+#define	HwCHCTRL_LOCK_EN				Hw11				// DMA transfer executed with lock transfer
+#define	HwCHCTRL_BST_NOARB			Hw10				// DMA transfer executed with no arbitration(burst operation)
+#define	HwCHCTRL_HRD_WR				Hw12				// ACK/EOT signals are issued When DMA-Write Operation
+#define	HwCHCTRL_HRD_RD				(0)					// ACK/EOT signals are issued When DMA-Read Operation
+#define	HwCHCTRL_LOCK_ON				Hw11				// DMA transfer executed with lock transfer
+#define	HwCHCTRL_LOCK_OFF			(0)					//
+#define	HwCHCTRL_BST_BURST			Hw10				// DMA transfer executed with no arbitration(burst operation)
+#define	HwCHCTRL_BST_ARB				(0)					// DMA transfer executed wth arbitration
+#define	HwCHCTRL_TYPE_SINGE			(0)					// SINGLE transfer with edge-triggered detection
+#define	HwCHCTRL_TYPE_HW				Hw8					// HW Transfer
+#define	HwCHCTRL_TYPE_SW				Hw9					// SW transfer
+#define	HwCHCTRL_TYPE_SINGL			(Hw9|Hw8)			// SINGLE transfer with level-triggered detection
+#define	HwCHCTRL_TYPE_SL				(Hw9|Hw8)			// SINGLE transfer with level-triggered detection
+#define HwCHCTRL_TYPE_SE				HwZERO				// SINGLE transfer with edge-triggered detection
+
+#define	HwCHCTRL_BSIZE_1				(0)					// 1 Burst transfer consists of 1 read or write cycle
+#define	HwCHCTRL_BSIZE_2				Hw6					// 1 Burst transfer consists of 2 read or write cycles
+#define	HwCHCTRL_BSIZE_4				Hw7					// 1 Burst transfer consists of 4 read or write cycles
+#define	HwCHCTRL_BSIZE_8				(Hw6|Hw7)			// 1 Burst transfer consists of 8 read or write cycles
+
+#define	HwCHCTRL_WSIZE_8				(0)					// Each cycle read or write 8bit data
+#define	HwCHCTRL_WSIZE_16			Hw4					// Each cycle read or write 16bit data
+#define	HwCHCTRL_WSIZE_32			Hw5					// Each cycle read or write 32bit data
+
+#define	HwCHCTRL_FLAG					Hw3					// Clears FLAG to 0
+#define	HwCHCTRL_IEN_ON				Hw2					// At the same time the FLAG goes to 1, DMA interrupt request is generated
+#define HwCHCTRL_IEN_EN				Hw2					// At the same time the FLAG goes to 1, DMA interrupt request is generated
+#define	HwCHCTRL_IEN_OFF			~Hw2				//
+#define	HwCHCTRL_REP_EN				Hw1					// The DMA channel remains enabled
+#define	HwCHCTRL_REP_DIS				~Hw1				// After all of hop transfer has executed, the DMA channel is disabled
+#define	HwCHCTRL_EN_ON				Hw0					// DMA channel is Enabled
+#define	HwCHCTRL_EN_OFF				~Hw0				// DMA channel is terminated and disabled/*}}}*/
+#define 	HwCHCTRL_EN_EN				Hw0					// DMA channel is enabled. If software type transfer is selected, this bit generates DMA request directly, or if hardware type transfer is used, the selected interrupt request flag generate DMA request
+
+
+/************************************************************************
+*	ECC Controller
+************************************************************************/
+#define	IO_ECC_DisableECC()	{ HwECC_CTRL &= HwECC_CTRL_SE_DIS; }
+#define	IO_ECC_EnableECC()	{ HwECC_CTRL |= HwECC_CTRL_SE_EN; }
+
+/**********************************************************
+*	int IO_ECC_CheckSLC(unsigned char *pcDATA, unsigned char *pcSPARE);
+*
+*	Input		: pcDATA = start address of data block
+*				  pcSPARE = start address of spare block
+*	Return		: 0 = no error or correctable error
+*				  -1 = uncorrectable error
+*	Description	: Check ECC and Correct Data Error
+************************************************************/
+int IO_ECC_CheckSLC(unsigned char *pcDATA, unsigned char *pcSPARE);
+
+/************************************************************************
+*	NAND Flash Controller
+************************************************************************/
+#define	HwNAND_CMD		(pHwND->CMD)
+#define	HwNAND_LADR		(pHwND->LADR)
+#define	HwNAND_DATA		(pHwND->WDATA.D32)
+#define	HwNAND_SDATA	((cIO_NFC_MEM) ? pHwND->WDATA.D8 : pHwND->SDATA.D32)
+#define	HwNAND_SADR		(pHwND->SADR)
+
+#define	ECC_BASEPAGE	((unsigned)&HwNAND_DATA)
+
+typedef	struct {				// NAND Request Structure
+	unsigned	CTRL;
+	unsigned	PADDR;			// Physical Address
+	unsigned	NFCCFG;			// image of HwNFC_CTRL register for corresponding request
+	unsigned	*PBUF;			// Pointer for Page Data
+	void		*SBUF;			// Pointer for Spare Data
+} sNFC_REQ;
+
+typedef	struct {				// NAND Request Master Structure
+	unsigned	uSEMA;			// Semaphore
+	sNFC_REQ	*pReqHead;		// request is poped from here.
+	sNFC_REQ	*pReqTail;		// request is pushed to here.
+} sNFC_REQMST;
+
+#define	REQ_FAIL		((sNFC_REQ *)(-1))
+
+// sNFC_REQ.CTRL bit-field definition
+//-----------------------------------------------------------------------------------
+#define	REQ_INACTIVE	(Hw31)			// Inactive, or End of Write Request (1)
+#define	REQ_EOR			(Hw30)			// End of Read Request, but not copied yet. (1)
+#define	REQ_ECCERR		(Hw29)			// Uncorrectable ECC error occurred. (1)
+#define	REQ_SPARE		(Hw28)			// Start from the spare area. (1)
+//-----------------------------------------------------------------------------------
+#define	REQ_DISABLE_MK	(Hw27)			// Disable Writing ECC MARK in data transfer (1)
+#define	REQ_ECCEN		(Hw26)			// Calc ECC in data transfer (1)
+#define	REQ_EOW			(Hw25)			// End of Write Request, but not check OK bit yet. (1)
+#define	REQ_WOK			(Hw24)			// Write OK Flag (1)
+//-----------------------------------------------------------------------------------
+#define	REQ_SKIPHCMD	(Hw23)			// Skip header command process (1)
+#define	REQ_SKIPTCMD	(Hw22)			// Skip tail command process (1)
+#define	REQ_SKIPCMD		(Hw23|Hw22)
+#define	REQ_CPBACK		(Hw21)			// Copy-Back Enabled. (1)
+#define	REQ_CPBACKW		(Hw20)			// Copy-Back with partial writing. (1)
+//-----------------------------------------------------------------------------------
+#define	REQ_SKIP10		(Hw19)			// Skip 0x10 command in writePAGE. (1)
+#define	REQ_ERASEBLK	(Hw18)			// Erase Block command. (1)
+#define	REQ_PRO_SPARE	(Hw17)			// Process spare area. (1)
+//-----------------------------------------------------------------------------------
+#define	REQ_READY		(Hw12)			// All settings for Request is ready (1)
+#define	REQ_DSIZE_MASK	(REQ_READY - 1)	// [11:0] = Data Size
+#define	REQ_DSIZE(X)	((X)&(REQ_DSIZE_MASK))
+
+// uCS bit-field definition
+#define	REQ_CSMASK		0x0000000F
+
+enum { IO_NFC_READ = 0, IO_NFC_WRITE = Hw15};
+
+void IO_NFC_InitDRV(void);
+void IO_NFC_OpenREQ(sNFC_REQ *pReq, unsigned uMaxNFC);
+void IO_NFC_CloseREQ(void);
+void IO_NFC_PopREQ(sNFC_REQ *pReq);
+void IO_NFC_EnableREQ(sNFC_REQ *pReq);
+void IO_NFC_IRQHandler(void);
+void IO_NFC_StartREAD(sNFC_REQ *pReq);
+void IO_NFC_ReadPAGE(unsigned *pBuffer, unsigned uDSize);
+void IO_NFC_ReadDATA(unsigned char *pBuffer, unsigned uDSize);
+int IO_NFC_CopyPAGE(unsigned char *pDest, unsigned *pSrc, unsigned uSize);
+sNFC_REQ *IO_NFC_PushRREQ(unsigned uCS, unsigned uPage, unsigned uColumn, unsigned *pSpare, unsigned uSize);
+void IO_NFC_StartWRITE(sNFC_REQ *pReq);
+void IO_NFC_WritePAGE(unsigned *pBuffer, unsigned uDSize);
+void IO_NFC_WriteDATA(unsigned char *pBuffer, unsigned uDSize);
+sNFC_REQ *IO_NFC_PushWREQ(	unsigned uCS, unsigned uPage, unsigned uColumn,
+							unsigned *pData, unsigned char *pSpare, unsigned uSize);
+int IO_NFC_CheckWOK(sNFC_REQ *pReq);
+unsigned IO_NFC_LookupID(unsigned uDID);
+unsigned IO_NFC_SetCONFIG(unsigned uType);
+unsigned IO_NFC_MakeNFC(unsigned uCS);
+unsigned IO_NFC_GetID(unsigned uCS);
+unsigned IO_NFC_ResetNAND(unsigned uCS);
+void IO_NFC_SetCYCLE(void);
+void IO_NFC_WaitEOT(sNFC_REQ *pReq);
+
+extern unsigned			uIO_NFC_CONFIG, uIO_NFC_MASK;
+extern unsigned char	cIO_NFC_MEM;
+extern PNFC				pIO_NFC_HwND;
+
+#define	IO_NFC_MakeMASK(uCS)	((uIO_NFC_CONFIG & (Hw14 << (uCS*16))) ? 0xFFFF : 0xFF)
+
+#define	IO_NFC_SetNFC(uCS)						\
+{												\
+	if (cIO_NFC_MEM)							\
+		HwCSCFG2	= IO_NFC_MakeNFC(uCS);		\
+	else										\
+		HwNFC_CTRL	= IO_NFC_MakeNFC(uCS);		\
+}
+
+#ifdef TCC79XX
+	#if defined(TCC7900_BOARD)
+		#define	GPIO_ND_nCS		HwPORTCFG2
+		#define	GPIO_ND_nCS1Bit	Hw5
+		#define	GPIO_ND_nCS0Bit	Hw4
+		#define	GPIO_ND_nWP		HwPORTCFG2
+		#define	GPIO_ND_nWPBit	Hw2
+		#define	GPIO_ND_RDY		HwPORTCFG2
+		#define	GPIO_ND_RDYBit	Hw3
+		#define	GPIO_NFC_nWP	HwPORTCFG2
+		#define	GPIO_NFC_nWPBit	Hw17
+	#elif defined(TCC792X_BOARD)
+		#define	GPIO_ND_nCS		HwPORTCFG2
+		#define	GPIO_ND_nCS1Bit	Hw9
+		#define	GPIO_ND_nCS0Bit	Hw8
+		#define	GPIO_ND_RDY		HwPORTCFG2
+		#define	GPIO_ND_RDYBit	Hw14
+	#endif
+#elif defined(TCC92XX) || defined(TCC89XX)
+	#if defined(TCC9200_BOARD)
+		#define	GPIO_ND_nCS		HwPORTCFG2
+		#define	GPIO_ND_nCS1Bit	Hw9
+		#define	GPIO_ND_nCS0Bit	Hw8
+		#define	GPIO_ND_RDY		HwPORTCFG2
+		#define	GPIO_ND_RDYBit	Hw14
+	#endif
+#endif
+
+#define	IO_NFC_DisableCS()										\
+{																\
+	if (cIO_NFC_MEM)											\
+		BITSET(GPIO_ND_nCS, GPIO_ND_nCS1Bit|GPIO_ND_nCS0Bit);	\
+	else														\
+		BITSET(HwNFC_CTRL, HwNFC_CTRL_CFG_NOACT);				\
+}
+
+#define	IO_NFC_EnableCS(uCS)											\
+{																		\
+	if (cIO_NFC_MEM)													\
+		BITSCLR(GPIO_ND_nCS, (uCS) ? GPIO_ND_nCS0Bit: GPIO_ND_nCS1Bit, (uCS) ? GPIO_ND_nCS1Bit: GPIO_ND_nCS0Bit);	\
+	else																\
+		BITSCLR(HwNFC_CTRL, (uCS) ? Hw22: Hw23, (uCS) ? Hw23 : Hw22);	\
+}
+
+#define	IO_NFC_DisableWP()						\
+{												\
+	if (cIO_NFC_MEM)							\
+		BITSET(GPIO_ND_nWP, GPIO_ND_nWPBit);	\
+	else										\
+		BITSET(GPIO_NFC_nWP, GPIO_NFC_nWPBit);	\
+}
+
+#define	IO_NFC_EnableWP()						\
+{												\
+	if (cIO_NFC_MEM)							\
+		BITCLR(GPIO_ND_nWP, GPIO_ND_nWPBit);	\
+	else										\
+		BITCLR(GPIO_NFC_nWP, GPIO_NFC_nWPBit);	\
+}
+
+#define	IO_NFC_NotREADY()						\
+	( (cIO_NFC_MEM) ? ISZERO(GPIO_ND_RDY, GPIO_ND_RDYBit) : ISZERO(HwNFC_CTRL, HwNFC_CTRL_RDY_RDY))
+
+#define	IO_NFC_WaitSTARDY()		{ ; }
+
+void IO_NFC_WaitREADY(void);
+void IO_NFC_WaitREADYForWriteCommand(void);
+
+#define	IO_NFC_WaitDONE(X)		{ while (ISZERO(HwNFC_IREQ, (X))); }
+
+#define	USE_NFC_DMA
+#define	USE_NFC_FIFO		// only meaningful when "USE_NFC_DMA" is defined.
+
+/************************************************************************
+*	DTCM Allocation Manager
+************************************************************************/
+//#define	USE_DYNAMIC_DTCM
+
+#if defined(TCC79XX)
+	#define	DTCM_BASE				0xA0000000
+	#define	DTCM_LIMIT				0xA0002000
+	#define	DTCM_SIZE				(DTCM_LIMIT - DTCM_BASE)
+	#define	ITCM_SIZE				0x00001000
+	#define	IO_USB_BUFFER0_BASE		(DTCM_BASE + 0x1800)
+	#define	IO_USB_BUFFER1_BASE		(DTCM_BASE + 0x1A00)
+	#define	IO_NFC_BUFFER0_BASE		(DTCM_BASE + 0x1C00)
+	#define	IO_NFC_BUFFER1_BASE		(DTCM_BASE + 0x1E00)
+#elif defined(TCC92XX) || defined(TCC89XX)
+	#define	DTCM_BASE				0xA0000000
+	#define	DTCM_LIMIT				0xA0004000
+	#define	DTCM_SIZE				(DTCM_LIMIT - DTCM_BASE)
+	#define	ITCM_SIZE				0x00004000
+	#define	IO_USB_BUFFER0_BASE		(DTCM_BASE + 0x1800)
+	#define	IO_USB_BUFFER1_BASE		(DTCM_BASE + 0x1A00)
+	#define	IO_NFC_BUFFER0_BASE		(DTCM_BASE + 0x1C00)
+	#define	IO_NFC_BUFFER1_BASE		(DTCM_BASE + 0x1E00)
+#endif
+
+
+#define	IO_HDD_BUFFER_BASE			IO_NFC_BUFFER0_BASE
+
+#ifdef	USE_DYNAMIC_DTCM
+	#define	DTCM_MaskSize			(8 * sizeof(unsigned))							// bit width of uDTCM_MAT[] table
+	#define	DTCM_Mask				((unsigned)((1 << DTCM_MaskSize) - 1))			// mask pattern of uDTCM_MAT[] table
+	#define	DTCM_SIZE				4096
+	#define	DTCM_AUNIT				64												// minimum allocation unit.
+	#define	DTCM_MAXBULK			(DTCM_SIZE / DTCM_AUNIT)						// maximum concurrent allocation.
+	#define	DTCM_MATSIZE			((DTCM_SIZE / DTCM_AUNIT) / DTCM_MaskSize)		// Bitmap table for each chunk (1 = used, 0 = not-used)
+#endif
+
+void IO_DTCM_InitDRV(void);
+void *IO_DTCM_Malloc(unsigned uDSize);
+void IO_DTCM_Free(void *pSrc, unsigned uDSize);
+
+unsigned IO_DTCM_AllocMAT(unsigned uASize);
+unsigned IO_DTCM_FindFMAX(void);
+
+
+/************************************************************************
+*	SRAM ADDR
+************************************************************************/
+#ifdef TCC79XX
+	#define	SRAM_BASE					0x00000000
+	#define	SRAM_LIMIT					0x00010000
+#elif defined(TCC92XX) || defined(TCC89XX)
+	#define	SRAM_BASE					0x10000000
+	#define	SRAM_LIMIT					0x00004000
+#endif
+
+/************************************************************************
+*	Interrupt Controller
+************************************************************************/
+#ifdef TCC92XX
+
+	// Interrupt Enable 0
+/*
+	#define	IO_INT_EHI0		HwINT0_EHI0
+	#define	IO_INT_ECC		HwINT0_ECC
+	#define	IO_INT_DMA		HwINT0_DMA
+	#define	IO_INT_TSADC	HwINT0_TSADC
+	#define	IO_INT_G2D		HwINT0_G2D
+	#define	IO_INT_3DMMU	HwINT0_3DMMU
+	#define	IO_INT_3DGP		HwINT0_3DGP
+	#define	IO_INT_3DPP		HwINT0_3DPP
+	#define	IO_INT_VCDC		HwINT0_VCDC
+	#define	IO_INT_JPGD		HwINT0_JPGD
+	#define	IO_INT_JPGE		HwINT0_JPGE
+	#define	IO_INT_VIPET	HwINT0_VIPET
+	#define	IO_INT_LCD1		HwINT0_LCD1
+	#define	IO_INT_LCD0		HwINT0_LCD0
+	#define	IO_INT_CAM		HwINT0_CAM
+	#define	IO_INT_SC1		HwINT0_SC1
+	#define	IO_INT_SC0		HwINT0_SC0
+	#define	IO_INT_EI11		HwINT0_EI11
+	#define	IO_INT_EI10		HwINT0_EI10
+	#define	IO_INT_EI9		HwINT0_EI9
+	#define	IO_INT_EI8		HwINT0_EI8
+	#define	IO_INT_EI7		HwINT0_EI7
+	#define	IO_INT_EI6		HwINT0_EI6
+	#define	IO_INT_EI5		HwINT0_EI5
+	#define	IO_INT_EI4		HwINT0_EI4
+	#define	IO_INT_EI3		HwINT0_EI3
+	#define	IO_INT_EI2		HwINT0_EI2
+	#define	IO_INT_EI1		HwINT0_EI1
+	#define	IO_INT_EI0		HwINT0_EI0
+	#define	IO_INT_SMUI2C	HwINT0_SMUI2C
+	#define	IO_INT_TC1		HwINT0_TC1
+	#define	IO_INT_TC0		HwINT0_TC0
+*/
+	enum {
+		IO_INT_nTC0,		// 0
+		IO_INT_nTC1,
+		IO_INT_nSMUI2C,
+		IO_INT_nEI0,
+		IO_INT_nEI1,
+		IO_INT_nEI2,		// 5
+		IO_INT_nEI3,
+		IO_INT_nEI4,
+		IO_INT_nEI5,
+		IO_INT_nEI6,
+		IO_INT_nEI7,		// 10
+		IO_INT_nEI8,
+		IO_INT_nEI9,
+		IO_INT_nEI10,
+		IO_INT_nEI11,
+		IO_INT_nSC0,		// 15
+		IO_INT_nSC1,
+		IO_INT_nCAM,
+		IO_INT_nLCD0,
+		IO_INT_nLCD1,
+		IO_INT_nVIPET,		// 20
+		IO_INT_nJPGE,
+		IO_INT_nJPGD,
+		IO_INT_nVCDC,
+		IO_INT_n3DPP,
+		IO_INT_n3DGP,		// 25
+		IO_INT_n3DMMU,
+		IO_INT_nG2D,
+		IO_INT_nTSADC,
+		IO_INT_nDMA,
+		IO_INT_nECC,		// 30
+		IO_INT_nEHI0
+	};
+
+	// Interrupt Enable 1
+/*
+	#define	IO_INT_AEIRQ	HwINT1_AEIRQ
+	#define	IO_INT_ASIRQ	HwINT1_ASIRQ
+	#define	IO_INT_AIRQ		HwINT1_AIRQ
+	#define	IO_INT_APMU		HwINT1_APMU
+	#define	IO_INT_AUDIO	HwINT1_AUDIO
+	#define	IO_INT_ADMA		HwINT1_ADMA
+	#define	IO_INT_DAITX	HwINT1_DAITX
+	#define	IO_INT_DAIRX	HwINT1_DAIRX
+	#define	IO_INT_CDRX		HwINT1_CDRX
+	#define	IO_INT_TSIF1	HwINT1_TSIF1
+	#define	IO_INT_TSIF0	HwINT1_TSIF0
+	#define	IO_INT_GPS2		HwINT1_GPS2
+	#define	IO_INT_GPS1		HwINT1_GPS1
+	#define	IO_INT_GPS0		HwINT1_GPS0
+	#define	IO_INT_UOTG		HwINT1_UOTG
+	#define	IO_INT_UART		HwINT1_UART
+	#define	IO_INT_SPDTX	HwINT1_SPDTX
+	#define	IO_INT_SD1		HwINT1_SD1	
+	#define	IO_INT_SD0		HwINT1_SD0
+	#define	IO_INT_RTC		HwINT1_RTC
+	#define	IO_INT_RMT		HwINT1_RMT
+	#define	IO_INT_NFG		HwINT1_NFC
+	#define	IO_INT_MS		HwINT1_MS
+	#define	IO_INT_MPEFEC	HwINT1_MPEFEC
+	#define	IO_INT_I2C		HwINT1_I2C
+	#define	IO_INT_HDD		HwINT1_HDD
+	#define	IO_INT_GPSB		HwINT1_GPSB
+	#define	IO_INT_HDMI		HwINT1_HDMI
+	#define	IO_INT_EHI1		HwINT1_EHI1
+*/
+	enum {
+		IO_INT_nEHI1,		// 0
+		IO_INT_nNotUsed0,
+		IO_INT_nHDMI,
+		IO_INT_nNotUsed1,
+		IO_INT_nGPSB,
+		IO_INT_nHDD,		// 5
+		IO_INT_nI2C,
+		IO_INT_nMPEFEC,
+		IO_INT_nMS,
+		IO_INT_nNFC,
+		IO_INT_nRMT,		// 10
+		IO_INT_nRTC,
+		IO_INT_nSD0,
+		IO_INT_nSD1,
+		IO_INT_nSPDTX,
+		IO_INT_nUART,		// 15
+		IO_INT_nUOTG,
+		IO_INT_nNotUsed2,
+		IO_INT_nGPS0,
+		IO_INT_nGPS1,
+		IO_INT_nGPS2,		// 20
+		IO_INT_nTSIF0,
+		IO_INT_nTSIF1,
+		IO_INT_nCDRX,
+		IO_INT_nDAIRX,
+		IO_INT_nDAITX,		// 25
+		IO_INT_nADMA,
+		IO_INT_nAUDIO,
+		IO_INT_nAPMU,
+		IO_INT_nAIRQ,
+		IO_INT_nASIRQ,		// 30
+		IO_INT_nAEIRQ,
+	};
+
+#elif defined(TCC79XX)
+	#define	IO_INT_HwIEN		HwIEN
+	#define	IO_INT_HwISTS		HwSTS
+	#define	IO_INT_HwMSTS		HwMSTS
+	#define	IO_INT_HwICLR		HwCLR
+	#define	IO_INT_HwISEL		HwSEL
+	#define	IO_INT_HwTMODE		HwMODE
+	#define	IO_INT_HwPOL		HwPOL
+	#define	IO_INT_HwEXT0		HwINT_EI0
+	#define	IO_INT_HwEXT1		HwINT_EI1
+	#define	IO_INT_HwEXT2		HwINT_EI2
+	#define	IO_INT_HwEXT3		HwINT_EI3
+	#define	IO_INT_HwRTC		HwINT_RTC
+	#define IO_INT_HwGPSB       HwINT_GPSB
+	#define	IO_INT_HwGPSB_CH0	HwINT_GPSB
+	#define	IO_INT_HwGPSB_CH1	HwINT_GPSB
+	#define	IO_INT_HwGPSB_CH2	HwINT_GPSB
+	#define	IO_INT_HwGPSB_CH3	HwINT_GPSB
+	#define	IO_INT_HwTIMER		(HwINT_TC1 | HwINT_TC0)
+	#define	IO_INT_HwTC0		HwINT_TC0
+	#define	IO_INT_HwTC1		HwINT_TC1
+	#define	IO_INT_HwSCORE		HwINT_SCORE
+	#define	IO_INT_HwSPDTX		HwINT_SPDTX
+	#define	IO_INT_HwSEL0		HwINT_SEL0
+	#define	IO_INT_HwSEL1		HwINT_SEL1
+	#define	IO_INT_HwSC			HwINT_SC
+	#define	IO_INT_HwI2C		HwINT_I2C
+	#define	IO_INT_HwDAIRX		HwINT_DAIRX
+	#define	IO_INT_HwDAITX		HwINT_DAITX
+	#define	IO_INT_HwCDIF		HwINT_CDRX
+	#define	IO_INT_HwEHI		HwINT_HPI
+	#define	IO_INT_HwUART		HwINT_UT
+	#define	IO_INT_HwUART0		HwINT_UT
+	#define	IO_INT_HwUART1		HwINT_UT
+	#define	IO_INT_HwSEL2		HwINT_SEL2
+	#define	IO_INT_HwG2D		HwINT_G2D
+	#define	IO_INT_HwUSBD		HwINT_UD
+	#define	IO_INT_HwUSBH		HwINT_UH
+	#define	IO_INT_HwDMA		HwINT_DMA
+	#define	IO_INT_HwDMA_CH0	HwINT_DMA
+	#define	IO_INT_HwDMA_CH1	HwINT_DMA
+	#define	IO_INT_HwDMA_CH2	HwINT_DMA
+	#define	IO_INT_HwHDD		HwINT_HDD
+	#define	IO_INT_HwSEL3		HwINT_SEL3
+	#define	IO_INT_HwNFC		HwINT_NFC
+	#define	IO_INT_HwSDMMC		HwINT_SD
+	#define	IO_INT_HwCAM		HwINT_CAM
+	#define	IO_INT_HwLCD		HwINT_LCD
+	#define	IO_INT_HwADC		HwINT_ADC
+	#define	IO_INT_HwSEL4		HwINT_SEL4
+	#define	IO_INT_HwGSIO		0
+
+	#define	IO_INT_HwVIDEO		HwINT_SEL0
+	#define	IO_INT_HwEXT5		HwINT_SEL1
+	#define	IO_INT_HwEHI1		HwINT_SEL2
+	#define	IO_INT_HwMSC		HwINT_SEL3
+	#define	IO_INT_HwEXT7		HwINT_SEL4
+	#define	IO_INT_HwUSBDMA		HwINT_SEL4
+
+	enum {
+		IO_INT_nEI0, 	// 0
+		IO_INT_nEI1, 
+		IO_INT_nEI2, 
+		IO_INT_nEI3, 
+		IO_INT_nRTC, 
+		IO_INT_nGPSB,	// 5 
+		IO_INT_nTC0, 
+		IO_INT_nTC1,
+		IO_INT_nVCORE, 
+		IO_INT_nSPDTX, 
+		IO_INT_nVIDEO, 	// 10
+		IO_INT_nEI5, 
+		IO_INT_nSC, 
+		IO_INT_nI2C, 
+		IO_INT_nDAIRX, 
+		IO_INT_nDAITX,	// 15
+		IO_INT_nCDRX, 
+		IO_INT_nEHI, 
+		IO_INT_nUT0, 
+		IO_INT_nEHI1, 
+		IO_INT_nUDMA, 	// 20
+		IO_INT_nUD, 
+		IO_INT_nUH, 
+		IO_INT_nDMA,
+		IO_INT_nHDD, 
+		IO_INT_nMS, 	// 25
+		IO_INT_nNFC, 
+		IO_INT_nSD, 
+		IO_INT_nCAM, 
+		IO_INT_nLCD, 
+		IO_INT_nADC, 	// 30
+		IO_INT_nUSBDMA
+	};
+#endif
+
+#if 0
+#define	IO_INT_EnableIRQ(X)					\
+		{									\
+			BITSET(IO_INT_HwISEL, X);		\
+			BITSET(IO_INT_HwIEN, X);		\
+		}
+#define	IO_INT_DisableIRQ(X)				\
+		{									\
+			BITCLR(HwIEN, X);				\
+		}
+#endif
+/************************************************************************
+*	EHI Controller
+************************************************************************/
+#define	EHI_MD_68		HwEHCFG_MD_68
+#define	EHI_MD_80		HwEHCFG_MD_80
+#define	EHI_USE_MASK	Hw1
+#define	EHI_BW_8		HwEHCFG_BW_8
+#define	EHI_BW_16		HwEHCFG_BW_16
+#define	EHI_USE_RDY		HwEHCFG_RDYE_RDY
+#define	EHI_USE_IRQ		HwEHCFG_RDYE_IRQ
+#define	EHI_HIGH_RDY	HwZERO
+#define	EHI_LOW_RDY		HwEHCFG_RDYP
+
+extern	unsigned	uEHI_CSCFG, uEHI_TACC;
+extern	volatile unsigned *pEHI_CSCFG;
+
+#ifdef	EHIS_TCC77X
+	#define	EHIS_HwEHST			0x90000800	// R/W, Status register
+	#define	EHIS_HwEHIINT		0x90000804	// R/W,  Internal interrupt control register
+	#define	EHIS_HwEHEINT		0x90000808	// R/W,  External interrupt control register
+	#define	EHIS_HwEHA			0x9000080C	// R/W,  Address register
+	#define	EHIS_HwEHAM			0x90000810	// R,  Address masking register
+	#define	EHIS_HwEHD			0x90000814	// R/W,  Data register
+	#define	EHIS_HwEHSEM		0x90000818	// R/W,  Semaphore register
+	#define	EHIS_HwEHCFG		0x9000081C	// R/W,  Configuration register
+	#define	EHIS_HwEHIND		0x90000820	// W,  Index register
+	#define	EHIS_HwEHRWCS		0x90000824	// R/W,  Read/Write Control/Status register
+#endif
+
+#ifdef EHI_MASTER
+	/**********************************************************
+	*	void IO_EHI_InitDRV(unsigned uCONFIG, unsigned uCS, unsigned uMask);
+	*
+	*	Input		: uCONFIG = Configuration Parameter
+	*					Hw0 = 68000 (1), x86 (0) interface
+	*					Hw1 = Use Mask (1), Don't used Mask (0)
+	*					Hw2 = 8bit (1), 16bit (0) interface
+	*					Hw3 = used as Ready signal (1), used as Interrupt signal (0)
+	*					Hw4 = Active Low Ready signal (1), Active High Ready signal (0)
+	*				  uCS = Chip Select number for EHI slave (0~3)
+	*				  uMask = Address Mask Pattern.
+	*	Return		:
+	*	Description	: Initialize EHI I/F module at the Master Site.
+	************************************************************/
+	void IO_EHI_InitDRV(unsigned uCONFIG, unsigned uCS, unsigned uMask);
+
+	/**********************************************************
+	*	unsigned IO_EHI_SetSPEED(unsigned uTAcc);
+	*
+	*	Input		: uTAcc = Access time in nano second
+	*	Output		:
+	*	Return		: previous CSCFG value
+	*
+	*	Description	: Set EHI Access parameter
+	************************************************************/
+	unsigned IO_EHI_SetSPEED(unsigned uTAcc);
+
+	/**********************************************************
+	*	unsigned IO_EHI_IncSPEED(int iTAccDelta);
+	*
+	*	Input		: iTAccDelta = Increment(+)/Decrement(-) of Access time in nano second
+	*	Output		:
+	*	Return		: Old TAcc
+	*
+	*	Description	: Increment EHI Access parameter
+	************************************************************/
+	unsigned IO_EHI_IncSPEED(int iTAccDelta);
+
+	/**********************************************************
+	*	void IO_EHI_WriteREG(unsigned uADDR, unsigned uDATA, unsigned uSize);
+	*
+	*	Input		: uADDR = Address of EHI Register
+	*				  uDATA = Data for EHI Register
+	*				  uSize = Register Size in byte.
+	*	Return		:
+	*	Description	: Write EHI Register
+	************************************************************/
+	void IO_EHI_WriteREG(unsigned uADDR, unsigned uDATA, unsigned uSize);
+
+	/**********************************************************
+	*	unsigned IO_EHI_ReadREG(unsigned uADDR, unsigned uSize);
+	*
+	*	Input		: uADDR = Address of EHI Register
+	*				  uSize = Register Size in byte.
+	*	Return		: Register value
+	*	Description	: Read EHI Register
+	************************************************************/
+	unsigned IO_EHI_ReadREG(unsigned uADDR, unsigned uSize);
+
+	/**********************************************************
+	*	unsigned IO_EHI_ReadST(void);
+	*
+	*	Input		:
+	*	Output		:
+	*	Return		: EHST value
+	*
+	*	Description	: Read EHST Register
+	************************************************************/
+	unsigned IO_EHI_ReadST(void);
+
+	/**********************************************************
+	*	unsigned IO_EHI_WriteDATA(unsigned uADDR, unsigned uParam1, unsigned uParam2);
+	*
+	*	Input		: uADDR = Address of EHI Slave memory.
+	*				  uParam1 = Pointer or Data value to write.
+	*				  uParam2
+	*					[31]   = Non-continuous(0), Continuous(1)
+	*					[30:0] = Data amount to Transfer (word unit)
+	*	Return		: 0
+	*	Description	: Write data to Memory of Slave
+	************************************************************/
+	unsigned IO_EHI_WriteDATA(unsigned uADDR, unsigned uParam1, unsigned uParam2);
+
+	/**********************************************************
+	*	unsigned IO_EHI_ReadDATA(unsigned uADDR, unsigned uParam1, unsigned uParam2);
+	*
+	*	Input		: uADDR = Address of EHI Slave memory.
+	*				  uParam1 = Pointer to store read data.
+	*				  uParam2
+	*					[31]   = Non-continuous (0), Continuous (1) transfer.
+	*					[30:0] = Data amount to Transfer (word unit)
+	*	Return		: Data value read or Pointer to bulk of data read.
+	*	Description	: Read data from Memory of Slave
+	************************************************************/
+	unsigned IO_EHI_ReadDATA(unsigned uADDR, unsigned uParam1, unsigned uParam2);
+#else
+	/**********************************************************
+	*	void IO_EHI_InitDRVS(unsigned uCONFIG);
+	*
+	*	Input		: uCONFIG = Configuration Parameter
+	*					Hw0 = 68000 (1), x86 (0) interface
+	*					Hw2 = 8bit (1), 16bit (0) interface
+	*					Hw3 = used as Ready signal (1), used as Interrupt signal (0)
+	*					Hw4 = Active Low Ready signal (1), Active High Ready signal (0)
+	*	Return		:
+	*	Description	: Initialize EHI I/F module at the Slave Site.
+	************************************************************/
+	void IO_EHI_InitDRVS(unsigned uCONFIG);
+#endif
+
+
+/************************************************************************
+*	Timer/Counter
+************************************************************************/
+#if defined(TCC92XX)
+	#define	IO_TMR_IREQT0	HwTIREQ_TI0
+	#define	IO_TMR_IREQT1	HwTIREQ_TI1
+	#define	IO_TMR_IREQT2	HwTIREQ_TI2
+	#define	IO_TMR_IREQT3	HwTIREQ_TI3
+	#define	IO_TMR_IREQT4	HwTIREQ_TI4
+	#define	IO_TMR_IREQT5	HwTIREQ_TI5
+	#define	IO_TMR_ClearTIREQ(X)	{ HwTMR->TIREQ = 1 << (X); }
+#else
+#ifdef TCC79XX
+	#define	IO_TMR_IREQT0	HwTIREQ_TI0
+	#define	IO_TMR_IREQT1	HwTIREQ_TI1
+	#define	IO_TMR_IREQT2	HwTIREQ_TI2
+	#define	IO_TMR_IREQT3	HwTIREQ_TI3
+	#define	IO_TMR_IREQT4	HwTIREQ_TI4
+	#define	IO_TMR_IREQT5	HwTIREQ_TI5
+#endif
+#define	IO_TMR_ClearTIREQ(X)	{ HwTIREQ = 1 << (X); }
+#endif
+
+/**********************************************************
+*	void IO_TMR_SetTIMER(unsigned uCH, unsigned uCTRL, unsigned uTREF, unsigned uTMREF);
+*
+*	Input		: uCH = Select timer channel. 0~5 is available.
+*				  uCTRL = Timer Control Register (HwTCFG) value.
+*				  uTREF = Timer Reference Register (HwTREF) value.
+*				  uTMREF = Timer Middle Reference Register (HwTMREF) value.
+*	Return		:
+*	Description	: Set and Enable a Timer/Counter (timer is automatically enabled regardless of uCTRL value)
+**********************************************************/
+void IO_TMR_SetTIMER(unsigned uCH, unsigned uCTRL, unsigned uTREF, unsigned uTMREF);
+
+/**********************************************************
+*	unsigned IO_TMR_GetTIMER(unsigned uCH);
+*
+*	Input		: uCH = Select timer channel. 0~5 is available.
+*	Return		: Current TCNT value.
+*	Description	: Get the current count value of channel.
+**********************************************************/
+unsigned IO_TMR_GetTIMER(unsigned uCH);
+
+/**********************************************************
+*	void IO_TMR_DisableTIMER(unsigned uCH);
+*
+*	Input		: uCH = Select timer channel. 0~5 is available.
+*	Return		:
+*	Description	: Disable a Timer
+**********************************************************/
+void IO_TMR_DisableTIMER(unsigned uCH);
+
+/**********************************************************
+*	void IO_TMR_EnableTIMER(unsigned uCH);
+*
+*	Input		: uCH = Select timer channel. 0~5 is available.
+*	Return		:
+*	Description	: Enable a Timer
+**********************************************************/
+void IO_TMR_EnableTIMER(unsigned uCH);
+
+#define	DBG_MAX_MEASURE		32
+#define	START_MEASURE		1
+#define	STOP_MEASURE		0
+
+typedef	struct
+{
+	unsigned	uStamp;				// Time Stamp value at the start time.
+	char		*pDescription;		// Timer description string.
+	unsigned	uPreCH;				// Bitmap of Channels that must to be enabled ahead to measure this channel.
+	unsigned	uMin;				// 1tic ~= 2.67us
+	unsigned	uMax;				// 1tic ~= 2.67us
+	unsigned	long long	uSum;	// summation of duration
+	unsigned	uNum;				// Number of durations measured. The average duration is acquired by (uSum / uNum)
+} sDBG_Timer;
+
+extern	sDBG_Timer	DBG_Timer[DBG_MAX_MEASURE];
+extern	unsigned	uMEA_CTRL, uMEA_STATE;
+
+/**********************************************************
+*	void IO_TMR_InitMEASURE(unsigned uCH);
+*
+*	Input		: uCH = Select a channel for initialize. (0xFFFFFFFF, 0 ~ 31 are possible, 0xFFFFFFFF means all of channel)
+*						(this is not same as physical timer channel number. this uses TIMER channel 4 only)
+*	Return		:
+*	Description	: Initialize MEASURE variables.
+*				  If all of channel should be initialized, use -1 as channel number.
+**********************************************************/
+void IO_TMR_InitMEASURE(unsigned uCH);
+
+/**********************************************************
+*	void IO_TMR_StartMEASURE(unsigned uCH, char *pDescriptor);
+*
+*	Input		: uCH = Select a channel for measure. (0 ~ 31 are possible)
+*						(this is not same as physical timer channel number. this uses TIMER channel 4 only)
+*				  pDescriptor = string for describing this channel.
+*	Return		:
+*	Description	: Start the timer for measuring a duration.
+*				  This uses only timer/counter 4.
+*				  It can measure the min/max/avg time duration of certain operation with limited period.
+**********************************************************/
+void IO_TMR_StartMEASURE(unsigned uCH, unsigned uPreCH, char *pDescriptor);
+void IO_TMR_StopMEASURE(unsigned uCH);
+void IO_TMR_StartMEASURE_NoIRQCnt(unsigned uCH, unsigned uPreCH, char *pDescriptor);
+unsigned IO_TMR_StopMEASURE_NoIRQCnt(unsigned uCH);
+
+/**********************************************************
+*	void IO_TMR_FinishMEASURE(unsigned uCH);
+*
+*	Input		: uCH = Select a channel for measure. (0 ~ 31 are possible)
+*						(this is not same as physical timer channel number. this uses TIMER channel 4 only)
+*	Return		:
+*	Description	: Finish the timer for measuring a duration.
+*				  This uses only timer/counter 4.
+*				  It stops measuring, and update min/max/sum/num field.
+**********************************************************/
+void IO_TMR_FinishMEASURE(unsigned uCH);
+
+/**********************************************************
+*	void IO_TMR_GetMEASURE(unsigned uCH, unsigned *pAvg, unsigned *pNum, unsigned *pMin, unsigned *pMax);
+*
+*	Input		: uCH = Select a channel for measure. (0 ~ 31 are possible)
+*						(this is not same as physical timer channel number. this uses TIMER channel 4 only)
+*				  pAvg = pointer for containing average time
+*				  pNum = pointer for containing number of times
+*				  pMin = pointer for containing minimum time
+*				  pMax = pointer for containing maximum time
+*				  *) all pointers can be zero not to contain values.
+*	Return		:
+*	Description	:
+**********************************************************/
+void IO_TMR_GetMEASURE(unsigned uCH, unsigned *pAvg, unsigned *pNum, unsigned *pMin, unsigned *pMax);
+
+// Time Duration Meter
+#ifndef USE_DOMEASURE
+	#define	DoMEASURE(CH, ONOFF, PreCH, Descriptor)			{;}
+#else
+	#define	DoMEASURE(CH, ONOFF, PreCH, Descriptor)			\
+	{														\
+		if (uMEA_CTRL & (1 << (CH)))						\
+		{													\
+			if ((ONOFF) != 0)								\
+				IO_TMR_StartMEASURE(CH, PreCH, Descriptor);	\
+			else											\
+				IO_TMR_FinishMEASURE(CH);					\
+		}													\
+	}
+#endif
+
+/**********************************************************
+*	unsigned int IO_TMR_Get32bitValue(void);
+*
+*	Input		:
+*	Return		: 32-bit Counter Current Value (main counter) 
+*	Description	:
+**********************************************************/
+unsigned int IO_TMR_Get32bitValue(void);
+
+
+/************************************************************************
+*	UART Controller
+************************************************************************/
+
+/**********************************************************
+*
+*	void IO_UART_Test(unsigned uCH);
+*
+*	Input		: uCH = channel number (0~2)
+*	Output		:
+*	Return		:
+*
+*	Description	: Test UART functions.
+**********************************************************/
+void IO_UART_Test(unsigned uCH);
+
+/**********************************************************
+*
+*	void IO_UART_Init(unsigned uCH);
+*
+*	Input		: uCH = channel number (0~2)
+*	Output		:
+*	Return		:
+*
+*	Description	: Initialize UART registers and UART Clocks.
+**********************************************************/
+void IO_UART_Init(unsigned uCH);
+
+/**********************************************************
+*
+*	void IO_UART_WriteString(unsigned uCH, const char *ccptrString)
+*
+*	Input		: uCH = channel number (0~2)
+*				  ccptrString = string to print
+*	Output		:
+*	Return		:
+*
+*	Description	: print argument string considering '\n' as '\r'+'n'.
+**********************************************************/
+void IO_UART_WriteString(unsigned uCH, const char *ccptrString);
+
+/**********************************************************
+*
+*	void IO_UART_WriteByte(unsigned uCH, char cChar)
+*
+*	Input		: uCH = channel number (0~2)
+*				  cChar = character to print
+*	Output		:
+*	Return		:
+*
+*	Description	: Print one character. Consider '\n' as '\r' + '\n'.
+**********************************************************/
+void IO_UART_WriteByte(unsigned uCH, char cChar);
+
+/**********************************************************
+*
+*	int IO_UART_InputByte(unsigned uCH, char *cptrChar)
+*
+*	Input		: uCH = channel number (0~2)
+*				  cptrChar = pointer for receiving character
+*	Output		:
+*	Return		: 0 = there is no input.
+*				  1 = there exist at least one byte and it is contained at the *cptrChar.
+*	Description	: Check there is at least one character in buffer, and if exist, store the code to *cptrChar and return 1.
+*				   Or return 0.
+**********************************************************/
+int IO_UART_InputByte(unsigned uCH, char *cptrChar);
+
+/**********************************************************
+*
+*	void IO_UART0_PutExtChar(unsigned uCH, const unsigned char cucChar)
+*
+*	Input		: uCH = channel number (0~2)
+*				  cucChar = character code
+*	Output		: Send one character
+*	Return		:
+*
+*	Description	: Print cucChar if cucChar is printable code or print '.' character.
+**********************************************************/
+void IO_UART_PutExtChar(unsigned uCH, const unsigned char cucChar);
+
+/**********************************************************
+*
+*	char IO_UART_GetChar(unsigned uCH)
+*
+*	Input		: uCH = channel number (0~2)
+*	Output		:
+*	Return		: Received character
+*
+*	Description	: Wait until at least one character is received & return the code with echoing.
+**********************************************************/
+char IO_UART_GetChar(unsigned uCH);
+
+/**********************************************************
+*
+*	char IO_UART_GetCh(unsigned uCH)
+*
+*	Input		: uCH = channel number (0~2)
+*	Output		:
+*	Return		: Received character
+*
+*	Description	: Wait until at least one character is received & return the code without echoing.
+**********************************************************/
+char IO_UART_GetCh(unsigned uCH);
+
+
+/************************************************************************
+*	RTC Controller
+************************************************************************/
+typedef struct {
+	unsigned	char		second;		// (0 ~ 59)
+	unsigned	char		minute;		// (0 ~ 59)
+	unsigned	char		hour;		// (0 ~ 23)
+	unsigned	char		day;		// Day of Week (SUN=0, MON, TUE, WED, THR, FRI, SAT=6)
+
+	unsigned	char		date;		// (1 ~ 28,29,30,31)
+	unsigned	char		month;		// (1 ~ 12)
+	unsigned short	year;
+} IO_RTC_DATETIME;
+
+/**********************************************************************************
+*	unsigned IO_RTC_Init(unsigned uWUPolarity);
+*
+*	Input		:
+*	Return		: 0
+*	Description	: Initialize RTC, RTC is disabled.
+*				  This function should not be called in normal case.
+**********************************************************************************/
+unsigned IO_RTC_Init(unsigned uWUPolarity);
+
+/**********************************************************************************
+*	unsigned IO_RTC_Start(void);
+*
+*	Input		:
+*	Return		: value of RTCCON register after enabled.
+*	Description	: RTC starts to operate.
+**********************************************************************************/
+unsigned IO_RTC_Start(void);
+
+/**********************************************************************************
+*	unsigned IO_RTC_Stop(void);
+*
+*	Input		:
+*	Return		: value of RTCCON register after disabled.
+*	Description	: RTC stops to operate.
+**********************************************************************************/
+unsigned IO_RTC_Stop(void);
+
+/**********************************************************************************
+*	unsigned IO_RTC_SetCON(unsigned uRTCCON);
+*
+*	Input		: uRTCCON = value for RTCCON register.
+*	Return		: value of RTCCON register after updated.
+*	Description	: Set RTCCON register as wanted value.
+**********************************************************************************/
+unsigned IO_RTC_SetCON(unsigned uRTCCON);
+
+/**********************************************************************************
+*	unsigned IO_RTC_GetTIME(IO_RTC_DATETIME *pTime);
+*	Input		: pTime = structure for getting RTC Time. (each element has decimal (non-BCD) value.)
+*	Return		: 0 = OK
+*				  1 = Read value has some error, and pTime contains predefined initial values
+*					 for calling IO_RTC_SetTIME();
+*	Description	: Get current time of RTC.
+*				  RTC has no power-on reset feature, it has random value after power-on.
+*				  It is reported by return value of 1 so user must re-set the current time.
+**********************************************************************************/
+unsigned IO_RTC_GetTIME(IO_RTC_DATETIME *pTime);
+
+/**********************************************************************************
+*	unsigned	IO_RTC_IsValidTime(void);
+*
+*	Input		: void
+*	Return		: 0 = OK
+*				  1 = Read value has some error
+*	Description	:This function is made to check whether current time setteing is correct or not
+*				 Maybe this function will be called by only the Janus core and will be used for setting
+*				 current RTC state(SET or UNSET).
+**********************************************************************************/
+unsigned IO_RTC_IsValidTime(void);
+
+/**********************************************************************************
+*	unsigned IO_RTC_SetTIME(RTC_APP_DATETIME *pTime);
+*
+*	Input		: pTime = structure for setting RTC Time (refer to IO_RTC_GetTIME())
+*	Return		: 0
+*	Description	:
+**********************************************************************************/
+unsigned IO_RTC_SetTIME(IO_RTC_DATETIME *pTime);
+
+/**********************************************************************************
+*	unsigned IO_RTC_SetBCDALARM(IO_RTC_DATETIME *pTime, unsigned uCON);
+*
+*	Input		: pTime = structure for setting RTC Time. (each element has BCD format)
+*				  uCON = same as HwRTCALM register map (refer to datasheet)
+*	Return		: 0
+*	Description	: Set ALARM time. It is not supported all combination of ALARM time.
+**********************************************************************************/
+unsigned IO_RTC_SetBCDALARM(IO_RTC_DATETIME *pTime, unsigned uCON);
+
+/**********************************************************************************
+*	unsigned IO_RTC_GetBCDTIME(RTC_APP_DATETIME *pTime);
+*
+*	Input		: pTime = structure for getting RTC Time. (BCD format)
+*	Return		: 0
+*	Description	: The current time is stored to structure pointed by pTime.
+**********************************************************************************/
+unsigned IO_RTC_GetBCDTIME(IO_RTC_DATETIME *pTime);
+
+/**********************************************************************************
+*	unsigned IO_RTC_SetBCDTIME(RTC_APP_DATETIME *pTime);
+*
+*	Input		: pTime = structure for setting RTC Time. (BCD format)
+*	Return		: 0
+*	Description	:
+**********************************************************************************/
+unsigned IO_RTC_SetBCDTIME(IO_RTC_DATETIME *pTime);
+
+/**********************************************************************************
+*	unsigned	IO_RTC_BCD2DEC( unsigned nBCD );
+*
+*	Input		: nBCD = BCD format value
+*	Return		: Equivalent value of hexa-decimal format
+*	Description	:
+**********************************************************************************/
+unsigned IO_RTC_BCD2DEC( unsigned nBCD );
+
+/**********************************************************************************
+*	unsigned	IO_RTC_DEC2BCD( unsigned uDEC );
+*
+*	Input		: nDEC = hexa-decimal format value
+*	Return		: Equivalent value of BCD format
+*	Description	:
+**********************************************************************************/
+unsigned IO_RTC_DEC2BCD( unsigned nDEC );
+
+/**********************************************************************************
+*	unsigned IO_RTC_SetALARM(IO_RTC_DATETIME *pTime);
+*
+*	Input		: pTime = structure for setting RTC Time. (Hexa-decimal format)
+*	Output		:
+*	Return		: 0 = OK
+*	Description	:
+**********************************************************************************/
+unsigned IO_RTC_SetALARM(IO_RTC_DATETIME *pTime);
+
+/**********************************************************************************
+*	unsigned IO_RTC_GetALARM(IO_RTC_DATETIME *pTime);
+*
+*	Input		: pTime = structure for setting RTC Time. (Hexa-decimal format)
+*	Output		:
+*	Return		: 0 = OK
+*	Description	:
+**********************************************************************************/
+unsigned IO_RTC_GetALARM(IO_RTC_DATETIME *pTime);
+
+/**********************************************************************************
+*	unsigned IO_RTC_WriteREG(volatile unsigned *pReg, unsigned uValue);
+*
+*	Input		: pReg = Register Address (BCD register address)
+*				  uValue = Register Value
+*	Return		: Register Value after writing.
+*	Description	:
+**********************************************************************************/
+unsigned IO_RTC_WriteREG(volatile unsigned *pReg, unsigned uValue);
+
+/**********************************************************************************
+*	unsigned	IO_RTC_GetBCDALARM(RTC_APP_DATETIME *pTime);
+*
+*	Input		: pTime = structure for setting RTC Time. (BCD format)
+*	Output		:
+*	Return		: HwRTCALM value
+*	Description	:
+**********************************************************************************/
+unsigned IO_RTC_GetBCDALARM(IO_RTC_DATETIME *pTime);
+
+/**************************************************************************
+ FUNCTION NAME : IO_RTC_DisableALMINT
+ 
+ DESCRIPTION : Disable Alarm Interrupt (ALMINT)
+ 
+ INPUT   : void - Parameter
+ OUTPUT  : void - Return Type
+ REMARK  : 
+**************************************************************************/
+void IO_RTC_DisableALMINT(void);
+
+/**********************************************************************************
+*	unsigned	IO_RTC_SetWKUP(IO_RTC_DATETIME *pTime, unsigned uActiveMode);
+*
+*	Input		: pTime = structure for setting RTC Time. (Hexa-decimal format)
+*				  uActiveMode : 1 = PMWKUP is active HIGH, 0 = PMWKUP is active LOW
+*	Output		:
+*	Return		: 0 = OK
+*	Description	: Set Wakeup Time. (System can be powered off & rebooted by wake-up signal)
+**********************************************************************************/
+unsigned IO_RTC_SetWKUP(IO_RTC_DATETIME *pTime, unsigned uActiveMode);
+
+
+
+/************************************************************************
+*	Debug Monitor
+************************************************************************/
+// Print Character for time stamp.
+#define	ST_ON	'1'
+#define	ST_OFF	'0'
+#ifndef WINVER
+#ifdef	USE_IO_DEBUG
+	//----------definition for GLOBAL monitoring ([7:0] are allocated)
+	#define	IO_DBG_Init			IO_DBG_Init_
+	#define	IO_DBG_Printf		IO_DBG_Printf_
+	#define	IO_DBG_SerialPrintf	IO_DBG_SerialPrintf_
+	#define	IO_DBG_Putc			IO_DBG_Putc_
+	#define	IO_DBG_TIME			HwTCNT4
+
+	//----------definition for GLOBAL monitoring ([-:0] are allocated)
+	#define	DBG_CTRL_USBD		Hw0
+	#define	DBG_CTRL_NFC		Hw1
+	#define	DBG_CTRL_DTCM		Hw2
+	#define	DBG_CTRL_SSFDC		Hw3
+	#define	DBG_CTRL_SSFDC_DRV	Hw4
+	#define	DBG_CTRL_FILE		Hw5
+	#define	DBG_CTRL_FAT		Hw6
+	#define	DBG_CTRL_MP3DEC	Hw7
+	//----------stamp definition ([31:-] are allocated)
+	#define	DBG_CTRL_STAMP0	Hw31
+	#define	DBG_CTRL_STAMP1	Hw30
+	#define	DBG_CTRL_STAMP2	Hw29
+	#define	DBG_CTRL_STAMP3	Hw28
+	#define	DBG_CTRL_STAMP4	Hw27
+	#define	DBG_CTRL_STAMP5	Hw26
+	#define	DBG_CTRL_STAMP6	Hw25
+	#define	DBG_CTRL_STAMP7	Hw24
+#else
+	// Disable All of monitoring functions
+	#define	IO_DBG_Init()			{;}
+	#define	IO_DBG_Printf(...)	
+	#define	IO_DBG_SerialPrintf(...)
+	#define	IO_DBG_Putc			
+	#define	IO_DBG_TIME			0
+
+	#define	DBG_CTRL_USBD		0
+	#define	DBG_CTRL_NFC		0
+	#define	DBG_CTRL_DTCM		0
+	#define	DBG_CTRL_SSFDC		0
+	#define	DBG_CTRL_SSFDC_DRV	0
+	#define	DBG_CTRL_FILE		0
+	#define	DBG_CTRL_FAT		0
+	#define	DBG_CTRL_MP3DEC		0
+	#define	DBG_CTRL_STAMP0		0
+	#define	DBG_CTRL_STAMP1		0
+	#define	DBG_CTRL_STAMP2		0
+	#define	DBG_CTRL_STAMP3		0
+	#define	DBG_CTRL_STAMP4		0
+	#define	DBG_CTRL_STAMP5		0
+	#define	DBG_CTRL_STAMP6		0
+	#define	DBG_CTRL_STAMP7		0
+#endif
+#endif
+#ifdef	CHECK_SPEED
+	// Stamp for
+	#define	MakeSTAMP0(X)	{if (uDBG_CTRL & DBG_CTRL_STAMP0) IO_DBG_Printf("[%05x]T0(%c)\n", IO_DBG_TIME, X);}
+
+	// Stamp for SSFDC_FS_WriteSector() execution time.
+	#define	MakeSTAMP1(X)	{if (uDBG_CTRL & DBG_CTRL_STAMP1) IO_DBG_Printf("[%05x]T1(%c)\n", IO_DBG_TIME, X);}
+
+	// Stamp for SSFDC_WriteSector() execution time.
+	#define	MakeSTAMP2(X)	{if (uDBG_CTRL & DBG_CTRL_STAMP2) IO_DBG_Printf("[%05x]T2(%c)\n", IO_DBG_TIME, X);}
+
+	// Stamp for read_file() or write_file() execution time.
+	#define	MakeSTAMP3(X)	{if (uDBG_CTRL & DBG_CTRL_STAMP3) IO_DBG_Printf("[%05x]T3(%c)\n", IO_DBG_TIME, X);}
+
+	// Stamp for
+	#define	MakeSTAMP4(X)	{if (uDBG_CTRL & DBG_CTRL_STAMP4) IO_DBG_Printf("[%05x]T4(%c)\n", IO_DBG_TIME, X);}
+
+	// Stamp for DISK_WriteSector() execution time.
+	#define	MakeSTAMP5(X)	{if (uDBG_CTRL & DBG_CTRL_STAMP5) IO_DBG_Printf("[%05x]T5(%c)\n", IO_DBG_TIME, X);}
+
+	// Stamp for pure NAND Data transfer execution time.
+	#define	MakeSTAMP6(X)	{if (uDBG_CTRL & DBG_CTRL_STAMP6) IO_DBG_Printf("[%05x]T6(%c)\n", IO_DBG_TIME, X);}
+
+	// Stamp for SSFDC_IO_R/W() execution time.
+	#define	MakeSTAMP7(X)	{if (uDBG_CTRL & DBG_CTRL_STAMP7) IO_DBG_Printf("[%05x]T7(%c)\n", IO_DBG_TIME, X);}
+#else
+	#define	MakeSTAMP0(X)	{;}
+	#define	MakeSTAMP1(X)	{;}
+	#define	MakeSTAMP2(X)	{;}
+	#define	MakeSTAMP3(X)	{;}
+	#define	MakeSTAMP4(X)	{;}
+	#define	MakeSTAMP5(X)	{;}
+	#define	MakeSTAMP6(X)	{;}
+	#define	MakeSTAMP7(X)	{;}
+#endif
+
+// definition for USB device monitoring
+#define	IO_USBD_Printf			if (uDBG_CTRL & DBG_CTRL_USBD) IO_DBG_Printf
+#define	IO_USBD_Putc(x)			if (uDBG_CTRL & DBG_CTRL_USBD) IO_DBG_Putc(x)
+// definition for NFC monitoring
+#define	IO_NFC_Printf			if (uDBG_CTRL & DBG_CTRL_NFC) IO_DBG_Printf
+#define	IO_NFC_Putc(x)			if (uDBG_CTRL & DBG_CTRL_NFC) IO_DBG_Putc(x)
+// definition for DTCM monitoring
+#define	IO_DTCM_Printf			if (uDBG_CTRL & DBG_CTRL_DTCM) IO_DBG_Printf
+#define	IO_DTCM_Putc(x)			if (uDBG_CTRL & DBG_CTRL_DTCM) IO_DBG_Putc(x)
+// definition for SSFDC monitoring
+#define	IO_SSFDC_Printf			if (uDBG_CTRL & DBG_CTRL_SSFDC) IO_DBG_Printf
+#define	IO_SSFDC_Putc(x)		if (uDBG_CTRL & DBG_CTRL_SSFDC) IO_DBG_Putc(x)
+// definition for SSFDC_DRV monitoring
+#define	IO_SSFDC_DRV_Printf		if (uDBG_CTRL & DBG_CTRL_SSFDC_DRV) IO_DBG_Printf
+#define	IO_SSFDC_DRV_Putc(x)	if (uDBG_CTRL & DBG_CTRL_SSFDC_DRV) IO_DBG_Putc(x)
+// definition for FILE monitoring
+#define	IO_FILE_Printf			if (uDBG_CTRL & DBG_CTRL_FILE) IO_DBG_Printf
+#define	IO_FILE_Putc(x)			if (uDBG_CTRL & DBG_CTRL_FILE) IO_DBG_Putc(x)
+// definition for FAT monitoring
+#define	IO_FAT_Printf			if (uDBG_CTRL & DBG_CTRL_FAT) IO_DBG_Printf
+#define	IO_FAT_Putc(x)			if (uDBG_CTRL & DBG_CTRL_FAT) IO_DBG_Putc(x)
+// definition for MP3DEC monitoring
+#define	IO_MP3DEC_Printf		if (uDBG_CTRL & DBG_CTRL_MP3DEC) IO_DBG_Printf
+#define	IO_MP3DEC_Putc(x)		if (uDBG_CTRL & DBG_CTRL_MP3DEC) IO_DBG_Putc(x)
+
+void IO_DBG_Printf_(char *format, ...);
+void IO_DBG_SerialPrintf_(char *format, ...);
+void IO_DBG_Sprintf(char *dst, char *format, ...);
+void IO_DBG_Putc_(char c);
+void IO_DBG_Init_(void);
+
+extern	const unsigned	IO_DBG_CRC_TABLE[256];
+unsigned IO_DBG_CalcCRC32_s(unsigned crc_in, unsigned data, unsigned size);
+
+/**********************************************************************************
+*	int stod(char *s);
+*
+*	Input		: s = string of decimal or hexa-decimal format
+*	Return		: converted value equivalent with s.
+*	Description	: if input string starts from "0x", it is regarded as hexa-decimal format,
+*				  or it is regarded as decimal format.
+**********************************************************************************/
+int stod(char *s);
+
+extern char		cDBG_txbuf[];		// all of string that is printed by IO_DBG_Printf() is stored at this buffer.
+									// this is ring type buffer.
+extern char		cDBG_rxbuf[];
+extern char		*p_prtbuf, cDirectPrint;
+extern unsigned	uDBG_CTRL, uDBG_txbuf_length;
+
+
+/************************************************************************
+*	UART
+************************************************************************/
+
+#ifdef TCC92XX
+// Should be fixed.
+/*
+	#define	IO_UART_CH		0
+
+	#define	IO_UART_LSR(X)	(((X) == 0) ? HwUART0_UTLSR : ((X) == 1) ? HwUART1_LSR : HwUART2_UTLSR)
+	#define	IO_UART_RCVD	Hw0
+	#define	IO_UART_TF(X)	(((X) == 0) ? HwUART0_UTLSR_TF_NOSTR : ((X) == 1) ? HwUART1_LSR_THRE_ON : HwUART2_UTLSR_TF_NOSTR)
+	#define	IO_UART_RXD(X)	(((X) == 0) ? HwUART0_UTRXD : ((X) == 1) ? HwUART1_RBR : HwUART2_UTRXD)
+	#define	IO_UART_TXD(X)	(((X) == 0) ? HwUART0_UTTXD : ((X) == 1) ? HwUART1_THR : HwUART2_UTTXD)
+	#define	IO_UART_WaitTXRDY(X)										\
+	{																	\
+		if ((X) == 0)														\
+			while (ISONE(HwUART0_UTLSR, HwUART0_UTLSR_TF_NOSTR));		\
+		else if ((X) == 1)													\
+			while (ISZERO(HwUART1_LSR, HwUART1_LSR_THRE_ON));			\
+		else if ((X) == 2)													\
+			while (ISONE(HwUART2_UTLSR, HwUART2_UTLSR_TF_NOSTR));		\
+	}
+	#define	IO_UART_WaitRXRDY(X)										\
+	{																	\
+		if ((X) == 0)														\
+			while (ISZERO(HwUART0_UTLSR, HwUART0_UTLSR_RA_RECV));		\
+		else if ((X) == 1)													\
+			while (ISZERO(HwUART1_LSR, HwUART1_LSR_DR_ON));			\
+		else if ((X) == 2)													\
+			while (ISZERO(HwUART2_UTLSR, HwUART2_UTLSR_RA_RECV));		\
+	}
+	#define	IO_UART_RXRDY(X)	( ((X) == 0) ? HwUART0_UTLSR & IO_UART_RCVD : \
+								  ((X) == 1) ? HwUART1_LSR & IO_UART_RCVD : HwUART2_UTLSR & IO_UART_RCVD )
+	#define	IO_UART_LSR_ERR(X)	( ((X) == 0) ? (HwUART0_UTLSR_FE_ERR | HwUART0_UTLSR_PE_ERR) :		\
+								  ((X) == 1) ? (HwUART1_LSR_FE_ON | HwUART1_LSR_PE_ON) :			\
+								  			(HwUART2_UTLSR_FE_ERR | HwUART2_UTLSR_PE_ERR) )
+	#define	IO_UART_ERR_Frame(X)	( ((X) == 0) ? HwUART0_UTLSR_FE_ERR : \
+									  ((X) == 1) ? HwUART1_LSR_FE_ON : HwUART2_UTLSR_FE_ERR )
+	#define	IO_UART_ERR_Parity(X)	( ((X) == 0) ? HwUART0_UTLSR_PE_ERR : \
+									  ((X) == 1) ? HwUART1_LSR_PE_ON : HwUART2_UTLSR_PE_ERR )
+*/									  
+#endif
+
+void IO_UART_Test(unsigned uCH);
+void IO_UART_Init(unsigned uCH);
+void IO_UART_WriteString(unsigned uCH, const char *ccptrString);
+void IO_UART_WriteByte(unsigned uCH, char cChar);
+int IO_UART_InputByte(unsigned uCH, char *cptrChar);
+void IO_UART_PutExtChar(unsigned uCH, const unsigned char cucChar);
+char IO_UART_GetChar(unsigned uCH);
+char IO_UART_GetCh(unsigned uCH);
+
+/************************************************************************
+*	GSIO & SPIS
+************************************************************************/
+
+#define	IO_GSIO_HwEN				Hw31
+#define	IO_GSIO_HwMSB1ST			Hw30
+#define	IO_GSIO_HwLSB1ST			HwZERO
+#define	IO_GSIO_HwWSIZE(X)			(((X)-1)*Hw26)
+#define	IO_GSIO_HwWSDYNAMIC			Hw25
+#define	IO_GSIO_HwDIV(X)			((X) * Hw18)
+#define	IO_GSIO_HwWSFIX				HwZERO
+#define	IO_GSIO_HwPOSSYNC			Hw17
+#define	IO_GSIO_HwNEGSYNC			HwZERO
+#define	IO_GSIO_HwMASKLSCK			Hw16
+#define	IO_GSIO_HwIEN				Hw15
+#define	IO_GSIO_HwTXDLY(X)			((X)*Hw13)
+#define	IO_GSIO_HwFRMACTHIGH		Hw12
+#define	IO_GSIO_HwFRMACTLOW			HwZERO
+#define	IO_GSIO_HwFRMST(X)			((X)*Hw6)
+#define	IO_GSIO_HwFRMEND(X)			((X)*Hw0)
+
+typedef	volatile struct
+{
+	unsigned	DO;
+	unsigned	DI;
+	unsigned	CTRL;
+	unsigned	dummy;
+} sHwGSIO;
+
+#define	IO_SPIS_HwTXFIFOCNT(X)		(((X)-1)*Hw29)
+#define	IO_SPIS_HwRXFIFOCNT(X)		(((X)-1)*Hw26)
+#define	IO_SPIS_HwISRC_RXCFULL		(0*Hw8)
+#define	IO_SPIS_HwISRC_RXFEMPTY		(1*Hw8)
+#define	IO_SPIS_HwISRC_RXFFULL		(2*Hw8)
+#define	IO_SPIS_HwISRC_TXCFULL		(4*Hw8)
+#define	IO_SPIS_HwISRC_TXFEMPTY		(5*Hw8)
+#define	IO_SPIS_HwISRC_TXFFULL		(6*Hw8)
+#define	IO_SPIS_HwMSB1ST			Hw5
+#define	IO_SPIS_HwLSB1ST			HwZERO
+#define	IO_SPIS_HwWSIZE(X)			(((X)/8-1)*Hw3)
+#define	IO_SPIS_HwPOSSYNC			Hw2
+#define	IO_SPIS_HwNEGSYNC			HwZERO
+#define	IO_SPIS_HwIEN				Hw1
+#define	IO_SPIS_HwEN				Hw0
+typedef struct
+{
+	unsigned	CTRL;
+	unsigned	DO;
+	unsigned	DI;
+	unsigned	dummy;
+} sHwSPIS;
+
+#define	IO_GSIO_WaitBUSY(CH, Tout)		{ Tout = 300;	 while (ISONE(HwGSGCR, Hw0 << (CH)) && (Tout --));	}
+#define	IO_SPIS_IsRXEMPTY(pSPIS)		ISONE((pSPIS)->CTRL, HwSPCTRL_EMP_RX)
+#define	IO_SPIS_IsRXFULL(pSPIS)			ISONE((pSPIS)->CTRL, HwSPCTRL_FUL_RX)
+#define	IO_SPIS_WaitRX(pSPIS, Tout)		{ Tout = 300; while (IO_SPIS_IsRXEMPTY(pSPIS) && (Tout --));	}
+#define	IO_SPIS_IsTXEMPTY(pSPIS)		ISONE((pSPIS)->CTRL, HwSPCTRL_EMP_TX)
+#define	IO_SPIS_IsTXFULL(pSPIS)			ISONE((pSPIS)->CTRL, HwSPCTRL_FUL_TX)
+#define	IO_SPIS_WaitTX(pSPIS, Tout)		{ Tout = 300; while (IO_SPIS_IsTXFULL(pSPIS) && (Tout --));	}
+
+/**********************************************************
+*	void IO_GSIO_InitCH(unsigned uCH, unsigned uCONTROL, unsigned uSCKfreq);
+*
+*	Input		: uCH = Select GSIO Master channel. 0~1 is available.
+*				  uCONTROL = GSIO control flags
+*					[31] = Enable(1)
+*					[30] = MSB First (1)
+*					[29:26] = Word Size (bit unit)
+*					[25] = Word size is dynamically controlled by GSDO register (1)
+*					[17] = Data transition occurs at the SCK rising (1)
+*					[16] = Mask out the last SCK (1)
+*					[15]	= Enable Interrupt (1)
+*					[14:13] = Transmission starting delay (1~3 is available)
+*					[12] = FRM is high active pulse
+*					[11:6] = FRM pulse start position
+*					[5:0] = FRM pulse end position
+*				  uSCKfreq = GSIO SCK clock frequency
+*	Return		:
+*	Description	: Set GSIO host channel
+**********************************************************/
+void IO_GSIO_InitCH(unsigned uCH, unsigned uCONTROL, unsigned uSCKfreq);
+
+/**********************************************************
+*	void IO_SPIS_InitCH(unsigned uCH, unsigned uCONTROL);
+*
+*	Input		: uCH = Select SPI slave channel. 0 is available.
+*				  uCONTROL = GSIO control flags
+*					[31:29] = TX FIFO count
+*					[28:26] = RX FIFO count
+*					[10:8] = Interrupt Source Selection
+*						0 : RX FIFO Counter Full
+*						1 : RX FIFO Empty
+*						2 : RX FIFO Full
+*						4 : TX FIFO Counter Full
+*						5 : TX FIFO Empty
+*						6 : TX FIFO Full
+*					[5] = MSB First (1)
+*					[4:3] = Word Size
+*						0 : 8bit, 1 : 16bit, 2 : 24bit, 3 : 32bit
+*					[2] = Data transition occurs at the SCK rising (1)
+*					[1] = Enable Interrupt (1)
+*					[0] = Enable (1)
+*	Return		:
+*	Description	: Set SPI slave channel
+**********************************************************/
+void IO_SPIS_InitCH(unsigned uCH, unsigned uCONTROL);
+
+enum
+{
+	LCD_18BIT_SET,
+	LCD_16BIT_SET,	
+	LCD_8BIT_SET
+};
+
+
+/************************************************************************
+*	Mail Box
+************************************************************************/
+typedef	volatile struct {
+	unsigned	TXD;
+	unsigned	uRsv1[7];
+	unsigned	RXD;
+	unsigned	uRsv2[7];
+	unsigned	CTR;
+	unsigned	STR;
+} sMBOX;
+
+enum {
+	MBOX_MAIN,
+	MBOX_SUB
+};
+
+
+/////////////////////////////////////////////
+
+#if !defined(_LINUX_)
+typedef	int (*ICallBack)(int num);
+#endif
+
+#define	ALIGN_UP(X, Y)				(((unsigned int)(X)+(unsigned int)(Y)-1) & ~((unsigned int)(Y)-1))
+
+
+/************************************************************************
+*	GPSB
+************************************************************************/
+typedef struct
+{
+	volatile unsigned long *BASE;
+	unsigned	uFRM, uSCK, uSDI, uSDO;
+	unsigned	uMODE;
+} sGPSBPORT;
+
+typedef struct	tag_sGPSBPacket
+{
+	char		TxStatus;		// 0=Empty, 1=Valid, 2=Sent
+	char		RxStatus;	// 0=Empty, 1=Wait, 2=Received
+	char		dummy[2];
+	unsigned	CurSize;
+	unsigned	*TxBufBASE;
+	unsigned	*RxBufBASE;
+} sGPSBPacket;
+
+typedef struct
+{
+	unsigned short	Num;		// total number of packet buffer.
+	unsigned short	CurNum;		// current number of packet buffer.
+	unsigned short	Head;		// Head
+	unsigned short	Tail;			// Tail
+	unsigned			MaxSize;		// Buffer Max size
+	sGPSBPacket		*Pkt;		// Packet Array
+} sGPSBPKTManager;
+
+typedef struct
+{
+	unsigned	char *pBuffer;
+	unsigned	short	uPktSize;
+	unsigned	short	uIncSize;
+	int		iRemainLength;
+} sGPSBTXManager;
+
+extern sGPSBPKTManager	gGPSBPKTManager[2];
+extern sGPSBTXManager	gGPSBTXManager[2];
+
+void IO_GPSB_WaitDONE(sGPSBPORT *pPORT);
+void IO_GPSBSW_DelayLOOP(unsigned uDelay);
+void IO_GPSBSW_SetFRM(sGPSBPORT *pPORT, unsigned uValue);
+void IO_GPSBSW_InvFRM(sGPSBPORT *pPORT);
+void IO_GPSBSW_SetSCK(sGPSBPORT *pPORT, unsigned uValue);
+void IO_GPSBSW_InvSCK(sGPSBPORT *pPORT);
+void IO_GPSBSW_SetSDO(sGPSBPORT *pPORT, unsigned uValue);
+unsigned IO_GPSBSW_GetSDI(sGPSBPORT *pPORT);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      IO_GPSB_ConfigPORT(unsigned uCHPort, unsigned uSDO, unsigned uMode);
+*  
+*  DESCRIPTION : Configure GPSB Channel and its PORT.
+*  
+*  INPUT:
+*			uCHPort	= GPSB Channel & I/O Port number
+*			[7:0]	= channel number (0 or 1)
+*			[8]		= I/O PORT number for GPSB Channel
+*					GPSB channel 0 can use 3 ports. (port number 0 ~ 2 are used)
+*						Port 0 : GPIO_E[19:16]
+*						Port 1 : GPIO_A[27:24]
+*						Port 2 : GPIO_C[15:12]
+*					GPSB channel 1 can only use 1 port. (port number 0 is used)
+*						Port 0 : GPIO_E[23:20]
+*
+*			uSDOSDI	= flag for using SDO or SDI pin
+*			[1]		= 0 : don't use SDO, 1 : use SDO
+*			[0]		= 0 : don't use SDI, 1 : use SDI
+*
+*			uMode	= 0 : for setting PORT as H/W, 1 : for setting PORT as GPIO
+*  
+*  OUTPUT:	
+*  			0 = Successful
+*			-1 = Illegal configuration.
+*  
+*  REMARK:	created on 2006 11 15   9:02:58    by vizirdo
+**************************************************************************/
+int IO_GPSB_ConfigPORT(unsigned uCHPort, unsigned uSDO, unsigned uMode);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      void IO_GPSB_InitCH(int iCH, unsigned uMode, unsigned uSCKfreq);
+*  
+*  DESCRIPTION : Initialize GPSB channel for Master mode only.
+*  
+*  INPUT:
+*			iCH		= GPSB Channel & I/O Port number
+*			[7:0]	= channel number (0 or 1)
+*			[8]		= I/O PORT number for GPSB Channel
+*					GPSB channel 0 can use 3 ports. (port number 0 ~ 2 are used)
+*						Port 0 : GPIO_E[19:16]
+*						Port 1 : GPIO_A[27:24]
+*						Port 2 : GPIO_C[15:12]
+*					GPSB channel 1 can only use 1 port. (port number 0 is used)
+*						Port 0 : GPIO_E[23:20]
+*
+*			uMode = Mode control
+*			[20] : PCS (0 = CS active low, 1 = CS active high)
+*			[17] : PD (0 = RX data on rising edge SCK & TX data on falling edge SCK)
+*					(1 = RX data on falling edge SCK & TX data on rising edge SCK)
+*			[16] : PCK (0 = SCK starts from 0, 1 = SCK starts from 1)
+*			[7] : Data shifting direction control. (0 = MSB first, 1 = LSB first)
+*
+*			uSCKfreq	= SCK frequency (with 100 Hz unit)
+*			uSW		= 0 for H/W mode, 1 for S/W mode.
+*  
+*  OUTPUT:	void - Return Type
+*  
+*  REMARK:	created on 2006 8 7   11:35:56    by vizirdo
+**************************************************************************/
+void IO_GPSB_InitCH(int iCH, unsigned uMode, unsigned uSCKfreq, unsigned uSW);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      unsigned	IO_GPSB_SendCMD(int iCH, unsigned uCmd, unsigned uCmdBitSize, unsigned uContinuous);
+*  
+*  DESCRIPTION : Send Command through GPSB port.
+*  
+*  INPUT:
+*			iCH	= channel number. (negative for using S/W SPI routine)
+*			uCmd	= command value
+*			uCmdBitSize	= bit size of command value.
+*			uContinuous	= flag for controlling nCS line. 
+*							if zero, nCS line goes to inactive state after the command value is sent.
+*							if non-zero, nCS line remains in active state so additional process for the command can follow.
+*  
+*  OUTPUT:	unsigned - Return Type
+*  			= response of command
+*  
+*  REMARK:	created on 2006 8 7   11:36:57    by vizirdo
+**************************************************************************/
+unsigned	IO_GPSB_SendCMD(int iCH, unsigned uCmd, unsigned uCmdBitSize, unsigned uContinuous);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      unsigned	IO_GPSB_TRxPKT(int iCH, void *pTxBuf, void *pRxBuf, unsigned uLength);
+*  
+*  DESCRIPTION : Transmit & Receive a packet data.
+*  
+*  INPUT:
+*			iCH		= GPSB Channel & I/O Port number (same as IO_GPSB_InitCH)
+*			pRxBuf	= base address of received data.
+*			pTxBuf	= base address of transmitting data.
+*			uLength	= data size (byte unit)
+*  
+*  OUTPUT:	unsigned - Return Type
+*  			= 0
+*  
+*  REMARK:	created on 2006 12 21   11:04:33    by vizirdo
+**************************************************************************/
+unsigned	IO_GPSB_TRxPKT(int iCH, void *pTxBuf, void *pRxBuf, unsigned uLength);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      unsigned	IO_GPSB_SendDATA(int iCH, unsigned char *pData, unsigned uLength, unsigned uBitConfig);
+*  
+*  DESCRIPTION : Send data through GPSB port
+*  
+*  INPUT:
+*			iCH	= channel number. (negative for using S/W SPI routine)
+*			pData		= pointer of data to send.
+*			uLength		= length of data to send.
+*			uBitConfig	= bit size of GPSB port.
+*  
+*  OUTPUT:	unsigned - Return Type
+*  			= 
+*  
+*  REMARK:	created on 2006 8 7   11:42:47    by vizirdo
+**************************************************************************/
+unsigned	IO_GPSB_SendDATA(int iCH, unsigned char *pData, unsigned uLength, unsigned uBitConfig);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      unsigned	IO_GPSB_RecvDATA(int iCH, unsigned char *pData, unsigned uLength, unsigned uBitConfig);
+*  
+*  DESCRIPTION : Receive data through GPSB port
+*  
+*  INPUT:
+*			iCH	= channel number. (negative for using S/W SPI routine)
+*			pData		= pointer of data to receive.
+*			uLength		= length of data to receive.
+*			uBitConfig	= 
+*  
+*  OUTPUT:	unsigned - Return Type
+*  			= 
+*  
+*  REMARK:	created on 2006 8 7   11:44:32    by vizirdo
+**************************************************************************/
+unsigned	IO_GPSB_RecvDATA(int iCH, unsigned char *pData, unsigned uLength, unsigned uBitConfig);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      void IO_GPSBS_InitCH(int iCH, unsigned uSDO, unsigned uMode);
+*  
+*  DESCRIPTION : Initialize GPSB channel for slave mode.
+*  
+*  INPUT:
+*			iCH		= GPSB Channel & I/O Port number
+*			[7:0]	= channel number (0 or 1)
+*			[8]		= I/O PORT number for GPSB Channel
+*					GPSB channel 0 can use 3 ports. (port number 0 ~ 2 are used)
+*						Port 0 : GPIO_E[19:16]
+*						Port 1 : GPIO_A[27:24]
+*						Port 2 : GPIO_C[15:12]
+*					GPSB channel 1 can only use 1 port. (port number 0 is used)
+*						Port 0 : GPIO_E[23:20]
+*
+*			uSDOSDI	= flag for using SDO or SDI pin
+*			[1]		= 0 : don't use SDO, 1 : use SDO
+*			[0]		= 0 : don't use SDI, 1 : use SDI
+*
+*			uMode	= GPSB Mode Selection
+*			[17]		= SDI capture control
+*				0 : SDI captured at rising edge SCK
+*				1 : SDI captured at falling edge SCK
+*			[16]		= SCK polarity control
+*				0 : SCKI is not inverted
+*				1 : SCKI is inverted
+*			[15:14]	= should be 3
+*			[12:8]	= Bit width - 1
+*			[7]		= 0 : MSB first, 1 : LSB first
+*			[4]		= 1 : continuous transfer mode
+*			[2]		= should be 1
+*			[0]		= 0 : SPI, 1 : SSP
+*  
+*  OUTPUT:	void - Return Type
+*  
+*  REMARK:	created on 2006 11 16   6:27:55    by vizirdo
+**************************************************************************/
+void IO_GPSBS_InitCH(int iCH, unsigned uSDO, unsigned uMode);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      int IO_GPSBS_ConfigDMA(unsigned uCH, unsigned uINTEN, unsigned uDMACTR, 
+*      	unsigned uPacketSize, unsigned uPacketNum);
+*  
+*  DESCRIPTION : Configurate a GPSB DMA setting for Transmit/Receive data.
+*                          GPSB & DMA operation is not yet enabled.
+*  
+*  INPUT:
+*			uCH			= channel number (0 or 1)
+*			uDMACTR	= DMACTR register value
+*			uINTEN		= INTEN register value
+*			uPacketNum	= number of packets
+*			uPacketSize	= packet size (byte unit)
+*  
+*  OUTPUT:	int - Return Type
+*  			= 0 : successful
+*			= negative : failure
+*  
+*  REMARK:	created on 2006 12 21   11:08:46    by vizirdo
+**************************************************************************/
+int IO_GPSBS_ConfigDMA(unsigned uCH, unsigned uINTEN, unsigned uDMACTR, 
+	unsigned uPacketSize, unsigned uPacketNum);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      int IO_GPSBS_StartRXDMA(unsigned uCH, unsigned uINTMode, unsigned uINTEN, unsigned uDMACTR, 
+*      	unsigned uPacketSize, unsigned uPacketNum, unsigned *pBuffer);
+*  
+*  DESCRIPTION : Start GPSB RX DMA at slave mode.
+*  
+*  INPUT:
+*			uCH			= GPSB channel number (0 or 1)
+*			uINTMode	= 0 : use edge triggered interrupt, 1 : use level triggered interrupt
+*			uINTEN		= GPSB.INTEN register value
+*			uDMACTR	= GPSB.DMACTR register value
+*			uPacketSize	= 1 packet size in bytes
+*			uPacketNum	= number of packets which RX DMA manipulate.
+*			pBuffer		= base of buffer to store RX data
+*  
+*  OUTPUT:	int - Return Type
+*  			= 0 : setup is successful.
+*			= -1 : illegal parameter
+*  
+*  REMARK:	created on 2006 11 16   9:29:16    by vizirdo
+**************************************************************************/
+int IO_GPSBS_StartRXDMA(unsigned uCH, unsigned uINTMode, unsigned uINTEN, unsigned uDMACTR, 
+	unsigned uPacketSize, unsigned uPacketNum, unsigned *pBuffer);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      void IO_GPSBS_EnablePKTDMA(unsigned uCH, unsigned uPktSize, unsigned *pTxBase, unsigned *pRxBase);
+*  
+*  DESCRIPTION : Enable GPSB & DMA Operation for packet data transfer.
+*  
+*  INPUT:
+*			uCH		= GPSB channel number (0 or 1)
+*			uPktSize	= packet size (in bytes)
+*			pTxBase	= base address of transmitting data buffer
+*			pRxBase	= base address of receiving data buffer
+*  
+*  OUTPUT:	void - Return Type
+*  
+*  REMARK:	created on 2006 12 21   11:11:50    by vizirdo
+**************************************************************************/
+void IO_GPSBS_EnablePKTDMA(unsigned uCH, unsigned uPktSize, unsigned *pTxBase, unsigned *pRxBase);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      void IO_GPSBS_EnableDMA(unsigned uCH, unsigned *pTxBase, unsigned *pRxBase);
+*  
+*  DESCRIPTION : Enable GPSB & DMA Operation for data transfer.
+*  
+*  INPUT:
+*			uCH		= GPSB channel number (0 or 1)
+*			pTxBase	= base address of transmitting data buffer
+*			pRxBase	= base address of receiving data buffer
+*  
+*  OUTPUT:	void - Return Type
+*  
+*  REMARK:	created on 2006 12 21   11:11:50    by vizirdo
+**************************************************************************/
+void IO_GPSBS_EnableDMA(unsigned uCH, unsigned *pTxBase, unsigned *pRxBase);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      void IO_GPSBS_DisableDMA(unsigned uCH);
+*  
+*  DESCRIPTION : Disable DMA Operation
+*  
+*  INPUT:
+*			uCH		= GPSB channel number (0 or 1)
+*  
+*  OUTPUT:	void - Return Type
+*  
+*  REMARK:	created on 2007/1/25    11:24:46    by vizirdo
+**************************************************************************/
+void IO_GPSBS_DisableDMA(unsigned uCH);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      void IO_GPSBS_PauseCH(int iCH);
+*  
+*  DESCRIPTION : Disable H/W Channel.
+*  
+*  INPUT:
+*			iCH	= channel number (0 or 1)
+*  
+*  OUTPUT:	void - Return Type
+*  
+*  REMARK:	created on 2006 11 17   12:25:30    by vizirdo
+**************************************************************************/
+void IO_GPSBS_PauseCH(int iCH);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      unsigned IO_GPSBS_CheckDATA(int iCH);
+*  
+*  DESCRIPTION : Check whether RX FIFO is empty or not.
+*  
+*  INPUT:
+*			iCH	= channel number (0 or 1)
+*  
+*  OUTPUT:	unsigned - Return Type
+*  			= 0 : RX FIFO is empty
+*			= 1 : RX FIFO is not empty
+*  
+*  REMARK:	created on 2006 11 18   6:40:50    by vizirdo
+**************************************************************************/
+unsigned IO_GPSBS_CheckDATA(int iCH);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      unsigned IO_GPSBS_GetDATA(int iCH);
+*  
+*  DESCRIPTION : Read RX FIFO
+*  
+*  INPUT:
+*			iCH	= channel number (0 or 1)
+*  
+*  OUTPUT:	unsigned - Return Type
+*  			= RX FIFO data.
+*  
+*  REMARK:	created on 2006 11 18   6:41:38    by vizirdo
+**************************************************************************/
+unsigned IO_GPSBS_GetDATA(int iCH);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      unsigned IO_GPSBS_SetDATA(int iCH, unsigned uData);
+*  
+*  DESCRIPTION : Send 1 word to master
+*  
+*  INPUT:
+*			iCH		= GPSB Channel number (0 or 1)
+*			uData	= Word value
+*  
+*  OUTPUT:	unsigned - Return Type
+*  			= FIFO valid count
+*  
+*  REMARK:	created on 2007/1/25    11:25:53    by vizirdo
+**************************************************************************/
+unsigned IO_GPSBS_SetDATA(int iCH, unsigned uData);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      unsigned IO_GPSBS_IsValidPKT(unsigned uCH);
+*  
+*  DESCRIPTION : Check Packet Buffer is empty or not.
+*  
+*  INPUT:
+*			uCH	= channel number (0 or 1)
+*  
+*  OUTPUT:	unsigned - Return Type
+*  			= 0 : Empty, 1 : Not empty
+*  
+*  REMARK:	created on 2006 12 14   9:37:16    by vizirdo
+**************************************************************************/
+unsigned IO_GPSBS_IsValidPKT(unsigned uCH);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      unsigned IO_GPSBS_IsFullPKT(unsigned uCH);
+*  
+*  DESCRIPTION : Check Packet Buffer is full or not.
+*  
+*  INPUT:
+*			uCH	= channel number (0 or 1)
+*  
+*  OUTPUT:	unsigned - Return Type
+*  			= 0 : Not full, 1 : Full
+*  
+*  REMARK:	created on 2006 12 14   9:45:53    by vizirdo
+**************************************************************************/
+unsigned IO_GPSBS_IsFullPKT(unsigned uCH);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      int IO_GPSBS_CheckEmptyPKT(unsigned uCH, char **ppRxBuf, char **ppTxBuf);
+*  
+*  DESCRIPTION : Check if there exist an empty packet buffer.
+*  
+*  INPUT:
+*			uCH		= channel number (0 or 1)
+*			ppRxBuf	= pointer to store base address of receiving data (NULL if not needed)
+*			ppTxBuf	= pointer to store base address of transmitting data (NULL if not needed)
+*  
+*  OUTPUT:	int - Return Type
+*  			= 1 : there exist an empty packet buffer, and its address is stored to ppRxBuf, ppTxBuf
+*  
+*  REMARK:	created on 2006 12 21   11:17:36    by vizirdo
+**************************************************************************/
+int IO_GPSBS_CheckEmptyPKT(unsigned uCH, char **ppRxBuf, char **ppTxBuf);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      int IO_GPSBS_PushPKT(unsigned uCH, unsigned char *pTxPKT, unsigned uSize);
+*  
+*  DESCRIPTION : Push a packet into packet buffer.
+*                          If pTxPkt == NULL, this packet only receives RX data.
+*  
+*  INPUT:
+*			uCH		= channel number (0 or 1)
+*			pTxPKT	= base address of transmitting data (NULL if not needed
+*			uSize	= size of data (in bytes)
+*  
+*  OUTPUT:	int - Return Type
+*  			= 0 : successful
+*			= negative : push failed
+*  
+*  REMARK:	created on 2006 12 21   11:20:32    by vizirdo
+**************************************************************************/
+int IO_GPSBS_PushPKT(unsigned uCH, unsigned char *pTxPKT, unsigned uSize);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      int IO_GPSBS_CheckValidPKT(unsigned uCH, char **ppRxBuf, char **ppTxBuf);
+*  
+*  DESCRIPTION : Check if there exist a valid packet buffer
+*  
+*  INPUT:
+*			uCH		= channel number (0 or 1)
+*			ppRxBuf	= pointer to store base address of receiving data (NULL if not needed)
+*			ppTxBuf	= pointer to store base address of transmitting data (NULL if not needed)
+*  
+*  OUTPUT:	int - Return Type
+*  			= 1 : there exist an valid packet buffer, and its address is stored to ppRxBuf, ppTxBuf
+*			= 0 : there is no valid packet. (packet is empty)
+*  
+*  REMARK:	created on 2006 12 21   11:24:29    by vizirdo
+**************************************************************************/
+int IO_GPSBS_CheckValidPKT(unsigned uCH, char **ppRxBuf, char **ppTxBuf);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      int IO_GPSBS_PopPKT(unsigned uCH, sHwGPSB *pHwGPSB, char *pRxBuf);
+*  
+*  DESCRIPTION : Pop a packet data and process next packet buffer. if packet buffer is empty, 
+*                          GPSB & DMA operation is disabled.
+*  
+*  INPUT:
+*			uCH			= channel number (0 or 1)
+*			pHwGPSB	= register base address for channel 0 or 1
+*			pRxBuf		= base address to store just received packet data.
+*  
+*  OUTPUT:	unsigned - Return Type
+*  			= 0 : there is no data.
+*			= 1 : last packet is just processed. GPSB & DMA operation is disabled
+*			= 2 : next packet operation starts.
+*  
+*  REMARK:	created on 2006 12 21   11:42:25    by vizirdo
+**************************************************************************/
+int IO_GPSBS_PopPKT(unsigned uCH, PGPSB pHwGPSB, char *pRxBuf);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      int IO_GPSBS_FlushPKT(unsigned uCH);
+*  
+*  DESCRIPTION : Remove existing all valid packet data
+*  
+*  INPUT:
+*			uCH	= channel number (0 or 1)
+*  
+*  OUTPUT:	int - Return Type
+*  			= 0 : successful
+*  
+*  REMARK:	created on 2006 12 22   2:24:50    by vizirdo
+**************************************************************************/
+int IO_GPSBS_FlushPKT(unsigned uCH);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      int IO_GPSBS_InsertPIDEntry(unsigned *pPIDTable, unsigned uPIDLength, int iIndex, unsigned uPIDValue, unsigned uPIDMask);
+*  
+*  DESCRIPTION : Insert PID entry at PID table
+*  
+*  INPUT:
+*			pPIDTable	= base address of PID table
+*			uPIDLength	= PID table length (0 ~ 63 is valid)
+*			iIndex		= index of PID table to insert. (if invalid index is used, search empty entry and insert at that index)
+*			uPIDValue	= PID bit field value
+*			uPIDMask	= PID Mask bit field value (1 = Masking Enabled, 0 = Masking Disabled)
+*
+*			uPIDMask & uPIDValue Format
+*				[14]		= PayLoad Start bit
+*				[13]		= Error Flag bit
+*				[12:0]	= PID value
+*  
+*  OUTPUT:	int - Return Type
+*  			= 0 ~ (uPIDLength-1) : index value which is selected to insert.
+*			= -1 : there is no empty entry
+**************************************************************************/
+int IO_GPSBS_InsertPIDEntry(unsigned *pPIDTable, unsigned uPIDLength, int iIndex, unsigned uPIDValue, unsigned uPIDMask);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      int IO_GPSBS_RemovePIDEntry(unsigned *pPIDTable, unsigned uPIDLength, int iIndex, unsigned uPIDValue, unsigned uPIDMask);
+*  
+*  DESCRIPTION : Remove PID entry at PID Table
+*  
+*  INPUT:
+*			pPIDTable	= base address of PID table
+*			uPIDLength	= PID table length (0 ~ 63 is valid)
+*			iIndex		= index of PID table to remove. 
+*						   (if invalid index is used, search matched entry with uPIDValue, uPIDMask and remove that entry)
+*			uPIDValue	= PID bit field value
+*			uPIDMask	= PID Mask bit field value (1 = Masking Enabled, 0 = Masking Disabled)
+*
+*			uPIDMask & uPIDValue Format
+*				[14]		= PayLoad Start bit
+*				[13]		= Error Flag bit
+*				[12:0]	= PID value
+*  
+*  OUTPUT:	int - Return Type
+*  			= 0 ~ (uPIDLength-1) : index value which is removed.
+*			= -1 : there is no matched entry
+**************************************************************************/
+int IO_GPSBS_RemovePIDEntry(unsigned *pPIDTable, unsigned uPIDLength, int iIndex, unsigned uPIDValue, unsigned uPIDMask);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      void	IO_GPSBS_StartTSIF(unsigned uCH, unsigned *pPIDTable, unsigned uPIDLength, unsigned uMatchPID, unsigned uMatchSync, 
+*      	unsigned *pBuffer, unsigned uPacketSize, unsigned uPacketNum);
+*  
+*  DESCRIPTION : Start TS I/F DMA mode
+*  
+*  INPUT:
+*			uCH			= GPSB Channel Number (0 or 1)
+*			pPIDTable	= base address of PID table
+*			uPIDLength	= entry size of PID table (1 ~ 64)
+*			uMatchPID	= 1 : PID filtering is enabled
+*			uMatchSync	= 1 : Sync byte matching is enabled
+*			pBuffer		= base address of RX DMA buffer (= uPacketSize * uPacketNum)
+*			uPacketSize	= packet size of RX DMA buffer
+*			uPacketNum	= packet number of RX DMA buffer
+*  
+*  OUTPUT:	void - Return Type
+**************************************************************************/
+void	IO_GPSBS_StartTSIF(unsigned uCH, unsigned *pPIDTable, unsigned uPIDLength, unsigned uMatchPID, unsigned uMatchSync, 
+	unsigned *pBuffer, unsigned uPacketSize, unsigned uPacketNum);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      int IO_GPSBS_CalcPKTConfig(unsigned uSize, unsigned uPktSize, unsigned *pPktNum);
+*  
+*  DESCRIPTION : Calculate packet number for uSize & uPktSize.
+*  
+*  INPUT:
+*			uSize	= Entire data size
+*			uPktSize	= 1 packet size
+*			pPktNum	= pointer to store calculated packet number.
+*  
+*  OUTPUT:	int - Return Type
+*  			= 1 : uSize is larger than maximum transfer size.
+*			= 0 : uSize is less or equal than maximum transfer size.
+*  
+*  REMARK:	created on 2007/1/25    12:7:0    by vizirdo
+**************************************************************************/
+int IO_GPSBS_CalcPKTConfig(unsigned uSize, unsigned uPktSize, unsigned *pPktNum);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      int IO_GPSBS_SendDATA(unsigned uCH, unsigned char *pBuffer, unsigned uSize, unsigned uPktSize);
+*  
+*  DESCRIPTION : Transmit bulk of data in slave mode.
+*  
+*  INPUT:
+*			uCH		= GPSB channel (0 or 1)
+*			pBuffer	= base address of bulk data.
+*			uSize	= size of bulk data.
+*			uPktSize	= 1 packet size for transmitting bulk of data. 
+*					   The Host should have idle time (~= 5ms) at every maximum transfer unit (= uPktSize * 32)
+*					   and must read uPktSize unit.
+*  
+*  OUTPUT:	int - Return Type
+*  			= 0 : Transfer begins
+*			= negative : invalid parameter
+*  
+*  REMARK:	created on 2007/1/25    12:51:55    by vizirdo
+**************************************************************************/
+int IO_GPSBS_SendDATA(unsigned uCH, unsigned char *pBuffer, unsigned uSize, unsigned uPktSize);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      int IO_GPSBS_GetRemainLength(unsigned uCH);
+*  
+*  DESCRIPTION : Get the size of data remains.
+*  
+*  INPUT:
+*			uCH	= GPSB Channel (0 or 1)
+*  
+*  OUTPUT:	int - Return Type
+*  			= Size of Data remains.
+*  
+*  REMARK:	created on 2007/1/25    12:56:38    by vizirdo
+**************************************************************************/
+int IO_GPSBS_GetRemainLength(unsigned uCH);
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      int IO_GPSBS_SendNextDATA(unsigned uCH);
+*  
+*  DESCRIPTION : Process next transfer for sending bulk of data.
+*  
+*  INPUT:
+*			uCH	= GPSB Channel (0 or 1)
+*  
+*  OUTPUT:	int - Return Type
+*  			= 0 : Transfer finished
+*			= 1 : Next packet is ready to be transferred
+*  
+*  REMARK:	created on 2007/1/25    12:58:4    by vizirdo
+**************************************************************************/
+int IO_GPSBS_SendNextDATA(unsigned uCH);
+
+
+#endif /* __IO_TCCXXX_H */
diff --git a/drivers/block/tcc/inc/tnftl/TC_DRV.h b/drivers/block/tcc/inc/tnftl/TC_DRV.h
new file mode 100644
index 0000000..dc516a8
--- /dev/null
+++ b/drivers/block/tcc/inc/tnftl/TC_DRV.h
@@ -0,0 +1,1700 @@
+/****************************************************************************
+ *   FileName    : TC_DRV.h
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+
+#ifndef	__TC_DRV_H__
+#define	__TC_DRV_H__
+
+#ifndef	__IO_TCCXXX_H
+#if defined(_LINUX_)
+#include <tnftl/IO_TCCXXX.h>
+#elif defined(_WINCE_)
+#include "IO_TCCXXX.h"
+#endif
+#endif
+
+//#include "TCCresource.h"
+
+/*==============================================================================
+				General DMA
+   ==============================================================================*/
+
+#define	DRV_GDMA_MAX_HANDLE		27
+
+// GDMA Driver Function Definition
+enum
+{
+	DRV_GDMA_FUNC_INIT,				// Driver Initialization : Argument = None
+	DRV_GDMA_FUNC_PROCESS_INTERRUPT,	// Process DMA Interrupt : Argument = None
+
+	DRV_GDMA_FUNC_OPEN,				// Open Handle : Argument = (Channel Number, *sDRV_GDMA)
+	DRV_GDMA_FUNC_INSTALL_HANDLER,	// Install DMA Interrupt Handler : Argument = (Channel, NewHandler, [* OldHandler])
+	DRV_GDMA_FUNC_UNINSTALL_HANDLER,	// UnInstall DMA Interrupt Handler : Argument = (Channel)
+
+	DRV_GDMA_FUNC_SETCFG,				// Configuration for DMA : Argument = (Handle, ConfigValue, ReqSel)
+	DRV_GDMA_FUNC_PARSECFG,			// Parse for DMA Configuration : parameter should be set ahead in structure : Argument = (Handle)
+	DRV_GDMA_FUNC_GETHwDMA,			// Get HwDMA Base Address : Argument = (Handle, *sHwDMA)
+	DRV_GDMA_FUNC_ISACTIVE,			// Check Activated State : Argument = (Handle)
+	DRV_GDMA_FUNC_SETREG,				// Setup DMA Register : Argument = (Handle, SrcBase, SrcInc, SrcMask, DstBase, DstInc, DstMask, DataSize) 
+	DRV_GDMA_FUNC_START,				// Start DMA Transfer : Argument = (Handle, SrcBase, SrcInc, SrcMask, DstBase, DstInc, DstMask, DataSize)
+	DRV_GDMA_FUNC_WAITDONE,			// Wait DMA Transfer Done : Argument = (Handle, [TimeOut Value], [TimeDelay(), TimeDelayFactor])
+	DRV_GDMA_FUNC_WAITDONE_STOP,		// Wait DMA Transfer Done & Stop DMA : Argument = (Handle, [TimeOut Value], [TimeDelay(), TimeDelayFactor])
+	DRV_GDMA_FUNC_PAUSE,				// Pause DMA Operation : Argument = (Handle)
+	DRV_GDMA_FUNC_CONTINUE,			// Continue DMA Operation : Argument = (Handle)
+	DRV_GDMA_FUNC_STOP,				// Stop DMA Operation -> This channel goes to IDLE state : Argument = (Handle)
+	DRV_GDMA_FUNC_CLOSE,				// Close DMA Channel from User : Argument = (Handle)
+	DRV_GDMA_FUNC_MAX
+};
+
+// GDMA Driver Status Definition
+enum
+{
+	DRV_GDMA_STATUS_INVALID,	// Not Opened
+	DRV_GDMA_STATUS_IDLE,		// Openad but Not Activated
+	DRV_GDMA_STATUS_PAUSE,	// Opened & Activated & Pause
+	DRV_GDMA_STATUS_ACTIVE,	// Opened & Activated
+	DRV_GDMA_STATUS_MAX
+};
+
+// GDMA Driver Data Structure
+typedef struct
+{
+	U32			CHCFG;
+	U32			REQSEL;
+
+	U8			CHSTS;
+	U8			BufShiftFactor;
+	U32			HwCHCTRL;
+	U32			HwREQSEL;
+#ifdef TCC89XX
+	PGDMACTRL	pHwDMA;
+#else
+	sHwDMA		*pHwDMA;
+#endif
+} sDRV_GDMA;
+
+// GDMA Driver Return Value Definition
+#define	DRV_GDMA_ERROR_YES	1
+#define	DRV_GDMA_ERROR_NO		0
+#define	DRV_GDMA_ERROR_OK		0
+enum
+{
+	// Error for Driver State
+	DRV_GDMA_ERROR_NOTINIT	= (int)0xF0040000,	// Non-init Function come before init function
+	DRV_GDMA_ERROR_DUPINIT,					// Init function called more than twice
+
+	// Error for Input Parameter
+	DRV_GDMA_ERROR_INVALID_FUNC,				// Function Code is out of range
+	DRV_GDMA_ERROR_INVALID_ARGUMENT,			// Number of Argument is out of range
+	DRV_GDMA_ERROR_INVALID_HANDLE,			// Handle value is out of range
+	DRV_GDMA_ERROR_INVALID_CH,				// Channel value is out of range
+
+	// Error for Resource Availability
+	DRV_GDMA_ERROR_NOTAVAILABLE_HANDLE,		// No available handle
+	DRV_GDMA_ERROR_NOTAVAILABLE_CH,			// No available channel
+
+	// Error for Operating
+	DRV_GDMA_ERROR_TIMEOUT,					// Time Out
+	DRV_GDMA_ERROR_NOT_READY,
+	DRV_GDMA_ERROR_NOT_ACTIVE,
+	DRV_GDMA_ERROR_NOT_PAUSE,
+
+	// Error for Illegal State
+	DRV_GDMA_ERROR_INTERNAL,					// Internal Bug
+
+	DRV_GDMA_ERROR_MAX
+};
+
+// GDMA Driver Channel Configuration Definition
+#define	DRV_GDMA_CFG_SyncHwReq				Hw13
+#define	DRV_GDMA_CFG_ASyncHwReq				0
+#define	DRV_GDMA_CFG_AckAtWrite				Hw12		// HwCHCTRL_HRD
+#define	DRV_GDMA_CFG_AckAtRead					0
+#define	DRV_GDMA_CFG_LockTransfer				Hw11		// HwCHCTRL_LOCK
+#define	DRV_GDMA_CFG_NoArbitration				Hw10		// HwCHCTRL_BST
+#define	DRV_GDMA_CFG_Arbitration					0
+#define	DRV_GDMA_CFG_StartBy_SHIFT				8
+#define	DRV_GDMA_CFG_StartBy(X)					((X)<<DRV_GDMA_CFG_StartBy_SHIFT)
+#define	DRV_GDMA_CFG_StartByHwReqEdge			DRV_GDMA_CFG_StartBy(0)
+#define	DRV_GDMA_CFG_StartByHwReqLevel			DRV_GDMA_CFG_StartBy(3)
+#define	DRV_GDMA_CFG_StartBySwReq				DRV_GDMA_CFG_StartBy(2)
+#define	DRV_GDMA_CFG_StartBy_MASK				DRV_GDMA_CFG_StartBy(3)
+#define	DRV_GDMA_CFG_ReadBW_8Bit				(0*Hw6)
+#define	DRV_GDMA_CFG_ReadBW_16Bit				(1*Hw6)
+#define	DRV_GDMA_CFG_ReadBW_32Bit				(2*Hw6)
+#define	DRV_GDMA_CFG_WriteBW_8Bit				(0*Hw4)
+#define	DRV_GDMA_CFG_WriteBW_16Bit				(1*Hw4)
+#define	DRV_GDMA_CFG_WriteBW_32Bit				(2*Hw4)
+#define	DRV_GDMA_CFG_InterruptEnable				Hw2			// HwCHCTRL_IEN
+#define	DRV_GDMA_CFG_RepeatEver				Hw1			// HwCHCTRL_REP
+
+#define	DRV_GDMA_CFG_1HopUnit_SHIFT			14
+#define	DRV_GDMA_CFG_1HopUnit(X)				((X)<<DRV_GDMA_CFG_1HopUnit_SHIFT)
+#define	DRV_GDMA_CFG_1HopUnit_1Byte			DRV_GDMA_CFG_1HopUnit(0)
+#define	DRV_GDMA_CFG_1HopUnit_2Byte			DRV_GDMA_CFG_1HopUnit(1)
+#define	DRV_GDMA_CFG_1HopUnit_4Byte			DRV_GDMA_CFG_1HopUnit(2)
+#define	DRV_GDMA_CFG_1HopUnit_8Byte			DRV_GDMA_CFG_1HopUnit(3)
+#define	DRV_GDMA_CFG_1HopUnit_16Byte			DRV_GDMA_CFG_1HopUnit(4)
+#define	DRV_GDMA_CFG_1HopUnit_32Byte			DRV_GDMA_CFG_1HopUnit(5)
+#define	DRV_GDMA_CFG_1HopUnit_MASK			DRV_GDMA_CFG_1HopUnit(7)
+#define	DRV_GDMA_CFG_1HopUnit_Auto				Hw17
+
+#define	DRV_GDMA_CFG_BufNum_SHIFT				18
+#define	DRV_GDMA_CFG_BufNum(X)				((X)<<DRV_GDMA_CFG_BufNum_SHIFT)
+#define	DRV_GDMA_CFG_BufNum_1					DRV_GDMA_CFG_BufNum(0)		// Single Buffering (DMA Interrupt Occurs after entire buffer is processed)
+#define	DRV_GDMA_CFG_BufNum_2					DRV_GDMA_CFG_BufNum(1)		// Double Buffering (DMA Interrupt Occurs after Half of buffer is processed)
+#define	DRV_GDMA_CFG_BufNum_4					DRV_GDMA_CFG_BufNum(2)		// Quad Buffering (DMA Interrupt Occurs after 1/4 of buffer is processed)
+#define	DRV_GDMA_CFG_BufNum_8					DRV_GDMA_CFG_BufNum(3)
+#define	DRV_GDMA_CFG_BufNum_16				DRV_GDMA_CFG_BufNum(4)
+#define	DRV_GDMA_CFG_BufNum_32				DRV_GDMA_CFG_BufNum(5)
+#define	DRV_GDMA_CFG_BufNum_64				DRV_GDMA_CFG_BufNum(6)
+#define	DRV_GDMA_CFG_BufNum_128				DRV_GDMA_CFG_BufNum(7)
+#define	DRV_GDMA_CFG_BufNum_256				DRV_GDMA_CFG_BufNum(8)
+#define	DRV_GDMA_CFG_BufNum_512				DRV_GDMA_CFG_BufNum(9)
+#define	DRV_GDMA_CFG_BufNum_1024				DRV_GDMA_CFG_BufNum(10)
+#define	DRV_GDMA_CFG_BufNum_2048				DRV_GDMA_CFG_BufNum(11)
+#define	DRV_GDMA_CFG_BufNum_4096				DRV_GDMA_CFG_BufNum(12)
+#define	DRV_GDMA_CFG_BufNum_8192				DRV_GDMA_CFG_BufNum(13)
+#define	DRV_GDMA_CFG_BufNum_16384				DRV_GDMA_CFG_BufNum(14)
+#define	DRV_GDMA_CFG_BufNum_32768				DRV_GDMA_CFG_BufNum(15)
+#define	DRV_GDMA_CFG_BufNum_MASK				DRV_GDMA_CFG_BufNum(15)
+
+// GDMA Driver H/W Request Selection Definition
+#define	DRV_GDMA_HwREQ_ECC					Hw0
+#define	DRV_GDMA_HwREQ_NFC					Hw1
+#define	DRV_GDMA_HwREQ_DAI_TX					Hw2
+#define	DRV_GDMA_HwREQ_DAI_RX					Hw3
+#define	DRV_GDMA_HwREQ_CDIF_RX				Hw4
+#define	DRV_GDMA_HwREQ_UART0_TX				Hw5
+#define	DRV_GDMA_HwREQ_UART0_RX				Hw6
+#define	DRV_GDMA_HwREQ_UART1_TX				Hw7
+#define	DRV_GDMA_HwREQ_UART1_RX				Hw8
+#define	DRV_GDMA_HwREQ_UART2_TX				Hw9
+#define	DRV_GDMA_HwREQ_UART2_RX				Hw10
+#define	DRV_GDMA_HwREQ_UART3_TX				Hw11
+#define	DRV_GDMA_HwREQ_UART3_RX				Hw12
+
+extern S32	DRV_GDMA(U32 Func, U32 ArgN, ...);
+
+/*==============================================================================
+				Timer
+   ==============================================================================*/
+
+#define	DRV_TMR_MAX_HANDLE						10
+enum
+{
+
+	DRV_TMR_FUNC_INIT,
+	DRV_TMR_FUNC_OPEN,
+	DRV_TMR_FUNC_SETCFG,
+	DRV_TMR_FUNC_CLOSE,
+	DRV_TMR_FUNC_START,
+	DRV_TMR_FUNC_ENABLE,
+	DRV_TMR_FUNC_DISABLE,
+
+	DRV_TMR_FUNC_MAX
+};
+
+
+// GDMA Driver Return Value Definition
+#define	DRV_TMR_ERROR_YES	1
+#define	DRV_TMR_ERROR_NO		0
+#define	DRV_TMR_ERROR_OK		0
+
+enum
+{
+	// Error for Driver State
+	DRV_TMR_ERROR_NOTINIT	= (int)0xF0040000,	// Non-init Function come before init function
+	DRV_TMR_ERROR_DUPINIT,					// Init function called more than twice
+
+	// Error for Input Parameter
+	DRV_TMR_ERROR_INVALID_FUNC,				// Function Code is out of range
+	DRV_TMR_ERROR_INVALID_ARGUMENT,			// Number of Argument is out of range
+	DRV_TMR_ERROR_INVALID_HANDLE,			// Handle value is out of range
+	DRV_TMR_ERROR_INVALID_CH,				// Channel value is out of range
+
+	// Error for Resource Availability
+	DRV_TMR_ERROR_NOTAVAILABLE_HANDLE,		// No available handle
+	DRV_TMR_ERROR_NOTAVAILABLE_CH,			// No available channel
+
+	// Error for Operating
+	DRV_TMR_ERROR_TIMEOUT,					// Time Out
+	DRV_TMR_ERROR_NOT_READY,
+	DRV_TMR_ERROR_NOT_ACTIVE,
+	DRV_TMR_ERROR_NOT_PAUSE,
+
+	// Error for Illegal State
+	DRV_TMR_ERROR_INTERNAL,					// Internal Bug
+
+	DRV_TMR_ERROR_MAX
+};
+
+// GDMA Driver Status Definition
+enum
+{
+	DRV_TMR_STATUS_INVALID,	// Not Opened
+	DRV_TMR_STATUS_IDLE,		// Openad but Not Activated
+	DRV_TMR_STATUS_PAUSE,	// Opened & Activated & Pause
+	DRV_TMR_STATUS_ACTIVE,	// Opened & Activated
+	DRV_TMR_STATUS_MAX
+};
+
+typedef struct
+{
+	U32		CHTCFG;
+	U32		CHTREF;
+	U32		CHTMREF;
+	U8		CHSTS;
+
+	U32		HwCHTCFG;
+	U32		HwCHTREF;
+	U32		HwCHTMREF;
+
+#ifdef TCC89XX
+	PTIMERN	pHwTMR;
+#else
+	sHwTMR	*pHwTMR;
+#endif
+	
+}sDRV_TMR;
+
+#define		TIMER_INT_ENABLE		1
+#define		TIMER_INT_DISABLE		0
+
+
+#define	DRV_TMR_CFG_ContinuousMode			0
+#define	DRV_TMR_CFG_OneTimeMode				Hw9
+#define	DRV_TMR_CFG_TCKDIVIDE2				0*Hw4
+#define	DRV_TMR_CFG_TCKDIVIDE4				1*Hw4
+#define	DRV_TMR_CFG_TCKDIVIDE8				2*Hw4
+#define	DRV_TMR_CFG_TCKDIVIDE16				3*Hw4
+#define	DRV_TMR_CFG_TCKDIVIDE32				4*Hw4
+#define	DRV_TMR_CFG_TCKDIVIDE1024			5*Hw4
+#define	DRV_TMR_CFG_TCKDIVIDE4096			6*Hw4
+#define	DRV_TMR_CFG_TCKEXTERNAL				7*Hw4
+#define	DRV_TMR_CFG_InterruptEnable			Hw3
+#define	DRV_TMR_CFG_InterruptDisable			0
+#define	DRV_TMR_CFG_PWMEnable				Hw2
+#define	DRV_TMR_CFG_PWMDisable				0
+#define	DRV_TMR_CFG_TCNTnSartCountTREFn		Hw1
+#define	DRV_TMR_CFG_TCNTnStartCountZero		0
+#define	DRV_TMR_CFG_TimerEnable				Hw0
+#define	DRV_TMR_CFG_TimerDisable				0
+
+extern S32	DRV_TIMER(U32 Func, U32 ArgN, ...);
+
+/*==============================================================================
+				UART
+   ==============================================================================*/
+
+#define	DRV_UART_MAX_HANDLE		10
+
+// UART Driver Function Definition
+enum
+{
+	DRV_UART_FUNC_INIT,					// UART Driver Initialization : Argument = None
+	DRV_UART_FUNC_PROCESS_INTERRUPT,	// Process UART Interrupt : Argument = [Channel]
+
+	DRV_UART_FUNC_OPEN,				// Open Handle : Argument = (Channel Number, [Port Number], *sDRV_UART)
+	DRV_UART_FUNC_INSTALL_HANDLER,		// Install UART Interrupt Handler : Argument = (Channel, NewHandler, [* OldHandler])
+	DRV_UART_FUNC_UNINSTALL_HANDLER,	// UnInstall UART Interrupt Handler : Argument = (Channel)
+
+	DRV_UART_FUNC_GETHwUART,			// Get HwUART Base Address : Argument = (Handle, *sHwUART)
+	DRV_UART_FUNC_SETCFG,				// Configurate UART : Argument = (Handle, Fuart, Baud, Interrupt, FifoCtrl, LineCtrl, AutoFlowControl)
+	DRV_UART_FUNC_SENDDATA,			// Send Data using UART Channel : Argument = (Handle, Byte)
+	DRV_UART_FUNC_RCVDATA,			// Receive Data using UART Channel : Argument = (Handle, *Byte)
+	DRV_UART_FUNC_OPENDMA,			// Set Registers for DMA Operation : Argument = (Handle, TriggerLevel, ParityFlag, StopBitNum, WordLength)
+	DRV_UART_FUNC_CLOSEDMA,			// Set Registers for Normal Operation : Argument = (Handle)
+
+	DRV_UART_FUNC_START,			// Start Handle : Argument = (Handle)
+	DRV_UART_FUNC_STOP,				// Stop Handle : Argument = (Handle)
+	DRV_UART_FUNC_CLOSE,			// Close Handle : Argument = (Handle)
+	
+	DRV_UART_FUNC_SC_OPEN,				// Open Smart Card Interface : Argument = (Handle)
+	DRV_UART_FUNC_SC_CLOSE,				// Close Smart Card Interface : Argument = (Handle)
+	DRV_UART_FUNC_SC_RESET,				// Reset Smart Card Interface : Argument = (Handle, pATRData, pATRLength)
+	DRV_UART_FUNC_SC_SENDDATA,			// Send Data to Smart Card : Argument = (Handle, pData, Length)
+	DRV_UART_FUNC_SC_RCVDATA,			// Receive Data from Smart Card : Argument = (Handle, pData, Length)
+
+	DRV_UART_FUNC_MAX
+};
+
+// UART Driver Status Definition
+enum
+{
+	DRV_UART_STATUS_INVALID,	// Not Opened
+	DRV_UART_STATUS_IDLE,		// Openad but Not Activated
+	DRV_UART_STATUS_PAUSE,		// Opened & Activated & Pause
+	DRV_UART_STATUS_ACTIVE,		// Opened & Activated
+	DRV_UART_STATUS_MAX
+};
+
+// UART Driver Data Structure
+typedef struct
+{
+	U32			BAUD;		// Baud Rate
+	U8			IER;		// Interrupt Enable Register
+	U8			FCR;		// FIFO Control Register
+	U8			LCR;		// Line Control Register
+	U8			AFT;		// Auto Flow Control Trigger Level Register
+	U32			Fuart;		// UART Main Clock Frequency
+	U32			SCCTRL;		// UART Smart Card Control
+	U32			SCCLK;		// UART Smart Card Clock
+
+	U8			CHSTS;		// Handle Status
+	U8			CHANNEL;	// Channel Number
+	U8			PORT;		// Port Number
+#ifdef TCC89XX
+	PUART		pHwUART;	// Base Address
+#else
+	sHwUART		*pHwUART;	// Base Address
+#endif
+} sDRV_UART;
+
+// UART Driver Buffer structure for Smart Card
+#define IO_UART_RX_BUFFER_SIZE		(1<<8)
+#define IO_UART_TX_BUFFER_SIZE		(1<<3)
+typedef struct
+{
+	U16			usTXHead, usTXTail;
+	U16			usRXHead, usRXTail;
+	U8			sRX_Buffer[IO_UART_RX_BUFFER_SIZE];
+	U8			sTX_Buffer[IO_UART_TX_BUFFER_SIZE];
+} sDRV_UART_BUF;
+
+// UART Driver Return Value Definition
+#define	DRV_UART_ERROR_YES		1
+#define	DRV_UART_ERROR_NO		0
+#define	DRV_UART_ERROR_OK		0
+enum
+{
+	// Error for Driver State
+	DRV_UART_ERROR_NOTINIT	= (int)0xF0055000,	// Non-init Function come before init function
+	DRV_UART_ERROR_DUPINIT,						// Init function called more than twice
+
+	// Error for Input Parameter
+	DRV_UART_ERROR_INVALID_FUNC,				// Function Code is out of range
+	DRV_UART_ERROR_INVALID_ARGUMENT,			// Number of Argument is out of range
+	DRV_UART_ERROR_INVALID_HANDLE,				// Handle value is out of range
+	DRV_UART_ERROR_INVALID_CH,					// Channel value is out of range
+
+	// Error for Resource Availability
+	DRV_UART_ERROR_NOTAVAILABLE_HANDLE,			// No available handle
+	DRV_UART_ERROR_NOTAVAILABLE_CH,				// No available channel
+
+	// Error for Receiving Operation
+	DRV_UART_ERROR_RCV_READY,					// Data is not ready
+	DRV_UART_ERROR_RCV_FRAMING,					// Received Data doesn't have a valid stop bit
+	DRV_UART_ERROR_RCV_PARITY,					// Received Data doesn't have a correct even/odd parity
+	
+	// Error for Illegal State
+	DRV_UART_ERROR_INTERNAL,					// Internal Bug
+
+	DRV_UART_ERROR_MAX
+};
+
+// UART Channel Number Definition
+enum
+{
+	DRV_UART_CH0 = 0,
+	DRV_UART_CH1,
+	DRV_UART_CH2,
+	DRV_UART_CH3,
+	DRV_UART_CHMAX
+};
+
+// UART Port Number Definition
+enum
+{
+	DRV_UART_PORT0 = 0,
+	DRV_UART_PORT1,
+	DRV_UART_PORT2,
+	DRV_UART_PORT3,
+	DRV_UART_PORT4,
+	DRV_UART_PORT5,
+	DRV_UART_PORTMAX
+};
+
+// UART Line Parity Definition
+enum
+{
+	DRV_UART_PARITY_NONE = 0,
+	DRV_UART_PARITY_ODD,
+	DRV_UART_PARITY_EVEN,
+	DRV_UART_PARITY_MAX
+};
+
+// UART Buffer Definition
+enum
+{
+	DRV_UART_BUFFER_TX = 0,
+	DRV_UART_BUFFER_RX,
+	DRV_UART_BUFFER_TXRX,
+	DRV_UART_BUFFER_MAX
+};
+
+// UART Smart Card Control Definition
+enum
+{
+	DRV_UART_SCCTRL_OFF = 0,
+	DRV_UART_SCCTRL_ON,
+	DRV_UART_SCCTRL_MAX
+};
+
+// UART Interrupt Definition for Smart Card
+enum
+{
+	DRV_UART_SCINT_DISABLE = 0,
+	DRV_UART_SCINT_ENABLE,
+	DRV_UART_SCINT_NOCHANGE,
+	DRV_UART_SCINT_MAX
+};
+
+// UART Application Definition
+enum 
+{ 
+	DRV_UART_APP_DEBUG = 0,	// Debugging by using tbench
+	DRV_UART_APP_BLUETOOTH,	// Bluetooth
+	DRV_UART_APP_SMARTCARD,	// SmartCard Interface
+	DRV_UART_APP_COMMAND,	// Command Interpreter for Module Solution
+	DRV_UART_APP_MAX
+};
+
+// UART Driver Channel Configuration Definition
+#define	DRV_UART_IER_EnableMSI				Hw3
+#define	DRV_UART_IER_DisableMSI				0
+#define	DRV_UART_IER_EnableRcvLSI			Hw2
+#define	DRV_UART_IER_DisableRcvLSI			0
+#define	DRV_UART_IER_EnableTXI				Hw1
+#define	DRV_UART_IER_DisableTXI				0
+#define	DRV_UART_IER_EnableRXI				Hw0
+#define	DRV_UART_IER_DisableRXI				0
+
+#define	DRV_UART_FCR_RxTriggerLvl_SHIFT		6
+#define	DRV_UART_FCR_RxTriggerLvl(X)			((X)<<DRV_UART_FCR_RxTriggerLvl_SHIFT)
+#define	DRV_UART_FCR_RxTriggerLvl_01			DRV_UART_FCR_RxTriggerLvl(0)
+#define	DRV_UART_FCR_RxTriggerLvl_04			DRV_UART_FCR_RxTriggerLvl(1)
+#define	DRV_UART_FCR_RxTriggerLvl_08			DRV_UART_FCR_RxTriggerLvl(2)
+#define	DRV_UART_FCR_RxTriggerLvl_14			DRV_UART_FCR_RxTriggerLvl(3)
+#define	DRV_UART_FCR_TxWindowLvl_SHIFT		4
+#define	DRV_UART_FCR_TxWindowLvl(X)			((X)<<DRV_UART_FCR_TxWindowLvl_SHIFT)
+#define	DRV_UART_FCR_TxWindowLvl_16			DRV_UART_FCR_TxWindowLvl(0)
+#define	DRV_UART_FCR_TxWindowLvl_08			DRV_UART_FCR_TxWindowLvl(1)
+#define	DRV_UART_FCR_TxWindowLvl_04			DRV_UART_FCR_TxWindowLvl(2)
+#define	DRV_UART_FCR_TxWindowLvl_01			DRV_UART_FCR_TxWindowLvl(3)
+#define	DRV_UART_FCR_EnableDMA				Hw3
+#define	DRV_UART_FCR_DisableDMA				0
+#define	DRV_UART_FCR_TxFifoReset			Hw2
+#define	DRV_UART_FCR_RxFifoReset			Hw1
+#define	DRV_UART_FCR_EnableFifo				Hw0
+#define	DRV_UART_FCR_DisableFifo			0
+
+#define	DRV_UART_LCR_AccessDivisor			Hw7
+#define	DRV_UART_LCR_NotAccessDivisor		0
+#define	DRV_UART_LCR_EnableBreak			Hw6
+#define	DRV_UART_LCR_DisableBreak			0
+#define	DRV_UART_LCR_EnableStickParity		Hw5
+#define	DRV_UART_LCR_DisableStickParity		0
+#define	DRV_UART_LCR_EnableEvenParity		Hw4
+#define	DRV_UART_LCR_EnableOddParity		0
+#define	DRV_UART_LCR_EnableParity			Hw3
+#define	DRV_UART_LCR_DisableParity			0
+#define	DRV_UART_LCR_OneStopBit				Hw2
+#define	DRV_UART_LCR_TwoStopBit				0
+#define	DRV_UART_LCR_WordLength_SHIFT		0
+#define	DRV_UART_LCR_WordLength(X)			((X)<<DRV_UART_LCR_WordLength_SHIFT)
+#define	DRV_UART_LCR_WordLength_5Bit		DRV_UART_LCR_WordLength(0)
+#define	DRV_UART_LCR_WordLength_6Bit		DRV_UART_LCR_WordLength(1)
+#define	DRV_UART_LCR_WordLength_7Bit		DRV_UART_LCR_WordLength(2)
+#define	DRV_UART_LCR_WordLength_8Bit		DRV_UART_LCR_WordLength(3)
+
+// UART SmartCard Clock Definition
+#define DRV_UART_SCCLK						60000 // 6.0 MHz
+// UART SmartCard Clock Conversion Factor Definition
+#define DRV_UART_SCCLK_FACTOR				372
+// UART SmartCard Delay Time Definition
+#define DRV_UART_SC_DELAY_TIME				4000 // 4.0 ms
+
+extern S32	DRV_UART(U32 Func, U32 ArgN, ...);
+
+/*==============================================================================
+				GPSB
+  ==============================================================================*/
+
+#define	DRV_GPSB_MAX_HANDLE		10
+
+// GPSB Driver Function Definition
+enum
+{
+	DRV_GPSB_FUNC_INIT,					// GPSB Driver Initialization : Argument = None
+	DRV_GPSB_FUNC_PROCESS_INTERRUPT,	// Process GPSB Interrupt : Argument = None
+
+	DRV_GPSB_FUNC_OPEN,					// Open Handle : Argument = (Channel Number, Port Number, *sDRV_GPSB)
+	DRV_GPSB_FUNC_INSTALL_HANDLER,		// Install Handler : Argument = (Channel, NewHandler, [* OldHandler])
+	DRV_GPSB_FUNC_UNINSTALL_HANDLER,	// Install Handler : Argument = (Channel)
+
+	DRV_GPSB_FUNC_GETHwGPSB,			// Get HwGPSB Base Address : Argument = (Handle, *sHwGPSB)
+	DRV_GPSB_FUNC_SETCFG,				// Configurate GPSB : Argument = (Handle, MODE, SCKFREQ, SWCTRL, SDOSDI)
+	DRV_GPSB_FUNC_SENDDATA,				// Send Data using GPSB Channel : Argument = (Handle, Cmd, *Buffer, Length, BitWidth)
+	DRV_GPSB_FUNC_RCVDATA,				// Receive Data using GPSB Channel : Argument = (Handle, Cmd, *Buffer, Length, BitWidth)
+	DRV_GPSB_FUNC_UPDATEPID,			// Update PID Table = (Handle, *PIDTable)
+	DRV_GPSB_FUNC_OPENDMA,				// Set Registers for DMA Operation : Argument = (Handle)
+	DRV_GPSB_FUNC_CLOSEDMA,				// Set Registers for Normal Operation : Argument = (Handle)
+	DRV_GPSB_FUNC_STARTDMA,				// Set Registers for Starting DMA Operation : Argument = (Handle, DMADir, PktSize, PktNum, *TxBuf, *RxBuf, FIFOThr, ContMode)
+	DRV_GPSB_FUNC_STOPDMA,				// Set Registers for Stopping DMA Operation : Argument = (Handle)
+
+	DRV_GPSB_FUNC_START,				// Start Handle : Argument = (Handle)
+	DRV_GPSB_FUNC_STOP,					// Stop Handle : Argument = (Handle)
+	DRV_GPSB_FUNC_CLOSE,				// Close Handle : Argument = (Handle)
+	
+	DRV_GPSB_FUNC_MAX
+};
+
+// GPSB Driver Status Definition
+enum
+{
+	DRV_GPSB_STATUS_INVALID,	// Not Opened
+	DRV_GPSB_STATUS_IDLE,		// Openad but Not Activated
+	DRV_GPSB_STATUS_PAUSE,		// Opened & Activated & Pause
+	DRV_GPSB_STATUS_ACTIVE,		// Opened & Activated
+	DRV_GPSB_STATUS_MAX
+};
+
+// GPSB DMA Mode Information Structure
+typedef struct
+{
+	U8			DMAMode;		// DMA Mode - Normal, MPEG2-TS			
+	U8			PIDMatch;		// PID Match Control - 0: Disable, 1: Enable
+	U8			SyncMatch;		// Sync Byte Match Control - 0: Disable, 1: Enable			
+	U8			PIDNum;			// Number of PID
+} sGPSB_DMA;
+
+// GPSB Driver Data Structure
+typedef struct
+{
+	U32			MODE;			// Mode Register
+	U32			SCKFREQ;		// SCK Frequency
+	U8			SWCTRL;			// Control Setting
+	U8			SDOSDI;			// Output/Input Use Setting
+	U8			CHSTS;			// Handle Status
+	U8			CHANNEL;		// Channel Number
+	U8			PORT;			// Port Number
+	sGPSB_DMA	DMAMODE;		// DMA Mode Information
+#ifdef TCC89XX
+	PGPSB		*pHwGPSB;		// Base Address
+#else
+	sHwGPSB		*pHwGPSB;		// Base Address
+#endif
+} sDRV_GPSB;
+
+// GPSB Driver Return Value Definition
+#define	DRV_GPSB_ERROR_YES		1
+#define	DRV_GPSB_ERROR_NO		0
+#define	DRV_GPSB_ERROR_OK		0
+enum
+{
+	// Error for Driver State
+	DRV_GPSB_ERROR_NOTINIT	= (int)0xF0057400,	// Non-init Function come before init function
+	DRV_GPSB_ERROR_DUPINIT,						// Init function called more than twice
+
+	// Error for Input Parameter
+	DRV_GPSB_ERROR_INVALID_FUNC,				// Function Code is out of range
+	DRV_GPSB_ERROR_INVALID_ARGUMENT,			// Number of Argument is out of range
+	DRV_GPSB_ERROR_INVALID_HANDLE,				// Handle value is out of range
+	DRV_GPSB_ERROR_INVALID_CH,					// Channel value is out of range
+
+	// Error for Resource Availability
+	DRV_GPSB_ERROR_NOTAVAILABLE_HANDLE,			// No available handle
+	DRV_GPSB_ERROR_NOTAVAILABLE_CH,				// No available channel
+
+	// Error for Illegal State
+	DRV_GPSB_ERROR_INTERNAL,					// Internal Bug
+
+	DRV_GPSB_ERROR_MAX
+};
+
+// GPSB Channel Control Method Definition
+enum
+{
+	DRV_GPSB_CTRL_HW = 0,
+	DRV_GPSB_CTRL_SW,
+	DRV_GPSB_CTRL_MAX
+};
+#define	DRV_GPSB_SwCtrlMode(X)		((X)&0x3F)
+
+// GPSB Tx/Rx Swap Mode Definition
+#define	DRV_GPSB_SWAP_TX		Hw6
+#define	DRV_GPSB_SWAP_RX		Hw7
+
+#define	DRV_GPSB_SwapMode(X)		((X) & (DRV_GPSB_SWAP_TX | DRV_GPSB_SWAP_RX))
+#define	DRV_GPSB_SwapMode_Tx(X)	(((X) & DRV_GPSB_SWAP_TX) ? 1 : 0)
+#define	DRV_GPSB_SwapMode_Rx(X)	(((X) & DRV_GPSB_SWAP_RX) ? 1 : 0)
+
+// GPSB Channel Master/Slave Definition
+enum
+{
+	DRV_GPSB_MODE_MASTER = 0,
+	DRV_GPSB_MODE_SLAVE,
+	DRV_GPSB_MODE_MAX
+};
+
+// GPSB Channel I/O Definition
+enum
+{
+	DRV_GPSB_SDOSDI_NOUSE = 0,
+	DRV_GPSB_SDOSDI_SDI,
+	DRV_GPSB_SDOSDI_SDO,
+	DRV_GPSB_SDOSDI_ALLUSE,
+	DRV_GPSB_SDOSDI_MAX
+};
+
+// GPSB Channel Number Definition
+enum
+{
+	DRV_GPSB_CH0 = 0,
+	DRV_GPSB_CH1,
+#if defined(TCC79XX) ||defined(TCC89XX)
+	DRV_GPSB_CH2,
+	DRV_GPSB_CH3,
+#endif
+#if defined(TCC89XX)
+	DRV_GPSB_CH4,
+	DRV_GPSB_CH5,
+#endif
+	DRV_GPSB_CHMAX
+};
+
+// GPSB Port Number Definition
+enum
+{
+	DRV_GPSB_PORT0 = 0,
+	DRV_GPSB_PORT1,
+	DRV_GPSB_PORT2,
+#if defined(TCC79XX) ||defined(TCC89XX)
+	DRV_GPSB_PORT3,
+	DRV_GPSB_PORT4,
+	DRV_GPSB_PORT5,
+	DRV_GPSB_PORT6,
+	DRV_GPSB_PORT7,
+	DRV_GPSB_PORT8,
+	DRV_GPSB_PORT9,
+	DRV_GPSB_PORT10,
+#endif
+#if defined(TCC89XX)
+	DRV_GPSB_PORT11,
+	DRV_GPSB_PORT12,
+#endif
+	DRV_GPSB_PORTMAX
+};
+
+// GPSB DMA Mode Definition
+enum
+{
+	DRV_GPSB_DMAMODE_NOR = 0,
+	DRV_GPSB_DMAMODE_TS,
+	DRV_GPSB_DMAMODE_MAX
+};
+
+// GPSB DMA Transfer Direction Definition
+enum
+{
+	DRV_GPSB_DMA_RECEIVE = 0,
+	DRV_GPSB_DMA_TRANSMIT,
+	DRV_GPSB_DMA_MAX
+};
+
+// GPSB Driver Channel Mode Definition
+#define	DRV_GPSB_MODE_Divisor_SHIFT			24
+#define	DRV_GPSB_MODE_Divisor(X)			((X)<<DRV_GPSB_MODE_Divisor_SHIFT)
+#define	DRV_GPSB_MODE_MRecoverTime_2SCKO	Hw23
+#define	DRV_GPSB_MODE_MRecoverTime_SCKO		0
+#define	DRV_GPSB_MODE_MHoldTime_2SCKO		Hw22
+#define	DRV_GPSB_MODE_MHoldTime_SCKO		0
+#define	DRV_GPSB_MODE_MSetupTime_2SCKO		Hw21
+#define	DRV_GPSB_MODE_MSetupTime_SCKO		0
+#define	DRV_GPSB_MODE_CSActiveHigh			Hw20
+#define	DRV_GPSB_MODE_CSActiveLow			0
+#define	DRV_GPSB_MODE_CMDActiveHigh			Hw19
+#define	DRV_GPSB_MODE_CMDActiveLow			0
+#define	DRV_GPSB_MODE_TransRisingEdge		Hw18
+#define	DRV_GPSB_MODE_TransFallingEdge		0
+#define	DRV_GPSB_MODE_RcvRisingEdge			Hw17
+#define	DRV_GPSB_MODE_RcvFallingEdge		0
+#define	DRV_GPSB_MODE_SCKPolCtrl_High		Hw16
+#define	DRV_GPSB_MODE_SCKPolCtrl_Low		0
+#define	DRV_GPSB_MODE_ClearRcvFifoCount		Hw15
+#define	DRV_GPSB_MODE_ClearTransFifoCount	Hw14
+#define	DRV_GPSB_MODE_BitWidth_SHIFT		8
+#define	DRV_GPSB_MODE_BitWidth(X)			((X)<<DRV_GPSB_MODE_BitWidth_SHIFT)
+#define	DRV_GPSB_MODE_DataShiftLSBFirst		Hw7
+#define	DRV_GPSB_MODE_DataShiftMSBFirst		0
+#define	DRV_GPSB_MODE_EnableLoopBack		Hw6
+#define	DRV_GPSB_MODE_DisableLoopBack		0
+#define	DRV_GPSB_MODE_EnableContTrans		Hw4
+#define	DRV_GPSB_MODE_DisableContTrans		0
+#define	DRV_GPSB_MODE_EnableOperation		Hw3
+#define	DRV_GPSB_MODE_DisableOperation		0
+#define	DRV_GPSB_MODE_SlaveMode				Hw2
+#define	DRV_GPSB_MODE_MasterMode			0
+#define	DRV_GPSB_MODE_OpMode_SHIFT			0
+#define	DRV_GPSB_MODE_OpMode(X)				((X)<<DRV_GPSB_MODE_OpMode_SHIFT)
+#define	DRV_GPSB_MODE_OpMod_SPI				DRV_GPSB_MODE_OpMode(0)
+#define	DRV_GPSB_MODE_OpMod_SSP				DRV_GPSB_MODE_OpMode(1)
+
+// GPSB PID Table Definition
+#define	DRV_GPSB_PID_MAX_NUM				32
+#define	DRV_GPSB_PID_VALUE_MASK				0x1FFF
+
+extern S32	DRV_GPSB(U32 Func, U32 ArgN, ...);
+
+
+/*==============================================================================
+				I2C
+   ==============================================================================*/
+int	DDI_I2C_Initialize(void);
+int	DDI_I2C_Terminate(void);
+int	DDI_I2C_Write(unsigned int uiFlag, unsigned int uiHbyte, unsigned int uiLbyte);
+int	DDI_I2C_Read(unsigned int uiFlag, unsigned int uiHbyte, unsigned int uiLbyte);
+
+#define	DRV_I2CM_MAX_HANDLE					10
+#define	DRV_I2CS_MAX_HANDLE					10
+
+#define	DRV_I2C_MASTER						1
+#define	DRV_I2C_SLAVE						2
+
+#define	DRV_I2C_MODE_8BIT					1
+#define	DRV_I2C_MODE_16BIT					2
+
+#define	DRV_IO_I2CM_CH0						0
+#define	DRV_IO_I2CM_CH1						1
+
+#define	DRV_IO_I2C_PORT0					0
+#define	DRV_IO_I2C_PORT1					1
+
+enum
+{
+
+	DRV_I2C_FUNC_INIT,
+	DRV_I2C_FUNC_OPEN,
+	DRV_I2C_FUNC_SETCFG,
+	DRV_I2C_FUNC_INSTALL_HANDLER,
+	DRV_I2C_FUNC_UNINSTALL_HANDLER,
+	DRV_I2C_FUNC_PROCESS_INTERRUPT,
+	DRV_I2C_FUNC_CLOSE,
+	DRV_I2C_FUNC_START,
+	DRV_I2C_FUNC_WRITE,
+	DRV_I2C_FUNC_READ,
+		
+	DRV_I2C_FUNC_MAX
+};
+
+
+// I2C Driver Return Value Definition
+#define	DRV_I2C_ERROR_YES						1
+#define	DRV_I2C_ERROR_NO						0
+#define	DRV_I2C_ERROR_OK						0
+
+enum
+{
+	// Error for Driver State
+	DRV_I2C_ERROR_NOTINIT	= (int)0xF0040000,	// Non-init Function come before init function
+	DRV_I2C_ERROR_DUPINIT,					// Init function called more than twice
+
+	// Error for Input Parameter
+	DRV_I2C_ERROR_INVALID_FUNC,				// Function Code is out of range
+	DRV_I2C_ERROR_INVALID_ARGUMENT,			// Number of Argument is out of range
+	DRV_I2C_ERROR_INVALID_HANDLE,			// Handle value is out of range
+	DRV_I2C_ERROR_INVALID_CH,				// Channel value is out of range
+
+	// Error for Resource Availability
+	DRV_I2C_ERROR_NOTAVAILABLE_HANDLE,		// No available handle
+	DRV_I2C_ERROR_NOTAVAILABLE_CH,			// No available channel
+
+	// Error for Operating
+	DRV_I2C_ERROR_TIMEOUT,					// Time Out
+	DRV_I2C_ERROR_NOT_READY,
+	DRV_I2C_ERROR_NOT_ACTIVE,
+	DRV_I2C_ERROR_NOT_PAUSE,
+
+	// Error for Illegal State
+	DRV_I2C_ERROR_INTERNAL,					// Internal Bug
+
+	DRV_I2C_ERROR_MAX
+};
+
+// I2C Driver Status Definition
+enum
+{
+	DRV_I2C_STATUS_INVALID,	// Not Opened
+	DRV_I2C_STATUS_IDLE,		// Openad but Not Activated
+	DRV_I2C_STATUS_PAUSE,	// Opened & Activated & Pause
+	DRV_I2C_STATUS_ACTIVE,	// Opened & Activated
+	DRV_I2C_STATUS_MAX
+};
+
+typedef struct
+{
+	U32			CHPRES;
+	U32			CHCTRL;
+	U8			CHSTS;
+
+	U32			SlaveAddr;
+	U32			PORT;
+	U32			BitMode;
+
+	U32			HWPRES;
+	U32			HWCTRL;
+	U32			HWSR;
+	U32			HWTR;
+
+#ifdef TCC89XX
+	I2CMASTER	*pHwI2CM;
+#else
+	sHwI2CM		*pHwI2CM;
+#endif
+
+}sDRV_I2CM;
+
+typedef struct
+{
+	U32			CHCTL;
+	U32			CHADDR;
+	U32			CHINT;
+	
+	U8			CHSTS;
+
+	U32			HwDPORT;
+	U32			HwCTL;
+	U32			HwADDR;
+	U32			HwINT;
+	U32			HwSTAT;
+	U32			HwMBF;
+	U32			HwMB0;
+	U32			HwMB1;	
+
+#ifdef TCC89XX
+	PI2CSLAVE	pHwI2CS;
+#else
+	sHwI2CS		*pHwI2CS;
+#endif
+	
+}sDRV_I2CS;
+
+#define	DRV_I2CM_SCL_400KHz							4000
+#define	DRV_I2CM_SCL_260KHz							2600
+#define	DRV_I2CM_SCL_200KHz							2000
+#define	DRV_I2CM_SCL_160KHz							1600
+#define	DRV_I2CM_SCL_133KHz							1330
+#define	DRV_I2CM_SCL_100KHz							1000
+
+#define	DRV_I2CM_CTR_I2CCoreEnable					Hw7
+#define	DRV_I2CM_CTR_I2CCoreDisable					0
+#define	DRV_I2CM_CTR_I2CCoreInterruptEnable			Hw6
+#define	DRV_I2CM_CTR_I2CCoreInterruptDisable			0
+#define	DRV_I2CM_CTR_I2CDataWidth8Bit					0
+#define	DRV_I2CM_CTR_I2CDataWidth16Bit				Hw5
+
+#define	DRV_I2CM_CMD_STA_Enable						Hw7
+#define	DRV_I2CM_CMD_STA_Disable						0
+#define	DRV_I2CM_CMD_STO_Enable						Hw6
+#define	DRV_I2CM_CMD_STO_Disable						0
+#define	DRV_I2CM_CMD_RD_Enable						Hw5
+#define	DRV_I2CM_CMD_RD_Disable						0
+#define	DRV_I2CM_CMD_WR_Enable						Hw4
+#define	DRV_I2CM_CMD_WR_Disable						0
+#define	DRV_I2CM_CMD_ACK_Enable						Hw3
+#define	DRV_I2CM_CMD_ACK_Disable						0
+#define	DRV_I2CM_CMD_LATCH_Enable					1
+#define	DRV_I2CM_CMD_LATCH_Disable					0
+
+#define	DRV_I2CS_CTL_0Master_1Master				0
+#define	DRV_I2CS_CTL_0Slave_1Master					Hw30
+#define	DRV_I2CS_CTL_0Master_1Slave					Hw31
+#define	DRV_I2CS_CTL_RXFIFOThreshold1				Hw8
+#define	DRV_I2CS_CTL_FIFO_Clear						Hw2
+#define	DRV_I2CS_CTL_I2CSlaveCoreEnable				Hw0
+#define	DRV_I2CS_CTL_I2CSlaveCoreDisable				0
+
+#define	DRV_I2CS_INT_STAT_R_BYTE						Hw27							// All byte of data buffer has been read by a master
+#define	DRV_I2CS_INT_STAT_W_BYTE						Hw26							// All byte of data buffer has been written by a master
+#define	DRV_I2CS_INT_STAT_R_BUFF						Hw25							// Data buffer has been read by a master
+#define	DRV_I2CS_INT_STAT_W_BUFF					Hw24							// Data buffer has been written by a master
+#define	DRV_I2CS_INT_STAT_TXUR						Hw23							// TX FIFO under run
+#define	DRV_I2CS_INT_STAT_RXOR						Hw22							// RX FIFO over run
+#define	DRV_I2CS_INT_STAT_TXB							Hw21							// TX bus cycle started with TX FIFO empty
+#define	DRV_I2CS_INT_STAT_RXF							Hw20							// RX FIFO full
+#define	DRV_I2CS_INT_STAT_TXE							Hw19							// TX FIFO empty
+#define	DRV_I2CS_INT_STAT_RXNE						Hw18							// RX FIFO not empty
+#define	DRV_I2CS_INT_STAT_TXL							Hw17							// TX FIFO Level (TXVC <= TXTH)
+#define	DRV_I2CS_INT_STAT_RXL							Hw16							// RX FIFO Level (RXVC <= RXTH)
+
+#define	DRV_I2CS_INT_EN_R_BYTE						Hw11							// All byte of data buffer has been read by a master
+#define	DRV_I2CS_INT_EN_W_BYTE						Hw10							// All byte of data buffer has been written by a master
+#define	DRV_I2CS_INT_EN_R_BUFF						Hw9								// Data buffer has been read by a master
+#define	DRV_I2CS_INT_EN_W_BUFF						Hw8								// Data buffer has been written by a master
+#define	DRV_I2CS_INT_EN_TXUR							Hw7								// TX FIFO under run
+#define	DRV_I2CS_INT_EN_RXOR							Hw6								// RX FIFO over run
+#define	DRV_I2CS_INT_EN_TXB							Hw5								// TX bus cycle started with TX FIFO empty
+#define	DRV_I2CS_INT_EN_RXF							Hw4								// RX FIFO full
+#define	DRV_I2CS_INT_EN_TXE							Hw3								// TX FIFO empty
+#define	DRV_I2CS_INT_EN_RXNE							Hw2								// RX FIFO not empty
+#define	DRV_I2CS_INT_EN_TXL							Hw1								// TX FIFO Level (TXVC <= TXTH)
+#define	DRV_I2CS_INT_EN_RXL							Hw0								// RX FIFO Level (RXVC <= RXTH)
+
+// I2C Master
+extern S32	DRV_I2CM(U32 Func, U32 ArgN, ...);
+
+// I2C Slave
+extern S32	DRV_I2CS( U32 Func, U32 ArgN, ... );
+
+
+/*==============================================================================
+				GPSB
+  ==============================================================================*/
+#if 0
+#define	DRV_GPSB_MAX_HANDLE		10
+
+// GPSB Driver Function Definition
+enum
+{
+	DRV_GPSB_FUNC_INIT,					// GPSB Driver Initialization : Argument = None
+	DRV_GPSB_FUNC_PROCESS_INTERRUPT,	// Process GPSB Interrupt : Argument = None
+
+	DRV_GPSB_FUNC_OPEN,					// Open Handle : Argument = (Channel Number, Port Number, *sDRV_GPSB)
+	DRV_GPSB_FUNC_INSTALL_HANDLER,		// Install Handler : Argument = (Channel, NewHandler, [* OldHandler])
+	DRV_GPSB_FUNC_UNINSTALL_HANDLER,	// Install Handler : Argument = (Channel)
+
+	DRV_GPSB_FUNC_GETHwGPSB,			// Get HwGPSB Base Address : Argument = (Handle, *sHwGPSB)
+	DRV_GPSB_FUNC_SETCFG,				// Configurate GPSB : Argument = (Handle, MODE, SCKFREQ, SWCTRL, SDOSDI)
+	DRV_GPSB_FUNC_SENDDATA,				// Send Data using GPSB Channel : Argument = (Handle, Cmd, *Buffer, Length, BitWidth)
+	DRV_GPSB_FUNC_RCVDATA,				// Receive Data using GPSB Channel : Argument = (Handle, Cmd, *Buffer, Length, BitWidth)
+	DRV_GPSB_FUNC_UPDATEPID,			// Update PID Table = (Handle, *PIDTable)
+	DRV_GPSB_FUNC_OPENDMA,				// Set Registers for DMA Operation : Argument = (Handle)
+	DRV_GPSB_FUNC_CLOSEDMA,				// Set Registers for Normal Operation : Argument = (Handle)
+	DRV_GPSB_FUNC_STARTDMA,				// Set Registers for Starting DMA Operation : Argument = (Handle, DMADir, PktSize, PktNum, *TxBuf, *RxBuf, FIFOThr, ContMode)
+	DRV_GPSB_FUNC_STOPDMA,				// Set Registers for Stopping DMA Operation : Argument = (Handle)
+
+	DRV_GPSB_FUNC_START,				// Start Handle : Argument = (Handle)
+	DRV_GPSB_FUNC_STOP,					// Stop Handle : Argument = (Handle)
+	DRV_GPSB_FUNC_CLOSE,				// Close Handle : Argument = (Handle)
+	
+	DRV_GPSB_FUNC_MAX
+};
+
+// GPSB Driver Status Definition
+enum
+{
+	DRV_GPSB_STATUS_INVALID,	// Not Opened
+	DRV_GPSB_STATUS_IDLE,		// Openad but Not Activated
+	DRV_GPSB_STATUS_PAUSE,		// Opened & Activated & Pause
+	DRV_GPSB_STATUS_ACTIVE,		// Opened & Activated
+	DRV_GPSB_STATUS_MAX
+};
+
+// GPSB DMA Mode Information Structure
+typedef struct
+{
+	U8			DMAMode;		// DMA Mode - Normal, MPEG2-TS			
+	U8			PIDMatch;		// PID Match Control - 0: Disable, 1: Enable
+	U8			SyncMatch;		// Sync Byte Match Control - 0: Disable, 1: Enable			
+	U8			PIDNum;			// Number of PID
+} sGPSB_DMA;
+
+// GPSB Driver Data Structure
+typedef struct
+{
+	U32			MODE;			// Mode Register
+	U32			SCKFREQ;		// SCK Frequency
+	U8			SWCTRL;			// Control Setting
+	U8			SDOSDI;			// Output/Input Use Setting
+	U8			CHSTS;			// Handle Status
+	U8			CHANNEL;		// Channel Number
+	U8			PORT;			// Port Number
+	sGPSB_DMA	DMAMODE;		// DMA Mode Information
+	sHwGPSB		*pHwGPSB;		// Base Address
+} sDRV_GPSB;
+
+// GPSB Driver Return Value Definition
+#define	DRV_GPSB_ERROR_YES		1
+#define	DRV_GPSB_ERROR_NO		0
+#define	DRV_GPSB_ERROR_OK		0
+enum
+{
+	// Error for Driver State
+	DRV_GPSB_ERROR_NOTINIT	= (int)0xF0057400,	// Non-init Function come before init function
+	DRV_GPSB_ERROR_DUPINIT,						// Init function called more than twice
+
+	// Error for Input Parameter
+	DRV_GPSB_ERROR_INVALID_FUNC,				// Function Code is out of range
+	DRV_GPSB_ERROR_INVALID_ARGUMENT,			// Number of Argument is out of range
+	DRV_GPSB_ERROR_INVALID_HANDLE,				// Handle value is out of range
+	DRV_GPSB_ERROR_INVALID_CH,					// Channel value is out of range
+
+	// Error for Resource Availability
+	DRV_GPSB_ERROR_NOTAVAILABLE_HANDLE,			// No available handle
+	DRV_GPSB_ERROR_NOTAVAILABLE_CH,				// No available channel
+
+	// Error for Illegal State
+	DRV_GPSB_ERROR_INTERNAL,					// Internal Bug
+
+	DRV_GPSB_ERROR_MAX
+};
+
+// GPSB Channel Control Method Definition
+enum
+{
+	DRV_GPSB_CTRL_HW = 0,
+	DRV_GPSB_CTRL_SW,
+	DRV_GPSB_CTRL_MAX
+};
+#define	DRV_GPSB_SwCtrlMode(X)		((X)&0x3F)
+
+// GPSB Tx/Rx Swap Mode Definition
+#define	DRV_GPSB_SWAP_TX		Hw6
+#define	DRV_GPSB_SWAP_RX		Hw7
+
+#define	DRV_GPSB_SwapMode(X)		((X) & (DRV_GPSB_SWAP_TX | DRV_GPSB_SWAP_RX))
+#define	DRV_GPSB_SwapMode_Tx(X)	(((X) & DRV_GPSB_SWAP_TX) ? 1 : 0)
+#define	DRV_GPSB_SwapMode_Rx(X)	(((X) & DRV_GPSB_SWAP_RX) ? 1 : 0)
+
+// GPSB Channel Master/Slave Definition
+enum
+{
+	DRV_GPSB_MODE_MASTER = 0,
+	DRV_GPSB_MODE_SLAVE,
+	DRV_GPSB_MODE_MAX
+};
+
+// GPSB Channel I/O Definition
+enum
+{
+	DRV_GPSB_SDOSDI_NOUSE = 0,
+	DRV_GPSB_SDOSDI_SDI,
+	DRV_GPSB_SDOSDI_SDO,
+	DRV_GPSB_SDOSDI_ALLUSE,
+	DRV_GPSB_SDOSDI_MAX
+};
+
+// GPSB Channel Number Definition
+enum
+{
+	DRV_GPSB_CH0 = 0,
+	DRV_GPSB_CH1,
+#ifdef TCC79XX
+	DRV_GPSB_CH2,
+	DRV_GPSB_CH3,
+#endif
+	DRV_GPSB_CHMAX
+};
+
+// GPSB Port Number Definition
+enum
+{
+	DRV_GPSB_PORT0 = 0,
+	DRV_GPSB_PORT1,
+	DRV_GPSB_PORT2,
+#ifdef TCC79XX
+	DRV_GPSB_PORT3,
+	DRV_GPSB_PORT4,
+	DRV_GPSB_PORT5,
+	DRV_GPSB_PORT6,
+	DRV_GPSB_PORT7,
+	DRV_GPSB_PORT8,
+	DRV_GPSB_PORT9,
+	DRV_GPSB_PORT10,
+#endif
+	DRV_GPSB_PORTMAX
+};
+
+// GPSB DMA Mode Definition
+enum
+{
+	DRV_GPSB_DMAMODE_NOR = 0,
+	DRV_GPSB_DMAMODE_TS,
+	DRV_GPSB_DMAMODE_MAX
+};
+
+// GPSB DMA Transfer Direction Definition
+enum
+{
+	DRV_GPSB_DMA_RECEIVE = 0,
+	DRV_GPSB_DMA_TRANSMIT,
+	DRV_GPSB_DMA_MAX
+};
+
+// GPSB Driver Channel Mode Definition
+#define	DRV_GPSB_MODE_Divisor_SHIFT			24
+#define	DRV_GPSB_MODE_Divisor(X)			((X)<<DRV_GPSB_MODE_Divisor_SHIFT)
+#define	DRV_GPSB_MODE_MRecoverTime_2SCKO	Hw23
+#define	DRV_GPSB_MODE_MRecoverTime_SCKO		0
+#define	DRV_GPSB_MODE_MHoldTime_2SCKO		Hw22
+#define	DRV_GPSB_MODE_MHoldTime_SCKO		0
+#define	DRV_GPSB_MODE_MSetupTime_2SCKO		Hw21
+#define	DRV_GPSB_MODE_MSetupTime_SCKO		0
+#define	DRV_GPSB_MODE_CSActiveHigh			Hw20
+#define	DRV_GPSB_MODE_CSActiveLow			0
+#define	DRV_GPSB_MODE_CMDActiveHigh			Hw19
+#define	DRV_GPSB_MODE_CMDActiveLow			0
+#define	DRV_GPSB_MODE_TransRisingEdge		Hw18
+#define	DRV_GPSB_MODE_TransFallingEdge		0
+#define	DRV_GPSB_MODE_RcvRisingEdge			Hw17
+#define	DRV_GPSB_MODE_RcvFallingEdge		0
+#define	DRV_GPSB_MODE_SCKPolCtrl_High		Hw16
+#define	DRV_GPSB_MODE_SCKPolCtrl_Low		0
+#define	DRV_GPSB_MODE_ClearRcvFifoCount		Hw15
+#define	DRV_GPSB_MODE_ClearTransFifoCount	Hw14
+#define	DRV_GPSB_MODE_BitWidth_SHIFT		8
+#define	DRV_GPSB_MODE_BitWidth(X)			((X)<<DRV_GPSB_MODE_BitWidth_SHIFT)
+#define	DRV_GPSB_MODE_DataShiftLSBFirst		Hw7
+#define	DRV_GPSB_MODE_DataShiftMSBFirst		0
+#define	DRV_GPSB_MODE_EnableLoopBack		Hw6
+#define	DRV_GPSB_MODE_DisableLoopBack		0
+#define	DRV_GPSB_MODE_EnableContTrans		Hw4
+#define	DRV_GPSB_MODE_DisableContTrans		0
+#define	DRV_GPSB_MODE_EnableOperation		Hw3
+#define	DRV_GPSB_MODE_DisableOperation		0
+#define	DRV_GPSB_MODE_SlaveMode				Hw2
+#define	DRV_GPSB_MODE_MasterMode			0
+#define	DRV_GPSB_MODE_OpMode_SHIFT			0
+#define	DRV_GPSB_MODE_OpMode(X)				((X)<<DRV_GPSB_MODE_OpMode_SHIFT)
+#define	DRV_GPSB_MODE_OpMod_SPI				DRV_GPSB_MODE_OpMode(0)
+#define	DRV_GPSB_MODE_OpMod_SSP				DRV_GPSB_MODE_OpMode(1)
+
+// GPSB PID Table Definition
+#define	DRV_GPSB_PID_MAX_NUM				32
+#define	DRV_GPSB_PID_VALUE_MASK				0x1FFF
+
+extern S32	DRV_GPSB(U32 Func, U32 ArgN, ...);
+#endif
+
+/*==============================================================================
+				2D DMA (TCC78x)
+   ==============================================================================*/
+#define	LCD_ROT0L		0
+#define	LCD_ROT90L		1
+#define	LCD_ROT180L		2
+#define	LCD_ROT270L		3
+#define	LCD_MIR_ROT0L	10
+#define	LCD_MIR_ROT90L	11
+#define	LCD_MIR_ROT180L	12
+#define	LCD_MIR_ROT270L	13
+
+
+#ifdef 	TCC79XX
+/*==============================================================================
+				NTSC/PAL Encoder
+  ==============================================================================*/
+
+#define	DRV_TVE_MAX_HANDLE		2
+
+// TVE Driver Function Definition
+enum
+{
+	DRV_TVE_FUNC_INIT,					// TVE Driver Initialization : Argument = None
+	DRV_TVE_FUNC_PROCESS_INTERRUPT,		// Process TVE Interrupt : Argument = None
+
+	DRV_TVE_FUNC_OPEN,					// Open Handle : Argument = (*sDRV_TVE)
+	DRV_TVE_FUNC_GETHwTVE,				// Get HwTVE Base Address : Argument = (Handle, *sHwTVE)
+	DRV_TVE_FUNC_SETCFG,				// Configurate TVE : Argument = (Handle, TVMode)
+
+	DRV_TVE_FUNC_START,					// Start Operation : Argument = (Handle)
+	DRV_TVE_FUNC_STOP,					// Stop Handle : Argument = (Handle)
+	DRV_TVE_FUNC_CLOSE,					// Close Handle : Argument = (Handle)
+
+	DRV_TVE_FUNC_ADJ, 						//Adjust Video : Argument = (Handle)
+
+	DRV_TVE_FUNC_MAX
+};
+
+// TVE Driver Status Definition
+enum
+{
+	DRV_TVE_STATUS_INVALID,		// Not Opened
+	DRV_TVE_STATUS_IDLE,		// Openad but Not Activated
+	DRV_TVE_STATUS_PAUSE,		// Opened & Activated & Pause
+	DRV_TVE_STATUS_ACTIVE,		// Opened & Activated
+	DRV_TVE_STATUS_MAX
+};
+
+// TVE Driver Data Structure
+typedef struct
+{
+	U8				TVMODE;			// Output Mode : NTSC or PAL
+	U8				CGMSCTRL;		// CGMS Control : ON or OFF
+	U32				CGMSDATA;		// CGMS Data : 20 bits
+	U8				CHSTS;			// Handle Status
+	sHwTVE			*pHwTVE;		// Base Address
+} sDRV_TVE;
+
+typedef	volatile struct {
+	unsigned VENCON;
+	unsigned VENCIF;
+} sHwTVECON;
+
+// TVE Mode Control Register Definition - ECMDA, ECMDB, ECMDC Register
+#define SET_TVE_MODE_PWDN_ENABLE			0x00000001
+#define SET_TVE_MODE_PWDN_DISABLE			0x00000002
+#define SET_TVE_MODE_FDRST_RELATIONSHIP		0x00000004
+#define SET_TVE_MODE_FDRST_FREERUNNING		0x00000008
+#define SET_TVE_MODE_FSCSEL_NTSC			0x00000010
+#define SET_TVE_MODE_FSCSEL_PALX			0x00000020
+#define SET_TVE_MODE_FSCSEL_PALM			0x00000040
+#define SET_TVE_MODE_FSCSEL_PALCN			0x00000080
+#define SET_TVE_MODE_PEDESTAL_ENABLE		0x00000100
+#define SET_TVE_MODE_PEDESTAL_DISABLE		0x00000200
+#define SET_TVE_MODE_PIXEL_601				0x00000400
+#define SET_TVE_MODE_PIXEL_SQUARE			0x00000800
+#define SET_TVE_MODE_OUTPUT_525LINES		0x00001000
+#define SET_TVE_MODE_OUTPUT_625LINES		0x00002000
+#define SET_TVE_MODE_PHALT_NTSC				0x00004000
+#define SET_TVE_MODE_PHALT_PAL				0x00008000
+
+#define SET_TVE_MODE_VBIBLANK_BLACK			0x00010000
+#define SET_TVE_MODE_VBIBLANK_BYPASS		0x00020000
+#define SET_TVE_MODE_CHROMABW_LOW			0x00040000
+#define SET_TVE_MODE_CHROMABW_MEDIUM		0x00080000
+#define SET_TVE_MODE_CHROMABW_HIGH			0x00100000
+#define SET_TVE_MODE_LUMABW_LOW				0x00200000
+#define SET_TVE_MODE_LUMABW_MEDIUM			0x00400000
+#define SET_TVE_MODE_LUMABW_HIGH			0x00800000
+
+#define SET_TVE_MODE_CSYNC_ENABLE			0x01000000
+#define SET_TVE_MODE_CSYNC_DISABLE			0x02000000
+#define SET_TVE_MODE_CSOUTPUT_CSYNC			0x04000000
+#define SET_TVE_MODE_CSOUTPUT_KEYCLAMP		0x08000000
+#define SET_TVE_MODE_CSOUTPUT_KEYPULSE		0x10000000
+#define SET_TVE_MODE_RGBSYNC_NOSYNC			0x20000000
+#define SET_TVE_MODE_RGBSYNC_RGB			0x40000000
+#define SET_TVE_MODE_RGBSYNC_G				0x80000000
+
+// TVE Clock Generator Register Definition - GLK Register
+#define SET_TVE_GLK_CRYSTAL_27MHZ			0x00000001
+#define SET_TVE_GLK_CRYSTAL_24MHZ			0x00000002
+#define SET_TVE_GLK_RESET_ENABLE			0x00000004
+#define SET_TVE_GLK_RESET_DISABLE			0x00000008
+#define SET_TVE_GLK_SOURCE_INT				0x00000010
+#define SET_TVE_GLK_SOURCE_RTCO				0x00000020
+#define SET_TVE_GLK_SOURCE_CLKI				0x00000040
+#define SET_TVE_GLK_PL_ACTIVELOW			0x00000080
+#define SET_TVE_GLK_PL_ACTIVEHIGH			0x00000100
+
+// TVE DAC Control Register Definition - DACSEL, DACPD Register
+#define SET_TVE_DAC_OUTPUT_CODE0			0x00000001
+#define SET_TVE_DAC_OUTPUT_CVBS				0x00000002
+#define SET_TVE_DAC_PWDN_ENABLE				0x00000004
+#define SET_TVE_DAC_PWDN_DISABLE			0x00000008
+
+// TVE SYNC Control Register Definition - ICNTL Register
+#define SET_TVE_SYNC_ODD_ACTIVELOW			0x00000001
+#define SET_TVE_SYNC_ODD_ACTIVEHIGH			0x00000002
+#define SET_TVE_SYNC_VSYNC_ACTIVELOW		0x00000004
+#define SET_TVE_SYNC_VSYNC_ACTIVEHIGH		0x00000008
+#define SET_TVE_SYNC_HSYNC_ACTIVELOW		0x00000010
+#define SET_TVE_SYNC_HSYNC_ACTIVEHIGH		0x00000020
+#define SET_TVE_SYNC_LATCH_VSFALLING		0x00000040
+#define SET_TVE_SYNC_LATCH_VSRISING			0x00000080
+#define SET_TVE_SYNC_VSOUTOUT_MID			0x00000100
+#define SET_TVE_SYNC_VSOUTOUT_START			0x00000200
+#define SET_TVE_SYNC_ISYNC_FSI				0x00000400
+#define SET_TVE_SYNC_ISYNC_HVFSI			0x00000800
+#define SET_TVE_SYNC_ISYNC_HVSI				0x00001000
+#define SET_TVE_SYNC_ISYNC_VFSI				0x00002000
+#define SET_TVE_SYNC_ISYNC_VSI				0x00004000
+#define SET_TVE_SYNC_ISYNC_ESAV_L			0x00008000
+#define SET_TVE_SYNC_ISYNC_ESAV_FI			0x00010000
+#define SET_TVE_SYNC_ISYNC_FREE				0x00020000
+
+// TVE VBI Control Register Definition -  VCTRL Register
+#define SET_TVE_VCTRL_VBICTL_NONE			0x00000001
+#define SET_TVE_VCTRL_VBICTL_10LINE			0x00000002
+#define SET_TVE_VCTRL_VBICTL_1LINE			0x00000004
+#define SET_TVE_VCTRL_VBICTL_2LINE			0x00000008
+#define SET_TVE_VCTRL_CAP_ODD_ENABLE		0x00000010
+#define SET_TVE_VCTRL_CAP_ODD_DISABLE		0x00000020
+#define SET_TVE_VCTRL_CAP_EVEN_ENABLE		0x00000040
+#define SET_TVE_VCTRL_CAP_EVEN_DISABLE		0x00000080
+#define SET_TVE_VCTRL_CGMS_ODD_ENABLE		0x00000100
+#define SET_TVE_VCTRL_CGMS_ODD_DISABLE		0x00000200
+#define SET_TVE_VCTRL_CGMS_EVEN_ENABLE		0x00000400
+#define SET_TVE_VCTRL_CGMS_EVEN_DISABLE		0x00000800
+#define SET_TVE_VCTRL_WSCREEN_ENABLE		0x00001000
+#define SET_TVE_VCTRL_WSCREEN_DISABLE		0x00002000
+
+// TVE Connection and I/F Control Definition - VENCON, VENCIF Register
+#define SET_TVE_CONIF_CON_ENABLE			0x00000001
+#define SET_TVE_CONIF_CON_DISABLE			0x00000002
+#define SET_TVE_CONIF_FMT_CINLSB			0x00000004
+#define SET_TVE_CONIF_FMT_CINMSB			0x00000008
+
+// TVE Setting Value Definition
+enum
+{
+	DRV_TVE_SET_SCH = 0,			
+	DRV_TVE_SET_HUE,		
+	DRV_TVE_SET_SAT,		
+	DRV_TVE_SET_CONT,		
+	DRV_TVE_SET_BRIGHT,		
+	DRV_TVE_SET_FSC,
+	DRV_TVE_SET_INPUT,
+	DRV_TVE_SET_HOFFSET,
+	DRV_TVE_SET_VOFFSET,
+	DRV_TVE_SET_HSOE,
+	DRV_TVE_SET_HSOB,
+	DRV_TVE_SET_VSOB,
+	DRV_TVE_SET_VSOE,
+	DRV_TVE_SET_VSOST,
+	DRV_TVE_SET_NOVRST
+};
+
+// TVE Input Format Definition
+enum
+{
+	DRV_TVE_INPUT_BW16_27MHZ = 0,			
+	DRV_TVE_INPUT_BW16_13P5MHZ,		
+	DRV_TVE_INPUT_BW8_13P5MHZ
+};
+
+// TVE Ouput Mode Definition
+enum
+{
+	DRV_TVE_OUTPUT_NTSC = 0,			
+	DRV_TVE_OUTPUT_PAL,			
+	DRV_TVE_OUTPUT_MAX			
+};
+
+// TVE Ouput Mode Definition
+enum
+{
+	DRV_TVE_CGMS_OFF = 0,			
+	DRV_TVE_CGMS_ON,			
+	DRV_TVE_CGMS_MAX			
+};
+
+// TVE Driver Return Value Definition
+#define	DRV_TVE_ERROR_YES		1
+#define	DRV_TVE_ERROR_NO		0
+#define	DRV_TVE_ERROR_OK		0
+enum
+{
+	// Error for Driver State
+	DRV_TVE_ERROR_NOTINIT	= (int)0xF9000000,	// Non-init Function come before init function
+	DRV_TVE_ERROR_DUPINIT,						// Init function called more than twice
+
+	// Error for Input Parameter
+	DRV_TVE_ERROR_INVALID_FUNC,					// Function Code is out of range
+	DRV_TVE_ERROR_INVALID_ARGUMENT,				// Number of Argument is out of range
+	DRV_TVE_ERROR_INVALID_HANDLE,				// Handle value is out of range
+	DRV_TVE_ERROR_INVALID_RESPONSE,				// No Response
+
+	// Error for Resource Availability
+	DRV_TVE_ERROR_NOTAVAILABLE_HANDLE,			// No available handle
+
+	// Error for Illegal State
+	DRV_TVE_ERROR_INTERNAL,						// Internal Bug
+
+	DRV_TVE_ERROR_MAX
+};
+
+extern S32	DRV_TVE(U32 Func, U32 ArgN, ...);
+
+/*==============================================================================
+				AUDIO
+   ==============================================================================*/
+/*---------------------------------------------------------------------
+	DDI_AUD_Set_EQ_FreqVal
+	
+Description	
+	Fix input equation value to global variable
+Parameters	
+	uiFreqValue : input value
+Returns 
+	None
+ -----------------------------------------------------------------------*/
+void DDI_AUD_Set_EQ_FreqVal(unsigned int uiFreqValue );
+
+/*---------------------------------------------------------------------
+	DDI_AUD_Get_EQ_FreqVal
+	
+Description	
+	Get input equation value to global variable
+Parameters	
+	None
+Returns 
+	uiFreqValue
+ -----------------------------------------------------------------------*/
+unsigned int DDI_AUD_Get_EQ_FreqVal(void);
+
+/*---------------------------------------------------------------------
+	UI_DRV_Get_EQ_FreqVal
+	
+Description	
+	Get input equation value to global variable
+Parameters	
+	None
+Returns 
+	uiFreqValue
+ -----------------------------------------------------------------------*/
+unsigned int DDI_AUD_Get_EQBandInst(void);
+
+/**********************************************************
+*
+*	Function of	
+*
+*	DDI_AUD_CopyMono
+*
+*	Input	: pSrc  = pointer of mono PCM data
+			  size  = size of PCM data
+			  
+*	Output	: 
+			  pLeft = pointer of left output
+			  pRight = pointer of right output
+			  
+*	Return	: none
+*
+*	Description	: 
+**********************************************************/
+void DDI_AUD_CopyMono( short *pSrc, short *pLeft, short *pRight, unsigned int size );
+
+/**********************************************************
+*
+*	Function of	
+*
+*	DDI_AUD_CopyStereo
+*
+*	Input	: pSrc  = pointer of stero PCM data
+			  size  = size of PCM data
+			  
+*	Output	: 
+			  pLeft = pointer of left output
+			  pRight = pointer of right output
+			  
+*	Return	: none
+*
+*	Description	: 
+**********************************************************/
+void DDI_AUD_CopyStereo( short *pSrc, short *pLeft, short *pRight, unsigned int size );
+
+/**********************************************************
+*
+*	Function of	
+*
+*	DDI_AUD_Terminate
+*
+*	Input	:
+*	Output	: 
+*	Return	: none
+*
+*	Description	: 
+**********************************************************/
+void DDI_AUD_Terminate(void);
+
+/**********************************************************
+*
+*	Function of	
+*
+*	DDI_AUD_Initialize
+*
+*	Input	: iSampleFreq = Sampling frequency
+			  iChannel = number of audio channel 
+*	Output	: 
+*	Return	: none
+*
+*	Description	: 
+**********************************************************/
+void DDI_AUD_Initialize( int iSampleFreq, int iChannel );
+
+/**********************************************************
+*
+*	Function of	
+*
+*	DDI_AUD_Output
+*
+*	Input	: pSrc  = pointer of PCM data
+			  iSize  = size of PCM data
+			  iChannel = number of audio channel 
+			  
+*	Output	: 
+*	Return	: none
+*
+*	Description	: 
+**********************************************************/
+void DDI_AUD_Output( short *pSrc, int iSize, int iChannel );
+
+/**********************************************************
+*
+*	Function of	
+*
+*	DDI_AUD_MuteOn
+*
+*	Input	: none
+*	Output	: none
+*	Return	: none
+*
+*	Description	: 
+**********************************************************/
+void DDI_AUD_MuteOn(void);
+
+/**********************************************************
+*
+*	Function of	
+*
+*	DDI_AUD_MuteOff
+*
+*	Input	: none
+*	Output	: none
+*	Return	: none
+*
+*	Description	: 
+**********************************************************/
+void DDI_AUD_MuteOff(void);
+
+/**********************************************************
+*
+*	Function of	
+*
+*	DDI_AUD_SetVolume
+*
+*	Input	: cVol = value of volume level
+*	Output	: none
+*	Return	: none
+*
+*	Description	: 
+**********************************************************/
+void DDI_AUD_SetVolume(	unsigned char cVol );
+
+/**********************************************************
+*
+*	Function of	
+*
+*	DDI_AUD_DisableEffect
+*
+*	Input	: none
+*	Output	: none
+*	Return	: none
+*
+*	Description	: 
+**********************************************************/
+void DDI_AUD_DisableEffect(void);
+
+/**********************************************************
+*
+*	Function of	
+*
+*	DDI_AUD_SetEffectEQ
+*
+*	Input	: iSampleFreq
+			  pEqValue = pointer of effect value 
+*	Output	: none
+*	Return	: none
+*
+*	Description	: 
+**********************************************************/
+void DDI_AUD_SetEffectEQ(unsigned int iSampleFreq );
+
+/*---------------------------------------------------------------------
+	DDI_AUD_ApplyEqualizerMode
+	
+Description	
+	Set the EQ mode
+Parameters	
+	ucEQMode : selected mode by user
+Returns
+	None
+ -----------------------------------------------------------------------*/
+void DDI_AUD_ApplyEqualizerMode(U8	ucEQMode);
+
+/**********************************************************
+*
+*	Function of	
+*
+*	DDI_AUD_SetSrsWow
+*
+*	Input	: iSampleFreq
+			  iSrs = value of SRS effect
+			  iWow = value of WOW effect
+*	Output	: none
+*	Return	: none
+*
+*	Description	: 
+**********************************************************/
+void DDI_AUD_SetSrsWow( int iSampleFreq, int iSrs, int iWow);
+
+
+/*==============================================================================
+				SMARTCARD
+   ==============================================================================*/
+
+/**********************************************************
+*	int	DDI_SC_Initialize(void);
+*
+*	Input		: 
+*	Output		:
+*	Return		: 0 = initialize successful
+*				  negative = initialize failed.
+*
+*	Description	: Initialize SC library & Create SEMA.
+**********************************************************/
+int	DDI_SC_Initialize(void);
+
+/**********************************************************
+*	int	DDI_SC_Open(void);
+*
+*	Input		: 
+*	Output		:
+*	Return		: 0 = Open successful, -1 = Open failed.
+*
+*	Description	: Establish New SC connection.
+**********************************************************/
+int	DDI_SC_Open(void);
+
+/**********************************************************
+*	int	DDI_SC_Close(void);
+*
+*	Input		: 
+*	Output		:
+*	Return		: 0 = Close successful
+*
+*	Description	: Close SC connection.
+**********************************************************/
+int	DDI_SC_Close(void);
+
+/**********************************************************
+*	int	DDI_SC_Reset(void *pATR, unsigned *pATRLength);
+*
+*	Input		: pATR = pointer for storing ATR string
+*				  pATRLength = pointer for storing ATR string length
+*	Output		:
+*	Return		: 0 = Reset successful
+*
+*	Description	: Reset SmartCard & Get ATR string.
+**********************************************************/
+int	DDI_SC_Reset(void *pATR, unsigned *pATRLength);
+
+/**********************************************************
+*	int	DDI_SC_SendRcv(void *pSend, unsigned uSendLength, void *pRcv, unsigned uRcvLength);
+*
+*	Input		: pSend = pointer of command string
+*				  uSendLength = length of command string
+*				  pRcv = pointer for storing response string
+*				  uRcvLength = length of response string.
+*	Output		:
+*	Return		: 0 = Send & Receiving is successful.
+*				  -1 = Response string is not good.
+*
+*	Description	: Send command string to SmartCard & Receive response string from SmartCard.
+**********************************************************/
+int	DDI_SC_SendRcv(void *pSend, unsigned uSendLength, void *pRcv, unsigned uRcvLength);
+
+#endif
+
+#endif
+
+/* end of file */
+
diff --git a/drivers/block/tcc/inc/tnftl/Typedefine.h b/drivers/block/tcc/inc/tnftl/Typedefine.h
new file mode 100644
index 0000000..1c50cc9
--- /dev/null
+++ b/drivers/block/tcc/inc/tnftl/Typedefine.h
@@ -0,0 +1,52 @@
+/****************************************************************************
+ *   FileName    :  Typedefine.h
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+
+typedef unsigned long           UNSIGNED;
+typedef long                    SIGNED;
+typedef unsigned char           DATA_ELEMENT;
+typedef DATA_ELEMENT            OPTION;
+typedef DATA_ELEMENT            BOOLEAN;
+typedef int                     STATUS;
+typedef unsigned char           UNSIGNED_CHAR;
+#ifndef _CHAR_
+#define _CHAR_
+typedef char                    CHAR;
+#endif
+typedef unsigned int            UNSIGNED_INT;
+typedef int                     INT;
+typedef unsigned long *         UNSIGNED_PTR;
+typedef unsigned char *         BYTE_PTR;
+#define VOID void
+
+#ifndef _INT8_
+#define _INT8_
+typedef char           INT8;
+#endif
+#ifndef _UINT8_
+#define _UINT8_
+typedef unsigned char  UINT8;
+#endif
+#ifndef _INT16_
+#define _INT16_
+typedef signed short   INT16;
+#endif
+#ifndef _UINT16_
+#define _UINT16_
+typedef unsigned short UINT16;
+#endif
+#ifndef _INT32_
+#define _INT32_
+typedef signed long    INT32;
+#endif
+#ifndef _UINT32_
+#define _UINT32_
+typedef unsigned long  UINT32;
+#endif
diff --git a/drivers/block/tcc/inc/tnftl/nand_drv.h b/drivers/block/tcc/inc/tnftl/nand_drv.h
new file mode 100644
index 0000000..ccf57f2
--- /dev/null
+++ b/drivers/block/tcc/inc/tnftl/nand_drv.h
@@ -0,0 +1,283 @@
+/****************************************************************************
+ *   FileName    : nand_drv.h
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ * 
+ ****************************************************************************/
+#ifndef __NAND_H
+#define __NAND_H
+
+//#include "main.h"
+
+//**********************************************************************
+//*		Define NAND Driver version for ChipSet
+//**********************************************************************
+#if defined(NAND_BOOT_REV)
+#define TNFTL_V7_INCLUDE
+#else	// K-FILESYSTEM
+#define TNFTL_V6_INCLUDE
+#endif
+
+//**********************************************************************
+//*		Include Header
+//**********************************************************************
+#if defined(_LINUX_) || defined(_WINCE_)
+#if defined(TNFTL_V7_INCLUDE)
+#include "tnftl_v7.h"
+#include "fwupgrade_NAND_v6.h"
+#elif defined(TNFTL_V6_INCLUDE)
+#include "tnftl_v6.h"
+#include "fwupgrade_NAND_v6.h"
+#endif
+#endif
+
+#if defined(USB_INCLUDE) && defined(FWDN_INCLUDE)
+#ifdef TNFTL_V5_INCLUDE
+#include "MASS_SCSI.h"
+#include "VTC.h"
+#include "Fwdn_protocol_v2.h"
+#define	TNFTL_DEBUG_INCLUDE
+#else
+#include "fwdn_protocol.h"
+#endif
+#endif
+
+//*****************************************************************************
+//*
+//*
+//*                       [ General DEFINE & TYPEDEF ]
+//*
+//*
+//*****************************************************************************
+#ifndef DISABLE
+#define DISABLE					0
+#endif
+#ifndef ENABLE
+#define	ENABLE					1
+#endif
+#ifndef FALSE
+#define FALSE           		0
+#endif
+#ifndef TRUE
+#define TRUE            		1
+#endif
+
+#ifndef _U8_
+#define _U8_
+typedef unsigned char			U8;
+#endif
+#ifndef _U16_
+#define _U16_
+typedef unsigned short int		U16;
+#endif
+#ifndef _U32_
+#define _U32_
+typedef unsigned int			U32;
+#endif
+#ifndef _BOOL_
+#define _BOOL_
+typedef unsigned int			BOOL;
+#endif
+
+#ifndef NOT_SUPPORT_NAND
+#define NOT_SUPPORT_NAND		0xFFFF
+#endif
+
+//*****************************************************************************
+//*
+//*
+//*                         [ ERROR CODE ENUMERATION ]
+//*
+//*
+//*****************************************************************************
+#ifndef SUCCESS
+#define SUCCESS		0
+#endif
+
+typedef enum
+{
+	ERR_NAND_FAILED_GET_DEVICE_INFO = 0xA300000,
+	ERR_NAND_INIT_FAILED
+} NAND_ERROR;
+ 
+//*****************************************************************************
+//*
+//*
+//*                          [ INTERNAL DEFINATION ]
+//*
+//*
+//*****************************************************************************
+#define MAX_NAND_DRIVE								1
+#define NAND_DRV_0									0
+
+#if defined( TNFTL_V7_INCLUDE )
+	#define TNFTL_ZONE_NUM_FOR_PRIMARY_PARTITION		32
+	#if defined(_LINUX_) || defined(_WINCE_)
+	#define TNFTL_ZONE_NUM_FOR_EXTENDED_PARTITION		32
+	#else
+	#define TNFTL_ZONE_NUM_FOR_EXTENDED_PARTITION		1
+	#endif
+	
+	#define TNFTL_WCACHE_NUM_For_PRIMARY_PARTITION		12
+	#define TNFTL_WCACHE_NUM_For_EXTENDED_PARTITION		2
+	
+	#define TNFTL_LPT_BLK_NUM_For_PRIMARY_PARTITION		TNFTL_ZONE_NUM_FOR_PRIMARY_PARTITION
+	#define TNFTL_LPT_BLK_NUM_For_EXTENDED_PARTITION	TNFTL_ZONE_NUM_FOR_EXTENDED_PARTITION
+	
+	#if defined(_LINUX_) || defined(_WINCE_)
+	#define TNFTL_EXTENDED_PARTITION_MAX_NUM			4
+	#define TNFTL_EXTENDED_PARTITION_NUM				1
+	#define TNFTL_EXTENDED_PARTITION_SIZE_MB			1
+	#else
+	#ifdef INTERNAL_HIDDEN_STORAGE_INCLUDE
+	#define TNFTL_EXTENDED_PARTITION_MAX_NUM			1
+	#define TNFTL_EXTENDED_PARTITION_NUM				1
+	#else
+	#define TNFTL_EXTENDED_PARTITION_MAX_NUM			1
+	#define TNFTL_EXTENDED_PARTITION_NUM				0
+	#endif
+	#endif
+#else 
+	#define TNFTL_ZONE_NUM_FOR_DATA_AREA				32
+	#if defined(_LINUX_) || defined(_WINCE_)
+	#define TNFTL_ZONE_NUM_FOR_HIDDEN_AREA				32
+	#else
+	#define TNFTL_ZONE_NUM_FOR_HIDDEN_AREA				1
+	#endif
+	
+	#if defined( TNFTL_V5_INCLUDE ) || defined(TNFTL_V6_INCLUDE)
+	#define TNFTL_WCACHE_NUM_For_DATA_AREA				12
+	#else
+	#define TNFTL_WCACHE_NUM_For_DATA_AREA				8
+	#endif
+	#define TNFTL_WCACHE_NUM_For_HIDDEN_AREA			2
+	
+	#define TNFTL_LPT_BLK_NUM_For_DATA_AREA				TNFTL_ZONE_NUM_FOR_DATA_AREA
+	#define TNFTL_LPT_BLK_NUM_For_HIDDEN_AREA			TNFTL_ZONE_NUM_FOR_HIDDEN_AREA
+	
+	#if defined(_LINUX_) || defined(_WINCE_)
+	#define TNFTL_MULTI_HIDDEN_AREA_MAX_NUM				3
+	#define TNFTL_MULTI_HIDDEN_AREA_NUM					3
+	#define INTERNAL_HIDDEN_STORAGE_SIZE_MB				1
+	#else
+	#ifdef INTERNAL_HIDDEN_STORAGE_INCLUDE
+	#define TNFTL_MULTI_HIDDEN_AREA_MAX_NUM				1
+	#define TNFTL_MULTI_HIDDEN_AREA_NUM					1
+	#else
+	#define TNFTL_MULTI_HIDDEN_AREA_MAX_NUM				1
+	#define TNFTL_MULTI_HIDDEN_AREA_NUM					0
+	#endif
+	#endif
+#endif
+
+//===========================================================
+//
+//	Common
+//
+//===========================================================
+#define NAND_TYPE_PURE_NAND							0
+#define NAND_TYPE_LBA_NAND							1
+
+#define TNFTL_MAX_SUPPORT_RCACHE_MEMORY_SIZE		16384
+#define TNFTL_MAX_SUPPORT_ALIGNCACHE_MEMORY_SIZE	16384					
+
+#define	MAX_ROMSIZE_NAND							0x200000
+
+#define NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE			4096
+#define NAND_HIDDEN_DRIVE_DEFAULT_TOTAL_SECTOR_SIZE	((2*1024*1024UL)/512UL)
+
+#define	MAX_ROMSIZE_NAND							0x200000
+					
+//*****************************************************************************
+//*
+//*
+//*                       [ INTERNAL STRUCT DEFINE ]
+//*
+//*
+//*****************************************************************************
+typedef struct __tag_NAND_DrvInfo
+{
+	unsigned short int			DrvStatus;			// Status of Drive
+	
+	unsigned long int			TotalDiskSector;	// Total Disk Sector
+	unsigned short int			Cylinder;
+	unsigned short int			Head;
+	unsigned char				Sector;
+
+	TNFTL_DRVINFO				*NFTLDrvInfo;		// NFTL Driver
+} NAND_DRVINFO;
+
+#if defined( TNFTL_V7_INCLUDE )
+typedef	struct	__tag_TNFTL_ExtPartitionSizeInfo
+{
+	unsigned int				ExtendedPartitionNum;
+	unsigned int				ExtPartitionSize[12];
+	unsigned int				ROAreaSize;						
+} TNFTL_EXT_PART_INFO;
+#else
+typedef	struct	__tag_TNFTL_HiddenSizeInfo
+{
+	unsigned int				HiddenPageSize;	// Default Hidden Area Pages
+	unsigned int				MultiHiddenAreaNum;		// Multi Hidden Num	
+	unsigned int 				MultiHiddenSize[8];	// Multi Hidden Configuration
+	unsigned int				ROAreaSize;
+} TNFTL_HIDDEN_INFO;
+#endif					
+
+#if defined( TNFTL_V7_INCLUDE )
+//*****************************************************************************
+//*
+//*
+//*                       [ EXTERNAL VARIABLE DEFINE ]
+//*
+//*
+//*****************************************************************************
+extern NAND_DRVINFO				gNAND_DrvInfo[MAX_NAND_DRIVE];
+extern TNFTL_EXT_PART_INFO		gTNFTL_ExtPartitionInfo[MAX_NAND_DRIVE];
+extern NAND_IO_DEVINFO			*gLBA_DevInfo;
+#else
+extern NAND_DRVINFO				gNAND_DrvInfo[MAX_NAND_DRIVE];
+extern TNFTL_HIDDEN_INFO		gTNFTL_HiddenInfo[MAX_NAND_DRIVE];
+extern NAND_IO_DEVINFO			*gLBA_DevInfo;
+#endif
+
+//*****************************************************************************
+//*
+//*
+//*                       [ EXTERNAL FUCTIONS DEFINE ]
+//*
+//*
+//*****************************************************************************
+extern void			NAND_Init( void );
+extern void 		NAND_InitHiddenInfo( void );
+extern void 		NAND_SetFlagOfChangeAreaSize( unsigned char On_Off );
+
+extern NAND_ERROR	NAND_InitDrive( int nDrvNo );
+
+extern int			NAND_ReadSector( int nDrvNo, U32 LBA, U32 nSecSize, void* nReadBuffer );
+extern int			NAND_WriteSector( int nDrvNo, U32 LBA, U32 nSecSize, void* nWriteBuffer );
+extern int			NAND_HDReadPage( U32 nHDPageAddr, U32 nPageSize, void* nReadBuffer );
+extern int			NAND_HDWritePage( U32 nHDPageAddr, U32 nPageSize, void* nWriteBuffer );
+extern int 			NAND_PhyReadPage( U32 nBlkAddr, U16 nPageAddr, U16 nCSorder, void* nReadBuffer );
+extern int			NAND_Ioctl( int function, void *param );
+
+extern int			NAND_ReadMultiSectorStart( U32 LBA, U32 nSecSize );
+extern int			NAND_ReadMultiSectorStop( void );
+extern int			NAND_WriteMultiSectorStart( U32 LBA, U32 nSecSize );
+extern int			NAND_WriteMultiSectorStop( void );
+extern int			NAND_HDClearPages( U32 nHDStPageAddr, U32 nHDEdPageAddr );
+
+extern int			NAND_HDReadSector( int nDrvNo, U32 LBA, U32 nSecSize, void* nReadBuffer );
+extern int			NAND_HDWriteSector( int nDrvNo, U32 LBA, U32 nSecSize, void* nWriteBuffer );
+extern int			NAND_HDIoctl( int function, void *param );
+
+extern U16			NAND_GetSerialNumber( U8* rSerialNumber, U16 nSize );
+extern U16			NAND_GetUniqueID( U8* rSerialNumber, U16 nSize );
+extern TNFTL_ERROR	NAND_SetUartDebug( unsigned int on_off );
+
+#endif
+
diff --git a/drivers/block/tcc/inc/tnftl/nand_io_v6.h b/drivers/block/tcc/inc/tnftl/nand_io_v6.h
new file mode 100644
index 0000000..aab4abf
--- /dev/null
+++ b/drivers/block/tcc/inc/tnftl/nand_io_v6.h
@@ -0,0 +1,828 @@
+/**************************************************************************************
+ *
+ * TELECHIPS Co.
+ * 
+ * 6th floor Corad Bldg 1000-12 Daechi-dong, KangNam-ku, Seoul, Korea
+ * ====================================================================================
+ *
+ * Name:        Hyun-Chul Hong
+ * Phone:       82-2-3443-6792
+ * E-mail:      hchong@telechips.com
+ *
+ * FILE NAME:   NAND_IO.H
+ *
+ * DESCRIPTION:
+ *       This is a Header File for NANDFLASH IO Interface 
+ *
+ *
+ * FILE HISTORY:
+ * 	Date: 2005.04.19	Start source coding		By Hyunchul Hong
+ *
+ **************************************************************************************/
+#ifndef __NAND_IO_H
+#define __NAND_IO_H
+
+//*****************************************************************************
+//*
+//*
+//*                       [ Specific DEFINE ]
+//*
+//*
+//*****************************************************************************
+#if defined(TCC83XX) && defined(_WINCE_)
+// In the case of LINUX, it is defined config.h
+#define NAND_2CS_ONLY
+#define NAND_8BIT_ONLY
+#else
+//#define NAND_2CS_ONLY
+//#define NAND_8BIT_ONLY
+#endif
+
+//**********************************************************************
+//*		Define Dev Board
+//**********************************************************************
+//#define TCC9200S_BOARD			// TCC9200S ND_RDY: GPIO_B31
+#define TCC89_92_BOARD			// TCC89/91/9200 ND_RDY: GPIO_B28 - EDI - NFC_CTRL
+
+//**********************************************************************
+//*		Define ECC Algorithm for ChipSet
+//**********************************************************************
+#if defined(TCC77X) || defined(TCC87XX) || defined(TCC82XX) || defined(TCC78X) || defined(TCC83XX) || defined(TCC79XX)
+#define ECC_TYPE_RS
+#elif defined(TCC81XX) || defined(TCC80XX) || defined(TCC92XX) || defined(TCC89XX)
+#define ECC_TYPE_BCH
+#endif
+
+#if defined(USE_V_ADDRESS)
+	#if defined(_LINUX_)
+	#define  ND_TRACE	printk
+	#elif defined(_WINCE_)
+	//#define  ND_TRACE(a)		RETAILMSG(1, a)
+	//#define  ND_TRACE2(a)		NKDbgPrintfW(a)
+	#endif
+#else
+	#if defined(_LINUX_)
+		#define  ND_TRACE	printf
+	#elif defined(_WINCE_)
+		#define  ND_TRACE	B_RETAILMSG
+	#endif
+#endif
+
+//*****************************************************************************
+//*
+//*
+//*                       [ General DEFINE & TYPEDEF ]
+//*
+//*
+//*****************************************************************************
+//===================================================================
+//
+//		DRIVER SIGNATURE
+//
+//===================================================================
+#define SIGBYAHONG				'S','I','G','B','Y','A','H','O','N','G','_'
+
+#define NAND_IO_SIGNATURE		'N','A','N','D','_','I','O','_'
+#define TNFTL_SIGNATURE			'T','N','F','T','L','_'
+
+#if defined(_WINCE_)
+#define SIGN_OS					'W','I','N','C','E','_'
+#elif defined(_LINUX_)
+#define SIGN_OS					'L','I','N','U','X','_'
+#else
+#define SIGN_OS					'N','U','_'
+#endif
+
+#if defined(TCC77X)
+#define SIGN_CHIPSET			'T','C','C','7','7','X','X','_'
+#elif defined(TCC78X)
+#define SIGN_CHIPSET			'T','C','C','7','8','X','X','_'
+#elif defined(TCC79X)
+#define SIGN_CHIPSET			'T','C','C','7','9','X','X','_'
+#elif defined(TCC81XX)
+#define SIGN_CHIPSET			'T','C','C','8','1','X','X','_'
+#elif defined(TCC82XX)
+#define SIGN_CHIPSET			'T','C','C','8','2','X','X','_'
+#elif defined(TCC83XX)
+#define SIGN_CHIPSET			'T','C','C','8','3','X','X','_'
+#elif defined(TCC87XX)
+#define SIGN_CHIPSET			'T','C','C','8','7','X','X','_'
+#elif defined(TCC89XX)
+#define SIGN_CHIPSET			'T','C','C','8','9','X','X','_'
+#elif defined(TCC91XX)
+#define SIGN_CHIPSET			'T','C','C','9','1','X','X','_'
+#elif defined(TCC92XX)
+#define SIGN_CHIPSET			'T','C','C','9','2','X','X','_'
+#else
+#error
+#endif
+
+#ifndef DISABLE
+#define DISABLE					0
+#endif
+#ifndef ENABLE
+#define	ENABLE					1
+#endif
+#ifndef FALSE
+#define FALSE           		0
+#endif
+#ifndef TRUE
+#define TRUE            		1
+#endif
+#ifndef NULL
+#define NULL            		0
+#endif
+
+#if defined(_LINUX_)
+#ifndef _U8_
+#define _U8_
+typedef unsigned char			U8;
+#endif
+#ifndef _U16_
+#define _U16_
+typedef unsigned short int		U16;
+#endif
+#ifndef _U32_
+#define _U32_
+typedef unsigned int			U32;
+#endif
+#ifndef _BOOL_
+#define _BOOL_
+typedef unsigned int			BOOL;
+#endif
+#else
+#ifndef U8
+typedef unsigned char			U8;
+#endif
+#ifndef U16
+typedef unsigned short int		U16;
+#endif
+#ifndef U32
+typedef unsigned int			U32;
+#endif
+#ifndef _BOOL_
+typedef unsigned int			BOOL;
+#endif
+#endif
+
+#ifndef DWORD_BYTE
+typedef	union {
+	unsigned long		DWORD;
+	unsigned short int	WORD[2];
+	unsigned char		BYTE[4];
+} DWORD_BYTE;
+#endif
+
+#ifndef BITSET
+#define	BITSET(X, MASK)				( (X) |= (U32)(MASK) )
+#endif
+#ifndef BITSCLR
+#define	BITSCLR(X, SMASK, CMASK)	( (X) = ((((U32)(X)) | ((U32)(SMASK))) & ~((U32)(CMASK))) )
+#endif
+#ifndef BITCSET
+#define	BITCSET(X, CMASK, SMASK)	( (X) = ((((U32)(X)) & ~((U32)(CMASK))) | ((U32)(SMASK))) )
+#endif
+#ifndef BITCLR
+#define	BITCLR(X, MASK)				( (X) &= ~((U32)(MASK)) )
+#endif
+#ifndef BITXOR
+#define	BITXOR(X, MASK)				( (X) ^= (U32)(MASK) )
+#endif
+#ifndef ISZERO
+#define	ISZERO(X, MASK)				(  ! (((U32)(X)) & ((U32)(MASK))) )
+#endif
+#ifndef BYTE_OF
+#define	BYTE_OF(X)					( *(volatile unsigned char *)(&(X)) )
+#endif
+#ifndef HWORD_OF
+#define	HWORD_OF(X)					( *(volatile unsigned short *)(&(X)) )
+#endif
+#ifndef WORD_OF
+#define	WORD_OF(X)					( *(volatile unsigned int *)(&(X)) )
+#endif
+
+//*****************************************************************************
+//*
+//*
+//*                         [ ERROR CODE ENUMERATION ]
+//*
+//*
+//*****************************************************************************
+#ifndef SUCCESS
+#define SUCCESS		0
+#endif
+
+typedef enum
+{
+	ERR_NAND_IO_FAILED_GET_DEVICE_INFO = 0xA100000,
+	ERR_NAND_IO_FAILED_CORRECTION_SLC_ECC,
+	ERR_NAND_IO_FAILED_CORRECTION_MLC_ECC,
+	ERR_NAND_IO_FAILED_GET_SHIFT_FACTOR_FOR_MULTIPLY,
+	ERR_NAND_IO_FAILED_GET_FACTORY_BAD_MARK_OF_PBLOCK,
+	ERR_NAND_IO_READ_STATUS_GENERAL_FAIL,
+	ERR_NAND_IO_TIME_OUT_READ_STATUS,
+	ERR_NAND_IO_WRONG_PARAMETER,
+	ERR_NAND_IO_WRONG_PARAMETER_ROW_COL_ADDRESS,
+	ERR_NAND_IO_NOT_READY_DEVICE_IO,
+	ERR_NAND_IO_FAILED_WRITE,
+	ERR_NAND_IO_NOT_EXIST_LBA_HEADBLOCK,
+	ERR_NAND_IO_FAILED_LBA_PARTITION_CHANGE
+} NAND_IO_ERROR;
+ 
+//*****************************************************************************
+//*
+//*
+//*                          [ INTERNAL DEFINATION ]
+//*
+//*
+//*****************************************************************************
+
+/* Maker Information of supported NANDFLASH */
+enum SUPPORT_MAKER_NAND
+{
+	SAMSUNG = 0,
+	TOSHIBA,
+	HYNIX,
+	ST,
+	MICRON,
+	MAX_SUPPORT_MAKER_NAND
+};
+
+enum SUPPORT_MAKER_LBA_NAND
+{
+	TOSHIBA_LBA = 0,
+	MAX_SUPPORT_MAKER_LBA_NAND
+};
+
+enum LBA_NAND_HIDDEN_INFO
+{
+		//==============================================		
+		// VFP Size			[  4Byte ]	0
+		// MDP Size			[  4Byte ]	1
+		// Hidden Size		[  4Byte ]	2
+		// Multi-Hidden Num [  4Byte ]	3
+		// Multi-Hidden Size[  4Byte ]	4~10
+		//==============================================
+	ENUM_LBA_VFP_SECTOR_SIZE = 0,
+	ENUM_LBA_MDP_SECTOR_SIZE,
+	ENUM_LBA_HIDDEN_SECTOR_SIZE,
+	ENUM_LBA_MULTI_HIDDEN_NUM,
+	ENUM_LBA_MULTI_HIDDEN_SIZE_0,
+	ENUM_LBA_MULTI_HIDDEN_SIZE_1,
+	ENUM_LBA_MULTI_HIDDEN_SIZE_2,
+	ENUM_LBA_MULTI_HIDDEN_SIZE_3,
+	ENUM_LBA_MULTI_HIDDEN_SIZE_4,
+	ENUM_LBA_MULTI_HIDDEN_SIZE_5,
+	ENUM_LBA_MULTI_HIDDEN_SIZE_6,
+	ENUM_LBA_MULTI_HIDDEN_SIZE_7,
+	ENUM_LBA_MULTI_HIDDEN_SIZE_8,
+	ENUM_LBA_MULTI_HIDDEN_SIZE_9
+};
+
+#define SAMSUNG_NAND_MAKER_ID					0xEC
+#define TOSHIBA_NAND_MAKER_ID					0x98
+#define HYNIX_NAND_MAKER_ID						0xAD
+#define ST_NAND_MAKER_ID						0x20
+#define MICRON_NAND_MAKER_ID					0x2C
+
+#define MAX_SUPPORT_SAMSUNG_NAND				24
+#define MAX_SUPPORT_TOSHIBA_NAND				16
+#define MAX_SUPPORT_HYNIX_NAND					23
+#define MAX_SUPPORT_ST_NAND						13
+#define MAX_SUPPORT_MICRON_NAND					10
+	
+/* LBA NAND FLASH */
+#define MAX_SUPPORT_TOSHIBA_LBA_NAND			3
+
+/* Media Attribute */
+#define A_08BIT									0x00000001		// 8Bit BUS
+#define A_BIG									0x00000002		// Big Page Size
+#define A_SMALL									0x00000004		// Small Page Size
+#define A_16BIT									0x00000008		// 16Bit BUS
+#define A_SLC									0x00000010		// Single Layer Cell
+#define A_MLC									0x00000020		// Multi Layer Cell
+#define A_MLC_8BIT								0x00000040		// 8Bit MLC ECC
+#define A_MLC_12BIT								0x00000080		// 12Bit MLC ECC
+
+#define A_PARALLEL								0x00000100		// Parallel Composition
+#define A_DATA_WITDH_08BIT						0x00000200		// Data 8Bit Bus
+#define A_DATA_WITDH_16BIT						0x00000400		// Data 16Bit Bus
+
+#define S_NOR									0x00010000		// NORMAL [ ReadID, Reset, Read, Page Program, Block Erase, Read Status ]
+#define S_CB									0x00020000		// COPY BACK
+#define S_CP									0x00040000 		// CACHE PROGRAM
+#define S_MP									0x00080000		// MULTI PLANE
+#define S_MP2									0x00100000		// MULTI PLANE
+#define S_MCP									0x00200000		// MULTI PLANE CACHE 
+#define S_IL									0x00400000		// INTER LEAVE
+#define S_EIL									0x00800000		// EXTERNAL INTER LEAVE 
+#define S_EPW									0x01000000		// EXCEPT PARTIAL WRITE
+#define S_NPW									0x02000000		// Not-Support PARTIAL WRITE
+#define S_MP_READ								0x04000000		// MULTI PLANE READ
+#define S_LBA									0x08000000		// LBA NAND
+
+#define NAND_IO_MAX_SUPPORT_DRIVER				2
+
+#define NAND_IO_SERIAL_COMBINATION_MODE			0x00
+#define NAND_IO_PARALLEL_COMBINATION_MODE		0x01
+
+#if defined(NAND_2CS_ONLY)
+#define NAND_IO_DRV0_START_CS					0
+#define NAND_IO_DRV0_END_CS						1
+#else
+#define NAND_IO_DRV0_START_CS					0
+#define NAND_IO_DRV0_END_CS						3
+#endif
+
+#define	ECC_OFF                     			0
+#define	ECC_ON                      			1
+#define SLC_ECC_TYPE							0x0001			// 10 Byte
+#define MLC_ECC_4BIT_TYPE						0x0002			// BCH: 7 Byte( 52 bit)	turn: 2, byte remain: 3, register mask: 0x0F
+#define MLC_ECC_8BIT_TYPE						0x0004			// BCH:13 Byte (104 bit)	turn: 4, byte remain: 1, register mask: 0xFF
+#define MLC_ECC_12BIT_TYPE						0x0010			// BCH:20 Byte (156 bit)	turn: 5, byte remain: 4, register mask: 0x0F
+#define MLC_ECC_14BIT_TYPE						0x0020			// BCH:23 Byte (184 bit)	turn: 6, byte remain: 3, register mask: 0xFF
+#define MLC_ECC_16BIT_TYPE						0x0040			// BCH:26 Byte (207 bit)turn: 7, byte remain: 2, register mask: 0x7F
+
+//----------------------------------------------------------------------
+// TNFTL R/W Area Spare Date
+//----------------------------------------------------------------------
+// Block Area & Type		1Byte :  0xFF
+// Block Parameter			2Byte
+// Logical Block Address	3Byte :  0x0 ~ 0xFFFFFE
+//----------------------------------------------------------------------
+// Spare Data Total 		6Byte
+//----------------------------------------------------------------------
+
+//----------------------------------------------------------------------
+// TNFTL R/O Area Spare Date
+//----------------------------------------------------------------------
+// Block Area & Type		1Byte :  0xFF
+// Rom Image Num			2Byte
+// Rom Image LBA			3Byte :  0x0 ~ 0xFFFFFE
+//----------------------------------------------------------------------
+// Spare Data Total 		6Byte
+//----------------------------------------------------------------------
+
+
+// 512 Page + 16 Spare : SLC / 4 Bit ECC
+typedef struct {
+	U8		SpareData0[4];		//  4 Bytes Spare data
+	U8		Temp;				//  1 Bytes Temp
+	U8		BadMark;			//  1 Bytes bad mark
+	U8		SpareData1[2];		//  2 Bytes Spare data
+	U8		PageECC[8];			//  8 Bytes Spare ECC --> 4Bit ECC
+} SLC_512Page_4BitECC_Spare;
+
+// 2048 Page + 64 Spare : 4 Bit ECC
+typedef struct {
+	U8		BadMark;			//  1 Bytes bad mark
+	U8		Temp;				//  1 Bytes Temp
+	U8		SpareECC[10];		//  8 Bytes Spare ECC --> 4Bit ECC
+	U8 		SpareData[12];		// 12 bytes Spare data
+	U8 		PageECC[4][10];		// 40 Bytes Page ECC
+} MLC_2KPage_4BitECC_Spare;
+
+// 4096 Page + 128 Spare : 4 Bit ECC
+typedef struct {
+	U8		BadMark;			//  1 Bytes bad mark
+	U8		Temp;				//  1 Bytes Temp
+	U8		SpareECC[10];		// 10 Bytes Spare ECC --> 4Bit ECC 
+	U8 		SpareData[20];		// 20 bytes Spare data
+	U8 		PageECC[8][10];		// 80 Bytes Page ECC
+} MLC_4KPage_4BitECC_Spare;
+
+// 4096 Page + 218 Spare : 8/12 Bit ECC
+typedef struct {
+	U8		BadMark;			//  1 Bytes bad mark
+	U8		Temp;				//  1 Bytes Temp
+	U8		SpareECC[20];		// 20 Bytes Spare ECC --> 8 / 12 Bit ECC
+	U8 		SpareData[36];		// 36 bytes Spare data
+	U8 		PageECC[8][20];		//160 Bytes Page ECC
+} MLC_4KPage_8_12BitECC_Spare;
+
+// 8192 Page + 436 Spare : 16 Bit ECC
+typedef struct {
+	U8		BadMark;			//  1 Bytes bad mark
+	U8		Temp;				//  1 Bytes Temp
+	U8		SpareECC[8];		//  8 Bytes Spare ECC --> 4 bit ECC
+	U8 		SpareData[10];		// 10 bytes Spare data
+	U8 		PageECC[16][26];	//416 Bytes Page ECC
+} MLC_4KPage_16BitECC_Spare;
+
+#ifdef ECC_TYPE_RS
+#define TYPE_ECC_FOR_1BIT_SLC_NANDFLASH			MLC_ECC_4BIT_TYPE
+#define TYPE_ECC_FOR_4BIT_MLC_NANDFLASH			MLC_ECC_4BIT_TYPE
+#define TYPE_ECC_FOR_8BIT_MLC_NANDFLASH			MLC_ECC_8BIT_TYPE
+#define ECC_SHIFT_DATASIZE						16
+#else
+#define TYPE_ECC_FOR_1BIT_SLC_NANDFLASH			MLC_ECC_4BIT_TYPE
+#define TYPE_ECC_FOR_4BIT_MLC_NANDFLASH			MLC_ECC_4BIT_TYPE
+#define TYPE_ECC_FOR_8BIT_MLC_NANDFLASH			MLC_ECC_12BIT_TYPE
+#define TYPE_ECC_FOR_12BIT_MLC_NANDFLASH		MLC_ECC_12BIT_TYPE
+#define TYPE_ECC_FOR_14BIT_MLC_NANDFLASH		MLC_ECC_14BIT_TYPE
+#define TYPE_ECC_FOR_16BIT_MLC_NANDFLASH		MLC_ECC_16BIT_TYPE
+#define ECC_SHIFT_DATASIZE						4
+#endif
+
+#define TNFTL_READ_SPARE_ON						0
+#define TNFTL_READ_SPARE_OFF					1
+
+#define NAND_MCU_ACCESS							0
+#define NAND_DMA_ACCESS							1
+
+#define NAND_NORMAL_BUFFER						0
+#define NAND_SERIAL_CHAIN_BUFFER				1
+
+
+#define ECC_DECODE								0
+#define ECC_ENCODE								1
+#define	INTER_LEAVE_OFF                			0
+#define	INTER_LEAVE_ON                			1
+#define MULTI_PLANE_MID_PAGE					0
+#define MULTI_PLANE_LAST_PAGE					1
+#define MULTI_PLANE_GOOD_BLOCK					0
+#define MULTI_PLANE_BAD_BLOCK					1
+
+#define NAND_IO_BSA_OK							0x0000
+#define NAND_IO_BSA_BAD_SERIAL					0x0001
+#define NAND_IO_BSA_BAD_BLOCK1_PARALLEL			0x0010
+#define NAND_IO_BSA_BAD_BLOCK2_PARALLEL			0x0100
+#define NAND_IO_BSA_FAIL_OTHER_REASON			0x1000
+
+#define NAND_IO_STATUS_FAIL_CS0_SERIAL			0x0001
+#define NAND_IO_STATUS_FAIL_CS0_PARALLEL		0x0010
+#define NAND_IO_STATUS_FAIL_CS1_PARALLEL		0x0100
+
+#define NAND_IO_LOG_COLUMN_IN_PAGE				0
+#define NAND_IO_LOG_COLUMN_IN_SPARE				1
+
+/* LBA NAND DEFINATION : [STATUS READ 2] */
+#define NAND_LBA_PNP							0x00
+#define NAND_LBA_BCM							0x02
+#define NAND_LBA_VFP							0x04
+#define NAND_LBA_MDP							0x06
+
+#define NAND_LBA_DATA_AREA						0x16
+#define NAND_LBA_HIDDEN_AREA					0x26
+#define NAND_LBA_MULTI_HIDDEN_AREA_0			0x36
+#define NAND_LBA_MULTI_HIDDEN_AREA_1			0x46
+#define NAND_LBA_MULTI_HIDDEN_AREA_2			0x56
+
+#define NAND_POWER_SAVE_ENABLE					0x01
+#define NAND_HIGH_SPEED_ENABLE					0x08
+
+#define NAND_ADDRESS_OUT_OF_RANGE_ERROR			0x10
+#define NAND_COMMAND_PARAMETER_ERROR			0x40
+
+/* LBA NAND Transfer Protocol 1 */
+#define NAND_PROT1_512x1						0x01
+#define NAND_PROT1_512x4						0x02
+#define NAND_PROT1_512x8						0x04
+
+#define NAND_PROT1_528x1						0x21
+#define NAND_PROT1_528x4						0x22
+#define NAND_PROT1_528x8						0x24
+
+#define NAND_PROT1_SPARE_INCLUDE				0x20
+#define NAND_PROT1_SECTOR_COUNT_MASK			0x07
+
+#define NAND_PROT1_NoCRC_NoECC					0x00
+#define NAND_PROT1_CRC							0x40
+#define NAND_PROT1_ECC_CHECK_ONLY				0x80
+#define NAND_PROT1_ECC_CORRECT					0xC0
+
+/* LBA NAND Transfer Protocol 2 */
+#define NAND_PROT2_READ_TYPE_A					0x00
+#define NAND_PROT2_READ_TYPE_B					0x02
+#define NAND_PROT2_READ_TYPE_C					0x03
+
+#define NAND_PROT2_WRITE_TYPE_A					0x00
+#define NAND_PROT2_WRITE_TYPE_B					0x04
+
+#define NAND_LBA_MAX_SUPPORT_MHD_AREA_NUM		10
+
+typedef void (*NAND_LBA_CALLBACK_HANDLER) ( U16 nDrvNo, U16 nStatusCode, U32 wParam );
+#define NAND_LBA_CALLBACK_LCD_FORMAT_PROCESS	0x04
+
+
+/* HardWare relevant variables */
+#define PAGE_ECC_OFF							0
+#define PAGE_ECC_ON								1
+
+#define NAND_IO_SPARE_SIZE_BIG					32
+#define NAND_IO_SPARE_SIZE_SMALL				8
+
+#define NAND_IO_NFC_BUS							0
+#define NAND_IO_MEM_BUS							1
+
+#define NAND_IO_DATA_WITDH_8BIT					0
+#define NAND_IO_DATA_WITDH_16BIT				1
+
+#if 0		/* 09.03.16 */
+#if defined(_LINUX_) || defined(_WINCE_)
+    #ifdef USE_V_ADDRESS
+		#if defined(_LINUX_)
+        #define	NAND_IO_HwCMD							*(volatile unsigned long*)0xF00B0000	//( gNAND_IO_pHwND->CMD )
+        #define	NAND_IO_HwLADR							*(volatile unsigned long*)0xF00B0004	//( gNAND_IO_pHwND->LADR )
+        #define	NAND_IO_HwDATA							*(volatile unsigned long*)0xF00B0010	//( gNAND_IO_pHwND->WDATA.D32 )
+        #define	NAND_IO_HwSDATA							*(volatile unsigned long*)0xF00B0040	//(/*( gNAND_IO_DataBusType == NAND_IO_MEM_BUS ) ? gNAND_IO_pHwND->WDATA.D8 : */gNAND_IO_pHwND->SDATA.D32 )
+        #define	NAND_IO_HwSADR							*(volatile unsigned long*)0xF00B000C	//( gNAND_IO_pHwND->SADR )
+        #define	NAND_IO_HwECCBASEPAGE					0xF00B0010								//((unsigned)&NAND_IO_HwDATA)
+		#elif defined(_WINCE_)
+        #define	NAND_IO_HwCMD							*(volatile unsigned long*)0xB00B0000	//( gNAND_IO_pHwND->CMD )
+        #define	NAND_IO_HwLADR							*(volatile unsigned long*)0xB00B0004	//( gNAND_IO_pHwND->LADR )
+        #define	NAND_IO_HwDATA							*(volatile unsigned long*)0xB00B0010	//( gNAND_IO_pHwND->WDATA.D32 )
+        #define	NAND_IO_HwSDATA							*(volatile unsigned long*)0xB00B0040	//(/*( gNAND_IO_DataBusType == NAND_IO_MEM_BUS ) ? gNAND_IO_pHwND->WDATA.D8 : */gNAND_IO_pHwND->SDATA.D32 )
+        #define	NAND_IO_HwSADR							*(volatile unsigned long*)0xB00B000C	//( gNAND_IO_pHwND->SADR )
+        #define	NAND_IO_HwECCBASEPAGE					0xF00B0010								//((unsigned)&NAND_IO_HwDATA)
+		#endif
+    #else	 // MAKEBOOTLOADER
+        #define	NAND_IO_HwCMD							*(volatile unsigned long*)0xF00B0000	//( gNAND_IO_pHwND->CMD )
+        #define	NAND_IO_HwLADR							*(volatile unsigned long*)0xF00B0004	//( gNAND_IO_pHwND->LADR )
+        #define	NAND_IO_HwDATA							*(volatile unsigned long*)0xF00B0010	//( gNAND_IO_pHwND->WDATA.D32 )
+        #define	NAND_IO_HwSDATA							*(volatile unsigned long*)0xF00B0040	//(/*( gNAND_IO_DataBusType == NAND_IO_MEM_BUS ) ? gNAND_IO_pHwND->WDATA.D8 : */gNAND_IO_pHwND->SDATA.D32 )
+        #define	NAND_IO_HwSADR							*(volatile unsigned long*)0xF00B000C	//( gNAND_IO_pHwND->SADR )
+        #define	NAND_IO_HwECCBASEPAGE					0xF00B0010								//((unsigned)&NAND_IO_HwDATA)
+    #endif
+#else
+	#define	NAND_IO_HwNFC_CMD						( gNAND_IO_pHwNFC->NFC_CMD )			// 0x000  W  	NAND Flash Command Register
+	#define	NAND_IO_HwNFC_LADDR						( gNAND_IO_pHwNFC->NFC_LADDR )			// 0x004  W  	NAND Flash Linear Address Register
+	#define	NAND_IO_HwNFC_BADDR						( gNAND_IO_pHwNFC->NFC_BADDR )			// 0x008  W  	NAND Flash Block Address Register
+	#define	NAND_IO_HwNFC_SADDR						( gNAND_IO_pHwNFC->NFC_SADDR )			// 0x00C  W  	NAND Flash Signal Address Register
+	#define	NAND_IO_HwNFC_WDATA						( gNAND_IO_pHwNFC->NFC_WDATA[0] )		// 0x01x  R/W	NAND Flash Word Data Register
+	#define	NAND_IO_HwNFC_LDATA						( gNAND_IO_pHwNFC->NFC_LDATA[0] )		// 0x02x/3x R/W	NAND Flash Linear Data Register
+	#define	NAND_IO_HwNFC_SDATA						( gNAND_IO_pHwNFC->NFC_SDATA )			// 0x040  R/W	NAND Flash Single Data Register
+	#define	NAND_IO_HwNFC_CTRL						( gNAND_IO_pHwNFC->NFC_CTRL )			// 0x050  R/W	NAND Flash Control Register
+	#define	NAND_IO_HwNFC_PSTART					( gNAND_IO_pHwNFC->NFC_PSTART )			// 0x054  W  	NAND Flash Program Start Register
+	#define	NAND_IO_HwNFC_RSTART 					( gNAND_IO_pHwNFC->NFC_RSTART )			// 0x058  W  	NAND Flash Read Start Register
+	#define	NAND_IO_HwNFC_DSIZE						( gNAND_IO_pHwNFC->NFC_DSIZE )			// 0x05C  R/W	NAND Flash Data Size Register
+	#define	NAND_IO_HwNFC_IREQ						( gNAND_IO_pHwNFC->NFC_IREQ )			// 0x060  R/W	NAND Flash Interrupt Request Register
+	#define	NAND_IO_HwNFC_RST						( gNAND_IO_pHwNFC->NFC_RST )			// 0x064  W  	NAND Flash Controller Reset Register
+	#define	NAND_IO_HwNFC_CTRL1						( gNAND_IO_pHwNFC->NFC_CTRL1 )			// 0x068  R/W	NAND Flash Control Register 1
+	#define	NAND_IO_HwNFC_MDATA						( gNAND_IO_pHwNFC->NFC_MDATA[0] )		// 0x07x  R/W	NAND Flash Multiple Data Register	
+	#define	NAND_IO_HwECCBASEPAGE					((unsigned)&NAND_IO_HwNFC_WDATA)
+#endif
+#endif /* 0 */
+
+
+#if defined(_LINUX_) || defined(_WINCE_)
+#if defined(TCC89XX) || defined(TCC92XX)
+#define	NAND_IO_HwCMD_PA							*(volatile unsigned long*)0xF05B0000		//( gNAND_IO_pHwND->CMD )
+#define	NAND_IO_HwLADR_PA							*(volatile unsigned long*)0xF05B0004		//( gNAND_IO_pHwND->LADR )
+#define	NAND_IO_HwDATA_PA							*(volatile unsigned long*)0xF05B0010		//( gNAND_IO_pHwND->WDATA.D32 )
+#define	NAND_IO_HwLDATA_PA							*(volatile unsigned long*)0xF05B0020		//( gNAND_IO_pHwND->LDATA )
+#define	NAND_IO_HwSDATA_PA							*(volatile unsigned long*)0xF05B0040		//(/*( gNAND_IO_DataBusType == NAND_IO_MEM_BUS ) ? gNAND_IO_pHwND->WDATA.D8 : */gNAND_IO_pHwND->SDATA.D32 )
+#define	NAND_IO_HwSADR_PA							*(volatile unsigned long*)0xF05B000C		//( gNAND_IO_pHwND->SADR )
+#endif
+#endif
+
+#if defined(TCC92XX)
+#define	NAND_IO_NFC_nWP							HwGPIOB->GPDAT
+#define	NAND_IO_NFC_nWPBit						Hw22
+#elif defined(TCC89XX)
+#define	NAND_IO_NFC_nWP							HwGPIOB->GPDAT
+#define	NAND_IO_NFC_nWPBit						Hw31
+#endif
+#define NAND_IO_STATUS_ENABLE					0x0001
+#define NAND_IO_STATUS_INTERLEAVING_MASK		0x00F0
+#define NAND_IO_STATUS_INTERLEAVING_CHIP1		0x0010
+#define NAND_IO_STATUS_INTERLEAVING_CHIP2		0x0020
+#define NAND_IO_STATUS_INTERLEAVING_CHIP3		0x0040
+#define NAND_IO_STATUS_INTERLEAVING_CHIP4		0x0080
+
+#define NAND_IO_DISTRICT_0						0x0001
+#define NAND_IO_DISTRICT_1						0x0002
+
+#define NAND_IO_DMA_WRITE						0x0001
+#define NAND_IO_DMA_READ						0x0002
+//*****************************************************************************
+//*
+//*
+//*                       [ INTERNAL STRUCT DEFINE ]
+//*
+//*
+//*****************************************************************************
+typedef struct __tag_NAND_IO_ECCSizeInfo
+{
+	unsigned int				EncodeFlag;
+	unsigned int				DecodeFlag;
+	unsigned int				ErrorNum;
+	unsigned char				ErrorCodeNum;		// Register Num
+	unsigned char				*All_FF_512_ECC_Code;
+} NAND_IO_ECC_INFO;
+
+typedef struct __tag_NAND_IO_WriteStatus
+{
+	unsigned char				ChipNo;
+	unsigned char				BlockStatus;
+	unsigned int				ErrorPHYPageAddr;
+} NAND_IO_WRITESTATUS;
+
+typedef struct __tag_NAND_IO_BadBlockAddr
+{
+	unsigned char				BlockStatus[4];
+	unsigned int				BadBlkPHYAddr[4];
+} NAND_IO_BADBLOCK;
+
+typedef struct __tag_NAND_IO_Cycle
+{
+	unsigned char				STP;
+	unsigned char				PW;
+	unsigned char				HLD;
+	unsigned int				RegValue;
+} NAND_IO_CYCLE;
+
+typedef struct __tag_NAND_IO_DeviceCode
+{
+	unsigned short int			Code[6];			// Factory ID code
+} NAND_IO_DEVID;
+
+typedef struct __tag_NAND_IO_LBADevInfo
+{
+	unsigned char				Usable;
+	
+	unsigned char				CurrentMode;
+	unsigned long int			CurrentSectorSize;
+	
+	unsigned char				HighSpeedMode;
+	unsigned char				PowerSaveMode;
+	unsigned char				TransProtocol1;
+	unsigned char				TransProtocol2;
+	unsigned char				SectorCount;
+	unsigned char 				DataTransferCheck;
+	unsigned char 				FlagOfChangeTotalSectorSize;
+
+	unsigned long int			VFPSectorSize;		// NBArea
+	
+	unsigned long int			MDPSectorSize;		// RWArea Totla Sector Size
+	unsigned long int			DTAreaSectorSize;	// RWArea
+	unsigned long int			HDAreaSectorSize;	// RWArea
+	unsigned long int			HDAreaAddrOffSet;
+
+	unsigned long int 			MHDAreaNums;	// Multi Hidden Area Num
+	unsigned long int			MHDAreaSectorSize[NAND_LBA_MAX_SUPPORT_MHD_AREA_NUM];
+	unsigned long int			MHDAreaAddrOffSet[NAND_LBA_MAX_SUPPORT_MHD_AREA_NUM];
+	
+} NAND_IO_LBADEVINFO;
+
+typedef struct __tag_NAND_IO_Feature
+{
+	NAND_IO_DEVID				DeviceID;			// Maker & Device ID Code
+	unsigned short int  		PBpV;				// Physical all Block Number
+	unsigned short int			BBpZ;				// Total Bad Block in one ZONE
+	unsigned short int  		PpB;				// Page Number Per Block
+	unsigned short int  		PageSize;			// Page Size
+	unsigned short int  		SpareSize;			// Spare Size
+	unsigned short int			ColCycle;			// Column Address Cycle
+	unsigned short int			RowCycle;			// Row Address Cycle
+	unsigned short int			WCtime;				// Write Cyclte time
+	unsigned short int			WriteSTP;
+	unsigned short int			WriteWP;
+	unsigned short int			WriteHLD;
+	unsigned short int			ReadSTP;
+	unsigned short int			ReadPW;
+	unsigned short int			ReadHLD;
+	unsigned long int			MediaType;			// Chracters of NANDFLASH
+} NAND_IO_FEATURE;
+
+typedef struct __tag_NAND_IO_DevInfo
+{
+	NAND_IO_FEATURE				Feature;			// Feature of NANDFLASH
+	unsigned short int			IoStatus;			// IO Status
+	unsigned short int			ChipNo;				// ChipSelect Number
+	unsigned short int			CmdMask;			// Command Mask Bit
+	unsigned short int			EccType;			// Type of ECC [ SLC , MLC4 ]
+	unsigned short int			EccDataSize;
+
+	unsigned short int			PPages;				// Total Partial Page [512+16Bytes]
+
+	unsigned short int			DistrictNum;
+	unsigned short int			ShiftDistrictNum;
+
+	unsigned short int			ExtInterleaveUsable;
+
+	unsigned short int			ShiftPBpV;
+	unsigned short int			ShiftPpB;
+	unsigned short int			ShiftPageSize;
+	unsigned short int			ShiftPPages;
+	
+	unsigned short int			PageUniteMode;
+	unsigned short int			RemapPpB;			// Physical Page Number Per FTL 1Block
+	unsigned short int			RemapPageOffset;	// Next FTL Block Page Offset
+	unsigned short int			RemapRatioBSize;	// Physical Block Number Per FTL 1Block
+	unsigned long int			RemapRatioPSize;	// Physical Block Number Per FTL 1Block
+	
+	unsigned short int			ShiftRemapPpB;
+	unsigned short int			ShiftRemapPageOffset;
+	unsigned short int			ShiftRemapRatioBSize;
+	unsigned short int			ShiftRemapRatioPSize;
+
+	unsigned long int			RemapPageWeight[4];
+
+	NAND_IO_WRITESTATUS			WriteStatus;
+		
+	NAND_IO_BADBLOCK			BadBlockInfo;
+	NAND_IO_LBADEVINFO			LBAInfo;
+} NAND_IO_DEVINFO;
+
+typedef struct __tag_NAND_IO_MakerInfo
+{
+	unsigned short int			MaxSupportNAND[MAX_SUPPORT_MAKER_NAND];
+	unsigned short int			MakerID[MAX_SUPPORT_MAKER_NAND];
+	NAND_IO_FEATURE*			DevInfo[MAX_SUPPORT_MAKER_NAND];
+} NAND_IO_MAKERINFO;
+
+
+typedef struct __tag_NAND_IO_LBAMakerInfo
+{
+	unsigned short int			MaxSupportNAND[MAX_SUPPORT_MAKER_LBA_NAND];
+	unsigned short int			MakerID[MAX_SUPPORT_MAKER_LBA_NAND];
+	NAND_IO_FEATURE*			DevInfo[MAX_SUPPORT_MAKER_LBA_NAND];
+} NAND_IO_LBA_MAKERINFO;
+
+//*****************************************************************************
+//*
+//*
+//*                       [ EXTERNAL VARIABLE DEFINE ]
+//*
+//*
+//*****************************************************************************
+extern const NAND_IO_MAKERINFO		NAND_SupportMakerInfo;
+extern const NAND_IO_LBA_MAKERINFO	LBA_NAND_SupportMakerInfo;
+
+extern const NAND_IO_FEATURE		SAMSUNG_NAND_DevInfo[MAX_SUPPORT_SAMSUNG_NAND];
+extern const NAND_IO_FEATURE		TOSHIBA_NAND_DevInfo[MAX_SUPPORT_TOSHIBA_NAND];
+extern const NAND_IO_FEATURE		HYNIX_NAND_DevInfo[MAX_SUPPORT_HYNIX_NAND];
+extern const NAND_IO_FEATURE		ST_NAND_DevInfo[MAX_SUPPORT_ST_NAND];
+extern const NAND_IO_FEATURE		MICRON_NAND_DevInfo[MAX_SUPPORT_MICRON_NAND];
+
+extern const NAND_IO_FEATURE		TOSHIBA_LBA_NAND_DevInfo[MAX_SUPPORT_TOSHIBA_LBA_NAND];
+
+//*****************************************************************************
+//*
+//*
+//*                       [ EXTERNAL FUCTIONS DEFINE ]
+//*
+//*
+//*****************************************************************************
+extern NAND_IO_ERROR		NAND_IO_CallBackChangeWCtime( unsigned short int TotalMediaNum, NAND_IO_DEVINFO *nDevInfo );
+extern NAND_IO_ERROR		NAND_IO_SetCycle( NAND_IO_DEVINFO *nDevInfo );
+extern NAND_IO_ERROR		NAND_IO_GetDeviceInfo( U16 nChipNo, NAND_IO_DEVINFO *nDevInfo );
+extern U32					NAND_IO_GetBUSTypeOfDataIO( void );
+extern void					NAND_IO_Init( void );
+extern void					NAND_IO_Reset( U16 nChipNo, int nMode );
+extern void					NAND_IO_ResetForReadID( U16 nChipNo, int nMode );
+extern void					NAND_IO_ReadID( U16 nChipNo, NAND_IO_DEVID *nDeviceCode, int nMode );
+
+extern NAND_IO_ERROR		NAND_IO_ReadSpare( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U8 *nSpareBuffer );
+extern NAND_IO_ERROR		NAND_IO_ReadPage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U16 nStartPPage, U16 nReadPPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+extern NAND_IO_ERROR		NAND_IO_ReadPageMTD( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U16 nStartPPage, U16 nReadPPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+extern NAND_IO_ERROR		NAND_IO_ReadNBPage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U16 nStartPPage, U16 nReadPPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+extern NAND_IO_ERROR		NAND_IO_ReadTwoPlanePage(NAND_IO_DEVINFO * nDevInfo, U32 nPageAddr, U32 nSecondPageAddr, U16 nStartPPage, U16 nReadPPSize, U8 * nPageBuffer, U8 * nSpareBuffer, int nEccOnOff);
+extern NAND_IO_ERROR		NAND_IO_ReadTwoPlaneLastPage(NAND_IO_DEVINFO * nDevInfo, U32 nPageAddr, U16 nStartPPage, U16 nReadPPSize, U8 * nPageBuffer, U8 * nSpareBuffer, int nEccOnOff);
+extern NAND_IO_ERROR		NAND_IO_ReadUserSizePage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U16 nColumnAddr, U32 nReadSize, U8 *nReadBuffer );
+extern NAND_IO_ERROR	 	NAND_IO_ReadChainPage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U8 *nPageBuffer, U8 *nSpareBuffer, int nMode );
+extern NAND_IO_ERROR 		NAND_IO_ReadGoldenPage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U8 *nPageBuffer, U8 *nSpareBuffer );
+
+extern NAND_IO_ERROR 		NAND_IO_WriteSpare( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U8* nSpareBuffer, int nEccOnOff );
+extern NAND_IO_ERROR		NAND_IO_WritePage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U16 nStartPPage, U16 nWritePPSize, U8 *nPageBuffer, U8* nSpareBuffer, int nEccOnOff );
+extern NAND_IO_ERROR		NAND_IO_WritePageMTD( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U16 nStartPPage, U16 nWritePPSize, U8 *nPageBuffer, U8* nSpareBuffer, int nEccOnOff );
+extern NAND_IO_ERROR 		NAND_IO_WriteNBPage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U16 nStartPPage, U16 nWritePPSize, U8 *nPageBuffer, U8* nSpareBuffer, int nEccOnOff );
+extern NAND_IO_ERROR		NAND_IO_WriteCachePage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U16 nStartPPage, U16 nWritePPSize, U8 *nPageBuffer, U8* nSpareBuffer, int nEccOnOff );
+extern NAND_IO_ERROR		NAND_IO_WriteTwoPlanePage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U16 nStartPPage, U16 nWritePPSize, U8 *nPageBuffer, U8* nSpareBuffer, int nEccOnOff );
+extern NAND_IO_ERROR		NAND_IO_WriteTwoPlaneLastPage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U16 nStartPPage, U16 nWritePPSize, U8 *nPageBuffer, U8* nSpareBuffer, int LastPage, int nEccOnOff );
+extern NAND_IO_ERROR		NAND_IO_WriteUserSizePage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U16 nColumnAddr, U32 nWriteSize, U8 *nWriteBuffer );
+
+extern NAND_IO_ERROR 		NAND_IO_WriteChainPage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U8 *nPageBuffer, U8 *nSpareBuffer, int nMode );
+extern NAND_IO_ERROR 		NAND_IO_WriteGoldenPage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U8 *nPageBuffer, U8 *nSpareBuffer );
+
+extern NAND_IO_ERROR		NAND_IO_CopyBackPage( NAND_IO_DEVINFO *nDevInfo, U32 nDesPageAddr, U32 nSrcPageAddr );
+extern NAND_IO_ERROR		NAND_IO_CopyBackTwoPlanePage( NAND_IO_DEVINFO *nDevInfo, U32 nDesPageAddr, U32 nSrcPageAddr );
+
+extern NAND_IO_ERROR		NAND_IO_EraseBlock( NAND_IO_DEVINFO *nDevInfo, U32 nBlockPageAddr, int nFormatMode );
+extern NAND_IO_ERROR		NAND_IO_EraseBlockForTwoPlane( NAND_IO_DEVINFO *nDevInfo, U32 nBlockPageAddr, int nFormatMode );
+
+extern NAND_IO_ERROR		NAND_IO_GetFactoryBadMarkOfPBlock( NAND_IO_DEVINFO *nDevInfo, U32 nBlockPageAddr );
+extern NAND_IO_ERROR		NAND_IO_GetUID( NAND_IO_DEVINFO *nDevInfo, U16 *nCmd, U8 *rReadData );
+extern NAND_IO_ERROR		NAND_IO_WaitBusyCheckForWriteEnd( NAND_IO_DEVINFO *nDevInfo );
+
+extern NAND_IO_ERROR 		NAND_IO_LBA_SetCallBackHandler( NAND_LBA_CALLBACK_HANDLER pCallBackHandler );
+extern U32  			    NAND_IO_LBA_GetSerialNumber( NAND_IO_DEVINFO *nDevInfo, U8* nPageBuffer, U8* rSerialNumber, U16 nSize );
+extern NAND_IO_ERROR		NAND_IO_LBA_PowerSaveMode( NAND_IO_DEVINFO *nDevInfo, int nOnOff );
+extern NAND_IO_ERROR 		NAND_IO_LBA_DeviceReboot( NAND_IO_DEVINFO *nDevInfo );
+
+extern NAND_IO_ERROR 		NAND_IO_LBA_GetDeviceInfo( NAND_IO_DEVINFO *nDevInfo );
+extern NAND_IO_ERROR 		NAND_IO_LBA_Init( NAND_IO_DEVINFO *nDevInfo );
+extern NAND_IO_ERROR 		NAND_IO_LBA_ReadSectorBy4Byte( NAND_IO_DEVINFO *nDevInfo, U8 nPartition, U32 nSectorAddr, U16 nOffset, U16 nReadSize, U8 *nReadBuffer );
+extern NAND_IO_ERROR 		NAND_IO_LBA_ReadSector( NAND_IO_DEVINFO *nDevInfo, U8 nPartition, U32 nSectorAddr, U16 nSecSize, U8 *nReadBuffer );
+extern NAND_IO_ERROR 		NAND_IO_LBA_WriteSector( NAND_IO_DEVINFO *nDevInfo,U8 nPartition, U32 nSectorAddr, U16 nSecSize, U8 *nWriteBuffer );
+extern NAND_IO_ERROR 		NAND_IO_LBA_AREAClear( NAND_IO_DEVINFO *nDevInfo, U8 nPartition );
+extern NAND_IO_ERROR 		NAND_IO_LBA_ModeChange( NAND_IO_DEVINFO *nDevInfo, int nMode );
+extern NAND_IO_ERROR 		NAND_IO_LBA_ScanHeaderOfVFP( NAND_IO_DEVINFO *nDevInfo );
+extern NAND_IO_ERROR 		NAND_IO_LBA_MakeHeaderOfVFP( NAND_IO_DEVINFO *nDevInfo );
+extern NAND_IO_ERROR 		NAND_IO_LBA_Read2Status( NAND_IO_DEVINFO *nDevInfo );
+extern NAND_IO_ERROR 		NAND_IO_LBA_GetTotalSecAndCHS( NAND_IO_DEVINFO *nDevInfo, int nPartition, U32 *rTotalSec, U16 *rCylinder, U16 *rHead, U8 *rSector );
+extern NAND_IO_ERROR 		NAND_IO_LBA_CacheFlush( NAND_IO_DEVINFO *nDevInfo );
+
+#endif
+
diff --git a/drivers/block/tcc/inc/tnftl/nand_io_v7.h b/drivers/block/tcc/inc/tnftl/nand_io_v7.h
new file mode 100644
index 0000000..4cabb3c
--- /dev/null
+++ b/drivers/block/tcc/inc/tnftl/nand_io_v7.h
@@ -0,0 +1,842 @@
+ /****************************************************************************
+ *   FileName    : nand_io_v7.h
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ * 
+ ****************************************************************************/
+#ifndef __NAND_IO_H
+#define __NAND_IO_H
+
+//*****************************************************************************
+//*
+//*
+//*                       [ Specific DEFINE ]
+//*
+//*
+//*****************************************************************************
+#if defined(TCC83XX) && defined(_WINCE_)
+// In the case of LINUX, it is defined config.h
+#define NAND_2CS_ONLY
+#define NAND_8BIT_ONLY
+#else
+//#define NAND_2CS_ONLY
+//#define NAND_8BIT_ONLY
+#endif
+
+//**********************************************************************
+//*		Define Dev Board
+//**********************************************************************
+//#define TCC9200S_BOARD			// TCC9200S ND_RDY: GPIO_B31
+#define TCC89_92_BOARD			// TCC89/91/9200 ND_RDY: GPIO_B28 - EDI - NFC_CTRL
+
+//**********************************************************************
+//*		Define ECC Algorithm for ChipSet
+//**********************************************************************
+#if defined(TCC77X) || defined(TCC87XX) || defined(TCC82XX) || defined(TCC78X) || defined(TCC83XX) || defined(TCC79XX)
+#define ECC_TYPE_RS
+#elif defined(TCC81XX) || defined(TCC80XX) || defined(TCC92XX) || defined(TCC89XX)
+#define ECC_TYPE_BCH
+#endif
+
+#if defined(USE_V_ADDRESS)
+	#if defined(_LINUX_)
+	#define  ND_TRACE	printk
+	#elif defined(_WINCE_)
+	//#define  ND_TRACE(a)		RETAILMSG(1, a)
+	#endif
+#else
+	#if defined(_LINUX_)
+		#define  ND_TRACE	printf
+	#elif defined(_WINCE_)
+		#define  ND_TRACE	B_RETAILMSG
+	#else
+		#define	 ND_TRACE	uart_send_printf
+	#endif
+#endif
+
+//*****************************************************************************
+//*
+//*
+//*                       [ General DEFINE & TYPEDEF ]
+//*
+//*
+//*****************************************************************************
+//===================================================================
+//
+//		DRIVER SIGNATURE
+//
+//===================================================================
+#define SIGBYAHONG				'S','I','G','B','Y','A','H','O','N','G','_'
+
+#define NAND_IO_SIGNATURE		'N','A','N','D','_','I','O','_'
+#define TNFTL_SIGNATURE			'T','N','F','T','L','_'
+
+#if defined(_WINCE_)
+#define SIGN_OS					'W','I','N','C','E','_'
+#elif defined(_LINUX_)
+#define SIGN_OS					'L','I','N','U','X','_'
+#else
+#define SIGN_OS					'N','U','_'
+#endif
+
+#if defined(TCC77X)
+#define SIGN_CHIPSET			'T','C','C','7','7','X','X','_'
+#elif defined(TCC78X)
+#define SIGN_CHIPSET			'T','C','C','7','8','X','X','_'
+#elif defined(TCC79X)
+#define SIGN_CHIPSET			'T','C','C','7','9','X','X','_'
+#elif defined(TCC81XX)
+#define SIGN_CHIPSET			'T','C','C','8','1','X','X','_'
+#elif defined(TCC82XX)
+#define SIGN_CHIPSET			'T','C','C','8','2','X','X','_'
+#elif defined(TCC83XX)
+#define SIGN_CHIPSET			'T','C','C','8','3','X','X','_'
+#elif defined(TCC87XX)
+#define SIGN_CHIPSET			'T','C','C','8','7','X','X','_'
+#elif defined(TCC89XX)
+#define SIGN_CHIPSET			'T','C','C','8','9','X','X','_'
+#elif defined(TCC91XX)
+#define SIGN_CHIPSET			'T','C','C','9','1','X','X','_'
+#elif defined(TCC92XX)
+#define SIGN_CHIPSET			'T','C','C','9','2','X','X','_'
+#else
+#error
+#endif
+
+#ifndef DISABLE
+#define DISABLE					0
+#endif
+#ifndef ENABLE
+#define	ENABLE					1
+#endif
+#ifndef FALSE
+#define FALSE           		0
+#endif
+#ifndef TRUE
+#define TRUE            		1
+#endif
+#ifndef NULL
+#define NULL            		0
+#endif
+
+#if defined(_LINUX_)
+#ifndef _U8_
+#define _U8_
+typedef unsigned char			U8;
+#endif
+#ifndef _U16_
+#define _U16_
+typedef unsigned short int		U16;
+#endif
+#ifndef _U32_
+#define _U32_
+typedef unsigned int			U32;
+#endif
+#ifndef _BOOL_
+#define _BOOL_
+typedef unsigned int			BOOL;
+#endif
+#else
+#ifndef U8
+typedef unsigned char			U8;
+#endif
+#ifndef U16
+typedef unsigned short int		U16;
+#endif
+#ifndef U32
+typedef unsigned int			U32;
+#endif
+#ifndef _BOOL_
+typedef unsigned int			BOOL;
+#endif
+#endif
+
+#ifndef DWORD_BYTE
+typedef	union {
+	unsigned long		DWORD;
+	unsigned short int	WORD[2];
+	unsigned char		BYTE[4];
+} DWORD_BYTE;
+#endif
+
+#ifndef BITSET
+#define	BITSET(X, MASK)				( (X) |= (U32)(MASK) )
+#endif
+#ifndef BITSCLR
+#define	BITSCLR(X, SMASK, CMASK)	( (X) = ((((U32)(X)) | ((U32)(SMASK))) & ~((U32)(CMASK))) )
+#endif
+#ifndef BITCSET
+#define	BITCSET(X, CMASK, SMASK)	( (X) = ((((U32)(X)) & ~((U32)(CMASK))) | ((U32)(SMASK))) )
+#endif
+#ifndef BITCLR
+#define	BITCLR(X, MASK)				( (X) &= ~((U32)(MASK)) )
+#endif
+#ifndef BITXOR
+#define	BITXOR(X, MASK)				( (X) ^= (U32)(MASK) )
+#endif
+#ifndef ISZERO
+#define	ISZERO(X, MASK)				(  ! (((U32)(X)) & ((U32)(MASK))) )
+#endif
+#ifndef BYTE_OF
+#define	BYTE_OF(X)					( *(volatile unsigned char *)(&(X)) )
+#endif
+#ifndef HWORD_OF
+#define	HWORD_OF(X)					( *(volatile unsigned short *)(&(X)) )
+#endif
+#ifndef WORD_OF
+#define	WORD_OF(X)					( *(volatile unsigned int *)(&(X)) )
+#endif
+
+//*****************************************************************************
+//*
+//*
+//*                         [ ERROR CODE ENUMERATION ]
+//*
+//*
+//*****************************************************************************
+#ifndef SUCCESS
+#define SUCCESS		0
+#endif
+
+typedef enum
+{
+	ERR_NAND_IO_FAILED_GET_DEVICE_INFO = 0xA100000,
+	ERR_NAND_IO_FAILED_CORRECTION_SLC_ECC,
+	ERR_NAND_IO_FAILED_CORRECTION_MLC_ECC,
+	ERR_NAND_IO_FAILED_GET_SHIFT_FACTOR_FOR_MULTIPLY,
+	ERR_NAND_IO_FAILED_GET_FACTORY_BAD_MARK_OF_PBLOCK,
+	ERR_NAND_IO_READ_STATUS_GENERAL_FAIL,
+	ERR_NAND_IO_TIME_OUT_READ_STATUS,
+	ERR_NAND_IO_WRONG_PARAMETER,
+	ERR_NAND_IO_WRONG_PARAMETER_ROW_COL_ADDRESS,
+	ERR_NAND_IO_NOT_READY_DEVICE_IO,
+	ERR_NAND_IO_FAILED_WRITE,
+	ERR_NAND_IO_NOT_EXIST_LBA_HEADBLOCK,
+	ERR_NAND_IO_FAILED_LBA_PARTITION_CHANGE
+} NAND_IO_ERROR;
+ 
+//*****************************************************************************
+//*
+//*
+//*                          [ INTERNAL DEFINATION ]
+//*
+//*
+//*****************************************************************************
+
+/* Maker Information of supported NANDFLASH */
+enum SUPPORT_MAKER_NAND
+{
+	SAMSUNG = 0,
+	TOSHIBA,
+	HYNIX,
+	ST,
+	MICRON,
+	MAX_SUPPORT_MAKER_NAND
+};
+
+enum SUPPORT_MAKER_LBA_NAND
+{
+	TOSHIBA_LBA = 0,
+	MAX_SUPPORT_MAKER_LBA_NAND
+};
+
+enum LBA_NAND_HIDDEN_INFO
+{
+	//==============================================		
+	// VFP Size			[  4Byte ]	0
+	// MDP Size			[  4Byte ]	1
+	// Hidden Size		[  4Byte ]	2
+	// Multi-Hidden Num [  4Byte ]	3
+	// Multi-Hidden Size[  4Byte ]	4~10
+	//==============================================
+	ENUM_LBA_VFP_SECTOR_SIZE = 0,
+	ENUM_LBA_MDP_SECTOR_SIZE,
+	ENUM_LBA_HIDDEN_SECTOR_SIZE,
+	ENUM_LBA_MULTI_HIDDEN_NUM,
+	ENUM_LBA_MULTI_HIDDEN_SIZE_0,
+	ENUM_LBA_MULTI_HIDDEN_SIZE_1,
+	ENUM_LBA_MULTI_HIDDEN_SIZE_2,
+	ENUM_LBA_MULTI_HIDDEN_SIZE_3,
+	ENUM_LBA_MULTI_HIDDEN_SIZE_4,
+	ENUM_LBA_MULTI_HIDDEN_SIZE_5,
+	ENUM_LBA_MULTI_HIDDEN_SIZE_6,
+	ENUM_LBA_MULTI_HIDDEN_SIZE_7,
+	ENUM_LBA_MULTI_HIDDEN_SIZE_8,
+	ENUM_LBA_MULTI_HIDDEN_SIZE_9
+};
+
+#define SAMSUNG_NAND_MAKER_ID					0xEC
+#define TOSHIBA_NAND_MAKER_ID					0x98
+#define HYNIX_NAND_MAKER_ID						0xAD
+#define ST_NAND_MAKER_ID						0x20
+#define MICRON_NAND_MAKER_ID					0x2C
+
+#define MAX_SUPPORT_SAMSUNG_NAND				24
+#define MAX_SUPPORT_TOSHIBA_NAND				16
+#define MAX_SUPPORT_HYNIX_NAND					25
+#define MAX_SUPPORT_ST_NAND						13
+#define MAX_SUPPORT_MICRON_NAND					10
+	
+/* LBA NAND FLASH */
+#define MAX_SUPPORT_TOSHIBA_LBA_NAND			3
+
+/* Media Attribute */
+#define A_08BIT									0x00000001		// 8Bit BUS
+#define A_BIG									0x00000002		// Big Page Size
+#define A_SMALL									0x00000004		// Small Page Size
+#define A_16BIT									0x00000008		// 16Bit BUS
+#define A_SLC									0x00000010		// Single Layer Cell
+#define A_MLC									0x00000020		// Multi Layer Cell
+#define A_MLC_8BIT								0x00000040		// 8Bit MLC ECC
+#define A_MLC_12BIT								0x00000080		// 12Bit MLC ECC
+
+#define A_PARALLEL								0x00000100		// Parallel Composition
+#define A_DATA_WITDH_08BIT						0x00000200		// Data 8Bit Bus
+#define A_DATA_WITDH_16BIT						0x00000400		// Data 16Bit Bus
+
+#define S_NOR									0x00010000		// NORMAL [ ReadID, Reset, Read, Page Program, Block Erase, Read Status ]
+#define S_CB									0x00020000		// COPY BACK
+#define S_CP									0x00040000 		// CACHE PROGRAM
+#define S_MP									0x00080000		// MULTI PLANE
+#define S_MP2									0x00100000		// MULTI PLANE
+#define S_MCP									0x00200000		// MULTI PLANE CACHE 
+#define S_IL									0x00400000		// INTER LEAVE
+#define S_EIL									0x00800000		// EXTERNAL INTER LEAVE 
+#define S_EPW									0x01000000		// EXCEPT PARTIAL WRITE
+#define S_NPW									0x02000000		// Not-Support PARTIAL WRITE
+#define S_MP_READ								0x04000000		// MULTI PLANE READ
+#define S_LBA									0x08000000		// LBA NAND
+#define S_RAND_IO								0x10000000		// Random Data In/Out
+
+#define NAND_IO_NORMAL_PAGE_PROGRAM				0x00000001
+#define NAND_IO_CACHE_PROGRAM_1ST				0x00000002
+#define NAND_IO_CACHE_PROGRAM_2ND				0x00000004
+#define NAND_IO_TWO_PLANE_PAGE_PROGAM_1ST		0x00000010
+#define NAND_IO_TWO_PLANE_PAGE_PROGAM_2ND		0x00000020
+
+#define NAND_IO_NORMAL_READ						0x00000001
+#define NAND_IO_CACHE_READ						0x00000002
+#define NAND_IO_TWO_PLANE_READ_1ST				0x00000010
+#define NAND_IO_TWO_PLANE_READ_2ND				0x00000020
+#define NAND_IO_TWO_PLANE_MID_PAGE				0x00000100
+#define NAND_IO_TWO_PLANE_LAST_PAGE				0x00000200
+
+
+#define NAND_IO_MAX_SUPPORT_DRIVER				2
+
+#define NAND_IO_SERIAL_COMBINATION_MODE			0x00
+#define NAND_IO_PARALLEL_COMBINATION_MODE		0x01
+
+#if defined(NAND_2CS_ONLY)
+#define NAND_IO_DRV0_START_CS					0
+#define NAND_IO_DRV0_END_CS						1
+#else
+#define NAND_IO_DRV0_START_CS					0
+#define NAND_IO_DRV0_END_CS						3
+#endif
+
+#define	ECC_OFF                     			0
+#define	ECC_ON                      			1
+#define SLC_ECC_TYPE							0x0001			// 10 Byte
+#define MLC_ECC_4BIT_TYPE						0x0002			// BCH: 7 Byte( 52 bit)	turn: 2, byte remain: 3, register mask: 0x0F
+#define MLC_ECC_8BIT_TYPE						0x0004			// BCH:13 Byte (104 bit)	turn: 4, byte remain: 1, register mask: 0xFF
+#define MLC_ECC_12BIT_TYPE						0x0010			// BCH:20 Byte (156 bit)	turn: 5, byte remain: 4, register mask: 0x0F
+#define MLC_ECC_14BIT_TYPE						0x0020			// BCH:23 Byte (184 bit)	turn: 6, byte remain: 3, register mask: 0xFF
+#define MLC_ECC_16BIT_TYPE						0x0040			// BCH:26 Byte (207 bit)turn: 7, byte remain: 2, register mask: 0x7F
+
+#define NAND_IO_SPARE_SIZE_BIG					16
+#define NAND_IO_SPARE_SIZE_SMALL				8
+
+
+#define PAGE_ECC_OFF							0
+#define PAGE_ECC_ON								1
+
+//----------------------------------------------------------------------
+// TNFTL R/W Area Spare Date
+//----------------------------------------------------------------------
+// Block Area & Type		1Byte :  0xFF
+// Block Parameter			2Byte
+// Logical Block Address	3Byte :  0x0 ~ 0xFFFFFE
+//----------------------------------------------------------------------
+// Spare Data Total 		6Byte
+//----------------------------------------------------------------------
+
+//----------------------------------------------------------------------
+// TNFTL R/O Area Spare Date
+//----------------------------------------------------------------------
+// Block Area & Type		1Byte :  0xFF
+// Rom Image Num			2Byte
+// Rom Image LBA			3Byte :  0x0 ~ 0xFFFFFE
+//----------------------------------------------------------------------
+// Spare Data Total 		6Byte
+//----------------------------------------------------------------------
+
+
+// 512 Page + 16 Spare : SLC / 4 Bit ECC
+typedef struct {
+	U8		SpareData0[4];		//  4 Bytes Spare data
+	U8		Temp;				//  1 Bytes Temp
+	U8		BadMark;			//  1 Bytes bad mark
+	U8		SpareData1[2];		//  2 Bytes Spare data
+	U8		PageECC[8];			//  8 Bytes Spare ECC --> 4Bit ECC
+} SLC_512Page_4BitECC_Spare;
+
+// 2048 Page + 64 Spare : 4 Bit ECC
+typedef struct {
+	U8		BadMark;			//  1 Bytes bad mark
+	U8		Temp;				//  1 Bytes Temp		--> Parallel Bad Mark reserved
+	U8 		SpareData[14];		// 14 bytes Spare data
+	U8		PageECC[4][8];		// 32 Bytes Spare ECC --> 4Bit ECC
+	U8		SpareECC[8];		//  8 Byte
+} MLC_2KPage_4BitECC_Spare;
+
+// 4096 Page + 128 Spare : 4 Bit ECC
+typedef struct {
+	U8		BadMark;			//  1 Bytes bad mark
+	U8		Temp;				//  1 Bytes Temp		--> Parallel Bad Mark reserved
+	U8 		SpareData[14];		// 14 bytes Spare data
+	U8		PageECC[8][8];		// 64 Bytes Spare ECC --> 4Bit ECC
+	U8		SpareECC[8];		//  8 Byte
+} MLC_4KPage_4BitECC_Spare;
+
+// 4096 Page + 218 Spare : 8/12 Bit ECC
+typedef struct {
+	U8		BadMark;			//  1 Bytes bad mark
+	U8		Temp;				//  1 Bytes Temp		--> Parallel Bad Mark reserved
+	U8 		SpareData[14];		// 14 bytes Spare data
+	U8		PageECC[8][20];		//160 Bytes Spare ECC --> 4Bit ECC
+	U8		SpareECC[20];		// 20 Byte
+} MLC_4KPage_8_12BitECC_Spare;
+
+// 8192 Page + 436 Spare : 16 Bit ECC
+typedef struct {
+	U8		BadMark;			//  1 Bytes bad mark
+	U8		Temp;				//  1 Bytes Temp
+	U8 		SpareData[10];		// 10 bytes Spare data
+	U8 		PageECC[16][26];	//416 Bytes Page ECC
+	U8		SpareECC[8];		//  8 Bytes Spare ECC --> 4 bit ECC
+} MLC_4KPage_16BitECC_Spare;
+
+
+#define TYPE_SPARE_FOR_512_16_NANDFLASH			0
+#define TYPE_SPARE_FOR_2048_64_NANDFLASH		1
+#define TYPE_SPARE_FOR_4096_128_NANDFLASH		2
+#define TYPE_SPARE_FOR_4096_218_NANDFLASH		3
+
+#ifdef ECC_TYPE_RS
+#define TYPE_ECC_FOR_1BIT_SLC_NANDFLASH			MLC_ECC_4BIT_TYPE
+#define TYPE_ECC_FOR_4BIT_MLC_NANDFLASH			MLC_ECC_4BIT_TYPE
+#define TYPE_ECC_FOR_8BIT_MLC_NANDFLASH			MLC_ECC_8BIT_TYPE
+#define ECC_SHIFT_DATASIZE						16
+#else
+#define TYPE_ECC_FOR_1BIT_SLC_NANDFLASH			MLC_ECC_4BIT_TYPE
+#define TYPE_ECC_FOR_4BIT_MLC_NANDFLASH			MLC_ECC_4BIT_TYPE
+#define TYPE_ECC_FOR_8BIT_MLC_NANDFLASH			MLC_ECC_12BIT_TYPE
+#define TYPE_ECC_FOR_12BIT_MLC_NANDFLASH		MLC_ECC_12BIT_TYPE
+#define TYPE_ECC_FOR_14BIT_MLC_NANDFLASH		MLC_ECC_14BIT_TYPE
+#define TYPE_ECC_FOR_16BIT_MLC_NANDFLASH		MLC_ECC_16BIT_TYPE
+#define ECC_SHIFT_DATASIZE						4
+#endif
+
+#define TNFTL_READ_SPARE_ON						0
+#define TNFTL_READ_SPARE_OFF					1
+
+#define NAND_MCU_ACCESS							0
+#define NAND_DMA_ACCESS							1
+
+#define NAND_NORMAL_BUFFER						0
+#define NAND_SERIAL_CHAIN_BUFFER				1
+
+
+#define ECC_DECODE								0
+#define ECC_ENCODE								1
+#define	INTER_LEAVE_OFF                			0
+#define	INTER_LEAVE_ON                			1
+#define MULTI_PLANE_MID_PAGE					0
+#define MULTI_PLANE_LAST_PAGE					1
+#define MULTI_PLANE_GOOD_BLOCK					0
+#define MULTI_PLANE_BAD_BLOCK					1
+
+#define NAND_IO_BSA_OK							0x0000
+#define NAND_IO_BSA_BAD_SERIAL					0x0001
+#define NAND_IO_BSA_BAD_BLOCK1_PARALLEL			0x0010
+#define NAND_IO_BSA_BAD_BLOCK2_PARALLEL			0x0100
+#define NAND_IO_BSA_FAIL_OTHER_REASON			0x1000
+
+#define NAND_IO_STATUS_FAIL_CS0_SERIAL			0x0001
+#define NAND_IO_STATUS_FAIL_CS0_PARALLEL		0x0010
+#define NAND_IO_STATUS_FAIL_CS1_PARALLEL		0x0100
+
+#define NAND_IO_LOG_COLUMN_IN_PAGE				0
+#define NAND_IO_LOG_COLUMN_IN_SPARE				1
+
+/* LBA NAND DEFINATION : [STATUS READ 2] */
+#define NAND_LBA_PNP							0x00
+#define NAND_LBA_BCM							0x02
+#define NAND_LBA_VFP							0x04
+#define NAND_LBA_MDP							0x06
+
+#define NAND_LBA_DATA_AREA						0x16
+#define NAND_LBA_HIDDEN_AREA					0x26
+#define NAND_LBA_MULTI_HIDDEN_AREA_0			0x36
+#define NAND_LBA_MULTI_HIDDEN_AREA_1			0x46
+#define NAND_LBA_MULTI_HIDDEN_AREA_2			0x56
+
+#define NAND_POWER_SAVE_ENABLE					0x01
+#define NAND_HIGH_SPEED_ENABLE					0x08
+
+#define NAND_ADDRESS_OUT_OF_RANGE_ERROR			0x10
+#define NAND_COMMAND_PARAMETER_ERROR			0x40
+
+/* LBA NAND Transfer Protocol 1 */
+#define NAND_PROT1_512x1						0x01
+#define NAND_PROT1_512x4						0x02
+#define NAND_PROT1_512x8						0x04
+
+#define NAND_PROT1_528x1						0x21
+#define NAND_PROT1_528x4						0x22
+#define NAND_PROT1_528x8						0x24
+
+#define NAND_PROT1_SPARE_INCLUDE				0x20
+#define NAND_PROT1_SECTOR_COUNT_MASK			0x07
+
+#define NAND_PROT1_NoCRC_NoECC					0x00
+#define NAND_PROT1_CRC							0x40
+#define NAND_PROT1_ECC_CHECK_ONLY				0x80
+#define NAND_PROT1_ECC_CORRECT					0xC0
+
+/* LBA NAND Transfer Protocol 2 */
+#define NAND_PROT2_READ_TYPE_A					0x00
+#define NAND_PROT2_READ_TYPE_B					0x02
+#define NAND_PROT2_READ_TYPE_C					0x03
+
+#define NAND_PROT2_WRITE_TYPE_A					0x00
+#define NAND_PROT2_WRITE_TYPE_B					0x04
+
+#define NAND_LBA_MAX_SUPPORT_MHD_AREA_NUM		10
+
+typedef void (*NAND_LBA_CALLBACK_HANDLER) ( U16 nDrvNo, U16 nStatusCode, U32 wParam );
+#define NAND_LBA_CALLBACK_LCD_FORMAT_PROCESS	0x04
+
+
+/* HardWare relevant variables */
+
+#define NAND_IO_NFC_BUS							0
+#define NAND_IO_MEM_BUS							1
+
+#define NAND_IO_DATA_WITDH_8BIT					0
+#define NAND_IO_DATA_WITDH_16BIT				1
+
+
+
+#if defined(_LINUX_) || defined(_WINCE_)
+#if defined(TCC89XX) || defined(TCC92XX)
+#define	NAND_IO_HwCMD_PA							*(volatile unsigned long*)0xF05B0000		//( gNAND_IO_pHwND->CMD )
+#define	NAND_IO_HwLADR_PA							*(volatile unsigned long*)0xF05B0004		//( gNAND_IO_pHwND->LADR )
+#define	NAND_IO_HwDATA_PA							*(volatile unsigned long*)0xF05B0010		//( gNAND_IO_pHwND->WDATA.D32 )
+#define	NAND_IO_HwLDATA_PA							*(volatile unsigned long*)0xF05B0020		//( gNAND_IO_pHwND->LDATA )
+#define	NAND_IO_HwSDATA_PA							*(volatile unsigned long*)0xF05B0040		//(/*( gNAND_IO_DataBusType == NAND_IO_MEM_BUS ) ? gNAND_IO_pHwND->WDATA.D8 : */gNAND_IO_pHwND->SDATA.D32 )
+#define	NAND_IO_HwSADR_PA							*(volatile unsigned long*)0xF05B000C		//( gNAND_IO_pHwND->SADR )
+#endif
+#endif
+
+#if defined(TCC92XX)
+#define	NAND_IO_NFC_nWP							HwGPIOB->GPDAT
+#define	NAND_IO_NFC_nWPBit						Hw22
+#elif defined(TCC89XX)
+#define	NAND_IO_NFC_nWP							HwGPIOB->GPDAT
+#define	NAND_IO_NFC_nWPBit						Hw31
+#endif
+#define NAND_IO_STATUS_ENABLE					0x0001
+#define NAND_IO_STATUS_INTERLEAVING_MASK		0x00F0
+#define NAND_IO_STATUS_INTERLEAVING_CHIP1		0x0010
+#define NAND_IO_STATUS_INTERLEAVING_CHIP2		0x0020
+#define NAND_IO_STATUS_INTERLEAVING_CHIP3		0x0040
+#define NAND_IO_STATUS_INTERLEAVING_CHIP4		0x0080
+
+#define NAND_IO_DISTRICT_0						0x0001
+#define NAND_IO_DISTRICT_1						0x0002
+
+#define NAND_IO_DMA_WRITE						0x0001
+#define NAND_IO_DMA_READ						0x0002
+
+#define NAND_SB_BOOT_PAGE_SIZE					260
+#define NAND_SB_BOOT_PAGE_ECC_SIZE				288
+
+//*****************************************************************************
+//*
+//*
+//*                       [ INTERNAL STRUCT DEFINE ]
+//*
+//*
+//*****************************************************************************
+#define GMC_NAND_NOMAL_BOOT_TYPE				0x54435342		// TCSB
+#define GMC_NAND_SECURE_BOOT_TYPE				0x54435353		// TCSS
+
+typedef struct	__tag_NAND_GOLDEN_INFO
+{
+	U32	Signature;
+	U16	PageSize;
+	U16	SpareSize;
+	U16	Ppage;
+	U16	PpB;
+	U32 PpBforAddress;	
+	U16 EccType;
+	U16 EccDataSize;
+	U32	TargetAddress;	// Working Address
+	U32	BootLoaderSize;
+	U32 LastBlockPpB;
+	U16	RomCopyNum;
+	U16	RomBlockNum;
+	U32	RomCRC;
+	U32	BlockUppuerLimit;
+	U32	BlockLowerLimit;
+//---------------------------------- 44Byte
+	U32	GoldenInfoCRC;
+	U32 SecureData[4];
+} 	NAND_GOLDEN_INFO;
+
+typedef struct	__tag_NAND_BOOTLOADER_INFO
+{
+	U16 BL_ColCycle;
+	U16 BL_RowCycle;
+	U32 BL_ReadCycle;
+	U32 BL_MediaType;
+	U32 BL_SpareDataSize;
+	U32 BL_TargetAddress;	// Working Address
+	U32	BL_MemInitCodeSize;
+	U32	BL_MemInitCodePpB;
+	U32	BL_RomFileSize;
+	U16	BL_RomCopyNum;
+	U16	BL_RomBlockNum;
+	U32	BL_BlockUppuerLimit;
+	U32	BL_BlockLowerLimit;
+	U32 BL_LastBlockPpB;
+	U32	BL_RomFileCRC;
+} 	NAND_BOOTLOADER_INFO;
+
+typedef struct __tag_NAND_IO_ECCSizeInfo
+{
+	unsigned int				EncodeFlag;
+	unsigned int				DecodeFlag;
+	unsigned int				ErrorNum;
+	unsigned char				EccDataSize;
+	unsigned char				*All_FF_512_ECC_Code;
+} NAND_IO_ECC_INFO;
+
+typedef struct __tag_NAND_IO_WriteStatus
+{
+	unsigned char				ChipNo;
+	unsigned char				BlockStatus;
+	unsigned int				ErrorPHYPageAddr;
+} NAND_IO_WRITESTATUS;
+
+typedef struct __tag_NAND_IO_BadBlockAddr
+{
+	unsigned char				BlockStatus[4];
+	unsigned int				BadBlkPHYAddr[4];
+} NAND_IO_BADBLOCK;
+
+typedef struct __tag_NAND_IO_Cycle
+{
+	unsigned char				STP;
+	unsigned char				PW;
+	unsigned char				HLD;
+	unsigned int				RegValue;
+} NAND_IO_CYCLE;
+
+typedef struct __tag_NAND_IO_DeviceCode
+{
+	unsigned short int			Code[6];			// Factory ID code
+} NAND_IO_DEVID;
+
+typedef struct __tag_NAND_IO_LBADevInfo
+{
+	unsigned char				Usable;
+	
+	unsigned char				CurrentMode;
+	unsigned long int			CurrentSectorSize;
+	
+	unsigned char				HighSpeedMode;
+	unsigned char				PowerSaveMode;
+	unsigned char				TransProtocol1;
+	unsigned char				TransProtocol2;
+	unsigned char				SectorCount;
+	unsigned char 				DataTransferCheck;
+	unsigned char 				FlagOfChangeTotalSectorSize;
+
+	unsigned long int			VFPSectorSize;		// NBArea
+	
+	unsigned long int			MDPSectorSize;		// RWArea Totla Sector Size
+	unsigned long int			DTAreaSectorSize;	// RWArea
+	unsigned long int			HDAreaSectorSize;	// RWArea
+	unsigned long int			HDAreaAddrOffSet;
+
+	unsigned long int 			MHDAreaNums;	// Multi Hidden Area Num
+	unsigned long int			MHDAreaSectorSize[NAND_LBA_MAX_SUPPORT_MHD_AREA_NUM];
+	unsigned long int			MHDAreaAddrOffSet[NAND_LBA_MAX_SUPPORT_MHD_AREA_NUM];
+	
+} NAND_IO_LBADEVINFO;
+
+typedef struct __tag_NAND_IO_Feature
+{
+	NAND_IO_DEVID				DeviceID;			// Maker & Device ID Code
+	unsigned short int  		PBpV;				// Physical all Block Number
+	unsigned short int			BBpZ;				// Total Bad Block in one ZONE
+	unsigned short int  		PpB;				// Page Number Per Block
+	unsigned short int  		PageSize;			// Page Size
+	unsigned short int  		SpareSize;			// Spare Size
+	unsigned short int			ColCycle;			// Column Address Cycle
+	unsigned short int			RowCycle;			// Row Address Cycle
+	unsigned short int			WCtime;				// Write Cyclte time
+	unsigned short int			WriteSTP;
+	unsigned short int			WriteWP;
+	unsigned short int			WriteHLD;
+	unsigned short int			ReadSTP;
+	unsigned short int			ReadPW;
+	unsigned short int			ReadHLD;
+	unsigned long int			MediaType;			// Chracters of NANDFLASH
+} NAND_IO_FEATURE;
+
+typedef struct __tag_NAND_IO_DevInfo
+{
+	NAND_IO_FEATURE				Feature;			// Feature of NANDFLASH
+	unsigned short int			IoStatus;			// IO Status
+	unsigned short int			ChipNo;				// ChipSelect Number
+	unsigned short int			CmdMask;			// Command Mask Bit
+	unsigned short int			EccType;			// Type of ECC [ SLC , MLC4 ]
+	unsigned short int			EccDataSize;
+	unsigned short int			EccWholeDataSize;
+
+	unsigned short int			PPages;				// Total Partial Page [512+16Bytes]
+
+	unsigned short int			DistrictNum;
+	unsigned short int			ShiftDistrictNum;
+
+	unsigned short int			ExtInterleaveUsable;
+
+	unsigned short int			ShiftPBpV;
+	unsigned short int			ShiftPpB;
+	unsigned short int			ShiftPageSize;
+	unsigned short int			ShiftPPages;
+	
+	unsigned short int			PageUniteMode;
+	unsigned short int			RemapPpB;			// Physical Page Number Per FTL 1Block
+	unsigned short int			RemapPageOffset;	// Next FTL Block Page Offset
+	unsigned short int			RemapRatioBSize;	// Physical Block Number Per FTL 1Block
+	unsigned long int			RemapRatioPSize;	// Physical Block Number Per FTL 1Block
+	
+	unsigned short int			ShiftRemapPpB;
+	unsigned short int			ShiftRemapPageOffset;
+	unsigned short int			ShiftRemapRatioBSize;
+	unsigned short int			ShiftRemapRatioPSize;
+
+	unsigned long int			RemapPageWeight[4];
+
+	NAND_IO_WRITESTATUS			WriteStatus;
+		
+	NAND_IO_BADBLOCK			BadBlockInfo;
+	NAND_IO_LBADEVINFO			LBAInfo;
+} NAND_IO_DEVINFO;
+
+typedef struct __tag_NAND_IO_MakerInfo
+{
+	unsigned short int			MaxSupportNAND[MAX_SUPPORT_MAKER_NAND];
+	unsigned short int			MakerID[MAX_SUPPORT_MAKER_NAND];
+	NAND_IO_FEATURE*			DevInfo[MAX_SUPPORT_MAKER_NAND];
+} NAND_IO_MAKERINFO;
+
+
+typedef struct __tag_NAND_IO_LBAMakerInfo
+{
+	unsigned short int			MaxSupportNAND[MAX_SUPPORT_MAKER_LBA_NAND];
+	unsigned short int			MakerID[MAX_SUPPORT_MAKER_LBA_NAND];
+	NAND_IO_FEATURE*			DevInfo[MAX_SUPPORT_MAKER_LBA_NAND];
+} NAND_IO_LBA_MAKERINFO;
+
+//*****************************************************************************
+//*
+//*
+//*                       [ EXTERNAL VARIABLE DEFINE ]
+//*
+//*
+//*****************************************************************************
+extern const NAND_IO_MAKERINFO		NAND_SupportMakerInfo;
+extern const NAND_IO_LBA_MAKERINFO	LBA_NAND_SupportMakerInfo;
+
+extern const NAND_IO_FEATURE		SAMSUNG_NAND_DevInfo[MAX_SUPPORT_SAMSUNG_NAND];
+extern const NAND_IO_FEATURE		TOSHIBA_NAND_DevInfo[MAX_SUPPORT_TOSHIBA_NAND];
+extern const NAND_IO_FEATURE		HYNIX_NAND_DevInfo[MAX_SUPPORT_HYNIX_NAND];
+extern const NAND_IO_FEATURE		ST_NAND_DevInfo[MAX_SUPPORT_ST_NAND];
+extern const NAND_IO_FEATURE		MICRON_NAND_DevInfo[MAX_SUPPORT_MICRON_NAND];
+
+extern const NAND_IO_FEATURE		TOSHIBA_LBA_NAND_DevInfo[MAX_SUPPORT_TOSHIBA_LBA_NAND];
+
+//*****************************************************************************
+//*
+//*
+//*                       [ EXTERNAL FUCTIONS DEFINE ]
+//*
+//*
+//*****************************************************************************
+extern NAND_IO_ERROR		NAND_IO_CallBackChangeWCtime( unsigned short int TotalMediaNum, NAND_IO_DEVINFO *nDevInfo );
+extern NAND_IO_ERROR		NAND_IO_SetCycle( NAND_IO_DEVINFO *nDevInfo );
+extern NAND_IO_ERROR		NAND_IO_GetDeviceInfo( U16 nChipNo, NAND_IO_DEVINFO *nDevInfo );
+extern U32					NAND_IO_GetBUSTypeOfDataIO( void );
+extern void					NAND_IO_Init( void );
+extern void					NAND_IO_Reset( U16 nChipNo, int nMode );
+extern void					NAND_IO_ResetForReadID( U16 nChipNo, int nMode );
+extern void					NAND_IO_ReadID( U16 nChipNo, NAND_IO_DEVID *nDeviceCode, int nMode );
+
+extern NAND_IO_ERROR		NAND_IO_ReadSpare( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U8 *nSpareBuffer );
+extern NAND_IO_ERROR		NAND_IO_ReadPage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U16 nStartPPage, U16 nReadPPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+extern NAND_IO_ERROR		NAND_IO_ReadPageMTD(NAND_IO_DEVINFO * nDevInfo, U32 nPageAddr, U16 nStartPPage, U16 nReadPPSize, U8 * nPageBuffer, U8 * nSpareBuffer, int nEccOnOff);
+extern NAND_IO_ERROR		NAND_IO_ReadTwoPlanePage(NAND_IO_DEVINFO * nDevInfo, U32 nPageAddr, U32 nSecondPageAddr, U16 nStartPPage, U16 nReadPPSize, U8 * nPageBuffer, U8 * nSpareBuffer, int nEccOnOff);
+extern NAND_IO_ERROR		NAND_IO_ReadTwoPlaneLastPage(NAND_IO_DEVINFO * nDevInfo, U32 nPageAddr, U16 nStartPPage, U16 nReadPPSize, U8 * nPageBuffer, U8 * nSpareBuffer, int nEccOnOff);
+extern NAND_IO_ERROR		NAND_IO_ReadUserSizePage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U16 nColumnAddr, U32 nReadSize, U8 *nReadBuffer );
+
+extern NAND_IO_ERROR 		NAND_IO_WriteSpare( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U8* nSpareBuffer, int nEccOnOff );
+extern NAND_IO_ERROR		NAND_IO_WritePage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U16 nStartPPage, U16 nWritePPSize, U8 *nPageBuffer, U8* nSpareBuffer, int nEccOnOff );
+extern NAND_IO_ERROR		NAND_IO_WritePageMTD(NAND_IO_DEVINFO * nDevInfo, U32 nPageAddr, U16 nStartPPage, U16 nWritePPSize, U8 * nPageBuffer, U8 * nSpareBuffer, int nEccOnOff);
+extern NAND_IO_ERROR		NAND_IO_WriteCachePage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U16 nStartPPage, U16 nWritePPSize, U8 *nPageBuffer, U8* nSpareBuffer, int nEccOnOff );
+extern NAND_IO_ERROR		NAND_IO_WriteTwoPlanePage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U16 nStartPPage, U16 nWritePPSize, U8 *nPageBuffer, U8* nSpareBuffer, int nEccOnOff );
+extern NAND_IO_ERROR		NAND_IO_WriteTwoPlaneLastPage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U16 nStartPPage, U16 nWritePPSize, U8 *nPageBuffer, U8* nSpareBuffer, int LastPage, int nEccOnOff );
+extern NAND_IO_ERROR		NAND_IO_WriteUserSizePage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U16 nColumnAddr, U32 nWriteSize, U8 *nWriteBuffer );
+extern NAND_IO_ERROR 		NAND_IO_MakeBootBinary( NAND_IO_DEVINFO *nDevInfo, U8 *nPageBuffer );
+
+extern NAND_IO_ERROR		NAND_IO_CopyBackPage( NAND_IO_DEVINFO *nDevInfo, U32 nDesPageAddr, U32 nSrcPageAddr );
+extern NAND_IO_ERROR		NAND_IO_CopyBackTwoPlanePage( NAND_IO_DEVINFO *nDevInfo, U32 nDesPageAddr, U32 nSrcPageAddr );
+
+extern NAND_IO_ERROR		NAND_IO_EraseBlock( NAND_IO_DEVINFO *nDevInfo, U32 nBlockPageAddr, int nFormatMode );
+extern NAND_IO_ERROR		NAND_IO_EraseBlockForTwoPlane( NAND_IO_DEVINFO *nDevInfo, U32 nBlockPageAddr, int nFormatMode );
+
+extern NAND_IO_ERROR		NAND_IO_GetFactoryBadMarkOfPBlock( NAND_IO_DEVINFO *nDevInfo, U32 nBlockPageAddr );
+extern NAND_IO_ERROR		NAND_IO_GetUID( NAND_IO_DEVINFO *nDevInfo, U16 *nCmd, U8 *rReadData );
+extern NAND_IO_ERROR		NAND_IO_WaitBusyCheckForWriteEnd( NAND_IO_DEVINFO *nDevInfo );
+
+#if defined (NAND_LBA_INCLUDE)
+extern NAND_IO_ERROR 		NAND_IO_LBA_SetCallBackHandler( NAND_LBA_CALLBACK_HANDLER pCallBackHandler );
+extern U32  			    NAND_IO_LBA_GetSerialNumber( NAND_IO_DEVINFO *nDevInfo, U8* nPageBuffer, U8* rSerialNumber, U16 nSize );
+extern NAND_IO_ERROR		NAND_IO_LBA_PowerSaveMode( NAND_IO_DEVINFO *nDevInfo, int nOnOff );
+extern NAND_IO_ERROR 		NAND_IO_LBA_DeviceReboot( NAND_IO_DEVINFO *nDevInfo );
+
+extern NAND_IO_ERROR 		NAND_IO_LBA_GetDeviceInfo( NAND_IO_DEVINFO *nDevInfo );
+extern NAND_IO_ERROR 		NAND_IO_LBA_Init( NAND_IO_DEVINFO *nDevInfo );
+extern NAND_IO_ERROR 		NAND_IO_LBA_ReadSectorBy4Byte( NAND_IO_DEVINFO *nDevInfo, U8 nPartition, U32 nSectorAddr, U16 nOffset, U16 nReadSize, U8 *nReadBuffer );
+extern NAND_IO_ERROR 		NAND_IO_LBA_ReadSector( NAND_IO_DEVINFO *nDevInfo, U8 nPartition, U32 nSectorAddr, U16 nSecSize, U8 *nReadBuffer );
+extern NAND_IO_ERROR 		NAND_IO_LBA_WriteSector( NAND_IO_DEVINFO *nDevInfo,U8 nPartition, U32 nSectorAddr, U16 nSecSize, U8 *nWriteBuffer );
+extern NAND_IO_ERROR 		NAND_IO_LBA_AREAClear( NAND_IO_DEVINFO *nDevInfo, U8 nPartition );
+extern NAND_IO_ERROR 		NAND_IO_LBA_ModeChange( NAND_IO_DEVINFO *nDevInfo, int nMode );
+extern NAND_IO_ERROR 		NAND_IO_LBA_ScanHeaderOfVFP( NAND_IO_DEVINFO *nDevInfo );
+extern NAND_IO_ERROR 		NAND_IO_LBA_MakeHeaderOfVFP( NAND_IO_DEVINFO *nDevInfo );
+extern NAND_IO_ERROR 		NAND_IO_LBA_Read2Status( NAND_IO_DEVINFO *nDevInfo );
+extern NAND_IO_ERROR 		NAND_IO_LBA_GetTotalSecAndCHS( NAND_IO_DEVINFO *nDevInfo, int nPartition, U32 *rTotalSec, U16 *rCylinder, U16 *rHead, U8 *rSector );
+extern NAND_IO_ERROR 		NAND_IO_LBA_CacheFlush( NAND_IO_DEVINFO *nDevInfo );
+#endif	//NAND_LBA_INCLUDE
+
+#endif
+
diff --git a/drivers/block/tcc/inc/tnftl/tnftl_v6.h b/drivers/block/tcc/inc/tnftl/tnftl_v6.h
new file mode 100644
index 0000000..930bdc8
--- /dev/null
+++ b/drivers/block/tcc/inc/tnftl/tnftl_v6.h
@@ -0,0 +1,614 @@
+/**************************************************************************************
+ *
+ * TELECHIPS Co.
+ * 
+ * 6th floor Corad Bldg 1000-12 Daechi-dong, KangNam-ku, Seoul, Korea
+ * ====================================================================================
+ *
+ * Name:        Hyun-Chul Hong
+ * Phone:       82-2-3443-6792
+ * E-mail:      hchong@telechips.com
+ *
+ * FILE NAME:   TNFTL.H
+ *
+ * DESCRIPTION:
+ *       This is a Header File for TNFTL [ Telechips Nand Flash Translation Layer ]
+ *
+ *
+ * FILE HISTORY:
+ * 	Date: 2005.04.19	Start source coding		By Hyunchul Hong
+ *
+ **************************************************************************************/
+#ifndef __TNFTL_H
+#define __TNFTL_H
+
+#if defined(_LINUX_)
+#include <tnftl/nand_io_v6.h>
+#elif defined(_WINCE_)
+#include "nand_io_v6.h"
+#else
+#include "nand_io_v6.h"
+#endif
+#if defined(TCC92XX) || defined(TCC89XX)
+#define TNFTL_V6_INCLUDE
+#elif defined(TCC82XX)||defined(TCC83XX)||defined(TCC79X) || defined(TCC81XX) || defined(TCC80XX)
+#define TNFTL_V5_INCLUDE
+#else
+#define TNFTL_V4_INCLUDE
+#endif
+
+//*****************************************************************************
+//*
+//*
+//*                       [ General DEFINE & TYPEDEF ]
+//*
+//*
+//*****************************************************************************
+#ifndef NOT_USED
+#define NOT_USED				0
+#endif
+#ifndef USED
+#define	USED					1
+#endif
+#ifndef DISABLE
+#define DISABLE					0
+#endif
+#ifndef ENABLE
+#define	ENABLE					1
+#endif
+#ifndef FALSE
+#define FALSE           		0
+#endif
+#ifndef TRUE
+#define TRUE            		1
+#endif
+#ifndef NULL
+#define NULL					0
+#endif
+#ifndef TNFTL_U16_NULL
+#define TNFTL_U16_NULL			0xFFFF
+#endif
+#ifndef TNFTL_U32_NULL
+#define TNFTL_U32_NULL			0xFFFFFFFF
+#endif
+
+#ifndef _U8_
+#define _U8_
+typedef unsigned char			U8;
+#endif
+#ifndef _U16_
+#define _U16_
+typedef unsigned short int		U16;
+#endif
+#ifndef _U32_
+#define _U32_
+typedef unsigned int			U32;
+#endif
+#ifndef _BOOL_
+#define _BOOL_
+typedef unsigned int			BOOL;
+#endif
+
+//*****************************************************************************
+//*
+//*
+//*                         [ ERROR CODE ENUMERATION ]
+//*
+//*
+//*****************************************************************************
+#ifndef SUCCESS
+#define SUCCESS		0
+#endif
+
+typedef enum
+{
+	ERR_TNFTL_NO_EXIST_NAND_FLASH = 0xA200000,
+	ERR_TNFTL_NO_BMP,
+	ERR_TNFTL_NOT_READY_IO,
+	ERR_TNFTL_NOT_READY_AREA,
+	ERR_TNFTL_NOT_EXIST_NANDFLASH,
+	ERR_TNFTL_NOT_EXIST_MEDIA_NUM_INFO,
+	ERR_TNFTL_NOT_HAVE_ENOUGH_ZONE_BLOCK,
+	ERR_TNFTL_NOT_EXIST_HIDDEN_HEADBLOCK,
+	ERR_TNFTL_NOT_EXIST_NANDBOOT_AREA,	
+	ERR_TNFTL_NOT_HIDDEN_WRITE_CACHE_BLOCK,
+	ERR_TNFTL_NOT_EXIST_DATA_IN_WRITE_CACHE_PAGE_BLOCK,
+	ERR_TNFTL_NOT_FRESH_NANDFLASH,
+	ERR_TNFTL_NOT_EXIST_FTL_BAD_BLOCK_INFO,
+	ERR_TNFTL_FAILED_CHECK_BMP,
+	ERR_TNFTL_FAILED_GET_REAL_PAGE_ADDR,
+	ERR_TNFTL_FAILED_ALLOCATE_MEM_AND_LINK_DRIVER,
+	ERR_TNFTL_FAILED_GOLDEN_PAGE,
+	ERR_TNFTL_FAILED_GET_SHIFT_FACTOR_FOR_MULTIPLY,
+	ERR_TNFTL_FAILED_GET_EMPTY_RAW_BLOCK,
+	ERR_TNFTL_FAILED_MAKE_BMP,
+	ERR_TNFTL_FAILED_GET_MEDIA_UID,
+	ERR_TNFTL_FAILED_GET_MEDIA_SID,
+	ERR_TNFTL_FAILED_GET_PBLOCK_STATUS_ON_BMP,
+	ERR_TNFTL_FAILED_GET_NANDBOOT_AREA,
+	ERR_TNFTL_FAILED_MAKE_HIDDEN_LBT_BLOCK,
+	ERR_TNFTL_FAILED_GET_EMPTY_HIDDEN_BLOCK,
+	ERR_TNFTL_FAILED_MAKE_HIDDEN_AREA,
+	ERR_TNFTL_FAILED_GET_FTL_PAGE_ADDRESS_OF_SECTOR_ADDRESS,
+	ERR_TNFTL_FAILED_GET_HIDDEN_WRITE_CACHE_NUMBER,
+	ERR_TNFTL_FAILED_GET_HIDDEN_WRITE_MAINPB_INFO,
+	ERR_TNFTL_FAILED_GET_EMPTY_FTL_BLOCK_FOR_WRITE_CACHE,
+	ERR_TNFTL_FAILED_GET_EMPTY_FTL_BLOCK,
+	ERR_TNFTL_FAILED_GET_EMPTY_PHYSICAL_BLOCK,
+	ERR_TNFTL_FAILED_GET_LPTSCAN_BUFFER,
+	ERR_TNFTL_TRY_ERASE_0TH_BLOCK,
+	ERR_TNFTL_OVERSIZE_ZONES,
+	ERR_TNFTL_WRONG_PARAMETER,
+	ERR_TNFTL_WCACHE_FORCE_FLUSH,
+	ERR_TNFTL_PBLOCK_IS_BAD_BLOCK,
+	ERR_TNFTL_LPT_CORRUPTED_SEG_NO,
+	ERR_TNFTL_CORRUPTED_HIDDEN_AREA,
+	ERR_TNFTL_SET_OVER_HIDDEN_PAGE_SIZE,
+	ERR_TNFTL_OVERSIZE_MULTIHIDDEN_NUM,
+	ERR_TNFTL_HAVE_MANY_BAD_BLOCKS_IN_ZONE,
+	ERR_TNFTL_MEDIA_HAVE_OVERSIZE_BAD_BLOCKS,
+	ERR_TNFTL_IMPOSSIBLE_TO_SET_SIZE_OF_DATA_AREA,
+	ERR_TNFTL_NANDBOOT_AREA_OVER_SIZE,
+	ERR_TNFTL_HIDDEN_AREA_OVER_SIZE,
+	ERR_TNFTL_DEBUG_WRONG_PARAMETER,
+	ERR_TNFTL_DEBUG_WRONG_COMMAND_PARAMETERS,
+	ERR_TNFTL_DEBUG_WRONG_RECEIVED_SECTOR_DATA,
+	ERR_TNFTL_DEBUG_WRONG_SEND_SECTOR_DATA,
+	ERR_TNFTL_WRONG_CRC_CODE_NANDBOOT_ROMFILE,
+	ERR_TNFTL_WRONG_MATCH_UID_NBAREA,
+	ERR_TNFTL_OVERSIZE_PPAGE_NUM,
+	ERR_TNFTL_OVERSIZE_MTD_AREA_SIZE
+} TNFTL_ERROR;
+
+//*****************************************************************************
+//*
+//*
+//*                          [ INTERNAL DEFINATION ]
+//*
+//*
+//*****************************************************************************
+#define TNFTL_MAX_SUPPORT_DRIVER								2
+#define TNFTL_MAX_SUPPORT_MULTI_NANDFLASH						4
+#define TNFTL_MAX_SUPPORT_NAND_IO_PAGE_SIZE						16384		// 4096*2(Parallel)*2(MultiPlane)
+#define TNFTL_MAX_SUPPORT_NAND_IO_SPARE_SIZE					512			// 128*4
+#define TNFTL_MAX_SUPPORT_NAND_IO_SECTOR_SIZE_PER_1PAGE			32			// 16384 / 512
+#define TNFTL_MAX_SUPPORT_NAND_IO_PAGE_SIZE_PER_1BLOCK			512			// PpB * 2 (Multi-Plane) * 2 (InterLeave)
+#define TNFTL_MAX_SUPPORT_MULTI_PLANE							4
+#define TNFTL_MAX_SUPPORT_SHIFT_MULTI_PLANE						2
+#define TNFTL_MAX_SUPPORT_BAD_BLOCKS_IN_1ZONE					20
+#define TNFTL_MAX_SUPPORT_NB_AND_HD_AREA_BLOCK_SIZE				900			// 900 Blocks
+#define TNFTL_MAX_VALID_BAD_BLOCK_PER_1ZONE						40			
+#define TNFTL_MAX_SUPPORT_ZONE									32
+#define TNFTL_MAX_SUPPORT_NAND_PPAGE_NUM						32
+
+#define TNFTL_PLANE_0											0
+#define TNFTL_PLANE_1											1
+#define TNFTL_PLANE_2											2
+#define TNFTL_PLANE_3											3
+
+#define TNFTL_PHY_BLOCKS_1ZONE									1024
+#define TNFTL_PHY_BLOCKS_1ZONE_SHIFT							10			// 2^10 = 1024
+
+#define TNFTL_BMP_HEADER_SIZE									8			// 8Bytes
+#define TNFTL_BMP_FLAGS_IN_1BYTE								4			// Flag Size is 2Bit
+#define TNFTL_BMP_FLAGS_IN_1BYTE_SHIFT							2			// Shift Factor
+#define	TNFTL_BMP_START_PAGE									2
+#define TNFTL_BMP_BAD_BLOCK_CACHE_SIZE							64			// 64*2 = 128Bytes
+#define TNFTL_BMP_STATUS_OK										0x0000
+#define TNFTL_BMP_STATUS_FAIL_NO_BMP1_SERIAL					0x0001
+#define TNFTL_BMP_STATUS_FAIL_NO_BMP1_PARALLEL					0x0010
+#define TNFTL_BMP_STATUS_FAIL_NO_BMP2_PARALLEL					0x0100
+#define TNFTL_BMP_STATUS_FAIL_OTHER_REASON						0x1000
+
+#define TNFTL_BSA_SCAN_BY_FACTORY_MARK							0
+#define TNFTL_BSA_SCAN_BY_CHECK_PATTERN							1
+#define TNFTL_BSA_GET_BY_BMP									0
+#define TNFTL_BSA_GET_BY_CHECK									1
+#define TNFTL_BSA_GET_BY_SPARE									2
+#define TNFTL_BSA_GET_BY_FTLBBINFO								3
+
+#define TNFTL_LPT_NOT_CHANGED									0x00
+#define TNFTL_LPT_CHANGED										0x01
+#define TNFTL_LPT_TABLE_VALUES_1PAGE							128
+#define TNFTL_LPT_TABLE_VALUES_1PAGE_SHIFT						7
+#define TNFTL_LPT_TABLE_PAGES_1BLOCK							8
+#define TNFTL_LPT_TABLE_PAGES_1BLOCK_SHIFT						3
+#define TNFTL_LPT_TABLE_VALUES_1BLOCK							1024
+#define TNFTL_LPT_TABLE_VALUES_1BLOCK_SHIFT						10
+#define TNFTL_LPT_TABLE_DATA_START_PAGE							1
+
+#define TNFTL_MAX_SERIAL_NUMBER_SIZE							32
+#define TNFTL_MAX_NANDFLASH_SID_SIZE							32
+#define TNFTL_MAX_NANDFLASH_UID_SIZE							16
+
+#define TNFTL_HIDDEN_DEFAULT_TOTAL_SECTOR_SIZE					6083
+#define TNFTL_HIDDEN_DEFAULT_SPARE_BLOCK_SIZE					8
+#define TNFTL_HIDDEN_BLOCK_SIZE_FOR_SYSTEM_BLOCK				3			// HEAD 1 + LBT BLOCK 2
+
+#define TNFTL_MAX_SUPPORT_MULTI_HIDDEN_AREA_NUM					10
+
+#define TNFTL_BAA_INVALID_BLOCK_MARK1							0xFF
+#define TNFTL_BAA_INVALID_BLOCK_MARK2							0xEE
+#define TNFTL_BAA_INVALID_ADDRESS								0xFFFFFE
+#define TNFTL_INVALID_LOG_ADDRESS								0xFFFFFFEE
+
+#define TNFTL_BLOCK_AREA_MASK									0xF0
+#define TNFTL_BLOCK_AREA_DATA_AREA								0x10
+#define TNFTL_BLOCK_AREA_HIDDEN_AREA							0x20
+#define TNFTL_BLOCK_AREA_MULTI_HIDDEN_AREA0						0x30
+#define TNFTL_BLOCK_AREA_MULTI_HIDDEN_AREA1						0x40
+#define TNFTL_BLOCK_AREA_MULTI_HIDDEN_AREA2						0x50
+#define TNFTL_BLOCK_AREA_MULTI_HIDDEN_AREA3						0x60
+#define TNFTL_BLOCK_AREA_MULTI_HIDDEN_AREA4						0x70
+#define TNFTL_BLOCK_AREA_MULTI_HIDDEN_AREA5						0x80
+#define TNFTL_BLOCK_AREA_MULTI_HIDDEN_AREA6						0x90
+#define TNFTL_BLOCK_AREA_MULTI_HIDDEN_AREA7						0xA0
+#define TNFTL_BLOCK_AREA_MULTI_HIDDEN_AREA8						0xB0
+#define TNFTL_BLOCK_AREA_MULTI_HIDDEN_AREA9						0xC0
+#define TNFTL_BLOCK_AREA_NANDBOOT_AREA							0xE0
+
+#define TNFTL_BLOCK_TYPE_MASK									0x0F
+#define TNFTL_BLOCK_TYPE_HEADER									0x01
+#define TNFTL_BLOCK_TYPE_LBT									0x02
+#define TNFTL_BLOCK_TYPE_DATA									0x03
+#define TNFTL_BLOCK_TYPE_WRITE_CACHE_PAGE						0x05
+#define TNFTL_BLOCK_TYPE_WRITE_CACHE_PAGE_2						0x06
+#define TNFTL_BLOCK_TYPE_WRITE_CACHE_SUB						0x07
+
+#define TNFTL_BLOCK_TYPE_WRITE_CACHE_PAGE_SERIAL				0x08
+#define TNFTL_BLOCK_TYPE_WRITE_CACHE_PAGE_2_SERIAL				0x09
+
+#define TNFTL_WRITE_CACHE_PAGE_OFFSET							0x01
+
+#define TNFTL_READ_SECTOR_FROM_NULL_BLOCK						0x00
+#define TNFTL_READ_SECTOR_FROM_MAIN_BLOCK						0x01
+#define TNFTL_READ_SECTOR_FROM_WCACHE_SUB_BLOCK					0x02
+#define TNFTL_READ_SECTOR_FROM_WCACHE_PAGE_BLOCK				0x03
+#define TNFTL_WRITE_SECTOR_TO_MAIN_BLOCK						0x04
+#define TNFTL_WRITE_SECTOR_TO_WCACHE_SUB_BLOCK					0x05
+#define TNFTL_WRITE_SECTOR_TO_WCACHE_PAGE_BLOCK					0x06
+
+#define TNFTL_FORMAT_AREA_QUICK_LEVEL							0x00
+#define TNFTL_FORMAT_AREA_LOW_LEVEL								0x01
+#define TNFTL_FORMAT_RWAREA_QUICK_LEVEL							0x02
+#define TNFTL_FORMAT_INTERNAL_QUICK_LEVEL						0x03
+
+typedef void (*TNFTL_CALLBACK_HANDLER) ( U16 nDrvNo, U16 nStatusCode, U32 wParam );
+#define TNFTL_CALLBACK_LCD_MAKE_HIDDEN_PAGE_START				0x00
+#define TNFTL_CALLBACK_LCD_MAKE_HIDDEN_PAGE_PROCESS				0x01
+#define TNFTL_CALLBACK_LCD_MAKE_HIDDEN_PAGE_STOP				0x02
+#define TNFTL_CALLBACK_LCD_FORMAT_START							0x03
+#define TNFTL_CALLBACK_LCD_FORMAT_PROCESS						0x04
+#define TNFTL_CALLBACK_LCD_FORMAT_STOP							0x05
+#define TNFTL_CALLBACK_LCD_BMP_UPDATE_START						0x06
+#define TNFTL_CALLBACK_LCD_BMP_UPDATE_PROCESS					0x07
+#define TNFTL_CALLBACK_LCD_BMP_UPDATE_STOP						0x08
+
+#define PHY_BAD_BLOCK_MASK										0xFF000000
+#define PHY_BAD_BLOCK_0											0x01000000
+#define PHY_BAD_BLOCK_1											0x02000000
+#define PHY_BAD_BLOCK_2											0x04000000
+#define PHY_BAD_BLOCK_3											0x08000000
+#define PHY_BAD_BLOCK_4											0x10000000
+#define PHY_BAD_BLOCK_5											0x20000000
+#define PHY_BAD_BLOCK_6											0x40000000
+#define PHY_BAD_BLOCK_7											0x80000000
+
+#define WCACHE_NORMAL_USED_MODE									0x00
+#define WCACHE_FORCE_SETUP_MODE									0x01
+
+#define	WCACHE_SERIAL_PAGE_MODE									0x00
+#define	WCACHE_NORMAL_PAGE_MODE									0x01
+
+#define RCACHE_HIT_SLOT_ENTRY									0x00
+#define RCACHE_NOHIT_SLOT_ENTRY									0x01
+#define RCACHE_MAKE_NEW_SLOT_ENTRY								0x02
+
+#define	TNFTL_SECURE_SIZE										0x20000			// 128KBytes
+
+//*****************************************************************************
+//*
+//*
+//*                       [ INTERNAL STRUCT DEFINE ]
+//*
+//*
+//*****************************************************************************
+typedef	void (*TNFTL_FUNC1)(void);
+typedef	void (*TNFTL_FUNC2)(unsigned int, unsigned int);
+typedef	void (*TNFTL_FUNC3)(unsigned int);
+
+typedef unsigned long int		TNFTL_LPT_TABLE_VALUE;
+typedef unsigned long int		TNFTL_LPT_BLOCK;
+typedef unsigned long int		TNFTL_RCACHE_SLOT;
+
+typedef struct __tag_TNFTL_LPT
+{
+	unsigned short int			Usable;
+	unsigned short int			Changed;
+	unsigned short int			SegNo;
+	unsigned short int			MaxTableBlkNums;
+	unsigned short int			CurrentPlane;
+	TNFTL_LPT_BLOCK				*BlkNo;
+	TNFTL_LPT_TABLE_VALUE		Tables[TNFTL_LPT_TABLE_VALUES_1BLOCK];
+	
+} TNFTL_LPT;
+
+typedef struct __tag_TNFTL_MAINPB_INFO
+{
+	unsigned short int			Used;
+	unsigned long int			LBNo;
+    unsigned long int			MainPBNo;
+    unsigned short int			WrEndPage;
+} TNFTL_MAINPB_INFO;
+
+typedef struct __tag_TNFTL_ALIGNCACHE_INFO
+{
+	unsigned short int			Usable;
+	unsigned short int			CurUsedSecSize;
+	unsigned long int			StartSecAddr;
+	unsigned long int			LimitSecSize;
+	
+} TNFTL_ALIGNCACHE_INFO;
+
+typedef struct __tag_TNFTL_READ_CACHE
+{	
+	unsigned short int 			Used;		
+	unsigned short int			OneSlotSize;		
+	unsigned short int 			ShiftOneSlotSize;
+	unsigned short int 			HitEntryPos;
+	unsigned short int			lastSlotNo; 
+	unsigned short int   		MaxSlotNums;
+	unsigned long  int			MaxMemorySize;
+	
+	TNFTL_RCACHE_SLOT			*Entry;
+} TNFTL_RCACHE;
+
+
+typedef struct __tag_TNFTL_WRITE_CACHE
+{
+	unsigned short int			Used;
+	unsigned short int			CacheNo;
+
+	unsigned short int			PageCacheMode;
+	
+	unsigned long int			UsedNo;
+	unsigned long int			LBNo;
+	unsigned long int			MainPBNo;
+	unsigned long int			SubPBNo;
+	unsigned long int			PagePBNo;
+	unsigned long int			PagePBNo2;
+
+	unsigned long int			nPoint;
+
+	unsigned short int			MainPBWrEndPage;
+	unsigned short int 			SubPBWrEndPage;
+	unsigned short int 			PagePBWrEndPage;
+
+	unsigned short int 			PageLastPBPageNo;
+
+	unsigned short int 			PagePBStatus[TNFTL_MAX_SUPPORT_NAND_IO_PAGE_SIZE_PER_1BLOCK * 2];
+
+} TNFTL_WCACHE;
+
+typedef struct __tag_TNFTL_RO_AREA
+{
+	unsigned short int			Usable;
+	unsigned long int			BlkAreaCode;
+
+	unsigned long int			StPB;							// Start Block Number [ FTL Blcok Addr ]
+	unsigned long int			EdPB;							// End Block Number   [ FTL Blcok Addr ]
+	unsigned long int			PBpV;							// Physical Block Size
+
+	unsigned long int			StPBAddr;						// Start Phy Block Addr
+	unsigned long int			EdPBAddr;						// End Phy Block Addr
+	
+} TNFTL_RO_AREA;
+
+typedef struct __tag_TNFTL_RW_AREA
+{
+	unsigned short int			Usable;
+	unsigned long int			BlkAreaCode;
+	unsigned long int			HeaderBlkAddr;
+
+	unsigned long int			PBpV;							// Physical Blocks
+	unsigned long int			DataPBpV;						// Area Data Block Size
+	unsigned long int			DataPPpV;						// Area Data Page Size
+	unsigned long int			TotalSectorSize;
+	unsigned short int			FlagOfChangeTotalSectorSize;
+	unsigned short int 			LptNums;						// Area Needs LPT Number
+	unsigned short int			WCacheNums;						// Write Cache Number
+	unsigned short int			WCacheMode;
+	unsigned long int			WCacheDataStartLBNo;
+
+	unsigned short int			MainPBInfoNums;					// Main page info Number
+
+	unsigned short int 			RCacheUsable;
+	unsigned short int			DrvStatus;						// Status of Drive
+	unsigned long int			TotalDiskSector;				// Total Disk Sector
+	unsigned short int			Cylinder;
+	unsigned short int			Head;
+	unsigned char				Sector;	
+	
+	TNFTL_LPT					Lpt;
+	TNFTL_MAINPB_INFO			*MainPBInfo;
+	TNFTL_WCACHE				*WCaches;
+	TNFTL_RCACHE				RCaches;
+
+	unsigned char				*ReadCacheBuffer;
+} TNFTL_RW_AREA;
+
+typedef struct __tag_TNFTL_DRVINFO
+{
+	TNFTL_RO_AREA				NBArea;							// NANDBOOT Area
+	TNFTL_RW_AREA				DTArea;							// Data Area
+	TNFTL_RW_AREA				HDArea;							// Hidden Area
+	TNFTL_RW_AREA				*MultiHDArea;					// Multi Hidden Area
+
+	TNFTL_ALIGNCACHE_INFO		AlignCache;
+
+	unsigned short int 			MultiHiddendNums;				// Multi Hidden Area Num
+	
+	unsigned char				NANDType;
+	unsigned short int			IoStatus;
+	unsigned short int			IoDrvNo;
+	unsigned short int			IoStCS;
+	unsigned short int			IoEdCS;
+	unsigned short int			IoBMPFlag;						// Flag of BMP
+	unsigned long int			DrvReturnValue;
+	
+	unsigned long int	  		PBpV;							// Physical all Blocks
+	unsigned short int			BBpZ;							// Bad Blocks per 1ZONE
+	unsigned short int  		PpB;							// Pages Per Block
+	unsigned short int			PageSize;						// PageSize
+	unsigned short int			SpareSize;						// SpareSize
+	unsigned short int			PPages;							// Total Partial Pages [ 512+16Bytes ]
+	unsigned short int  		ShiftPpB;						// Shift Factor of Pages Per Block
+	unsigned short int			ShiftPPages;					// Shift Factor of Total Partial Pages
+
+	unsigned long int			RwAreaStBlk;					// RW Area Start Block Addr
+	unsigned long int			RwAreaEdBlk;					// RW Area End Block Addr
+	unsigned long int			ROAreaSize;						// RO Area Size
+	unsigned long int			ROAreaBlkNum;
+	unsigned short int			RWAreaFormatFlag;
+
+	unsigned short int  		MPlanePpB;						// FTLInfo->PpB >> FTLInfo->ShiftMPlane
+	unsigned short int  		ILMPlanePpB;					// FTLInfo->PpB >> 2
+	unsigned short int			MPlane;							// Multi Plane Num
+	unsigned short int			ShiftMPlane;					// Shift Factor of Multi Plane
+	unsigned long int 			RoundMPlane;
+	unsigned long int 			RemainMPlane;
+	unsigned long int 			LPTBufferSize;
+
+	unsigned short int			LPT_Values_1Page;
+	unsigned short int			LPT_Values_1Page_Shift;
+	unsigned short int			LPT_Pages_1Block;
+	unsigned short int			LPT_Pages_1Block_Shift;
+	unsigned short int			LPT_Block_PPage;
+
+	unsigned short int			FTLBadBlockStatus;
+	unsigned long int			FTLBadBlockNum;
+	unsigned long int			FTLBadBlock[TNFTL_MAX_VALID_BAD_BLOCK_PER_1ZONE * TNFTL_MAX_SUPPORT_ZONE];
+
+	unsigned short int			MediaNums;
+	unsigned short int			ShiftMediaNums;
+	unsigned short int			MediaBadBlockNum[TNFTL_MAX_SUPPORT_MULTI_NANDFLASH];
+
+	unsigned short int			ECCStatus;
+
+	unsigned char				MediaSizeOfSerialID;
+	unsigned char				MediaSizeOfUniqueID;
+	unsigned char				MediaSerialID[TNFTL_MAX_NANDFLASH_SID_SIZE];
+	unsigned char				MediaUniqueID[TNFTL_MAX_NANDFLASH_UID_SIZE];
+	unsigned long int			MediaTotalFTLPageAddr[TNFTL_MAX_SUPPORT_MULTI_NANDFLASH];
+	unsigned long int			MediaTotalFTLBlkAddr[TNFTL_MAX_SUPPORT_MULTI_NANDFLASH];
+	unsigned short int			MediaRatioPSize[TNFTL_MAX_SUPPORT_MULTI_NANDFLASH];
+	unsigned short int			MediaRatioBSize[TNFTL_MAX_SUPPORT_MULTI_NANDFLASH];
+	unsigned short int			MediaRatioShiftPSize[TNFTL_MAX_SUPPORT_MULTI_NANDFLASH];
+	unsigned short int			MediaRatioShiftBSize[TNFTL_MAX_SUPPORT_MULTI_NANDFLASH];
+	unsigned long int 			StPBForGetEmptyPB[TNFTL_MAX_SUPPORT_MULTI_PLANE];
+	NAND_IO_DEVINFO				MediaDevInfo[TNFTL_MAX_SUPPORT_MULTI_NANDFLASH];
+
+	unsigned char				*FTLPageBuffer;
+	unsigned char				*AlignCacheBuffer;
+	unsigned int				*LPTBuffer;
+	
+} TNFTL_DRVINFO;
+
+//*****************************************************************************
+//*
+//*
+//*                       [ EXTERNAL VARIABLE DEFINE ]
+//*
+//*
+//*****************************************************************************
+
+
+
+//*****************************************************************************
+//*
+//*
+//*                       [ EXTERNAL FUCTIONS DEFINE ]
+//*
+//*
+//*****************************************************************************
+extern void 					TNFTL_SetROAreaSize( TNFTL_DRVINFO * FTLInfo, int nROAreaSize );
+
+extern TNFTL_ERROR				TNFTL_AllocMemAndLinkForDriver( U16 nDrvNo, TNFTL_DRVINFO *nMDrvInfo, TNFTL_DRVINFO **nPDrvInfo );
+extern TNFTL_ERROR				TNFTL_AllocMemAndLinkForLPT( U16 nDrvNo, TNFTL_RW_AREA *nArea, TNFTL_LPT_BLOCK *nLptTableBlk, U32 nLptTableBlkSize );
+extern TNFTL_ERROR				TNFTL_AllocMemAndLinkForWCACHE( U16 nDrvNo, TNFTL_RW_AREA *nArea, TNFTL_WCACHE *nWCaches, U32 nWCacheNum );
+extern TNFTL_ERROR 				TNFTL_AllocMemAndLinkForRCACHE( U16 nDrvNo, TNFTL_RW_AREA *nArea, TNFTL_RCACHE_SLOT *nRCacheSlots );
+
+
+extern TNFTL_ERROR 				TNFTL_AllocMemAndLinkForMainPBInfo( U16 nDrvNo, TNFTL_RW_AREA *nArea, TNFTL_MAINPB_INFO *nMainPBInfo, U32 nMainPBInfoNum );
+extern TNFTL_ERROR				TNFTL_AllocMemAndLinkForPageBuffer( U16 nDrvNo, U8 *nPageBuffer );
+extern TNFTL_ERROR 				TNFTL_AllocMemAndLinkForRCacheBuffer( U16 nDrvNo, TNFTL_RW_AREA *nArea, U8 *nPageBuffer, U32 nBufferSize );
+extern TNFTL_ERROR 				TNFTL_AllocMemAndLinkForAlignCacheBuffer( U16 nDrvNo, U8 *nPageBuffer, U32 nBufferSize );
+
+extern TNFTL_ERROR				TNFTL_AllocMemAndLinkForMakeLPT( U16 nDrvNo, U32 *nLPTBuffer, U32 nBufferSize );
+extern TNFTL_ERROR 				TNFTL_AllocMemAndLinkForMultiHidden( U16 nDrvNo, TNFTL_RW_AREA *nArea );
+extern TNFTL_ERROR				TNFTL_SetStEdOfCS( U16 nDrvNo, U16 nStartCS, U16 nEndCS );
+extern TNFTL_ERROR				TNFTL_SetMultiHiddenNums( U16 nDrvNo, U16 nMHiddenNums );
+
+extern void						TNFTL_DEBUG_Init( void );
+extern void 					TNFTL_DEBUG_Init_Function( TNFTL_FUNC1 nFUNC1, TNFTL_FUNC2 nFUNC2, TNFTL_FUNC2 nFUNC3, TNFTL_FUNC2 nFUNC4,	TNFTL_FUNC2 nFUNC5,	TNFTL_FUNC3 nFUNC6, TNFTL_FUNC1 nFUNC7,	TNFTL_FUNC1 nFUNC8);
+
+extern TNFTL_ERROR 				TNFTL_DEBUG_VTCParser( void* nVTCCmd );
+extern void						TNFTL_Init( U16 nDrvNo );
+extern TNFTL_ERROR				TNFTL_InitDrive( TNFTL_DRVINFO *FTLInfo );
+extern TNFTL_ERROR				TNFTL_CheckIsExistBMP( TNFTL_DRVINFO *FTLInfo );
+
+extern TNFTL_ERROR 				TNFTL_AlignCacheFlush( TNFTL_DRVINFO *FTLInfo );
+
+extern U32						TNFTL_AREAGetTotalSectorSize( TNFTL_DRVINFO *FTLInfo, TNFTL_RW_AREA *nArea );
+extern TNFTL_ERROR				TNFTL_AREAGetTotalSecAndCHS( TNFTL_DRVINFO *FTLInfo, TNFTL_RW_AREA *nArea, U32 *rTotalSec, U16 *rCylinder, U16 *rHead, U8 *rSector );
+extern TNFTL_ERROR				TNFTL_AREASetTotalSectorSize( TNFTL_DRVINFO *FTLInfo, TNFTL_RW_AREA *nArea, U32 nTotalSectorSize );
+extern TNFTL_ERROR				TNFTL_AREAReadSectorBy4Byte( TNFTL_DRVINFO *FTLInfo, TNFTL_RW_AREA *nArea, U32 nSectorAddr, U16 nOffset, U16 nReadSize, U8 *nReadBuffer );
+extern TNFTL_ERROR				TNFTL_AREAReadSector( TNFTL_DRVINFO *FTLInfo, TNFTL_RW_AREA *nArea, U32 nSectorAddr, U32 nSecSize, U8 *nReadBuffer );
+extern TNFTL_ERROR				TNFTL_AREAWriteSector( TNFTL_DRVINFO *FTLInfo, TNFTL_RW_AREA *nArea, U32 nSectorAddr, U32 nSecSize, U8 *nWriteBuffer );
+extern TNFTL_ERROR				TNFTL_AREAFormat( TNFTL_DRVINFO *FTLInfo, TNFTL_RW_AREA *nArea, U16 nFormatLevel );
+extern TNFTL_ERROR				TNFTL_NBGetCRCOfImageFile( TNFTL_DRVINFO *FTLInfo, U32 nFlagSelfChecking, U32 *nOrgCRCcode1, U32 *nOrgCRCcode2, U32 *nRomFileSize, U32 *rRstCRCcode1, U32 *rRstCRCcode2 );
+extern TNFTL_ERROR 				TNFTL_NBGetCRCValueOfImageFile( TNFTL_DRVINFO *FTLInfo, U32 *nOrgCRCcode1, U32 *nOrgCRCcode2, U32 *nRomFileSize );
+extern TNFTL_ERROR				TNFTL_NBGetSizeOfImageFile( TNFTL_DRVINFO *FTLInfo, U32 *nRomFileSize ) ;
+extern void					 	TNFTL_WCacheSetDataStartSector( TNFTL_DRVINFO *FTLInfo, TNFTL_RW_AREA *nArea, unsigned int nDataStartSector );
+
+extern U16						TNFTL_GetSerialNumber( TNFTL_DRVINFO *FTLInfo, U8* rSerialNumber, U16 nSize );
+extern void						TNFTL_SetFlagOfChangeTotalSecSize( TNFTL_DRVINFO *FTLInfo, TNFTL_RW_AREA *nArea, U16 on_off );
+
+extern TNFTL_ERROR 				TNFTL_IOReadPhyPage( TNFTL_DRVINFO *FTLInfo, U32 nBlkAddr, U32 nPageAddr, U16 nCSorder, U8 *nReadBuffer );
+extern __inline TNFTL_ERROR		TNFTL_IOReadSpare( TNFTL_DRVINFO *FTLInfo, U32 nFTLPageAddr, U8 *nSpareBuffer );
+#ifndef RVDS
+extern __inline TNFTL_ERROR		TNFTL_IOReadPage( TNFTL_DRVINFO *FTLInfo, U32 nFTLPageAddr, U16 nStartPPage, U16 nReadPPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+#endif
+extern __inline TNFTL_ERROR		TNFTL_IOReadPageForSignature( TNFTL_DRVINFO *FTLInfo, U32 nFTLPageAddr, U16 nStartPPage, U16 nReadPPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+
+extern __inline TNFTL_ERROR		TNFTL_IOReadTwoPlanePage( TNFTL_DRVINFO *FTLInfo, U32 nFTLPageAddr, U16 nStartPPage, U16 nReadPPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nReadOption, int nEccOnOff );
+extern __inline TNFTL_ERROR		TNFTL_IOReadTwoPlaneLastPage( TNFTL_DRVINFO *FTLInfo, U32 nFTLPageAddr, U16 nStartPPage, U16 nReadPPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+#ifndef RVDS
+extern __inline TNFTL_ERROR		TNFTL_IOReadUserSizePage( TNFTL_DRVINFO *FTLInfo, U32 nFTLPageAddr, U16 nColumnAddr, U32 nReadSize, U8 *nReadBuffer );
+#endif
+extern __inline TNFTL_ERROR		TNFTL_IOWritePage( TNFTL_DRVINFO *FTLInfo, U32 nFTLPageAddr, U16 nStartPPage, U16 nWritePPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+extern __inline TNFTL_ERROR		TNFTL_IOWriteTwoPlanePage( TNFTL_DRVINFO *FTLInfo, U32 nFTLPageAddr, U16 nStartPPage, U16 nWritePPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+extern __inline TNFTL_ERROR		TNFTL_IOWriteTwoPlaneLastPage( TNFTL_DRVINFO *FTLInfo, U32 nFTLPageAddr, U16 nStartPPage, U16 nWritePPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int LastPage, int nEccOnOff );
+extern __inline TNFTL_ERROR		TNFTL_IOWriteCachePage( TNFTL_DRVINFO *FTLInfo, U32 nFTLPageAddr, U16 nStartPPage, U16 nWritePPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+extern __inline TNFTL_ERROR		TNFTL_IOWriteCacheLastPage( TNFTL_DRVINFO *FTLInfo, U32 nFTLPageAddr, U16 nStartPPage, U16 nWritePPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+extern __inline TNFTL_ERROR		TNFTL_IOWriteUserSizePage( TNFTL_DRVINFO *FTLInfo, U32 nFTLPageAddr, U16 nColumnAddr, U32 nWriteSize, U8 *nWriteBuffer );
+extern __inline TNFTL_ERROR		TNFTL_IOWriteSpare( TNFTL_DRVINFO *FTLInfo, U32 nFTLPageAddr, U8 *nSpareBuffer );
+
+extern __inline TNFTL_ERROR		TNFTL_IOCopyBackPage( TNFTL_DRVINFO *FTLInfo, U32 nDesFTLPageAddr, U32 nSrcFTLPageAddr, U8 *nPageBuffer, U8 *nSpareBuffer );
+extern __inline TNFTL_ERROR		TNFTL_IOEraseBlock( TNFTL_DRVINFO *FTLInfo, U32 nFTLBlkAddr, int nFormatMode );
+extern __inline TNFTL_ERROR		TNFTL_IOCopyBackTwoPlanePage( TNFTL_DRVINFO *FTLInfo, U32 nDesFTLPageAddr, U32 nSrcFTLPageAddr, U8 *nPageBuffer, U8 *nSpareBuffer );
+
+extern TNFTL_ERROR 				TNFTL_GoldenPageWrite( TNFTL_DRVINFO *FTLInfo, U32 nStarAddr, U32 nWriteByteSize, U8 *nPageBuffer );
+extern TNFTL_ERROR 				TNFTL_GoldenPageRead( TNFTL_DRVINFO *FTLInfo, U32 nStarAddr, U32 nReadByteSize, U8 *nPageBuffer );
+extern TNFTL_ERROR 				TNFTL_SizeofGoldenPage( TNFTL_DRVINFO *FTLInfo );
+
+extern TNFTL_ERROR				TNFTL_SetCallBackHandler( TNFTL_CALLBACK_HANDLER pCallBackHandler );
+extern TNFTL_ERROR				TNFTL_SetUartDebug( unsigned int on_off );
+extern TNFTL_ERROR				TNFTL_BMPRefresh( TNFTL_DRVINFO *FTLInfo );
+
+extern TNFTL_ERROR				TNFTL_SetUseAreaReadCacheMode( TNFTL_DRVINFO *FTLInfo, TNFTL_RW_AREA *nArea, unsigned int on_off );
+extern TNFTL_ERROR 				TNFTL_SetUseAlignCacheMode( TNFTL_DRVINFO *FTLInfo, unsigned int on_off );
+
+
+#endif
+
diff --git a/drivers/block/tcc/inc/tnftl/tnftl_v7.h b/drivers/block/tcc/inc/tnftl/tnftl_v7.h
new file mode 100644
index 0000000..c487e19
--- /dev/null
+++ b/drivers/block/tcc/inc/tnftl/tnftl_v7.h
@@ -0,0 +1,656 @@
+/**************************************************************************************
+ *
+ * TELECHIPS Co.
+ * 
+ * 6th floor Corad Bldg 1000-12 Daechi-dong, KangNam-ku, Seoul, Korea
+ * ====================================================================================
+ *
+ * Name:        Hyun-Chul Hong
+ * Phone:       82-2-3443-6792
+ * E-mail:      hchong@telechips.com
+ *
+ * FILE NAME:   TNFTL.H
+ *
+ * DESCRIPTION:
+ *       This is a Header File for TNFTL [ Telechips Nand Flash Translation Layer ]
+ *
+ *
+ * FILE HISTORY:
+ * 	Date: 2005.04.19	Start source coding		By Hyunchul Hong
+ *
+ **************************************************************************************/
+#ifndef __TNFTL_H
+#define __TNFTL_H
+
+#if defined(_LINUX_)
+#include <tnftl/nand_io_v7.h>
+#elif defined(_WINCE_)
+#include "nand_io_v7.h"
+#else
+#include "nand_io_v7.h"
+#endif
+
+#if defined(TCC92XX) || defined(TCC89XX)
+#if defined(NAND_BOOT_REV)
+#define TNFTL_V7_INCLUDE
+#else
+#define TNFTL_V6_INCLUDE
+#endif
+#elif defined(TCC82XX)||defined(TCC83XX)||defined(TCC79X) || defined(TCC81XX) || defined(TCC80XX)
+#define TNFTL_V5_INCLUDE
+#else
+#define TNFTL_V4_INCLUDE
+#endif
+
+//*****************************************************************************
+//*
+//*
+//*                       [ General DEFINE & TYPEDEF ]
+//*
+//*
+//*****************************************************************************
+#ifndef NOT_USED
+#define NOT_USED				0
+#endif
+#ifndef USED
+#define	USED					1
+#endif
+#ifndef DISABLE
+#define DISABLE					0
+#endif
+#ifndef ENABLE
+#define	ENABLE					1
+#endif
+#ifndef FALSE
+#define FALSE           		0
+#endif
+#ifndef TRUE
+#define TRUE            		1
+#endif
+#ifndef NULL
+#define NULL					0
+#endif
+#ifndef TNFTL_U16_NULL
+#define TNFTL_U16_NULL			0xFFFF
+#endif
+#ifndef TNFTL_U32_NULL
+#define TNFTL_U32_NULL			0xFFFFFFFF
+#endif
+
+#ifndef _U8_
+#define _U8_
+typedef unsigned char			U8;
+#endif
+#ifndef _U16_
+#define _U16_
+typedef unsigned short int		U16;
+#endif
+#ifndef _U32_
+#define _U32_
+typedef unsigned int			U32;
+#endif
+#ifndef _BOOL_
+#define _BOOL_
+typedef unsigned int			BOOL;
+#endif
+
+//*****************************************************************************
+//*
+//*
+//*                         [ ERROR CODE ENUMERATION ]
+//*
+//*
+//*****************************************************************************
+#ifndef SUCCESS
+#define SUCCESS		0
+#endif
+
+typedef enum
+{
+	ERR_TNFTL_NO_EXIST_NAND_FLASH = 0xA200000,
+	ERR_TNFTL_NO_BMP,
+	ERR_TNFTL_NOT_READY_IO,
+	ERR_TNFTL_NOT_READY_AREA,
+	ERR_TNFTL_NOT_EXIST_NANDFLASH,
+	ERR_TNFTL_NOT_EXIST_MEDIA_NUM_INFO,
+	ERR_TNFTL_NOT_HAVE_ENOUGH_ZONE_BLOCK,
+	ERR_TNFTL_NOT_EXIST_HIDDEN_HEADBLOCK,
+	ERR_TNFTL_NOT_EXIST_NANDBOOT_AREA,	
+	ERR_TNFTL_NOT_HIDDEN_WRITE_CACHE_BLOCK,
+	ERR_TNFTL_NOT_EXIST_DATA_IN_WRITE_CACHE_PAGE_BLOCK,
+	ERR_TNFTL_NOT_FRESH_NANDFLASH,
+	ERR_TNFTL_NOT_EXIST_FTL_BAD_BLOCK_INFO,
+	ERR_TNFTL_FAILED_CHECK_BMP,
+	ERR_TNFTL_FAILED_GET_REAL_PAGE_ADDR,
+	ERR_TNFTL_FAILED_ALLOCATE_MEM_AND_LINK_DRIVER,
+	ERR_TNFTL_FAILED_GOLDEN_PAGE,
+	ERR_TNFTL_FAILED_GET_SHIFT_FACTOR_FOR_MULTIPLY,
+	ERR_TNFTL_FAILED_GET_EMPTY_RAW_BLOCK,
+	ERR_TNFTL_FAILED_MAKE_BMP,
+	ERR_TNFTL_FAILED_GET_MEDIA_UID,
+	ERR_TNFTL_FAILED_GET_MEDIA_SID,
+	ERR_TNFTL_FAILED_GET_PBLOCK_STATUS_ON_BMP,
+	ERR_TNFTL_FAILED_GET_NANDBOOT_AREA,
+	ERR_TNFTL_FAILED_MAKE_HIDDEN_LBT_BLOCK,
+	ERR_TNFTL_FAILED_GET_EMPTY_HIDDEN_BLOCK,
+	ERR_TNFTL_FAILED_MAKE_HIDDEN_AREA,
+	ERR_TNFTL_FAILED_GET_FTL_PAGE_ADDRESS_OF_SECTOR_ADDRESS,
+	ERR_TNFTL_FAILED_GET_HIDDEN_WRITE_CACHE_NUMBER,
+	ERR_TNFTL_FAILED_GET_HIDDEN_WRITE_MAINPB_INFO,
+	ERR_TNFTL_FAILED_GET_EMPTY_FTL_BLOCK_FOR_WRITE_CACHE,
+	ERR_TNFTL_FAILED_GET_EMPTY_FTL_BLOCK,
+	ERR_TNFTL_FAILED_GET_EMPTY_PHYSICAL_BLOCK,
+	ERR_TNFTL_FAILED_GET_LPTSCAN_BUFFER,
+	ERR_TNFTL_TRY_ERASE_0TH_BLOCK,
+	ERR_TNFTL_OVERSIZE_ZONES,
+	ERR_TNFTL_WRONG_PARAMETER,
+	ERR_TNFTL_WCACHE_FORCE_FLUSH,
+	ERR_TNFTL_PBLOCK_IS_BAD_BLOCK,
+	ERR_TNFTL_LPT_CORRUPTED_SEG_NO,
+	ERR_TNFTL_CORRUPTED_HIDDEN_AREA,
+	ERR_TNFTL_SET_OVER_HIDDEN_PAGE_SIZE,
+	ERR_TNFTL_OVERSIZE_MULTIHIDDEN_NUM,
+	ERR_TNFTL_HAVE_MANY_BAD_BLOCKS_IN_ZONE,
+	ERR_TNFTL_MEDIA_HAVE_OVERSIZE_BAD_BLOCKS,
+	ERR_TNFTL_IMPOSSIBLE_TO_SET_SIZE_OF_DATA_AREA,
+	ERR_TNFTL_NANDBOOT_AREA_OVER_SIZE,
+	ERR_TNFTL_HIDDEN_AREA_OVER_SIZE,
+	ERR_TNFTL_DEBUG_WRONG_PARAMETER,
+	ERR_TNFTL_DEBUG_WRONG_COMMAND_PARAMETERS,
+	ERR_TNFTL_DEBUG_WRONG_RECEIVED_SECTOR_DATA,
+	ERR_TNFTL_DEBUG_WRONG_SEND_SECTOR_DATA,
+	ERR_TNFTL_WRONG_CRC_CODE_NANDBOOT_ROMFILE,
+	ERR_TNFTL_WRONG_MATCH_UID_NBAREA,
+	ERR_TNFTL_OVERSIZE_PPAGE_NUM,
+	ERR_TNFTL_OVERSIZE_MTD_AREA_SIZE
+} TNFTL_ERROR;
+
+
+#define TNFTL_MAX_BLOCK_NUM_OF_NBAREA							100
+
+//*****************************************************************************
+//*
+//*
+//*                          [ INTERNAL DEFINATION ]
+//*
+//*
+//*****************************************************************************
+#define TNFTL_MAX_SUPPORT_DRIVER								2
+#define TNFTL_MAX_SUPPORT_MULTI_NANDFLASH						4
+#define TNFTL_MAX_SUPPORT_NAND_IO_PAGE_SIZE						16384		// 4096*2(Parallel)*2(MultiPlane)
+#define TNFTL_MAX_SUPPORT_NAND_IO_SPARE_SIZE					512			// 128*4
+#define TNFTL_MAX_SUPPORT_NAND_IO_SECTOR_SIZE_PER_1PAGE			32			// 16384 / 512
+#define TNFTL_MAX_SUPPORT_NAND_IO_PAGE_SIZE_PER_1BLOCK			512			// PpB * 2 (Multi-Plane) * 2 (InterLeave)
+#define TNFTL_MAX_SUPPORT_MULTI_PLANE							4
+#define TNFTL_MAX_SUPPORT_SHIFT_MULTI_PLANE						2
+#define TNFTL_MAX_SUPPORT_BAD_BLOCKS_IN_1ZONE					20
+#define TNFTL_MAX_SUPPORT_NB_AND_HD_AREA_BLOCK_SIZE				900			// 900 Blocks
+#define TNFTL_MAX_VALID_BAD_BLOCK_PER_1ZONE						40			
+#define TNFTL_MAX_SUPPORT_ZONE									32
+#define TNFTL_MAX_SUPPORT_NAND_PPAGE_NUM						32
+
+#define TNFTL_PLANE_0											0
+#define TNFTL_PLANE_1											1
+#define TNFTL_PLANE_2											2
+#define TNFTL_PLANE_3											3
+
+#define TNFTL_PHY_BLOCKS_1ZONE									1024
+#define TNFTL_PHY_BLOCKS_1ZONE_SHIFT							10			// 2^10 = 1024
+
+#define TNFTL_BMP_HEADER_SIZE									4			// 4Bytes
+#define TNFTL_BMP_FLAGS_IN_1BYTE								4			// Flag Size is 2Bit
+#define TNFTL_BMP_FLAGS_IN_1BYTE_SHIFT							2			// Shift Factor
+#define	TNFTL_BMP_START_PAGE									2
+#define TNFTL_BMP_BAD_BLOCK_CACHE_SIZE							64			// 64*2 = 128Bytes
+#define TNFTL_BMP_STATUS_OK										0x0000
+#define TNFTL_BMP_STATUS_FAIL_NO_BMP1_SERIAL					0x0001
+#define TNFTL_BMP_STATUS_FAIL_NO_BMP1_PARALLEL					0x0010
+#define TNFTL_BMP_STATUS_FAIL_NO_BMP2_PARALLEL					0x0100
+#define TNFTL_BMP_STATUS_FAIL_OTHER_REASON						0x1000
+
+#define TNFTL_BSA_SCAN_BY_FACTORY_MARK							0
+#define TNFTL_BSA_SCAN_BY_CHECK_PATTERN							1
+#define TNFTL_BSA_GET_BY_BMP									0
+#define TNFTL_BSA_GET_BY_CHECK									1
+#define TNFTL_BSA_GET_BY_SPARE									2
+#define TNFTL_BSA_GET_BY_FTLBBINFO								3
+
+#define TNFTL_LPT_NOT_CHANGED									0x00
+#define TNFTL_LPT_CHANGED										0x01
+#define TNFTL_LPT_TABLE_VALUES_1PAGE							128
+#define TNFTL_LPT_TABLE_VALUES_1PAGE_SHIFT						7
+#define TNFTL_LPT_TABLE_PAGES_1BLOCK							8
+#define TNFTL_LPT_TABLE_PAGES_1BLOCK_SHIFT						3
+#define TNFTL_LPT_TABLE_VALUES_1BLOCK							1024
+#define TNFTL_LPT_TABLE_VALUES_1BLOCK_SHIFT						10
+#define TNFTL_LPT_TABLE_DATA_START_PAGE							1
+
+#define TNFTL_MAX_SERIAL_NUMBER_SIZE							32
+#define TNFTL_MAX_NANDFLASH_SID_SIZE							32
+#define TNFTL_MAX_NANDFLASH_UID_SIZE							16
+
+#define TNFTL_HIDDEN_DEFAULT_TOTAL_SECTOR_SIZE					6083
+#define TNFTL_HIDDEN_DEFAULT_SPARE_BLOCK_SIZE					8
+#define TNFTL_HIDDEN_BLOCK_SIZE_FOR_SYSTEM_BLOCK				3			// HEAD 1 + LBT BLOCK 2
+
+#define TNFTL_MAX_SUPPORT_MULTI_HIDDEN_AREA_NUM					10
+
+#define TNFTL_BAA_INVALID_BLOCK_MARK1							0xFF
+#define TNFTL_BAA_INVALID_BLOCK_MARK2							0xEE
+#define TNFTL_BAA_INVALID_ADDRESS								0xFFFFFE
+#define TNFTL_INVALID_LOG_ADDRESS								0xFFFFFFEE
+
+#define TNFTL_BLOCK_AREA_MASK									0xF0
+#define TNFTL_BLOCK_AREA_DATA_AREA								0x10
+#define TNFTL_BLOCK_AREA_HIDDEN_AREA							0x20
+#define TNFTL_BLOCK_AREA_MULTI_HIDDEN_AREA0						0x30
+#define TNFTL_BLOCK_AREA_MULTI_HIDDEN_AREA1						0x40
+#define TNFTL_BLOCK_AREA_MULTI_HIDDEN_AREA2						0x50
+#define TNFTL_BLOCK_AREA_MULTI_HIDDEN_AREA3						0x60
+#define TNFTL_BLOCK_AREA_MULTI_HIDDEN_AREA4						0x70
+#define TNFTL_BLOCK_AREA_MULTI_HIDDEN_AREA5						0x80
+#define TNFTL_BLOCK_AREA_MULTI_HIDDEN_AREA6						0x90
+#define TNFTL_BLOCK_AREA_MULTI_HIDDEN_AREA7						0xA0
+#define TNFTL_BLOCK_AREA_MULTI_HIDDEN_AREA8						0xB0
+#define TNFTL_BLOCK_AREA_MULTI_HIDDEN_AREA9						0xC0
+#define TNFTL_BLOCK_AREA_NANDBOOT_AREA							0xE0
+
+
+#define TNFTL_BLOCK_AREA_PRIMARY_PARTITION						0x10
+
+#define TNFTL_BLOCK_AREA_EXTENDED_PARTITION_0					0x20
+#define TNFTL_BLOCK_AREA_EXTENDED_PARTITION_1					0x30
+#define TNFTL_BLOCK_AREA_EXTENDED_PARTITION_2					0x40
+#define TNFTL_BLOCK_AREA_EXTENDED_PARTITION_3					0x50
+#define TNFTL_BLOCK_AREA_EXTENDED_PARTITION_4					0x60
+#define TNFTL_BLOCK_AREA_EXTENDED_PARTITION_5					0x70
+#define TNFTL_BLOCK_AREA_EXTENDED_PARTITION_6					0x80
+#define TNFTL_BLOCK_AREA_EXTENDED_PARTITION_8					0x90
+#define TNFTL_BLOCK_AREA_EXTENDED_PARTITION_9					0xA0
+#define TNFTL_BLOCK_AREA_EXTENDED_PARTITION_10					0xB0
+#define TNFTL_BLOCK_AREA_EXTENDED_PARTITION_11					0xC0
+#define TNFTL_BLOCK_AREA_EXTENDED_PARTITION_12					0xD0
+
+
+
+#define TNFTL_BLOCK_TYPE_MASK									0x0F
+#define TNFTL_BLOCK_TYPE_HEADER									0x01
+#define TNFTL_BLOCK_TYPE_LBT									0x02
+#define TNFTL_BLOCK_TYPE_DATA									0x03
+#define TNFTL_BLOCK_TYPE_WRITE_CACHE_PAGE						0x05
+#define TNFTL_BLOCK_TYPE_WRITE_CACHE_PAGE_2						0x06
+#define TNFTL_BLOCK_TYPE_WRITE_CACHE_SUB						0x07
+#define TNFTL_BLOCK_TYPE_WRITE_CACHE_PAGE_SERIAL				0x08
+#define TNFTL_BLOCK_TYPE_WRITE_CACHE_PAGE_2_SERIAL				0x09
+
+
+#define TNFTL_BLOCK_TYPE_NB_MASTER								0x01
+#define TNFTL_BLOCK_TYPE_NB_DATA								0x03
+#define TNFTL_BLOCK_TYPE_NB_BOOTLOADER							0x04
+
+
+#define TNFTL_WRITE_CACHE_PAGE_OFFSET							0x01
+
+#define TNFTL_READ_SECTOR_FROM_NULL_BLOCK						0x00
+#define TNFTL_READ_SECTOR_FROM_MAIN_BLOCK						0x01
+#define TNFTL_READ_SECTOR_FROM_WCACHE_SUB_BLOCK					0x02
+#define TNFTL_READ_SECTOR_FROM_WCACHE_PAGE_BLOCK				0x03
+#define TNFTL_WRITE_SECTOR_TO_MAIN_BLOCK						0x04
+#define TNFTL_WRITE_SECTOR_TO_WCACHE_SUB_BLOCK					0x05
+#define TNFTL_WRITE_SECTOR_TO_WCACHE_PAGE_BLOCK					0x06
+
+#define TNFTL_FORMAT_AREA_QUICK_LEVEL							0x00
+#define TNFTL_FORMAT_AREA_LOW_LEVEL								0x01
+
+typedef void (*TNFTL_CALLBACK_HANDLER) ( U16 nDrvNo, U16 nStatusCode, U32 wParam );
+#define TNFTL_CALLBACK_LCD_MAKE_HIDDEN_PAGE_START				0x00
+#define TNFTL_CALLBACK_LCD_MAKE_HIDDEN_PAGE_PROCESS				0x01
+#define TNFTL_CALLBACK_LCD_MAKE_HIDDEN_PAGE_STOP				0x02
+#define TNFTL_CALLBACK_LCD_FORMAT_START							0x03
+#define TNFTL_CALLBACK_LCD_FORMAT_PROCESS						0x04
+#define TNFTL_CALLBACK_LCD_FORMAT_STOP							0x05
+#define TNFTL_CALLBACK_LCD_BMP_UPDATE_START						0x06
+#define TNFTL_CALLBACK_LCD_BMP_UPDATE_PROCESS					0x07
+#define TNFTL_CALLBACK_LCD_BMP_UPDATE_STOP						0x08
+
+#define PHY_BAD_BLOCK_MASK										0xFF000000
+#define PHY_BAD_BLOCK_0											0x01000000
+#define PHY_BAD_BLOCK_1											0x02000000
+#define PHY_BAD_BLOCK_2											0x04000000
+#define PHY_BAD_BLOCK_3											0x08000000
+#define PHY_BAD_BLOCK_4											0x10000000
+#define PHY_BAD_BLOCK_5											0x20000000
+#define PHY_BAD_BLOCK_6											0x40000000
+#define PHY_BAD_BLOCK_7											0x80000000
+
+#define WCACHE_NORMAL_USED_MODE									0x00
+#define WCACHE_FORCE_SETUP_MODE									0x01
+
+#define	WCACHE_SERIAL_PAGE_MODE									0x00
+#define	WCACHE_NORMAL_PAGE_MODE									0x01
+
+#define RCACHE_HIT_SLOT_ENTRY									0x00
+#define RCACHE_NOHIT_SLOT_ENTRY									0x01
+#define RCACHE_MAKE_NEW_SLOT_ENTRY								0x02
+
+#define	TNFTL_SECURE_SIZE										0x20000			// 128KBytes
+
+//*****************************************************************************
+//*
+//*
+//*                       [ INTERNAL STRUCT DEFINE ]
+//*
+//*
+//*****************************************************************************
+typedef	void (*TNFTL_FUNC1)(void);
+typedef	void (*TNFTL_FUNC2)(unsigned int, unsigned int);
+typedef	void (*TNFTL_FUNC3)(unsigned int);
+
+typedef unsigned long int		TNFTL_LPT_TABLE_VALUE;
+typedef unsigned long int		TNFTL_LPT_BLOCK;
+typedef unsigned long int		TNFTL_RCACHE_SLOT;
+
+
+typedef struct __tag_TNFTL_INIT_INFO
+{
+	U8	SerialNumber[64];
+	U8	BMPSignature[4];
+	U32	ExtendedPartitionNo; 		// Extended Partition Number
+	U32	ExtendedPartitionSectorSize[10];
+	U32 ROAreaSize;
+	U32 ROAreaStPB;
+} TNFTL_INIT_INFO;
+
+typedef struct __tag_TNFTL_LPT
+{
+	unsigned short int			Usable;
+	unsigned short int			Changed;
+	unsigned short int			SegNo;
+	unsigned short int			MaxTableBlkNums;
+	unsigned short int			CurrentPlane;
+	TNFTL_LPT_BLOCK				*BlkNo;
+	TNFTL_LPT_TABLE_VALUE		Tables[TNFTL_LPT_TABLE_VALUES_1BLOCK];
+	
+} TNFTL_LPT;
+
+typedef struct __tag_TNFTL_MAINPB_INFO
+{
+	unsigned short int			Used;
+	unsigned long int			LBNo;
+    unsigned long int			MainPBNo;
+    unsigned short int			WrEndPage;
+} TNFTL_MAINPB_INFO;
+
+typedef struct __tag_TNFTL_ALIGNCACHE_INFO
+{
+	unsigned short int			Usable;
+	unsigned short int			CurUsedSecSize;
+	unsigned long int			StartSecAddr;
+	unsigned long int			LimitSecSize;
+	
+} TNFTL_ALIGNCACHE_INFO;
+
+typedef struct __tag_TNFTL_READ_CACHE
+{	
+	unsigned short int 			Used;		
+	unsigned short int			OneSlotSize;		
+	unsigned short int 			ShiftOneSlotSize;
+	unsigned short int 			HitEntryPos;
+	unsigned short int			lastSlotNo; 
+	unsigned short int   		MaxSlotNums;
+	unsigned long  int			MaxMemorySize;
+	
+	TNFTL_RCACHE_SLOT			*Entry;
+} TNFTL_RCACHE;
+
+
+typedef struct __tag_TNFTL_WRITE_CACHE
+{
+	unsigned short int			Used;
+	unsigned short int			CacheNo;
+
+	unsigned short int			PageCacheMode;
+	
+	unsigned long int			UsedNo;
+	unsigned long int			LBNo;
+	unsigned long int			MainPBNo;
+	unsigned long int			SubPBNo;
+	unsigned long int			PagePBNo;
+	unsigned long int			PagePBNo2;
+
+	unsigned long int			nPoint;
+
+	unsigned short int			MainPBWrEndPage;
+	unsigned short int 			SubPBWrEndPage;
+	unsigned short int 			PagePBWrEndPage;
+
+	unsigned short int 			PageLastPBPageNo;
+
+	unsigned short int 			PagePBStatus[TNFTL_MAX_SUPPORT_NAND_IO_PAGE_SIZE_PER_1BLOCK * 2];
+
+} TNFTL_WCACHE;
+
+typedef struct __tag_TNFTL_RO_AREA
+{
+	unsigned short int			Usable;
+	unsigned long int			BlkAreaCode;
+
+	unsigned long int			StPB;							// Start Block Number [ FTL Blcok Addr ]
+	unsigned long int			EdPB;							// End Block Number   [ FTL Blcok Addr ]
+	unsigned long int			PBpV;							// Physical Block Size
+
+	unsigned long int			StPBAddr;						// Start Phy Block Addr
+	unsigned long int			EdPBAddr;						// End Phy Block Addr
+	
+} TNFTL_RO_AREA;
+
+typedef struct __tag_TNFTL_RW_AREA
+{
+	unsigned short int			Usable;
+	unsigned long int			BlkAreaCode;
+	unsigned long int			HeaderBlkAddr;
+
+	unsigned long int			PBpV;							// Physical Blocks
+	unsigned long int			DataPBpV;						// Area Data Block Size
+	unsigned long int			DataPPpV;						// Area Data Page Size
+	unsigned long int			TotalSectorSize;
+	unsigned short int			FlagOfChangeTotalSectorSize;
+	unsigned short int 			LptNums;						// Area Needs LPT Number
+	unsigned short int			WCacheNums;						// Write Cache Number
+	unsigned short int			WCacheMode;
+	unsigned long int			WCacheDataStartLBNo;
+
+	unsigned short int			MainPBInfoNums;					// Main page info Number
+
+	unsigned short int 			RCacheUsable;
+	unsigned short int			DrvStatus;						// Status of Drive
+	unsigned long int			TotalDiskSector;				// Total Disk Sector
+	unsigned short int			Cylinder;
+	unsigned short int			Head;
+	unsigned char				Sector;	
+	
+	TNFTL_LPT					Lpt;
+	TNFTL_MAINPB_INFO			*MainPBInfo;
+	TNFTL_WCACHE				*WCaches;
+	TNFTL_RCACHE				RCaches;
+
+	unsigned char				*ReadCacheBuffer;
+} TNFTL_RW_AREA;
+
+typedef struct __tag_TNFTL_DRVINFO
+{
+	TNFTL_RO_AREA				NBArea;							// NANDBOOT Area
+	TNFTL_RW_AREA				PriPartition;					// Primary Partition
+	TNFTL_RW_AREA				*ExtPartition;					// Extended Partition[n]
+
+	TNFTL_ALIGNCACHE_INFO		AlignCache;
+
+	unsigned short int 			ExtendedPartitionNo;			// Extended Partition Number
+	unsigned char	 			FlagOfChangePartition;
+
+	
+	unsigned char				NANDType;
+	unsigned short int			IoStatus;
+	unsigned short int			IoDrvNo;
+	unsigned short int			IoStCS;
+	unsigned short int			IoEdCS;
+	unsigned short int			IoBMPFlag;						// Flag of BMP
+	unsigned long int			DrvReturnValue;
+
+
+	
+	unsigned long int	  		PBpV;							// Physical all Blocks
+	unsigned short int			BBpZ;							// Bad Blocks per 1ZONE
+	unsigned short int  		PpB;							// Pages Per Block
+	unsigned short int			PageSize;						// PageSize
+	unsigned short int			SpareSize;						// SpareSize
+	unsigned short int			PPages;							// Total Partial Pages [ 512+16Bytes ]
+	unsigned short int  		ShiftPpB;						// Shift Factor of Pages Per Block
+	unsigned short int			ShiftPPages;					// Shift Factor of Total Partial Pages
+
+	unsigned long int			RwAreaStBlk;					// RW Area Start Block Addr
+	unsigned long int			RwAreaEdBlk;					// RW Area End Block Addr
+	unsigned long int			ROAreaSize;						// RO Area Size
+	unsigned long int			ROAreaStPB;
+	unsigned long int			ROAreaBlkNum;
+	unsigned short int			RWAreaFormatFlag;
+
+	unsigned short int  		MPlanePpB;						// FTLInfo->PpB >> FTLInfo->ShiftMPlane
+	unsigned short int  		ILMPlanePpB;					// FTLInfo->PpB >> 2
+	unsigned short int			MPlane;							// Multi Plane Num
+	unsigned short int			ShiftMPlane;					// Shift Factor of Multi Plane
+	unsigned long int 			RoundMPlane;
+	unsigned long int 			RemainMPlane;
+	unsigned long int 			LPTBufferSize;
+
+	unsigned short int			LPT_Values_1Page;
+	unsigned short int			LPT_Values_1Page_Shift;
+	unsigned short int			LPT_Pages_1Block;
+	unsigned short int			LPT_Pages_1Block_Shift;
+	unsigned short int			LPT_Block_PPage;
+
+	unsigned short int			FTLBadBlockStatus;
+	unsigned long int			FTLBadBlockNum;
+	unsigned long int			FTLBadBlock[TNFTL_MAX_VALID_BAD_BLOCK_PER_1ZONE * TNFTL_MAX_SUPPORT_ZONE];
+
+	unsigned short int			MediaNums;
+	unsigned short int			ShiftMediaNums;
+	unsigned short int			MediaBadBlockNum[TNFTL_MAX_SUPPORT_MULTI_NANDFLASH];
+
+	unsigned short int			ECCStatus;
+
+	unsigned char				MediaSizeOfSerialID;
+	unsigned char				MediaSizeOfUniqueID;
+	unsigned char				MediaSerialID[TNFTL_MAX_NANDFLASH_SID_SIZE];
+	unsigned char				MediaUniqueID[TNFTL_MAX_NANDFLASH_UID_SIZE];
+	unsigned long int			MediaTotalFTLPageAddr[TNFTL_MAX_SUPPORT_MULTI_NANDFLASH];
+	unsigned long int			MediaTotalFTLBlkAddr[TNFTL_MAX_SUPPORT_MULTI_NANDFLASH];
+	unsigned short int			MediaRatioPSize[TNFTL_MAX_SUPPORT_MULTI_NANDFLASH];
+	unsigned short int			MediaRatioBSize[TNFTL_MAX_SUPPORT_MULTI_NANDFLASH];
+	unsigned short int			MediaRatioShiftPSize[TNFTL_MAX_SUPPORT_MULTI_NANDFLASH];
+	unsigned short int			MediaRatioShiftBSize[TNFTL_MAX_SUPPORT_MULTI_NANDFLASH];
+	unsigned long int 			StPBForGetEmptyPB[TNFTL_MAX_SUPPORT_MULTI_PLANE];
+	NAND_IO_DEVINFO				MediaDevInfo[TNFTL_MAX_SUPPORT_MULTI_NANDFLASH];
+
+	unsigned char				*FTLPageBuffer;
+	unsigned char				*AlignCacheBuffer;
+	unsigned int				*LPTBuffer;
+	
+} TNFTL_DRVINFO;
+
+//*****************************************************************************
+//*
+//*
+//*                       [ EXTERNAL VARIABLE DEFINE ]
+//*
+//*
+//*****************************************************************************
+
+
+
+//*****************************************************************************
+//*
+//*
+//*                       [ EXTERNAL FUCTIONS DEFINE ]
+//*
+//*
+//*****************************************************************************
+extern TNFTL_ERROR				TNFTL_AllocMemAndLinkForDriver( U16 nDrvNo, TNFTL_DRVINFO *nMDrvInfo, TNFTL_DRVINFO **nPDrvInfo );
+extern TNFTL_ERROR				TNFTL_AllocMemAndLinkForLPT( U16 nDrvNo, TNFTL_RW_AREA *nArea, TNFTL_LPT_BLOCK *nLptTableBlk, U32 nLptTableBlkSize );
+extern TNFTL_ERROR				TNFTL_AllocMemAndLinkForWCACHE( U16 nDrvNo, TNFTL_RW_AREA *nArea, TNFTL_WCACHE *nWCaches, U32 nWCacheNum );
+extern TNFTL_ERROR 				TNFTL_AllocMemAndLinkForRCACHE( U16 nDrvNo, TNFTL_RW_AREA *nArea, TNFTL_RCACHE_SLOT *nRCacheSlots );
+
+extern TNFTL_ERROR 				TNFTL_AllocMemAndLinkForMainPBInfo( U16 nDrvNo, TNFTL_RW_AREA *nArea, TNFTL_MAINPB_INFO *nMainPBInfo, U32 nMainPBInfoNum );
+extern TNFTL_ERROR				TNFTL_AllocMemAndLinkForPageBuffer( U16 nDrvNo, U8 *nPageBuffer );
+extern TNFTL_ERROR 				TNFTL_AllocMemAndLinkForRCacheBuffer( U16 nDrvNo, TNFTL_RW_AREA *nArea, U8 *nPageBuffer, U32 nBufferSize );
+extern TNFTL_ERROR 				TNFTL_AllocMemAndLinkForAlignCacheBuffer( U16 nDrvNo, U8 *nPageBuffer, U32 nBufferSize );
+
+extern TNFTL_ERROR				TNFTL_AllocMemAndLinkForMakeLPT( U16 nDrvNo, U32 *nLPTBuffer, U32 nBufferSize );
+extern TNFTL_ERROR 				TNFTL_AllocMemAndLinkForExtendedPartition( U16 nDrvNo, TNFTL_RW_AREA *nArea );
+extern TNFTL_ERROR				TNFTL_SetStEdOfCS( U16 nDrvNo, U16 nStartCS, U16 nEndCS );
+extern TNFTL_ERROR				TNFTL_SetExtendedPartitionNums( U16 nDrvNo, U16 nExtPartitionNums );
+
+extern void 					TNFTL_SetNBAreaEndPBAddr( int nPhyBlockAddr );
+extern void 					TNFTL_SetROAreaSize(TNFTL_DRVINFO * FTLInfo, int nROAreaSize, int nROAreaUsable);
+extern void						TNFTL_SetAreaProtectFlag( int value );
+
+extern void						TNFTL_DEBUG_Init( void );
+extern void 					TNFTL_DEBUG_Init_Function( TNFTL_FUNC1 nFUNC1, TNFTL_FUNC2 nFUNC2, TNFTL_FUNC2 nFUNC3, TNFTL_FUNC2 nFUNC4,	TNFTL_FUNC2 nFUNC5,	TNFTL_FUNC3 nFUNC6, TNFTL_FUNC1 nFUNC7,	TNFTL_FUNC1 nFUNC8);
+
+extern TNFTL_ERROR 				TNFTL_DEBUG_VTCParser( void* nVTCCmd );
+extern void						TNFTL_Init( U16 nDrvNo );
+extern TNFTL_ERROR				TNFTL_InitDrive( TNFTL_DRVINFO *FTLInfo );
+extern TNFTL_ERROR				TNFTL_CheckIsExistBMP( TNFTL_DRVINFO *FTLInfo );
+
+extern TNFTL_ERROR 				TNFTL_AlignCacheFlush( TNFTL_DRVINFO *FTLInfo );
+
+extern U32						TNFTL_AREAGetTotalSectorSize( TNFTL_DRVINFO *FTLInfo, TNFTL_RW_AREA *nArea );
+extern TNFTL_ERROR				TNFTL_AREAGetTotalSecAndCHS( TNFTL_DRVINFO *FTLInfo, TNFTL_RW_AREA *nArea, U32 *rTotalSec, U16 *rCylinder, U16 *rHead, U8 *rSector );
+extern TNFTL_ERROR				TNFTL_AREASetTotalSectorSize( TNFTL_DRVINFO *FTLInfo, TNFTL_RW_AREA *nArea, U32 nTotalSectorSize );
+extern TNFTL_ERROR				TNFTL_AREAReadSectorBy4Byte( TNFTL_DRVINFO *FTLInfo, TNFTL_RW_AREA *nArea, U32 nSectorAddr, U16 nOffset, U16 nReadSize, U8 *nReadBuffer );
+extern TNFTL_ERROR				TNFTL_AREAReadSector( TNFTL_DRVINFO *FTLInfo, TNFTL_RW_AREA *nArea, U32 nSectorAddr, U32 nSecSize, U8 *nReadBuffer );
+extern TNFTL_ERROR				TNFTL_AREAWriteSector( TNFTL_DRVINFO *FTLInfo, TNFTL_RW_AREA *nArea, U32 nSectorAddr, U32 nSecSize, U8 *nWriteBuffer );
+extern TNFTL_ERROR				TNFTL_AREAFormat( TNFTL_DRVINFO *FTLInfo, TNFTL_RW_AREA *nArea, U16 nFormatLevel );
+extern TNFTL_ERROR				TNFTL_NBGetCRCOfImageFile( TNFTL_DRVINFO *FTLInfo, U32 nFlagSelfChecking, U32 *nOrgCRCcode1, U32 *nOrgCRCcode2, U32 *nRomFileSize, U32 *rRstCRCcode1, U32 *rRstCRCcode2 );
+extern TNFTL_ERROR 				TNFTL_NBGetCRCValueOfImageFile( TNFTL_DRVINFO *FTLInfo, U32 *nOrgCRCcode1, U32 *nOrgCRCcode2, U32 *nRomFileSize );
+extern TNFTL_ERROR				TNFTL_NBGetSizeOfImageFile( TNFTL_DRVINFO *FTLInfo, U32 *nRomFileSize ) ;
+extern void					 	TNFTL_WCacheSetDataStartSector( TNFTL_DRVINFO *FTLInfo, TNFTL_RW_AREA *nArea, unsigned int nDataStartSector );
+
+extern U16						TNFTL_GetSerialNumber( TNFTL_DRVINFO *FTLInfo, U8* rSerialNumber, U16 nSize );
+extern void 					TNFTL_SetFlagOfChangePartition( TNFTL_DRVINFO *FTLInfo, U16 on_off );
+
+
+extern TNFTL_ERROR 				TNFTL_IOReadPhyPage( TNFTL_DRVINFO *FTLInfo, U32 nBlkAddr, U32 nPageAddr, U16 nCSorder, U8 *nReadBuffer );
+extern __inline TNFTL_ERROR		TNFTL_IOReadSpare( TNFTL_DRVINFO *FTLInfo, U32 nFTLPageAddr, U8 *nSpareBuffer );
+extern __inline TNFTL_ERROR		TNFTL_IOReadPage( TNFTL_DRVINFO *FTLInfo, U32 nFTLPageAddr, U16 nStartPPage, U16 nReadPPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+extern __inline TNFTL_ERROR		TNFTL_IOReadPageForSignature( TNFTL_DRVINFO *FTLInfo, U32 nFTLPageAddr, U16 nStartPPage, U16 nReadPPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+
+extern __inline TNFTL_ERROR		TNFTL_IOReadTwoPlanePage( TNFTL_DRVINFO *FTLInfo, U32 nFTLPageAddr, U16 nStartPPage, U16 nReadPPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nReadOption, int nEccOnOff );
+extern __inline TNFTL_ERROR		TNFTL_IOReadTwoPlaneLastPage( TNFTL_DRVINFO *FTLInfo, U32 nFTLPageAddr, U16 nStartPPage, U16 nReadPPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+extern __inline TNFTL_ERROR		TNFTL_IOReadUserSizePage( TNFTL_DRVINFO *FTLInfo, U32 nFTLPageAddr, U16 nColumnAddr, U32 nReadSize, U8 *nReadBuffer );
+extern __inline TNFTL_ERROR		TNFTL_IOWritePage( TNFTL_DRVINFO *FTLInfo, U32 nFTLPageAddr, U16 nStartPPage, U16 nWritePPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+extern __inline TNFTL_ERROR		TNFTL_IOWriteTwoPlanePage( TNFTL_DRVINFO *FTLInfo, U32 nFTLPageAddr, U16 nStartPPage, U16 nWritePPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+extern __inline TNFTL_ERROR		TNFTL_IOWriteTwoPlaneLastPage( TNFTL_DRVINFO *FTLInfo, U32 nFTLPageAddr, U16 nStartPPage, U16 nWritePPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int LastPage, int nEccOnOff );
+extern __inline TNFTL_ERROR		TNFTL_IOWriteCachePage( TNFTL_DRVINFO *FTLInfo, U32 nFTLPageAddr, U16 nStartPPage, U16 nWritePPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+extern __inline TNFTL_ERROR		TNFTL_IOWriteCacheLastPage( TNFTL_DRVINFO *FTLInfo, U32 nFTLPageAddr, U16 nStartPPage, U16 nWritePPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+extern __inline TNFTL_ERROR		TNFTL_IOWriteUserSizePage( TNFTL_DRVINFO *FTLInfo, U32 nFTLPageAddr, U16 nColumnAddr, U32 nWriteSize, U8 *nWriteBuffer );
+extern __inline TNFTL_ERROR		TNFTL_IOWriteSpare( TNFTL_DRVINFO *FTLInfo, U32 nFTLPageAddr, U8 *nSpareBuffer );
+
+extern __inline TNFTL_ERROR		TNFTL_IOCopyBackPage( TNFTL_DRVINFO *FTLInfo, U32 nDesFTLPageAddr, U32 nSrcFTLPageAddr, U8 *nPageBuffer, U8 *nSpareBuffer );
+extern __inline TNFTL_ERROR		TNFTL_IOEraseBlock( TNFTL_DRVINFO *FTLInfo, U32 nFTLBlkAddr, int nFormatMode );
+extern __inline TNFTL_ERROR		TNFTL_IOCopyBackTwoPlanePage( TNFTL_DRVINFO *FTLInfo, U32 nDesFTLPageAddr, U32 nSrcFTLPageAddr, U8 *nPageBuffer, U8 *nSpareBuffer );
+
+extern TNFTL_ERROR 				TNFTL_GoldenPageWrite( TNFTL_DRVINFO *FTLInfo, U32 nStarAddr, U32 nWriteByteSize, U8 *nPageBuffer );
+extern TNFTL_ERROR 				TNFTL_GoldenPageRead( TNFTL_DRVINFO *FTLInfo, U32 nStarAddr, U32 nReadByteSize, U8 *nPageBuffer );
+extern U32 						TNFTL_SizeofGoldenPage( TNFTL_DRVINFO *FTLInfo );
+
+extern TNFTL_ERROR				TNFTL_SetCallBackHandler( TNFTL_CALLBACK_HANDLER pCallBackHandler );
+extern TNFTL_ERROR				TNFTL_SetUartDebug( unsigned int on_off );
+extern TNFTL_ERROR				TNFTL_BMPRefresh( TNFTL_DRVINFO *FTLInfo );
+
+extern TNFTL_ERROR				TNFTL_SetUseAreaReadCacheMode( TNFTL_DRVINFO *FTLInfo, TNFTL_RW_AREA *nArea, unsigned int on_off );
+extern TNFTL_ERROR 				TNFTL_SetUseAlignCacheMode( TNFTL_DRVINFO *FTLInfo, unsigned int on_off );
+
+
+#endif
+
diff --git a/drivers/block/tcc/init_ddr2.c b/drivers/block/tcc/init_ddr2.c
new file mode 100644
index 0000000..a964ecd
--- /dev/null
+++ b/drivers/block/tcc/init_ddr2.c
@@ -0,0 +1,1008 @@
+/****************************************************************************
+ *   FileName    : init_MEM.c
+ *   Description : Init code for TCC8900 DDRAM
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+#if defined(_WINCE_)
+#include "bsp.h"
+#elif defined(_LINUX_)
+#include <common.h>
+#include <def_tcc.h>
+#endif
+
+#if defined(DRAM_DDR2)
+
+#define	repeat(n) { volatile int i; for (i=0; i<=n; i++); }
+#define DDR_DELAY	1
+/****************************************************************************************
+* FUNCTION :void InitRoutine_Start(void)
+* DESCRIPTION :
+* ***************************************************************************************/
+	/*-------------------
+	   PLL0   m      p    s
+	  ------------------
+	   600    200   2     1
+	   500    250   3     1
+	   480    160   2     1
+	   480	  400	3	  2
+	---------------------*/
+	/*-------------------
+	   PLL1   m 	 p	  s
+	  ------------------
+	   560	  140	3	  0
+	   520	  130	3	  0
+	   500	  125	3	  0
+	   480	  40	1	  0
+	---------------------*/
+#pragma optimize( "g", off )
+
+volatile void InitRoutine_Start(void)
+{
+	volatile int i;
+	// 44.0 ms
+	//Enter Mode		
+		*(volatile unsigned long *)0xF0302004 = 0x00000003; // PL341_PAUSE
+		while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+	
+		*(volatile unsigned long *)0xF0302004 = 0x00000004; // PL341_Configure
+		while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+	// DLL OFF
+		*(volatile unsigned long *)0xF0304404 &=  ~(0x00000003);	 // DLL-0FF,DLL-Stop running
+		*(volatile unsigned long *)0xF0304428 &= ~(0x00000003); // Calibration Start,Update Calibration
+		*(volatile unsigned long *)0xF030302c &=  ~(0x00004000);  //SDRAM IO Control Register Gatein Signal Power Down
+			
+		i = 1600;
+		while(i)
+			i--;
+		// 37.7 ms
+		*(volatile unsigned long *)0xF0400030 = 0x01010101;
+		*(volatile unsigned long *)0xF0400034 = 0x01010101;
+	
+		*(volatile unsigned long *)0xF0400000 = 0x002ffff4; // XI - corebus
+		*(volatile unsigned long *)0xF0400008 = 0x00200014; // XI - memebus
+//PLL0
+		*(volatile unsigned long *)0xf0400020= 0x0000fa03; // pll pwr off
+		*(volatile unsigned long *)0xF0400020= 0x0100C802; // pms - pllout_600M
+		*(volatile unsigned long *)0xF0400020= 0x8100C802; //	pll pwr on	
+
+//PLL1
+		*(volatile unsigned long *)0xF0400024= 0x0000fa03; // pll pwr off
+		*(volatile unsigned long *)0xF0400024= 0x00008c03; // pms - pllout_560M
+		*(volatile unsigned long *)0xF0400024= 0x80008c03; //	pll pwr on
+
+		//PLL2
+		*(volatile unsigned long *)0xF0400028= 0x0000fa03; // pll pwr off
+		*(volatile unsigned long *)0xF0400028= 0x00002701; // pms - pllout_468M
+		*(volatile unsigned long *)0xF0400028= 0x80002701; //	pll pwr on
+
+		i = 3200;
+		while(i)
+			i--;
+		*(volatile unsigned long *)0xF0400000 = 0x002AAAA0; // 300Mhz
+		*(volatile unsigned long *)0xF0400008 = 0x00200030; // 150Mhz
+		*(volatile unsigned long *)0xF0400010 = 0x00200022; // CKC-CLKCTRL4 - I/O BUS
+		i = 3200;
+		while(i)
+			i--;
+
+		*(volatile unsigned long *) 0xf0302004=0x00000003; // PL341_PAUSE
+		*(volatile unsigned long *) 0xf0302004=0x00000004; // PL341_CONFIGURE
+
+// memory arb.
+		*(volatile unsigned long *) 0xf030200c=0x00140000; // config0 - qos master bits set
+// memory arb. end
+	// Samsung/ Hynix	
+		*(volatile unsigned long *)0xF030200C = 0x00150012; 		// config0 cas 10bit, ras 13bit
+	// ELPIDA 256MB
+	//	*(volatile unsigned long *)0xF030200C = 0x0015001A; 		// config0 cas 10bit, ras 14bit
+			
+		*(volatile unsigned long *) 0xf0302010=0x00000445; // refresh
+#if defined(DRAM_BANK3)
+		*(volatile unsigned long *) 0xf030204c=0x00000571; // config2 - SOC
+#else
+		*(volatile unsigned long *) 0xf030204c=0x00000541; // config2 - SOC
+#endif		
+
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *) 0xf0302014=0x0000000C; // cas_latency
+#else
+		*(volatile unsigned long *) 0xf0302014=0x0000000A; // cas_latency
+#endif		
+
+		*(volatile unsigned long *) 0xf030201c=0x00000003; // tMRD
+
+		//New
+		// 1 Tick = 2.5ns
+		*(volatile unsigned long *)0xF0302020 = 0x0000000D; // tRAS - 45ns
+		*(volatile unsigned long *)0xF0302024 = 0x00000011; // tRC	- 60ns
+		*(volatile unsigned long *)0xF0302028 = 0x00000205; // tRCD - 15ns
+		*(volatile unsigned long *)0xF030202c = 0x00001B1E; // tRFC - 105ns
+		*(volatile unsigned long *)0xF0302030 = 0x00000205; // tRP	- 15ns
+		*(volatile unsigned long *)0xF0302034 = 0x00000005; // tRRD
+		*(volatile unsigned long *)0xF0302038 = 0x00000006; // tWR
+		*(volatile unsigned long *)0xF030203c = 0x00000003; // tWTR
+		*(volatile unsigned long *)0xF0302040 = 0x00000003; // tXP
+		*(volatile unsigned long *)0xF0302044 = 0x00000022; // tXSR
+		*(volatile unsigned long *)0xF0302048 = 0x000000FA; // tESR
+		*(volatile unsigned long *)0xF0302054 = 0x00001619; // tFAW
+
+		//i = 3200;
+		//while(i)
+		//	i--;
+		*(volatile unsigned long *) 0xf0302200=0x000040f0; // config_chip0 - CS0 - 0x40000000~0x47ffffff
+
+		i = 3200;
+		while(i)
+			i--;
+		*(volatile unsigned long *)0xF0302004 = 0x00000003; // PL341_PAUSE
+		while (((*(volatile unsigned long *)0xf0302000) & (0x03)) != 2);	// Wait until PAUSE
+		
+		*(volatile unsigned long *)0xF0302004 = 0x00000001; // PL341_SLEEP
+		while (((*(volatile unsigned long *)0xf0302000) & (0x03)) != 3);	// Wait until SLEEP
+
+		//*(volatile unsigned long *) 0xf030302c=0x00004000; // SSTL
+		*(volatile unsigned long *)0xF030302C = 0x7FFF; 		// SSTL SDRAM IO Control Register 
+
+		 // - SOC
+	//	 *(volatile unsigned long *) 0xf0303004 |= 0x00800000; // bit23 enable -synopt enable
+		
+		*(volatile unsigned long *) 0xf0303020=0x00010103; // emccfg_config0
+		*(volatile unsigned long *) 0xf0303024=0x00000000; // phyctrl
+		*(volatile unsigned long *) 0xf0304400=0x00000000; // DDR2PHY_PHYMODE
+		*(volatile unsigned long *) 0xf0304404=0x00000001; // DLLCTRL - DLL ON
+		*(volatile unsigned long *) 0xf0304408=0x00001717; // DLLPDCFG (200Mhz)
+		*(volatile unsigned long *) 0xf0304404=0x00000003; // DLLCTRL - DLL ON, DLL start
+		while (!((*(volatile unsigned long *)0xF0304404) & (3<<3)));	// Wait until PDFL == 1
+		
+		*(volatile unsigned long *) 0xf0304424=0x00000035; // DLLFORCELOCK
+		*(volatile unsigned long *) 0xf030440c=0x00000006; // GATECTRL
+	#if defined(DRAM_CAS6)
+		*(volatile unsigned long *) 0xf0304430=0x00000006; // RDDELAY - SOC
+	#else
+		*(volatile unsigned long *) 0xf0304430=0x00000005; // RDDELAY - SOC
+	#endif
+	
+	#if defined(DRAM_ODTOFF)
+		*(volatile unsigned long *) 0xf0304428=0x00069151; // ZQCTRL
+	#else
+		*(volatile unsigned long *) 0xf0304428=0x00068151; // ZQCTRL
+	#endif
+		while (!((*(volatile unsigned long *)0xF030442c) & (1)));	// Wait until Calibration completion without error
+		
+	#if defined(DRAM_ODTOFF)
+		*(volatile unsigned long *) 0xf0304428=0x00069153; // ZQCTRL
+	#else
+		*(volatile unsigned long *) 0xf0304428=0x00068153; // ZQCTRL
+	#endif
+		i = 3200;
+		while(i)
+			i--;
+	#if defined(DRAM_ODTOFF)
+		*(volatile unsigned long *) 0xf0304428=0x00069151; // ZQCTRL
+	#else
+		*(volatile unsigned long *) 0xf0304428=0x00068151; // ZQCTRL
+	#endif
+		//i = 3200;
+		//while(i)
+		//	i--;
+		
+		*(volatile unsigned long *)0xF0302004 = 0x00000002; // PL34X_WAKEUP
+		while (((*(volatile unsigned long *)0xf0302000) & (0x03)) != 2);	// Wait until PAUSE
+	
+		*(volatile unsigned long *)0xF0302004 = 0x00000004; // PL341_CONFIGURE
+		while (((*(volatile unsigned long *)0xf0302000) & (0x03)) != 0);	// Wait until CONFIGURE		
+// CS0 Command Initialize...
+		*(volatile unsigned long *) 0xf0302008=0x000c0000; // dir_cmd
+		*(volatile unsigned long *) 0xf0302008=0x00000000; // dir_cmd
+		*(volatile unsigned long *)0xF0302008 = 0x00040000; // Direct COmmnad Register 
+		*(volatile unsigned long *)0xF0302008 = 0x00040000; // Direct COmmnad Register 
+		*(volatile unsigned long *) 0xf0302008=0x000a0000; // dir_cmd
+		*(volatile unsigned long *) 0xf0302008=0x000b0000; // dir_cmd
+		*(volatile unsigned long *) 0xf0302008=0x00090000; // dir_cmd
+		
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *) 0xf0302008=0x00080962; // dir_cmd - SOC
+#else
+		*(volatile unsigned long *) 0xf0302008=0x00080952; // dir_cmd - SOC
+#endif		
+		*(volatile unsigned long *) 0xf0302008=0x00000000; // dir_cmd
+
+		// repeat 100
+		i = 100;
+		while(i)
+		{
+			*(volatile unsigned long *) 0xf0302008=0x00040000; // dir_cmd
+			i--;
+		}
+		// repeat end
+
+#if defined(DRAM_CAS6)
+		*(volatile unsigned long *) 0xf0302008=0x00080862; // dir_cmd
+#else
+		*(volatile unsigned long *) 0xf0302008=0x00080852; // dir_cmd
+#endif		
+	#if defined(DRAM_ODTOFF)
+
+	#else
+		*(volatile unsigned long *) 0xf0302008=0x00090380; // dir_cmd
+		//*(volatile unsigned long *) 0xf0302008=0x00090000; // dir_cmd
+		*(volatile unsigned long *) 0xf0302008=0x00090004; // dir_cmd	//soc1-3
+	#endif
+
+		*(volatile unsigned long *) 0xf0302004=0x00000000; // PL341_GO
+}
+#pragma optimize( "g", on )
+
+volatile void InitRoutine_End(void)
+{
+
+}
+
+#if !defined(NKUSE) && !defined(__KERNEL__)
+/*=========================================================================================================================
+*
+*										Used Boot Loader
+*
+==========================================================================================================================*/
+void init_clock(void)
+{
+	PCKC		lCKC = (CKC *)&HwCLK_BASE;
+	PPMU		lPMU = (PMU *)&HwPMU_BASE;
+	PNTSCPAL	lNTSCPAL=(PNTSCPAL)&HwTVE_BASE;
+	volatile unsigned int nCount = 0;
+
+	tca_ckc_init(); 
+	
+	// Set PLL - default PLL: PLL1,PLL2,PLL3 Disable
+	// Change PLL Value
+	tca_ckc_setpll(4680000,2); // 240 *2 100hz -SDMMC
+	tca_ckc_setpll(5280000,3); // 156 *2 100hz	
+	
+	//CLKDIVC0/1
+	lCKC->CLKDIVC	= 0x01010101;
+	lCKC->CLKDIVC1	= 0x01010101;
+
+#if defined(TCC_R_AX)
+	tca_ckc_setswreset(RESET_VIDEOBUS, ON);
+	tca_ckc_setswreset(RESET_VIDEOCORE, ON);
+	#if !defined(TCC_MAX_FGRP_INCLUDE)
+	tca_ckc_setswreset(RESET_GRAPBUS, ON);
+	#endif
+#endif
+
+	tca_ckc_setfbusctrl(CLKCTRL1,ENABLE,NORMAL_MD,2640000,DIRECTPLL3);/*FBUS_DDI		240 MHz*/
+	tca_ckc_setfbusctrl(CLKCTRL4,ENABLE,NORMAL_MD,1560000,DIRECTPLL2);/*FBUS_IOB		166 MHz */
+#if defined(TCC_R_AX)
+	tca_ckc_setfbusctrl(CLKCTRL5,DISABLE,NORMAL_MD,60000,DIRECTXIN);/*FBUS_VBUS		215 MHz */ //2640000 , 1760000
+	tca_ckc_setfbusctrl(CLKCTRL6,DISABLE,NORMAL_MD,60000,DIRECTXIN);/*FBUS_VCODEC	160 MHz */ //2340000 , 1560000
+#else
+	tca_ckc_setfbusctrl(CLKCTRL5,ENABLE,NORMAL_MD,60000,DIRECTXIN);/*FBUS_VBUS		215 MHz */ //2640000 , 1760000
+	tca_ckc_setfbusctrl(CLKCTRL6,ENABLE,NORMAL_MD,60000,DIRECTXIN);/*FBUS_VCODEC	160 MHz */ //2340000 , 1560000
+#endif
+	
+
+#if defined(FMBUS_330MHZ_INCLUDE) ||  defined(FMBUS_360MHZ_INCLUDE) || defined(FMBUS_400MHZ_INCLUDE)
+#if defined(TCC_R_AX)
+	#if defined(TCC_MAX_FGRP_INCLUDE)
+		tca_ckc_setfbusctrl(CLKCTRL3,ENABLE,NORMAL_MD,2640000,DIRECTPLL3);/*FBUS_GRP		*/
+	#else
+		tca_ckc_setfbusctrl(CLKCTRL3,DISABLE,NORMAL_MD,60000,DIRECTXIN);/*FBUS_GRP		*/
+	#endif
+#else
+		tca_ckc_setfbusctrl(CLKCTRL3,ENABLE,NORMAL_MD,2640000,DIRECTPLL3);/*FBUS_GRP		*/
+#endif
+	tca_ckc_setfbusctrl(CLKCTRL7,ENABLE,NORMAL_MD,1760000,DIRECTPLL3);/*FBUS_SMU		*/
+#else
+#if defined(TCC_R_AX)
+	#if defined(TCC_MAX_FGRP_INCLUDE)
+		tca_ckc_setfbusctrl(CLKCTRL3,ENABLE,NORMAL_MD,2340000,DIRECTPLL2);/*FBUS_GRP		190 MHz */
+	#else
+		tca_ckc_setfbusctrl(CLKCTRL3,DISABLE,NORMAL_MD,60000,DIRECTXIN);/*FBUS_GRP		190 MHz */
+	#endif
+#else
+		tca_ckc_setfbusctrl(CLKCTRL3,ENABLE,NORMAL_MD,2340000,DIRECTPLL2);/*FBUS_GRP		190 MHz */
+#endif
+	tca_ckc_setfbusctrl(CLKCTRL7,ENABLE,NORMAL_MD,1170000,DIRECTPLL2);/*FBUS_SMU		125 MHz */
+#endif
+
+	// Enable Peri.
+	lPMU->CONTROL	|= Hw16;		// Touch ADC Power Enable
+	nCount = 10;	
+	for ( ; nCount > 0 ; nCount --);		// delay
+	lNTSCPAL->DACPD |= Hw0;
+	
+	lPMU->PWROFF	&= ~Hw0;			// Video Dac(TVOUT)
+	nCount = 500;	
+	for ( ; nCount > 0 ; nCount --);		// delay
+	lPMU->PWROFF	|=(Hw0			
+						|Hw1		// HDMI PHY
+						|Hw2		// LVDS
+						|Hw4		//SATA PHY
+#if defined(TCC_R_AX)
+						|Hw6		// Video Bus
+						#if !defined(TCC_MAX_FGRP_INCLUDE)
+						|Hw8
+						#endif
+#endif
+	); // HDMI Phy,LVDS Phy,SATA Phy , Video Bus , Graphic Bus 
+	
+#if defined(TCC_R_AX)
+	tca_ckc_setswreset(RESET_VIDEOCORE, OFF);
+	tca_ckc_setswreset(RESET_VIDEOBUS, OFF);
+	#if !defined(TCC_MAX_FGRP_INCLUDE)
+	tca_ckc_setswreset(RESET_GRAPBUS, OFF);
+	#endif
+#endif
+// init Peri. Clock
+	tca_ckc_setperi(PERI_TCZ,ENABLE,120000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_ADC,ENABLE,390000,PCDIRECTPLL2);
+	tca_ckc_setperi(PERI_I2C,ENABLE,40000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_UART0,ENABLE,520000,PCDIRECTPLL2); 
+	tca_ckc_setperi(PERI_LCD1,ENABLE,1560000,PCDIRECTPLL2);
+
+	tca_ckc_setperi(PERI_LCD0,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_LCDSI,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_CIFMC,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_CIFSC,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_OUT0,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_OUT1,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_HDMI,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_SDMMC0,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_MSTICK,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_UART1,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_UART2,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_UART3,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_UART4,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_UART5,ENABLE,10000,PCDIRECTXIN);
+
+	tca_ckc_setperi(PERI_GPSB0,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_GPSB1,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_GPSB2,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_GPSB3,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_GPSB4,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_GPSB5,ENABLE,10000,PCDIRECTXIN);
+
+//	tca_ckc_setperi(PERI_SPDIF,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_EHI0,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_EHI1,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_CAN,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_SDMMC1,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_DAI,ENABLE,10000,PCDIRECTXIN);
+
+// init Io Bus
+	tca_ckc_setiobus(RB_USB11H, DISABLE);	
+	tca_ckc_setiobus(RB_IDECONTROLLER, DISABLE);	
+	tca_ckc_setiobus(RB_SDMMCCONTROLLER, DISABLE);	
+	tca_ckc_setiobus(RB_SATAHCONTROLLER, DISABLE);	
+	tca_ckc_setiobus(RB_MEMORYSTICKCONTROLLER, DISABLE);	
+	tca_ckc_setiobus(RB_EXTHCONTROLLER0, DISABLE);	
+	tca_ckc_setiobus(RB_EXTHCONTROLLER1, DISABLE);	
+	tca_ckc_setiobus(RB_UARTCONTROLLER1, DISABLE);	
+	tca_ckc_setiobus(RB_UARTCONTROLLER2, DISABLE);	
+	tca_ckc_setiobus(RB_UARTCONTROLLER3, DISABLE);	
+	tca_ckc_setiobus(RB_UARTCONTROLLER4, DISABLE);	
+	tca_ckc_setiobus(RB_UARTCONTROLLER5, DISABLE);	
+	tca_ckc_setiobus(RB_GPSBCONTROLLER0, DISABLE);	
+	tca_ckc_setiobus(RB_GPSBCONTROLLER1, DISABLE);	
+	tca_ckc_setiobus(RB_GPSBCONTROLLER2, DISABLE);	
+	tca_ckc_setiobus(RB_GPSBCONTROLLER3, DISABLE);	
+	tca_ckc_setiobus(RB_GPSBCONTROLLER4, DISABLE);	
+	tca_ckc_setiobus(RB_GPSBCONTROLLER5, DISABLE);	
+	tca_ckc_setiobus(RB_SPDIFTXCONTROLLER, DISABLE);	
+	tca_ckc_setiobus(RB_GPSCONTROLLER, DISABLE);	
+	tca_ckc_setiobus(RB_CANCONTROLLER, DISABLE);	
+	tca_ckc_setiobus(RB_MPE_FECCONTROLLER, DISABLE);	
+	tca_ckc_setiobus(RB_TSIFCONTROLLER, DISABLE);	
+//	tca_ckc_setiobus(RB_SRAMCONTROLLER, DISABLE);	
+
+// init ddi Pwdn
+	tca_ckc_setddipwdn(DDIPWDN_CIF, DISABLE);	
+	tca_ckc_setddipwdn(DDIPWDN_VIQE, DISABLE);	
+	tca_ckc_setddipwdn(DDIPWDN_LCDC0, DISABLE);	
+	tca_ckc_setddipwdn(DDIPWDN_MSCL0, DISABLE);	
+	tca_ckc_setddipwdn(DDIPWDN_MSCL1, DISABLE);	
+	tca_ckc_setddipwdn(DDIPWDN_HDMI, DISABLE);	
+	
+#if defined(_WINCE_)
+	enable_irq();
+#endif
+}
+
+/*	
+*	Example 
+* ------------------------------------------------------------------------------------------------------------------------------
+* define HIGH_VOLTAGE_CLOCK_INCLUDE
+*
+*	1. Core 600Mhz, Mem 400Mhz
+*		#define lpll0		800
+*		#define lpll1		660
+*		#define lmem_source 0	// 0 : PLL0 , 1 : PLL1
+*		#define lcore_div	12	// (lpll0 * lcore_div)/16 - refer DataSheet CKC Block
+*		#define lmem_div	2	// if lmem_source is 0, lpll0/lmem_div = Mem Bus /	if lmem_source is 0, lpll0/lmem_div = Mem Bus
+*
+*	2. Core 600Mhz, Mem 330Mhz
+*		#define lpll0		600
+*		#define lpll1		660
+*		#define lmem_source 1	// 0 : PLL0 , 1 : PLL1
+*		#define lcore_div	16	// (lpll0 * lcore_div)/16 - refer DataSheet CKC Block
+*		#define lmem_div	2	// if lmem_source is 0, lpll0/lmem_div = Mem Bus /	if lmem_source is 1, lpll1/lmem_div = Mem Bus
+*	3. Core 506Mhz, Mem 330Mhz
+*		#define lpll0		540
+*		#define lpll1		660
+*		#define lmem_source 1	// 0 : PLL0 , 1 : PLL1
+*		#define lcore_div	15	// (lpll0 * lcore_div)/16 - refer DataSheet CKC Block
+*		#define lmem_div	2	// if lmem_source is 0, lpll0/lmem_div = Mem Bus /	if lmem_source is 1, lpll1/lmem_div = Mem Bus
+* ------------------------------------------------------------------------------------------------------------------------------
+*	4. Core 600Mhz, Mem 280Mhz
+*		#define lpll0		600
+*		#define lpll1		560
+*		#define lmem_source 1	// 0 : PLL0 , 1 : PLL1
+*		#define lcore_div	16	// (lpll0 * lcore_div)/16 - refer DataSheet CKC Block
+*		#define lmem_div	2	// if lmem_source is 0, lpll0/lmem_div = Mem Bus /	if lmem_source is 1, lpll1/lmem_div = Mem Bus
+*
+*	5. Core 506Mhz, Mem 280Mhz
+*		#define lpll0		540
+*		#define lpll1		560
+*		#define lmem_source 1	// 0 : PLL0 , 1 : PLL1
+*		#define lcore_div	15	// (lpll0 * lcore_div)/16 - refer DataSheet CKC Block
+*		#define lmem_div	2	// if lmem_source is 0, lpll0/lmem_div = Mem Bus /	if lmem_source is 0, lpll0/lmem_div = Mem Bus
+* ------------------------------------------------------------------------------------------------------------------------------
+*/
+volatile void init_bootddr(void)
+{
+
+#if defined(FMBUS_400MHZ_INCLUDE)
+	#define lpll0		800
+	#define lpll1		540
+	#define lmem_source 0 
+
+// Core
+	#if defined(FCPU_506MHZ_INCLUDE)
+		#define lcore_div	10 
+	#elif defined(FCPU_600MHZ_INCLUDE)
+		#define lcore_div	12 
+	#else
+		#define lcore_div	10 
+	#endif	
+
+#elif defined(FMBUS_360MHZ_INCLUDE)  && defined(FCPU_720MHZ_INCLUDE)
+	#define lpll0		720
+	#define lpll1		540
+	#define lmem_source 0 
+
+// Core
+	#define lcore_div	16	
+
+#else // FMBUS 330 or 280 Mhz
+
+// Core
+	#if defined(FCPU_506MHZ_INCLUDE)
+		#define lpll0		540
+		#define lcore_div	15 // refer DataSheet CKC Block 
+	#elif defined(FCPU_600MHZ_INCLUDE)
+		#define lpll0		600
+		#define lcore_div	16 // refer DataSheet CKC Block 
+	#else
+		#define lpll0		540
+		#define lcore_div	15 // refer DataSheet CKC Block 
+	#endif
+// Mbus
+	#if defined(FMBUS_280MHZ_INCLUDE)
+		#define lpll1		560
+		#define lmem_source 1 // 0 : PLL0 , 1 : PLL1	
+	#elif defined(FMBUS_330MHZ_INCLUDE)
+		#define lpll1		660
+		#define lmem_source 1 // 0 : PLL0 , 1 : PLL1	
+	#elif defined(FMBUS_300MHZ_INCLUDE)
+		#define lpll1		540
+		#define lmem_source 0 // 0 : PLL0 , 1 : PLL1	
+	#else
+		#define lpll1		560
+		#define lmem_source 1 // 0 : PLL0 , 1 : PLL1	
+	#endif
+	
+#endif
+
+	#define lmem_div	2
+	volatile unsigned int i = 0;	
+	unsigned int ldiv = 0;
+	unsigned int lcycle = 0;
+    unsigned int lindex[17];
+	lindex[0] = 0x0;
+	lindex[1] = 0x8000;
+	lindex[2] = 0x8008;
+	lindex[3] = 0x8808;
+	lindex[4] = 0x8888;
+	lindex[5] = 0xA888;
+	lindex[6] = 0xA8A8;
+	lindex[7] = 0xAAA8;
+	lindex[8] = 0xAAAA;
+	lindex[9] = 0xECCC;
+	lindex[10] = 0xEECC;
+	lindex[11] = 0xEEEC;
+	lindex[12] = 0xEEEE;
+	lindex[13] = 0xFEEE;
+	lindex[14] = 0xFFEE;
+	lindex[15] = 0xFFFE;
+	lindex[16] = 0xFFFF;	
+
+//Enter Mode		
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xF0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xF0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xF030302c &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+		
+	i = 1600;
+	while(i)
+		i--;
+
+//Clock Change	
+	*(volatile unsigned long *)0xF0400030 = 0x01010101;
+	*(volatile unsigned long *)0xF0400034 = 0x01010101;
+	
+	*(volatile unsigned long *)0xF0400000 = 0x002ffff4; 		// XI - corebus
+	*(volatile unsigned long *)0xF0400008 = 0x00200014; 		// XI - memebus
+	
+	i = 2400;
+	while(i)
+		i--;
+	//PLL0
+	*(volatile unsigned long *)0xf0400020= 0x0000fa03;			// pll pwr off
+	if(lpll0 == 800)
+	{
+		*(volatile unsigned long *)0xF0400020= 0x01019003;		// pms - pllout_800M
+		*(volatile unsigned long *)0xF0400020= 0x81019003;		//	pll pwr on	
+	}
+	else if(lpll0 == 720)
+	{
+		*(volatile unsigned long *)0xF0400020= 0x0100F002;		// pms - pllout_720M
+		*(volatile unsigned long *)0xF0400020= 0x8100F002;		//	pll pwr on	
+	}
+	else if(lpll0 == 600)
+	{
+		*(volatile unsigned long *)0xF0400020= 0x0100C802;		// pms - pllout_600M
+		*(volatile unsigned long *)0xF0400020= 0x8100C802;		//	pll pwr on	
+	}
+	else if(lpll0 == 540)			
+	{
+		*(volatile unsigned long *)0xF0400020= 0x0100B402;		// pms - pllout_540M
+		*(volatile unsigned long *)0xF0400020= 0x8100B402;		//	pll pwr on	
+	}
+	else if(lpll0 == 400)			
+	{
+		*(volatile unsigned long *)0xF0400020= 0x02019003;		// pms - pllout_400M
+		*(volatile unsigned long *)0xF0400020= 0x82019003;		//	pll pwr on	
+	}
+	else if(lpll0 == 216)			
+	{
+		*(volatile unsigned long *)0xF0400020= 0x02009002;		// pms - pllout_216M
+		*(volatile unsigned long *)0xF0400020= 0x82009002;		//	pll pwr on	
+	}
+	else
+	{
+		*(volatile unsigned long *)0xF0400020= 0x0100C802;		// pms - pllout_600M
+		*(volatile unsigned long *)0xF0400020= 0x8100C802;		//	pll pwr on	
+	}
+	
+	//PLL1
+	*(volatile unsigned long *)0xF0400024= 0x0000fa03;			// pll pwr off
+	if(lpll1 == 660)
+	{
+		*(volatile unsigned long *)0xF0400024= 0x00006E02;		// pms - pllout_660M
+		*(volatile unsigned long *)0xF0400024= 0x80006E02;		//	pll pwr on
+	}
+	else if(lpll1 == 560)
+	{
+		*(volatile unsigned long *)0xF0400024= 0x00008c03;		// pms - pllout_560M
+		*(volatile unsigned long *)0xF0400024= 0x80008c03;		//	pll pwr on
+	}
+	else if(lpll1 == 540)
+	{
+		*(volatile unsigned long *)0xF0400024= 0x00002D01;		// pms - pllout_540M
+		*(volatile unsigned long *)0xF0400024= 0x80002D01;		//	pll pwr on
+	}
+	else if(lpll1 == 282)
+	{
+		*(volatile unsigned long *)0xF0400024= 0x01002F01;		// pms - pllout_560M
+		*(volatile unsigned long *)0xF0400024= 0x81002F01;		//	pll pwr on
+	}
+	else
+	{
+		*(volatile unsigned long *)0xF0400024= 0x00008c03;		// pms - pllout_560M
+		*(volatile unsigned long *)0xF0400024= 0x80008c03;		//	pll pwr on
+	}
+
+	i = 3200;
+	while(i)
+		i--;
+	*(volatile unsigned long *)0xF0400000 = (0x00200000 | (lindex[lcore_div] << 4));		// CKC-CLKCTRL0 - Core
+	*(volatile unsigned long *)0xF0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+	i = 3200;
+	while(i)
+		i--;
+
+//Init DDR2 
+	*(volatile unsigned long *) 0xf0302004=0x00000003;			// PL341_PAUSE
+	*(volatile unsigned long *) 0xf0302004=0x00000004;			// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+// memory arb.
+	*(volatile unsigned long *)0xF030200C |= 0x00140000; 
+/*
+	*(volatile unsigned long *) 0xf0302100=0x0000002b; // (10<<2)(1<<1)(1<<0) - video codec + jpeg encoder
+	*(volatile unsigned long *) 0xf0302104=0x0000002b; // (10<<2)(1<<1)(1<<0) - video cache + jpeg decoder
+	*(volatile unsigned long *) 0xf0302108=0x00000017; // (5<<2)(1<<1)(1<<0) - video codec secondary
+	*(volatile unsigned long *) 0xf030210c=0x00000017; // (5<<2)(1<<1)(1<<0) - io bus
+	*(volatile unsigned long *) 0xf0302110=0x0000000f; // (3<<2)(1<<1)(1<<1) - lcd
+	*(volatile unsigned long *) 0xf0302114=0x0000000f; // (3<<2)(1<<1)(1<<1) - lcd_mscl
+	*(volatile unsigned long *) 0xf0302118=0x00000017; // (5<<2)(1<<1)(1<<1) - VIQE
+	*(volatile unsigned long *) 0xf030211c=0x00000007; // (1<<2)(1<<1)(1<<1) - ddi cache
+	*(volatile unsigned long *) 0xf0302124=0x0000003f; // (15<<2)(1<<1)(1<<1) - ARM DMA bus
+	*(volatile unsigned long *) 0xf0302128=0x0000003f; // (15<<2)(1<<1)(1<<1) - ARM data bus
+	*(volatile unsigned long *) 0xf030212c=0x0000002b; // (10<<2)(1<<1)(1<<1) - ARM instruction
+	*(volatile unsigned long *) 0xf0302130=0x0000003f; // (15<<2)(1<<1)(1<<1) - overlay mixer
+	*(volatile unsigned long *) 0xf0302134=0x0000003f; // (15<<2)(1<<1)(1<<1) - overlay mixer
+	*(volatile unsigned long *) 0xf0302138=0x0000003f; // (15<<2)(1<<1)(1<<1) - overlay mixer
+	*(volatile unsigned long *) 0xf030213c=0x0000002b; // (10<<2)(1<<1)(1<<1) - 3d
+*/
+// memory arb. end
+	*(volatile unsigned long *) 0xF0303000 |= 0x80800000;		// bit23 enable -synopt enable
+	*(volatile unsigned long *) 0xF0303010 |= 0x80800000;		// bit23 enable -synopt enable
+	
+// Samsung/ Hynix	
+	*(volatile unsigned long *)0xF030200C = 0x00150012; 		// config0 cas 10bit, ras 13bit
+// ELPIDA 256MB
+//	*(volatile unsigned long *)0xF030200C = 0x0015001A; 		// config0 cas 10bit, ras 14bit
+
+	if(lmem_source == 1)
+	{
+		if((lpll1/lmem_div) == 330) 
+			*(volatile unsigned long *)0xf0302010 = 0x00000507; 	// refresh 
+		else
+			*(volatile unsigned long *)0xF0302010 = 0x00000445; 	// refresh 
+	}
+	else // Over Mem 330Mhz
+	{
+		*(volatile unsigned long *) 0xf0302010=0x00000618;		// refresh
+	}
+		
+#if defined(DRAM_BANK3)
+	*(volatile unsigned long *) 0xf030204c=0x00000571; // config2 - SOC
+#else
+	*(volatile unsigned long *) 0xf030204c=0x00000541; // config2 - SOC
+#endif		
+
+
+#if defined(DRAM_CAS6)
+	*(volatile unsigned long *) 0xf0302014=0x0000000C; // cas_latency
+#else
+	*(volatile unsigned long *) 0xf0302014=0x0000000A; // cas_latency
+#endif		
+				
+	*(volatile unsigned long *)0xF030201c = 0x00000003; 		// tMRD
+
+	//lcycle = 450/ldiv;
+	if(lmem_source == 0)
+        lcycle = 450/(10000/(lpll0/lmem_div));
+	else
+        lcycle = 450/(10000/(lpll1/lmem_div));
+	*(volatile unsigned long *)0xF0302020 = lcycle+DDR_DELAY; 			// tRAS - 45ns
+	//lcycle = 600/ldiv;
+	if(lmem_source == 0)
+        lcycle = 600/(10000/(lpll0/lmem_div));
+	else
+        lcycle = 600/(10000/(lpll1/lmem_div));
+	*(volatile unsigned long *)0xF0302024 = lcycle+DDR_DELAY; 			// tRC	- 60ns
+	//lcycle = 150/ldiv;
+	if(lmem_source == 0)
+        lcycle = 150/(10000/(lpll0/lmem_div));
+	else
+        lcycle = 150/(10000/(lpll1/lmem_div));
+	*(volatile unsigned long *)0xF0302028 = ((lcycle+DDR_DELAY-3)<<8 | lcycle+DDR_DELAY); // tRCD - 15ns
+	//lcycle = 1050/ldiv;
+	if(lmem_source == 0)
+        lcycle = 1050/(10000/(lpll0/lmem_div));
+	else
+        lcycle = 1050/(10000/(lpll1/lmem_div));
+	*(volatile unsigned long *)0xF030202c = ((lcycle+DDR_DELAY-3)<<8 | lcycle+DDR_DELAY); // tRFC - 105ns
+	//lcycle = 150/ldiv;
+	if(lmem_source == 0)
+        lcycle = 150/(10000/(lpll0/lmem_div));
+	else
+        lcycle = 150/(10000/(lpll1/lmem_div));
+	*(volatile unsigned long *)0xF0302030 = ((lcycle+DDR_DELAY-3)<<8 | lcycle+DDR_DELAY); // tRP	- 15ns
+	//lcycle = 100/ldiv;
+	if(lmem_source == 0)
+        lcycle = 100/(10000/(lpll0/lmem_div));
+	else
+        lcycle = 100/(10000/(lpll1/lmem_div));
+	*(volatile unsigned long *)0xF0302034 = lcycle+DDR_DELAY; 			// tRRD - 10ns
+	//lcycle = 150/ldiv;
+	if(lmem_source == 0)
+        lcycle = 150/(10000/(lpll0/lmem_div));
+	else
+        lcycle = 150/(10000/(lpll1/lmem_div));
+	*(volatile unsigned long *)0xF0302038 = lcycle+DDR_DELAY; 			// tWR - 15ns
+	//lcycle = 75/ldiv;
+	if(lmem_source == 0)
+        lcycle = 75/(10000/(lpll0/lmem_div));
+	else
+        lcycle = 75/(10000/(lpll1/lmem_div));
+	*(volatile unsigned long *)0xF030203c = lcycle+DDR_DELAY; 			// tWTR - 7.5ns
+	*(volatile unsigned long *)0xF0302040 = 0x00000003; 		// tXP - min 2tCK
+
+	if(lmem_source == 1) // under 330Mhz
+	{
+		*(volatile unsigned long *)0xF0302044 = 0x00000022; 	// tXSR
+		*(volatile unsigned long *)0xF0302048 = 0x000000FA; 	// tESR
+		*(volatile unsigned long *)0xF0302054 = 0x00001619; 	// tFAW
+	}
+	else // Over Mem 330Mhz
+	{
+		*(volatile unsigned long *) 0xf0302044=0x0000002E;		// tXSR
+		*(volatile unsigned long *) 0xf0302048=0x00000050;		// tESR
+		*(volatile unsigned long *) 0xf0302054=0x0000191c;		// tFAW
+	}
+
+	i = 3200;
+	while(i)
+		i--;
+
+	*(volatile unsigned long *)0xF0302200 = 0x000040f0; 		// config_chip0
+//	*(volatile unsigned long *)0xF0302200 = 0x000040f8; 		// config_chip0  //soc1-3
+	i = 3200;
+	while(i)
+		i--;
+	*(volatile unsigned long *)0xF0302004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000001; 		// PL341_SLEEP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 3);	// Wait until SLEEP
+
+	*(volatile unsigned long *)0xF030302C |= 0x00004000; 		// SSTL SDRAM IO Control Register 
+
+
+	
+	*(volatile unsigned long *)0xF0303020 = 0x00010103; 		// emccfg_config0
+	*(volatile unsigned long *)0xF0303024 = 0x00000000; 		// SDRAM PHY Control Register 
+	*(volatile unsigned long *)0xF0304400 = 0x00000000; 		// DDR2PHY_PHYMODE
+	*(volatile unsigned long *)0xF0304404 = 0x00000001; 		// DLLCTRL
+	
+	if(lmem_source == 1) // under 330Mhz
+	{
+		*(volatile unsigned long *)0xF0304408 = 0x00001717; 	// DLLPDCFG
+	}
+	else // Over Mem 330Mhz
+	{
+		*(volatile unsigned long *)0xF0304408 = 0x00001212; 	// DLLPDCFG
+	}
+		
+	*(volatile unsigned long *)0xF0304404 = 0x00000003; 		// DLLCTRL
+	while (((*(volatile unsigned long *)0xF0304404) & (0x00000018)) != (0x00000018)); // Wait DLL Lock
+
+	*(volatile unsigned long *)0xF0304424 = 0x00000035; 		// DLLFORCELOCK
+	*(volatile unsigned long *)0xF030440C = 0x00000006; 		// GATECTRL
+#if defined(DRAM_CAS6)  //soc1-3
+		*(volatile unsigned long *) 0xf0304430=0x00000006; // RDDELAY - SOC
+#else
+		*(volatile unsigned long *) 0xf0304430=0x00000005; // RDDELAY - SOC
+#endif
+	
+	#if defined(DRAM_ODTOFF)
+		*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+							| (0 << 16)	// PRD_CEN
+							| (7 << 13)	// DRV_STR
+							| (1 << 12)	// TERM_DIS
+							| (2 << 9)	// ODT(PHY) value
+							| (5 << 6)	// PULL UP
+							| (2 << 3)	// PULL DOWN
+							| (0 << 2)	// ZQ
+							| (0 << 1)	// UPDATE
+							| (1 << 0);	// CAL_START
+	#else
+		*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+							| (0 << 16)	// PRD_CEN
+							| (7 << 13)	// DRV_STR
+							| (0 << 12)	// TERM_DIS
+							| (2 << 9)	// ODT(PHY) value
+							| (5 << 6)	// PULL UP
+							| (2 << 3)	// PULL DOWN
+							| (0 << 2)	// ZQ
+							| (0 << 1)	// UPDATE
+							| (1 << 0);	// CAL_START
+	#endif
+	
+	while (!((*(volatile unsigned long *)0xF030442c) & (1)));	// Wait until Calibration completion without error
+	#if defined(DRAM_ODTOFF)
+		*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+							| (0 << 16)	// PRD_CEN
+							| (7 << 13)	// DRV_STR
+							| (1 << 12)	// TERM_DIS
+							| (2 << 9)	// ODT(PHY) value
+							| (5 << 6)	// PULL UP
+							| (2 << 3)	// PULL DOWN
+							| (0 << 2)	// ZQ
+							| (1 << 1)	// UPDATE
+							| (1 << 0);	// CAL_START
+	#else
+		*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+							| (0 << 16)	// PRD_CEN
+							| (7 << 13)	// DRV_STR
+							| (0 << 12)	// TERM_DIS
+							| (2 << 9)	// ODT(PHY) value
+							| (5 << 6)	// PULL UP
+							| (2 << 3)	// PULL DOWN
+							| (0 << 2)	// ZQ
+							| (1 << 1)	// UPDATE
+							| (1 << 0);	// CAL_START
+	#endif
+	i = 3200;
+	while(i)
+		i--;
+	#if defined(DRAM_ODTOFF)
+		*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+							| (0 << 16)	// PRD_CEN
+							| (7 << 13)	// DRV_STR
+							| (1 << 12)	// TERM_DIS
+							| (2 << 9)	// ODT(PHY) value
+							| (5 << 6)	// PULL UP
+							| (2 << 3)	// PULL DOWN
+							| (0 << 2)	// ZQ
+							| (0 << 1)	// UPDATE
+							| (1 << 0);	// CAL_START
+	#else
+		*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+							| (0 << 16)	// PRD_CEN
+							| (7 << 13)	// DRV_STR
+							| (0 << 12)	// TERM_DIS
+							| (2 << 9)	// ODT(PHY) value
+							| (5 << 6)	// PULL UP
+							| (2 << 3)	// PULL DOWN
+							| (0 << 2)	// ZQ
+							| (0 << 1)	// UPDATE
+							| (1 << 0);	// CAL_START
+	#endif
+	i = 3200;
+	while(i)
+		i--;
+	
+	*(volatile unsigned long *)0xF0302004 = 0x00000002; 		// PL34X_WAKEUP
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000004; 		// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0302000) & (0x03)) != 0);	// Wait until CONFIGURE
+
+	*(volatile unsigned long *)0xF0302008 = 0x000c0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00040000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000a0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x000b0000; 		// Direct COmmnad Register 
+	*(volatile unsigned long *)0xF0302008 = 0x00090000; 		// Direct COmmnad Register	  
+	
+	if(lmem_source == 1) // under 330Mhz
+	{
+		#if defined(DRAM_CAS6)
+			*(volatile unsigned long *)0xF0302008 = 0x00080962; 	// Direct COmmnad Register 
+		#else
+			*(volatile unsigned long *)0xF0302008 = 0x00080952; 	// Direct COmmnad Register 
+		#endif		
+	}
+	else // Over Mem 330Mhz
+	{
+		if((lpll0/lmem_div) <= 330)
+		{
+			#if defined(DRAM_CAS6)
+					*(volatile unsigned long *)0xF0302008 = 0x00080962; 	// Direct COmmnad Register
+			#else
+					*(volatile unsigned long *)0xF0302008 = 0x00080952; 	// Direct COmmnad Register
+			#endif
+		}
+		else
+		{
+			#if defined(DRAM_CAS6)
+					*(volatile unsigned long *)0xF0302008 = 0x00080762; 	// Direct COmmnad Register
+			#else
+					*(volatile unsigned long *)0xF0302008 = 0x00080752; 	// Direct COmmnad Register
+			#endif
+		}
+	}
+		
+	*(volatile unsigned long *)0xF0302008 = 0x00000000; 		// Direct COmmnad Register 
+
+	//i = 100;
+	i = 200; //soc1-3
+	while(i)
+	{
+		*(volatile unsigned long *) 0xf0302008=0x00040000; // dir_cmd
+		*(volatile unsigned long *) 0xf0302008=0x00040000; // dir_cmd  //soc1-3
+		i--;
+	}
+	
+	if(lmem_source == 1) // under 330Mhz
+	{
+	#if defined(DRAM_CAS6)
+			*(volatile unsigned long *)0xF0302008 = 0x00080862; 	// Direct COmmnad Register 
+	#else
+			*(volatile unsigned long *)0xF0302008 = 0x00080852; 	// Direct COmmnad Register 
+	#endif		
+	}
+	else // Over Mem 330Mhz
+	{
+		if((lpll0/lmem_div) <= 330)
+		{
+		#if defined(DRAM_CAS6)
+					*(volatile unsigned long *)0xF0302008 = 0x00080862; 	// Direct COmmnad Register
+		#else
+					*(volatile unsigned long *)0xF0302008 = 0x00080852; 	// Direct COmmnad Register
+		#endif
+		}
+		else
+		{
+		#if defined(DRAM_CAS6)
+					*(volatile unsigned long *)0xF0302008 = 0x00080662; 	// Direct COmmnad Register
+		#else
+					*(volatile unsigned long *)0xF0302008 = 0x00080652; 	// Direct COmmnad Register
+		#endif
+		}
+	}
+	#if defined(DRAM_ODTOFF)
+
+	#else
+		*(volatile unsigned long *)0xF0302008 = 0x00090380; 		// Direct COmmnad Register 
+		*(volatile unsigned long *)0xF0302008 = 0x00090004; 		// Direct COmmnad Register //soc1-3
+	#endif
+			
+
+	*(volatile unsigned long *)0xF0302004 = 0x00000000; 		// PL341_GO
+	i = 1600;
+	while(i)
+		i--;
+
+}
+
+typedef void (*lpfunc)();
+lpfunc lpSelfRefresh;
+
+void init_copybootddr(void)
+{
+	#define SRAM_ADDR_STANDBY		0x10000400
+	#define SRAM_FUNC_SIZE			0x900
+	volatile unsigned int	*fptr;
+	volatile unsigned int	*p;
+	int 					i;
+	unsigned int lstack = 0;
+				
+	fptr = (volatile unsigned int*)init_bootddr;
+	lpSelfRefresh = (lpfunc)(SRAM_ADDR_STANDBY);
+	
+	p = (volatile unsigned int*)SRAM_ADDR_STANDBY;
+	
+	for (i = 0;i < (SRAM_FUNC_SIZE);i++)
+	{
+		*p = *fptr;
+		p++;
+		fptr++;
+	}
+	
+	while(--i);
+	
+	// Jump to Function Start Point
+	lpSelfRefresh();
+}
+#endif //!defined(NKUSE) && !defined(__KERNEL__)
+#endif //defined(DRAM_DDR2)
+
+/************* end of file *************************************************************/
+
diff --git a/drivers/block/tcc/init_mddr.c b/drivers/block/tcc/init_mddr.c
new file mode 100644
index 0000000..749a4e7
--- /dev/null
+++ b/drivers/block/tcc/init_mddr.c
@@ -0,0 +1,761 @@
+/****************************************************************************
+ *   FileName    : init_MEM.c
+ *   Description : Init code for TCC8900 DDRAM
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+#if defined(_WINCE_)
+#include "bsp.h"
+#elif defined(_LINUX_)
+#include <common.h>
+#include <def_tcc.h>
+#endif
+
+#if defined(DRAM_MDDR)
+
+#define	repeat(n) { volatile int i; for (i=0; i<=n; i++); }
+#define DDR_DELAY	1
+/****************************************************************************************
+* FUNCTION :void InitRoutine_Start(void)
+* DESCRIPTION :
+* ***************************************************************************************/
+	/*-------------------
+	   PLL0   m      p    s
+	  ------------------
+	   600    200   2     1
+	   500    250   3     1
+	   480    160   2     1
+	   480	  400	3	  2
+	---------------------*/
+	/*-------------------
+	   PLL1   m 	 p	  s
+	  ------------------
+	   560	  140	3	  0
+	   520	  130	3	  0
+	   500	  125	3	  0
+	   480	  40	1	  0
+	---------------------*/
+#pragma optimize( "g", off )
+
+volatile void InitRoutine_Start(void)
+{
+	volatile unsigned int i;
+	//*(volatile unsigned long *)0xF0101000 |= 0x00800000;
+
+	// 44.0 ms
+//Enter Mode		
+	*(volatile unsigned long *)0xF0301004 = 0x00000003; 		// PL340_PAUSE
+	while (((*(volatile unsigned long *)0xF0301000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xF0301004 = 0x00000004; 		// PL340_Configure
+	while (((*(volatile unsigned long *)0xF0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xF0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xF0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xF030302c &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+	i = 1600;
+	while(i)
+		i--;
+
+	i = 100;
+	while(i)
+	{
+		*(volatile unsigned long *)0xF0301008 = 0x00040000;
+		i--;
+	}		// repeat end
+	// 37.7 ms
+	*(volatile unsigned long *)0xF0400030 = 0x01010101;
+	*(volatile unsigned long *)0xF0400034 = 0x01010101;
+
+	*(volatile unsigned long *)0xF0400000 = 0x002ffff4; // XI - corebus
+	*(volatile unsigned long *)0xF0400008 = 0x00200014; // XI - memebus
+//PLL0
+	*(volatile unsigned long *)0xF0400020= 0x0000fa03; // pll pwr off
+	*(volatile unsigned long *)0xF0400020= 0x0100C802; // pms - pllout_600M
+	*(volatile unsigned long *)0xF0400020= 0x8100C802; //	pll pwr on	
+//PLL1
+	*(volatile unsigned long *)0xF0400024= 0x0000fa03; // pll pwr off
+	*(volatile unsigned long *)0xF0400024= 0x00008c03; // pms - pllout_560M
+	*(volatile unsigned long *)0xF0400024= 0x80008c03; //	pll pwr on
+
+//PLL2
+//	*(volatile unsigned long *)0xF0400028= 0x0000fa03; // pll pwr off
+//	*(volatile unsigned long *)0xF0400028= 0x00002701; // pms - pllout_468M
+//	*(volatile unsigned long *)0xF0400028= 0x80002701; //	pll pwr on
+	i = 3200;
+	while(i)
+		i--;
+	*(volatile unsigned long *)0xF0400000 = 0x002AAAA0; // 300Mhz
+	*(volatile unsigned long *)0xF0400008 = 0x00200030; // 150Mhz
+	*(volatile unsigned long *)0xF0400010 = 0x00200022; // CKC-CLKCTRL4 - I/O BUS
+	i = 3200;
+	while(i)
+		i--;
+	i = 100;
+	while(i)
+	{
+		*(volatile unsigned long *)0xF0301008 = 0x00040000;
+		i--;
+	}		// repeat end
+
+	*(volatile unsigned long *)0xF0301004 = 0x00000004; 		// PL340_Configure
+	while (((*(volatile unsigned long *)0xF0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+	// MEMCFG0
+	// clumn_bits=2, row_bits=2, ap_bit=0, mem_burst=2,active.chips=0
+	*(volatile unsigned long *)0xF030100c = 0x00010012;
+	// MEMCFG1
+	// mem_width=1, mem_type=3,read_delay=1, Sync = 1
+	*(volatile unsigned long *)0xF030104c = 0x000002d1;
+	*(volatile unsigned long *)0xF0301010 = 0x000003e8; // refresh_prd = 1000
+	*(volatile unsigned long *)0xF0301014 = 0x00000006; // cas_latency = 3
+	*(volatile unsigned long *)0xF030101C = 0x00000002; // tMRD=3
+	*(volatile unsigned long *)0xF0301020 = 0x00000005; // tRAS=6
+	*(volatile unsigned long *)0xF0301024 = 0x00000007; // tRC=11
+	*(volatile unsigned long *)0xF0301028 = 0x00000003; // tRCD=3<<3|5<<0
+	*(volatile unsigned long *)0xF030102c = 0x00000B0E; // tRFC=(19<<8|21<<0)
+	*(volatile unsigned long *)0xF0301030 = 0x00000003; // tRP=3<<3|5<<0
+	*(volatile unsigned long *)0xF0301034 = 0x00000001; // tRRD=2
+	*(volatile unsigned long *)0xF0301038 = 0x00000002; // tWR=5
+	*(volatile unsigned long *)0xF030103c = 0x00000001; // tWTR=4
+	*(volatile unsigned long *)0xF0301040 = 0x00000002; // tXP=3
+	*(volatile unsigned long *)0xF0301044 = 0x00000012; // tXSR=14
+	*(volatile unsigned long *)0xF0301048 = 0x00000032; // tESR=200
+	// CHIP0 address_match=0x40, address_mask=0x40
+	*(volatile unsigned long *)0xF0301200 = 0x000040F0;
+
+/*
+	i = 3200;
+	while(i)
+		i--;
+*/
+	*(volatile unsigned long *)0xF030302C = 0x3FFF;
+
+	//HwEMCCFG->uCONFIG0.bReg.AXI_SEL = 0;
+	//HwEMCCFG->uCONFIG0.bReg.IO_SEL = 1;
+	*(volatile unsigned long *)0xF0303020 = 0x00010102;
+	//HwEMCCFG->uPHYCTRL.bReg.PL340_SEL = 1;
+	*(volatile unsigned long *)0xF0303024 = 0x00000100;
+	*(volatile unsigned long *)0xF030302C = 0x00000000;
+	//SSTL_IO_Init (IO_CMOS)
+	*(volatile unsigned long *) 0xF0304400=0x00000002; // DDR2PHY_PHYMODE
+	*(volatile unsigned long *) 0xF0304404=0x00004d69; // DLLCTRL - DLL ON
+	*(volatile unsigned long *) 0xF0304408=0x00002f2f; // DLLPDCFG (200Mhz)
+	*(volatile unsigned long *) 0xF0304404=0x000047d3; // DLLCTRL - DLL ON, DLL start
+	while (!((*(volatile unsigned long *)0xF0304404) & (3<<3)));	// Wait until PDFL == 1
+	
+	*(volatile unsigned long *) 0xF0304424=0x00000035; // DLLFORCELOCK
+	*(volatile unsigned long *) 0xF030440c=0x00000003; // GATECTRL
+	*(volatile unsigned long *) 0xF0304430=0x00000004; // RDDELAY - SOC
+	*(volatile unsigned long *) 0xF0304428=0x0006F151; // ZQCTRL Termination Selection    : 0 for disable
+	while (!((*(volatile unsigned long *)0xF030442c) & (1)));	// Wait until Calibration completion without error
+	
+	*(volatile unsigned long *) 0xF0304428=0x0006F153; // ZQCTRL Termination Selection    : 0 for disable
+/*
+	i = 3200;
+	while(i)
+		i--;
+		*/
+	*(volatile unsigned long *) 0xF0304428=0x0006F151; // ZQCTRL Termination Selection    : 0 for disable
+	//i = 3200;
+	//while(i)
+	//	i--;
+
+	//HwPL340->direct_cmd = 		
+	*(volatile unsigned long *)0xF0301008 = 0x00000032;
+	*(volatile unsigned long *)0xF0301008 = 0x000a0000;
+	*(volatile unsigned long *)0xF0301008 = 0x00080032;
+
+
+	i = 50;
+	while(i)
+	{
+		*(volatile unsigned long *)0xF0301008 = 0x00040032;
+		i--;
+		*(volatile unsigned long *)0xF0301008 = 0x00040032;
+	}
+
+
+	*(volatile unsigned long *) 0xF0301004=0x00000000; // PL341_GO
+		while (((*(volatile unsigned long *)0xF0301000) & (0x03)) != 1);	// Wait until READY
+}
+#pragma optimize( "g", on )
+
+volatile void InitRoutine_End(void)
+{
+
+}
+#ifndef NKUSE
+/*=========================================================================================================================
+*
+*										Used Boot Loader
+*
+==========================================================================================================================*/
+void init_clock(void)
+{
+	PCKC		lCKC = (CKC *)&HwCLK_BASE;
+	PPMU		lPMU = (PMU *)&HwPMU_BASE;
+	PNTSCPAL	lNTSCPAL=(PNTSCPAL)&HwTVE_BASE;
+	volatile unsigned int nCount = 0;
+
+	
+	tca_ckc_init(); 
+	
+	// Set PLL - default PLL: PLL1,PLL2,PLL3 Disable
+	// Change PLL Value
+	tca_ckc_setpll(4680000,2); // 240 *2 100hz -SDMMC
+	tca_ckc_setpll(5280000,3); // 156 *2 100hz	
+	
+	//CLKDIVC0/1
+	lCKC->CLKDIVC	= 0x01010101;
+	lCKC->CLKDIVC1	= 0x01010101;
+	
+#if defined(TCC_R_AX)
+	tca_ckc_setswreset(RESET_VIDEOBUS, ON);
+	tca_ckc_setswreset(RESET_VIDEOCORE, ON);
+	#if !defined(TCC_MAX_FGRP_INCLUDE)
+	tca_ckc_setswreset(RESET_GRAPBUS, ON);
+	#endif
+#endif
+	
+	tca_ckc_setfbusctrl(CLKCTRL1,ENABLE,NORMAL_MD,2340000,DIRECTPLL2);/*FBUS_DDI		240 MHz */
+#if defined(TCC_R_AX)
+	#if defined(TCC_MAX_FGRP_INCLUDE)
+		tca_ckc_setfbusctrl(CLKCTRL3,ENABLE,NORMAL_MD,2340000,DIRECTPLL2);/*FBUS_GRP		190 MHz */
+	#else
+		tca_ckc_setfbusctrl(CLKCTRL3,DISABLE,NORMAL_MD,60000,DIRECTXIN);/*FBUS_GRP		190 MHz */
+	#endif
+#else
+		tca_ckc_setfbusctrl(CLKCTRL3,ENABLE,NORMAL_MD,2340000,DIRECTPLL2);/*FBUS_GRP		190 MHz */
+#endif
+	tca_ckc_setfbusctrl(CLKCTRL4,ENABLE,NORMAL_MD,1560000,DIRECTPLL2);/*FBUS_IOB		166 MHz */
+
+#if defined(TCC_R_AX)
+	tca_ckc_setfbusctrl(CLKCTRL5,DISABLE,NORMAL_MD,60000,DIRECTXIN);/*FBUS_VBUS		215 MHz */ //2640000 , 1760000
+	tca_ckc_setfbusctrl(CLKCTRL6,DISABLE,NORMAL_MD,60000,DIRECTXIN);/*FBUS_VCODEC	160 MHz */ //2340000 , 1560000
+#else
+	tca_ckc_setfbusctrl(CLKCTRL5,ENABLE,NORMAL_MD,60000,DIRECTXIN);/*FBUS_VBUS		215 MHz */ //2640000 , 1760000
+	tca_ckc_setfbusctrl(CLKCTRL6,ENABLE,NORMAL_MD,60000,DIRECTXIN);/*FBUS_VCODEC	160 MHz */ //2340000 , 1560000
+#endif
+	tca_ckc_setfbusctrl(CLKCTRL7,ENABLE,NORMAL_MD,1170000,DIRECTPLL2);/*FBUS_SMU		125 MHz */
+		
+	// Enable Peri.
+	lPMU->CONTROL	|= Hw16;		// Touch ADC Power Enable
+	nCount = 10;	
+	for ( ; nCount > 0 ; nCount --);		// delay
+	lNTSCPAL->DACPD |= Hw0;
+	
+	lPMU->PWROFF	&= ~Hw0;			// Video Dac(TVOUT)
+	nCount = 500;	
+	for ( ; nCount > 0 ; nCount --);		// delay
+
+	lPMU->PWROFF	|=(Hw0			// Video Dac(TVOUT)
+						|Hw1		// HDMI PHY
+						|Hw2		// LVDS
+						|Hw4		//SATA PHY
+#if defined(TCC_R_AX)
+						|Hw6		// Video Bus
+						#if !defined(TCC_MAX_FGRP_INCLUDE)
+						|Hw8
+						#endif
+#endif
+	); // HDMI Phy,LVDS Phy,SATA Phy , Video Bus , Graphic Bus 
+	
+#if defined(TCC_R_AX)
+	tca_ckc_setswreset(RESET_VIDEOCORE, OFF);
+	tca_ckc_setswreset(RESET_VIDEOBUS, OFF);
+	#if !defined(TCC_MAX_FGRP_INCLUDE)
+	tca_ckc_setswreset(RESET_GRAPBUS, OFF);
+	#endif
+#endif
+
+// init Peri. Clock
+	tca_ckc_setperi(PERI_TCZ,ENABLE,120000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_ADC,ENABLE,390000,PCDIRECTPLL2);
+	tca_ckc_setperi(PERI_I2C,ENABLE,40000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_UART0,ENABLE,520000,PCDIRECTPLL2); 
+	tca_ckc_setperi(PERI_LCD1,ENABLE,1560000,PCDIRECTPLL2);
+
+	tca_ckc_setperi(PERI_LCD0,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_LCDSI,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_CIFMC,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_CIFSC,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_OUT0,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_OUT1,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_HDMI,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_SDMMC0,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_MSTICK,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_UART1,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_UART2,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_UART3,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_UART4,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_UART5,ENABLE,10000,PCDIRECTXIN);
+
+	tca_ckc_setperi(PERI_GPSB0,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_GPSB1,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_GPSB2,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_GPSB3,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_GPSB4,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_GPSB5,ENABLE,10000,PCDIRECTXIN);
+
+	tca_ckc_setperi(PERI_SPDIF,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_EHI0,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_EHI1,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_CAN,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_SDMMC1,ENABLE,10000,PCDIRECTXIN);
+	tca_ckc_setperi(PERI_DAI,ENABLE,10000,PCDIRECTXIN);
+
+// init Io Bus
+	tca_ckc_setiobus(RB_USB11H, DISABLE);	
+	tca_ckc_setiobus(RB_IDECONTROLLER, DISABLE);	
+	tca_ckc_setiobus(RB_SDMMCCONTROLLER, DISABLE);	
+	tca_ckc_setiobus(RB_SATAHCONTROLLER, DISABLE);	
+	tca_ckc_setiobus(RB_MEMORYSTICKCONTROLLER, DISABLE);	
+	tca_ckc_setiobus(RB_EXTHCONTROLLER0, DISABLE);	
+	tca_ckc_setiobus(RB_EXTHCONTROLLER1, DISABLE);	
+	tca_ckc_setiobus(RB_UARTCONTROLLER1, DISABLE);	
+	tca_ckc_setiobus(RB_UARTCONTROLLER2, DISABLE);	
+	tca_ckc_setiobus(RB_UARTCONTROLLER3, DISABLE);	
+	tca_ckc_setiobus(RB_UARTCONTROLLER4, DISABLE);	
+	tca_ckc_setiobus(RB_UARTCONTROLLER5, DISABLE);	
+	tca_ckc_setiobus(RB_GPSBCONTROLLER0, DISABLE);	
+	tca_ckc_setiobus(RB_GPSBCONTROLLER1, DISABLE);	
+	tca_ckc_setiobus(RB_GPSBCONTROLLER2, DISABLE);	
+	tca_ckc_setiobus(RB_GPSBCONTROLLER3, DISABLE);	
+	tca_ckc_setiobus(RB_GPSBCONTROLLER4, DISABLE);	
+	tca_ckc_setiobus(RB_GPSBCONTROLLER5, DISABLE);	
+	tca_ckc_setiobus(RB_SPDIFTXCONTROLLER, DISABLE);	
+	tca_ckc_setiobus(RB_GPSCONTROLLER, DISABLE);	
+	tca_ckc_setiobus(RB_CANCONTROLLER, DISABLE);	
+	tca_ckc_setiobus(RB_MPE_FECCONTROLLER, DISABLE);	
+	tca_ckc_setiobus(RB_TSIFCONTROLLER, DISABLE);	
+//	tca_ckc_setiobus(RB_SRAMCONTROLLER, DISABLE);	
+
+// init ddi Pwdn
+	tca_ckc_setddipwdn(DDIPWDN_CIF, DISABLE);	
+	tca_ckc_setddipwdn(DDIPWDN_VIQE, DISABLE);	
+	tca_ckc_setddipwdn(DDIPWDN_LCDC0, DISABLE);	
+	tca_ckc_setddipwdn(DDIPWDN_MSCL0, DISABLE);	
+	tca_ckc_setddipwdn(DDIPWDN_MSCL1, DISABLE);	
+	tca_ckc_setddipwdn(DDIPWDN_HDMI, DISABLE);	
+	
+#if defined(_WINCE_)
+	enable_irq();
+#endif
+}
+
+/*	
+*	Example 
+* ------------------------------------------------------------------------------------------------------------------------------
+* define HIGH_VOLTAGE_CLOCK_INCLUDE
+*
+*	1. Core 600Mhz, Mem 400Mhz
+*		#define lpll0		800
+*		#define lpll1		660
+*		#define lmem_source 0	// 0 : PLL0 , 1 : PLL1
+*		#define lcore_div	12	// (lpll0 * lcore_div)/16 - refer DataSheet CKC Block
+*		#define lmem_div	2	// if lmem_source is 0, lpll0/lmem_div = Mem Bus /	if lmem_source is 0, lpll0/lmem_div = Mem Bus
+*
+*	2. Core 600Mhz, Mem 330Mhz
+*		#define lpll0		600
+*		#define lpll1		660
+*		#define lmem_source 1	// 0 : PLL0 , 1 : PLL1
+*		#define lcore_div	16	// (lpll0 * lcore_div)/16 - refer DataSheet CKC Block
+*		#define lmem_div	2	// if lmem_source is 0, lpll0/lmem_div = Mem Bus /	if lmem_source is 1, lpll1/lmem_div = Mem Bus
+*	3. Core 506Mhz, Mem 330Mhz
+*		#define lpll0		540
+*		#define lpll1		660
+*		#define lmem_source 1	// 0 : PLL0 , 1 : PLL1
+*		#define lcore_div	15	// (lpll0 * lcore_div)/16 - refer DataSheet CKC Block
+*		#define lmem_div	2	// if lmem_source is 0, lpll0/lmem_div = Mem Bus /	if lmem_source is 1, lpll1/lmem_div = Mem Bus
+* ------------------------------------------------------------------------------------------------------------------------------
+*	4. Core 600Mhz, Mem 280Mhz
+*		#define lpll0		600
+*		#define lpll1		560
+*		#define lmem_source 1	// 0 : PLL0 , 1 : PLL1
+*		#define lcore_div	16	// (lpll0 * lcore_div)/16 - refer DataSheet CKC Block
+*		#define lmem_div	2	// if lmem_source is 0, lpll0/lmem_div = Mem Bus /	if lmem_source is 1, lpll1/lmem_div = Mem Bus
+*
+*	5. Core 506Mhz, Mem 280Mhz
+*		#define lpll0		540
+*		#define lpll1		560
+*		#define lmem_source 1	// 0 : PLL0 , 1 : PLL1
+*		#define lcore_div	15	// (lpll0 * lcore_div)/16 - refer DataSheet CKC Block
+*		#define lmem_div	2	// if lmem_source is 0, lpll0/lmem_div = Mem Bus /	if lmem_source is 0, lpll0/lmem_div = Mem Bus
+* ------------------------------------------------------------------------------------------------------------------------------
+*/
+#pragma optimize( "g", off )
+
+void init_bootddr(void)
+{
+	#define lmem_source 1 // 0 : PLL0 , 1 : PLL1	
+// Core
+	#if  defined(FCPU_337MHZ_INCLUDE)
+		#define lpll0		540
+		#define lcore_div	10 // refer DataSheet CKC Block 
+	#elif  defined(FCPU_506MHZ_INCLUDE)
+		#define lpll0		540
+		#define lcore_div	15 // refer DataSheet CKC Block 
+	#elif defined(FCPU_600MHZ_INCLUDE)
+		#define lpll0		600
+		#define lcore_div	16 // refer DataSheet CKC Block 
+	#else
+		#define lpll0		540
+		#define lcore_div	15 // refer DataSheet CKC Block 
+	#endif
+// Mbus
+	#if defined(FMBUS_180MHZ_INCLUDE)
+		#define lpll1		360
+	#elif defined(FMBUS_160MHZ_INCLUDE)
+		#define lpll1		320
+	#elif defined(FMBUS_133MHZ_INCLUDE)
+		#define lpll1		266
+	#else
+		#define lpll1		266
+	#endif
+
+
+	#define lmem_div	2
+	volatile unsigned int i = 0;	
+	unsigned int ldiv = 0;
+	unsigned int lcycle = 0;
+	unsigned int lindex[17];
+	lindex[0] = 0x0;
+	lindex[1] = 0x8000;
+	lindex[2] = 0x8008;
+	lindex[3] = 0x8808;
+	lindex[4] = 0x8888;
+	lindex[5] = 0xA888;
+	lindex[6] = 0xA8A8;
+	lindex[7] = 0xAAA8;
+	lindex[8] = 0xAAAA;
+	lindex[9] = 0xECCC;
+	lindex[10] = 0xEECC;
+	lindex[11] = 0xEEEC;
+	lindex[12] = 0xEEEE;
+	lindex[13] = 0xFEEE;
+	lindex[14] = 0xFFEE;
+	lindex[15] = 0xFFFE;
+	lindex[16] = 0xFFFF;	
+
+//Enter Mode		
+	*(volatile unsigned long *)0xF0301004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0301000) & 0x3)!=2); //Wait PL34X_STATUS_PAUSED
+
+	*(volatile unsigned long *)0xF0301004 = 0x00000004; 		// PL341_Configure
+	while (((*(volatile unsigned long *)0xF0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+// DLL OFF
+	*(volatile unsigned long *)0xF0304404 &=  ~(0x00000003);	// DLL-0FF,DLL-Stop running
+	*(volatile unsigned long *)0xF0304428 &= ~(0x00000003); 	// Calibration Start,Update Calibration
+	*(volatile unsigned long *)0xF030302c &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+		
+	i = 1600;
+	while(i)
+		i--;
+
+	i = 100;
+	while(i)
+	{
+		*(volatile unsigned long *)0xF0301008 = 0x00040000;
+		i--;
+	}		// repeat end
+
+
+//Clock Change	
+	*(volatile unsigned long *)0xF0400030 = 0x01010101;
+	*(volatile unsigned long *)0xF0400034 = 0x01010101;
+	
+	*(volatile unsigned long *)0xF0400000 = 0x002ffff4; 		// XI - corebus
+	*(volatile unsigned long *)0xF0400008 = 0x00200014; 		// XI - memebus
+	
+	i = 2400;
+	while(i)
+		i--;
+
+	//PLL0
+	*(volatile unsigned long *)0xF0400020= 0x0000fa03;			// pll pwr off
+
+	if(lpll0 == 600)
+	{
+		*(volatile unsigned long *)0xF0400020= 0x0100C802;		// pms - pllout_600M
+		*(volatile unsigned long *)0xF0400020= 0x8100C802;		//	pll pwr on	
+	}
+	else if(lpll0 == 540)			
+	{
+		*(volatile unsigned long *)0xF0400020= 0x0100B402;		// pms - pllout_540M
+		*(volatile unsigned long *)0xF0400020= 0x8100B402;		//	pll pwr on	
+	}
+	else if(lpll0 == 400)			
+	{
+		*(volatile unsigned long *)0xF0400020= 0x02019003;		// pms - pllout_400M
+		*(volatile unsigned long *)0xF0400020= 0x82019003;		//	pll pwr on	
+	}
+	else
+	{
+		*(volatile unsigned long *)0xF0400020= 0x0100C802;		// pms - pllout_600M
+		*(volatile unsigned long *)0xF0400020= 0x8100C802;		//	pll pwr on	
+	}
+	
+	//PLL1
+	*(volatile unsigned long *)0xF0400024= 0x0000fa03;			// pll pwr off
+	if(lpll1 == 360)
+	{
+		*(volatile unsigned long *)0xF0400024= 0x00001E01;		// pms - pllout_360M
+		*(volatile unsigned long *)0xF0400024= 0x80001E01;		//	pll pwr on
+	}
+	else if(lpll1 == 320)
+	{
+		*(volatile unsigned long *)0xF0400024= 0x00005003;		// pms - pllout_320M
+		*(volatile unsigned long *)0xF0400024= 0x80005003;		//	pll pwr on
+	}
+	else if(lpll1 == 266)
+	{
+		*(volatile unsigned long *)0xF0400024= 0x01008503;		// pms - pllout_266M
+		*(volatile unsigned long *)0xF0400024= 0x81008503;		//	pll pwr on
+	}
+	else
+	{
+		*(volatile unsigned long *)0xF0400024= 0x01008503;		// pms - pllout_266M
+		*(volatile unsigned long *)0xF0400024= 0x81008503;		//	pll pwr on
+	}
+
+//PLL2
+	*(volatile unsigned long *)0xF0400028= 0x0000fa03; // pll pwr off
+	*(volatile unsigned long *)0xF0400028= 0x00002701; // pms - pllout_468M
+	*(volatile unsigned long *)0xF0400028= 0x80002701; //	pll pwr on
+
+	i = 3200;
+	while(i)
+		i--;
+	*(volatile unsigned long *)0xF0400000 = (0x00200000 | (lindex[lcore_div] << 4));		// CKC-CLKCTRL0 - Core
+//	*(volatile unsigned long *)0xF0400000 = (0x00301A00 );		// CKC-CLKCTRL0 - Core
+//	*(volatile unsigned long *)0xF0400000 = (0x00301600 );		// CKC-CLKCTRL0 - Core
+	*(volatile unsigned long *)0xF0400008 = (0x00200000 | ((lmem_div-1) << 4)|lmem_source); // CKC-CLKCTRL2 - Mem
+	i = 3200;
+	while(i)
+		i--;
+
+
+	i = 100;
+	while(i)
+	{
+		*(volatile unsigned long *)0xF0301008 = 0x00040000;
+		i--;
+	}
+	
+//Init mDDR
+// memory arb.
+/*
+	*(volatile unsigned long *)0xF030100C |= 0x00140000; 
+	*(volatile unsigned long *) 0xF0301100=0x0000002b; // (10<<2)(1<<1)(1<<0) - video codec + jpeg encoder
+	*(volatile unsigned long *) 0xF0301104=0x0000002b; // (10<<2)(1<<1)(1<<0) - video cache + jpeg decoder
+	*(volatile unsigned long *) 0xF0301108=0x00000017; // (5<<2)(1<<1)(1<<0) - video codec secondary
+	*(volatile unsigned long *) 0xF030110c=0x00000017; // (5<<2)(1<<1)(1<<0) - io bus
+	*(volatile unsigned long *) 0xF0301110=0x0000000f; // (3<<2)(1<<1)(1<<1) - lcd
+	*(volatile unsigned long *) 0xF0301114=0x0000000f; // (3<<2)(1<<1)(1<<1) - lcd_mscl
+	*(volatile unsigned long *) 0xF0301118=0x00000017; // (5<<2)(1<<1)(1<<1) - VIQE
+	*(volatile unsigned long *) 0xF030111c=0x00000007; // (1<<2)(1<<1)(1<<1) - ddi cache
+	*(volatile unsigned long *) 0xF0301124=0x0000003f; // (15<<2)(1<<1)(1<<1) - ARM DMA bus
+	*(volatile unsigned long *) 0xF0301128=0x0000003f; // (15<<2)(1<<1)(1<<1) - ARM data bus
+	*(volatile unsigned long *) 0xF030112c=0x0000002b; // (10<<2)(1<<1)(1<<1) - ARM instruction
+	*(volatile unsigned long *) 0xF0301130=0x0000003f; // (15<<2)(1<<1)(1<<1) - overlay mixer
+	*(volatile unsigned long *) 0xF0301134=0x0000003f; // (15<<2)(1<<1)(1<<1) - overlay mixer
+	*(volatile unsigned long *) 0xF0301138=0x0000003f; // (15<<2)(1<<1)(1<<1) - overlay mixer
+	*(volatile unsigned long *) 0xF030113c=0x0000002b; // (10<<2)(1<<1)(1<<1) - 3d
+*/
+// memory arb. end	
+
+	i = 100;
+	while(i)
+	{
+		*(volatile unsigned long *)0xF0301008 = 0x00040000;
+		i--;
+	}
+
+	*(volatile unsigned long *) 0xF0301004=0x00000004;			// PL341_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0301000) & 0x3)!=0); //Wait PL34X_STATUS_CONFIG
+
+
+	*(volatile unsigned long *)0xF030100C = 0x00210012; 		// config0 cas 10bit, ras 13bit , AP bit 10, Burst 4, 2chips
+
+	*(volatile unsigned long *) 0xF0303000 |= 0x00800000;		// bit23 enable -synopt enable
+	*(volatile unsigned long *) 0xF0303010 |= 0x00800000;		// bit23 enable -synopt enable
+
+	*(volatile unsigned long *)0xF030104C= 0x000002D1;
+	
+	*(volatile unsigned long *)0xF0301010 = 0x000003E8; // refresh_prd = 1000
+
+
+
+#if defined(DRAM_CAS3)
+	*(volatile unsigned long *)0xF0301014 = 0x00000006; // cas_latency = 3
+#else
+	*(volatile unsigned long *)0xF0301014 = 0x00000004; // cas_latency = 2
+#endif					
+
+	*(volatile unsigned long *)0xF030101C = 0x00000002; // tMRD 2tck 
+	*(volatile unsigned long *)0xF0301020 = 0x0000000A; // tRAS 42ns
+	*(volatile unsigned long *)0xF0301024 = 0x0000000F; // tRC 60ns
+	*(volatile unsigned long *)0xF0301028 = 0x00000014; // tRCD 18ns
+	*(volatile unsigned long *)0xF030102c = 0x00000E11; // tRFC 72ns
+	*(volatile unsigned long *)0xF0301030 = 0x00000014; // tRP 18ns
+	*(volatile unsigned long *)0xF0301034 = 0x00000001; // tRRD 12ns
+	*(volatile unsigned long *)0xF0301038 = 0x00000002; // tWR 15ns
+	*(volatile unsigned long *)0xF030103c = 0x00000001; // tWTR 1tck
+	*(volatile unsigned long *)0xF0301040 = 0x00000002; // tXP=3
+	*(volatile unsigned long *)0xF0301044 = 0x00000016; // tXSR 120ns
+	*(volatile unsigned long *)0xF0301048 = 0x00000032; // tESR=200
+
+	i = 3200;
+	while(i)
+		i--;
+
+	//*(volatile unsigned long *)0xF0301200 = 0x00004040; // Chip 0
+	*(volatile unsigned long *)0xF0301200 = 0x000040F0; // Chip 0
+	
+	i = 3200;
+	while(i)
+		i--;		
+	
+	*(volatile unsigned long *)0xF0301004 = 0x00000000; 		// PL341_GO
+	while (((*(volatile unsigned long *)0xF0301000) & (0x03)) != 1);	// Wait until READY
+	
+	*(volatile unsigned long *)0xF0301004 = 0x00000003; 		// PL341_PAUSE
+	while (((*(volatile unsigned long *)0xF0301000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0301004 = 0x00000001; 		// PL341_SLEEP
+	while (((*(volatile unsigned long *)0xF0301000) & (0x03)) != 3);	// Wait until SLEEP
+
+	*(volatile unsigned long *)0xF030302c &=  ~(0x00004000);	//SDRAM IO Control Register Gatein Signal Power Down
+	*(volatile unsigned long *)0xF0303020 &=  ~(0x00000001);		// SW ? AXI_SEL     = 0
+	*(volatile unsigned long *)0xF0303020 |= 0x00000002; 		// SW ? IO_SEL      = 1;
+	*(volatile unsigned long *)0xF0303024 = 0x00000100;		// Hw8 SDR/mDDR/DDR
+
+
+	*(volatile unsigned long *)0xF0304400 = 0x00000002; 		// DDR2PHY_PHYMODE
+	*(volatile unsigned long *)0xF0304404 = 0x00000001; 		// DLLCTRL
+
+	*(volatile unsigned long *) 0xF0304408=0x00002020; // DLLPDCFG (145 ~ 180Mhz)
+	
+	*(volatile unsigned long *) 0xF0304404=0x00000003; // DLLCTRL - DLL ON, DLL start
+	while (!((*(volatile unsigned long *)0xF0304404) & (3<<3) == 0x18));	// Wait until PDFL == 1
+	*(volatile unsigned long *)0xF0304424 = 0x00000035; 		// DLLFORCELOCK
+	*(volatile unsigned long *)0xF030440C = 0x00000003; 		// GATECTRL	
+	*(volatile unsigned long *)0xF0304430 = 0x00000001; 	// RDDELAY	
+
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	while (!((*(volatile unsigned long *)0xF030442c) & (1)));	// Wait until Calibration completion without error
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (1 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START
+	*(volatile unsigned long *)0xF0304428 =  (3 << 17)	// PRD_CAL
+						| (0 << 16)	// PRD_CEN
+						| (7 << 13)	// DRV_STR
+						| (1 << 12)	// TERM_DIS
+						| (2 << 9)	// ODT(PHY) value
+						| (5 << 6)	// PULL UP
+						| (2 << 3)	// PULL DOWN
+						| (0 << 2)	// ZQ
+						| (0 << 1)	// UPDATE
+						| (1 << 0);	// CAL_START	
+	
+	i = 3200;
+	while(i)
+		i--;	
+
+	*(volatile unsigned long *)0xF0301004 = 0x00000002; 		// PL340_WAKEUP
+	while (((*(volatile unsigned long *)0xF0301000) & (0x03)) != 2);	// Wait until PAUSE
+
+	*(volatile unsigned long *)0xF0301004 = 0x00000004; 		// PL340_CONFIGURE
+	while (((*(volatile unsigned long *)0xF0301000) & (0x03)) != 0);	// Wait until CONFIGURE	
+
+	//HwPL340->direct_cmd = 		
+	#if defined(DRAM_CAS3)
+		*(volatile unsigned long *)0xF0301008 = 0x00000032; //MRS
+	#else
+		*(volatile unsigned long *)0xF0301008 = 0x00000022; //MRS
+	#endif					
+
+	*(volatile unsigned long *)0xF0301008 = 0x000a0000;//EMRS
+	#if defined(DRAM_CAS3)
+		*(volatile unsigned long *)0xF0301008 = 0x00080032;
+	#else
+		*(volatile unsigned long *)0xF0301008 = 0x00080022;
+	#endif					
+
+	// repeat 100
+	i = 100;
+	while(i)
+	{
+		#if defined(DRAM_CAS3)
+			*(volatile unsigned long *)0xF0301008 = 0x00040032;
+		#else
+			*(volatile unsigned long *)0xF0301008 = 0x00040022;
+		#endif					
+		i--;
+	}		// repeat end
+
+	*(volatile unsigned long *) 0xF0301004=0x00000000; // PL341_GO
+	while (((*(volatile unsigned long *)0xF0301000) & (0x03)) != 1);	// Wait until READY
+	
+}
+#pragma optimize( "g", on )
+
+typedef void (*lpfunc)();
+lpfunc lpSelfRefresh;
+
+void init_copybootddr(void)
+{
+	#define SRAM_ADDR_STANDBY		0x10000400
+	#define SRAM_FUNC_SIZE			0x900
+	volatile unsigned int	*fptr;
+	volatile unsigned int	*p;
+	int 					i;
+	unsigned int lstack = 0;
+				
+	fptr = (volatile unsigned int*)init_bootddr;
+	lpSelfRefresh = (lpfunc)(SRAM_ADDR_STANDBY);
+	
+	p = (volatile unsigned int*)SRAM_ADDR_STANDBY;
+	
+	for (i = 0;i < (SRAM_FUNC_SIZE);i++)
+	{
+		*p = *fptr;
+		p++;
+		fptr++;
+	}
+	
+	while(--i);
+	
+	// Jump to Function Start Point
+	lpSelfRefresh();
+}
+
+#endif // NKUSE
+#endif //defined(DRAM_MDDR)
+
+/************* end of file *************************************************************/
+
+
diff --git a/drivers/block/tcc/kernel_nand_drv.c b/drivers/block/tcc/kernel_nand_drv.c
new file mode 100644
index 0000000..98c4bbd
--- /dev/null
+++ b/drivers/block/tcc/kernel_nand_drv.c
@@ -0,0 +1,685 @@
+/* 
+ *       TITLE: LINUX NAND DRIVER
+ *   CORE TYPE: TCCXXX
+ * DRIVER TYPE: kernel module
+ *        NAME: tccXXX_nand.ko
+ *
+ * @Copyright 2008 Telechips, Inc. 
+ * SYS4-3 Team Linux <linux@telechips.com>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+
+#include <linux/ctype.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/vmalloc.h>
+#include <linux/genhd.h>
+#include <linux/blkdev.h>
+#include <linux/hdreg.h>
+#include <linux/blkpg.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/irq.h>
+#include <asm/scatterlist.h>
+#include <asm/mach-types.h>
+#include <asm/memory.h>
+#include <asm/dma.h>
+
+#include "IO_TCCXXX.h"
+#include "nand_drv.h"
+#include "nand_io_v7.h"
+#include "Disk.h"
+
+#include <linux/tcc_ioctl.h>
+
+#define __USE_TCC_NAND_WORK_Q__
+#ifdef __USE_TCC_NAND_WORK_Q__
+#include <linux/workqueue.h>
+#include <linux/slab.h>
+typedef struct _nand_priv_data_t {
+    struct work_struct nand_work;
+    struct semaphore sem;
+    struct mutex mutex;
+    struct workqueue_struct *wq_ptr;
+    struct request_queue *req;
+} nand_priv_data_t;
+
+nand_priv_data_t tcc_nand_data;
+#endif
+
+struct dma_buf {
+	void *v_addr;
+	unsigned int dma_addr;
+	int buf_size;
+};
+struct dma_buf dma_t;
+
+static int ndevices = 2;
+module_param(ndevices, int, 0);
+
+
+extern unsigned char *gNAND_PageBuffer;
+extern unsigned char gNAND_PartitionInfoLoadFlag;
+//void __iomem *virtadr;
+
+#define NDD_DEV_NAME		"ndd"
+#define NDD_DEV_MAJOR 		240
+#define MAX_NDD_DEV			MAX_NAND_DRIVE	// # of NAND device: 1
+#define NDD_MAX_PARTITIONS  5				// Max # of partitions: 4
+
+/* 
+ * IOCTL
+ */
+#define IOCTL_NDD_GET_INFO			_IO(NDD_DEV_MAJOR, 1)
+#define IOCTL_NDD_MULTI_HD_WRITE	_IO(NDD_DEV_MAJOR, 2)
+#define IOCTL_NDD_MULTI_HD_READ		_IO(NDD_DEV_MAJOR, 3)
+#define IOCTL_NDD_BOOT_WRITE		_IO(NDD_DEV_MAJOR, 4)
+#define IOCTL_NDD_HD_WRITE			_IO(NDD_DEV_MAJOR, 5)
+#define IOCTL_NDD_HD_READ			_IO(NDD_DEV_MAJOR, 6)
+
+struct ndd_data {
+	loff_t i_size;
+};
+
+struct ndd_hidden_info {
+	unsigned int  DriveNum;			// # of multi-hidden area (0~2) - ONLY multi hidden
+	unsigned int  HiddenAddress;	// start page offset
+	unsigned int  SectorNum;		// write/read page size
+	unsigned char *DataBuffer;		// buffer
+	unsigned int  DataBufferSize;	// buffer size
+};
+
+struct ndd_boot_info {
+	char *buf;						// bootloader buffer
+	unsigned int len;				// bootloader length
+};
+
+extern int FWUG_MainFunc(char *rom_buf, int iFileSize);
+//////////////////////////////////////
+
+typedef struct __tag_ndd_dev
+{
+	int						size;
+	u8			 			*data;
+	short					users;
+	short					media_change;
+	struct request_queue 	*queue;
+	spinlock_t				lock;
+	struct gendisk 			*gd;
+	struct timer_list		timer;
+	char 					*buf;
+}Device;
+
+static Device ndd_dev[MAX_NDD_DEV];
+
+static int ndd_open(struct block_device *bdev, fmode_t mode);
+static int ndd_release(struct gendisk *disk, fmode_t mode);
+static int ndd_ioctl (struct block_device *bdev, struct file *filp, unsigned int cmd, unsigned long arg);
+static void ndd_transfer(Device *dev, unsigned long sector, unsigned long nsect, char *buffer, int write);
+static void ndd_request(struct request_queue *q);
+static int ndd_getgeo(struct block_device *bdev, struct hd_geometry *geo);
+
+static struct block_device_operations ndd_fops = 
+{
+	.owner = THIS_MODULE,
+	.open = ndd_open,
+	.release = ndd_release,
+	.ioctl = ndd_ioctl,
+	.getgeo = ndd_getgeo,
+};
+
+
+#ifdef __USE_TCC_NAND_WORK_Q__
+static void tcc_nand_func(struct work_struct *work)
+{
+    nand_priv_data_t *nand_data_ptr = container_of(work, nand_priv_data_t, nand_work);
+	struct request *req;
+    struct request_queue *q = nand_data_ptr->req;
+
+	unsigned int idx = 0, sector = 0;
+	int first = 1;
+	int xfer = 0;
+
+	while ((req = elv_next_request(q)) != NULL) {
+		Device *dev = req->rq_disk->private_data;
+		if( !blk_fs_request(req)) {
+			end_request(req, 0);
+		} else {
+			//printk("(%lu-%d/%lu)", req->sector, req->current_nr_sectors, req->nr_sectors);
+
+			/* read */
+			if (!rq_data_dir(req)) {
+				if (first) {
+					idx = 0;
+					ndd_transfer(dev, req->sector, req->nr_sectors, dev->buf, 0);
+					first = 0;
+				}
+
+				memcpy(req->buffer, &dev->buf[idx * 512], req->current_nr_sectors * 512);
+				idx += req->current_nr_sectors;
+
+				if (req->current_nr_sectors == req->nr_sectors) {
+					first = 1;
+				}				
+				end_request(req, 1);
+
+			/* write */
+			} else {
+				if (first) {
+					idx = 0;
+					first = 0;
+					xfer = 0;
+					sector = req->sector;
+				}
+
+				memcpy(&dev->buf[idx * 512], req->buffer, req->current_nr_sectors * 512);
+				idx += req->current_nr_sectors;
+
+				if (req->current_nr_sectors == req->nr_sectors) {
+					xfer = 1;
+				}
+
+				if (xfer) {
+					ndd_transfer(dev, sector, idx, dev->buf, 1);
+					first = 1;
+				}
+				end_request(req, 1);
+			}
+		}
+	}
+
+    up(&(nand_data_ptr->sem));
+}
+#endif
+
+static int ndd_ioctl (struct block_device *bdev, struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	switch (cmd) {
+		case IOCTL_NDD_MULTI_HD_WRITE:
+		{
+			struct ndd_hidden_info param;
+			char *buf;
+			if (copy_from_user(&param, (void *)arg, sizeof(struct ndd_hidden_info))) {
+				printk("[tcc_nand] IOCTL_NDD_MULTI_HD_WRITE copy_from_user(struct) fail\n");
+				return -EFAULT;
+			}
+			buf = kmalloc(param.DataBufferSize, GFP_KERNEL);
+			if (!buf) {
+				printk("[tcc_nand] IOCTL_NDD_MULTI_HD_WRITE kmalloc fail\n");
+				return -EFAULT;
+			}
+			if (copy_from_user(buf, param.DataBuffer, param.DataBufferSize)) {
+				printk("[tcc_nand] IOCTL_NDD_MULTI_HD_WRITE copy_from_user(buffer) fail\n");
+				kfree(buf);
+				return -EFAULT;
+			}
+			if (NAND_HDWriteSector(param.DriveNum, param.HiddenAddress, param.SectorNum, buf)) {
+				printk("[tcc_nand] IOCTL_NDD_MULTI_HD_WRITE write fail\n");
+				kfree(buf);
+				return -EFAULT;
+			}
+			kfree(buf);
+			break;
+		}
+		case IOCTL_NDD_MULTI_HD_READ:
+		{
+			struct ndd_hidden_info param, *temp;
+			char *buf;
+			temp = (struct ndd_hidden_info *)arg;
+			if (copy_from_user(&param, (void *)arg, sizeof(struct ndd_hidden_info))) {
+				printk("[tcc_nand] IOCTL_NDD_MULTI_HD_READ copy_from_user(struct) fail\n");
+				return -EFAULT;
+			}
+			buf = kmalloc(param.DataBufferSize, GFP_KERNEL);
+			if (!buf) {
+				printk("[tcc_nand] IOCTL_NDD_MULTI_HD_READ kmalloc fail\n");
+				return -EFAULT;
+			}
+			if (NAND_HDReadSector(param.DriveNum, param.HiddenAddress, param.SectorNum, buf)) {
+				printk("[tcc_nand] IOCTL_NDD_MULTI_HD_READ read fail\n");
+				kfree(buf);
+				return -EFAULT;
+			}
+			if (copy_to_user(temp->DataBuffer, buf, temp->DataBufferSize)) {
+				printk("[tcc_nand] IOCTL_NDD_MULTI_HD_READ copy_to_user(buffer) fail\n");
+				kfree(buf);
+				return -EFAULT;
+			}
+			kfree(buf);
+			break;
+		}
+		case IOCTL_NDD_BOOT_WRITE:
+		{
+			int ret;
+			struct ndd_boot_info param;
+			char *buf;
+			if (copy_from_user(&param, (void *)arg, sizeof(struct ndd_boot_info))) {
+				printk("[tcc_nand] IOCTL_NDD_BOOT_UPDATE copy_from_user(struct) fail\n");
+				return -EFAULT;
+			}
+			buf = kmalloc(param.len, GFP_KERNEL);
+			if (!buf) {
+				printk("[tcc_nand] IOCTL_NDD_BOOT_UPDATE kmalloc fail\n");
+				return -EFAULT;
+			}
+			if (copy_from_user(buf, param.buf, param.len)) {
+				printk("[tcc_nand] IOCTL_NDD_BOOT_UPDATE copy_from_user(buffer) fail\n");
+				kfree(buf);
+				return -EFAULT;
+			}
+			ret = FWUG_MainFunc(buf, param.len);
+			if (ret) {
+				printk("[tcc_nand] IOCTL_NDD_BOOT_UPDATE update fail(%d)\n", ret);
+				kfree(buf);
+				return -EFAULT;
+			}
+			kfree(buf);
+			break;
+		}
+		case IOCTL_NDD_HD_WRITE:
+		{
+			struct ndd_hidden_info param;
+			char *buf;
+			if (copy_from_user(&param, (void *)arg, sizeof(struct ndd_hidden_info))) {
+				printk("[tcc_nand] IOCTL_NDD_HD_WRITE copy_from_user(struct) fail\n");
+				return -EFAULT;
+			}
+			buf = kmalloc(param.DataBufferSize, GFP_KERNEL);
+			if (!buf) {
+				printk("[tcc_nand] IOCTL_NDD_HD_WRITE kmalloc fail\n");
+				return -EFAULT;
+			}
+			if (copy_from_user(buf, param.DataBuffer, param.DataBufferSize)) {
+				printk("[tcc_nand] IOCTL_NDD_HD_WRITE copy_from_user(buffer) fail\n");
+				kfree(buf);
+				return -EFAULT;
+			}
+			if (NAND_HDWritePage(param.HiddenAddress, param.SectorNum, buf)) {
+				printk("[tcc_nand] IOCTL_NDD_HD_WRITE write fail\n");
+				kfree(buf);
+				return -EFAULT;
+			}
+			kfree(buf);
+			break;
+		}
+		case IOCTL_NDD_HD_READ:
+		{
+			struct ndd_hidden_info param, *temp;
+			char *buf;
+			temp = (struct ndd_hidden_info *)arg;
+			if (copy_from_user(&param, (void *)arg, sizeof(struct ndd_hidden_info))) {
+				printk("[tcc_nand] IOCTL_NDD_HD_READ copy_from_user(struct) fail\n");
+				return -EFAULT;
+			}
+			buf = kmalloc(param.DataBufferSize, GFP_KERNEL);
+			if (!buf) {
+				printk("[tcc_nand] IOCTL_NDD_HD_READ kmalloc fail\n");
+				return -EFAULT;
+			}
+			if (NAND_HDReadPage(param.HiddenAddress, param.SectorNum, buf)) {
+				printk("[tcc_nand] IOCTL_NDD_HD_READ write fail\n");
+				kfree(buf);
+				return -EFAULT;
+			}
+			if (copy_to_user(temp->DataBuffer, buf, temp->DataBufferSize)) {
+				printk("[tcc_nand] IOCTL_NDD_HD_READ copy_to_user(buffer) fail\n");
+				kfree(buf);
+				return -EFAULT;
+			}
+			kfree(buf);
+			break;
+		}
+
+		/* for USB MSC */
+		case IOCTL_NDD_GET_INFO:
+		{
+			struct ndd_data ndata;
+			void __user *uarg = (void __user *) arg;
+			ndata.i_size = i_size_read(filp->f_mapping->host);
+			if (copy_to_user(uarg, &ndata, sizeof(ndata)))
+				return -EFAULT;
+			break;
+		}
+
+		case IOCTL_STORAGE_PING:
+		{
+			// ping
+			break;
+		}
+		case IOCTL_STORAGE_DIRECT_READ:
+		{
+			Device *dev = bdev->bd_disk->private_data;
+			struct storage_direct sdArg;
+			unsigned int sector, nsect;
+			void *buf;
+
+			if (copy_from_user(&sdArg, (void __user *)arg, sizeof(struct storage_direct))) {
+				printk("[tcc_nand] IOCTL_STORAGE_DIRECT_READ copy_from_user(struct) fail\n");
+				return -EFAULT;
+			}
+
+			sector = sdArg.pos>>9;
+			nsect = sdArg.count>>9;
+			if(sdArg.user_space)
+			{
+				printk("[tcc_nand] IOCTL_STORAGE_DIRECT_READ access from user space is not supported yet.\n");
+				return -EFAULT;
+			}
+			else
+				buf = sdArg.buf;
+			if( (sector + nsect) > dev->size ) {
+				printk("beyond-end read (%d %d %d)\n", sector, nsect, dev->size);
+				return -EFAULT;
+			}
+			if (NAND_ReadSector(0, sector, nsect, buf)) {
+				printk("[tcc_nand] IOCTL_STORAGE_DIRECT_READ read fail\n");
+				return -EFAULT;
+			}
+			sdArg.pos += sdArg.count;
+			sdArg.actual = sdArg.count;
+			if (copy_to_user((void __user *)arg, &sdArg, sizeof(struct storage_direct)))
+			{
+				printk("[tcc_nand] IOCTL_STORAGE_DIRECT_READ copy_to_user(struct) fail\n");
+				return -EFAULT;
+			}
+			break;
+		}
+		case IOCTL_STORAGE_DIRECT_WRITE:
+		{
+			Device *dev = bdev->bd_disk->private_data;
+			struct storage_direct sdArg;
+			unsigned int sector, nsect;
+			void *buf;
+
+			if (copy_from_user(&sdArg, (void __user *)arg, sizeof(struct storage_direct))) {
+				printk("[tcc_nand] IOCTL_STORAGE_DIRECT_WRITE copy_from_user(struct) fail\n");
+				return -EFAULT;
+			}
+
+			sector = sdArg.pos>>9;
+			nsect = sdArg.count>>9;
+			if(sdArg.user_space)
+			{
+				printk("[tcc_nand] IOCTL_STORAGE_DIRECT_WRITE access from user space is not supported yet.\n");
+				return -EFAULT;
+			}
+			else
+				buf = sdArg.buf;
+			if( (sector + nsect) > dev->size ) {
+				printk("beyond-end write (%d %d %d)\n", sector, nsect, dev->size);
+				return -EFAULT;
+			}
+			if (NAND_WriteSector(0, sector, nsect, buf)) {
+				printk("[tcc_nand] IOCTL_STORAGE_DIRECT_WRITE write fail\n");
+				return -EFAULT;
+			}
+			sdArg.pos += sdArg.count;
+			sdArg.actual = sdArg.count;
+			if (copy_to_user((void __user *)arg, &sdArg, sizeof(struct storage_direct)))
+			{
+				printk("[tcc_nand] IOCTL_STORAGE_DIRECT_WRITE copy_to_user(struct) fail\n");
+				return -EFAULT;
+			}
+			break;
+		}
+		default:
+			printk("[tcc_nand] ioctl (0x%x)\n", cmd); 
+			return -ENOIOCTLCMD;
+			break;
+	}
+
+	return 0;
+}
+
+static int ndd_getgeo(struct block_device *bdev, struct hd_geometry *geo)
+{
+	geo->cylinders = gNAND_DrvInfo[0].Cylinder;
+	geo->heads =  gNAND_DrvInfo[0].Head;
+	geo->sectors = gNAND_DrvInfo[0].Sector;
+	geo->start = get_start_sect(bdev);
+
+	return 0;
+}
+
+static int ndd_open(struct block_device *bdev, fmode_t mode)
+{
+	Device *dev = bdev->bd_disk->private_data;
+
+	spin_lock(&dev->lock);
+	dev->users++;
+	spin_unlock(&dev->lock);
+
+	return 0;
+}
+
+static int ndd_release(struct gendisk *disk, fmode_t mode)
+{
+	Device *dev = disk->private_data;
+
+	spin_lock(&dev->lock);
+	dev->users--;
+	spin_unlock(&dev->lock);
+
+	return 0;
+}
+
+static int __init ndd_init(void)
+{
+	int res, i;
+
+#ifdef __USE_TCC_NAND_WORK_Q__
+    mutex_init(&(tcc_nand_data.mutex));
+    sema_init(&(tcc_nand_data.sem), 0);
+    tcc_nand_data.wq_ptr = create_workqueue("nand_work_q");
+    if (tcc_nand_data.wq_ptr == NULL) {
+        return -ENOMEM;
+    }
+
+    INIT_WORK(&(tcc_nand_data.nand_work), tcc_nand_func);
+#endif
+	
+	/* DTCM mapping */
+	//virtadr = (void __iomem *)ioremap(IO_NFC_BUFFER0_BASE, 512);
+	//printk("DTCM ioremap %s: 0x%08X -> 0x%08X\n", virtadr?"OK":"FAIL", IO_NFC_BUFFER0_BASE, virtadr);
+	//if (!virtadr) {
+	//	printk("ndd: ioremap failed\n");
+	//	iounmap((void *)virtadr);
+	//	return -EIO;
+	//}
+
+	/* DMA alloc */
+	dma_t.buf_size = 1024;
+	dma_t.v_addr = dma_alloc_writecombine(0, dma_t.buf_size, &dma_t.dma_addr, GFP_KERNEL);
+	//printk("[tcc_nand] alloc DMA buffer @0x%08X(phy=0x%08X), size=%d\n", 
+	//		(unsigned int)dma_t.v_addr, dma_t.dma_addr, dma_t.buf_size);
+
+	gNAND_PageBuffer = (unsigned char *)( ((unsigned int)gNAND_PageBuffer + 8) & 0xFFFFFFF8 );
+
+	for (i = 0; i < MAX_NDD_DEV ; i++) {
+		/*
+		 * NAND INIT - NAND_Ioctl(DEV_INITIALIZE)
+		 */
+
+		NAND_Ioctl(DEV_INITIALIZE, NULL);
+
+#if 0		/* 09.07.24 */
+		NAND_Init();
+	
+		if ( gNAND_PartitionInfoLoadFlag == DISABLE )
+			NAND_InitExtPartitionInfo();
+		else
+			TNFTL_SetExtendedPartitionNums( NAND_DRV_0, (U16)gTNFTL_ExtPartitionInfo[NAND_DRV_0].ExtendedPartitionNum );
+		
+		for ( i = 0; i < gTNFTL_ExtPartitionInfo[NAND_DRV_0].ExtendedPartitionNum; ++i )
+		{
+			TNFTL_AREASetTotalSectorSize( gNAND_DrvInfo[0].NFTLDrvInfo,
+										  &gNAND_DrvInfo[0].NFTLDrvInfo->ExtPartition[i],
+										  gTNFTL_ExtPartitionInfo[NAND_DRV_0].ExtPartitionSize[i] );
+		}
+
+		gNAND_DrvInfo[i].DrvStatus = DISABLE;
+
+		res = NAND_InitDrive(i); 
+		if (res != SUCCESS) {
+			printk("ndd: TNFTL(%s, %s) init failed(0x%08x)\n", TCC_ARCH, NAND_VER, res);
+			return EINITFAIL;
+		}
+	
+		TNFTL_AREAGetTotalSecAndCHS( gNAND_DrvInfo[0].NFTLDrvInfo,
+					 			     &gNAND_DrvInfo[0].NFTLDrvInfo->PriPartition,
+					 			     (U32 *)&gNAND_DrvInfo[0].TotalDiskSector,
+					 			     &gNAND_DrvInfo[0].Cylinder,
+					 			     &gNAND_DrvInfo[0].Head,
+					 			     &gNAND_DrvInfo[0].Sector );
+
+		gNAND_DrvInfo[i].DrvStatus = ENABLE;
+#endif /* 0 */
+		//<-- end of NAND_INIT
+
+		res = register_blkdev(NDD_DEV_MAJOR, NDD_DEV_NAME); 
+		if (res < 0) {
+			printk(KERN_WARNING "ndd: unable to get major number.\n");
+			return -EBUSY;
+		}
+
+		ndd_dev[i].size = gNAND_DrvInfo[i].TotalDiskSector;
+		ndd_dev[i].data = kmalloc(sizeof(Device), GFP_KERNEL);	//size should be less than 128*1024
+		ndd_dev[i].buf = kmalloc((sizeof(char) * 256 * 512), GFP_KERNEL);
+		if (!ndd_dev[i].data || !ndd_dev[i].buf) {
+			printk("ndd: Unable to allocate NAND device structure.\n");
+			kfree(ndd_dev[i].data);
+			kfree(ndd_dev[i].buf);
+			return 0;
+		}
+		memset(ndd_dev[i].data, 0, sizeof(Device));
+
+		// init gendisk
+		ndd_dev[i].gd = alloc_disk(NDD_MAX_PARTITIONS);
+		if (!ndd_dev[i].gd) {
+			printk("ndd: allocate gendisk failed.\n");
+			return 0;
+		}
+
+		spin_lock_init(&(ndd_dev[i].lock));
+		ndd_dev[i].queue 			= blk_init_queue(ndd_request, &(ndd_dev[i].lock));
+		ndd_dev[i].gd->major 		= NDD_DEV_MAJOR;
+		ndd_dev[i].gd->first_minor 	= i * NDD_MAX_PARTITIONS;
+		ndd_dev[i].gd->fops 		= &ndd_fops;
+		ndd_dev[i].gd->private_data = &ndd_dev[i];
+		sprintf(ndd_dev[i].gd->disk_name, "ndd%c", 'a' + i);
+		set_capacity(ndd_dev[i].gd, gNAND_DrvInfo[0].TotalDiskSector);
+		ndd_dev[i].gd->queue 		= ndd_dev[i].queue;
+
+//		ndd_dev[i].queue->queue_flags |= (1<<QUEUE_FLAG_WRITEFULL) | (1<<QUEUE_FLAG_READFULL) | (1<<QUEUE_FLAG_ELVSWITCH);
+
+		// add gendisk
+		add_disk(ndd_dev[i].gd);
+	}
+
+#if 0
+	printk("DrvStatus       0x%08x\n", gNAND_DrvInfo[0].DrvStatus);
+	printk("TotalDiskSector 0x%08x\n", gNAND_DrvInfo[0].TotalDiskSector);
+	printk("Cylinder        0x%08x\n", gNAND_DrvInfo[0].Cylinder);
+	printk("Head            0x%08x\n", gNAND_DrvInfo[0].Head);
+	printk("Sector          0x%08x\n", gNAND_DrvInfo[0].Sector);
+#endif
+
+	printk("[tcc_nand] init ndd(%s, %s)\n", TCC_ARCH, NAND_VER);
+	return 0;
+}
+
+static void ndd_request(struct request_queue *q)
+{
+#ifdef __USE_TCC_NAND_WORK_Q__
+    mutex_lock(&(tcc_nand_data.mutex));
+    tcc_nand_data.req = q;
+
+    queue_work(tcc_nand_data.wq_ptr, &(tcc_nand_data.nand_work));
+    if (down_interruptible(&(tcc_nand_data.sem))) {
+        flush_workqueue(tcc_nand_data.wq_ptr);
+        sema_init(&(tcc_nand_data.sem), 0);
+    }
+    mutex_unlock(&(tcc_nand_data.mutex));
+#else
+	struct request *req;
+		
+	while((req = elv_next_request(q)) != NULL) {
+		Device *dev = req->rq_disk->private_data;
+		if( !blk_fs_request(req)) {
+			end_request(req,0);
+		} else {
+			ndd_transfer(dev, req->sector,
+					req->current_nr_sectors,
+					req->buffer, rq_data_dir(req));
+			end_request(req,1);
+		}
+	}
+#endif
+}
+
+static void ndd_transfer(Device *dev, unsigned long sector,
+		unsigned long nsect, char *buffer, int write)
+{	
+	//printk("%s: sector(%lu), nsect(%lu)\n", write?"write":"read", sector, nsect);
+	if( (sector + nsect) > dev->size ) {
+		printk(KERN_NOTICE "beyond-end write (%lu %lu %d)\n",
+				sector, nsect, dev->size);
+		return;
+	}
+
+	if(write) {
+		//printk("|");
+		NAND_WriteSector(0, sector, nsect, buffer);
+	} else {
+		//printk("-");
+		NAND_ReadSector(0, sector, nsect, buffer);
+	}
+}
+
+static void __exit ndd_exit(void)
+{
+	int i;
+	printk("[tcc_nand]: exit ndd\n");
+
+#ifdef __USE_TCC_NAND_WORK_Q__
+    if (tcc_nand_data.wq_ptr) {
+        flush_workqueue(tcc_nand_data.wq_ptr);
+        destroy_workqueue(tcc_nand_data.wq_ptr);
+        tcc_nand_data.wq_ptr = NULL;
+    }
+    memset(&tcc_nand_data, 0, sizeof(nand_priv_data_t));
+#endif
+	
+	for(i = 0; i < MAX_NDD_DEV; i++) {	
+		del_gendisk(ndd_dev[i].gd);
+		put_disk(ndd_dev[i].gd);
+		blk_cleanup_queue(ndd_dev[i].queue);
+		kfree(ndd_dev[i].data);
+		kfree(ndd_dev[i].buf);
+	}
+
+	//iounmap(virtadr);
+	dma_free_writecombine(0, dma_t.buf_size, dma_t.v_addr, dma_t.dma_addr);
+	unregister_blkdev(NDD_DEV_MAJOR, NDD_DEV_NAME);
+}
+
+
+module_init(ndd_init);
+module_exit(ndd_exit);
+
+MODULE_AUTHOR("Telechips Inc. SYS4-3 twkwon@telechips.com");
+MODULE_DESCRIPTION("TCC NAND driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/block/tcc/libtnftl/libtnftl_V6005_TCC8900.o_shipped b/drivers/block/tcc/libtnftl/libtnftl_V6005_TCC8900.o_shipped
new file mode 100644
index 0000000000000000000000000000000000000000..4de126c4730bd87be073c7eaa273afd8aaf0e17c
GIT binary patch
literal 198915
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
ZVP&q}UEjF9O?Ta?i)+5e6giyu{{dJ4&%Xcw

literal 0
HcmV?d00001

diff --git a/drivers/block/tcc/libtnftl/libtnftl_V7003_TCC8900.o_shipped b/drivers/block/tcc/libtnftl/libtnftl_V7003_TCC8900.o_shipped
new file mode 100644
index 0000000000000000000000000000000000000000..7983ac32cb37fa9deab52adfb8da7437917c64b9
GIT binary patch
literal 202508
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%0AI`&14
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%0AAcH+d9K#@
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
Q;j7tQVgo0YPAxb851%naegFUf

literal 0
HcmV?d00001

diff --git a/drivers/block/tcc/nand_buffer.c b/drivers/block/tcc/nand_buffer.c
new file mode 100644
index 0000000..0bcb5b0
--- /dev/null
+++ b/drivers/block/tcc/nand_buffer.c
@@ -0,0 +1,40 @@
+/****************************************************************************
+ *   FileName    : nand_buffer.c
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+#include "nand_drv.h"
+
+
+#if defined( FWDN_DOWNLOADER_INCLUDE )
+const unsigned char	NANDBUF_Library_Version[] = { "SIGBYAHONG_NANDBUF_FWDN_V001000" };
+#elif defined(TCC92XX)
+const unsigned char	NANDBUF_Library_Version[] = { "SIGBYAHONG_NANDBUF_TCC92XX_V001000" };
+#elif defined(TCC89XX)
+const unsigned char	NANDBUF_Library_Version[] = { "SIGBYAHONG_NANDBUF_TCC89XX_V001000" };
+#endif
+
+//**********************************************************
+//*
+//*		Global Variables
+//*
+//**********************************************************
+#if defined(_WINCE_)
+#pragma pack(8)
+unsigned char	gNAND_PageBuffer[TNFTL_MAX_SUPPORT_NAND_IO_PAGE_SIZE + TNFTL_MAX_SUPPORT_NAND_IO_SPARE_SIZE];
+unsigned char	gNAND_RCacheDTAreaBuffer[TNFTL_MAX_SUPPORT_RCACHE_MEMORY_SIZE];
+unsigned char	gNAND_AlignBuffer[TNFTL_MAX_SUPPORT_ALIGNCACHE_MEMORY_SIZE];
+#pragma pack()
+#elif defined(_LINUX_)
+	//NOTE: In the case of LINUX, gNAND_PageBuffer is defined nand_drv.c
+#else
+__align(8) unsigned char	gNAND_PageBuffer[TNFTL_MAX_SUPPORT_NAND_IO_PAGE_SIZE + TNFTL_MAX_SUPPORT_NAND_IO_SPARE_SIZE];
+__align(8) unsigned char 	gNAND_RCacheDTAreaBuffer[TNFTL_MAX_SUPPORT_RCACHE_MEMORY_SIZE];
+__align(8) unsigned char	gNAND_AlignBuffer[TNFTL_MAX_SUPPORT_ALIGNCACHE_MEMORY_SIZE];
+#endif
+
diff --git a/drivers/block/tcc/nand_crc.c b/drivers/block/tcc/nand_crc.c
new file mode 100644
index 0000000..6d692b2
--- /dev/null
+++ b/drivers/block/tcc/nand_crc.c
@@ -0,0 +1,193 @@
+
+/****************************************************************************
+ *   FileName    : nand_crc.c
+ *   Description : 
+ ****************************************************************************
+*
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+*
+ ****************************************************************************/
+const unsigned	CRC32_TABLE[256] = {
+	0x00000000,	0x90910101,	0x91210201,	0x01B00300,
+	0x92410401,	0x02D00500,	0x03600600,	0x93F10701,
+	0x94810801,	0x04100900,	0x05A00A00,	0x95310B01,
+	0x06C00C00,	0x96510D01,	0x97E10E01,	0x07700F00,
+	0x99011001,	0x09901100,	0x08201200,	0x98B11301,
+	0x0B401400,	0x9BD11501,	0x9A611601,	0x0AF01700,
+	0x0D801800,	0x9D111901,	0x9CA11A01,	0x0C301B00,
+	0x9FC11C01,	0x0F501D00,	0x0EE01E00,	0x9E711F01,
+	0x82012001,	0x12902100,	0x13202200,	0x83B12301,
+	0x10402400,	0x80D12501,	0x81612601,	0x11F02700,
+	0x16802800,	0x86112901,	0x87A12A01,	0x17302B00,
+	0x84C12C01,	0x14502D00,	0x15E02E00,	0x85712F01,
+	0x1B003000,	0x8B913101,	0x8A213201,	0x1AB03300,
+	0x89413401,	0x19D03500,	0x18603600,	0x88F13701,
+	0x8F813801,	0x1F103900,	0x1EA03A00,	0x8E313B01,
+	0x1DC03C00,	0x8D513D01,	0x8CE13E01,	0x1C703F00,
+	0xB4014001,	0x24904100,	0x25204200,	0xB5B14301,
+	0x26404400,	0xB6D14501,	0xB7614601,	0x27F04700,
+	0x20804800,	0xB0114901,	0xB1A14A01,	0x21304B00,
+	0xB2C14C01,	0x22504D00,	0x23E04E00,	0xB3714F01,
+	0x2D005000,	0xBD915101,	0xBC215201,	0x2CB05300,
+	0xBF415401,	0x2FD05500,	0x2E605600,	0xBEF15701,
+	0xB9815801,	0x29105900,	0x28A05A00,	0xB8315B01,
+	0x2BC05C00,	0xBB515D01,	0xBAE15E01,	0x2A705F00,
+	0x36006000,	0xA6916101,	0xA7216201,	0x37B06300,
+	0xA4416401,	0x34D06500,	0x35606600,	0xA5F16701,
+	0xA2816801,	0x32106900,	0x33A06A00,	0xA3316B01,
+	0x30C06C00,	0xA0516D01,	0xA1E16E01,	0x31706F00,
+	0xAF017001,	0x3F907100,	0x3E207200,	0xAEB17301,
+	0x3D407400,	0xADD17501,	0xAC617601,	0x3CF07700,
+	0x3B807800,	0xAB117901,	0xAAA17A01,	0x3A307B00,
+	0xA9C17C01,	0x39507D00,	0x38E07E00,	0xA8717F01,
+	0xD8018001,	0x48908100,	0x49208200,	0xD9B18301,
+	0x4A408400,	0xDAD18501,	0xDB618601,	0x4BF08700,
+	0x4C808800,	0xDC118901,	0xDDA18A01,	0x4D308B00,
+	0xDEC18C01,	0x4E508D00,	0x4FE08E00,	0xDF718F01,
+	0x41009000,	0xD1919101,	0xD0219201,	0x40B09300,
+	0xD3419401,	0x43D09500,	0x42609600,	0xD2F19701,
+	0xD5819801,	0x45109900,	0x44A09A00,	0xD4319B01,
+	0x47C09C00,	0xD7519D01,	0xD6E19E01,	0x46709F00,
+	0x5A00A000,	0xCA91A101,	0xCB21A201,	0x5BB0A300,
+	0xC841A401,	0x58D0A500,	0x5960A600,	0xC9F1A701,
+	0xCE81A801,	0x5E10A900,	0x5FA0AA00,	0xCF31AB01,
+	0x5CC0AC00,	0xCC51AD01,	0xCDE1AE01,	0x5D70AF00,
+	0xC301B001,	0x5390B100,	0x5220B200,	0xC2B1B301,
+	0x5140B400,	0xC1D1B501,	0xC061B601,	0x50F0B700,
+	0x5780B800,	0xC711B901,	0xC6A1BA01,	0x5630BB00,
+	0xC5C1BC01,	0x5550BD00,	0x54E0BE00,	0xC471BF01,
+	0x6C00C000,	0xFC91C101,	0xFD21C201,	0x6DB0C300,
+	0xFE41C401,	0x6ED0C500,	0x6F60C600,	0xFFF1C701,
+	0xF881C801,	0x6810C900,	0x69A0CA00,	0xF931CB01,
+	0x6AC0CC00,	0xFA51CD01,	0xFBE1CE01,	0x6B70CF00,
+	0xF501D001,	0x6590D100,	0x6420D200,	0xF4B1D301,
+	0x6740D400,	0xF7D1D501,	0xF661D601,	0x66F0D700,
+	0x6180D800,	0xF111D901,	0xF0A1DA01,	0x6030DB00,
+	0xF3C1DC01,	0x6350DD00,	0x62E0DE00,	0xF271DF01,
+	0xEE01E001,	0x7E90E100,	0x7F20E200,	0xEFB1E301,
+	0x7C40E400,	0xECD1E501,	0xED61E601,	0x7DF0E700,
+	0x7A80E800,	0xEA11E901,	0xEBA1EA01,	0x7B30EB00,
+	0xE8C1EC01,	0x7850ED00,	0x79E0EE00,	0xE971EF01,
+	0x7700F000,	0xE791F101,	0xE621F201,	0x76B0F300,
+	0xE541F401,	0x75D0F500,	0x7460F600,	0xE4F1F701,
+	0xE381F801,	0x7310F900,	0x72A0FA00,	0xE231FB01,
+	0x71C0FC00,	0xE151FD01,	0xE0E1FE01,	0x7070FF00
+};
+
+/************************************************************************************************
+* FUNCTION		: int SetKitlMode(int argc, char *argv[])
+*
+* DESCRIPTION	: 
+*
+************************************************************************************************/
+unsigned long makecrc (unsigned char *s, unsigned n)
+{
+    unsigned long c;
+    static unsigned long crc = (unsigned long)0xffffffffL;
+
+    if (s == 0)
+	{
+		c = 0xffffffffL;
+    }
+	else
+	{
+		c = crc;
+        if (n)
+        {
+            do
+		    {
+                c = CRC32_TABLE[((int)c ^ (*s++)) & 0xff] ^ (c >> 8);
+            } while (--n);
+        }
+    }
+    crc = c;
+    return c ^ 0xffffffffL;
+}
+
+int VerifyROMFile(unsigned int *pBuffer,unsigned int size )
+{
+	#if defined(NAND_INCLUDE)
+	unsigned int crcout = 0;
+	unsigned int cnt, i, code, tmp;
+	unsigned int First_CrcRegion, Second_CrcRegion;
+
+	First_CrcRegion = (128<<10)>>2;  //=32768  
+	Second_CrcRegion = (size>>2);
+
+
+	//First CRC Check 0~128kbyte	
+	for(cnt=0; cnt<First_CrcRegion; cnt++)
+	{
+		if(cnt == 4 || cnt == 5)
+			continue;
+		
+		code = pBuffer[cnt];
+		for(i=0; i<4; i++)
+		{
+			tmp = code^crcout;
+			crcout = (crcout>>8)^CRC32_TABLE[tmp&0xFF];
+			code = code >> 8;
+		}
+	}
+	if(crcout !=pBuffer[4]) return -1;
+
+
+	//Second CRC Check 0~End
+	crcout=0;
+	
+	for(cnt=0; cnt<Second_CrcRegion; cnt++)
+	{
+		code = pBuffer[cnt];	
+		if(cnt == 4 || cnt == 5 )
+		{
+			continue;
+		}
+		else if(cnt==6){
+			code = 0x00000000;
+		}
+		
+		for(i=0; i<4; i++)
+		{
+			tmp = code^crcout;
+			crcout = (crcout>>8)^CRC32_TABLE[tmp&0xFF];
+			code = code >> 8;
+		}
+		
+	}
+	if(crcout !=pBuffer[6]) return -1;
+
+	#endif
+	
+	return 1;
+}
+
+int VerifyROMFile_128K(unsigned int *pBuffer,unsigned int size )
+{
+
+	unsigned int crcout = 0;
+	unsigned int cnt, i, code, tmp;
+	unsigned int First_CrcRegion, Second_CrcRegion;
+
+	First_CrcRegion = (128<<10)>>2;  //=32768  
+	Second_CrcRegion = (size>>2);
+
+
+	//First CRC Check 0~128kbyte	
+	for(cnt=0; cnt<First_CrcRegion; cnt++)
+	{
+		if(cnt == 4 || cnt == 5)
+			continue;
+		
+		code = pBuffer[cnt];
+		for(i=0; i<4; i++)
+		{
+			tmp = code^crcout;
+			crcout = (crcout>>8)^CRC32_TABLE[tmp&0xFF];
+			code = code >> 8;
+		}
+	}
+	if(crcout !=pBuffer[4]) return -1;
+	return 1;
+}
diff --git a/drivers/block/tcc/nand_drv.c b/drivers/block/tcc/nand_drv.c
new file mode 100644
index 0000000..0380f29
--- /dev/null
+++ b/drivers/block/tcc/nand_drv.c
@@ -0,0 +1,2117 @@
+/****************************************************************************
+ *   FileName    : nand_drv.c
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+#if defined(_LINUX_)
+#include "common.h"
+#if defined(USE_V_ADDRESS)
+#include <linux/kernel.h>
+#include <linux/string.h>
+#endif
+#endif
+
+#if defined(_LINUX_) || defined(_WINCE_)
+//#include "IO_TCC7XX.h"
+#include "nand_drv.h"
+//#include "Disk.h"
+#include "TC_File.h"
+#else
+#include "Globals.h"
+#include "IO_TCCXXX.h"
+#include "nand_drv.h"
+#include "disk.h"
+#include "FileBufferCtrl.h"
+#include "Assert.h"
+#endif
+
+#ifdef _WINCE_
+#include "bsp.h"
+#include "args.h"
+#endif
+
+#if defined(__NUCLEUS_KERNEL__)
+#include "TC_Kernel.h"
+#endif
+
+#ifdef AUDIOUI_INCLUDE	
+#include "AudioUI.H"
+#endif
+
+
+//#define NAND_DRV_PORT_DEBUG
+
+#ifdef BOOTCRCCHEK
+	typedef struct _BootCRC
+	{
+		unsigned int crc128kchk;
+		unsigned int crcfullchk;
+		unsigned int bootfilesize;
+	}BootCRC; 
+#endif
+
+#ifndef WITHOUT_FILESYSTEM
+
+#if defined( FWDN_DOWNLOADER_INCLUDE )
+const unsigned char	NANDDRV_Library_Version[] = { "SIGBYAHONG_NANDDRV_FWDN_V001000" };
+#elif defined(TCC92XX)
+const unsigned char	NANDDRV_Library_Version[] = { "SIGBYAHONG_NANDDRV_TCC92XX_V001000" };
+#elif defined(TCC89XX)
+const unsigned char	NANDDRV_Library_Version[] = { "SIGBYAHONG_NANDDRV_TCC89XX_V001000" };
+#endif
+
+//=============================================================================
+//*
+//*
+//*                           [ CONST DATA DEFINE ]
+//*
+//*
+//=============================================================================
+#define NAND_DRV_HIDDEN_INFO_SIZE	( 19 + 8 + 1*4 )
+
+const unsigned char gNAND_HiddenInfoSignature[ NAND_DRV_HIDDEN_INFO_SIZE ] =
+{
+	'T','N','F','T','L','H','I','D','D','E','N','S','I','Z','E','I','N','F','O',
+    
+    #ifndef NU_FILE_INCLUDE
+	#ifdef AUDIOUI_INCLUDE	
+	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE+AUI_HD_OCCPAGE) >>  0) & 0xFF,
+	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE+AUI_HD_OCCPAGE) >>  8) & 0xFF,
+	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE+AUI_HD_OCCPAGE) >> 16) & 0xFF,
+	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE+AUI_HD_OCCPAGE) >> 24) & 0xFF,
+	#else
+	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE) >>  0) & 0xFF,
+	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE) >>  8) & 0xFF,
+	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE) >> 16) & 0xFF,
+	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE)>> 24) & 0xFF,
+    #endif
+    #else
+    ((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE) >>  0) & 0xFF,
+	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE) >>  8) & 0xFF,
+	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE) >> 16) & 0xFF,
+	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE) >> 24) & 0xFF,
+	#endif
+
+	((unsigned long int)TNFTL_MULTI_HIDDEN_AREA_NUM >>  0) & 0xFF,
+	((unsigned long int)TNFTL_MULTI_HIDDEN_AREA_NUM >>  8) & 0xFF,
+	((unsigned long int)TNFTL_MULTI_HIDDEN_AREA_NUM >> 16) & 0xFF,
+	((unsigned long int)TNFTL_MULTI_HIDDEN_AREA_NUM >> 24) & 0xFF,
+
+	((unsigned long int)NAND_HIDDEN_DRIVE_DEFAULT_TOTAL_SECTOR_SIZE >>  0) & 0xFF,
+	((unsigned long int)NAND_HIDDEN_DRIVE_DEFAULT_TOTAL_SECTOR_SIZE >>  8) & 0xFF,
+	((unsigned long int)NAND_HIDDEN_DRIVE_DEFAULT_TOTAL_SECTOR_SIZE >> 16) & 0xFF,
+	((unsigned long int)NAND_HIDDEN_DRIVE_DEFAULT_TOTAL_SECTOR_SIZE >> 24) & 0xFF
+};
+
+//=============================================================================
+//*
+//*
+//*                           [ GLOBAL VARIABLE DEFINE ]
+//*
+//*
+//=============================================================================
+NAND_DRVINFO		gNAND_DrvInfo[MAX_NAND_DRIVE];
+TNFTL_HIDDEN_INFO	gTNFTL_HiddenInfo[MAX_NAND_DRIVE];
+
+TNFTL_DRVINFO		gTNFTL_DrvInfo[MAX_NAND_DRIVE];
+TNFTL_RW_AREA		gTNFTL_MULTIHDAreaInfo[MAX_NAND_DRIVE][TNFTL_MULTI_HIDDEN_AREA_MAX_NUM];
+TNFTL_LPT_BLOCK		gTNFTL_DTAreaLPTBlk[MAX_NAND_DRIVE][TNFTL_LPT_BLK_NUM_For_DATA_AREA];
+TNFTL_LPT_BLOCK		gTNFTL_HDAreaLPTBlk[MAX_NAND_DRIVE][TNFTL_LPT_BLK_NUM_For_HIDDEN_AREA];
+TNFTL_LPT_BLOCK		gTNFTL_MULTIHDAreaLPTBlk[MAX_NAND_DRIVE][TNFTL_MULTI_HIDDEN_AREA_MAX_NUM][TNFTL_LPT_BLK_NUM_For_DATA_AREA];
+TNFTL_WCACHE		gTNFTL_DTAreaWCache[MAX_NAND_DRIVE][TNFTL_WCACHE_NUM_For_DATA_AREA];
+TNFTL_WCACHE		gTNFTL_HDAreaWCache[MAX_NAND_DRIVE][TNFTL_WCACHE_NUM_For_HIDDEN_AREA];
+TNFTL_WCACHE		gTNFTL_MULTIHDAreaWCache[MAX_NAND_DRIVE][TNFTL_MULTI_HIDDEN_AREA_MAX_NUM][TNFTL_WCACHE_NUM_For_DATA_AREA];
+
+#if defined( TNFTL_V5_INCLUDE ) || defined(TNFTL_V6_INCLUDE)
+TNFTL_RCACHE_SLOT 	gTNFTL_DTAreaRCache[MAX_NAND_DRIVE][TNFTL_MAX_SUPPORT_RCACHE_MEMORY_SIZE>>9];
+TNFTL_RCACHE_SLOT	gTNFTL_HDAreaRCache[MAX_NAND_DRIVE][TNFTL_MAX_SUPPORT_RCACHE_MEMORY_SIZE>>9];
+TNFTL_RCACHE_SLOT	gTNFTL_MULTIHDAreaRCache[MAX_NAND_DRIVE][TNFTL_MULTI_HIDDEN_AREA_MAX_NUM][TNFTL_MAX_SUPPORT_RCACHE_MEMORY_SIZE>>9];
+#endif
+
+TNFTL_MAINPB_INFO 	gTNFTL_DTAreaMainPBInfo[MAX_NAND_DRIVE][TNFTL_WCACHE_NUM_For_DATA_AREA];
+TNFTL_MAINPB_INFO 	gTNFTL_HDAreaMainPBInfo[MAX_NAND_DRIVE][TNFTL_WCACHE_NUM_For_HIDDEN_AREA];
+TNFTL_MAINPB_INFO 	gTNFTL_MULTIHDAreaMainPBInfo[MAX_NAND_DRIVE][TNFTL_MULTI_HIDDEN_AREA_MAX_NUM][TNFTL_WCACHE_NUM_For_DATA_AREA];
+
+NAND_IO_DEVINFO		*gLBA_DevInfo;
+
+unsigned char		gNAND_UARTDebugFlag = DISABLE;
+unsigned char		gNAND_HiddenInfoLoadFlag = DISABLE;
+#if defined(_LINUX_) || defined(_WINCE_)
+unsigned char		gNAND_SetFlagOfChangeAreaSize = DISABLE;
+unsigned char		gFormatType	= TC_LOWLEVEL_YES;
+unsigned int		gMAX_ROMSIZE = MAX_ROMSIZE_NAND;
+#else
+unsigned char		gNAND_SetFlagOfChangeAreaSize = ENABLE;
+#endif
+
+//=============================================================================
+//*
+//*
+//*                           [ LOCAL FUNCTIONS DEFINE ]
+//*
+//*
+//=============================================================================
+
+//=============================================================================
+//*
+//*
+//*                     [ EXTERN VARIABLE & FUNCTIONS DEFINE ]
+//*
+//*
+//=============================================================================
+extern unsigned char	NANDBUF_Library_Version[];
+#if defined(_LINUX_)
+unsigned char gNAND_PageBuffer[TNFTL_MAX_SUPPORT_NAND_IO_PAGE_SIZE + TNFTL_MAX_SUPPORT_NAND_IO_SPARE_SIZE] __attribute__((aligned(8)));
+unsigned char gNAND_RCacheDTAreaBuffer[TNFTL_MAX_SUPPORT_RCACHE_MEMORY_SIZE] __attribute__((aligned(8)));
+unsigned char gNAND_AlignBuffer[TNFTL_MAX_SUPPORT_ALIGNCACHE_MEMORY_SIZE] __attribute__((aligned(8)));
+#else
+extern unsigned char	gNAND_PageBuffer[TNFTL_MAX_SUPPORT_NAND_IO_PAGE_SIZE + TNFTL_MAX_SUPPORT_NAND_IO_SPARE_SIZE];
+extern unsigned char 	gNAND_RCacheDTAreaBuffer[TNFTL_MAX_SUPPORT_RCACHE_MEMORY_SIZE];
+extern unsigned char	gNAND_AlignBuffer[TNFTL_MAX_SUPPORT_ALIGNCACHE_MEMORY_SIZE];
+#endif
+
+extern NAND_IO_CYCLE		WriteCycleTime;
+extern NAND_IO_CYCLE		ReadCycleTime;
+extern NAND_IO_CYCLE		CommCycleTime;
+extern unsigned int			gMaxBusClkMHZ;
+extern unsigned int			gCycleTick;
+
+#if !defined(NU_FILE_INCLUDE) && !defined(_LINUX_) && !defined(_WINCE_)
+extern unsigned int		fat_cbuffer[];
+#else
+extern unsigned char	gFormatType;
+#endif
+
+extern unsigned short		usbFirmwareDownloadMode;
+
+#if !defined(FWDN_DOWNLOADER_INCLUDE) && !defined(_LINUX_) && !defined(_WINCE_)
+	#ifdef MTP_INCLUDE
+	extern void*			MTPMEM_AllocNandInitBuffer( void );
+	extern unsigned int		MTPMEM_GetNandIintBufferSize( void );
+	#else
+	extern char	gFileBuffer[RAW_BUFFERSIZE];
+	#endif
+#endif
+
+/******************************************************************************
+*
+*	unsigned char*	NAND_TellLibraryVersion
+*
+*	Input	: NONE
+*	Output	: NONE
+*	Return	: NONE
+*
+*	Description :
+*
+*******************************************************************************/
+unsigned char*	NAND_TellLibraryVersion( void )
+{
+	return (unsigned char*)gNAND_HiddenInfoSignature;
+}	
+
+/******************************************************************************
+*
+*	unsigned char*	NAND_DRV_TellLibraryVersion
+*
+*	Input	: NONE
+*	Output	: NONE
+*	Return	: NONE
+*
+*	Description :
+*
+*******************************************************************************/
+unsigned char*	NAND_DRV_TellLibraryVersion( void )
+{
+	unsigned short int 	i = 0;
+
+	if ( i )
+		return (unsigned char*)NANDBUF_Library_Version;
+	else
+		return (unsigned char*)NANDDRV_Library_Version;
+}
+
+/*************************************************************************************
+ *          NAND_Init
+ *
+ * Description  :
+ * Argument     :
+ * Return       :   if it is successed then return 0
+ *                  if it is failed then return Error Code
+ *
+ *************************************************************************************/
+void NAND_Init( void )
+{
+	#ifdef NAND_LBA_INCLUDE
+	NAND_ERROR	res;
+	#endif
+		
+	#ifdef INTERNAL_HIDDEN_STORAGE_INCLUDE
+	unsigned int 	i;
+	#endif
+	
+	#if !defined(NU_FILE_INCLUDE) && !defined(FWDN_DOWNLOADER_INCLUDE) && !defined(_LINUX_) & !defined(_WINCE_)
+	unsigned int	BufferSize;
+	#endif
+
+    //=====================================================
+    // Initialize NAND IO & TNFTL Variable
+    //=====================================================
+	NAND_IO_Init();
+
+    //=================================================================
+    // Initialize TNFTL Driver
+    //=================================================================
+	/* Drive #0 */
+	TNFTL_AllocMemAndLinkForDriver( NAND_DRV_0, &gTNFTL_DrvInfo[NAND_DRV_0], &gNAND_DrvInfo[NAND_DRV_0].NFTLDrvInfo );
+	TNFTL_AllocMemAndLinkForLPT( NAND_DRV_0, &gTNFTL_DrvInfo[NAND_DRV_0].DTArea, &gTNFTL_DTAreaLPTBlk[NAND_DRV_0][0], TNFTL_LPT_BLK_NUM_For_DATA_AREA );
+	TNFTL_AllocMemAndLinkForLPT( NAND_DRV_0, &gTNFTL_DrvInfo[NAND_DRV_0].HDArea, &gTNFTL_HDAreaLPTBlk[NAND_DRV_0][0], TNFTL_LPT_BLK_NUM_For_HIDDEN_AREA );
+	TNFTL_AllocMemAndLinkForWCACHE( NAND_DRV_0, &gTNFTL_DrvInfo[NAND_DRV_0].DTArea, &gTNFTL_DTAreaWCache[NAND_DRV_0][0], TNFTL_WCACHE_NUM_For_DATA_AREA );
+	TNFTL_AllocMemAndLinkForWCACHE( NAND_DRV_0, &gTNFTL_DrvInfo[NAND_DRV_0].HDArea, &gTNFTL_HDAreaWCache[NAND_DRV_0][0], TNFTL_WCACHE_NUM_For_HIDDEN_AREA );
+	#if defined( TNFTL_V5_INCLUDE ) || defined(TNFTL_V6_INCLUDE)
+	TNFTL_AllocMemAndLinkForRCACHE( NAND_DRV_0, &gTNFTL_DrvInfo[NAND_DRV_0].DTArea, &gTNFTL_DTAreaRCache[NAND_DRV_0][0] );
+	TNFTL_AllocMemAndLinkForRCACHE( NAND_DRV_0, &gTNFTL_DrvInfo[NAND_DRV_0].HDArea, &gTNFTL_HDAreaRCache[NAND_DRV_0][0] );
+	#endif
+    TNFTL_AllocMemAndLinkForMainPBInfo( NAND_DRV_0, &gTNFTL_DrvInfo[NAND_DRV_0].DTArea, &gTNFTL_DTAreaMainPBInfo[NAND_DRV_0][0], 2 );
+	TNFTL_AllocMemAndLinkForMainPBInfo( NAND_DRV_0, &gTNFTL_DrvInfo[NAND_DRV_0].HDArea, &gTNFTL_HDAreaMainPBInfo[NAND_DRV_0][0], TNFTL_WCACHE_NUM_For_HIDDEN_AREA );
+	TNFTL_AllocMemAndLinkForMultiHidden( NAND_DRV_0, &gTNFTL_MULTIHDAreaInfo[NAND_DRV_0][0] );
+	TNFTL_SetMultiHiddenNums( NAND_DRV_0, TNFTL_MULTI_HIDDEN_AREA_NUM );
+
+	#ifdef INTERNAL_HIDDEN_STORAGE_INCLUDE
+	for ( i = 0; i < TNFTL_MULTI_HIDDEN_AREA_NUM; ++i )
+	{
+		TNFTL_AllocMemAndLinkForLPT( NAND_DRV_0, &gTNFTL_DrvInfo[NAND_DRV_0].MultiHDArea[i], &gTNFTL_MULTIHDAreaLPTBlk[NAND_DRV_0][i][0], TNFTL_LPT_BLK_NUM_For_DATA_AREA );
+		TNFTL_AllocMemAndLinkForWCACHE( NAND_DRV_0, &gTNFTL_DrvInfo[NAND_DRV_0].MultiHDArea[i], &gTNFTL_MULTIHDAreaWCache[NAND_DRV_0][i][0], TNFTL_WCACHE_NUM_For_DATA_AREA );
+		TNFTL_AllocMemAndLinkForMainPBInfo( NAND_DRV_0, &gTNFTL_DrvInfo[NAND_DRV_0].MultiHDArea[i], &gTNFTL_MULTIHDAreaMainPBInfo[NAND_DRV_0][i][0], TNFTL_WCACHE_NUM_For_DATA_AREA );
+		#if defined( TNFTL_V5_INCLUDE ) || defined(TNFTL_V6_INCLUDE)
+		TNFTL_AllocMemAndLinkForRCACHE( NAND_DRV_0, &gTNFTL_DrvInfo[NAND_DRV_0].MultiHDArea[i], &gTNFTL_MULTIHDAreaRCache[NAND_DRV_0][i][0] );
+		#endif	
+	}
+	#endif
+
+	TNFTL_Init( NAND_DRV_0 );
+	TNFTL_SetStEdOfCS( NAND_DRV_0, NAND_IO_DRV0_START_CS, NAND_IO_DRV0_END_CS );
+
+	TNFTL_AllocMemAndLinkForPageBuffer( NAND_DRV_0, gNAND_PageBuffer );
+	#if defined( TNFTL_V5_INCLUDE ) || defined(TNFTL_V6_INCLUDE)
+	/* RCACHE & ALIGN Cache Buffer Memory Allocation( TNFTL V5 ) */
+	TNFTL_AllocMemAndLinkForRCacheBuffer( NAND_DRV_0, &gTNFTL_DrvInfo[NAND_DRV_0].DTArea, gNAND_RCacheDTAreaBuffer, TNFTL_MAX_SUPPORT_RCACHE_MEMORY_SIZE );
+	TNFTL_SetUseAreaReadCacheMode( gNAND_DrvInfo[NAND_DRV_0].NFTLDrvInfo, &gTNFTL_DrvInfo[NAND_DRV_0].DTArea, ENABLE );
+	TNFTL_AllocMemAndLinkForAlignCacheBuffer( NAND_DRV_0, gNAND_AlignBuffer, TNFTL_MAX_SUPPORT_ALIGNCACHE_MEMORY_SIZE );
+	#endif
+
+	#if !defined(NU_FILE_INCLUDE) && !defined(_LINUX_) && !defined(_WINCE_)
+	#ifndef FWDN_DOWNLOADER_INCLUDE
+		#ifdef MTP_INCLUDE
+		BufferSize = MTPMEM_GetNandIintBufferSize() / 4;
+		#else
+		BufferSize = RAW_BUFFERSIZE / 4;
+		#endif
+
+		if ( BufferSize > 65536 / 4 )
+		{
+			#ifdef MTP_INCLUDE
+			TNFTL_AllocMemAndLinkForMakeLPT( NAND_DRV_0, (unsigned char*)MTPMEM_AllocNandInitBuffer(), MTPMEM_GetNandIintBufferSize() / 4 );
+			#else
+			TNFTL_AllocMemAndLinkForMakeLPT( NAND_DRV_0, gFileBuffer, RAW_BUFFERSIZE / 4 );
+			#endif
+		}
+		else
+		{
+			TNFTL_AllocMemAndLinkForMakeLPT( NAND_DRV_0, fat_cbuffer, 65536 / 4 );
+		}
+	#else	
+		TNFTL_AllocMemAndLinkForMakeLPT( NAND_DRV_0, fat_cbuffer, 65536 / 4 );
+	#endif
+	#endif
+
+	#ifdef NAND_LBA_INCLUDE
+	gLBA_DevInfo = &gNAND_DrvInfo[0].NFTLDrvInfo->MediaDevInfo[0];
+	
+	gLBA_DevInfo->LBAInfo.FlagOfChangeTotalSectorSize = DISABLE;
+	res = NAND_IO_LBA_GetDeviceInfo( gLBA_DevInfo );
+	if ( ( res == SUCCESS ) || ( gLBA_DevInfo->Feature.MediaType & S_LBA ) )
+		gNAND_DrvInfo[0].NFTLDrvInfo->NANDType = NAND_TYPE_LBA_NAND;
+	else
+		gNAND_DrvInfo[0].NFTLDrvInfo->NANDType = NAND_TYPE_PURE_NAND;
+	#else
+		gNAND_DrvInfo[0].NFTLDrvInfo->NANDType = NAND_TYPE_PURE_NAND;	
+	#endif
+
+	/* Init TNFTL MSC Debug Monitor */
+	#if !defined(FWDN_DOWNLOADER_INCLUDE) && !defined(_LINUX_) && !defined(_WINCE_)
+	#ifdef TNFTL_DEBUG_INCLUDE
+	TNFTL_DEBUG_Init_Function(  MASS_SCSI_InitMSCDebugMonitor,
+								VTC_SendData,
+								VTC_ReceiveData,
+								MASS_BulkOnly_SendData,
+								MASS_BulkOnly_ReceiveData,
+								MASS_SCSI_SetMSCDebugMonitorHandler,
+								FWDN_PROT_ResponseAck,
+								FWDN_PROT_ResponseNack);
+	TNFTL_DEBUG_Init();
+	#endif
+	#endif
+
+	return;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      void NAND_InitHiddenInfo( void );
+*  
+*  DESCRIPTION : 
+*  
+*  INPUT :	NONE
+*  
+*  OUTPUT:	void - Return Type
+*  
+**************************************************************************/
+void NAND_InitHiddenInfo( void )
+{
+	unsigned int i;
+	
+    #if defined(_LINUX_) || defined(_WINCE_)
+	gTNFTL_HiddenInfo[NAND_DRV_0].HiddenPageSize = 4096;
+	gTNFTL_HiddenInfo[NAND_DRV_0].MultiHiddenAreaNum = 0;
+	gTNFTL_HiddenInfo[NAND_DRV_0].ROAreaSize = 0;
+	#else	
+	gTNFTL_HiddenInfo[NAND_DRV_0].HiddenPageSize = NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE;
+	gTNFTL_HiddenInfo[NAND_DRV_0].MultiHiddenAreaNum = TNFTL_MULTI_HIDDEN_AREA_NUM;
+	#endif
+
+	for ( i = 0; i < TNFTL_MULTI_HIDDEN_AREA_MAX_NUM; ++i )
+		gTNFTL_HiddenInfo[NAND_DRV_0].MultiHiddenSize[i] = NAND_HIDDEN_DRIVE_DEFAULT_TOTAL_SECTOR_SIZE;
+
+	gTNFTL_HiddenInfo[NAND_DRV_0].ROAreaSize = 0;
+	
+	return;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      void NAND_SetFlagOfChangeAreaSize( unsigned char On_Off );
+*  
+*  DESCRIPTION :
+*  
+*  INPUT :
+*			On_Off	= ENABLE/DISABLE
+*  
+*  OUTPUT:	void - Return Type
+*  
+**************************************************************************/
+void NAND_SetFlagOfChangeAreaSize( unsigned char On_Off )
+{
+	gNAND_SetFlagOfChangeAreaSize = On_Off;
+	return;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      void NAND_SetHiddenInfoLoagFlag( unsigned char On_Off );
+*  
+*  DESCRIPTION : 
+*  
+*  INPUT:
+*			On_Off	= ENABLE/DISABLE
+*  
+*  OUTPUT:	void - Return Type
+*  
+**************************************************************************/
+void NAND_SetHiddenInfoLoagFlag( unsigned char On_Off )
+{
+	gNAND_HiddenInfoLoadFlag = On_Off;
+	return;
+}
+	
+/******************************************************************************
+*
+*	NAND_ERROR		NAND_InitDrive
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_ERROR NAND_InitDrive( int nDrvNo )
+{
+	unsigned int	i;
+
+	TNFTL_ERROR res;
+	#if defined(NU_FILE_INCLUDE) || defined(_LINUX_) || defined(_WINCE_)
+	void		*pointer;
+		#if defined(_LINUX_)
+		unsigned				bufSize	= 64*1024;
+		static unsigned int		Tempbuffer[64*1024];
+		#else
+		unsigned				bufSize	= 256*1024;
+		static unsigned char	Tempbuffer[256*1024];
+		#endif
+	#endif
+
+	if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+	{
+	    //===============================================================
+	    // Check Drive I/O in the FTL Layer
+	    //===============================================================	
+	    gNAND_DrvInfo[nDrvNo].DrvStatus = DISABLE;
+    
+		#if defined(NU_FILE_INCLUDE)
+	    pointer	= TC_Allocate_Memory(bufSize);
+	    if (pointer == NULL)
+			return	-1;
+		#elif defined(_LINUX_) || defined(_WINCE_)
+		pointer	= Tempbuffer;
+		if (pointer == NULL)
+			return	-1;
+		#endif
+    
+		#if defined(NU_FILE_INCLUDE)|| defined(_LINUX_) || defined(_WINCE_)
+			#if defined(_LINUX_)
+			TNFTL_AllocMemAndLinkForMakeLPT( NAND_DRV_0, pointer, bufSize );	/* [1193] */
+			#else
+	  	  	TNFTL_AllocMemAndLinkForMakeLPT( NAND_DRV_0, pointer, bufSize/4 );	/* [1193] */
+			#endif
+		#endif
+    
+	    if ( gNAND_SetFlagOfChangeAreaSize == DISABLE )
+		    TNFTL_SetFlagOfChangeTotalSecSize( gNAND_DrvInfo[0].NFTLDrvInfo, &gNAND_DrvInfo[0].NFTLDrvInfo->HDArea, DISABLE );
+	    else
+		    TNFTL_SetFlagOfChangeTotalSecSize( gNAND_DrvInfo[0].NFTLDrvInfo, &gNAND_DrvInfo[0].NFTLDrvInfo->HDArea, ENABLE );
+	    
+	    // Check if low-level format option is enabled.	/*	[1255]  */
+	    if (usbFirmwareDownloadMode & Hw8)
+	    {
+		    BITCLR(usbFirmwareDownloadMode, Hw8);
+		    TNFTL_BMPRefresh( gNAND_DrvInfo[0].NFTLDrvInfo);
+	    }
+
+		//=========================================================
+		// Linux MTD Include
+		//=========================================================
+		TNFTL_SetROAreaSize( gNAND_DrvInfo[nDrvNo].NFTLDrvInfo, gTNFTL_HiddenInfo[NAND_DRV_0].ROAreaSize << 20 );
+		//=========================================================
+
+	    res = TNFTL_InitDrive( gNAND_DrvInfo[nDrvNo].NFTLDrvInfo );
+		#ifdef NU_FILE_INCLUDE
+		TC_Deallocate_Memory(pointer);
+		#endif
+ 
+		#if defined(USE_V_ADDRESS) && defined(_WINCE_)
+		RETAILMSG(1, (TEXT("[NAND        ] [BClk %dMHZ][1Tick %d][RE-S:%d,P:%d,H:%d][WR-S:%d,P:%d,H:%d][COM-S:%d,P:%d,H:%d]\n"),
+		gMaxBusClkMHZ,gCycleTick,ReadCycleTime.STP,ReadCycleTime.PW,ReadCycleTime.HLD,
+		WriteCycleTime.STP,WriteCycleTime.PW,WriteCycleTime.HLD,CommCycleTime.STP,CommCycleTime.PW,CommCycleTime.HLD));
+		RETAILMSG(1, (TEXT("[NAND        ] [NB Area:%dMB][DT Area:%dMB][HD Area:%dMB]"), 
+		//gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->NBArea.PBpV << gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->MediaRatioShiftBSize[0],
+		( gMAX_ROMSIZE * 2 ) >> 20,
+		gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->DTArea.TotalSectorSize >> 11, 
+		gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->HDArea.TotalSectorSize >> 11 ));
+		for ( i = 0; i < gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->MultiHiddendNums; ++i )
+			RETAILMSG(1, (TEXT( "[MH Area%d:%dMB]"), i, gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->MultiHDArea[i].TotalSectorSize >> 11 ));
+		if ( gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->ROAreaSize != 0 )
+			RETAILMSG(1, (TEXT( "[MTD Size:%dMB]"), gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->ROAreaSize >> 20 ));
+		RETAILMSG(1, (TEXT("\n")));
+		#else
+		ND_TRACE( "[NAND        ] [BClk %dMHZ][1Tick %d][RE-S:%d,P:%d,H:%d][WR-S:%d,P:%d,H:%d][COM-S:%d,P:%d,H:%d]\n",
+		gMaxBusClkMHZ,gCycleTick,ReadCycleTime.STP,ReadCycleTime.PW,ReadCycleTime.HLD,
+		WriteCycleTime.STP,WriteCycleTime.PW,WriteCycleTime.HLD,CommCycleTime.STP,CommCycleTime.PW,CommCycleTime.HLD );		
+		ND_TRACE( "[NAND        ] [NB Area:%dMB][DT Area:%dMB][HD Area:%dMB]", 
+		//gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->NBArea.PBpV << gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->MediaRatioShiftBSize[0],
+		(gMAX_ROMSIZE * 2) >> 20,
+		gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->DTArea.TotalSectorSize >> 11, 
+		gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->HDArea.TotalSectorSize >> 11);
+		for ( i = 0; i < gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->MultiHiddendNums; ++i )
+			ND_TRACE( "[MH Area%d:%dMB]", i, gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->MultiHDArea[i].TotalSectorSize >> 11 );
+		if ( gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->ROAreaSize != 0 )
+			ND_TRACE("[MTD Size:%dMB]", gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->ROAreaSize >> 20 );
+		ND_TRACE("\n");
+		#endif
+		
+	    if ( res != SUCCESS )
+		{
+			#if defined(USE_V_ADDRESS)
+				#if defined(_LINUX_)
+				if ( res == ERR_TNFTL_OVERSIZE_MTD_AREA_SIZE )
+					printk("\nError: MTD Area Size is too big...\n");
+				else
+					printk("\nTNFTL_Init_Fail:0x%X", res );
+				#endif			
+			#else
+				#if defined(_LINUX_)
+				if ( res == ERR_TNFTL_OVERSIZE_MTD_AREA_SIZE )
+					printf("\nError: MTD Area Size is too big...\n");
+				else
+					printf("\nTNFTL_Init_Fail:0x%X", res );
+				#endif
+			#endif
+		    return ERR_NAND_INIT_FAILED;
+		    //return res; //original
+		}
+    	
+	    TNFTL_AREAGetTotalSecAndCHS( gNAND_DrvInfo[nDrvNo].NFTLDrvInfo,
+								     &gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->DTArea,
+								     (U32 *)&gNAND_DrvInfo[nDrvNo].TotalDiskSector,
+								     &gNAND_DrvInfo[nDrvNo].Cylinder,
+								     &gNAND_DrvInfo[nDrvNo].Head,
+								     &gNAND_DrvInfo[nDrvNo].Sector );
+    
+	    gNAND_DrvInfo[nDrvNo].DrvStatus = ENABLE;
+	}
+	else
+	{
+		#ifdef NAND_LBA_INCLUDE
+
+		gNAND_DrvInfo[nDrvNo].DrvStatus = DISABLE;
+		
+		if ( gNAND_SetFlagOfChangeAreaSize == DISABLE )
+			gLBA_DevInfo->LBAInfo.FlagOfChangeTotalSectorSize = DISABLE;
+		else
+			gLBA_DevInfo->LBAInfo.FlagOfChangeTotalSectorSize = ENABLE;
+
+		res = NAND_IO_LBA_Init( gLBA_DevInfo );
+		if ( res != SUCCESS )
+			return ERR_NAND_INIT_FAILED;
+
+		NAND_IO_LBA_GetTotalSecAndCHS( gLBA_DevInfo,
+									   NAND_LBA_DATA_AREA,
+									   (U32)&gNAND_DrvInfo[nDrvNo].TotalDiskSector,
+									   &gNAND_DrvInfo[nDrvNo].Cylinder,
+									   &gNAND_DrvInfo[nDrvNo].Head,
+									   &gNAND_DrvInfo[nDrvNo].Sector );
+
+		gNAND_DrvInfo[nDrvNo].DrvStatus = ENABLE;
+		#endif
+	}
+
+	return (NAND_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	int				NAND_ReadSector
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+int NAND_ReadSector( int nDrvNo, U32 LBA, U32 nSecSize, void* nReadBuffer )
+{
+	#ifdef NAND_INCLUDE
+	TNFTL_ERROR		res = SUCCESS;
+
+		//=================[ For DEBUG ]================================================
+		#ifdef NAND_DRV_UART_MEASURE
+		unsigned long int	count;
+		HwTCNT4 = 0;
+		#endif
+		#ifdef NAND_DRV_UART_DEBUG
+		if ( gNAND_UARTDebugFlag == ENABLE )
+			PRINTF( "\n\nNAND_ReadSector( %08d, %08d ) -------------------------- ", LBA, nSecSize );
+		#endif
+
+		#ifdef NAND_DRV_UART_DEBUG
+			#if defined(USE_V_ADDRESS)
+				#if defined(_WINCE_)
+				if ( gNAND_UARTDebugFlag == ENABLE )
+				RETAILMSG(1,(TEXT( "\n\nNAND_ReadSector( %08d, %08d ) -------------------------- "), LBA, nSecSize ));
+				#endif
+			#endif
+		#endif
+		//==============================================================================
+		
+		if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+		{
+	        res = TNFTL_AREAReadSector( gNAND_DrvInfo[nDrvNo].NFTLDrvInfo,
+								        &gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->DTArea,
+								        LBA, nSecSize, nReadBuffer );
+		}
+		else
+		{
+			#ifdef NAND_LBA_INCLUDE
+			res = NAND_IO_LBA_ReadSector( gLBA_DevInfo,
+										  NAND_LBA_DATA_AREA, 
+										  LBA, nSecSize, nReadBuffer);
+			#endif
+		}
+
+		//=================[ For DEBUG ]================================================
+		#ifdef NAND_DRV_UART_MEASURE
+		count = HwTCNT4;
+		PRINTF( "\n[NAND_READ Sector %08d - %05d ] ( %d uS ) -------------------------- ",
+		LBA,
+		nSecSize,
+		(count*267)/100);
+		#endif
+		//==============================================================================		
+
+	if ( res != SUCCESS )
+	{
+		#ifdef NAND_DRV_UART_DEBUG
+		if ( gNAND_UARTDebugFlag == ENABLE )
+			PRINTF( " FAIL %08X", res );
+		#endif
+
+		return -1;
+	}
+
+	return 0;
+	#else
+	return NOT_SUPPORT_NAND;
+	#endif
+}	
+
+/******************************************************************************
+*
+*	int				NAND_WriteSector
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+int NAND_WriteSector( int nDrvNo, U32 LBA, U32 nSecSize, void* nWriteBuffer )
+{
+	#ifdef NAND_INCLUDE
+	TNFTL_ERROR		res = SUCCESS;
+
+		//=================[ For DEBUG ]================================================
+		#ifdef NAND_DRV_UART_MEASURE
+		unsigned long int	count;
+		HwTCNT4 = 0;
+		#endif
+		#ifdef NAND_DRV_UART_DEBUG
+		if ( gNAND_UARTDebugFlag == ENABLE )
+			PRINTF( "\n\nNAND_WriteSector( %08d, %08d ) -----------------------------------", LBA, nSecSize );
+		#endif
+
+		#ifdef NAND_DRV_UART_DEBUG
+			#if defined(USE_V_ADDRESS)
+				#if defined(_WINCE_)
+				if ( gNAND_UARTDebugFlag == ENABLE )			
+				RETAILMSG(1,(TEXT( "\n\nNAND_WriteSector( %08d, %08d ) -------------------------- "), LBA, nSecSize ));
+				#endif
+			#endif
+		#endif
+		
+		//==============================================================================
+		if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+		{
+	        res = TNFTL_AREAWriteSector( gNAND_DrvInfo[nDrvNo].NFTLDrvInfo,
+								         &gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->DTArea,
+								         LBA, nSecSize, nWriteBuffer );
+		}
+		else
+		{
+			#ifdef NAND_LBA_INCLUDE
+			res = NAND_IO_LBA_WriteSector( gLBA_DevInfo,
+										  NAND_LBA_DATA_AREA, 
+										  LBA, nSecSize, nWriteBuffer );
+			#endif
+		}
+
+		//=================[ For DEBUG ]================================================
+		#ifdef NAND_DRV_UART_MEASURE
+		count = HwTCNT4;
+		PRINTF( "\n[NAND_WRITE Sector %08d - %05d ] ( %d uS ) -------------------------- ",
+		LBA,
+		nSecSize,
+		(count*267)/100);
+		#endif
+		//==============================================================================
+
+	if ( res != SUCCESS )
+	{
+		#ifdef NAND_DRV_UART_DEBUG
+		if ( gNAND_UARTDebugFlag == ENABLE )
+			PRINTF( "\nFAIL : %08X ", res );
+		#endif
+
+		return -1;
+	}	
+
+	return 0;
+	#else
+	return NOT_SUPPORT_NAND;
+	#endif
+}	
+
+/******************************************************************************
+*
+*	int				NAND_HDReadSector
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+int NAND_HDReadSector( int nDrvNo, U32 LBA, U32 nSecSize, void* nReadBuffer )
+{
+	#ifdef NAND_INCLUDE
+	TNFTL_ERROR		res = SUCCESS;
+		
+	if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+	{
+	    #if defined(_LINUX_) || defined(_WINCE_)
+		res = TNFTL_AREAReadSector( gNAND_DrvInfo[0].NFTLDrvInfo,
+									&gNAND_DrvInfo[0].NFTLDrvInfo->MultiHDArea[nDrvNo],
+									LBA, nSecSize, nReadBuffer );
+		#else
+	    res = TNFTL_AREAReadSector( gNAND_DrvInfo[nDrvNo].NFTLDrvInfo,
+								    &gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->MultiHDArea[0],
+								    LBA, nSecSize, nReadBuffer );
+		#endif
+	}
+	else
+	{
+		#ifdef NAND_LBA_INCLUDE
+	
+		res = NAND_IO_LBA_ReadSector( gLBA_DevInfo,
+									  NAND_LBA_MULTI_HIDDEN_AREA_0, 
+									  LBA, nSecSize, nReadBuffer);
+		#endif
+	}
+
+	if ( res != SUCCESS )
+	{
+		#ifdef NAND_DRV_UART_DEBUG
+		if ( gNAND_UARTDebugFlag == ENABLE )
+			PRINTF( " FAIL %08X", res );
+		#endif
+
+		return -1;
+	}
+
+	return 0;
+	#else
+	return NOT_SUPPORT_NAND;
+	#endif
+}	
+
+/******************************************************************************
+*
+*	int				NAND_HDWriteSector
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+int NAND_HDWriteSector( int nDrvNo, U32 LBA, U32 nSecSize, void* nWriteBuffer )
+{
+	#ifdef NAND_INCLUDE
+	TNFTL_ERROR		res = SUCCESS;
+
+	if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+	{
+		#if defined(_LINUX_) || defined(_WINCE_)
+		res = TNFTL_AREAWriteSector( gNAND_DrvInfo[0].NFTLDrvInfo,
+									 &gNAND_DrvInfo[0].NFTLDrvInfo->MultiHDArea[nDrvNo],
+									 LBA, nSecSize, nWriteBuffer );
+		#else
+	    res = TNFTL_AREAWriteSector( gNAND_DrvInfo[nDrvNo].NFTLDrvInfo,
+								     &gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->MultiHDArea[0],
+								     LBA, nSecSize, nWriteBuffer );
+		#endif
+	}
+	else
+	{
+		#ifdef NAND_LBA_INCLUDE	
+		res = NAND_IO_LBA_WriteSector( gLBA_DevInfo,
+									  NAND_LBA_MULTI_HIDDEN_AREA_0, 
+									  LBA, nSecSize, nWriteBuffer );
+		#endif
+	}
+
+	if ( res != SUCCESS )
+	{
+		#ifdef NAND_DRV_UART_DEBUG
+		if ( gNAND_UARTDebugFlag == ENABLE )
+			PRINTF( "\nFAIL : %08X ", res );
+		#endif
+
+		return -1;
+	}	
+
+	return 0;
+	#else
+	return NOT_SUPPORT_NAND;
+	#endif
+}	
+
+/******************************************************************************
+*
+*	int				NAND_HDReadPage
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+int NAND_HDReadPage( U32 nHDPageAddr, U32 nPageSize, void* nReadBuffer )
+{
+	#ifdef NAND_INCLUDE
+	TNFTL_ERROR		res = SUCCESS;
+
+		//=================[ For DEBUG ]================================================
+		#ifdef NAND_DRV_UART_MEASURE
+		unsigned long int	count;
+		HwTCNT4 = 0;
+		#endif
+		#ifdef NAND_DRV_UART_DEBUG
+		if ( gNAND_UARTDebugFlag == ENABLE )
+			PRINTF( "\n\nNAND_HDReadPage( %08d, %08d ) -----", nHDPageAddr, nPageSize );
+		#endif
+		//==============================================================================
+
+		if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+		{
+	        res = TNFTL_AREAReadSector( gNAND_DrvInfo[0].NFTLDrvInfo,
+								        &gNAND_DrvInfo[0].NFTLDrvInfo->HDArea,
+								        nHDPageAddr, nPageSize, nReadBuffer );
+		}
+		else
+		{
+			#ifdef NAND_LBA_INCLUDE
+			res = NAND_IO_LBA_ReadSector( gLBA_DevInfo,
+										  NAND_LBA_HIDDEN_AREA, 
+										  nHDPageAddr, nPageSize, nReadBuffer );
+			#endif
+		}
+
+		//=================[ For DEBUG ]================================================
+		#ifdef NAND_DRV_UART_MEASURE
+		count = HwTCNT4;
+		PRINTF( "\n[NAND_HDReadPage %08d - %05d ] ( %d uS ) ---- ",
+		LBA,
+		nSecSize,
+		(count*267)/100);
+		#endif
+		//==============================================================================
+
+	if ( res != SUCCESS )
+	{
+		#ifdef NAND_DRV_UART_DEBUG
+		if ( gNAND_UARTDebugFlag == ENABLE )
+			PRINTF( "\nFAIL : %08X ", res );
+		#endif
+
+		return -1;
+	}
+
+	return 0;
+	#else
+	return NOT_SUPPORT_NAND;
+	#endif
+}
+
+/******************************************************************************
+*
+*	int				NAND_HDWritePage
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+int NAND_HDWritePage( U32 nHDPageAddr, U32 nPageSize, void* nWriteBuffer )
+{
+	#ifdef NAND_INCLUDE
+	TNFTL_ERROR		res = SUCCESS;
+	
+		//=================[ For DEBUG ]================================================
+		#ifdef NAND_DRV_UART_MEASURE
+		unsigned long int	count;
+		HwTCNT4 = 0;
+		#endif
+		#ifdef NAND_DRV_UART_DEBUG
+		if ( gNAND_UARTDebugFlag == ENABLE )
+			PRINTF( "\n\nNAND_HDWritePage( %08d, %08d ) ----", nHDPageAddr, nPageSize );
+		#endif
+		//==============================================================================
+
+		if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+		{
+	        res = TNFTL_AREAWriteSector( gNAND_DrvInfo[0].NFTLDrvInfo, 
+								         &gNAND_DrvInfo[0].NFTLDrvInfo->HDArea,
+								         nHDPageAddr, nPageSize, nWriteBuffer );
+		}
+		else
+		{
+			#ifdef NAND_LBA_INCLUDE
+			res = NAND_IO_LBA_WriteSector( gLBA_DevInfo,
+										  NAND_LBA_HIDDEN_AREA, 
+										  nHDPageAddr, nPageSize, nWriteBuffer );
+			#endif
+		}
+
+		//=================[ For DEBUG ]================================================
+		#ifdef NAND_DRV_UART_MEASURE
+		count = HwTCNT4;
+		PRINTF( "\n[NAND_HDWritePage %08d - %05d ] ( %d uS ) ---- ",
+		LBA,
+		nSecSize,
+		(count*267)/100);
+		#endif
+		//==============================================================================
+
+	if ( res != SUCCESS )
+	{
+		#ifdef NAND_DRV_UART_DEBUG
+		if ( gNAND_UARTDebugFlag == ENABLE )
+			PRINTF( "\nFAIL : %08X ", res );
+		#endif
+	
+		return -1;
+	}
+
+	return 0;
+	#else
+	return NOT_SUPPORT_NAND;
+	#endif
+}	
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      int NAND_PhyReadPage( U32 nBlkAddr, U16 nPageAddr, U16 nCSorder, void* nReadBuffer );
+*  
+*  DESCRIPTION : 
+*  
+*  INPUT:
+*			nBlkAddr	= 
+*			nCSorder	= 
+*			nPageAddr	= 
+*			nReadBuffer	= 
+*  
+*  OUTPUT:	int - Return Type
+*  			= 
+*  
+*  REMARK:	  by nemo
+**************************************************************************/
+int NAND_PhyReadPage( U32 nBlkAddr, U16 nPageAddr, U16 nCSorder, void* nReadBuffer )
+{
+	TNFTL_ERROR		res = SUCCESS;
+	#if defined(NAND_INCLUDE)
+
+	#ifdef NAND_DRV_UART_DEBUG
+	if ( gNAND_UARTDebugFlag == ENABLE )
+		PRINTF( "\nNAND_PhyReadPage( %08d, %08d ) ----", nBlkAddr, nPageAddr );
+	#endif
+
+	#if defined( TNFTL_V5_INCLUDE ) || defined(TNFTL_V6_INCLUDE)
+	res = TNFTL_IOReadPhyPage( gNAND_DrvInfo[0].NFTLDrvInfo,
+							   nBlkAddr, nPageAddr,
+							   nCSorder, nReadBuffer );
+	#endif
+	
+	if ( res != SUCCESS )
+	{
+		#ifdef NAND_DRV_UART_DEBUG
+		if ( gNAND_UARTDebugFlag == ENABLE )
+			PRINTF( "\nFAIL : %08X ", res );
+		#endif
+	
+		return -1;
+	}
+	#endif
+
+	return 0;
+}
+
+int NAND_MTD_Init( U32* rMTDStBlk, U32* rMTDEdBlk )
+{  
+	unsigned int 		i;
+	unsigned int		nBlockPageAddr;
+	unsigned int		nMTDStBlk, nMTDEdBlk;
+	NAND_IO_DEVINFO		sDevInfo;
+	NAND_IO_DEVINFO 	*nDevInfo;
+
+	NAND_IO_GetDeviceInfo( 0, &sDevInfo);
+	nDevInfo = &sDevInfo;
+
+	if ( gNAND_DrvInfo[0].NFTLDrvInfo->IoStatus == DISABLE )
+		return -1;	
+
+	nMTDStBlk = nDevInfo->Feature.PBpV - gNAND_DrvInfo[0].NFTLDrvInfo->ROAreaBlkNum;
+	nMTDEdBlk = nDevInfo->Feature.PBpV - 1;
+
+	for ( i = nMTDStBlk; i < nMTDEdBlk; ++i )
+	{
+		nBlockPageAddr = i << nDevInfo->ShiftPpB;
+		
+		NAND_IO_EraseBlock( nDevInfo, nBlockPageAddr, INTER_LEAVE_OFF );
+	}
+	
+	*rMTDStBlk = nMTDStBlk;
+	*rMTDEdBlk = nMTDEdBlk;
+
+	return 0;
+}
+
+int NAND_MTD_WritePage( U32 nPageAddr, U8* nPageBuffer )
+{
+	unsigned char	*nSpareBuffer;
+	NAND_IO_DEVINFO *nDevInfo;
+	NAND_IO_ERROR	res;
+
+	nDevInfo = &gNAND_DrvInfo[0].NFTLDrvInfo->MediaDevInfo[0];
+
+	nSpareBuffer = (unsigned char *)nPageBuffer;
+	//nSpareBuffer += nDevInfo->Feature.PageSize;
+	nSpareBuffer += 2048;
+	
+	res = NAND_IO_WritePageMTD( nDevInfo, 
+							  nPageAddr, 0, 4/*nDevInfo->PPages*/, 
+							  nPageBuffer,
+							  nSpareBuffer, ECC_ON );
+	return res;
+}
+
+int NAND_MTD_ReadPage( U32 nPageAddr, U8* nPageBuffer )
+{
+	unsigned char	*nSpareBuffer;
+	NAND_IO_DEVINFO *nDevInfo;
+	NAND_IO_ERROR	res;
+	
+	nDevInfo = &gNAND_DrvInfo[0].NFTLDrvInfo->MediaDevInfo[0];
+
+	nSpareBuffer = (unsigned char *)nPageBuffer;
+	//nSpareBuffer += nDevInfo->Feature.PageSize;
+	nSpareBuffer += 2048;
+		
+	res = NAND_IO_ReadPageMTD( nDevInfo, 
+							  nPageAddr, 0, 4/*nDevInfo->PPages*/,
+							  nPageBuffer,
+							  nSpareBuffer, ECC_ON );
+	return res;	
+}
+
+
+/******************************************************************************
+*
+*	int				NAND_Ioctl
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+int NAND_Ioctl( int function, void *param )
+{
+	#if defined(_LINUX_) || defined(_WINCE_) || defined (NAND_LBA_INCLUDE)
+	unsigned int	 i = 0;
+	#endif
+	
+	switch( function )
+	{
+		case	DEV_INITIALIZE:
+			{
+				NAND_Init();
+				
+				#if defined(_LINUX_) || defined(_WINCE_)
+				if ( gNAND_HiddenInfoLoadFlag == DISABLE )
+					NAND_InitHiddenInfo();
+				else
+					TNFTL_SetMultiHiddenNums( NAND_DRV_0, (U16)gTNFTL_HiddenInfo[NAND_DRV_0].MultiHiddenAreaNum );
+				#else
+				NAND_InitHiddenInfo();
+				#endif
+
+				if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+				{
+				    #ifdef BRWS_STR_NAND_INCLUDE
+				    TNFTL_AREASetTotalSectorSize( gNAND_DrvInfo[0].NFTLDrvInfo,
+											      &gNAND_DrvInfo[0].NFTLDrvInfo->HDArea,
+										  	      gTNFTL_HiddenInfo[NAND_DRV_0].HiddenPageSize
+											      + BRWS_NAME_AREA_SIZE
+											    #ifndef NU_FILE_INCLUDE
+											    #ifdef AUDIOUI_INCLUDE
+											      + AUI_HD_OCCPAGE
+											    #endif
+											    #endif
+											    );
+				    #else
+				    TNFTL_AREASetTotalSectorSize( gNAND_DrvInfo[0].NFTLDrvInfo,
+											      &gNAND_DrvInfo[0].NFTLDrvInfo->HDArea,
+											      gTNFTL_HiddenInfo[NAND_DRV_0].HiddenPageSize
+											    #ifndef NU_FILE_INCLUDE
+											    #ifdef AUDIOUI_INCLUDE
+											      + AUI_HD_OCCPAGE
+											    #endif
+											    #endif
+											    );
+				    #endif
+
+					#if defined(_LINUX_) || defined(_WINCE_)
+					for ( i = 0; i < gTNFTL_HiddenInfo[NAND_DRV_0].MultiHiddenAreaNum; ++i )
+					{
+						TNFTL_AREASetTotalSectorSize( gNAND_DrvInfo[0].NFTLDrvInfo,
+													  &gNAND_DrvInfo[0].NFTLDrvInfo->MultiHDArea[i],
+													  gTNFTL_HiddenInfo[NAND_DRV_0].MultiHiddenSize[i] );
+					}
+					#else
+				    TNFTL_AREASetTotalSectorSize( gNAND_DrvInfo[0].NFTLDrvInfo,
+											      &gNAND_DrvInfo[0].NFTLDrvInfo->MultiHDArea[0],
+											      gTNFTL_HiddenInfo[NAND_DRV_0].MultiHiddenSize[0] );
+    
+					#endif
+
+				    gNAND_DrvInfo[0].DrvStatus = DISABLE;
+
+
+				    if ( NAND_InitDrive(0) != SUCCESS )
+					    return EINITFAIL;
+    
+				    TNFTL_AREAGetTotalSecAndCHS( gNAND_DrvInfo[0].NFTLDrvInfo,
+								 			     &gNAND_DrvInfo[0].NFTLDrvInfo->DTArea,
+								 			     (U32 *)&gNAND_DrvInfo[0].TotalDiskSector,
+								 			     &gNAND_DrvInfo[0].Cylinder,
+								 			     &gNAND_DrvInfo[0].Head,
+								 			     &gNAND_DrvInfo[0].Sector );
+    
+				    gNAND_DrvInfo[0].DrvStatus = ENABLE;
+				}
+				else
+				{
+					#ifdef NAND_LBA_INCLUDE
+				
+					#ifdef BRWS_STR_NAND_INCLUDE
+					gLBA_DevInfo->LBAInfo.HDAreaSectorSize = ( gTNFTL_HiddenInfo[NAND_DRV_0].HiddenPageSize
+																						  + BRWS_NAME_AREA_SIZE
+																						#ifndef NU_FILE_INCLUDE
+																						#ifdef AUDIOUI_INCLUDE
+																						  + AUI_HD_OCCPAGE
+																						#endif
+																						#endif
+																						);
+					#else
+					gLBA_DevInfo->LBAInfo.HDAreaSectorSize = ( gTNFTL_HiddenInfo[NAND_DRV_0].HiddenPageSize
+																						#ifndef NU_FILE_INCLUDE
+																						#ifdef AUDIOUI_INCLUDE
+																						  + AUI_HD_OCCPAGE
+																						#endif
+																						#endif
+																						);
+					#endif
+					
+					gLBA_DevInfo->LBAInfo.MHDAreaNums = TNFTL_MULTI_HIDDEN_AREA_NUM;			
+					
+					#ifdef INTERNAL_HIDDEN_STORAGE_INCLUDE					
+					for ( i = 0; i < TNFTL_MULTI_HIDDEN_AREA_NUM; ++i )
+						gLBA_DevInfo->LBAInfo.MHDAreaSectorSize[i] = gTNFTL_HiddenInfo[NAND_DRV_0].MultiHiddenSize[i];
+					#endif
+					
+					gNAND_DrvInfo[0].DrvStatus = DISABLE;
+					
+					if ( NAND_InitDrive(0) != SUCCESS )
+						return EINITFAIL;
+					
+					gNAND_DrvInfo[0].DrvStatus = ENABLE;
+					#endif
+				}					
+			}
+			break;
+			
+		case	DEV_GET_DISKINFO:
+			{
+				ioctl_diskinfo_t	*info = (ioctl_diskinfo_t *) param;
+
+				#ifdef NU_FILE_INCLUDE
+				gFormatType	= TC_LOWLEVEL_NO;
+				#endif
+				info->cylinder		= gNAND_DrvInfo[0].Cylinder;
+				info->head			= gNAND_DrvInfo[0].Head;
+				info->sector		= gNAND_DrvInfo[0].Sector;
+				info->sector_size	= 512;
+				info->Total_sectors	= gNAND_DrvInfo[0].TotalDiskSector;				
+			}
+			break;
+			
+		case	DEV_FORMAT_DISK:
+			{
+				unsigned short	mode = *((unsigned short *)param);
+
+				#ifdef NU_FILE_INCLUDE
+				gFormatType	= TC_LOWLEVEL_NO;
+				#endif
+
+				if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+				{
+				    TNFTL_AREAFormat( gNAND_DrvInfo[0].NFTLDrvInfo,
+								      &gNAND_DrvInfo[0].NFTLDrvInfo->DTArea,
+								      mode );
+				}
+				#ifdef NAND_LBA_INCLUDE
+				else
+				{
+				//	NAND_IO_LBA_AREAClear( gLBA_DevInfo, NAND_LBA_DATA_AREA );
+				}
+				#endif
+
+				return NAND_InitDrive(0);
+			}
+			break;
+			
+		case	DEV_ERASE_INIT:
+			{
+				ioctl_diskeraseinit_t	*erase = (ioctl_diskeraseinit_t *) param;
+				erase = erase;
+			}
+			break;
+			
+		case	DEV_ERASE_BLOCK:
+			{
+				ioctl_diskerase_t	*erase = (ioctl_diskerase_t *) param;
+				erase = erase;				
+			}
+			break;
+			
+		case	DEV_WRITEBACK_ON_IDLE:
+			{
+
+			}
+			break;
+			
+		case	DEV_ERASE_CLOSE:
+			{
+
+			}
+			break;
+			
+		case	DEV_HIDDEN_READ_PAGE_4:
+			{
+				ioctl_diskhdread4_t	*hd_r = (ioctl_diskhdread4_t *) param;
+
+				if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+				{
+				    TNFTL_AREAReadSectorBy4Byte( gNAND_DrvInfo[0].NFTLDrvInfo,
+											     &gNAND_DrvInfo[0].NFTLDrvInfo->HDArea,
+												 (U32)hd_r->start_page,
+												 (U16)hd_r->page_offset,
+												 (U16)hd_r->read_size,
+											     hd_r->buff );
+			    }
+				else
+				{
+					#ifdef NAND_LBA_INCLUDE
+					NAND_IO_LBA_ReadSectorBy4Byte( gLBA_DevInfo,
+												   NAND_LBA_VFP,
+												   (U32)hd_r->start_page,
+												   (U16)hd_r->page_offset,
+												   (U16)hd_r->read_size,
+												   hd_r->buff );
+					#endif
+				}
+
+			}
+			break;
+		case	DEV_SET_POWER:
+			{
+				#ifdef NAND_LBA_INCLUDE			
+				unsigned short	mode = *((unsigned short *)param);
+				#endif
+				
+				if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+				{
+					// NOP
+				}
+				else
+				{
+					#ifdef NAND_LBA_INCLUDE
+
+					if ( mode == DISK_STATE_STANDBY )
+					{
+						NAND_IO_LBA_PowerSaveMode( gLBA_DevInfo, DISABLE );
+					}
+					else if ( mode == DISK_STATE_IDLE )
+					{
+						NAND_IO_LBA_PowerSaveMode( gLBA_DevInfo, ENABLE );						
+					}
+					#endif
+				}					
+			}
+			break;
+		case	DEV_GET_MAX_SECTOR_PER_BLOCK:
+			{
+				unsigned short *value = (unsigned short *)param;
+				if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+				{
+				    if ( gNAND_DrvInfo[0].DrvStatus == ENABLE )
+					    *value = ( gNAND_DrvInfo[0].NFTLDrvInfo->PpB << gNAND_DrvInfo[0].NFTLDrvInfo->ShiftPPages );
+				    else
+					    *value = TNFTL_MAX_SUPPORT_NAND_IO_SECTOR_SIZE_PER_1PAGE;
+				}
+				else
+				{
+					*value = 2048; // PpB: 128 *  PPage: 16
+				}
+			}
+			break;
+
+		case	DEV_TELL_DATASTARTSECTOR:
+			{
+				if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+				{
+				    TNFTL_WCacheSetDataStartSector( gNAND_DrvInfo[0].NFTLDrvInfo,
+												    &gNAND_DrvInfo[0].NFTLDrvInfo->DTArea,
+												    *(unsigned int*)param );
+				}
+				
+				break;
+			}
+
+		case	DEV_CHECK_CRC_NANDBOOT_IMAGE_ROM:
+		#if defined (BOOTCRCCHEK)
+			{
+				BootCRC *pbootcrc;
+
+				pbootcrc = (BootCRC*)param;
+				if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+				{
+					return TNFTL_NBGetCRCValueOfImageFile(gNAND_DrvInfo[0].NFTLDrvInfo, &pbootcrc->crc128kchk, &pbootcrc->crcfullchk, &pbootcrc->bootfilesize);
+				}
+				else
+					return 0;
+			}
+		#else
+			{
+				unsigned int	nOrgCRCcode1;
+				unsigned int	nOrgCRCcode2;
+				unsigned int	nRomFileSize;
+				unsigned int	rRstCRCcode1;
+				unsigned int	rRstCRCcode2;
+		
+				if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+				{
+				    return TNFTL_NBGetCRCOfImageFile( gNAND_DrvInfo[0].NFTLDrvInfo, 1,
+												      &nOrgCRCcode1, &nOrgCRCcode2, &nRomFileSize,
+												      &rRstCRCcode1, &rRstCRCcode2 );
+			}
+				else
+					return 0;
+		 	}
+		#endif
+			break;
+		#ifdef TNFTL_V4_INCLUDE
+		case	DEV_FORCE_FLUSH_CACHE_DATA:
+			{
+				return 	TNFTL_WCacheFourceFlushCache_DATA( gNAND_DrvInfo[0].NFTLDrvInfo,
+											 		 	   &gNAND_DrvInfo[0].NFTLDrvInfo->DTArea );				
+			}
+			break;
+		#endif
+		#if defined( TNFTL_V5_INCLUDE ) || defined(TNFTL_V6_INCLUDE)
+		case	DEV_SET_ALIGEN_CACHE:
+			{
+				unsigned short	mode = *((unsigned short *)param);
+				return TNFTL_SetUseAlignCacheMode( gNAND_DrvInfo[0].NFTLDrvInfo, mode );
+			}
+			break;
+		#endif
+		case	DEV_GET_WRITE_PROTECT:
+			return  0;
+			break;
+		case	DEV_GET_INSERTED:
+			return 1;
+		#ifdef NU_FILE_INCLUDE
+		case	DEV_GET_HIDDEN_SIZE:
+			if (gNAND_DrvInfo[0].DrvStatus == ENABLE)
+				*(int *)param	= NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE;
+			else
+				*(int *)param	= -1;
+			break;
+        #endif
+		case	DEV_GET_INITED:
+			return 1;
+		case DEV_GET_PLAYABLE_STATUS:
+			return 1;			
+		default:
+			return	ENOTSUPPORT;
+	}
+	#endif
+	return 0;	/* SUCCESS */
+}
+
+/******************************************************************************
+*
+*	int				NAND_HDIoctl
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+int NAND_HDIoctl( int function, void *param )
+{
+	#if defined(_LINUX_) || defined(_WINCE_)
+	unsigned int	 i;
+	#endif
+
+	switch( function )
+	{
+		case	DEV_INITIALIZE:
+			{
+				NAND_Init();
+				
+				#if defined(_LINUX_) || defined(_WINCE_)
+				if ( gNAND_HiddenInfoLoadFlag == DISABLE )
+					NAND_InitHiddenInfo();
+				else
+					TNFTL_SetMultiHiddenNums( NAND_DRV_0, (U16)gTNFTL_HiddenInfo[NAND_DRV_0].MultiHiddenAreaNum );
+				#endif
+
+				#ifdef BRWS_STR_NAND_INCLUDE
+				TNFTL_AREASetTotalSectorSize( gNAND_DrvInfo[0].NFTLDrvInfo,
+											  &gNAND_DrvInfo[0].NFTLDrvInfo->HDArea,
+										  	  gTNFTL_HiddenInfo[NAND_DRV_0].HiddenPageSize
+											  + BRWS_NAME_AREA_SIZE 
+											#ifndef NU_FILE_INCLUDE
+											#ifdef AUDIOUI_INCLUDE
+											  + AUI_HD_OCCPAGE
+											#endif
+											#endif
+											);
+				#else
+				TNFTL_AREASetTotalSectorSize( gNAND_DrvInfo[0].NFTLDrvInfo,
+											  &gNAND_DrvInfo[0].NFTLDrvInfo->HDArea,
+											  gTNFTL_HiddenInfo[NAND_DRV_0].HiddenPageSize
+											#ifndef NU_FILE_INCLUDE
+											#ifdef AUDIOUI_INCLUDE
+											  + AUI_HD_OCCPAGE
+											#endif
+											#endif
+											);
+				#endif
+
+				#if defined(_LINUX_) || defined(_WINCE_)
+				for ( i = 0; i < gTNFTL_HiddenInfo[NAND_DRV_0].MultiHiddenAreaNum; ++i )
+				{
+					TNFTL_AREASetTotalSectorSize( gNAND_DrvInfo[0].NFTLDrvInfo,
+												  &gNAND_DrvInfo[0].NFTLDrvInfo->MultiHDArea[i],
+												  gTNFTL_HiddenInfo[NAND_DRV_0].MultiHiddenSize[i] );
+				}
+				#else
+				TNFTL_AREASetTotalSectorSize( gNAND_DrvInfo[0].NFTLDrvInfo,
+											  &gNAND_DrvInfo[0].NFTLDrvInfo->MultiHDArea[0],
+											  NAND_HIDDEN_DRIVE_DEFAULT_TOTAL_SECTOR_SIZE );
+				#endif
+
+				gNAND_DrvInfo[0].NFTLDrvInfo->MultiHDArea[0].DrvStatus = DISABLE;
+				
+				if ( NAND_InitDrive(0) != SUCCESS )
+					return EINITFAIL;
+
+				TNFTL_AREAGetTotalSecAndCHS( gNAND_DrvInfo[0].NFTLDrvInfo,
+								 			 &gNAND_DrvInfo[0].NFTLDrvInfo->MultiHDArea[0],
+								 			 (U32 *)&gNAND_DrvInfo[0].NFTLDrvInfo->MultiHDArea[0].TotalDiskSector,
+								 			 &gNAND_DrvInfo[0].NFTLDrvInfo->MultiHDArea[0].Cylinder,
+								 			 &gNAND_DrvInfo[0].NFTLDrvInfo->MultiHDArea[0].Head,
+								 			 &gNAND_DrvInfo[0].NFTLDrvInfo->MultiHDArea[0].Sector );
+
+				gNAND_DrvInfo[0].NFTLDrvInfo->MultiHDArea[0].DrvStatus = ENABLE;
+			}
+			break;
+			
+		case	DEV_GET_DISKINFO:
+			{
+				ioctl_diskinfo_t	*info = (ioctl_diskinfo_t *) param;
+
+				info->cylinder		= gNAND_DrvInfo[0].NFTLDrvInfo->MultiHDArea[0].Cylinder;
+				info->head			= gNAND_DrvInfo[0].NFTLDrvInfo->MultiHDArea[0].Head;
+				info->sector		= gNAND_DrvInfo[0].NFTLDrvInfo->MultiHDArea[0].Sector;
+				info->sector_size	= 512;
+			}
+			break;
+			
+		case	DEV_FORMAT_DISK:
+			{
+				unsigned short	mode = *((unsigned short *)param);
+
+				TNFTL_AREAFormat( gNAND_DrvInfo[0].NFTLDrvInfo,
+								  &gNAND_DrvInfo[0].NFTLDrvInfo->MultiHDArea[0],
+								  mode );
+
+				return NAND_InitDrive(0);
+			}
+			break;
+			
+		case	DEV_ERASE_INIT:
+			{
+				ioctl_diskeraseinit_t	*erase = (ioctl_diskeraseinit_t *) param;
+				erase = erase;
+			}
+			break;
+			
+		case	DEV_ERASE_BLOCK:
+			{
+				ioctl_diskerase_t	*erase = (ioctl_diskerase_t *) param;
+				erase = erase;				
+			}
+			break;
+			
+		case	DEV_WRITEBACK_ON_IDLE:
+			{
+
+			}
+			break;
+			
+		case	DEV_ERASE_CLOSE:
+			{
+
+			}
+			break;
+			
+		case	DEV_HIDDEN_READ_PAGE_4:
+			{
+
+			}
+			break;
+
+		case	DEV_GET_MAX_SECTOR_PER_BLOCK:
+			{
+				unsigned short *value = (unsigned short *)param;
+
+				if ( gNAND_DrvInfo[0].NFTLDrvInfo->MultiHDArea[0].DrvStatus == ENABLE )
+				{
+					if ( gNAND_DrvInfo[0].NFTLDrvInfo->MultiHDArea[0].TotalDiskSector >
+					    (U32)( gNAND_DrvInfo[0].NFTLDrvInfo->PpB << gNAND_DrvInfo[0].NFTLDrvInfo->ShiftPPages ) * 2 )
+						*value = ( gNAND_DrvInfo[0].NFTLDrvInfo->PpB << gNAND_DrvInfo[0].NFTLDrvInfo->ShiftPPages );
+					else
+						*value = TNFTL_MAX_SUPPORT_NAND_IO_SECTOR_SIZE_PER_1PAGE;
+				}
+				else
+					*value = TNFTL_MAX_SUPPORT_NAND_IO_SECTOR_SIZE_PER_1PAGE;
+			}
+			break;
+
+		case	DEV_TELL_DATASTARTSECTOR:
+			{
+				TNFTL_WCacheSetDataStartSector( gNAND_DrvInfo[0].NFTLDrvInfo,
+												&gNAND_DrvInfo[0].NFTLDrvInfo->MultiHDArea[0],
+												*(unsigned int*)param );
+				break;
+			}
+
+		case	DEV_GET_WRITE_PROTECT:
+			return  0;
+			break;
+		case	DEV_GET_INSERTED:
+			return 1;
+		case	DEV_GET_INITED:
+			return 1;
+		case DEV_GET_PLAYABLE_STATUS:
+			return 1;			
+		default:
+			return	ENOTSUPPORT;
+	}
+	
+	return 0;	/* SUCCESS */
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      int NAND_ReadMultiSectorStart( U32 LBA, U16 nSecSize );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			LBA	= 
+*			nSecSize	= 
+*  
+*  OUTPUT:	int - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+int NAND_ReadMultiSectorStart( U32 LBA, U32 nSecSize )
+{
+	#ifdef NAND_INCLUDE
+	LBA = 0;
+	nSecSize = 0;
+	return 0;
+	#else
+	return NOT_SUPPORT_NAND;
+	#endif
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      int NAND_ReadMultiSectorStop( void );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			None
+*  
+*  OUTPUT:	int - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+int NAND_ReadMultiSectorStop( void )
+{
+	#ifdef NAND_INCLUDE
+	return 0;
+	#else
+	return NOT_SUPPORT_NAND;
+	#endif
+}	
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      int NAND_WriteMultiSectorStart( U32 LBA, U16 nSecSize );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			LBA	= 
+*			nSecSize	= 
+*  
+*  OUTPUT:	int - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+int NAND_WriteMultiSectorStart( U32 LBA, U32 nSecSize )
+{
+	#ifdef NAND_INCLUDE
+	LBA = 0;
+	nSecSize = 0;
+	return 0;
+	#else
+	return NOT_SUPPORT_NAND;
+	#endif
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      int NAND_WriteMultiSectorStop( void );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			None
+*  
+*  OUTPUT:	int - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+int NAND_WriteMultiSectorStop( void )
+{
+	#ifdef NAND_INCLUDE
+	return 0;
+	#else
+	return NOT_SUPPORT_NAND;
+	#endif
+}	
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      int NAND_HDClearPages( U32 nHDStPageAddr, U32 nHDEdPageAddr );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nHDEdPageAddr	= 
+*			nHDStPageAddr	= 
+*  
+*  OUTPUT:	int - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+int NAND_HDClearPages( U32 nHDStPageAddr, U32 nHDEdPageAddr )
+{
+	#ifdef NAND_INCLUDE
+	nHDStPageAddr = 0;
+	nHDEdPageAddr = 0;
+	return 0;
+	#else
+	return NOT_SUPPORT_NAND;
+	#endif
+}	
+
+/******************************************************************************
+*
+*	U16				NAND_GetSerialNumber
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+U16 NAND_GetSerialNumber( U8* rSerialNumber, U16 nSize )
+{
+	#ifdef NAND_INCLUDE
+	if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+		return TNFTL_GetSerialNumber( gNAND_DrvInfo[0].NFTLDrvInfo, rSerialNumber, nSize );
+	else
+	{
+		#ifdef NAND_LBA_INCLUDE
+		return NAND_IO_LBA_GetSerialNumber( gLBA_DevInfo, gNAND_PageBuffer, rSerialNumber, nSize );
+		#else
+		return 0;
+		#endif
+	}
+	#else
+	return 0;
+	#endif
+}
+
+/******************************************************************************
+*
+*	U16				NAND_GetUniqueID
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+U16 NAND_GetUniqueID( U8* rSerialNumber, U16 nSize )
+{
+	if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+	{
+		#if defined(NAND_INCLUDE) && !defined(_SDRAMONLY1_)
+		unsigned int uiIDSize;
+
+		uiIDSize = ( nSize < gNAND_DrvInfo[0].NFTLDrvInfo->MediaSizeOfUniqueID ) ? nSize : gNAND_DrvInfo[0].NFTLDrvInfo->MediaSizeOfUniqueID;
+		memcpy((void*)rSerialNumber, (void*)gNAND_DrvInfo[0].NFTLDrvInfo->MediaUniqueID, uiIDSize);
+
+		return (U16)uiIDSize;
+		#else
+		return 0;
+		#endif
+	}
+	else
+		return 0;
+}
+
+/******************************************************************************
+*
+*	TNFTL_ERROR		NAND_SetUartDebug
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+TNFTL_ERROR	NAND_SetUartDebug( unsigned int on_off )
+{
+	gNAND_UARTDebugFlag = (U8)on_off;
+
+	return (TNFTL_ERROR)SUCCESS;
+}	
+
+#ifdef NU_FILE_INCLUDE
+/************************************************************************
+* FUNCTION                                                              
+*                                                                       
+*       NAND_IO_Open                                                      
+*                                                                       
+* DESCRIPTION                                                           
+*                                                                       
+*       This function prepares the NAND Flash for usage by allocating the 
+*       pages necessary for usage.                                       
+*                                                                       
+* INPUTS                                                                
+*                                                                       
+*       driveno                             The number assigned to the NAND Flash. 
+*                                                                       
+* OUTPUTS                                                               
+*                                                                       
+*       YES                                 Successful Completion.      
+*       NO                                  Couldn't allocate all of the
+*                                            pages.                     
+*                                                                       
+*************************************************************************/
+INT NAND_IO_Open(UINT16 driveno)
+{
+	NU_Obtain_Semaphore(&CAPP_SEM, NU_SUSPEND);
+	NAND_Ioctl(DEV_INITIALIZE, NULL);
+	NU_Release_Semaphore(&CAPP_SEM);
+    	return(YES);
+}
+
+#ifdef INTERNAL_HIDDEN_STORAGE_INCLUDE
+/**************************************************************************
+*  FUNCTION NAME : 
+*      INT NAND_HD_IO_Open(UINT16 driveno);
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			driveno	= 
+*  
+*  OUTPUT:	INT - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+INT NAND_HD_IO_Open(UINT16 driveno)
+{
+	NU_Obtain_Semaphore(&CAPP_SEM, NU_SUSPEND);
+	NAND_HDIoctl(DEV_INITIALIZE, NULL);
+	NU_Release_Semaphore(&CAPP_SEM);
+    	return(YES);
+}
+#endif	//INTERNAL_HIDDEN_STORAGE_INCLUDE
+
+/************************************************************************
+* FUNCTION                                                              
+*                                                                       
+*       NAND_IO_RAW_Open                                                  
+*                                                                       
+* DESCRIPTION                                                           
+*                                                                       
+*       This function doesn't do anything for the NAND Flash.  It is      
+*       included for devtable consistency.                              
+*                                                                       
+* INPUTS                                                                
+*                                                                       
+*       None.                                                           
+*                                                                       
+* OUTPUTS                                                               
+*                                                                       
+*       None.                                                           
+*                                                                       
+*************************************************************************/
+INT NAND_IO_RAW_Open(UINT16 driveno)
+{
+    return(NO);
+}
+
+#ifdef INTERNAL_HIDDEN_STORAGE_INCLUDE
+/**************************************************************************
+*  FUNCTION NAME : 
+*      INT NAND_HD_IO_RAW_Open(UINT16 driveno);
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			driveno	= 
+*  
+*  OUTPUT:	INT - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+INT NAND_HD_IO_RAW_Open(UINT16 driveno)
+{
+    return(NO);
+}
+#endif	//INTERNAL_HIDDEN_STORAGE_INCLUDE
+
+/************************************************************************
+* FUNCTION                                                              
+*                                                                       
+*       NAND_IO_Close                                                     
+*                                                                       
+* DESCRIPTION                                                           
+*                                                                       
+*       This function deallocates all of the pages associated with the  
+*       NAND Flash. The actual code here is commented out since we        
+*       probably don't want to loose the data on a close.               
+*                                                                       
+* INPUTS                                                                
+*                                                                       
+*       driveno                             The number assigned to the NAND Flash.
+*                                                                       
+* OUTPUTS                                                               
+*                                                                       
+*       YES                                 Successful Completion.      
+*       NO                                  Couldn't allocate all of the
+*                                            pages.                     
+*                                                                       
+*************************************************************************/
+INT NAND_IO_Close(UINT16 driveno) 
+{
+    return(YES);
+}
+
+#ifdef INTERNAL_HIDDEN_STORAGE_INCLUDE
+/**************************************************************************
+*  FUNCTION NAME : 
+*      INT NAND_HD_IO_Close(UINT16 driveno) ;
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			driveno	= 
+*  
+*  OUTPUT:	INT - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+INT NAND_HD_IO_Close(UINT16 driveno) 
+{
+    return(YES);
+}
+#endif	//INTERNAL_HIDDEN_STORAGE_INCLUDE
+
+/************************************************************************
+* FUNCTION                                                              
+*                                                                       
+*       NAND_IO_ReadWrite                                                        
+*                                                                       
+* DESCRIPTION                                                           
+*                                                                       
+*       This function reads or writes data from and to the NAND Flash     
+*       based on the 'reading' parameter.                               
+*                                                                       
+* INPUTS                                                                
+*                                                                       
+*       driveno                             The number assigned to the  
+*                                            RAM Disk (not used)        
+*       block                               The block number to read or 
+*                                            write                      
+*       buffer                              Pointer to the data to be   
+*                                            placed from a read or      
+*                                            stored on a write          
+*       count                               Number of bytes to be read  
+*                                            or written                 
+*       reading                             Indicates whether or not we 
+*                                            are reading or writing     
+*                                                                       
+* OUTPUTS                                                               
+*                                                                       
+*       YES                                 Successful Completion.      
+*       NO                                  Block number is out of range.
+*                                                                       
+*************************************************************************/
+INT NAND_IO_ReadWrite(UINT16 driveno, UINT32 block, VOID *buffer, UINT16 count, INT reading) 
+{
+	int result;
+
+	NU_Obtain_Semaphore(&CAPP_SEM, NU_SUSPEND);
+	
+	if(reading)
+		result = NAND_ReadSector(driveno, block, count, buffer);
+	else
+		result = NAND_WriteSector(driveno, block, count, buffer);
+
+	NU_Release_Semaphore(&CAPP_SEM);
+
+	if(!result)
+		return (YES);
+	else
+		return (NO);
+}
+
+#ifdef INTERNAL_HIDDEN_STORAGE_INCLUDE
+/**************************************************************************
+*  FUNCTION NAME : 
+*      INT NAND_HD_IO_ReadWrite(UINT16 driveno, UINT32 block, VOID *buffer, UINT16 count, INT reading) ;
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			block	= 
+*			buffer	= 
+*			count	= 
+*			driveno	= 
+*			reading	= 
+*  
+*  OUTPUT:	INT - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+INT NAND_HD_IO_ReadWrite(UINT16 driveno, UINT32 block, VOID *buffer, UINT16 count, INT reading) 
+{
+	int result;
+
+	NU_Obtain_Semaphore(&CAPP_SEM, NU_SUSPEND);
+
+	driveno	-= INTERNAL_HIDDEN_STORAGE_START_NO;
+	if(reading)
+		result = NAND_HDReadSector(driveno, block, count, buffer);
+	else
+		result = NAND_HDWriteSector(driveno, block, count, buffer);
+
+	NU_Release_Semaphore(&CAPP_SEM);
+
+	if(!result)
+		return (YES);
+	else
+		return (NO);
+}
+#endif	//INTERNAL_HIDDEN_STORAGE_INCLUDE
+
+/************************************************************************
+* FUNCTION                                                              
+*                                                                       
+*       NAND_IO_Ioctl                                                     
+*                                                                       
+* DESCRIPTION                                                           
+*                                                                       
+*       This function doesn't do anything for the NAND Flash.  It is      
+*       included for devtable consistency.                              
+*                                                                       
+* INPUTS                                                                
+*                                                                       
+*       None.                                                           
+*                                                                       
+* OUTPUTS                                                               
+*                                                                       
+*       None.                                                           
+*                                                                       
+*************************************************************************/
+INT NAND_IO_Ioctl(UINT16 driveno, UINT16 command, VOID *buffer)
+{
+	int result;
+
+	NU_Obtain_Semaphore(&CAPP_SEM, NU_SUSPEND);
+	result	= NAND_Ioctl(command, buffer);
+	NU_Release_Semaphore(&CAPP_SEM);
+
+	return result;
+}
+
+#ifdef INTERNAL_HIDDEN_STORAGE_INCLUDE
+/**************************************************************************
+*  FUNCTION NAME : 
+*      INT NAND_HD_IO_Ioctl(UINT16 driveno, UINT16 command, VOID *buffer);
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			buffer	= 
+*			command	= 
+*			driveno	= 
+*  
+*  OUTPUT:	INT - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+INT NAND_HD_IO_Ioctl(UINT16 driveno, UINT16 command, VOID *buffer)
+{
+	int result;
+
+	NU_Obtain_Semaphore(&CAPP_SEM, NU_SUSPEND);
+	result	= NAND_HDIoctl(command, buffer);
+	NU_Release_Semaphore(&CAPP_SEM);
+
+	return result;
+}
+#endif	//INTERNAL_HIDDEN_STORAGE_INCLUDE
+
+#endif	// NU_FILE_INCLUDE
+
+//#endif	// WITHOUT_FILESYSTEM
+
+/* end of file */
diff --git a/drivers/block/tcc/nand_drv_v7.c b/drivers/block/tcc/nand_drv_v7.c
new file mode 100644
index 0000000..a5e94e7
--- /dev/null
+++ b/drivers/block/tcc/nand_drv_v7.c
@@ -0,0 +1,2096 @@
+/****************************************************************************
+ *   FileName    : nand_drv_v7.c
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+#if defined(_LINUX_)
+#include "common.h"
+#if defined(USE_V_ADDRESS)
+#include <linux/kernel.h>
+#include <linux/string.h>
+#endif
+#endif
+
+#if defined(_LINUX_) || defined(_WINCE_)
+//#include "IO_TCC7XX.h"
+#include "nand_drv.h"
+//#include "Disk.h"
+#include "TC_File.h"
+#else
+#include "Globals.h"
+#include "IO_TCCXXX.h"
+#include "nand_drv.h"
+#include "disk.h"
+#include "FileBufferCtrl.h"
+#include "Assert.h"
+#endif
+
+#ifdef _WINCE_
+#include "bsp.h"
+#include "args.h"
+#endif
+
+#if defined(__NUCLEUS_KERNEL__)
+#include "TC_Kernel.h"
+#endif
+
+#ifdef AUDIOUI_INCLUDE	
+#include "AudioUI.H"
+#endif
+
+//#define NAND_DRV_PORT_DEBUG
+
+//#define TNFTL_READ_CACHE_INCLUDE
+
+#ifdef BOOTCRCCHEK
+	typedef struct _BootCRC
+	{
+		unsigned int crc128kchk;
+		unsigned int crcfullchk;
+		unsigned int bootfilesize;
+	}BootCRC; 
+#endif
+
+#ifndef WITHOUT_FILESYSTEM
+
+#if defined( FWDN_DOWNLOADER_INCLUDE )
+const unsigned char	NANDDRV_Library_Version[] = { "SIGBYAHONG_NANDDRV_FWDN_V007000" };
+#elif defined(TCC92XX)
+const unsigned char	NANDDRV_Library_Version[] = { "SIGBYAHONG_NANDDRV_TCC92XX_V007000" };
+#elif defined(TCC89XX)
+const unsigned char	NANDDRV_Library_Version[] = { "SIGBYAHONG_NANDDRV_TCC89XX_V007000" };
+#endif
+
+//=============================================================================
+//*
+//*
+//*                           [ CONST DATA DEFINE ]
+//*
+//*
+//=============================================================================
+#define NAND_DRV_HIDDEN_INFO_SIZE	( 19 + 8 + 1*4 )
+
+const unsigned char gNAND_HiddenInfoSignature[ NAND_DRV_HIDDEN_INFO_SIZE ] =
+{
+	'T','N','F','T','L','H','I','D','D','E','N','S','I','Z','E','I','N','F','O',
+    
+    #ifndef NU_FILE_INCLUDE
+	#ifdef AUDIOUI_INCLUDE	
+	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE+AUI_HD_OCCPAGE) >>  0) & 0xFF,
+	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE+AUI_HD_OCCPAGE) >>  8) & 0xFF,
+	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE+AUI_HD_OCCPAGE) >> 16) & 0xFF,
+	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE+AUI_HD_OCCPAGE) >> 24) & 0xFF,
+	#else
+	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE) >>  0) & 0xFF,
+	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE) >>  8) & 0xFF,
+	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE) >> 16) & 0xFF,
+	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE)>> 24) & 0xFF,
+    #endif
+    #else
+    ((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE) >>  0) & 0xFF,
+	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE) >>  8) & 0xFF,
+	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE) >> 16) & 0xFF,
+	((unsigned long int)(NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE) >> 24) & 0xFF,
+	#endif
+
+	((unsigned long int)TNFTL_EXTENDED_PARTITION_NUM >>  0) & 0xFF,
+	((unsigned long int)TNFTL_EXTENDED_PARTITION_NUM >>  8) & 0xFF,
+	((unsigned long int)TNFTL_EXTENDED_PARTITION_NUM >> 16) & 0xFF,
+	((unsigned long int)TNFTL_EXTENDED_PARTITION_NUM >> 24) & 0xFF,
+
+	((unsigned long int)NAND_HIDDEN_DRIVE_DEFAULT_TOTAL_SECTOR_SIZE >>  0) & 0xFF,
+	((unsigned long int)NAND_HIDDEN_DRIVE_DEFAULT_TOTAL_SECTOR_SIZE >>  8) & 0xFF,
+	((unsigned long int)NAND_HIDDEN_DRIVE_DEFAULT_TOTAL_SECTOR_SIZE >> 16) & 0xFF,
+	((unsigned long int)NAND_HIDDEN_DRIVE_DEFAULT_TOTAL_SECTOR_SIZE >> 24) & 0xFF
+};
+
+//=============================================================================
+//*
+//*
+//*                           [ GLOBAL VARIABLE DEFINE ]
+//*
+//*
+//=============================================================================
+NAND_DRVINFO		gNAND_DrvInfo[MAX_NAND_DRIVE];
+TNFTL_EXT_PART_INFO	gTNFTL_ExtPartitionInfo[MAX_NAND_DRIVE];
+TNFTL_DRVINFO		gTNFTL_DrvInfo[MAX_NAND_DRIVE];
+
+TNFTL_RW_AREA		gTNFTL_ExtPartitionDrvInfo[MAX_NAND_DRIVE][TNFTL_EXTENDED_PARTITION_MAX_NUM];
+
+TNFTL_LPT_BLOCK		gTNFTL_PriPartitionLPTBlk[MAX_NAND_DRIVE][TNFTL_LPT_BLK_NUM_For_PRIMARY_PARTITION];
+TNFTL_LPT_BLOCK		gTNFTL_ExtPartitionLPTBlk[MAX_NAND_DRIVE][TNFTL_EXTENDED_PARTITION_MAX_NUM][TNFTL_LPT_BLK_NUM_For_EXTENDED_PARTITION];
+
+TNFTL_WCACHE		gTNFTL_PriPartitionWCache[MAX_NAND_DRIVE][TNFTL_WCACHE_NUM_For_PRIMARY_PARTITION];
+TNFTL_WCACHE		gTNFTL_ExtPartitionWCache[MAX_NAND_DRIVE][TNFTL_EXTENDED_PARTITION_MAX_NUM][TNFTL_WCACHE_NUM_For_EXTENDED_PARTITION];
+
+#if defined( TNFTL_READ_CACHE_INCLUDE )
+TNFTL_RCACHE_SLOT 	gTNFTL_PriPartitionRCache[MAX_NAND_DRIVE][TNFTL_MAX_SUPPORT_RCACHE_MEMORY_SIZE>>9];
+TNFTL_RCACHE_SLOT	gTNFTL_ExtPartitionRCache[MAX_NAND_DRIVE][TNFTL_EXTENDED_PARTITION_MAX_NUM][TNFTL_MAX_SUPPORT_RCACHE_MEMORY_SIZE>>9];
+#endif
+
+TNFTL_MAINPB_INFO 	gTNFTL_PriPartitionMainPBInfo[MAX_NAND_DRIVE][TNFTL_WCACHE_NUM_For_PRIMARY_PARTITION];
+TNFTL_MAINPB_INFO 	gTNFTL_ExtPartitionMainPBInfo[MAX_NAND_DRIVE][TNFTL_EXTENDED_PARTITION_MAX_NUM][TNFTL_WCACHE_NUM_For_EXTENDED_PARTITION];
+
+NAND_IO_DEVINFO		*gLBA_DevInfo;
+
+unsigned char		gNAND_UARTDebugFlag = DISABLE;
+unsigned char		gNAND_PartitionInfoLoadFlag = DISABLE;
+#if defined(_LINUX_) || defined(_WINCE_)
+unsigned char		gNAND_SetFlagOfChangeAreaSize = DISABLE;
+unsigned char		gFormatType	= TC_LOWLEVEL_YES;
+unsigned int		gMAX_ROMSIZE = MAX_ROMSIZE_NAND;
+#else
+unsigned char		gNAND_SetFlagOfChangeAreaSize = ENABLE;
+#endif
+
+//=============================================================================
+//*
+//*
+//*                           [ LOCAL FUNCTIONS DEFINE ]
+//*
+//*
+//=============================================================================
+
+//=============================================================================
+//*
+//*
+//*                     [ EXTERN VARIABLE & FUNCTIONS DEFINE ]
+//*
+//*
+//=============================================================================
+extern unsigned char	NANDBUF_Library_Version[];
+#if defined(_LINUX_)
+unsigned char 			gNAND_PageBuffer[TNFTL_MAX_SUPPORT_NAND_IO_PAGE_SIZE + TNFTL_MAX_SUPPORT_NAND_IO_SPARE_SIZE] __attribute__((aligned(8)));
+unsigned char 			gNAND_RCacheDTAreaBuffer[TNFTL_MAX_SUPPORT_RCACHE_MEMORY_SIZE] __attribute__((aligned(8)));
+unsigned char 			gNAND_AlignBuffer[TNFTL_MAX_SUPPORT_ALIGNCACHE_MEMORY_SIZE] __attribute__((aligned(8)));
+#else
+extern unsigned char	gNAND_PageBuffer[TNFTL_MAX_SUPPORT_NAND_IO_PAGE_SIZE + TNFTL_MAX_SUPPORT_NAND_IO_SPARE_SIZE];
+extern unsigned char 	gNAND_RCacheDTAreaBuffer[TNFTL_MAX_SUPPORT_RCACHE_MEMORY_SIZE];
+extern unsigned char	gNAND_AlignBuffer[TNFTL_MAX_SUPPORT_ALIGNCACHE_MEMORY_SIZE];
+#endif
+
+extern NAND_IO_CYCLE	WriteCycleTime;
+extern NAND_IO_CYCLE	ReadCycleTime;
+extern NAND_IO_CYCLE	CommCycleTime;
+extern unsigned int		gMaxBusClkMHZ;
+extern unsigned int		gCycleTick;
+
+#if !defined(NU_FILE_INCLUDE) && !defined(_LINUX_) && !defined(_WINCE_)
+extern unsigned int		fat_cbuffer[];
+#else
+extern unsigned char	gFormatType;
+#endif
+
+#if !defined(FWDN_DOWNLOADER_INCLUDE) && !defined(_LINUX_) && !defined(_WINCE_)
+	#ifdef MTP_INCLUDE
+	extern void*		MTPMEM_AllocNandInitBuffer( void );
+	extern unsigned int	MTPMEM_GetNandIintBufferSize( void );
+	#else
+	extern char			gFileBuffer[RAW_BUFFERSIZE];
+	#endif
+#endif
+
+#if defined(_WINCE_)
+extern void B_RETAILMSG(const char * fmt, ...);
+#endif
+
+/******************************************************************************
+*
+*	unsigned char*	NAND_TellLibraryVersion
+*
+*	Input	: NONE
+*	Output	: NONE
+*	Return	: NONE
+*
+*	Description :
+*
+*******************************************************************************/
+unsigned char*	NAND_TellLibraryVersion( void )
+{
+	return (unsigned char*)gNAND_HiddenInfoSignature;
+}	
+
+/******************************************************************************
+*
+*	unsigned char*	NAND_DRV_TellLibraryVersion
+*
+*	Input	: NONE
+*	Output	: NONE
+*	Return	: NONE
+*
+*	Description :
+*
+*******************************************************************************/
+unsigned char*	NAND_DRV_TellLibraryVersion( void )
+{
+	unsigned short int 	i = 0;
+
+	if ( i )
+		return (unsigned char*)NANDBUF_Library_Version;
+	else
+		return (unsigned char*)NANDDRV_Library_Version;
+}
+
+/*************************************************************************************
+ *          NAND_Init
+ *
+ * Description  :
+ * Argument     :
+ * Return       :   if it is successed then return 0
+ *                  if it is failed then return Error Code
+ *
+ *************************************************************************************/
+void NAND_Init( void )
+{
+	#ifdef NAND_LBA_INCLUDE
+	NAND_ERROR	res;
+	#endif
+		
+	#ifdef INTERNAL_HIDDEN_STORAGE_INCLUDE
+	unsigned int 	i;
+	#endif
+	
+	#if !defined(NU_FILE_INCLUDE) && !defined(FWDN_DOWNLOADER_INCLUDE) && !defined(_LINUX_) & !defined(_WINCE_)
+	unsigned int	BufferSize;
+	#endif
+
+    //=====================================================
+    // Initialize NAND IO & TNFTL Variable
+    //=====================================================
+	NAND_IO_Init();
+
+    //=================================================================
+    // Initialize TNFTL Driver
+    //=================================================================
+	/* Drive #0 */
+	TNFTL_AllocMemAndLinkForDriver( NAND_DRV_0, &gTNFTL_DrvInfo[NAND_DRV_0], &gNAND_DrvInfo[NAND_DRV_0].NFTLDrvInfo );
+	
+	TNFTL_AllocMemAndLinkForLPT( NAND_DRV_0, &gTNFTL_DrvInfo[NAND_DRV_0].PriPartition, &gTNFTL_PriPartitionLPTBlk[NAND_DRV_0][0], TNFTL_LPT_BLK_NUM_For_PRIMARY_PARTITION );
+	TNFTL_AllocMemAndLinkForWCACHE( NAND_DRV_0, &gTNFTL_DrvInfo[NAND_DRV_0].PriPartition, &gTNFTL_PriPartitionWCache[NAND_DRV_0][0], TNFTL_WCACHE_NUM_For_PRIMARY_PARTITION );
+	#if defined( TNFTL_READ_CACHE_INCLUDE )
+	TNFTL_AllocMemAndLinkForRCACHE( NAND_DRV_0, &gTNFTL_DrvInfo[NAND_DRV_0].PriPartition, &gTNFTL_PriPartitionRCache[NAND_DRV_0][0] );
+	#endif
+    TNFTL_AllocMemAndLinkForMainPBInfo( NAND_DRV_0, &gTNFTL_DrvInfo[NAND_DRV_0].PriPartition, &gTNFTL_PriPartitionMainPBInfo[NAND_DRV_0][0], 2 );
+
+	TNFTL_AllocMemAndLinkForExtendedPartition( NAND_DRV_0, &gTNFTL_ExtPartitionDrvInfo[NAND_DRV_0][0] );
+	TNFTL_SetExtendedPartitionNums( NAND_DRV_0, TNFTL_EXTENDED_PARTITION_NUM );
+
+	#ifdef INTERNAL_HIDDEN_STORAGE_INCLUDE
+	for ( i = 0; i < TNFTL_EXTENDED_PARTITION_MAX_NUM; ++i )
+	{
+		TNFTL_AllocMemAndLinkForLPT( NAND_DRV_0, &gTNFTL_DrvInfo[NAND_DRV_0].ExtPartition[i], &gTNFTL_ExtPartitionLPTBlk[NAND_DRV_0][i][0], TNFTL_LPT_BLK_NUM_For_EXTENDED_PARTITION );
+		TNFTL_AllocMemAndLinkForWCACHE( NAND_DRV_0, &gTNFTL_DrvInfo[NAND_DRV_0].ExtPartition[i], &gTNFTL_ExtPartitionWCache[NAND_DRV_0][i][0], TNFTL_WCACHE_NUM_For_EXTENDED_PARTITION );
+		TNFTL_AllocMemAndLinkForMainPBInfo( NAND_DRV_0, &gTNFTL_DrvInfo[NAND_DRV_0].ExtPartition[i], &gTNFTL_ExtPartitionMainPBInfo[NAND_DRV_0][i][0], TNFTL_WCACHE_NUM_For_EXTENDED_PARTITION );
+		#if defined( TNFTL_V5_INCLUDE ) || defined(TNFTL_V6_INCLUDE)
+		TNFTL_AllocMemAndLinkForRCACHE( NAND_DRV_0, &gTNFTL_DrvInfo[NAND_DRV_0].ExtPartition[i], &gTNFTL_ExtPartitionRCache[NAND_DRV_0][i][0] );
+		#endif	
+	}
+	#endif
+
+	TNFTL_Init( NAND_DRV_0 );
+	TNFTL_SetStEdOfCS( NAND_DRV_0, NAND_IO_DRV0_START_CS, NAND_IO_DRV0_END_CS );
+
+	TNFTL_AllocMemAndLinkForPageBuffer( NAND_DRV_0, gNAND_PageBuffer );
+	#if defined( TNFTL_READ_CACHE_INCLUDE )
+	TNFTL_AllocMemAndLinkForRCacheBuffer( NAND_DRV_0, &gTNFTL_DrvInfo[NAND_DRV_0].PriPartition, gNAND_RCacheDTAreaBuffer, TNFTL_MAX_SUPPORT_RCACHE_MEMORY_SIZE );
+	TNFTL_SetUseAreaReadCacheMode( gNAND_DrvInfo[NAND_DRV_0].NFTLDrvInfo, &gTNFTL_DrvInfo[NAND_DRV_0].PriPartition, ENABLE );
+	TNFTL_AllocMemAndLinkForAlignCacheBuffer( NAND_DRV_0, gNAND_AlignBuffer, TNFTL_MAX_SUPPORT_ALIGNCACHE_MEMORY_SIZE );
+	#endif
+
+	#if !defined(NU_FILE_INCLUDE) && !defined(_LINUX_) && !defined(_WINCE_)
+	#ifndef FWDN_DOWNLOADER_INCLUDE
+		#ifdef MTP_INCLUDE
+		BufferSize = MTPMEM_GetNandIintBufferSize() / 4;
+		#else
+		BufferSize = RAW_BUFFERSIZE / 4;
+		#endif
+
+		if ( BufferSize > 65536 / 4 )
+		{
+			#ifdef MTP_INCLUDE
+			TNFTL_AllocMemAndLinkForMakeLPT( NAND_DRV_0, (unsigned char*)MTPMEM_AllocNandInitBuffer(), MTPMEM_GetNandIintBufferSize() / 4 );
+			#else
+			TNFTL_AllocMemAndLinkForMakeLPT( NAND_DRV_0, gFileBuffer, RAW_BUFFERSIZE / 4 );
+			#endif
+		}
+		else
+		{
+			TNFTL_AllocMemAndLinkForMakeLPT( NAND_DRV_0, fat_cbuffer, 65536 / 4 );
+		}
+	#else	
+		TNFTL_AllocMemAndLinkForMakeLPT( NAND_DRV_0, fat_cbuffer, 65536 / 4 );
+	#endif
+	#endif
+
+	#ifdef NAND_LBA_INCLUDE
+	gLBA_DevInfo = &gNAND_DrvInfo[0].NFTLDrvInfo->MediaDevInfo[0];
+	
+	gLBA_DevInfo->LBAInfo.FlagOfChangeTotalSectorSize = DISABLE;
+	res = NAND_IO_LBA_GetDeviceInfo( gLBA_DevInfo );
+	if ( ( res == SUCCESS ) || ( gLBA_DevInfo->Feature.MediaType & S_LBA ) )
+		gNAND_DrvInfo[0].NFTLDrvInfo->NANDType = NAND_TYPE_LBA_NAND;
+	else
+		gNAND_DrvInfo[0].NFTLDrvInfo->NANDType = NAND_TYPE_PURE_NAND;
+	#else
+		gNAND_DrvInfo[0].NFTLDrvInfo->NANDType = NAND_TYPE_PURE_NAND;	
+	#endif
+
+	/* Init TNFTL MSC Debug Monitor */
+	#if !defined(FWDN_DOWNLOADER_INCLUDE) && !defined(_LINUX_) && !defined(_WINCE_)
+	#ifdef TNFTL_DEBUG_INCLUDE
+	TNFTL_DEBUG_Init_Function(  MASS_SCSI_InitMSCDebugMonitor,
+								VTC_SendData,
+								VTC_ReceiveData,
+								MASS_BulkOnly_SendData,
+								MASS_BulkOnly_ReceiveData,
+								MASS_SCSI_SetMSCDebugMonitorHandler,
+								FWDN_PROT_ResponseAck,
+								FWDN_PROT_ResponseNack);
+	TNFTL_DEBUG_Init();
+	#endif
+	#endif
+
+	return;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      void NAND_InitExtPartitionInfo( void );
+*  
+*  DESCRIPTION : 
+*  
+*  INPUT :	NONE
+*  
+*  OUTPUT:	void - Return Type
+*  
+**************************************************************************/
+void NAND_InitExtPartitionInfo( void )
+{
+	unsigned int i;
+
+	gTNFTL_ExtPartitionInfo[NAND_DRV_0].ExtendedPartitionNum = TNFTL_EXTENDED_PARTITION_NUM;
+
+	#if defined(_LINUX_) || defined(_WINCE_)
+	for ( i = 0; i < TNFTL_EXTENDED_PARTITION_NUM; ++i )
+		gTNFTL_ExtPartitionInfo[NAND_DRV_0].ExtPartitionSize[i] =  4096;
+
+	#else
+	for ( i = 0; i < TNFTL_EXTENDED_PARTITION_MAX_NUM; ++i )
+		gTNFTL_ExtPartitionInfo[NAND_DRV_0].ExtPartitionSize[i] =  NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE;
+
+	#endif
+	return;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      void NAND_SetFlagOfChangeAreaSize( unsigned char On_Off );
+*  
+*  DESCRIPTION :
+*  
+*  INPUT :
+*			On_Off	= ENABLE/DISABLE
+*  
+*  OUTPUT:	void - Return Type
+*  
+**************************************************************************/
+void NAND_SetFlagOfChangeAreaSize( unsigned char On_Off )
+{
+	gNAND_SetFlagOfChangeAreaSize = On_Off;
+	return;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      void NAND_SetExtPartitionInfoLoagFlag( unsigned char On_Off );
+*  
+*  DESCRIPTION : 
+*  
+*  INPUT:
+*			On_Off	= ENABLE/DISABLE
+*  
+*  OUTPUT:	void - Return Type
+*  
+**************************************************************************/
+void NAND_SetExtPartitionInfoLoagFlag( unsigned char On_Off )
+{
+	gNAND_PartitionInfoLoadFlag = On_Off;
+	return;
+}
+	
+/******************************************************************************
+*
+*	NAND_ERROR		NAND_InitDrive
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_ERROR NAND_InitDrive( int nDrvNo )
+{
+	unsigned int	i = 0;
+	TNFTL_ERROR res;
+	#if defined(NU_FILE_INCLUDE) || defined(_LINUX_) || defined(_WINCE_)
+	void		*pointer;
+		#if defined(_LINUX_)
+		unsigned				bufSize	= 64*1024;
+		static unsigned int		Tempbuffer[64*1024];
+		#else
+		unsigned				bufSize	= 256*1024;
+		static unsigned char	Tempbuffer[256*1024];
+		#endif
+	#endif
+
+	unsigned int	 nTemp;
+	
+	if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+	{
+	    //===============================================================
+	    // Check Drive I/O in the FTL Layer
+	    //===============================================================	
+	    gNAND_DrvInfo[nDrvNo].DrvStatus = DISABLE;
+    
+		#if defined(NU_FILE_INCLUDE)
+	    pointer	= TC_Allocate_Memory(bufSize);
+	    if (pointer == NULL)
+			return	-1;
+		#elif defined(_LINUX_) || defined(_WINCE_)
+		pointer	= Tempbuffer;
+		if (pointer == NULL)
+			return	-1;
+		#endif
+    
+		#if defined(NU_FILE_INCLUDE)|| defined(_LINUX_) || defined(_WINCE_)
+			#if defined(_LINUX_)
+			TNFTL_AllocMemAndLinkForMakeLPT( NAND_DRV_0, pointer, bufSize );	/* [1193] */
+			#else
+	  	  	TNFTL_AllocMemAndLinkForMakeLPT( NAND_DRV_0, pointer, bufSize/4 );	/* [1193] */
+			#endif
+		#endif
+    
+	    if ( gNAND_SetFlagOfChangeAreaSize == DISABLE )
+			TNFTL_SetFlagOfChangePartition( gNAND_DrvInfo[0].NFTLDrvInfo, DISABLE );
+		else
+		{
+			TNFTL_SetFlagOfChangePartition( gNAND_DrvInfo[0].NFTLDrvInfo, ENABLE );
+			TNFTL_SetAreaProtectFlag(DISABLE);		// Set Flag Only FWDN_MODE
+		}
+	    
+		#ifdef NU_FILE_INCLUDE	
+	    // Check if low-level format option is enabled.	/*	[1255]  */
+	    if (usbFirmwareDownloadMode & Hw8)
+	    {
+		    BITCLR(usbFirmwareDownloadMode, Hw8);
+		    TNFTL_BMPRefresh( gNAND_DrvInfo[0].NFTLDrvInfo);
+	    }
+	    #endif
+
+		//=========================================================
+		// Linux MTD Include
+		//=========================================================
+		#if defined(_LINUX_) //&& defined(_MTD_IO_INCLUDE_)
+		TNFTL_SetROAreaSize( gNAND_DrvInfo[nDrvNo].NFTLDrvInfo, gTNFTL_ExtPartitionInfo[NAND_DRV_0].ROAreaSize << 20, ENABLE );
+		#else
+		TNFTL_SetROAreaSize( gNAND_DrvInfo[nDrvNo].NFTLDrvInfo, 0, DISABLE );
+		#endif
+		
+		NAND_IO_GetDeviceInfo( 0, &gNAND_DrvInfo[0].NFTLDrvInfo->MediaDevInfo[0] );
+		nTemp 	= gMAX_ROMSIZE >> gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->MediaDevInfo[0].ShiftPageSize;
+		nTemp 	= nTemp >> gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->MediaDevInfo[0].ShiftPpB;
+		nTemp 	= nTemp << 2;
+		nTemp 	+= 20;
+		TNFTL_SetNBAreaEndPBAddr(nTemp);		// 1 ~ n Block No...
+		
+	    res = TNFTL_InitDrive( gNAND_DrvInfo[nDrvNo].NFTLDrvInfo );
+
+		#if defined(USE_V_ADDRESS) && defined(_WINCE_)
+			//--------------------------
+			// NAND Cycle Info
+			//--------------------------
+			#if 1
+			RETAILMSG(1, (TEXT("[NAND        ] [BClk %dMHZ][1Tick %d][RE-S:%d,P:%d,H:%d][WR-S:%d,P:%d,H:%d][COM-S:%d,P:%d,H:%d]\n"),
+			gMaxBusClkMHZ,gCycleTick,ReadCycleTime.STP,ReadCycleTime.PW,ReadCycleTime.HLD,
+			WriteCycleTime.STP,WriteCycleTime.PW,WriteCycleTime.HLD,CommCycleTime.STP,CommCycleTime.PW,CommCycleTime.HLD));
+			#endif
+
+			//--------------------------
+			// NAND Area Size Info
+			//--------------------------
+			#if 0
+			RETAILMSG(1, (TEXT("[NAND        ] [NB Area:%dMB][DT Area:%dMB]"), 
+			( gMAX_ROMSIZE * 2 ) >> 20,	gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->PriPartition.TotalSectorSize >> 11 ));
+			for ( i = 0; i < gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->ExtendedPartitionNo; ++i )
+				RETAILMSG(1, (TEXT( "[HD Area%d:%dMB]"), i, gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->ExtPartition[i].TotalSectorSize >> 11 ));
+			RETAILMSG(1, (TEXT("\n")));
+			#endif
+
+			//--------------------------
+			// NAND Area Bad Block Info
+			//--------------------------
+			#if 0
+			RETAILMSG(1, (TEXT( "[NAND        ] [BadBlockNum: %d]\n"),gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->FTLBadBlockNum ));
+			RETAILMSG(1, (TEXT( "[NAND        ] [Blk:")));
+			for ( i = 0; i < gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->FTLBadBlockNum; ++i )
+				RETAILMSG(1, (TEXT( "%d "), ( gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->FTLBadBlock[i] & 0x0000FFFF)));
+			RETAILMSG(1, (TEXT("\n")));
+			#endif
+
+		    if ( res != SUCCESS )
+				RETAILMSG(1, (TEXT( "\n[NAND        ] [NAND_Init_Error:0x%x]\n"), res ));
+		#else
+			//--------------------------
+			// NAND Cycle Info
+			//--------------------------
+			#if 1
+			ND_TRACE( "[NAND        ] [BClk %dMHZ][1Tick %d][RE-S:%d,P:%d,H:%d][WR-S:%d,P:%d,H:%d][COM-S:%d,P:%d,H:%d]\n",
+			gMaxBusClkMHZ,gCycleTick,ReadCycleTime.STP,ReadCycleTime.PW,ReadCycleTime.HLD,
+			WriteCycleTime.STP,WriteCycleTime.PW,WriteCycleTime.HLD,CommCycleTime.STP,CommCycleTime.PW,CommCycleTime.HLD );
+			#endif
+
+			//--------------------------
+			// NAND Area Size Info
+			//--------------------------			
+			#if 1
+			ND_TRACE( "[NAND        ] [NB Area:%dMB][DT Area:%dMB]", 
+			(gMAX_ROMSIZE * 2) >> 20,
+			gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->PriPartition.TotalSectorSize >> 11);
+			for ( i = 0; i < gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->ExtendedPartitionNo; ++i )
+				ND_TRACE( "[HD Area%d:%dMB]", i, gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->ExtPartition[i].TotalSectorSize >> 11 );
+			#if defined(_LINUX_)
+			if ( gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->ROAreaSize != 0 )
+				ND_TRACE("[MTD Size:%dMB]", gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->ROAreaSize >> 20 );
+			#endif
+			ND_TRACE("\n");
+			#endif
+
+			//--------------------------
+			// NAND Area Bad Block Info
+			//--------------------------			
+			#if 0
+			ND_TRACE( "[NAND        ] [BadBlockNum: %d]\n",gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->FTLBadBlockNum );
+			ND_TRACE( "[NAND        ] [Blk:");
+			for ( i = 0; i < gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->FTLBadBlockNum; ++i )
+				ND_TRACE( "%d ", ( gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->FTLBadBlock[i] & 0x0000FFFF));
+			ND_TRACE("]\n");
+			#endif
+
+		    if ( res != SUCCESS )
+				ND_TRACE("\n[NAND        ] [NAND_Init_Error:0x%x]\n", res );
+
+		#endif
+	    
+		#ifdef NU_FILE_INCLUDE
+		TC_Deallocate_Memory(pointer);
+		#endif
+    
+	    if ( res != SUCCESS )
+		    return ERR_NAND_INIT_FAILED;
+		    //return res; //original
+    
+	    TNFTL_AREAGetTotalSecAndCHS( gNAND_DrvInfo[nDrvNo].NFTLDrvInfo,
+								     &gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->PriPartition,
+								     (U32 *)&gNAND_DrvInfo[nDrvNo].TotalDiskSector,
+								     &gNAND_DrvInfo[nDrvNo].Cylinder,
+								     &gNAND_DrvInfo[nDrvNo].Head,
+								     &gNAND_DrvInfo[nDrvNo].Sector );
+    
+	    gNAND_DrvInfo[nDrvNo].DrvStatus = ENABLE;
+	}
+	else
+	{
+		#ifdef NAND_LBA_INCLUDE
+
+		gNAND_DrvInfo[nDrvNo].DrvStatus = DISABLE;
+		
+		if ( gNAND_SetFlagOfChangeAreaSize == DISABLE )
+			gLBA_DevInfo->LBAInfo.FlagOfChangeTotalSectorSize = DISABLE;
+		else
+			gLBA_DevInfo->LBAInfo.FlagOfChangeTotalSectorSize = ENABLE;
+
+		res = NAND_IO_LBA_Init( gLBA_DevInfo );
+		if ( res != SUCCESS )
+			return ERR_NAND_INIT_FAILED;
+
+		NAND_IO_LBA_GetTotalSecAndCHS( gLBA_DevInfo,
+									   NAND_LBA_DATA_AREA,
+									   (U32)&gNAND_DrvInfo[nDrvNo].TotalDiskSector,
+									   &gNAND_DrvInfo[nDrvNo].Cylinder,
+									   &gNAND_DrvInfo[nDrvNo].Head,
+									   &gNAND_DrvInfo[nDrvNo].Sector );
+
+		gNAND_DrvInfo[nDrvNo].DrvStatus = ENABLE;
+		#endif
+	}
+
+	return (NAND_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	int				NAND_ReadSector
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+int NAND_ReadSector( int nDrvNo, U32 LBA, U32 nSecSize, void* nReadBuffer )
+{
+	#ifdef NAND_INCLUDE
+	TNFTL_ERROR		res = SUCCESS;
+
+		//=================[ For DEBUG ]================================================
+		#ifdef NAND_DRV_UART_MEASURE
+		unsigned long int	count;
+		HwTCNT4 = 0;
+		#endif
+		#ifdef NAND_DRV_UART_DEBUG
+		if ( gNAND_UARTDebugFlag == ENABLE )
+			PRINTF( "\n\nNAND_ReadSector( %08d, %08d ) -------------------------- ", LBA, nSecSize );
+		#endif
+
+		#ifdef NAND_DRV_UART_DEBUG
+			#if defined(USE_V_ADDRESS)
+				#if defined(_WINCE_)
+				if ( gNAND_UARTDebugFlag == ENABLE )
+				RETAILMSG(1,(TEXT( "\n\nNAND_ReadSector( %08d, %08d ) -------------------------- "), LBA, nSecSize ));
+				#endif
+			#endif
+		#endif
+		//==============================================================================
+		
+		if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+		{
+	        res = TNFTL_AREAReadSector( gNAND_DrvInfo[nDrvNo].NFTLDrvInfo,
+								        &gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->PriPartition,
+								        LBA, nSecSize, nReadBuffer );
+		}
+		else
+		{
+			#ifdef NAND_LBA_INCLUDE
+			res = NAND_IO_LBA_ReadSector( gLBA_DevInfo,
+										  NAND_LBA_DATA_AREA, 
+										  LBA, nSecSize, nReadBuffer);
+			#endif
+		}
+
+		//=================[ For DEBUG ]================================================
+		#ifdef NAND_DRV_UART_MEASURE
+		count = HwTCNT4;
+		PRINTF( "\n[NAND_READ Sector %08d - %05d ] ( %d uS ) -------------------------- ",
+		LBA,
+		nSecSize,
+		(count*267)/100);
+		#endif
+		//==============================================================================		
+
+	if ( res != SUCCESS )
+	{
+		#ifdef NAND_DRV_UART_DEBUG
+		if ( gNAND_UARTDebugFlag == ENABLE )
+			PRINTF( " FAIL %08X", res );
+		#endif
+
+		return -1;
+	}
+
+	return 0;
+	#else
+	return NOT_SUPPORT_NAND;
+	#endif
+}	
+
+/******************************************************************************
+*
+*	int				NAND_WriteSector
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+int NAND_WriteSector( int nDrvNo, U32 LBA, U32 nSecSize, void* nWriteBuffer )
+{
+	#ifdef NAND_INCLUDE
+	TNFTL_ERROR		res = SUCCESS;
+	
+		//=================[ For DEBUG ]================================================
+		#ifdef NAND_DRV_UART_MEASURE
+		unsigned long int	count;
+		HwTCNT4 = 0;
+		#endif
+		#ifdef NAND_DRV_UART_DEBUG
+		if ( gNAND_UARTDebugFlag == ENABLE )
+			PRINTF( "\n\nNAND_WriteSector( %08d, %08d ) -----------------------------------", LBA, nSecSize );
+		#endif
+
+		#ifdef NAND_DRV_UART_DEBUG
+			#if defined(USE_V_ADDRESS)
+				#if defined(_WINCE_)
+				if ( gNAND_UARTDebugFlag == ENABLE )			
+				RETAILMSG(1,(TEXT( "\n\nNAND_WriteSector( %08d, %08d ) -------------------------- "), LBA, nSecSize ));
+				#endif
+			#endif
+		#endif
+
+		//==============================================================================
+		if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+		{
+	        res = TNFTL_AREAWriteSector( gNAND_DrvInfo[nDrvNo].NFTLDrvInfo,
+								         &gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->PriPartition,
+								         LBA, nSecSize, nWriteBuffer );
+		}
+		else
+		{
+			#ifdef NAND_LBA_INCLUDE
+			res = NAND_IO_LBA_WriteSector( gLBA_DevInfo,
+										  NAND_LBA_DATA_AREA, 
+										  LBA, nSecSize, nWriteBuffer );
+			#endif
+		}
+			
+		//=================[ For DEBUG ]================================================
+		#ifdef NAND_DRV_UART_MEASURE
+		count = HwTCNT4;
+		PRINTF( "\n[NAND_WRITE Sector %08d - %05d ] ( %d uS ) -------------------------- ",
+		LBA,
+		nSecSize,
+		(count*267)/100);
+		#endif
+		//==============================================================================
+
+	if ( res != SUCCESS )
+	{
+		#ifdef NAND_DRV_UART_DEBUG
+		if ( gNAND_UARTDebugFlag == ENABLE )
+			PRINTF( "\nFAIL : %08X ", res );
+		#endif
+
+		return -1;
+	}	
+
+	return 0;
+	#else
+	return NOT_SUPPORT_NAND;
+	#endif
+}	
+
+/******************************************************************************
+*
+*	int				NAND_HDReadSector
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+int NAND_HDReadSector( int nDrvNo, U32 LBA, U32 nSecSize, void* nReadBuffer )
+{
+	#ifdef NAND_INCLUDE
+	TNFTL_ERROR		res = SUCCESS;
+		
+	if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+	{
+	    #if defined(_LINUX_) || defined(_WINCE_)
+		res = TNFTL_AREAReadSector( gNAND_DrvInfo[0].NFTLDrvInfo,
+									&gNAND_DrvInfo[0].NFTLDrvInfo->ExtPartition[nDrvNo + 1],
+									LBA, nSecSize, nReadBuffer );
+		#else
+	    res = TNFTL_AREAReadSector( gNAND_DrvInfo[nDrvNo].NFTLDrvInfo,
+								    &gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->ExtPartition[1],
+								    LBA, nSecSize, nReadBuffer );
+		#endif
+	}
+	else
+	{
+		#ifdef NAND_LBA_INCLUDE
+	
+		res = NAND_IO_LBA_ReadSector( gLBA_DevInfo,
+									  NAND_LBA_MULTI_HIDDEN_AREA_0, 
+									  LBA, nSecSize, nReadBuffer);
+		#endif
+	}
+
+	if ( res != SUCCESS )
+	{
+		#ifdef NAND_DRV_UART_DEBUG
+		if ( gNAND_UARTDebugFlag == ENABLE )
+			PRINTF( " FAIL %08X", res );
+		#endif
+
+		return -1;
+	}
+
+	return 0;
+	#else
+	return NOT_SUPPORT_NAND;
+	#endif
+}	
+
+/******************************************************************************
+*
+*	int				NAND_HDWriteSector
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+int NAND_HDWriteSector( int nDrvNo, U32 LBA, U32 nSecSize, void* nWriteBuffer )
+{
+	#ifdef NAND_INCLUDE
+	TNFTL_ERROR		res = SUCCESS;
+
+	if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+	{
+		#if defined(_LINUX_) || defined(_WINCE_)
+		res = TNFTL_AREAWriteSector( gNAND_DrvInfo[0].NFTLDrvInfo,
+									 &gNAND_DrvInfo[0].NFTLDrvInfo->ExtPartition[nDrvNo+1],
+									 LBA, nSecSize, nWriteBuffer );
+		#else
+	    res = TNFTL_AREAWriteSector( gNAND_DrvInfo[nDrvNo].NFTLDrvInfo,
+								     &gNAND_DrvInfo[nDrvNo].NFTLDrvInfo->ExtPartition[1],
+								     LBA, nSecSize, nWriteBuffer );
+		#endif
+	}
+	else
+	{
+		#ifdef NAND_LBA_INCLUDE	
+		res = NAND_IO_LBA_WriteSector( gLBA_DevInfo,
+									  NAND_LBA_MULTI_HIDDEN_AREA_0, 
+									  LBA, nSecSize, nWriteBuffer );
+		#endif
+	}
+
+	if ( res != SUCCESS )
+	{
+		#ifdef NAND_DRV_UART_DEBUG
+		if ( gNAND_UARTDebugFlag == ENABLE )
+			PRINTF( "\nFAIL : %08X ", res );
+		#endif
+
+		return -1;
+	}	
+
+	return 0;
+	#else
+	return NOT_SUPPORT_NAND;
+	#endif
+}	
+
+/******************************************************************************
+*
+*	int				NAND_HDReadPage
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+int NAND_HDReadPage( U32 nHDPageAddr, U32 nPageSize, void* nReadBuffer )
+{
+	#ifdef NAND_INCLUDE
+	TNFTL_ERROR		res = SUCCESS;
+
+		//=================[ For DEBUG ]================================================
+		#ifdef NAND_DRV_UART_MEASURE
+		unsigned long int	count;
+		HwTCNT4 = 0;
+		#endif
+		#ifdef NAND_DRV_UART_DEBUG
+		if ( gNAND_UARTDebugFlag == ENABLE )
+			PRINTF( "\n\nNAND_HDReadPage( %08d, %08d ) -----", nHDPageAddr, nPageSize );
+		#endif
+		//==============================================================================
+
+		if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+		{
+	        res = TNFTL_AREAReadSector( gNAND_DrvInfo[0].NFTLDrvInfo,
+								        &gNAND_DrvInfo[0].NFTLDrvInfo->ExtPartition[0],
+								        nHDPageAddr, nPageSize, nReadBuffer );
+		}
+		else
+		{
+			#ifdef NAND_LBA_INCLUDE
+			res = NAND_IO_LBA_ReadSector( gLBA_DevInfo,
+										  NAND_LBA_HIDDEN_AREA, 
+										  nHDPageAddr, nPageSize, nReadBuffer );
+			#endif
+		}
+
+		//=================[ For DEBUG ]================================================
+		#ifdef NAND_DRV_UART_MEASURE
+		count = HwTCNT4;
+		PRINTF( "\n[NAND_HDReadPage %08d - %05d ] ( %d uS ) ---- ",
+		LBA,
+		nSecSize,
+		(count*267)/100);
+		#endif
+		//==============================================================================
+
+	if ( res != SUCCESS )
+	{
+		#ifdef NAND_DRV_UART_DEBUG
+		if ( gNAND_UARTDebugFlag == ENABLE )
+			PRINTF( "\nFAIL : %08X ", res );
+		#endif
+
+		return -1;
+	}
+
+	return 0;
+	#else
+	return NOT_SUPPORT_NAND;
+	#endif
+}
+
+/******************************************************************************
+*
+*	int				NAND_HDWritePage
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+int NAND_HDWritePage( U32 nHDPageAddr, U32 nPageSize, void* nWriteBuffer )
+{
+	#ifdef NAND_INCLUDE
+	TNFTL_ERROR		res = SUCCESS;
+	
+		//=================[ For DEBUG ]================================================
+		#ifdef NAND_DRV_UART_MEASURE
+		unsigned long int	count;
+		HwTCNT4 = 0;
+		#endif
+		#ifdef NAND_DRV_UART_DEBUG
+		if ( gNAND_UARTDebugFlag == ENABLE )
+			PRINTF( "\n\nNAND_HDWritePage( %08d, %08d ) ----", nHDPageAddr, nPageSize );
+		#endif
+		//==============================================================================
+
+		if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+		{
+	        res = TNFTL_AREAWriteSector( gNAND_DrvInfo[0].NFTLDrvInfo, 
+								         &gNAND_DrvInfo[0].NFTLDrvInfo->ExtPartition[0],
+								         nHDPageAddr, nPageSize, nWriteBuffer );
+		}
+		else
+		{
+			#ifdef NAND_LBA_INCLUDE
+			res = NAND_IO_LBA_WriteSector( gLBA_DevInfo,
+										  NAND_LBA_HIDDEN_AREA, 
+										  nHDPageAddr, nPageSize, nWriteBuffer );
+			#endif
+		}
+
+		//=================[ For DEBUG ]================================================
+		#ifdef NAND_DRV_UART_MEASURE
+		count = HwTCNT4;
+		PRINTF( "\n[NAND_HDWritePage %08d - %05d ] ( %d uS ) ---- ",
+		LBA,
+		nSecSize,
+		(count*267)/100);
+		#endif
+		//==============================================================================
+
+	if ( res != SUCCESS )
+	{
+		#ifdef NAND_DRV_UART_DEBUG
+		if ( gNAND_UARTDebugFlag == ENABLE )
+			PRINTF( "\nFAIL : %08X ", res );
+		#endif
+	
+		return -1;
+	}
+
+	return 0;
+	#else
+	return NOT_SUPPORT_NAND;
+	#endif
+}	
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      int NAND_PhyReadPage( U32 nBlkAddr, U16 nPageAddr, U16 nCSorder, void* nReadBuffer );
+*  
+*  DESCRIPTION : 
+*  
+*  INPUT:
+*			nBlkAddr	= 
+*			nCSorder	= 
+*			nPageAddr	= 
+*			nReadBuffer	= 
+*  
+*  OUTPUT:	int - Return Type
+*  			= 
+*  
+*  REMARK:	  by nemo
+**************************************************************************/
+int NAND_PhyReadPage( U32 nBlkAddr, U16 nPageAddr, U16 nCSorder, void* nReadBuffer )
+{
+	TNFTL_ERROR		res = SUCCESS;
+	#if defined(NAND_INCLUDE)
+
+	#ifdef NAND_DRV_UART_DEBUG
+	if ( gNAND_UARTDebugFlag == ENABLE )
+		PRINTF( "\nNAND_PhyReadPage( %08d, %08d ) ----", nBlkAddr, nPageAddr );
+	#endif
+
+	res = TNFTL_IOReadPhyPage( gNAND_DrvInfo[0].NFTLDrvInfo,
+							   nBlkAddr, nPageAddr,
+							   nCSorder, nReadBuffer );	
+	if ( res != SUCCESS )
+	{
+		#ifdef NAND_DRV_UART_DEBUG
+		if ( gNAND_UARTDebugFlag == ENABLE )
+			PRINTF( "\nFAIL : %08X ", res );
+		#endif
+	
+		return -1;
+	}
+	#endif
+
+	return 0;
+}
+
+int NAND_MTD_Init( U32* rMTDStBlk, U32* rMTDEdBlk )
+{  
+	unsigned int 		i;
+	unsigned int		nBlockPageAddr;
+	unsigned int		nMTDStBlk, nMTDEdBlk;
+	NAND_IO_DEVINFO		sDevInfo;
+	NAND_IO_DEVINFO 	*nDevInfo;
+
+	NAND_IO_GetDeviceInfo( 0, &sDevInfo);
+	nDevInfo = &sDevInfo;
+
+	if ( gNAND_DrvInfo[0].NFTLDrvInfo->IoStatus == DISABLE )
+		return -1;	
+
+	nMTDStBlk = gNAND_DrvInfo[0].NFTLDrvInfo->NBArea.EdPBAddr - gNAND_DrvInfo[0].NFTLDrvInfo->ROAreaBlkNum;
+	nMTDEdBlk = gNAND_DrvInfo[0].NFTLDrvInfo->NBArea.EdPBAddr;
+
+	for ( i = nMTDStBlk; i < nMTDEdBlk; ++i )
+	{
+		nBlockPageAddr = i << nDevInfo->ShiftPpB;
+
+		NAND_IO_EraseBlock( nDevInfo, nBlockPageAddr, INTER_LEAVE_OFF );
+	}
+	
+	*rMTDStBlk = nMTDStBlk;
+	*rMTDEdBlk = nMTDEdBlk;
+
+	return 0;
+}
+
+int NAND_MTD_WritePage( U32 nPageAddr, U8* nPageBuffer )
+{
+	unsigned char	*nSpareBuffer;
+	NAND_IO_DEVINFO *nDevInfo;
+	NAND_IO_ERROR	res;
+
+	nDevInfo = &gNAND_DrvInfo[0].NFTLDrvInfo->MediaDevInfo[0];
+
+	nSpareBuffer = (unsigned char *)nPageBuffer;
+	nSpareBuffer += 2048;
+	
+	res = NAND_IO_WritePageMTD( nDevInfo, 
+							  nPageAddr, 0, 4/*nDevInfo->PPages*/, 
+							  nPageBuffer,
+							  nSpareBuffer, ECC_ON );
+	return res;
+}
+
+int NAND_MTD_ReadPage( U32 nPageAddr, U8* nPageBuffer )
+{
+	unsigned char	*nSpareBuffer;
+	NAND_IO_DEVINFO *nDevInfo;
+	NAND_IO_ERROR	res;
+	
+	nDevInfo = &gNAND_DrvInfo[0].NFTLDrvInfo->MediaDevInfo[0];
+
+	nSpareBuffer = (unsigned char *)nPageBuffer;
+	nSpareBuffer += 2048;
+
+	res = NAND_IO_ReadPageMTD( nDevInfo, 
+							  nPageAddr, 0, 4/*nDevInfo->PPages*/,
+							  nPageBuffer,
+							  nSpareBuffer, ECC_ON );
+	return res;	
+}
+
+
+/******************************************************************************
+*
+*	int				NAND_Ioctl
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+int NAND_Ioctl( int function, void *param )
+{
+	#if defined(_LINUX_) || defined(_WINCE_) || defined (NAND_LBA_INCLUDE)
+	unsigned int	 i = 0;
+	#endif
+
+	switch( function )
+	{
+		case	DEV_INITIALIZE:
+			{
+				NAND_Init();
+					
+				#if defined(_LINUX_) || defined(_WINCE_)
+				if ( gNAND_PartitionInfoLoadFlag == DISABLE )
+					NAND_InitExtPartitionInfo();
+				else
+					TNFTL_SetExtendedPartitionNums( NAND_DRV_0, (U16)gTNFTL_ExtPartitionInfo[NAND_DRV_0].ExtendedPartitionNum );
+				#else
+				NAND_InitExtPartitionInfo();
+				#endif
+
+				if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+				{
+					for ( i = 0; i < gTNFTL_ExtPartitionInfo[NAND_DRV_0].ExtendedPartitionNum; ++i )
+					{
+						TNFTL_AREASetTotalSectorSize( gNAND_DrvInfo[0].NFTLDrvInfo,
+													  &gNAND_DrvInfo[0].NFTLDrvInfo->ExtPartition[i],
+													  gTNFTL_ExtPartitionInfo[NAND_DRV_0].ExtPartitionSize[i] );
+					}
+
+				    gNAND_DrvInfo[0].DrvStatus = DISABLE;
+
+				    if ( NAND_InitDrive(0) != SUCCESS )
+					    return EINITFAIL;
+    
+				    TNFTL_AREAGetTotalSecAndCHS( gNAND_DrvInfo[0].NFTLDrvInfo,
+								 			     &gNAND_DrvInfo[0].NFTLDrvInfo->PriPartition,
+								 			     (U32 *)&gNAND_DrvInfo[0].TotalDiskSector,
+								 			     &gNAND_DrvInfo[0].Cylinder,
+								 			     &gNAND_DrvInfo[0].Head,
+								 			     &gNAND_DrvInfo[0].Sector );
+    
+				    gNAND_DrvInfo[0].DrvStatus = ENABLE;
+				}
+				else
+				{
+					#ifdef NAND_LBA_INCLUDE
+				
+					#ifdef BRWS_STR_NAND_INCLUDE
+					gLBA_DevInfo->LBAInfo.HDAreaSectorSize = ( gTNFTL_HiddenInfo[NAND_DRV_0].HiddenPageSize
+																						  + BRWS_NAME_AREA_SIZE
+																						#ifndef NU_FILE_INCLUDE
+																						#ifdef AUDIOUI_INCLUDE
+																						  + AUI_HD_OCCPAGE
+																						#endif
+																						#endif
+																						);
+					#else
+					gLBA_DevInfo->LBAInfo.HDAreaSectorSize = ( gTNFTL_HiddenInfo[NAND_DRV_0].HiddenPageSize
+																						#ifndef NU_FILE_INCLUDE
+																						#ifdef AUDIOUI_INCLUDE
+																						  + AUI_HD_OCCPAGE
+																						#endif
+																						#endif
+																						);
+					#endif
+					
+					gLBA_DevInfo->LBAInfo.MHDAreaNums = TNFTL_MULTI_HIDDEN_AREA_NUM;			
+					
+					#ifdef INTERNAL_HIDDEN_STORAGE_INCLUDE					
+					for ( i = 0; i < TNFTL_MULTI_HIDDEN_AREA_NUM; ++i )
+						gLBA_DevInfo->LBAInfo.MHDAreaSectorSize[i] = gTNFTL_HiddenInfo[NAND_DRV_0].MultiHiddenSize[i];
+					#endif
+					
+					gNAND_DrvInfo[0].DrvStatus = DISABLE;
+					
+					if ( NAND_InitDrive(0) != SUCCESS )
+						return EINITFAIL;
+					
+					gNAND_DrvInfo[0].DrvStatus = ENABLE;
+					#endif
+				}					
+			}
+			break;
+			
+		case	DEV_GET_DISKINFO:
+			{
+				ioctl_diskinfo_t	*info = (ioctl_diskinfo_t *) param;
+
+				#ifdef NU_FILE_INCLUDE
+				gFormatType	= TC_LOWLEVEL_NO;
+				#endif
+				info->cylinder		= gNAND_DrvInfo[0].Cylinder;
+				info->head			= gNAND_DrvInfo[0].Head;
+				info->sector		= gNAND_DrvInfo[0].Sector;
+				info->sector_size	= 512;
+				info->Total_sectors	= gNAND_DrvInfo[0].TotalDiskSector;				
+			}
+			break;
+			
+		case	DEV_FORMAT_DISK:
+			{
+				unsigned short	mode = *((unsigned short *)param);
+
+				#ifdef NU_FILE_INCLUDE
+				gFormatType	= TC_LOWLEVEL_NO;
+				#endif
+
+				if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+				{
+				    TNFTL_AREAFormat( gNAND_DrvInfo[0].NFTLDrvInfo,
+								      &gNAND_DrvInfo[0].NFTLDrvInfo->PriPartition,
+								      mode );
+				}
+				#ifdef NAND_LBA_INCLUDE
+				else
+				{
+				//	NAND_IO_LBA_AREAClear( gLBA_DevInfo, NAND_LBA_DATA_AREA );
+				}
+				#endif
+
+				return NAND_InitDrive(0);
+			}
+			break;
+			
+		case	DEV_ERASE_INIT:
+			{
+				ioctl_diskeraseinit_t	*erase = (ioctl_diskeraseinit_t *) param;
+				erase = erase;
+			}
+			break;
+			
+		case	DEV_ERASE_BLOCK:
+			{
+				ioctl_diskerase_t	*erase = (ioctl_diskerase_t *) param;
+				erase = erase;				
+			}
+			break;
+			
+		case	DEV_WRITEBACK_ON_IDLE:
+			{
+
+			}
+			break;
+			
+		case	DEV_ERASE_CLOSE:
+			{
+
+			}
+			break;
+			
+		case	DEV_HIDDEN_READ_PAGE_4:
+			{
+				ioctl_diskhdread4_t	*hd_r = (ioctl_diskhdread4_t *) param;
+
+				if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+				{
+				    TNFTL_AREAReadSectorBy4Byte( gNAND_DrvInfo[0].NFTLDrvInfo,
+											     &gNAND_DrvInfo[0].NFTLDrvInfo->ExtPartition[0],
+												 (U32)hd_r->start_page,
+												 (U16)hd_r->page_offset,
+												 (U16)hd_r->read_size,
+											     hd_r->buff );
+			    }
+				else
+				{
+					#ifdef NAND_LBA_INCLUDE
+					NAND_IO_LBA_ReadSectorBy4Byte( gLBA_DevInfo,
+												   NAND_LBA_VFP,
+												   (U32)hd_r->start_page,
+												   (U16)hd_r->page_offset,
+												   (U16)hd_r->read_size,
+												   hd_r->buff );
+					#endif
+				}
+
+			}
+			break;
+		case	DEV_SET_POWER:
+			{
+				#ifdef NAND_LBA_INCLUDE			
+				unsigned short	mode = *((unsigned short *)param);
+				#endif
+				
+				if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+				{
+					// NOP
+				}
+				else
+				{
+					#ifdef NAND_LBA_INCLUDE
+
+					if ( mode == DISK_STATE_STANDBY )
+					{
+						NAND_IO_LBA_PowerSaveMode( gLBA_DevInfo, DISABLE );
+					}
+					else if ( mode == DISK_STATE_IDLE )
+					{
+						NAND_IO_LBA_PowerSaveMode( gLBA_DevInfo, ENABLE );						
+					}
+					#endif
+				}					
+			}
+			break;
+		case	DEV_GET_MAX_SECTOR_PER_BLOCK:
+			{
+				unsigned short *value = (unsigned short *)param;
+				if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+				{
+				    if ( gNAND_DrvInfo[0].DrvStatus == ENABLE )
+					    *value = ( gNAND_DrvInfo[0].NFTLDrvInfo->PpB << gNAND_DrvInfo[0].NFTLDrvInfo->ShiftPPages );
+				    else
+					    *value = TNFTL_MAX_SUPPORT_NAND_IO_SECTOR_SIZE_PER_1PAGE;
+				}
+				else
+				{
+					*value = 2048; // PpB: 128 *  PPage: 16
+				}
+			}
+			break;
+
+		case	DEV_TELL_DATASTARTSECTOR:
+			{
+				if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+				{
+				    TNFTL_WCacheSetDataStartSector( gNAND_DrvInfo[0].NFTLDrvInfo,
+												    &gNAND_DrvInfo[0].NFTLDrvInfo->PriPartition,
+												    *(unsigned int*)param );
+				}
+				
+				break;
+			}
+
+		case	DEV_CHECK_CRC_NANDBOOT_IMAGE_ROM:
+#ifdef TODO_NEMO		/* 09.04.13 */
+		#if defined (BOOTCRCCHEK)
+			{
+				BootCRC *pbootcrc;
+
+				pbootcrc = (BootCRC*)param;
+				if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+				{
+					return TNFTL_NBGetCRCValueOfImageFile(gNAND_DrvInfo[0].NFTLDrvInfo, &pbootcrc->crc128kchk, &pbootcrc->crcfullchk, &pbootcrc->bootfilesize);
+				}
+				else
+					return 0;
+			}
+		#else
+			{
+				unsigned int	nOrgCRCcode1;
+				unsigned int	nOrgCRCcode2;
+				unsigned int	nRomFileSize;
+				unsigned int	rRstCRCcode1;
+				unsigned int	rRstCRCcode2;
+		
+				if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+				{
+				    return TNFTL_NBGetCRCOfImageFile( gNAND_DrvInfo[0].NFTLDrvInfo, 1,
+												      &nOrgCRCcode1, &nOrgCRCcode2, &nRomFileSize,
+												      &rRstCRCcode1, &rRstCRCcode2 );
+			}
+				else
+					return 0;
+		 	}
+		#endif
+#endif /* TODO_NEMO */
+			break;
+		#ifdef TNFTL_V4_INCLUDE
+		case	DEV_FORCE_FLUSH_CACHE_DATA:
+			{
+				return 	TNFTL_WCacheFourceFlushCache_DATA( gNAND_DrvInfo[0].NFTLDrvInfo,
+											 		 	   &gNAND_DrvInfo[0].NFTLDrvInfo->PriPartition );				
+			}
+			break;
+		#endif
+		#if defined( TNFTL_V5_INCLUDE ) || defined(TNFTL_V6_INCLUDE)
+		case	DEV_SET_ALIGEN_CACHE:
+			{
+				unsigned short	mode = *((unsigned short *)param);
+				return TNFTL_SetUseAlignCacheMode( gNAND_DrvInfo[0].NFTLDrvInfo, mode );
+			}
+			break;
+		#endif
+		case	DEV_GET_WRITE_PROTECT:
+			return  0;
+			break;
+		case	DEV_GET_INSERTED:
+			return 1;
+		#ifdef NU_FILE_INCLUDE
+		case	DEV_GET_HIDDEN_SIZE:
+			if (gNAND_DrvInfo[0].DrvStatus == ENABLE)
+				*(int *)param	= NAND_HIDDEN_DEFAULT_TOTAL_PAGESIZE;
+			else
+				*(int *)param	= -1;
+			break;
+        #endif
+		case	DEV_GET_INITED:
+			return 1;
+		case DEV_GET_PLAYABLE_STATUS:
+			return 1;			
+		default:
+			return	ENOTSUPPORT;
+	}
+	#endif
+	return 0;	/* SUCCESS */
+}
+
+/******************************************************************************
+*
+*	int				NAND_HDIoctl
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+int NAND_HDIoctl( int function, void *param )
+{
+	#if defined(_LINUX_) || defined(_WINCE_)
+	unsigned int	 i;
+	#endif
+
+	switch( function )
+	{
+		case	DEV_INITIALIZE:
+			{
+				NAND_Init();
+				
+				#if defined(_LINUX_) || defined(_WINCE_)
+				if ( gNAND_PartitionInfoLoadFlag == DISABLE )
+					NAND_InitExtPartitionInfo();
+				else
+					TNFTL_SetExtendedPartitionNums( NAND_DRV_0, (U16)gTNFTL_ExtPartitionInfo[NAND_DRV_0].ExtendedPartitionNum );
+				#endif
+
+
+				for ( i = 0; i < gTNFTL_ExtPartitionInfo[NAND_DRV_0].ExtendedPartitionNum; ++i )
+				{
+					TNFTL_AREASetTotalSectorSize( gNAND_DrvInfo[0].NFTLDrvInfo,
+												  &gNAND_DrvInfo[0].NFTLDrvInfo->ExtPartition[i],
+												  gTNFTL_ExtPartitionInfo[NAND_DRV_0].ExtPartitionSize[i] );
+				}
+
+				gNAND_DrvInfo[0].NFTLDrvInfo->ExtPartition[1].DrvStatus = DISABLE;
+				
+				if ( NAND_InitDrive(0) != SUCCESS )
+					return EINITFAIL;
+
+				TNFTL_AREAGetTotalSecAndCHS( gNAND_DrvInfo[0].NFTLDrvInfo,
+								 			 &gNAND_DrvInfo[0].NFTLDrvInfo->ExtPartition[1],
+								 			 (U32 *)&gNAND_DrvInfo[0].NFTLDrvInfo->ExtPartition[1].TotalDiskSector,
+								 			 &gNAND_DrvInfo[0].NFTLDrvInfo->ExtPartition[1].Cylinder,
+								 			 &gNAND_DrvInfo[0].NFTLDrvInfo->ExtPartition[1].Head,
+								 			 &gNAND_DrvInfo[0].NFTLDrvInfo->ExtPartition[1].Sector );
+
+				gNAND_DrvInfo[0].NFTLDrvInfo->ExtPartition[1].DrvStatus = ENABLE;
+			}
+			break;
+			
+		case	DEV_GET_DISKINFO:
+			{
+				ioctl_diskinfo_t	*info = (ioctl_diskinfo_t *) param;
+
+				info->cylinder		= gNAND_DrvInfo[0].NFTLDrvInfo->ExtPartition[1].Cylinder;
+				info->head			= gNAND_DrvInfo[0].NFTLDrvInfo->ExtPartition[1].Head;
+				info->sector		= gNAND_DrvInfo[0].NFTLDrvInfo->ExtPartition[1].Sector;
+				info->sector_size	= 512;
+			}
+			break;
+			
+		case	DEV_FORMAT_DISK:
+			{
+				unsigned short	mode = *((unsigned short *)param);
+
+				TNFTL_AREAFormat( gNAND_DrvInfo[0].NFTLDrvInfo,
+								  &gNAND_DrvInfo[0].NFTLDrvInfo->ExtPartition[1],
+								  mode );
+
+				return NAND_InitDrive(0);
+			}
+			break;
+			
+		case	DEV_ERASE_INIT:
+			{
+				ioctl_diskeraseinit_t	*erase = (ioctl_diskeraseinit_t *) param;
+				erase = erase;
+			}
+			break;
+			
+		case	DEV_ERASE_BLOCK:
+			{
+				ioctl_diskerase_t	*erase = (ioctl_diskerase_t *) param;
+				erase = erase;				
+			}
+			break;
+			
+		case	DEV_WRITEBACK_ON_IDLE:
+			{
+
+			}
+			break;
+			
+		case	DEV_ERASE_CLOSE:
+			{
+
+			}
+			break;
+			
+		case	DEV_HIDDEN_READ_PAGE_4:
+			{
+
+			}
+			break;
+
+		case	DEV_GET_MAX_SECTOR_PER_BLOCK:
+			{
+				unsigned short *value = (unsigned short *)param;
+
+				if ( gNAND_DrvInfo[0].NFTLDrvInfo->ExtPartition[1].DrvStatus == ENABLE )
+				{
+					if ( gNAND_DrvInfo[0].NFTLDrvInfo->ExtPartition[1].TotalDiskSector >
+					    (U32)( gNAND_DrvInfo[0].NFTLDrvInfo->PpB << gNAND_DrvInfo[0].NFTLDrvInfo->ShiftPPages ) * 2 )
+						*value = ( gNAND_DrvInfo[0].NFTLDrvInfo->PpB << gNAND_DrvInfo[0].NFTLDrvInfo->ShiftPPages );
+					else
+						*value = TNFTL_MAX_SUPPORT_NAND_IO_SECTOR_SIZE_PER_1PAGE;
+				}
+				else
+					*value = TNFTL_MAX_SUPPORT_NAND_IO_SECTOR_SIZE_PER_1PAGE;
+			}
+			break;
+
+		case	DEV_TELL_DATASTARTSECTOR:
+			{
+				TNFTL_WCacheSetDataStartSector( gNAND_DrvInfo[0].NFTLDrvInfo,
+												&gNAND_DrvInfo[0].NFTLDrvInfo->ExtPartition[1],
+												*(unsigned int*)param );
+				break;
+			}
+
+		case	DEV_GET_WRITE_PROTECT:
+			return  0;
+			break;
+		case	DEV_GET_INSERTED:
+			return 1;
+		case	DEV_GET_INITED:
+			return 1;
+		case DEV_GET_PLAYABLE_STATUS:
+			return 1;			
+		default:
+			return	ENOTSUPPORT;
+	}
+	
+	return 0;	/* SUCCESS */
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      int NAND_ReadMultiSectorStart( U32 LBA, U16 nSecSize );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			LBA	= 
+*			nSecSize	= 
+*  
+*  OUTPUT:	int - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+int NAND_ReadMultiSectorStart( U32 LBA, U32 nSecSize )
+{
+	#ifdef NAND_INCLUDE
+	LBA = 0;
+	nSecSize = 0;
+	return 0;
+	#else
+	return NOT_SUPPORT_NAND;
+	#endif
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      int NAND_ReadMultiSectorStop( void );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			None
+*  
+*  OUTPUT:	int - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+int NAND_ReadMultiSectorStop( void )
+{
+	#ifdef NAND_INCLUDE
+	return 0;
+	#else
+	return NOT_SUPPORT_NAND;
+	#endif
+}	
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      int NAND_WriteMultiSectorStart( U32 LBA, U16 nSecSize );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			LBA	= 
+*			nSecSize	= 
+*  
+*  OUTPUT:	int - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+int NAND_WriteMultiSectorStart( U32 LBA, U32 nSecSize )
+{
+	#ifdef NAND_INCLUDE
+	LBA = 0;
+	nSecSize = 0;
+	return 0;
+	#else
+	return NOT_SUPPORT_NAND;
+	#endif
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      int NAND_WriteMultiSectorStop( void );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			None
+*  
+*  OUTPUT:	int - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+int NAND_WriteMultiSectorStop( void )
+{
+	#ifdef NAND_INCLUDE
+	return 0;
+	#else
+	return NOT_SUPPORT_NAND;
+	#endif
+}	
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      int NAND_HDClearPages( U32 nHDStPageAddr, U32 nHDEdPageAddr );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nHDEdPageAddr	= 
+*			nHDStPageAddr	= 
+*  
+*  OUTPUT:	int - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+int NAND_HDClearPages( U32 nHDStPageAddr, U32 nHDEdPageAddr )
+{
+	#ifdef NAND_INCLUDE
+	nHDStPageAddr = 0;
+	nHDEdPageAddr = 0;
+	return 0;
+	#else
+	return NOT_SUPPORT_NAND;
+	#endif
+}	
+
+/******************************************************************************
+*
+*	U16				NAND_GetSerialNumber
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+U16 NAND_GetSerialNumber( U8* rSerialNumber, U16 nSize )
+{
+	#ifdef NAND_INCLUDE
+	if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+		return TNFTL_GetSerialNumber( gNAND_DrvInfo[0].NFTLDrvInfo, rSerialNumber, nSize );
+	else
+	{
+		#ifdef NAND_LBA_INCLUDE
+		return NAND_IO_LBA_GetSerialNumber( gLBA_DevInfo, gNAND_PageBuffer, rSerialNumber, nSize );
+		#else
+		return 0;
+		#endif
+	}
+	#else
+	return 0;
+	#endif
+}
+
+/******************************************************************************
+*
+*	U16				NAND_GetUniqueID
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+U16 NAND_GetUniqueID( U8* rSerialNumber, U16 nSize )
+{
+	if ( gNAND_DrvInfo[0].NFTLDrvInfo->NANDType == NAND_TYPE_PURE_NAND )
+	{
+		#if defined(NAND_INCLUDE) && !defined(_SDRAMONLY1_)
+		unsigned int uiIDSize;
+
+		uiIDSize = ( nSize < gNAND_DrvInfo[0].NFTLDrvInfo->MediaSizeOfUniqueID ) ? nSize : gNAND_DrvInfo[0].NFTLDrvInfo->MediaSizeOfUniqueID;
+		memcpy((void*)rSerialNumber, (void*)gNAND_DrvInfo[0].NFTLDrvInfo->MediaUniqueID, uiIDSize);
+
+		return (U16)uiIDSize;
+		#else
+		return 0;
+		#endif
+	}
+	else
+		return 0;
+}
+
+/******************************************************************************
+*
+*	TNFTL_ERROR		NAND_SetUartDebug
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+TNFTL_ERROR	NAND_SetUartDebug( unsigned int on_off )
+{
+	gNAND_UARTDebugFlag = (U8)on_off;
+
+	return (TNFTL_ERROR)SUCCESS;
+}	
+
+#ifdef NU_FILE_INCLUDE
+/************************************************************************
+* FUNCTION                                                              
+*                                                                       
+*       NAND_IO_Open                                                      
+*                                                                       
+* DESCRIPTION                                                           
+*                                                                       
+*       This function prepares the NAND Flash for usage by allocating the 
+*       pages necessary for usage.                                       
+*                                                                       
+* INPUTS                                                                
+*                                                                       
+*       driveno                             The number assigned to the NAND Flash. 
+*                                                                       
+* OUTPUTS                                                               
+*                                                                       
+*       YES                                 Successful Completion.      
+*       NO                                  Couldn't allocate all of the
+*                                            pages.                     
+*                                                                       
+*************************************************************************/
+INT NAND_IO_Open(UINT16 driveno)
+{
+	NU_Obtain_Semaphore(&CAPP_SEM, NU_SUSPEND);
+	NAND_Ioctl(DEV_INITIALIZE, NULL);
+	NU_Release_Semaphore(&CAPP_SEM);
+    	return(YES);
+}
+
+#ifdef INTERNAL_HIDDEN_STORAGE_INCLUDE
+/**************************************************************************
+*  FUNCTION NAME : 
+*      INT NAND_HD_IO_Open(UINT16 driveno);
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			driveno	= 
+*  
+*  OUTPUT:	INT - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+INT NAND_HD_IO_Open(UINT16 driveno)
+{
+	NU_Obtain_Semaphore(&CAPP_SEM, NU_SUSPEND);
+	NAND_HDIoctl(DEV_INITIALIZE, NULL);
+	NU_Release_Semaphore(&CAPP_SEM);
+    	return(YES);
+}
+#endif	//INTERNAL_HIDDEN_STORAGE_INCLUDE
+
+/************************************************************************
+* FUNCTION                                                              
+*                                                                       
+*       NAND_IO_RAW_Open                                                  
+*                                                                       
+* DESCRIPTION                                                           
+*                                                                       
+*       This function doesn't do anything for the NAND Flash.  It is      
+*       included for devtable consistency.                              
+*                                                                       
+* INPUTS                                                                
+*                                                                       
+*       None.                                                           
+*                                                                       
+* OUTPUTS                                                               
+*                                                                       
+*       None.                                                           
+*                                                                       
+*************************************************************************/
+INT NAND_IO_RAW_Open(UINT16 driveno)
+{
+    return(NO);
+}
+
+#ifdef INTERNAL_HIDDEN_STORAGE_INCLUDE
+/**************************************************************************
+*  FUNCTION NAME : 
+*      INT NAND_HD_IO_RAW_Open(UINT16 driveno);
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			driveno	= 
+*  
+*  OUTPUT:	INT - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+INT NAND_HD_IO_RAW_Open(UINT16 driveno)
+{
+    return(NO);
+}
+#endif	//INTERNAL_HIDDEN_STORAGE_INCLUDE
+
+/************************************************************************
+* FUNCTION                                                              
+*                                                                       
+*       NAND_IO_Close                                                     
+*                                                                       
+* DESCRIPTION                                                           
+*                                                                       
+*       This function deallocates all of the pages associated with the  
+*       NAND Flash. The actual code here is commented out since we        
+*       probably don't want to loose the data on a close.               
+*                                                                       
+* INPUTS                                                                
+*                                                                       
+*       driveno                             The number assigned to the NAND Flash.
+*                                                                       
+* OUTPUTS                                                               
+*                                                                       
+*       YES                                 Successful Completion.      
+*       NO                                  Couldn't allocate all of the
+*                                            pages.                     
+*                                                                       
+*************************************************************************/
+INT NAND_IO_Close(UINT16 driveno) 
+{
+    return(YES);
+}
+
+#ifdef INTERNAL_HIDDEN_STORAGE_INCLUDE
+/**************************************************************************
+*  FUNCTION NAME : 
+*      INT NAND_HD_IO_Close(UINT16 driveno) ;
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			driveno	= 
+*  
+*  OUTPUT:	INT - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+INT NAND_HD_IO_Close(UINT16 driveno) 
+{
+    return(YES);
+}
+#endif	//INTERNAL_HIDDEN_STORAGE_INCLUDE
+
+/************************************************************************
+* FUNCTION                                                              
+*                                                                       
+*       NAND_IO_ReadWrite                                                        
+*                                                                       
+* DESCRIPTION                                                           
+*                                                                       
+*       This function reads or writes data from and to the NAND Flash     
+*       based on the 'reading' parameter.                               
+*                                                                       
+* INPUTS                                                                
+*                                                                       
+*       driveno                             The number assigned to the  
+*                                            RAM Disk (not used)        
+*       block                               The block number to read or 
+*                                            write                      
+*       buffer                              Pointer to the data to be   
+*                                            placed from a read or      
+*                                            stored on a write          
+*       count                               Number of bytes to be read  
+*                                            or written                 
+*       reading                             Indicates whether or not we 
+*                                            are reading or writing     
+*                                                                       
+* OUTPUTS                                                               
+*                                                                       
+*       YES                                 Successful Completion.      
+*       NO                                  Block number is out of range.
+*                                                                       
+*************************************************************************/
+INT NAND_IO_ReadWrite(UINT16 driveno, UINT32 block, VOID *buffer, UINT16 count, INT reading) 
+{
+	int result;
+
+	NU_Obtain_Semaphore(&CAPP_SEM, NU_SUSPEND);
+	
+	if(reading)
+		result = NAND_ReadSector(driveno, block, count, buffer);
+	else
+		result = NAND_WriteSector(driveno, block, count, buffer);
+
+	NU_Release_Semaphore(&CAPP_SEM);
+
+	if(!result)
+		return (YES);
+	else
+		return (NO);
+}
+
+#ifdef INTERNAL_HIDDEN_STORAGE_INCLUDE
+/**************************************************************************
+*  FUNCTION NAME : 
+*      INT NAND_HD_IO_ReadWrite(UINT16 driveno, UINT32 block, VOID *buffer, UINT16 count, INT reading) ;
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			block	= 
+*			buffer	= 
+*			count	= 
+*			driveno	= 
+*			reading	= 
+*  
+*  OUTPUT:	INT - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+INT NAND_HD_IO_ReadWrite(UINT16 driveno, UINT32 block, VOID *buffer, UINT16 count, INT reading) 
+{
+	int result;
+
+	NU_Obtain_Semaphore(&CAPP_SEM, NU_SUSPEND);
+
+	driveno	-= INTERNAL_HIDDEN_STORAGE_START_NO;
+	if(reading)
+		result = NAND_HDReadSector(driveno, block, count, buffer);
+	else
+		result = NAND_HDWriteSector(driveno, block, count, buffer);
+
+	NU_Release_Semaphore(&CAPP_SEM);
+
+	if(!result)
+		return (YES);
+	else
+		return (NO);
+}
+#endif	//INTERNAL_HIDDEN_STORAGE_INCLUDE
+
+/************************************************************************
+* FUNCTION                                                              
+*                                                                       
+*       NAND_IO_Ioctl                                                     
+*                                                                       
+* DESCRIPTION                                                           
+*                                                                       
+*       This function doesn't do anything for the NAND Flash.  It is      
+*       included for devtable consistency.                              
+*                                                                       
+* INPUTS                                                                
+*                                                                       
+*       None.                                                           
+*                                                                       
+* OUTPUTS                                                               
+*                                                                       
+*       None.                                                           
+*                                                                       
+*************************************************************************/
+INT NAND_IO_Ioctl(UINT16 driveno, UINT16 command, VOID *buffer)
+{
+	int result;
+
+	NU_Obtain_Semaphore(&CAPP_SEM, NU_SUSPEND);
+	result	= NAND_Ioctl(command, buffer);
+	NU_Release_Semaphore(&CAPP_SEM);
+
+	return result;
+}
+
+#ifdef INTERNAL_HIDDEN_STORAGE_INCLUDE
+/**************************************************************************
+*  FUNCTION NAME : 
+*      INT NAND_HD_IO_Ioctl(UINT16 driveno, UINT16 command, VOID *buffer);
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			buffer	= 
+*			command	= 
+*			driveno	= 
+*  
+*  OUTPUT:	INT - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+INT NAND_HD_IO_Ioctl(UINT16 driveno, UINT16 command, VOID *buffer)
+{
+	int result;
+
+	NU_Obtain_Semaphore(&CAPP_SEM, NU_SUSPEND);
+	result	= NAND_HDIoctl(command, buffer);
+	NU_Release_Semaphore(&CAPP_SEM);
+
+	return result;
+}
+#endif	//INTERNAL_HIDDEN_STORAGE_INCLUDE
+
+#endif	// NU_FILE_INCLUDE
+
+//#endif	// WITHOUT_FILESYSTEM
+
+/* end of file */
diff --git a/drivers/block/tcc/nand_io_v6.c b/drivers/block/tcc/nand_io_v6.c
new file mode 100644
index 0000000..7b2f2db
--- /dev/null
+++ b/drivers/block/tcc/nand_io_v6.c
@@ -0,0 +1,15833 @@
+/****************************************************************************
+ *   FileName    : nand_io_v6.c
+ *   Description : 
+ ****************************************************************************
+ *
+ *   TCC Version 1.0
+ *   Copyright (c) Telechips, Inc.
+ *   ALL RIGHTS RESERVED
+ *
+ ****************************************************************************/
+#ifndef WITHOUT_FILESYSTEM
+
+#if defined(_LINUX_) || defined(_WINCE_)
+#include "IO_TCCXXX.h"
+#include "nand_io_v6.h"
+#else
+#include "main.h"
+#include "IO_TCCXXX.h"
+#include "nand_io_v6.h"
+#endif
+
+#if defined(_WINCE_)
+#if defined(USE_V_ADDRESS)
+#include "Tcc_ckc.h"
+#include "tcc_gpio.h"
+#else
+#include "Tca_ckc.h"
+#endif
+#include "bsp.h"
+#include "args.h"
+#elif defined(_LINUX_)
+#if defined(USE_V_ADDRESS)
+#include <mach/tca_ckc.h>
+#else
+#include "ckc.h"
+#endif
+#endif
+
+#if defined(TCC89XX) || defined(TCC92XX)
+#if defined(_LINUX_) || defined(_WINCE_)
+#include "TC_DRV.h"
+#else
+#include "TC_DRV.h"
+#endif
+#endif
+
+#if defined(_WINCE_)
+#include "stdlib.h"
+#endif
+
+//=============================================================================
+//
+// Version Signature
+//
+//=============================================================================
+#define NAND_IO_VERSION		'V','6','0','0','6'
+
+static const unsigned char 	NANDIO_Library_Version[] = 
+{ 	
+	SIGBYAHONG, 
+	NAND_IO_SIGNATURE, 
+	SIGN_OS, 
+	SIGN_CHIPSET, 
+	NAND_IO_VERSION, 
+	NULL
+};
+
+#ifdef UARTCON_INCLUDE
+//#define NAND_IO_ECC_ERROR_LOG
+//#define NAND_IO_UART_MEASURE
+#endif
+
+#if defined(_LINUX_)
+#ifdef KERNEL_DRIVER
+#include <linux/kernel.h>
+#include <linux/string.h>
+//extern void *virtadr;
+struct dma_buf {
+	void *v_addr;
+	unsigned int dma_addr;
+	int buf_size;
+};
+extern struct dma_buf dma_t;
+#else
+#define DMA_ADDR	(BSS_OFFSET - 0x00700000)
+#endif
+#else
+// TCC92 NU
+extern unsigned char *gpNandBuffer;
+#endif
+
+#if defined(_LINUX_)
+#define ASM_NOP {					\
+	__asm__ __volatile__ ("nop");	\
+	__asm__ __volatile__ ("nop");	\
+	__asm__ __volatile__ ("nop");	\
+	__asm__ __volatile__ ("nop");	\
+	__asm__ __volatile__ ("nop");	\
+	__asm__ __volatile__ ("nop");	\
+}
+#elif defined(_WINCE_)
+volatile int __asm_nop_count = 0;
+#define ASM_NOP { __asm_nop_count++; }
+#else
+#define ASM_NOP { __asm{ NOP }; __asm{ NOP };  __asm{ NOP }; __asm{ NOP }; __asm{ NOP }; __asm{ NOP };}
+#endif
+
+#if defined(_WINCE_)
+#define NAND_IO_USE_DMA_ACCESS
+#elif defined(_LINUX_)
+	#ifdef KERNEL_DRIVER
+		#define NAND_IO_USE_DMA_ACCESS
+//		#define NAND_IO_USE_MCU_ACCESS
+	#else
+		#define NAND_IO_USE_DMA_ACCESS
+	#endif
+#else
+#define NAND_IO_USE_DMA_ACCESS
+#endif
+
+#ifdef NAND_IO_USE_DMA_ACCESS
+#define NAND_IO_USE_DMA_DOUBLE_BUF
+#endif
+
+//=============================================================================
+//*
+//*
+//*                           [ CONST DATA DEFINE ]
+//*
+//*
+//=============================================================================
+const NAND_IO_FEATURE	TOSHIBA_NAND_DevInfo[] =
+{
+    //*=======================================================================================================================================================
+    //*[        DEVICE CODE       ][           SIZE          ][               Cycle               ][                  ATTRIBUTE                  ]
+    //*-------------------------------------------------------------------------------------------------------------------------------------------------------
+    //* 1st, 2nd,  3rd,  4th,  5th,  6th,  PBpV,BBpZ, PpB, Page,Spare,Col,Low,Twc, Ws, Wp, Wh, Rs, Rp, Rh
+    //*=======================================================================================================================================================
+    // [ 32MB] TC58DVM82A1FT
+    { 0x98, 0x75, 0x00, 0x00, 0x00, 0x00, 2048,  20,  32,  512,   16,  1,  2, 50,	 0, 25, 15,  0, 25, 15, A_08BIT|A_SLC	    |A_SMALL|S_NOR			   	},
+    // [ 64MB] TC58DVM92A1FT
+    { 0x98, 0x76, 0x00, 0x00, 0x00, 0x00, 4096,  20,  32,  512,   16,  1,  3, 50,	 0, 25, 15,  0, 25, 15, A_08BIT|A_SLC	    |A_SMALL|S_NOR			  	},
+    // [ 64MB] TC58NWM9S3B
+    { 0x98, 0xF0, 0x00, 0x00, 0x00, 0x00,  512,  10,  64, 2048,   64,  2,  2, 50,	 0, 25, 15,  0, 25, 15, A_08BIT|A_SLC	    |A_BIG  |S_NOR			   	},
+    // [128MB] TC58DVG02A1FT
+    { 0x98, 0x79, 0x00, 0x00, 0x00, 0x00, 8192,  20,  32,  512,   16,  1,  3, 50,	 0, 25, 15,  0, 25, 15, A_08BIT|A_SLC	    |A_SMALL|S_NOR			   	},	
+    // [128MB] TC58NVG0S3AFT
+    { 0x98, 0xF1, 0x00, 0x00, 0x00, 0x00, 1024,  20,  64, 2048,   64,  2,  2, 50,	 0, 25, 15,  0, 25, 15, A_08BIT|A_SLC	    |A_BIG  |S_NOR			   	},	
+    // [256MB] TH58NVG1S3AFT
+    { 0x98, 0xDA, 0x00, 0x00, 0x00, 0x00, 2048,  20,  64, 2048,   64,  2,  3, 50,	 0, 25, 15,  0, 25, 15, A_08BIT|A_SLC	    |A_BIG  |S_NOR			   	},
+    // [512MB] THGVN0G4D1DTG00
+    { 0x98, 0xDC, 0x00, 0x15, 0x00, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 50,	 0, 25, 15,  0, 35, 15, A_08BIT|A_SLC	    |A_BIG  |S_NOR|S_LBA		},
+    // [512MB] TH58NYG2S8C
+    { 0x98, 0xBC, 0x91, 0xD5, 0x49, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 50,	 0, 25, 15,  0, 35, 15, A_16BIT|A_SLC	    |A_BIG  |S_NOR			   	},
+    // [512MB] TH58NVG2D4CTG00
+    { 0x98, 0xDC, 0x84, 0xA5, 0x60, 0x00, 2048,  40, 128, 2048,   64,  2,  3, 50,	 0, 25, 15,  0, 25, 15, A_08BIT|A_MLC	    |A_BIG  |S_NOR|S_MP2	   	},
+    // [512MB] TH58NVG2D4BFT00
+    { 0x98, 0xDC, 0x84, 0xA5, 0x54, 0x00, 2048,  40, 128, 2048,   64,  2,  3, 50,	 0, 25, 15,  0, 25, 15, A_08BIT|A_MLC	    |A_BIG  |S_NOR			   	},
+    // [  1GB] TH58NVG3D4BFT00
+    { 0x98, 0xD3, 0x85, 0xA5, 0x58, 0x00, 4096,  40, 128, 2048,   64,  2,  3, 50,	 0, 25, 15,  0, 25, 15, A_08BIT|A_MLC	    |A_BIG  |S_NOR		  	    },
+    // [  1GB] TC58NVG3D4CTG00
+    { 0x98, 0xD3, 0x84, 0xA5, 0x66, 0x00, 4096,  40, 128, 2048,   64,  2,  3, 30,	 0, 20, 10,  0, 20, 10, A_08BIT|A_MLC	    |A_BIG  |S_NOR|S_MP	 		},
+    // [  2GB] TH58NVG4D4CFT00	[  4GB] TH58NVG5D4CTG20
+    { 0x98, 0xD5, 0x85, 0xA5, 0x00, 0x00, 8192,  40, 128, 2048,   64,  2,  3, 30,	 0, 20, 10,  0, 20, 10, A_08BIT|A_MLC	    |A_BIG  |S_NOR|S_MP			},
+    // [  1GB] TH58NVG3D1DTG00	// 4k Page
+    { 0x98, 0xD3, 0x94, 0xBA, 0x64, 0x00, 2048,  40, 128, 4096,  218,  2,  3, 30,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC_8BIT  |A_BIG  |S_NOR|S_MP			},
+	// [  2GB] TH58NVG4D1DTG00	[  4GB] TH58NVG5D1DTG20	
+    { 0x98, 0xD5, 0x94, 0x00, 0x00, 0x00, 4096,  40, 128, 4096,  218,  2,  3, 30,	 0, 20, 10,  0, 15, 15, A_08BIT|A_MLC_8BIT  |A_BIG  |S_NOR|S_MP			},
+    // [  8GB] TH58NVG6D1DTG20	// 4k Page
+    { 0x98, 0xD7, 0x00, 0x00, 0x00, 0x00, 8192,  40, 128, 4096,  218,  2,  3, 30,	 0, 20, 10,  0, 15, 15, A_08BIT|A_MLC_8BIT  |A_BIG  |S_NOR|S_MP			}
+};
+
+const NAND_IO_FEATURE	TOSHIBA_LBA_NAND_DevInfo[] =
+{
+    //*=======================================================================================================================================================
+    //*[        DEVICE CODE       ][           SIZE          ][               Cycle               ][                  ATTRIBUTE                  ]
+    //*-------------------------------------------------------------------------------------------------------------------------------------------------------
+    //* 1st, 2nd,  3rd,  4th,  5th,  6th,  PBpV,BBpZ, PpB, Page,Spare,Col,Low,Twc, Ws, Wp, Wh, Rs, Rp, Rh
+    //*=======================================================================================================================================================
+    // [  2GB] THGVN0G4D1DTG00
+    { 0x98, 0x21, 0x01, 0x55, 0xAA, 0x00, 8192,  40, 128, 4096,  218,  2,  3, 30,	 0, 20, 10,  0, 15, 15, A_08BIT|A_MLC_8BIT|A_BIG  |S_NOR|S_MP			},
+    // [  8GB] THGVN1G6D4ELA02
+    { 0x98, 0x21, 0x03, 0x55, 0xAA, 0x00, 8192,  40, 128, 4096,  218,  2,  3, 30,	 0, 20, 10,  0, 15, 15, A_08BIT|A_MLC_8BIT|A_BIG  |S_NOR|S_MP			},
+    // [  16GB] THGVN1G7D8ELA09
+    { 0x98, 0x21, 0x04, 0x55, 0xAA, 0x00, 8192,  40, 128, 4096,  218,  2,  3, 30,	 0, 20, 10,  0, 15, 15, A_08BIT|A_MLC_8BIT|A_BIG  |S_NOR|S_MP			}
+};
+
+const NAND_IO_FEATURE	HYNIX_NAND_DevInfo[] =
+{
+    //*=======================================================================================================================================================
+    //*[        DEVICE CODE       ][           SIZE          ][               Cycle               ][                  ATTRIBUTE                  ]
+    //*-------------------------------------------------------------------------------------------------------------------------------------------------------
+    //* 1st, 2nd,  3rd,  4th,  5th,  6th,  PBpV,BBpZ, PpB, Page,Spare,Col,Low,Twc, Ws, Wp, Wh, Rs, Rp, Rh
+    //*=======================================================================================================================================================
+    // [ 32MB] HY27US08561M
+    { 0xAD, 0x75, 0x00, 0x00, 0x00, 0x00, 2048,  20,  32,  512,   16,  1,  2, 50,	 0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	  |A_SMALL|S_NOR|S_CB        	},
+    // [ 64MB] HY27US08121M
+    { 0xAD, 0x76, 0x00, 0x00, 0x00, 0x00, 4096,  20,  32,  512,   16,  1,  3, 60,	 0, 40, 20,  0, 40, 20, A_08BIT|A_SLC	  |A_SMALL|S_NOR|S_CB        	},
+	// [ 64MB] HY27SS16122A
+    { 0xAD, 0x46, 0xAD, 0x46, 0xAD, 0x00, 4096,  20,  32,  512,   16,  1,  3, 60,	 0, 40, 20,  0, 50, 20, A_16BIT|A_SLC	  |A_SMALL|S_NOR|S_CB	       	},
+    // [128MB] HY27UA081G1M
+    { 0xAD, 0x79, 0x00, 0x00, 0x00, 0x00, 8192,  20,  32,  512,   16,  1,  3, 60,	 0, 40, 15,  0, 40, 15, A_08BIT|A_SLC	  |A_SMALL|S_NOR|S_CB	    	},
+    // [128MB] HY27UF081G2M, HY27UF081G2A 
+    { 0xAD, 0xF1, 0x00, 0x00, 0x00, 0x00, 1024,  20,  64, 2048,   64,  2,  2, 50,	 0, 35, 20,  0, 35, 20, A_08BIT|A_SLC	  |A_BIG  |S_NOR|S_CB|S_CP   	},
+	// [256MB] HY27UF082G2M, HY27UG082G2M
+	{ 0xAD, 0xDA, 0x80, 0x15, 0x00, 0x00, 2048,  20,  64, 2048,   64,  2,  3, 50,	 0, 35, 20,  0, 35, 20, A_08BIT|A_SLC	  |A_BIG  |S_NOR|S_CB|S_CP   	},
+	// [256MB] HY27UF082G2A
+	{ 0xAD, 0xDA, 0x80, 0x1D, 0x00, 0x00, 2048,  20,  64, 2048,   64,  2,  3, 50,	 0, 35, 20,  0, 35, 20, A_08BIT|A_SLC	  |A_BIG  |S_NOR|S_CB|S_CP   	},
+	// [256MB] HY27UF082G2B
+	{ 0xAD, 0xDA, 0x10, 0x95, 0x44, 0x00, 2048,  20,  64, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_SLC	  |A_BIG  |S_NOR|S_MP			},
+    // [512MB] HY27UF084G2M
+    { 0xAD, 0xDC, 0x80, 0x95, 0x00, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 30,	 0, 20, 10,  0, 20, 10, A_08BIT|A_SLC	  |A_BIG  |S_NOR|S_CB|S_CP   	},
+	// [512MB] HY27UF084G2B
+    { 0xAD, 0xDC, 0x10, 0x95, 0x00, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_SLC	  |A_BIG  |S_NOR|S_CB|S_MP	   	},
+    // [512MB] HY27UG084G2M, HY27UH084G2M
+    { 0xAD, 0xDC, 0x80, 0x15, 0x00, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 60,	 0, 35, 20,  0, 35, 20, A_08BIT|A_SLC	  |A_BIG  |S_NOR|S_CB|S_CP   	},
+    // [512MB] HY27UT084G2M
+    { 0xAD, 0xDC, 0x84, 0x25, 0x00, 0x00, 2048,  40, 128, 2048,   64,  2,  3, 50,	 0, 35, 15,  0, 35, 15, A_08BIT|A_MLC	  |A_BIG  |S_NOR				},
+    // [512MB] HY27UT084G2A
+    { 0xAD, 0xDC, 0x14, 0xA5, 0x24, 0x00, 2048,  25, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	  |A_BIG  |S_NOR|S_MP			},
+    // [  1GB] HY27UH088G2M
+    { 0xAD, 0xD3, 0x80, 0x15, 0x00, 0x00, 8192,  20,  64, 2048,   64,  2,  3, 60,	 0, 35, 20,  0, 35, 20, A_08BIT|A_SLC	  |A_BIG  |S_NOR|S_CB|S_CP   	},
+    // [  1GB] HY27UG088G2M  	[  2GB] HY27UH08AG5M
+    { 0xAD, 0xD3, 0xC1, 0x95, 0x00, 0x00, 8192,  20,  64, 2048,   64,  2,  3, 30,	 0, 20, 10,  0, 20, 10, A_08BIT|A_SLC	  |A_BIG  |S_NOR|S_CB|S_CP 	 	},
+    // [  1GB] H27U8G8F2M
+    { 0xAD, 0xD3, 0x10, 0xA6, 0x34, 0x00, 4096,  20,  64, 4096,  128,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_SLC	  |A_BIG  |S_NOR|S_MP	 	 	},	
+    // [  1GB] HY27UU088G2M
+    { 0xAD, 0xD3, 0x85, 0x25, 0x00, 0x00, 4096,  40, 128, 2048,   64,  2,  3, 50,	 0, 35, 15,  0, 35, 15, A_08BIT|A_MLC	  |A_BIG  |S_NOR				},
+    // [  1GB] HY27UT088G2M  	[  2GB] HY27UU08AG5M
+    { 0xAD, 0xD3, 0x14, 0xA5, 0x64, 0xAD, 4096,  25, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	  |A_BIG  |S_NOR|S_MP			},
+    // [  1GB] HY27UT088G2A
+    { 0xAD, 0xD3, 0x14, 0xA5, 0x34, 0x00, 4096,  25, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	  |A_BIG  |S_NOR|S_MP			},
+    // [  4GB] HY27UV08BG5M	 	[  8GB] HY27UW08CGFM
+    { 0xAD, 0xD5, 0x55, 0xA5, 0x68,	0x00, 8192,  25, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	  |A_BIG  |S_NOR|S_MP			},
+    // [  4GB] HY27UV08BG5A	 
+    { 0xAD, 0xD5, 0x55, 0xA5, 0x38,	0x00, 8192,  25, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	  |A_BIG  |S_NOR|S_MP			},
+	// [  2GB] HY27UAG8T2MTR
+    { 0xAD, 0xD5, 0x14, 0xB6, 0x44,	0x00, 4096,  25, 128, 4096,  128,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	  |A_BIG  |S_NOR|S_MP		 	},
+    // [  8GB] HY27UCG8V5MTR
+    { 0xAD, 0xD7, 0x55, 0xB6, 0x48,	0x00, 8192,  25, 128, 4096,  128,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	  |A_BIG  |S_NOR|S_MP			}
+};
+
+const NAND_IO_FEATURE	ST_NAND_DevInfo[] =
+{
+    //*=======================================================================================================================================================
+    //*[        DEVICE CODE       ][           SIZE          ][               Cycle               ][                  ATTRIBUTE                  ]
+    //*-------------------------------------------------------------------------------------------------------------------------------------------------------
+    //* 1st, 2nd,  3rd,  4th,  5th,  6th,  PBpV,BBpZ, PpB, Page,Spare,Col,Low,Twc, Ws, Wp, Wh, Rs, Rp, Rh
+    //*=======================================================================================================================================================
+    // [ 32MB] NAND256W3A
+    { 0x20, 0x75, 0x00, 0x00, 0x00, 0x00, 2048,  20,  32,  512,   16,  1,  2, 50,  	 0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	  |A_SMALL|S_NOR			   	},
+    // [ 64MB] NAND512W3A
+    { 0x20, 0x76, 0x00, 0x00, 0x00, 0x00, 4096,  20,  32,  512,   16,  1,  3, 50,	 0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	  |A_SMALL|S_NOR			   	},
+    // [128MB] NAND01GW3A
+    { 0x20, 0x79, 0x00, 0x00, 0x00, 0x00, 8192,  20,  32,  512,   16,  1,  3, 50,	 0, 35, 20,  0, 25, 20, A_08BIT|A_SLC	  |A_SMALL|S_NOR|S_CB|S_CP   	},
+    // [128MB] NAND01GW3B2C
+    { 0x20, 0xF1, 0x00, 0x1D, 0x00, 0x00, 1024,  20,  64, 2048,   64,  2,  2, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_SLC	  	|A_BIG  |S_NOR			 	},
+    // [128MB] NAND01GW3B
+    { 0x20, 0xF1, 0x00, 0x00, 0x00, 0x00, 1024,  20,  64, 2048,   64,  2,  2, 50,	 0, 35, 20,  0, 35, 20, A_08BIT|A_SLC	  |A_BIG  |S_NOR|S_CB|S_CP   	},
+	// [256MB] NAND02GW3B2D
+    { 0x20, 0xDA, 0x10, 0x95, 0x44, 0x00, 2048,  20,  64, 2048,   64,  2,  3, 45,	 0, 25, 20,  0, 25, 20, A_08BIT|A_SLC	  |A_BIG  |S_NOR|S_MP		   	},
+    // [256MB] NAND02GW3B
+    { 0x20, 0xDA, 0x00, 0x00, 0x00, 0x00, 2048,  20,  64, 2048,   64,  2,  3, 50,	 0, 35, 20,  0, 35, 20, A_08BIT|A_SLC	  |A_BIG  |S_NOR|S_CB|S_CP   	},
+	// [512MB] NAND04GW3B2D
+    { 0x20, 0xDC, 0x10, 0x95, 0x54, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_SLC	  |A_BIG  |S_NOR|S_MP		  	},
+    // [512MB] NAND04GW3B
+    { 0x20, 0xDC, 0x80, 0x95, 0x00, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 50,	 0, 35, 20,  0, 35, 20, A_08BIT|A_SLC	  |A_BIG  |S_NOR|S_CB|S_CP   	},
+    // [512MB] NAND04GW3C2A
+    { 0x20, 0xDC, 0x84, 0x25, 0x00, 0x00, 2048,  40, 128, 2048,   64,  2,  3, 60,	 0, 40, 20,  0, 40, 20, A_08BIT|A_MLC	  |A_BIG  |S_NOR				},
+	// [  1GB] NAND08GW3B2CN6
+    { 0x20, 0xD3, 0x51, 0x95, 0x58, 0x00, 8192,  20,  64, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_SLC	  |A_BIG  |S_NOR|S_MP|S_IL		},
+    // [  1GB] NAND08GW3B
+    { 0x20, 0xD3, 0x85, 0x25, 0x00, 0x00, 8192,  20,  64, 2048,   64,  2,  3, 50,	 0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	  |A_BIG  |S_NOR|S_CB|S_CP   	},
+	// [  1GB] NAND08GW3C2A,	[ 2GB] NAND16GW3C4A 
+    { 0x20, 0xD3, 0x14, 0xA5, 0x00, 0x00, 4096,  20, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	  |A_BIG  |S_NOR|S_MP		  	}
+};
+
+const NAND_IO_FEATURE	SAMSUNG_NAND_DevInfo[] =
+{
+    //*=======================================================================================================================================================
+    //*[        DEVICE CODE       ][           SIZE          ][               Cycle               ][                  ATTRIBUTE                  ]
+	//*-------------------------------------------------------------------------------------------------------------------------------------------------------
+    //* 1st, 2nd,  3rd,  4th,  5th,  6th,  PBpV,BBpZ, PpB, Page,Spare,Col,Low,Twc, Ws, Wp, Wh, Rs, Rp, Rh
+    //*=======================================================================================================================================================
+	// [ 32MB] K9F5608U0B/C/D ~TEST(C) ~TEST(D)   
+    { 0xEC, 0x75, 0x00, 0x00, 0x00, 0x00, 2048,  20,  32,  512,   16,  1,  2, 50,  	0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	   |A_SMALL|S_NOR|S_CB        	},
+    // [ 64MB] K9F1208U0M/A/B
+    { 0xEC, 0x76, 0xA5, 0xC0, 0x00, 0x00, 4096,  20,  32,  512,   16,  1,  3, 50,  	0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	   |A_SMALL|S_NOR|S_CB    	 	},
+    // [ 64MB] K9F1208U0C: ~TEST(C) WC: 42 WP: 21 WH: 15 
+    { 0xEC, 0x76, 0x5A, 0x3F, 0x00, 0x00, 4096,  20,  32,  512,   16,  1,  3, 50,  	0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	   |A_SMALL|S_NOR		   	 	},
+    // [128MB] K9K1G08U0M/A/B: ~TEST(B) 
+    { 0xEC, 0x79, 0xA5, 0xC0, 0x00, 0x00, 8192,  20,  32,  512,   16,  1,  3, 50,  	0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	   |A_SMALL|S_NOR|S_CB    	 	},
+    // [128MB] K9F1G08U0M,A
+    { 0xEC, 0xF1, 0x80, 0x15, 0x40, 0x00, 1024,  20,  64, 2048,   64,  2,  2, 50,  	0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	   |A_BIG  |S_NOR|S_CB|S_CP		},
+    // [128MB] K9F1G08U0B
+    { 0xEC, 0xF1, 0x00, 0x95, 0x40, 0x00, 1024,  20,  64, 2048,   64,  2,  2, 50,  	0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	   |A_BIG  |S_NOR|S_CB	 	  	},
+    // [256MB] KBE00S00AB	MCP MEMORY - Supply Voltage: Vcc 2.5 ~ 2.9 
+    { 0xEC, 0x71, 0x5A, 0x3F, 0x00, 0x00,16384,  20,  32,  512,   16,  1,  3, 50,  	0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	   |A_SMALL|S_NOR	    	 	},
+	// [256MB] K9F2G08U0M, K9K2G08U0M/A ~TEST(A)
+    { 0xEC, 0xDA, 0x00, 0x15, 0x00, 0x00, 2048,  20,  64, 2048,   64,  2,  3, 50,  	0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	   |A_BIG  |S_NOR|S_CB|S_CP 	},
+	// [256MB] K9F2G08U0A
+    { 0xEC, 0xDA, 0x10, 0x95, 0x44, 0x00, 2048,  20,  64, 2048,   64,  2,  3, 25,  	0, 15, 10,  0, 15, 10, A_08BIT|A_SLC       |A_BIG  |S_NOR|S_MP	  		},
+    // [512MB] K9K4G08U0M
+    { 0xEC, 0xDC, 0xC1, 0x15, 0x00, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 30,  	0, 20, 10,  0, 20, 10, A_08BIT|A_SLC	   |A_BIG  |S_NOR|S_CB|S_CP   	},
+    // [512MB] K9F4G08U0M
+    { 0xEC, 0xDC, 0x10, 0x95, 0x00, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 25,  	0, 15, 10,  0, 15, 10, A_08BIT|A_SLC	   |A_BIG  |S_NOR|S_CB		    },
+    // [256MB] K9G2G08U0M
+	{ 0xEC, 0xDA, 0x14, 0x25, 0x44, 0x00, 1024,  25, 128, 2048,   64,  2,  3, 30,  	0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	   |A_BIG  |S_NOR|S_MP	 		},	
+    // [512MB] K9G4G08U0M/A		[  1GB] K9L8G08U1M
+    { 0xEC, 0xDC, 0x14, 0x25, 0x54, 0x00, 2048,  40, 128, 2048,   64,  2,  3, 30,  	0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	   |A_BIG  |S_NOR|S_MP	    	},
+    // [512MB] K9G4G08U0B
+    { 0xEC, 0xDC, 0x14, 0xA5, 0x54, 0x00, 2048,  25, 128, 2048,   64,  2,  3, 25,  	0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	   |A_BIG  |S_NOR|S_MP	    	},
+    // [  1GB] K9K8G08UOM		[  2GB] K9WAG08U1M 
+    { 0xEC, 0xD3, 0x51, 0x95, 0x00, 0x00, 8192,  20,  64, 2048,   64,  2,  3, 25,  	0, 15, 10,  0, 15, 10, A_08BIT|A_SLC	   |A_BIG  |S_NOR|S_CB			},
+    // [  1GB] K9L8G08UOM		[  2GB] K9HAG08U1M
+    { 0xEC, 0xD3, 0x55, 0x25, 0x00, 0x00, 4096,  40, 128, 2048,   64,  2,  3, 35,  	0, 25, 10,  0, 25, 10, A_08BIT|A_MLC	   |A_BIG  |S_NOR|S_MP|S_IL   	},
+    // [  1GB] K9G8G08UOM		[  2GB] K9LAG08U1M 
+    { 0xEC, 0xD3, 0x14, 0x25, 0x64, 0x00, 4096,  40, 128, 2048,   64,  2,  3, 35,  	0, 25, 10,  0, 25, 10, A_08BIT|A_MLC	   |A_BIG  |S_NOR|S_MP			},
+    // [  1GB] K9G8G08UOA/B		[  2GB] K9LAG08U1A 
+    { 0xEC, 0xD3, 0x14, 0xA5, 0x64, 0x00, 4096,  25, 128, 2048,   64,  2,  3, 50,  	0, 30, 20,  0, 30, 20, A_08BIT|A_MLC	   |A_BIG  |S_NOR|S_MP			},	
+    // [  2GB] K9LAG08UOM	  	[  4GB] K9HBG08U1M	  [  8GB] K9MCG08U5M
+    { 0xEC, 0xD5, 0x55, 0x25, 0x68, 0x00, 8192,  40, 128, 2048,   64,  2,  3, 30,  	0, 20, 10,  0, 20, 10, A_08BIT|A_MLC	   |A_BIG  |S_NOR|S_MP|S_IL		},
+	// [  2GB] K9LAG08UOA/B	 
+	{ 0xEC, 0xD5, 0x55, 0xA5, 0x68, 0x00, 8192,  25, 128, 2048,   64,  2,  3, 25,  	0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	   |A_BIG  |S_NOR|S_MP|S_IL		},
+    // [  2GB] K9GAG08UOM	// 4K Page
+    { 0xEC, 0xD5, 0x14, 0xB6, 0x74, 0x00, 4096,  25, 128, 4096,  128,  2,  3, 25,  	0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	   |A_BIG  |S_NOR|S_MP			},
+    // [  4GB] K9LBG08UOM		[  8GB] K9HCG08U1M    [ 16G] K9MDG08U5M
+    { 0xEC, 0xD7, 0x55, 0xB6, 0x78, 0x00, 8192,  25, 128, 4096,  128,  2,  3, 25,  	0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	   |A_BIG  |S_NOR|S_MP|S_IL		},
+    // [  2GB] K9GAG08UOD		[ 4GB] K9LBG08U1D	  [ 8GB] K9HCG08U5D
+    { 0xEC, 0xD5, 0x94, 0x29, 0x34, 0x41, 4096,  25, 128, 4096,  218,  2,  3, 30,   0, 15, 10,  0, 15, 10, A_08BIT|A_MLC_8BIT  |A_BIG  |S_NOR|S_MCP			},
+    // [  4GB] K9LBG08UOD		[  8GB] K9HCG08U1D	  [ 16G] K9MDG08U5D   [ 32G] K9PDG08U5D
+    { 0xEC, 0xD7, 0xD5, 0x29, 0x38, 0x41, 8192,  25, 128, 4096,  218,  2,  3, 30,  	0, 20, 10,  0, 20, 10, A_08BIT|A_MLC_8BIT  |A_BIG  |S_NOR|S_MP|S_IL		}
+};
+
+const NAND_IO_FEATURE	MICRON_NAND_DevInfo[] =
+{
+    //*=======================================================================================================================================================
+    //*[        DEVICE CODE       ][           SIZE          ][               Cycle               ][                  ATTRIBUTE                  ]
+    //*-------------------------------------------------------------------------------------------------------------------------------------------------------
+    //* 1st, 2nd,  3rd,  4th,  5th,  6th,  PBpV,BBpZ, PpB, Page,Spare,Col,Low,Twc, Ws, Wp, Wh, Rs, Rp, Rh
+    //*=======================================================================================================================================================
+    // [256MB] 29F2G08AAC		
+    { 0x2C, 0xDA, 0x00, 0x00, 0x00, 0x00, 2048,  20,  64, 2048,   64,  2,  3, 30,	 0, 25, 15,  0, 25, 15, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CP    	    },
+    // [512MB] 29F4G08BAC,		[  1GB] 29F8G08FAC	
+    { 0x2C, 0xDC, 0x80, 0x15, 0x50, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 30,	 0, 25, 15,  0, 25, 15, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CP		    },
+    // [512MB] 29F4G08AAA/C		[  1GB] 29F8G08DAA
+    { 0x2C, 0xDC, 0x90, 0x95, 0x54, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 30,	 0, 25, 15,  0, 25, 15, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_MP			},
+    // [  2GB] 29F16G08FAA
+    { 0x2C, 0xD3, 0xD1, 0x95, 0x58, 0x00, 8192,  20,  64, 2048,   64,  2,  3, 30,	 0, 25, 15,  0, 25, 15, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP	},
+    // [  1GB] 29F08G08MAA   	[  2GB] 29F16G08QAA
+    { 0x2C, 0xD3, 0x94, 0xA5, 0x64, 0x00, 4096,  40, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP			},
+    // [  4GB] 29F32G08TAA
+    { 0x2C, 0xD5, 0xD5, 0xA5, 0x68, 0x00, 8192,  40, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP			},
+    // [  2GB] 29F16G08MAA		[  4GB] 29F32G08QAA 
+	{ 0x2C, 0xD5, 0x94, 0x3E, 0x74, 0x00, 4096,  25, 128, 4096,  218,  2,  3, 30,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC_8BIT 	|A_BIG  |S_NOR|S_MP			},
+	// [  8GB] 29F64G08TAA
+	{ 0x2C, 0xD7, 0xD5, 0x3E, 0x78, 0x00, 8192,  25, 128, 4096,  218,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC_8BIT	|A_BIG  |S_NOR|S_MP|S_IL	},
+	// [  4GB] 29F32G08CBAAA, 	[  8GB] 29F64G08CFAAA 
+	{ 0x2C, 0xD7, 0x94, 0x3E, 0x84, 0x00, 8192,  25, 128, 4096,  218,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC_12BIT	|A_BIG  |S_NOR|S_MCP		},
+	// [ 16GB] 29F128G08CJAA 
+	{ 0x2C, 0xD9, 0xD5, 0x3E, 0x88, 0x00,16384,  25, 128, 4096,  218,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC_12BIT	|A_BIG  |S_NOR|S_MP|S_IL	}	
+};
+
+const NAND_IO_MAKERINFO	NAND_SupportMakerInfo =
+ {
+	// MAXIMUM SUPPORT NANDFLASH
+	MAX_SUPPORT_SAMSUNG_NAND,
+	MAX_SUPPORT_TOSHIBA_NAND,
+	MAX_SUPPORT_HYNIX_NAND,
+	MAX_SUPPORT_ST_NAND,
+	MAX_SUPPORT_MICRON_NAND,
+	// NAND MAKER ID
+	SAMSUNG_NAND_MAKER_ID,
+	TOSHIBA_NAND_MAKER_ID,
+	HYNIX_NAND_MAKER_ID,
+	ST_NAND_MAKER_ID,
+	MICRON_NAND_MAKER_ID,
+	// POINTER OF NANDFLASH INFOMATION
+	(NAND_IO_FEATURE*)SAMSUNG_NAND_DevInfo,
+	(NAND_IO_FEATURE*)TOSHIBA_NAND_DevInfo,
+	(NAND_IO_FEATURE*)HYNIX_NAND_DevInfo,
+	(NAND_IO_FEATURE*)ST_NAND_DevInfo,
+	(NAND_IO_FEATURE*)MICRON_NAND_DevInfo	
+};
+
+const NAND_IO_LBA_MAKERINFO	LBA_NAND_SupportMakerInfo =
+ {
+	// MAXIMUM SUPPORT NANDFLASH
+	MAX_SUPPORT_TOSHIBA_LBA_NAND,
+	// NAND MAKER ID
+	TOSHIBA_NAND_MAKER_ID,
+	// POINTER OF NANDFLASH INFOMATION
+	(NAND_IO_FEATURE*)TOSHIBA_LBA_NAND_DevInfo
+};
+
+const unsigned char NAND_LBA_VFP_AREA_Signature[] =
+{
+	"NANDLBASIGNATURE"
+};
+
+#define NAND_IO_MAX_SHIFT_FACTOR_FOR_MULTIPLY	16
+const unsigned short int    NAND_IO_ShiftFactorForMultiplay[NAND_IO_MAX_SHIFT_FACTOR_FOR_MULTIPLY] =
+{
+    1,      //     1 = 2^0
+    2,      //     2 = 2^1
+    4,      //     4 = 2^2
+    8,      //     8 = 2^3
+    16,     //    16 = 2^4
+    32,     //    32 = 2^5
+    64,     //    64 = 2^6
+    128,    //   128 = 2^7
+    256,    //   256 = 2^8
+    512,    //   512 = 2^9
+    1024,   //  1024 = 2^10
+    2048,   //  2048 = 2^11
+    4096,   //  4096 = 2^12
+    8192,   //  8192 = 2^13
+    16384,  // 16384 = 2^14
+    32768	// 32768 = 2^15
+};
+
+const unsigned char	ALL_FF_ECC_BCH_04BIT_12[30] =
+{ 
+	0x48,0xF6,0x3C,0xC9,0xAA,
+	0x45,0x03,0x00,0x00,0x00,
+
+	0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,
+
+	0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00	
+};
+
+// BCH 4bit Code: 6.5 Byte
+const unsigned char	ALL_FF_ECC_BCH_04BIT_512[30] =
+{ 
+	0xEB,0x37,0xCC,0x63,0x96,
+	0xCA,0x01,0x00,0x00,0x00,
+
+	0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,
+
+	0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00
+};
+
+// BCH 8bit Code:  13 Byte
+const unsigned char	ALL_FF_ECC_BCH_08BIT_512[30] =
+{ 
+	0x08,0x75,0x8B,0x6F,0x48,
+	0x36,0xA6,0xBC,0x16,0x61,
+	0x58,0xDB,0x52,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,
+
+	0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00	
+};
+
+// BCH 12bit Code:  19.5 Byte
+const unsigned char	ALL_FF_ECC_BCH_12BIT_512[30] = 
+{ 
+	0x81,0xEC,0xE8,0x4E,0xE3,
+	0x46,0x44,0xA1,0x3F,0x8A,
+	0x29,0x06,0xD0,0x90,0x06,
+	0x76,0x21,0x32,0x3E,0x0F,
+	0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00
+};
+
+// BCH 14bit Code:  23 Byte
+const unsigned char	ALL_FF_ECC_BCH_14BIT_512[25] = 
+{ 
+	0xFF,0xFF,0xFF,0xFF,0xFF,
+	0xFF,0xFF,0xFF,0xFF,0xFF,
+	0xFF,0xFF,0xFF,0xFF,0xFF,
+	0xFF,0xFF,0xFF,0xFF,0xFF,
+	0xFF,0xFF,0xFF,0xFF,0xFF 
+};  
+
+// BCH 16bit Code:  26 Byte
+const unsigned char	ALL_FF_ECC_BCH_16BIT_512[30] = 
+{ 
+	0xFF,0xFF,0xFF,0xFF,0xFF,
+	0xFF,0xFF,0xFF,0xFF,0xFF,
+	0xFF,0xFF,0xFF,0xFF,0xFF,
+	0xFF,0xFF,0xFF,0xFF,0xFF,
+	0xFF,0xFF,0xFF,0xFF,0xFF,
+	0xFF,0xFF,0xFF,0xFF,0xFF
+};
+
+//=============================================================================
+//*
+//*
+//*                           [ GLOBAL VARIABLE DEFINE ]
+//*
+//*
+//=============================================================================
+NAND_IO_CYCLE		WriteCycleTime;
+NAND_IO_CYCLE		ReadCycleTime;
+NAND_IO_CYCLE		CommCycleTime;
+unsigned int		gMaxBusClkMHZ;
+unsigned int		gCycleTick;
+
+NAND_IO_ECC_INFO	gMLC_ECC_4Bit;
+NAND_IO_ECC_INFO	gMLC_ECC_8Bit;
+NAND_IO_ECC_INFO	gMLC_ECC_12Bit;
+NAND_IO_ECC_INFO	gMLC_ECC_14Bit;
+NAND_IO_ECC_INFO	gMLC_ECC_16Bit;
+
+
+unsigned int		gNAND_IO_DataBusType;
+
+PGPIO 				pGPIO;
+PNFC				pNFC;
+PECC				pECC;
+PIOBUSCFG			pIOBUSCFG_T;
+#if defined(_WINCE_)
+tSYSTEM_PARAM  		*pSYS_PARAM;
+#endif
+PGDMANCTRL			pNAND_DMA;
+
+unsigned int		gInterLeavePageAddr;
+unsigned int		gInterLeaveCSNum;
+unsigned short int	gInterLeaveIoStatus;
+unsigned int		gInterLeaveWriteStatus;
+
+/* Micron Interleaver */
+unsigned int		gInterLeaveDie0BlockAddr;
+unsigned int		gInterLeaveDie1BlockAddr;
+
+unsigned int		gNANDIO_GSELReg;
+unsigned int		gNANDIO_GIOCONReg;
+unsigned int		gNANDIO_GDATASet;
+unsigned int		gNAND_GPIO_ON_OFF = ENABLE;
+
+unsigned int		*gpDMA_PhyBuffer0;
+unsigned int		*gpDMA_WorkBuffer0;
+unsigned int		*gpDMA_PhyBuffer1;
+unsigned int		*gpDMA_WorkBuffer1;
+
+NAND_IO_DEVINFO 	*gDevInfo;
+NAND_IO_DEVINFO 	rDevInfo;
+
+#if defined(TCC89XX) || defined(TCC92XX)
+int					gDRV_GDMA_Handle_NAND;
+sDRV_GDMA			gDRV_GDMA_NAND	=
+{
+	0 | DRV_GDMA_CFG_StartByHwReqLevel
+	| DRV_GDMA_CFG_AckAtRead
+	| DRV_GDMA_CFG_Arbitration//| DRV_GDMA_CFG_NoArbitration
+	| DRV_GDMA_CFG_BufNum_1
+	| DRV_GDMA_CFG_1HopUnit_16Byte
+	| DRV_GDMA_CFG_ReadBW_32Bit
+	| DRV_GDMA_CFG_WriteBW_32Bit
+	, DRV_GDMA_HwREQ_NFC
+	, 0,
+};
+#endif
+
+//#define SPEED_CHECK
+#if defined(SPEED_CHECK)
+//#define READ_SPEED_CHECK
+//#define WRITE_SPEED_CHECK
+#endif
+
+#if defined(_WINCE_)
+#pragma pack(8)
+unsigned char			gNAND_IO_ShareEccBuffer[ 512 ];
+#pragma pack()
+#elif defined(_LINUX_)
+unsigned char			gNAND_IO_ShareEccBuffer[ 512 ] __attribute__((aligned(8)));
+#else
+__align(8) unsigned char		gNAND_IO_ShareEccBuffer[ 512 ];
+#endif
+
+NAND_LBA_CALLBACK_HANDLER	NAND_IO_LBA_CallBackLcdDisplay;
+
+//=============================================================================
+//*
+//*
+//*                           [ LOCAL FUNCTIONS DEFINE ]
+//*
+//*
+//=============================================================================
+static __inline void				NAND_IO_SetDataWidth( U32 width );
+static __inline void				NAND_IO_PreProcess( void );
+static __inline void				NAND_IO_PostProcess( void );
+static __inline void				NAND_IO_SetBasicCycleTime( void );
+static __inline void				NAND_IO_SetCommCycleTime( void );
+static __inline void				NAND_IO_SetWriteCycleTime(void);
+static __inline void				NAND_IO_SetReadCycleTime(void);
+static __inline void				NAND_IO_EnableChipSelect( U16 nChipNo );
+static __inline void				NAND_IO_DisableChipSelect( void );
+static __inline void				NAND_IO_EnableWriteProtect( void );
+static __inline void				NAND_IO_DisableWriteProtect( void );
+static __inline U32					NAND_IO_CheckReadyAndBusy( U16 nChipNo);
+static __inline void				NAND_IO_WaitBusy( U16 nChipNo );
+static __inline void				NAND_IO_WaitBusyForProgramAndErase( NAND_IO_DEVINFO *nDevInfo );
+static __inline void				NAND_IO_WaitBusyForCacheProgram( NAND_IO_DEVINFO *nDevInfo );
+
+static __inline void 				NAND_IO_ClearInterleaveStatus( NAND_IO_DEVINFO *nDevInfo );
+static __inline void 				NAND_IO_SetInterleaveStatus( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr );
+
+static __inline void				NAND_IO_Delay( void );
+
+static __inline NAND_IO_ERROR  		NAND_IO_WaitBusyForInterleave( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr );
+static __inline NAND_IO_ERROR		NAND_IO_ReadStatus( NAND_IO_DEVINFO *nDevInfo );
+static __inline NAND_IO_ERROR		NAND_IO_ReadStatusForMultiPlane( NAND_IO_DEVINFO *nDevInfo );
+static __inline NAND_IO_ERROR		NAND_IO_ReadStatusForCacheProgram( NAND_IO_DEVINFO *nDevInfo );
+static __inline NAND_IO_ERROR		NAND_IO_ReadStatusForInterleave( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr );
+static __inline NAND_IO_ERROR		NAND_IO_ReadStatusForInterleaveClear( NAND_IO_DEVINFO *nDevInfo );
+
+static __inline NAND_IO_ERROR		NAND_IO_GenerateRowColAddrForRead( U32 nPageAddr, U16 nColumnAddr, U32* rRowAddr, U32* rColumnAddr, NAND_IO_DEVINFO *nDevInfo );
+static __inline NAND_IO_ERROR		NAND_IO_GenerateRowColAddrForWrite( U32 nPageAddr, U16 nColumnAddr, U32* rRowAddr, U32* rColumnAddr, NAND_IO_DEVINFO *nDevInfo );
+static __inline NAND_IO_ERROR		NAND_IO_GenerateRowColAddrForCBandCP( U32 nPageAddr, U16 nColumnAddr, U32* rRowAddr, U32* rColumnAddr, NAND_IO_DEVINFO *nDevInfo );
+static __inline void				NAND_IO_WriteRowColAddr( U32 nRowAddr, U32 nColumnAddr, NAND_IO_DEVINFO *nDevInfo );
+static __inline void 				NAND_IO_WriteColAddr( U32 nColumnAddr, NAND_IO_DEVINFO *nDevInfo );
+static __inline void				NAND_IO_WriteBlockPageAddr( U32 nBlockPageAddr, NAND_IO_DEVINFO *nDevInfo );
+static __inline void				NAND_IO_SetNFCBusWidth( NAND_IO_DEVINFO *nDevInfo );
+
+#if defined(NAND_IO_USE_DMA_ACCESS)
+static __inline void 				NAND_IO_SetupDMA(void * pSRC, unsigned uSrcInc, unsigned uSrcMask, void * pDST, unsigned uDstInc, unsigned uDstMask, int nMode, int nDSize );
+static __inline void 				NAND_IO_SetupDMADoubleBuf(  int nMode, int nDMACh );
+#endif
+static __inline void				NAND_IO_SetupECC( U16 nEccOnOff, U16 nEncDec, U16 nEccType, U16 nAccessType, U32 EccBaseAddr );
+
+static __inline NAND_IO_ERROR 		NAND_IO_EncodeECC( U16 nEccType, U8* nSpareBuffer );
+static __inline NAND_IO_ERROR 		NAND_IO_EncodeNBECC( U16 nEccType, U8* nSpareBuffer );
+
+static __inline NAND_IO_ERROR		NAND_IO_CorrectionSLC( U8* nPageBuffer, U8* nSpareBuffer );
+static __inline NAND_IO_ERROR		NAND_IO_CorrectionSLCForNB( U8* nPageBuffer, U8* nSpareBuffer );
+static __inline NAND_IO_ERROR 		NAND_IO_CorrectionMLC( U16 nEccType, U8* nPageBuffer, U8* nSpareBuffer, U16 nDataSize );
+static __inline NAND_IO_ERROR 		NAND_IO_CorrectionMLCForNB( U8* nPageBuffer, U8* nSpareBuffer );
+static __inline NAND_IO_ERROR 		NAND_IO_CorrectionMLCForCB( U8* nPageBuffer, U8* nSpareBuffer, U16 nDataSize, U16 nBufferMode );
+static __inline NAND_IO_ERROR 		NAND_IO_CorrectionMLC8ForCB( U8* nPageBuffer, U8* nSpareBuffer, U16 nDataSize, U16 nBufferMode );
+static __inline NAND_IO_ERROR 		NAND_IO_CorrectionMLC12ForCB( U8* nPageBuffer, U8* nSpareBuffer, U16 nDataSize, U16 nBufferMode );
+
+static __inline NAND_IO_ERROR 		NAND_IO_EncodeChainData( NAND_IO_DEVINFO *nDevInfo, U8 *nPageBuffer, U8 *nSpareBuffer, int nMode, int nEccOnOff );
+static __inline NAND_IO_ERROR 		NAND_IO_DecodeChainData( NAND_IO_DEVINFO *nDevInfo, U8 *nPageBuffer, U8 *nSpareBuffer, int nMode, int nEccOnOff );
+static __inline NAND_IO_ERROR 		NAND_IO_EncodeChainDataForGoldenPage( NAND_IO_DEVINFO *nDevInfo, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+static __inline NAND_IO_ERROR 		NAND_IO_DecodeChainDataForGoldenPage( NAND_IO_DEVINFO *nDevInfo, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+
+static __inline NAND_IO_ERROR		NAND_IO_ReadSpareData( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nReadPPSize, U8 *nSpareBuffer );
+static __inline NAND_IO_ERROR 		NAND_IO_ReadSpareDataECC( NAND_IO_DEVINFO *nDevInfo, U8 *nSpareBuffer, int nEccOnOff );
+static __inline NAND_IO_ERROR 		NAND_IO_ReadSpareDataMTD( NAND_IO_DEVINFO *nDevInfo, U8 *nSpareBuffer, int nEccOnOff );
+static __inline NAND_IO_ERROR		NAND_IO_Read512DataDoubleBuf( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nReadPPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff, int nSpareOnOff );
+static __inline NAND_IO_ERROR		NAND_IO_Read512Data( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nReadPPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff, int nSpareOnOff );
+static __inline NAND_IO_ERROR		NAND_IO_Read528Data( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nReadPPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+static __inline NAND_IO_ERROR		NAND_IO_Read512DataMTD( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nReadPPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff, int nSpareOnOff );
+static __inline NAND_IO_ERROR		NAND_IO_ReadUserSizeData( NAND_IO_DEVINFO *nDevInfo, U16 nColumnAddr, U32 nReadSize, U8 *nReadBuffer );
+
+static __inline NAND_IO_ERROR 		NAND_IO_WriteSpareData( NAND_IO_DEVINFO *nDevInfo, U8 *nSpareBuffer, int nEccOnOff );
+static __inline NAND_IO_ERROR		NAND_IO_Write512DataDoubleBuf( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nWritePPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+static __inline NAND_IO_ERROR		NAND_IO_Write512Data( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nWritePPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+static __inline NAND_IO_ERROR		NAND_IO_Write528Data( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nWritePPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+static __inline NAND_IO_ERROR		NAND_IO_Write512DataMTD( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nWritePPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+
+static __inline NAND_IO_ERROR		NAND_IO_WriteUserSizeData( NAND_IO_DEVINFO *nDevInfo, U16 nColumnAddr, U32 nWriteSize, U8 *nWriteBuffer );
+
+static __inline NAND_IO_ERROR		NAND_IO_GetShiftValueForFastMultiPly( U16 nValue, U16* rFactor );
+
+static __inline NAND_IO_ERROR 		NAND_IO_LBA_ReadData( NAND_IO_DEVINFO *nDevInfo, U16 nReadPPSize, U8 *nPageBuffer, U8 *nSpareBuffer );
+static __inline NAND_IO_ERROR 		NAND_IO_LBA_WriteData( NAND_IO_DEVINFO *nDevInfo, U16 nWritePPSize, U8 *nPageBuffer, U8 *nSpareBuffer );
+static __inline NAND_IO_ERROR 		NAND_IO_LBA_WriteDummyData( NAND_IO_DEVINFO *nDevInfo, U16 nWritePPSize );
+
+NAND_IO_ERROR 						NAND_IO_LBA_VFPInitArea( NAND_IO_DEVINFO *nDevInfo );
+NAND_IO_ERROR						NAND_IO_LBA_MDPGetTotalSectorSize(NAND_IO_DEVINFO * nDevInfo, unsigned long int * rTotalSector);
+NAND_IO_ERROR						NAND_IO_LBA_VFPGetTotalSectorSize(NAND_IO_DEVINFO * nDevInfo, U32 * rTotalSector);
+NAND_IO_ERROR						NAND_IO_LBA_VFPChangeSectorSize(NAND_IO_DEVINFO * nDevInfo, U32 nTotalSector);
+NAND_IO_ERROR						NAND_IO_LBA_SetTransferProtocol(NAND_IO_DEVINFO * nDevInfo, U8 nProtocol1, U8 nProtocol2);
+NAND_IO_ERROR 						NAND_IO_LBA_SetBootModeChange( NAND_IO_DEVINFO *nDevInfo, U8 nBootMode );
+NAND_IO_ERROR 						NAND_IO_LBA_SetRebootCmdChange( NAND_IO_DEVINFO *nDevInfo, U8 nRebootCmd );
+NAND_IO_ERROR 						NAND_IO_LBA_GetPersistentFunction( NAND_IO_DEVINFO *nDevInfo, U8 *rBootMode, U8 *rRebootCmd );
+NAND_IO_ERROR 						NAND_IO_LBA_GetTransferProtocol( NAND_IO_DEVINFO *nDevInfo, U8 *rProtocol1, U8 *rProtocol2 );
+NAND_IO_ERROR 						NAND_IO_LBA_GetBootMode( NAND_IO_DEVINFO *nDevInfo, U8 *rBootMode );
+NAND_IO_ERROR		 				NAND_IO_LBA_HighSpeedMode( NAND_IO_DEVINFO *nDevInfo, int nOnOff );
+NAND_IO_ERROR 						NAND_IO_LBA_ReadID( NAND_IO_DEVINFO *nDevInfo, NAND_IO_DEVID *nDeviceCode );
+NAND_IO_ERROR 						NAND_IO_LBA_Reset( NAND_IO_DEVINFO *nDevInfo );
+
+//=============================================================================
+//*
+//*
+//*                     [ EXTERN VARIABLE & FUNCTIONS DEFINE ]
+//*
+//*
+//=============================================================================
+#if defined(_LINUX_) || defined(_WINCE_)
+int					TCC7XX_USBDRV_WriteToQueue( void ){ return 0;}
+extern unsigned int		gMAX_ROMSIZE;
+#else
+extern void			memcpy(void *pvDest, const void *pvSrc, unsigned long iCount);
+extern void			memset(void *pvDest, char cChar, unsigned long iCount);
+extern int			memcmp(const void *pvSrc1, const void *pvSrc2, unsigned long iCount);
+extern int			TCC7XX_USBDRV_WriteToQueue( void );
+extern unsigned int		gMAX_ROMSIZE;
+#endif
+
+#ifndef _LINUX_
+extern unsigned		fmemcpy16(void *dest, void *src, unsigned length);
+#endif
+
+#ifdef SPEED_CHECK
+void NAND_IO_GPIO_Toggle( U32 nBitNum )
+{
+	if( pGPIO->GPFDAT & nBitNum )
+		BITCLR(pGPIO->GPFDAT, nBitNum);
+	else
+		BITSET(pGPIO->GPFDAT, nBitNum);
+}
+#endif
+
+#if defined(_WINCE_)
+//extern unsigned int tcc_allocbaseaddress(unsigned int iphysicalbaseaddress, unsigned int isize);
+extern void B_RETAILMSG(const char * fmt, ...);
+#endif
+
+/******************************************************************************
+*
+*	unsigned char*	NAND_IO_TellLibraryVersion
+*
+*	Input	: NONE
+*	Output	: NONE
+*	Return	: NONE
+*
+*	Description :
+*
+*******************************************************************************/
+unsigned char*	NAND_IO_TellLibraryVersion( void )
+{
+	return (unsigned char*)NANDIO_Library_Version;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      NAND_IO_ERROR NAND_IO_NANDGPIOControlFlag( unsigned int on_off );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			on_off	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+*  REMARK:	  by nemo
+**************************************************************************/
+NAND_IO_ERROR NAND_IO_NANDGPIOControlFlag( unsigned int on_off )
+{
+	gNAND_GPIO_ON_OFF = on_off;
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_CallBackChangeWCtime
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_CallBackChangeWCtime( unsigned short int TotalMediaNum, NAND_IO_DEVINFO *nDevInfo )
+{
+	if ( nDevInfo->IoStatus == ENABLE )
+	{
+		//**************************************************************
+		// Case on K9NBG08U5M Samsung NANDFLASH
+		//**************************************************************
+		if ( nDevInfo->Feature.DeviceID.Code[0] == 0xEC &&
+			 nDevInfo->Feature.DeviceID.Code[1] == 0xD3 &&
+			 nDevInfo->Feature.DeviceID.Code[2] == 0x51 &&
+			 nDevInfo->Feature.DeviceID.Code[3] == 0x95 )
+		{
+			if ( TotalMediaNum == 4 )
+			{
+				nDevInfo->Feature.WCtime 	= 45;
+
+				nDevInfo->Feature.WriteSTP 	= 0;
+				nDevInfo->Feature.WriteWP 	= 30;
+				nDevInfo->Feature.WriteHLD 	= 15;
+
+				nDevInfo->Feature.ReadSTP	= 0;
+				nDevInfo->Feature.ReadPW 	= 30;
+				nDevInfo->Feature.ReadHLD 	= 15;
+				
+				NAND_IO_SetCycle( nDevInfo );
+			}
+		}
+		//**************************************************************
+		// Case on K9MBG08U5M Samsung NANDFLASH
+		//**************************************************************
+		else if ( nDevInfo->Feature.DeviceID.Code[0] == 0xEC &&
+			 	  nDevInfo->Feature.DeviceID.Code[1] == 0xD3 &&
+				  nDevInfo->Feature.DeviceID.Code[2] == 0x55 &&
+				  nDevInfo->Feature.DeviceID.Code[3] == 0x25 )
+		{
+			if ( TotalMediaNum == 4 )
+			{
+				nDevInfo->Feature.WCtime = 45;
+
+				nDevInfo->Feature.WriteSTP 	= 0;
+				nDevInfo->Feature.WriteWP 	= 30;
+				nDevInfo->Feature.WriteHLD 	= 15;
+
+				nDevInfo->Feature.ReadSTP	= 0;
+				nDevInfo->Feature.ReadPW 	= 30;
+				nDevInfo->Feature.ReadHLD 	= 15;
+
+				NAND_IO_SetCycle( nDevInfo );
+			}
+		}
+		//**************************************************************
+		// Case on K9MCG08U5M Samsung NANDFLASH
+		//**************************************************************
+		else if ( nDevInfo->Feature.DeviceID.Code[0] == 0xEC &&
+			 	  nDevInfo->Feature.DeviceID.Code[1] == 0xD5 &&
+			 	  nDevInfo->Feature.DeviceID.Code[2] == 0x55 &&
+			 	  nDevInfo->Feature.DeviceID.Code[3] == 0x25 &&
+			 	  nDevInfo->Feature.DeviceID.Code[4] == 0x68 )
+		{
+			if ( TotalMediaNum == 4 )
+			{
+				nDevInfo->Feature.WCtime = 45;
+
+				nDevInfo->Feature.WriteSTP 	= 0;
+				nDevInfo->Feature.WriteWP 	= 30;
+				nDevInfo->Feature.WriteHLD 	= 15;
+
+				nDevInfo->Feature.ReadSTP	= 0;
+				nDevInfo->Feature.ReadPW 	= 30;
+				nDevInfo->Feature.ReadHLD 	= 15;
+
+				NAND_IO_SetCycle( nDevInfo );
+			}
+		}
+		//**************************************************************
+		// Case on K9MDG08U5M Samsung NANDFLASH
+		//**************************************************************
+		else if ( nDevInfo->Feature.DeviceID.Code[0] == 0xEC &&
+			 	  nDevInfo->Feature.DeviceID.Code[1] == 0xD7 &&
+			 	  nDevInfo->Feature.DeviceID.Code[2] == 0x55 &&
+			 	  nDevInfo->Feature.DeviceID.Code[3] == 0xB6 &&
+			 	  nDevInfo->Feature.DeviceID.Code[4] == 0x78 )
+		{
+			if ( TotalMediaNum == 4 )
+			{
+				nDevInfo->Feature.WCtime = 45;
+
+				nDevInfo->Feature.WriteSTP 	= 0;
+				nDevInfo->Feature.WriteWP 	= 30;
+				nDevInfo->Feature.WriteHLD 	= 15;
+
+				nDevInfo->Feature.ReadSTP	= 0;
+				nDevInfo->Feature.ReadPW 	= 30;
+				nDevInfo->Feature.ReadHLD 	= 15;
+
+				NAND_IO_SetCycle( nDevInfo );
+			}
+		}
+		//**************************************************************
+		// Case on K9MDG08U5D Samsung NANDFLASH
+		//**************************************************************
+		else if ( nDevInfo->Feature.DeviceID.Code[0] == 0xEC &&
+			 	  nDevInfo->Feature.DeviceID.Code[1] == 0xD7 &&
+			 	  nDevInfo->Feature.DeviceID.Code[2] == 0xD5 &&
+			 	  nDevInfo->Feature.DeviceID.Code[3] == 0x29 &&
+			 	  nDevInfo->Feature.DeviceID.Code[4] == 0x38 )
+		{
+			if ( TotalMediaNum == 2 )
+			{
+				nDevInfo->Feature.WCtime = 45;
+
+				nDevInfo->Feature.WriteSTP 	= 0;
+				nDevInfo->Feature.WriteWP 	= 30;
+				nDevInfo->Feature.WriteHLD 	= 15;
+
+				nDevInfo->Feature.ReadSTP	= 0;
+				nDevInfo->Feature.ReadPW 	= 30;
+				nDevInfo->Feature.ReadHLD 	= 15;
+
+				NAND_IO_SetCycle( nDevInfo );
+			}
+		}
+		//**************************************************************
+		// Case on TH58NVG5D4CTG20 Toshiba NANDFLASH
+		//**************************************************************
+		else if ( nDevInfo->Feature.DeviceID.Code[0] == 0x98 &&
+			 	  nDevInfo->Feature.DeviceID.Code[1] == 0xD5 &&
+			 	  nDevInfo->Feature.DeviceID.Code[2] == 0x85 &&
+			 	  nDevInfo->Feature.DeviceID.Code[3] == 0xA5 )
+		{
+			if ( TotalMediaNum == 2 )
+			{
+				nDevInfo->Feature.WCtime = 30;
+
+				nDevInfo->Feature.WriteSTP 	= 0;
+				nDevInfo->Feature.WriteWP 	= 20;
+				nDevInfo->Feature.WriteHLD 	= 10;
+
+				nDevInfo->Feature.ReadSTP	= 0;
+				nDevInfo->Feature.ReadPW 	= 20;
+				nDevInfo->Feature.ReadHLD 	= 10;
+
+				NAND_IO_SetCycle( nDevInfo );
+			}
+		}
+	}
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_SetCycle
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_SetCycle( NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned int	nMaxBusClk;
+	unsigned int	nMaxBusClkMHZ;
+	unsigned int	nCycleTick;
+	unsigned int	nTickRange = 10;
+	unsigned int	nDevSTP, nDevPW, nDevHLD;
+	unsigned int	nMCycleSTP, nMCyclePW, nMCycleHLD;
+	unsigned int	nSCycleSTP, nSCyclePW, nSCycleHLD;
+	int				nRemainSTP, nRemainPW, nRemainHLD;
+	int				nTempResult;
+	unsigned int	nReCompRatioSTP, nReCompRatioHLD, nReCompRatioPW;
+	unsigned int	nWrCompRatioSTP, nWrCompRatioHLD, nWrCompRatioPW;
+	unsigned int	nCoCompRatioSTP, nCoCompRatioHLD, nCoCompRatioPW;	
+	unsigned int	nReGateDelay, nWrGateDelay;
+
+	//===================================
+	// Get Max Bus CLK
+	//===================================
+	#ifdef FWDN_DOWNLOADER_INCLUDE
+	nMaxBusClk = 1000000;	// 100MHZ
+	#elif defined(TCC89XX) || defined(TCC92XX)
+	{
+		#if defined(_WINCE_)
+			#if defined(USE_V_ADDRESS)
+			nMaxBusClk = tcc_ckc_getfbusctrl(CLKCTRL4);		
+			#else
+			tca_ckc_init();
+			nMaxBusClk = tca_ckc_getfbusctrl(CLKCTRL4);
+			#endif
+		#elif defined(_LINUX_)
+			tca_ckc_init();
+			nMaxBusClk = tca_ckc_getfbusctrl(CLKCTRL4);
+		#else
+		    //#ifdef CLOCK_ADJUST_ENABLE
+		    //nMaxBusClk	= IO_CKC_GetCurrentBUSClock4Cycle();
+		    //#else
+		    //nMaxBusClk = IO_CKC_Fmaxbus;	// frequency of 100Hz unit
+		    //#endif
+			nMaxBusClk = 1660000;
+		
+		#endif
+	}
+	#endif
+
+	if ( nMaxBusClk  == 0 )
+		nMaxBusClk = 1660000;
+
+	/* Convert MHZ Value of Max Bus Clock */
+	if (!( nMaxBusClk / 10000 ))
+		return ERR_NAND_IO_WRONG_PARAMETER;
+	nMaxBusClkMHZ = ( nMaxBusClk / 10000 );
+
+	/* Get Cycke Tick */
+	nCycleTick = ( 1000 * nTickRange ) / nMaxBusClkMHZ;
+	if (( 1000 * nTickRange ) % nMaxBusClkMHZ )
+		++nCycleTick;
+
+	//===================================
+	// Set Cycle
+	//===================================
+
+	/* Basis Setting */
+	#if defined(TCC89XX) || defined(TCC92XX)	
+	nReGateDelay	= 15;	
+	nWrGateDelay	= 0;
+	#else
+	nReGateDelay	= 15;	
+	nWrGateDelay	= 0;
+	#endif
+	
+	nReCompRatioSTP	= 6;
+	nReCompRatioHLD	= 0;
+	nReCompRatioPW	= 0;
+	
+	nWrCompRatioSTP	= 6;
+	nWrCompRatioHLD	= 0;
+	nWrCompRatioPW	= 0;
+
+	nCoCompRatioSTP	= 0;
+	nCoCompRatioHLD	= 0;
+	nCoCompRatioPW	= 0;
+
+	/* Read Cycle */
+	nDevSTP				= nDevInfo->Feature.ReadSTP * nTickRange;
+	nDevPW				= nDevInfo->Feature.ReadPW * nTickRange;
+	nDevHLD				= nDevInfo->Feature.ReadHLD * nTickRange;
+	
+	nMCycleSTP			= ( nDevSTP / nCycleTick ) + (( nDevSTP && !( nDevSTP / nCycleTick )) ? 1 : 0 );
+	nMCycleHLD			= ( nDevHLD / nCycleTick ) + (( nDevHLD && !( nDevHLD / nCycleTick )) ? 1 : 0 );
+	nRemainSTP			= ( nMCycleSTP * nCycleTick ) - nDevSTP;
+	nRemainHLD			= ( nMCycleHLD * nCycleTick ) - nDevHLD;
+	nSCycleSTP			= (( nRemainSTP < 0 ) && ((( nRemainSTP >= 0 ) ? nRemainSTP : -nRemainSTP ) > (int)(( nCycleTick / 10 ) * nReCompRatioSTP ))) ? 1 : 0;
+	nSCycleHLD			= (( nRemainHLD < 0 ) && ((( nRemainHLD >= 0 ) ? nRemainHLD : -nRemainHLD ) > (int)(( nCycleTick / 10 ) * nReCompRatioHLD ))) ? 1 : 0;
+	nTempResult			= ( nDevPW + ( nReGateDelay * nTickRange )) + (( nRemainSTP >= 0 ) ? 0 : -nRemainSTP ) + (( nRemainHLD >= 0 ) ? 0 : -nRemainHLD );
+	nMCyclePW			= ( nTempResult >= (int)nCycleTick ) ? ( nTempResult / nCycleTick ) : 1;
+	nRemainPW			= ( nMCyclePW * nCycleTick ) - ( nDevPW + ( nReGateDelay * nTickRange ));
+	nSCyclePW			= (( nRemainPW < 0 ) && ((( nRemainPW >= 0 ) ? nRemainPW : -nRemainPW ) > (int)(( nCycleTick / 10 ) * nReCompRatioPW ))) ? 1 : 0;
+
+	ReadCycleTime.STP	= (U8)(nMCycleSTP + nSCycleSTP);
+	ReadCycleTime.HLD	= (U8)(nMCycleHLD + nSCycleHLD);
+	ReadCycleTime.PW	= (U8)(nMCyclePW + nSCyclePW + (( nDevInfo->Feature.MediaType & A_PARALLEL ) ? 1: 0 ));
+
+	/* Write Cycle */
+	nDevSTP				= nDevInfo->Feature.WriteSTP * nTickRange;
+	nDevPW				= nDevInfo->Feature.WriteWP * nTickRange;
+	nDevHLD				= nDevInfo->Feature.WriteHLD * nTickRange;
+	
+	nMCycleSTP			= ( nDevSTP / nCycleTick ) + (( nDevSTP && !( nDevSTP / nCycleTick )) ? 1 : 0 );
+	nMCycleHLD			= ( nDevHLD / nCycleTick ) + (( nDevHLD && !( nDevHLD / nCycleTick )) ? 1 : 0 );
+	nRemainSTP			= ( nMCycleSTP * nCycleTick ) - nDevSTP;
+	nRemainHLD			= ( nMCycleHLD * nCycleTick ) - nDevHLD;
+	nSCycleSTP			= (( nRemainSTP < 0 ) && ((( nRemainSTP >= 0 ) ? nRemainSTP : -nRemainSTP ) > (int)(( nCycleTick / 10 ) * nWrCompRatioSTP ))) ? 1 : 0;
+	nSCycleHLD			= (( nRemainHLD < 0 ) && ((( nRemainHLD >= 0 ) ? nRemainHLD : -nRemainHLD ) > (int)(( nCycleTick / 10 ) * nWrCompRatioHLD ))) ? 1 : 0;
+	nTempResult			= ( nDevPW + ( nWrGateDelay * nTickRange )) + (( nRemainSTP >= 0 ) ? 0 : -nRemainSTP ) + (( nRemainHLD >= 0 ) ? 0 : -nRemainHLD );
+	nMCyclePW			= ( nTempResult >= (int)nCycleTick ) ? ( nTempResult / nCycleTick ) : 1;
+	nRemainPW			= ( nMCyclePW * nCycleTick ) - ( nDevPW + ( nWrGateDelay * nTickRange ));
+	nSCyclePW			= (( nRemainPW < 0 ) && ((( nRemainPW >= 0 ) ? nRemainPW : -nRemainPW ) > (int)(( nCycleTick / 10 ) * nWrCompRatioPW ))) ? 1 : 0;
+
+	WriteCycleTime.STP	= (U8)(nMCycleSTP + nSCycleSTP);
+	WriteCycleTime.HLD	= (U8)(nMCycleHLD + nSCycleHLD);
+	WriteCycleTime.PW	= (U8)(nMCyclePW + nSCyclePW);
+	
+	/* Comm Cycle */
+	nDevSTP				= 10 * nTickRange;
+	nDevPW				= 80 * nTickRange;
+	nDevHLD				= 40 * nTickRange;
+	
+	nMCycleSTP			= ( nDevSTP / nCycleTick ) + (( nDevSTP && !( nDevSTP / nCycleTick )) ? 1 : 0 );
+	nMCycleHLD			= ( nDevHLD / nCycleTick ) + (( nDevHLD && !( nDevHLD / nCycleTick )) ? 1 : 0 );
+	nRemainSTP			= ( nMCycleSTP * nCycleTick ) - nDevSTP;
+	nRemainHLD			= ( nMCycleHLD * nCycleTick ) - nDevHLD;
+	nSCycleSTP			= (( nRemainSTP < 0 ) && ((( nRemainSTP >= 0 ) ? nRemainSTP : -nRemainSTP ) > (int)(( nCycleTick / 10 ) * nCoCompRatioSTP ))) ? 1 : 0;
+	nSCycleHLD			= (( nRemainHLD < 0 ) && ((( nRemainHLD >= 0 ) ? nRemainHLD : -nRemainHLD ) > (int)(( nCycleTick / 10 ) * nCoCompRatioHLD ))) ? 1 : 0;
+	nTempResult			= ( nDevPW + ( nReGateDelay * nTickRange )) + (( nRemainSTP >= 0 ) ? 0 : -nRemainSTP ) + (( nRemainHLD >= 0 ) ? 0 : -nRemainHLD );
+	nMCyclePW			= ( nTempResult >= (int)nCycleTick ) ? ( nTempResult / nCycleTick ) : 1;
+	nRemainPW			= ( nMCyclePW * nCycleTick ) - ( nDevPW + ( nReGateDelay * nTickRange ));
+	nSCyclePW			= (( nRemainPW < 0 ) && ((( nRemainPW >= 0 ) ? nRemainPW : -nRemainPW ) > (int)(( nCycleTick / 10 ) * nCoCompRatioPW ))) ? 1 : 0;
+
+	CommCycleTime.STP	= (U8)(nMCycleSTP + nSCycleSTP);
+	CommCycleTime.HLD	= (U8)(nMCycleHLD + nSCycleHLD);
+	CommCycleTime.PW	= (U8)(nMCyclePW + nSCyclePW);
+
+	if (WriteCycleTime.STP >= 16)
+		WriteCycleTime.STP	= 15;
+	if (WriteCycleTime.PW >= 16)
+		WriteCycleTime.PW	= 15;
+	if (WriteCycleTime.HLD >= 16)
+		WriteCycleTime.HLD	= 15;
+	if (WriteCycleTime.HLD == 0)
+		WriteCycleTime.HLD	= 1;	
+
+	if (ReadCycleTime.STP >= 16)
+		ReadCycleTime.STP	= 15;
+	if (ReadCycleTime.PW >= 16)
+		ReadCycleTime.PW	= 15;
+	if (ReadCycleTime.HLD >= 16)
+		ReadCycleTime.HLD	= 15;
+
+	if (CommCycleTime.STP >= 16)
+		CommCycleTime.STP	= 15;
+	if (CommCycleTime.PW >= 16)
+		CommCycleTime.PW	= 15;
+	if (CommCycleTime.HLD >= 16)
+		CommCycleTime.HLD	= 15;
+
+	if ( gNAND_IO_DataBusType == NAND_IO_NFC_BUS )
+	{
+		WriteCycleTime.RegValue	= ( WriteCycleTime.STP << 8 ) + ( WriteCycleTime.PW << 4 ) + WriteCycleTime.HLD;
+		ReadCycleTime.RegValue	= ( ReadCycleTime.STP << 8 ) + ( ReadCycleTime.PW << 4 ) + ReadCycleTime.HLD;
+		CommCycleTime.RegValue	= ( CommCycleTime.STP << 8 ) + ( CommCycleTime.PW << 4 ) + CommCycleTime.HLD;
+	}
+	else if ( gNAND_IO_DataBusType == NAND_IO_MEM_BUS )
+	{
+		#if defined(TCC860x)
+			WriteCycleTime.RegValue	= ( WriteCycleTime.STP << 6 ) + ( WriteCycleTime.PW << 3 ) + WriteCycleTime.HLD;
+			ReadCycleTime.RegValue	= ( ReadCycleTime.STP << 6 ) + ( ReadCycleTime.PW << 3 ) + ReadCycleTime.HLD;
+			CommCycleTime.RegValue	= ( CommCycleTime.STP << 6 ) + ( CommCycleTime.PW << 3 ) + CommCycleTime.HLD;
+		#else
+		    WriteCycleTime.RegValue	= ( WriteCycleTime.STP << 11 ) + (( WriteCycleTime.PW - 1 ) << 3 ) + WriteCycleTime.HLD;
+		    ReadCycleTime.RegValue	= ( ReadCycleTime.STP << 11 ) + (( ReadCycleTime.PW - 1 ) << 3 ) + ReadCycleTime.HLD;
+		    CommCycleTime.RegValue	= ( CommCycleTime.STP << 11 ) + (( CommCycleTime.PW - 1 ) << 3 ) + CommCycleTime.HLD;
+		#endif
+	}
+
+//#if defined(USE_V_ADDRESS)
+//	#if defined(_LINUX_)
+//	printk("[NAND        ] [BClk %dMHZ][1Tick %d][RE-S:%d,P:%d,H:%d][WR-S:%d,P:%d,H:%d][COM-S:%d,P:%d,H:%d]\n",
+//	nMaxBusClkMHZ,nCycleTick,ReadCycleTime.STP,ReadCycleTime.PW,ReadCycleTime.HLD,
+//	WriteCycleTime.STP,WriteCycleTime.PW,WriteCycleTime.HLD,CommCycleTime.STP,CommCycleTime.PW,CommCycleTime.HLD );
+//	#elif defined(_WINCE_)
+//	RETAILMSG(1,(	TEXT("[NAND        ] [BClk %dMHZ][1Tick %d][RE-S:%d,P:%d,H:%d][WR-S:%d,P:%d,H:%d][COM-S:%d,P:%d,H:%d]\n"),
+//	nMaxBusClkMHZ,nCycleTick,ReadCycleTime.STP,ReadCycleTime.PW,ReadCycleTime.HLD,
+//	WriteCycleTime.STP,WriteCycleTime.PW,WriteCycleTime.HLD,CommCycleTime.STP,CommCycleTime.PW,CommCycleTime.HLD));
+//	#endif
+//#else
+//	#if defined(_LINUX_)
+//	printf("[NAND        ] [BClk %dMHZ][1Tick %d][RE-S:%d,P:%d,H:%d][WR-S:%d,P:%d,H:%d][COM-S:%d,P:%d,H:%d]\n",
+//	nMaxBusClkMHZ,nCycleTick,ReadCycleTime.STP,ReadCycleTime.PW,ReadCycleTime.HLD,
+//	WriteCycleTime.STP,WriteCycleTime.PW,WriteCycleTime.HLD,CommCycleTime.STP,CommCycleTime.PW,CommCycleTime.HLD );
+//	#elif defined(_WINCE_)
+//	B_RETAILMSG("[NAND        ] [BClk %dMHZ][1Tick %d][RE-S:%d,P:%d,H:%d][WR-S:%d,P:%d,H:%d][COM-S:%d,P:%d,H:%d]\n",
+//	nMaxBusClkMHZ,nCycleTick,ReadCycleTime.STP,ReadCycleTime.PW,ReadCycleTime.HLD,
+//	WriteCycleTime.STP,WriteCycleTime.PW,WriteCycleTime.HLD,CommCycleTime.STP,CommCycleTime.PW,CommCycleTime.HLD );
+//	#endif
+//#endif
+
+
+	gMaxBusClkMHZ = nMaxBusClkMHZ;
+	gCycleTick = nCycleTick;
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_GetDeviceInfo
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_GetDeviceInfo( U16 nChipNo, NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned short int		j,k,l;
+	unsigned char			bFindMedia;
+	unsigned char			bFindMakerNo;
+	unsigned char			bMatchCount;
+	NAND_IO_DEVID			sDeviceCode1,sDeviceCode2;
+	NAND_IO_FEATURE			*sTempFeatureInfo;
+	NAND_IO_FEATURE			*sFindFeatureInfo;
+	NAND_IO_ERROR			res;
+
+	bFindMedia 				= FALSE;
+	nDevInfo->IoStatus		= 0; 
+	nDevInfo->ChipNo		= 0xFF;
+	gInterLeaveCSNum 		= 0;
+	gInterLeaveIoStatus		= 0;
+	gInterLeaveWriteStatus	= MULTI_PLANE_GOOD_BLOCK;
+
+	// Init Variable
+	sTempFeatureInfo	= (NAND_IO_FEATURE*)NAND_SupportMakerInfo.DevInfo[0];
+	sFindFeatureInfo	= (NAND_IO_FEATURE*)NAND_SupportMakerInfo.DevInfo[0];
+
+	//=====================================================================
+	// Search Matched NANDFLASH (x8 Bit Serial NAND)
+	//=====================================================================
+	for ( j = 0; j < 3; ++j )	/* Check Read ID during 3 turn */
+	{
+		//IO_CKC_EnableBUS( IO_CKC_BUS_NFC );
+		// 16Bit NAND Mask Disable
+		BITCLR( pNFC->NFC_CTRL, HwNFC_CTRL_MASK_EN );
+
+		/* Read Device CODE */
+		NAND_IO_ResetForReadID( nChipNo, NAND_IO_SERIAL_COMBINATION_MODE );			// x8 Bit NAND Search
+		NAND_IO_ReadID( nChipNo, &sDeviceCode1, NAND_IO_SERIAL_COMBINATION_MODE );	// x8 Bit NAND Search
+
+		/* Check Maker ID */
+		bFindMakerNo = 0xFF;
+		for ( k = 0; k < MAX_SUPPORT_MAKER_NAND; ++k )
+		{
+			if ( sDeviceCode1.Code[0] == NAND_SupportMakerInfo.MakerID[k] )
+			{
+				bFindMakerNo		= (unsigned char)k;
+				sTempFeatureInfo	= (NAND_IO_FEATURE*)NAND_SupportMakerInfo.DevInfo[k];
+				break;
+			}	
+		}
+			
+		if ( bFindMakerNo >= MAX_SUPPORT_MAKER_NAND )
+			continue;
+
+		/* Check Device ID */
+		for ( k = 0; k < NAND_SupportMakerInfo.MaxSupportNAND[bFindMakerNo]; ++k )
+		{
+			bMatchCount = 0;
+			
+			for ( l = 0; l < 5; ++l )
+			{
+				if ( sTempFeatureInfo->DeviceID.Code[l+1] == 0x00 )
+					++bMatchCount;
+				else if ( sDeviceCode1.Code[l+1] == sTempFeatureInfo->DeviceID.Code[l+1] )
+					++bMatchCount;
+			}
+
+			/* Found NAND Device */
+			if ( bMatchCount >= 5 )
+			{
+				bFindMedia = TRUE;
+				sFindFeatureInfo = sTempFeatureInfo;
+				break;
+			}
+			else
+				++sTempFeatureInfo;
+		}
+
+		/* Found NAND Device */
+		if ( bFindMedia == TRUE )
+			break;
+	}
+
+	if ( bFindMedia != TRUE )
+	{
+		//=====================================================================
+		// Search Matched NANDFLASH (x16 Bit Serial NAND)
+	//=====================================================================
+	for ( j = 0; j < 3; ++j )	/* Check Read ID during 3 turn */
+	{
+			//IO_CKC_EnableBUS( IO_CKC_BUS_NFC );
+			// 16Bit NAND Mask Enable
+			BITSET( pNFC->NFC_CTRL, HwNFC_CTRL_MASK_EN );
+
+		    /* Read Device CODE */
+			NAND_IO_ResetForReadID( nChipNo, NAND_IO_PARALLEL_COMBINATION_MODE );			// x16 Bit NAND Command
+			NAND_IO_ReadID( nChipNo, &sDeviceCode1, NAND_IO_PARALLEL_COMBINATION_MODE );	// x16 Bit NAND Search
+    
+		    /* Check Maker ID */
+		    bFindMakerNo = 0xFF;
+		    for ( k = 0; k < MAX_SUPPORT_MAKER_NAND; ++k )
+		    {
+			    if ( sDeviceCode1.Code[0] == NAND_SupportMakerInfo.MakerID[k] )
+			    {
+				    bFindMakerNo		= (unsigned char)k;
+				    sTempFeatureInfo	= (NAND_IO_FEATURE*)NAND_SupportMakerInfo.DevInfo[k];
+				    break;
+			    }	
+		    }
+			    
+		    if ( bFindMakerNo >= MAX_SUPPORT_MAKER_NAND )
+			    continue;
+    
+		    /* Check Device ID */
+		    for ( k = 0; k < NAND_SupportMakerInfo.MaxSupportNAND[bFindMakerNo]; ++k )
+		    {
+			    bMatchCount = 0;
+			    
+			    for ( l = 0; l < 5; ++l )
+			    {
+				    if ( sTempFeatureInfo->DeviceID.Code[l+1] == 0x00 )
+					    ++bMatchCount;
+				    else if ( sDeviceCode1.Code[l+1] == sTempFeatureInfo->DeviceID.Code[l+1] )
+					    ++bMatchCount;
+			    }
+    
+			    /* Found NAND Device */
+			    if ( bMatchCount >= 5 )
+			    {
+				    bFindMedia = TRUE;
+				    sFindFeatureInfo = sTempFeatureInfo;
+				    break;
+			    }
+			    else
+				    ++sTempFeatureInfo;
+		    }
+    
+		    /* Found NAND Device */
+		    if ( bFindMedia == TRUE )
+			    break;
+	    }
+	}
+
+	//=====================================================================
+	// If Media is founded
+	//=====================================================================
+	if ( bFindMedia == TRUE )
+	{
+		/* Get NAND Feature Info */
+		memcpy( (void*)&nDevInfo->Feature,
+			 	(void*)sFindFeatureInfo,
+				sizeof(NAND_IO_FEATURE) );
+
+		/* Get ECC Type Info */
+		if ( nDevInfo->Feature.MediaType & A_SLC )
+		{
+			nDevInfo->EccType = TYPE_ECC_FOR_1BIT_SLC_NANDFLASH;
+			nDevInfo->EccDataSize = 10;
+
+			if ( nDevInfo->Feature.MediaType & A_16BIT )
+				nDevInfo->EccDataSize = 12;
+		}
+		else if ( nDevInfo->Feature.MediaType & A_MLC )
+		{
+			nDevInfo->EccType = TYPE_ECC_FOR_4BIT_MLC_NANDFLASH;
+			nDevInfo->EccDataSize = 10;
+		}
+		else if ( nDevInfo->Feature.MediaType & A_MLC_8BIT )
+		{
+			nDevInfo->EccType = TYPE_ECC_FOR_8BIT_MLC_NANDFLASH;
+			nDevInfo->EccDataSize = 20;
+			nDevInfo->Feature.SpareSize = 192;
+		}
+		else if ( nDevInfo->Feature.MediaType & A_MLC_12BIT )
+		{
+			nDevInfo->EccType = TYPE_ECC_FOR_12BIT_MLC_NANDFLASH;
+			nDevInfo->EccDataSize = 20;
+			nDevInfo->Feature.SpareSize = 192;
+		}
+			
+		if ( nDevInfo->Feature.PageSize == 4096 )
+			nDevInfo->DistrictNum = 1024;
+		else
+			nDevInfo->DistrictNum = 2048;
+		
+		//=====================================================================
+		//EXCEPTION: TH58NVG4D1D/5D1DTG20 TH58NVG6D1DTG20
+		//=====================================================================
+		if ( ( nDevInfo->Feature.DeviceID.Code[0]== 0x98 ) &&  ( nDevInfo->Feature.DeviceID.Code[1] == 0xD5 ) && ( nDevInfo->Feature.DeviceID.Code[2] == 0x94 ))
+			nDevInfo->DistrictNum = 2048;
+
+		if ( ( nDevInfo->Feature.DeviceID.Code[0]== 0x98 ) &&  ( nDevInfo->Feature.DeviceID.Code[1] == 0xD7 ) )
+			nDevInfo->DistrictNum = 2048;
+
+		if ( nDevInfo->Feature.MediaType & A_08BIT )
+		{
+		    #ifndef NAND_8BIT_ONLY
+		    /* Check if compositin of NAND is parallel or serial */
+		    NAND_IO_ResetForReadID( nChipNo, NAND_IO_PARALLEL_COMBINATION_MODE );
+		    NAND_IO_ReadID( nChipNo, &sDeviceCode2, NAND_IO_PARALLEL_COMBINATION_MODE );
+    
+		    if ( ((sDeviceCode2.Code[0] & 0xFF) == ((sDeviceCode2.Code[0] >> 8) & 0xFF)) &&
+			     ((sDeviceCode2.Code[1] & 0xFF) == ((sDeviceCode2.Code[1] >> 8) & 0xFF)) &&
+			     ((sDeviceCode2.Code[2] & 0xFF) == ((sDeviceCode2.Code[2] >> 8) & 0xFF)) &&
+			     ((sDeviceCode2.Code[3] & 0xFF) == ((sDeviceCode2.Code[3] >> 8) & 0xFF)) &&
+			     ((sDeviceCode2.Code[4] & 0xFF) == ((sDeviceCode2.Code[4] >> 8) & 0xFF)) )
+		    {
+			    nDevInfo->Feature.MediaType |= A_PARALLEL;
+				nDevInfo->Feature.MediaType |= A_DATA_WITDH_16BIT;
+			    nDevInfo->Feature.PageSize *= 2;
+			    nDevInfo->Feature.SpareSize *= 2;
+    
+			    if ( ( ( nDevInfo->Feature.MediaType & A_MLC ) || (nDevInfo->Feature.MediaType & A_SLC ) ) && ( nDevInfo->Feature.MediaType & A_BIG ) )
+			    {
+				    nDevInfo->EccDataSize +=2;
+			    }
+			    
+			    nDevInfo->CmdMask = 0xFFFF;
+		    }
+		    else
+		    {
+				nDevInfo->Feature.MediaType |= A_DATA_WITDH_08BIT;				
+			    nDevInfo->CmdMask = 0x00FF;
+		    }
+    
+		    #else
+				nDevInfo->Feature.MediaType |= A_DATA_WITDH_08BIT;				
+			    nDevInfo->CmdMask = 0x00FF;
+		    #endif
+		}
+		else
+		{
+			//IO_CKC_EnableBUS( IO_CKC_BUS_NFC );
+			// 16Bit NAND Mask Enable
+			BITSET( pNFC->NFC_CTRL, HwNFC_CTRL_MASK_EN );
+			nDevInfo->Feature.MediaType |= A_DATA_WITDH_16BIT;
+			nDevInfo->CmdMask = 0x00FF;
+		}
+
+		
+		/* Get Total Partial Page [512+16Bytes] */
+		nDevInfo->PPages = ( nDevInfo->Feature.PageSize / 512 );
+		
+		/* Get Shift Factors of PBpV, PpB, PageSize, SpareSize, PPages */
+		res = (NAND_IO_ERROR)SUCCESS;
+		res |= NAND_IO_GetShiftValueForFastMultiPly( nDevInfo->Feature.PBpV, &nDevInfo->ShiftPBpV );
+		res |= NAND_IO_GetShiftValueForFastMultiPly( nDevInfo->Feature.PpB, &nDevInfo->ShiftPpB );
+		res |= NAND_IO_GetShiftValueForFastMultiPly( nDevInfo->Feature.PageSize, &nDevInfo->ShiftPageSize );
+		//res |= NAND_IO_GetShiftValueForFastMultiPly( nDevInfo->Feature.SpareSize, &nDevInfo->ShiftSpareSize );
+		res |= NAND_IO_GetShiftValueForFastMultiPly( nDevInfo->PPages, &nDevInfo->ShiftPPages );
+		res |= NAND_IO_GetShiftValueForFastMultiPly( nDevInfo->DistrictNum, &nDevInfo->ShiftDistrictNum );
+
+		if ( res != SUCCESS )
+			return res;
+		
+		for ( j = 0; j < 4; ++j )
+		{
+			nDevInfo->BadBlockInfo.BlockStatus[j] 	= MULTI_PLANE_GOOD_BLOCK;
+			nDevInfo->BadBlockInfo.BadBlkPHYAddr[j] = 0xFFFFFFFF;
+		}
+
+		NAND_IO_SetCycle( nDevInfo );
+	}
+	//=====================================================================
+	// Not Found
+	//=====================================================================
+	else
+	{
+		return ERR_NAND_IO_FAILED_GET_DEVICE_INFO;
+	}
+
+	nDevInfo->IoStatus	= NAND_IO_STATUS_ENABLE;
+	nDevInfo->ChipNo	= nChipNo;
+
+	//=====================================================================
+	// gDevInfo( Global Variable ) Initialize 
+	//=====================================================================
+	if ( nDevInfo->ChipNo == 0 )
+		gDevInfo = (NAND_IO_DEVINFO *)nDevInfo;
+	
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	U32		NAND_IO_GetBUSTypeOfDataIO( void )
+*
+*	Input	: NONE
+*	Output	: NONE
+*	Return	: NONE
+*
+*	Description : Initialize NAND IO Layer
+*
+*******************************************************************************/
+U32 NAND_IO_GetBUSTypeOfDataIO( void )
+{
+	return gNAND_IO_DataBusType;
+}
+
+void NAND_IO_ECC_InfoInit( void )
+{
+	gMLC_ECC_4Bit.ErrorCodeNum 			= 2;
+	gMLC_ECC_4Bit.EncodeFlag			= HwECC_IREQ_M4EF;
+	gMLC_ECC_4Bit.DecodeFlag			= HwECC_IREQ_M4DF;
+	gMLC_ECC_4Bit.ErrorNum				= 4;
+	gMLC_ECC_4Bit.All_FF_512_ECC_Code	= (U8 *)&ALL_FF_ECC_BCH_04BIT_512;
+		
+	gMLC_ECC_8Bit.ErrorCodeNum 			= 4;
+	gMLC_ECC_8Bit.EncodeFlag			= HwECC_IREQ_M8EF;
+	gMLC_ECC_8Bit.DecodeFlag			= HwECC_IREQ_M8DF;
+	gMLC_ECC_8Bit.ErrorNum				= 8;
+	gMLC_ECC_8Bit.All_FF_512_ECC_Code	= (U8 *)&ALL_FF_ECC_BCH_08BIT_512;
+
+	gMLC_ECC_12Bit.ErrorCodeNum 		= 5;
+	gMLC_ECC_12Bit.EncodeFlag			= HwECC_IREQ_M12EF;
+	gMLC_ECC_12Bit.DecodeFlag			= HwECC_IREQ_M12DF;
+	gMLC_ECC_12Bit.ErrorNum 			= 12;
+	gMLC_ECC_12Bit.All_FF_512_ECC_Code	= (U8 *)&ALL_FF_ECC_BCH_12BIT_512;
+
+	gMLC_ECC_14Bit.ErrorCodeNum 		= 6;
+	gMLC_ECC_14Bit.EncodeFlag			= HwECC_IREQ_M14EF;
+	gMLC_ECC_14Bit.DecodeFlag			= HwECC_IREQ_M14DF;
+	gMLC_ECC_14Bit.ErrorNum 			= 14;
+	gMLC_ECC_14Bit.All_FF_512_ECC_Code	= (U8 *)&ALL_FF_ECC_BCH_14BIT_512;
+
+	gMLC_ECC_16Bit.ErrorCodeNum 		= 7;
+	gMLC_ECC_16Bit.EncodeFlag			= HwECC_IREQ_M16EF;
+	gMLC_ECC_16Bit.DecodeFlag			= HwECC_IREQ_M16DF;
+	gMLC_ECC_16Bit.ErrorNum 			= 16;
+	gMLC_ECC_16Bit.All_FF_512_ECC_Code	= (U8 *)&ALL_FF_ECC_BCH_16BIT_512;
+}
+
+void NAND_IO_InitDMABuffer( void )
+{
+	#if defined(_WINCE_)
+	tSYSTEM_PARAM	*pSYS_Work_PARAM	= (tSYSTEM_PARAM*)(SYSTEM_PARAM_BASEADDRESS);
+	#endif
+	
+	#if defined(_WINCE_)
+	gpDMA_PhyBuffer0 	= (unsigned int*)pSYS_Work_PARAM->DMA2.CH0_BUFFER;	// Working Address
+	gpDMA_WorkBuffer0 	= (unsigned int*)pSYS_PARAM->DMA2.CH0_BUFFER;		// Physical Address
+	gpDMA_PhyBuffer1 	= (unsigned int*)pSYS_Work_PARAM->DMA2.CH1_BUFFER;	// Working Address
+	gpDMA_WorkBuffer1 	= (unsigned int*)pSYS_PARAM->DMA2.CH1_BUFFER;		// Physical Address	
+	#elif defined(_LINUX_)
+	#ifdef KERNEL_DRIVER
+	gpDMA_PhyBuffer0 	= dma_t.dma_addr;
+	gpDMA_WorkBuffer0	= (unsigned int*)dma_t.v_addr;
+	gpDMA_PhyBuffer1 	= (unsigned char*)gpDMA_PhyBuffer0 + 512;
+	gpDMA_WorkBuffer1	= (unsigned char*)gpDMA_WorkBuffer0 + 512;
+	#else
+	gpDMA_PhyBuffer0 	= (unsigned int*)DMA_ADDR;
+	gpDMA_WorkBuffer0	= (unsigned int*)DMA_ADDR;
+	gpDMA_PhyBuffer1 	= (unsigned int*)DMA_ADDR + 512;
+	gpDMA_WorkBuffer1	= (unsigned int*)DMA_ADDR + 512;	
+	#endif
+	#else		// NU
+	gpDMA_PhyBuffer0 	= (unsigned int*)gpNandBuffer;
+	gpDMA_WorkBuffer0	= (unsigned int*)gpNandBuffer;
+	gpDMA_PhyBuffer1 	= (unsigned char*)gpDMA_PhyBuffer0 + 512;
+	gpDMA_WorkBuffer1	= (unsigned char*)gpDMA_WorkBuffer0 + 512;
+	#endif
+}
+
+/******************************************************************************
+*
+*	void    NAND_IO_Init( void )
+*
+*	Input	: NONE
+*	Output	: NONE
+*	Return	: NONE
+*
+*	Description : Initialize NAND IO Layer
+*
+*******************************************************************************/
+void NAND_IO_Init( void )
+{
+	unsigned int		i;
+	PEDI				pEDI;
+	PPIC 				pPIC;
+	NAND_IO_DEVINFO		sDevInfo;
+	NAND_IO_ERROR		res;
+	
+	memset( &sDevInfo, 0x00, sizeof(NAND_IO_DEVINFO));
+
+#if defined(USE_V_ADDRESS)
+	#if defined(_LINUX_)
+	pGPIO 		= (PGPIO)(&HwGPIO_BASE);
+	pEDI 		= (PEDI)(&HwEDI_BASE);
+	pNFC 		= (PNFC)(&HwNFC_BASE);
+	pECC 		= (PECC)(&HwECC_BASE);
+	pIOBUSCFG_T = (PIOBUSCFG)(&HwIOBUSCFG_BASE);
+	pNAND_DMA	= (PGDMANCTRL)(&HwGDMA2_BASE);
+	#if defined(_WINCE_)
+	pSYS_PARAM	= (ptSYSTEM_PARAM)(&SYSTEM_PARAM_BASEADDRESS);
+	#endif
+	pPIC		= (PPIC)(&HwPIC_BASE);
+	#elif defined(_WINCE_)
+	pGPIO 		= (PGPIO)tcc_allocbaseaddress((unsigned int)&HwGPIO_BASE);
+	pEDI 		= (PEDI)tcc_allocbaseaddress((unsigned int)&HwEDI_BASE);
+	pNFC 		= (PNFC)tcc_allocbaseaddress((unsigned int)&HwNFC_BASE);
+	pECC 		= (PECC)tcc_allocbaseaddress((unsigned int)&HwECC_BASE);
+	pIOBUSCFG_T = (PIOBUSCFG)tcc_allocbaseaddress((unsigned int)&HwIOBUSCFG_BASE);
+	pPIC		= (PPIC)tcc_allocbaseaddress((unsigned int)&HwPIC_BASE);
+	pSYS_PARAM	= (tSYSTEM_PARAM*)tcc_allocbaseaddress((unsigned int)SYSTEM_PARAM_BASEADDRESS);
+	pNAND_DMA	= (PGDMANCTRL)tcc_allocbaseaddress((unsigned int)&HwGDMA2_BASE);
+	#endif
+#else
+	pGPIO 		= (PGPIO)(&HwGPIO_BASE);
+	pEDI 		= (PEDI)(&HwEDI_BASE);
+	pNFC 		= (PNFC)(&HwNFC_BASE);
+	pECC 		= (PECC)(&HwECC_BASE);
+	pIOBUSCFG_T = (PIOBUSCFG)(&HwIOBUSCFG_BASE);
+	pPIC		= (PPIC)(&HwPIC_BASE);
+	#if defined(_WINCE_)
+	pSYS_PARAM	= (tSYSTEM_PARAM*)(SYSTEM_PARAM_BASEADDRESS);
+	#endif
+	pNAND_DMA	= (PGDMANCTRL)(&HwGDMA2_BASE);
+#endif
+
+	/*************************************/
+	/*Don't remove NAND_IO_Delay Function*/
+	/*************************************/
+	for( i = 0; i < 5000; ++i )
+		NAND_IO_Delay();
+
+	for ( i = 0; i < 2; ++i )
+	{
+		/***********************************/
+		/* Setting NANDFLASH on Memory Bus */
+		/***********************************/		
+		if ( i == 0 )
+		{
+			ASM_NOP;
+		}
+		/********************************/
+		/* Setting NANDFLASH on NFC Bus */
+		/********************************/		
+		else
+		{
+			#if defined(TCC89XX) || defined(TCC92XX)
+			// Set ECC Code Register Base Address
+			//gHwECC	= ( ECC *)(&HwECC_BASE);
+			//gHwECCErrorAddr = ( ECCERRADDR *)(&HwECCERRADDR_BASE);
+			#endif
+			
+		    //IO_CKC_EnableBUS( IO_CKC_BUS_NFC );
+
+			//volatile unsigned int	EDI_CTRL;                       //  0x00 R/W 0x00000000 EDI Control Register.
+			//volatile unsigned int	EDI_CSNCFG0;                    //  0x04 R/W 0x00543210 EDI CSN Configuration Register 0.
+			//volatile unsigned int	EDI_CSNCFG1;                    //  0x08 R/W 0x00BA9876 EDI CSN Configuration Register 1.
+			//volatile unsigned int	NOTDEFINE0[2];                  //  Reserved 0x0C R/W - -
+			//volatile unsigned int	EDI_RDYCFG;                     //  0x14 R/W 0x76543210 EDI Ready Configuration Register
+			//volatile unsigned int	NOTDEFINE1[2];                  //  Reserved 0x18 R/W 0x00000000 EDI Time-Out Configuration Register 0
+			//volatile unsigned int	EDI_REQOFF;                     //  0x20 R/W 0x00000000 EDI Request OFF Flag register    
+		
+			pEDI->EDI_RDYCFG 	= 0x00000001;
+			//pEDI->EDI_CSNCFG0	= 0x00403265;
+			BITCSET(pEDI->EDI_CSNCFG0, 0xFFFF, 0x8765 );
+			
+			#ifdef NAND_8BIT_ONLY
+			pGPIO->GPBFN0 		= 0x11110000;	//NANDXD[7:4]
+			pGPIO->GPBFN1		= 0x00001111;	//NANDXD[3:0]
+			#else
+			pGPIO->GPBFN0 		= 0x11111111;	//NANDXD[11:8],[7:4]
+			pGPIO->GPBFN1 		= 0x11111111;	//NANDXD[15:12],[3:0]
+			#endif
+			pGPIO->GPBFN2 		= 0x11111111;	//{CSN0,XA2,XA1,XA0,OEN1,OEN0,WEN1,WEN0}
+			pGPIO->GPBFN3 		= 0x01011111;  	//{GPIOB[31],CSN1,RDY1,RDY0,XX,XX,XX,XX}
+
+			//=================================================
+			// NAND Write Portect Pin Set
+			//=================================================
+			#if defined(TCC89_92_BOARD)
+			pGPIO->GPBFN3 &= ~0x10000000;		// ND_WP: GPIO_B31
+			#else	// TCC9200S_BOARD
+			pGPIO->GPBFN2 &= ~0x01000000;		// ND_WP: GPIO_B22
+			#endif
+			// Write Protect Pin: Output Mode
+			BITSET( pGPIO->GPBEN, NAND_IO_NFC_nWPBit );
+			
+			//=================================================
+			// TCC9200S_BOARD NAND Ready/Busy Pin Set
+			/* ND_RDY: GPIO_B31 */
+			//=================================================
+			#if defined(TCC9200S_BOARD)
+			pGPIO->GPBFN3 &= ~0x10000000;		// ND_RDY: GPIO_B31			
+			BITCLR(pGPIO->GPBEN, Hw31);
+			#endif
+	    
+		    gNAND_IO_DataBusType	= NAND_IO_NFC_BUS;
+
+		    /* Make Reset */
+		    pNFC->NFC_RST = 0;
+
+		    /* Set Default NFC Configuration */
+		    pNFC->NFC_CTRL	= HwNFC_CTRL_DEN_EN		|
+					          HwNFC_CTRL_CFG_NOACT	|
+					          HwNFC_CTRL_BSIZE_1	|
+						      (4 << 4)				|		// pw = 5
+					          (1 << 0);						// hold = 1
+
+			/* GPIO B Arbitration ENABLE */
+			pNFC->NFC_CTRL1 |= Hw31;
+			pNFC->NFC_CTRL1 |= Hw30;
+
+		    /* Enable Interrupt */
+			pNFC->NFC_IREQ = 0x77;				// Clear Interrupt
+			pPIC->CLR1		= HwINT1_NFC;
+		    BITSET( pPIC->SEL1, HwINT1_NFC);				// Set NFC as IRQ interrupt
+		    BITSET( pPIC->MODE1, HwINT1_NFC );	// Level type for NFC interrupt, IO_INT_HwNFC );	// Level type for NFC interrupt
+
+		    //IO_CKC_DisableBUS( IO_CKC_BUS_NFC );
+		    
+		    /* Searching NANDFLASH */
+		    res = NAND_IO_GetDeviceInfo( 0, &sDevInfo );
+
+			#ifdef SPEED_CHECK
+			{
+				pGPIO->GPFFN0 = 0xFFFFFFFF;
+				pGPIO->GPFEN  = 0xFFFFFFFF;
+				//pGPIO->GPFDAT = 0xFFFFFFFF;
+				pGPIO->GPFDAT = HwZERO;
+			}
+			#endif
+
+		    if ( res == SUCCESS )
+	    		break;	
+		}
+	}
+
+	/* Setup Variable about ECC */
+	//IO_CKC_EnableBUS( IO_CKC_BUS_ECC );
+	pECC->ECC_CTRL	= 0x04000000;		/* ECC Control Register */
+	pECC->ECC_BASE	= pNFC->NFC_WDATA;	/* Base Address for ECC Calculation */
+	pECC->ECC_MASK	= 0x00000000;		/* Address mask for ECC area */
+	//IO_CKC_DisableBUS( IO_CKC_BUS_ECC );	
+
+	memcpy( &rDevInfo, &sDevInfo, sizeof(NAND_IO_DEVINFO) );
+
+	NAND_IO_ECC_InfoInit();
+
+	#ifdef NAND_IO_USE_DMA_ACCESS
+	NAND_IO_InitDMABuffer();
+	#endif
+}
+
+/******************************************************************************
+*
+*	void    NAND_IO_Reset
+*
+*	Input	: Chip Select Number
+*	Output	: NONE
+*	Return	: NONE
+*
+*	Description : Reset NANDFLASH
+*
+*******************************************************************************/
+void NAND_IO_Reset( U16 nChipNo, int nMode )
+{
+	/* Pre Process */
+	NAND_IO_PreProcess();
+	
+	/* Set Setuo Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nChipNo );
+
+	/* Set Data Bus as 16Bit */
+	NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	
+	/* Command RESET [ 0xFF ] */
+	if ( nMode == NAND_IO_PARALLEL_COMBINATION_MODE )
+		pNFC->NFC_CMD = 0xFFFF;
+	else
+		pNFC->NFC_CMD = 0x00FF;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nChipNo );
+
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+	
+}
+
+/******************************************************************************
+*
+*	void    NAND_IO_ResetForReadID
+*
+*	Input	: Chip Select Number
+*	Output	: NONE
+*	Return	: NONE
+*
+*	Description : Reset NANDFLASH
+*
+*******************************************************************************/
+void NAND_IO_ResetForReadID( U16 nChipNo, int nMode )
+{
+	unsigned int	i,j;
+	
+	/* Pre Process */
+	NAND_IO_PreProcess();
+	
+	/* Set Setuo Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nChipNo );
+
+	/* Set Data Bus as 16Bit */
+	NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+
+	/* Command RESET [ 0xFF ] */
+	if ( nMode == NAND_IO_PARALLEL_COMBINATION_MODE )
+		pNFC->NFC_CMD = 0xFFFF;
+	else
+		pNFC->NFC_CMD = 0x00FF;
+
+	/* Wait until it is ready */
+	for ( i = 0; i < 0x100; ++i )
+	{
+		for ( j = 0; j < 0x80; ++j )
+		{
+			ASM_NOP;
+		}
+	}
+
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+	
+}
+
+/******************************************************************************
+*
+*	void    NAND_IO_ReadID
+*
+*	Input	: Chip Select Number
+*			  Mode : 0 => Serial Composition , 1 => Parallel Composition
+*	Output	: NANDFLASH Device Code
+*	Return	: NONE
+*
+*	Description : Get Device Code of NANDFLASH
+*
+*******************************************************************************/
+void NAND_IO_ReadID( U16 nChipNo, NAND_IO_DEVID *nDeviceCode, int nMode )
+{
+	/* Pre Process */
+	NAND_IO_PreProcess();
+
+	/* Set Setup Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nChipNo );
+
+	/* Set Data Bus as 16Bit */
+	NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	
+	/* Parallel Composition */
+	if ( nMode == NAND_IO_PARALLEL_COMBINATION_MODE )
+	{
+		pNFC->NFC_CMD		= 0x9090;	/* Command READ ID [ 0x90 ] */
+		pNFC->NFC_SADDR	= 0x0000;	/* Address [ 0x00 ] */
+	}
+	/* Serial Composition */
+	else
+	{
+		pNFC->NFC_CMD		= 0x0090;	/* Command READ ID [ 0x90 ] */
+		pNFC->NFC_SADDR	= 0x0000;	/* Address [ 0x00 ] */
+	}
+	
+	/* Delay : tAR1[READID] Max 200nS */
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+
+	/* Parallel Composition */
+	if ( nMode == NAND_IO_PARALLEL_COMBINATION_MODE )
+	{
+		nDeviceCode->Code[0] = (U16)pNFC->NFC_SDATA;
+		nDeviceCode->Code[1] = (U16)pNFC->NFC_SDATA;
+		nDeviceCode->Code[2] = (U16)pNFC->NFC_SDATA;
+		nDeviceCode->Code[3] = (U16)pNFC->NFC_SDATA;
+		nDeviceCode->Code[4] = (U16)pNFC->NFC_SDATA;
+		nDeviceCode->Code[5] = (U16)pNFC->NFC_SDATA;
+	}	
+	/* Serial Composition */
+	else
+	{
+		nDeviceCode->Code[0] = (U8)( pNFC->NFC_SDATA & 0xFF );
+		nDeviceCode->Code[1] = (U8)( pNFC->NFC_SDATA & 0xFF );
+		nDeviceCode->Code[2] = (U8)( pNFC->NFC_SDATA & 0xFF );
+		nDeviceCode->Code[3] = (U8)( pNFC->NFC_SDATA & 0xFF );
+		nDeviceCode->Code[4] = (U8)( pNFC->NFC_SDATA & 0xFF );
+		nDeviceCode->Code[5] = (U8)( pNFC->NFC_SDATA & 0xFF );
+	}	
+
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+	
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_ReadSpare
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_ReadSpare( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U8 *nSpareBuffer )
+{
+	unsigned int		RowAddr, ColumnAddr;
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+
+	//=============================================
+	// PreProcess
+	// Set Setup and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP LOW
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_SetNFCBusWidth(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+		NAND_IO_ClearInterleaveStatus( nDevInfo );
+	else
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	NAND_IO_EnableWriteProtect();
+		
+	//=============================================
+	// Read Data
+	//=============================================	
+
+	if ( nDevInfo->Feature.MediaType  & A_BIG )
+	{
+		/* Generate Row and Column Address */
+		res = NAND_IO_GenerateRowColAddrForRead( nPageAddr, ( ( 512 + nDevInfo->EccDataSize ) << nDevInfo->ShiftPPages ), &RowAddr, &ColumnAddr, nDevInfo );
+		if ( res != SUCCESS )
+			goto ErrorReadSpare;
+
+		/* Write Row and Column Address	*/
+		NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+		/* Command READ2 [ 0x30 ] for Advance NandFlash */
+		if ( nDevInfo->Feature.MediaType & A_BIG )
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+		
+		/* Wait until it is ready */
+		NAND_IO_WaitBusy( nDevInfo->ChipNo );
+		
+		/* Read Spare data from NANDFLASH */
+		res = NAND_IO_ReadSpareDataECC( nDevInfo, 
+										nSpareBuffer, 
+										ECC_ON );
+		if ( res != SUCCESS )
+			goto ErrorReadSpare;
+	}
+	else
+	{
+		/* Generate Row and Column Address */
+		res = NAND_IO_GenerateRowColAddrForRead( nPageAddr, 512, &RowAddr, &ColumnAddr, nDevInfo );
+		if ( res != SUCCESS )
+			goto ErrorReadSpare;
+
+		/* Write Row and Column Address	*/
+		NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+		/* Command READ2 [ 0x30 ] for Advance NandFlash */
+		if ( nDevInfo->Feature.MediaType & A_BIG )
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+		
+		/* Wait until it is ready */
+		NAND_IO_WaitBusy( nDevInfo->ChipNo );
+		
+		/* Read Spare data from NANDFLASH */
+		res = NAND_IO_ReadSpareData( nDevInfo,
+									 0,
+									 1,
+									 nSpareBuffer );
+		if ( res != SUCCESS )
+			goto ErrorReadSpare;		
+	}
+	
+							
+ErrorReadSpare:
+	//=============================================
+	// Disable Chip Select
+	// PostProcess
+	//=============================================	
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+	
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_ReadPage
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_ReadPage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
+								U16 nStartPPage, U16 nReadPPSize,
+								U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff )
+{
+	unsigned int		RowAddr, ColumnAddr;
+	unsigned int		nSpareOnOff;
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ) )
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+
+	if ( ( nStartPPage + nReadPPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+	
+	#ifdef READ_SPEED_CHECK
+	pGPIO->GPFDAT = 0;
+	NAND_IO_GPIO_Toggle(Hw7);
+	#endif
+	//=============================================
+	// PreProcess
+	// Set Setup and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP LOW
+	//=============================================	
+	#ifdef READ_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw5);
+	#endif
+	NAND_IO_PreProcess();
+	NAND_IO_SetNFCBusWidth(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+	#ifdef READ_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw5);
+	#endif	
+
+	#ifdef READ_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw6);
+	#endif	
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+		NAND_IO_ClearInterleaveStatus( nDevInfo );
+	else
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	#ifdef READ_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw6);
+	#endif
+
+
+	#ifdef READ_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw4);
+	#endif
+	NAND_IO_EnableWriteProtect();
+	#ifdef READ_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw4);
+	#endif
+
+	//=============================================
+	// Read Data
+	//=============================================	
+	
+	/* Generate Row and Column Address */
+	if ( nDevInfo->Feature.MediaType  & A_BIG )
+		res = NAND_IO_GenerateRowColAddrForRead( nPageAddr, ( ( 512 + nDevInfo->EccDataSize ) * nStartPPage ), &RowAddr, &ColumnAddr, nDevInfo );
+	else
+		res = NAND_IO_GenerateRowColAddrForRead( nPageAddr, ( 528 * nStartPPage ), &RowAddr, &ColumnAddr, nDevInfo );
+	
+	if ( res != SUCCESS )
+		goto ErrorReadPage;
+	#ifdef READ_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw5);
+	#endif
+
+	/* Write Row and Column Address	*/
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+
+	#ifdef READ_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw5);
+	#endif
+	
+	/* Command READ2 [ 0x30 ] for Advance NandFlash */
+	if ( nDevInfo->Feature.MediaType & A_BIG )
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+
+	#ifdef READ_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw6);
+	#endif
+	
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	#ifdef READ_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw6);
+	#endif
+	
+	/* Change Cycle */
+	NAND_IO_SetReadCycleTime();
+
+	/* Read Page Size data from NANDFLASH */
+	nSpareOnOff = TNFTL_READ_SPARE_ON;
+
+	if ( nDevInfo->Feature.MediaType  & A_BIG )
+	{
+		#if defined(NAND_IO_USE_DMA_DOUBLE_BUF)
+		res = NAND_IO_Read512DataDoubleBuf( nDevInfo,
+										   nStartPPage,
+										   nReadPPSize,
+										   nPageBuffer,
+										   nSpareBuffer,
+										   nEccOnOff,
+										   TNFTL_READ_SPARE_ON );
+		#else
+		res = NAND_IO_Read512Data( nDevInfo,
+								   nStartPPage,
+								   nReadPPSize,
+								   nPageBuffer,
+								   nSpareBuffer,
+								   nEccOnOff,
+								   TNFTL_READ_SPARE_ON );		
+		#endif
+	}
+	else
+	{
+		/* Read Page Size data from NANDFLASH */
+		res = NAND_IO_Read528Data( nDevInfo,
+								   nStartPPage,
+								   nReadPPSize,
+								   nPageBuffer,
+								   nSpareBuffer,
+								   nEccOnOff );		
+	}
+	/* Change Cycle */
+	NAND_IO_SetCommCycleTime();
+							
+ErrorReadPage:
+	//=============================================
+	// Disable Chip Select
+	// PostProcess
+	//=============================================	
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+	
+	#ifdef READ_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw7);
+	#endif
+	
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_ReadNBPage
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_ReadNBPage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
+								  U16 nStartPPage, U16 nReadPPSize,
+								  U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff )
+{
+	unsigned int		RowAddr, ColumnAddr;
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ) )
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+
+	if ( ( nStartPPage + nReadPPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=============================================
+	// PreProcess
+	// Set Setup and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP LOW
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_SetNFCBusWidth(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+	
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+		NAND_IO_ClearInterleaveStatus( nDevInfo );
+	else
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	NAND_IO_EnableWriteProtect();
+
+	//=============================================
+	// Read Data
+	//=============================================	
+	/* Generate Row and Column Address */
+	if ( ( nDevInfo->Feature.MediaType  & A_MLC_8BIT )  || ( nDevInfo->Feature.MediaType  & A_MLC_12BIT ) )
+		res = NAND_IO_GenerateRowColAddrForRead( nPageAddr, ( ( 512 + nDevInfo->EccDataSize ) * nStartPPage ), &RowAddr, &ColumnAddr, nDevInfo );
+	else
+		res = NAND_IO_GenerateRowColAddrForRead( nPageAddr, nStartPPage * 528, &RowAddr, &ColumnAddr, nDevInfo );
+	
+	if ( res != SUCCESS )
+		goto ErrorReadPage;
+
+	/* Write Row and Column Address	*/
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* Command READ2 [ 0x30 ] for Advance NandFlash */
+	if ( nDevInfo->Feature.MediaType & A_BIG )
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+	
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+	
+	/* Change Cycle */
+	NAND_IO_SetReadCycleTime();
+
+	if ( ( nDevInfo->Feature.MediaType  & A_MLC_8BIT )  || ( nDevInfo->Feature.MediaType  & A_MLC_12BIT ) )
+	{
+		#if defined(NAND_IO_USE_DMA_DOUBLE_BUF)
+		res = NAND_IO_Read512DataDoubleBuf( nDevInfo,
+										    nStartPPage,
+										    nReadPPSize,
+										    nPageBuffer,
+										    nSpareBuffer,
+										    nEccOnOff,
+										    TNFTL_READ_SPARE_ON );
+		#else
+		res = NAND_IO_Read512Data( nDevInfo,
+								   nStartPPage,
+								   nReadPPSize,
+								   nPageBuffer,
+								   nSpareBuffer,
+								   nEccOnOff,
+								   TNFTL_READ_SPARE_ON );
+		#endif
+	}
+	else
+	{
+		/* Read Page Size data from NANDFLASH */
+		res = NAND_IO_Read528Data( nDevInfo,
+								   nStartPPage,
+								   nReadPPSize,
+								   nPageBuffer,
+								   nSpareBuffer,
+								   nEccOnOff );		
+	}
+	
+	/* Change Cycle */
+	NAND_IO_SetCommCycleTime();
+							
+ErrorReadPage:
+	//=============================================
+	// Disable Chip Select
+	// PostProcess
+	//=============================================	
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+	
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_ReadPageMTD
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_ReadPageMTD( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
+									U16 nStartPPage, U16 nReadPPSize,
+									U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff )
+{
+	unsigned int		RowAddr, ColumnAddr;
+	unsigned int		nSpareOnOff;
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ) )
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+
+	if ( ( nStartPPage + nReadPPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+	
+	//=============================================
+	// PreProcess
+	// Set Setup and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP LOW
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_SetNFCBusWidth(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+	
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+		NAND_IO_ClearInterleaveStatus( nDevInfo );
+	else
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	NAND_IO_EnableWriteProtect();
+
+	// Read Data
+	//=============================================	
+	/* Generate Row and Column Address */
+	if ( ( nDevInfo->Feature.MediaType  & A_BIG ) || (( nDevInfo->Feature.MediaType  & A_SMALL ) && ( nDevInfo->Feature.MediaType  & A_PARALLEL )))
+		res = NAND_IO_GenerateRowColAddrForRead( nPageAddr, nDevInfo->Feature.PageSize, &RowAddr, &ColumnAddr, nDevInfo );
+	else
+		res = NAND_IO_GenerateRowColAddrForRead( nPageAddr, ( nStartPPage << 9 ), &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorReadPage;
+
+	/* Write Row and Column Address	*/
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* Command READ2 [ 0x30 ] for Advance NandFlash */
+	if ( nDevInfo->Feature.MediaType & A_BIG )
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	/* Change Cycle */
+	NAND_IO_SetReadCycleTime();
+
+	/* Read Page Size data from NANDFLASH */
+	nSpareOnOff = TNFTL_READ_SPARE_ON;
+
+	if ( nDevInfo->Feature.MediaType & A_BIG )
+	{
+		res = NAND_IO_ReadSpareDataMTD( nDevInfo, nSpareBuffer, PAGE_ECC_ON );
+		if ( res != SUCCESS )
+			goto ErrorReadPage;
+
+		/* Change Cycle */
+		NAND_IO_SetCommCycleTime();
+		
+		/* Command Random Data Output [ 0x05 ] for Advance NandFlash */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0505;
+		
+		ColumnAddr = ( nStartPPage << 9 );
+		ColumnAddr	= ( nDevInfo->Feature.MediaType & A_PARALLEL ) ? (ColumnAddr >> 1) : ColumnAddr;
+
+		NAND_IO_WriteColAddr( ColumnAddr, nDevInfo );
+
+		/* Command Random Data Output [ 0xE0 ] for Advance NandFlash */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0xE0E0;
+
+		/* Change Cycle */
+		NAND_IO_SetReadCycleTime();
+	}
+	else if (( nDevInfo->Feature.MediaType  & A_SMALL ) && ( nDevInfo->Feature.MediaType  & A_PARALLEL ))
+	{
+		res = NAND_IO_ReadSpareDataMTD( nDevInfo, nSpareBuffer, PAGE_ECC_ON );
+		if ( res != SUCCESS )
+			goto ErrorReadPage;
+
+		/* Change Cycle */
+		NAND_IO_SetCommCycleTime();
+
+		res = NAND_IO_GenerateRowColAddrForRead( nPageAddr, ( nStartPPage << 9 ), &RowAddr, &ColumnAddr, nDevInfo );
+		if ( res != SUCCESS )
+			goto ErrorReadPage;
+
+		/* Write Row and Column Address	*/
+		NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+		/* Wait until it is ready */
+		NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+		/* Change Cycle */
+		NAND_IO_SetReadCycleTime();
+	}
+
+	res = NAND_IO_Read512DataMTD( nDevInfo,
+							   nStartPPage,
+							   nReadPPSize,
+							   nPageBuffer,
+							   nSpareBuffer,
+							   nEccOnOff,
+							   TNFTL_READ_SPARE_ON );		
+	/* Change Cycle */
+	NAND_IO_SetCommCycleTime();
+							
+ErrorReadPage:
+	//=============================================
+	// Disable Chip Select
+	// PostProcess
+	//=============================================	
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+	
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_ReadTwoPlanePage
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_ReadTwoPlanePage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U32 nSecondPageAddr,
+										U16 nStartPPage, U16 nReadPPSize,
+										U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff )
+{
+	unsigned int		RowAddr, ColumnAddr;
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ) )
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+
+	if ( ( nStartPPage + nReadPPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	#ifdef READ_SPEED_CHECK
+	pGPIO->GPFDAT = 0;
+	NAND_IO_GPIO_Toggle(Hw7);
+	#endif
+	
+	//=============================================
+	// PreProcess
+	// Set Setup and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP LOW
+	//=============================================
+	NAND_IO_PreProcess();
+	NAND_IO_SetNFCBusWidth(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) &&
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+		NAND_IO_WaitBusyForInterleave( nDevInfo, nPageAddr );
+	else
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	NAND_IO_EnableWriteProtect();
+
+	//=============================================
+	// PRE-Operation
+	//=============================================
+	/* Generate Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForCBandCP( nPageAddr, ( ( 512 + nDevInfo->EccDataSize ) * nStartPPage ), &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorReadPage;
+
+	/* Two-Plane Page Read Command [0x60] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x6060;
+
+	/* Write Row Address: Fixed 'Low' */
+	NAND_IO_WriteBlockPageAddr( 0, nDevInfo );
+
+	/* Two-Plane Page Read Command 2 [0x60] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x6060;
+
+	NAND_IO_WriteBlockPageAddr( nSecondPageAddr, nDevInfo );
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+
+	#ifdef READ_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw6);
+	#endif
+	
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	#ifdef READ_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw6);
+	#endif
+	
+	//=============================================
+	// Read Data
+	//=============================================	
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+
+	/* Write Col & Row Address: Fixed 'Low' */
+	NAND_IO_WriteRowColAddr( 0, 0, nDevInfo );
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0505;
+
+	/* Write Col Address: Valid */
+	NAND_IO_WriteColAddr( ColumnAddr, nDevInfo );
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0xE0E0;
+
+	/* Change Cycle */
+	NAND_IO_SetReadCycleTime();
+
+	/* Read Page Size data from NANDFLASH */
+	#if defined(NAND_IO_USE_DMA_DOUBLE_BUF)
+	res = NAND_IO_Read512DataDoubleBuf( nDevInfo,
+									    nStartPPage,
+									    nReadPPSize,
+									    nPageBuffer,
+									    nSpareBuffer,
+									    nEccOnOff,
+									    TNFTL_READ_SPARE_ON );
+	#else
+	res = NAND_IO_Read512Data( nDevInfo,
+							   nStartPPage,
+							   nReadPPSize,
+							   nPageBuffer,
+							   nSpareBuffer,
+							   nEccOnOff,
+							   TNFTL_READ_SPARE_ON );
+	#endif
+	/* Change Cycle */
+	NAND_IO_SetCommCycleTime();
+							
+ErrorReadPage:
+	//=============================================
+	// Disable Chip Select
+	// PostProcess
+	//=============================================	
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+
+	#ifdef READ_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw7);
+	#endif
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_ReadTwoPlaneLastPage
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_ReadTwoPlaneLastPage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
+											U16 nStartPPage, U16 nReadPPSize,
+											U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff )
+{
+	unsigned int		RowAddr, ColumnAddr;
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ) )
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+
+	if ( ( nStartPPage + nReadPPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	#ifdef READ_SPEED_CHECK
+	pGPIO->GPFDAT = 0;
+	NAND_IO_GPIO_Toggle(Hw7);
+	#endif
+	
+	//=============================================
+	// PreProcess
+	// Set Setup and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP LOW
+	//=============================================
+	NAND_IO_PreProcess();
+	NAND_IO_SetNFCBusWidth(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) &&
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+		NAND_IO_ClearInterleaveStatus( nDevInfo );
+	else
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	NAND_IO_EnableWriteProtect();
+
+	//=============================================
+	// Read Data
+	//=============================================	
+	/* Generate Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForRead( nPageAddr, ( ( 512 + nDevInfo->EccDataSize ) * nStartPPage ), &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorReadPage;
+
+	/* Write Col & Row Address: Col Addr = Fixed 'Low' */
+	NAND_IO_WriteRowColAddr( RowAddr, 0, nDevInfo );
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0505;
+
+	/* Write Col Address: Valid */
+	NAND_IO_WriteColAddr( ColumnAddr, nDevInfo );
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0xE0E0;
+
+	/* Change Cycle */
+	NAND_IO_SetReadCycleTime();
+	
+	/* Read Page Size data from NANDFLASH */
+	#if defined(NAND_IO_USE_DMA_DOUBLE_BUF)
+	res = NAND_IO_Read512DataDoubleBuf( nDevInfo,
+									    nStartPPage,
+									    nReadPPSize,
+									    nPageBuffer,
+									    nSpareBuffer,
+									    nEccOnOff,
+									    TNFTL_READ_SPARE_ON );	
+	#else
+	res = NAND_IO_Read512Data( nDevInfo,
+							   nStartPPage,
+							   nReadPPSize,
+							   nPageBuffer,
+							   nSpareBuffer,
+							   nEccOnOff,
+							   TNFTL_READ_SPARE_ON );	
+	#endif	
+	/* Change Cycle */
+	NAND_IO_SetCommCycleTime();
+							
+ErrorReadPage:
+	//=============================================
+	// Disable Chip Select
+	// PostProcess
+	//=============================================	
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+
+	#ifdef READ_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw7);
+	#endif
+	
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_ReadUserSizePage
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_ReadUserSizePage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
+										U16 nColumnAddr, U32 nReadSize, U8 *nReadBuffer )
+{
+	unsigned int		RowAddr, ColumnAddr;
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+
+	if ( (U32)( nColumnAddr + nReadSize ) > (U16)( nDevInfo->Feature.PageSize + nDevInfo->Feature.SpareSize ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=============================================
+	// PreProcess
+	// Set Setup Time and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP LOW	
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_SetNFCBusWidth(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+		NAND_IO_ClearInterleaveStatus( nDevInfo );
+	else
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	NAND_IO_EnableWriteProtect();
+		
+	//=============================================
+	// Read UserSize Data
+	//=============================================
+			
+	/* Generate Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForRead( nPageAddr, nColumnAddr, &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorReadUserSizePage;
+
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+	
+	/* Command READ2 [ 0x30 ] for Advance NandFlash */
+	if ( nDevInfo->Feature.MediaType & A_BIG )
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+	
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	/* Change Cycle */
+	NAND_IO_SetReadCycleTime();
+
+	/* Read User Size data from NANDFLASH */
+	res = NAND_IO_ReadUserSizeData( nDevInfo,
+									nColumnAddr,
+									nReadSize,
+									nReadBuffer );
+	/* Change Cycle */
+	NAND_IO_SetCommCycleTime();
+
+	if ( res != SUCCESS )
+		goto ErrorReadUserSizePage;
+	
+ErrorReadUserSizePage:
+	//=============================================
+	// Disable Chip Select
+	// PostProcess
+	//=============================================	
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+	
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_ReadChainPage
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_ReadChainPage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U8 *nPageBuffer, U8 *nSpareBuffer, int nMode )
+{
+	unsigned int		RowAddr, ColumnAddr;
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+
+	//=============================================
+	// PreProcess
+	// Set Setup Time and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP LOW	
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_SetNFCBusWidth(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+		NAND_IO_ClearInterleaveStatus( nDevInfo );
+	else
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	NAND_IO_EnableWriteProtect();
+		
+	//=============================================
+	// Read UserSize Data
+	//=============================================
+
+	/* Generate Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForRead( nPageAddr, 0, &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorReadUserSizePage;
+
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+	
+	/* Command READ2 [ 0x30 ] for Advance NandFlash */
+	if ( nDevInfo->Feature.MediaType & A_BIG )
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+	
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+	
+	/* Change Cycle */
+	NAND_IO_SetReadCycleTime();
+
+	/* Read User Size data from NANDFLASH */
+	res = NAND_IO_ReadUserSizeData( nDevInfo,
+									0,
+									nDevInfo->Feature.PageSize,
+									nPageBuffer );
+	if ( res != SUCCESS )
+		goto ErrorReadUserSizePage;
+
+	res = NAND_IO_ReadUserSizeData( nDevInfo,
+									0,
+									nDevInfo->Feature.SpareSize,
+									nSpareBuffer );
+	if ( res != SUCCESS )
+		goto ErrorReadUserSizePage;
+
+	/* Change Cycle */
+	NAND_IO_SetCommCycleTime();
+
+	//=============================================
+	// ECC Decode
+	//=============================================
+	res = NAND_IO_DecodeChainData( nDevInfo, 
+	  							   nPageBuffer, 
+	  							   nSpareBuffer, 
+	  							   nMode, ECC_ON );
+	if ( res != SUCCESS )
+		goto ErrorReadUserSizePage;
+
+ErrorReadUserSizePage:
+	//=============================================
+	// Disable Chip Select
+	// PostProcess
+	//=============================================	
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+	
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      NAND_IO_ERROR NAND_IO_ReadGoldenPage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U8 *nPageBuffer, U8 *nSpareBuffer );
+*  
+*  DESCRIPTION : 
+*  
+*  INPUT:
+*			nDevInfo	= 
+*			nPageAddr	= 
+*			nPageBuffer	= 
+*			nSpareBuffer	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+*  REMARK:	  by nemo
+**************************************************************************/
+NAND_IO_ERROR NAND_IO_ReadGoldenPage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U8 *nPageBuffer, U8 *nSpareBuffer )
+{
+	unsigned int		RowAddr, ColumnAddr;
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+
+	//=============================================
+	// PreProcess
+	// Set Setup Time and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP LOW	
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_SetNFCBusWidth(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+		NAND_IO_ClearInterleaveStatus( nDevInfo );
+	else
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	NAND_IO_EnableWriteProtect();
+		
+	//=============================================
+	// Read UserSize Data
+	//=============================================
+			
+	/* Generate Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForRead( nPageAddr, 0, &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorReadUserSizePage;
+
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+	
+	/* Command READ2 [ 0x30 ] for Advance NandFlash */
+	if ( nDevInfo->Feature.MediaType & A_BIG )
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+	
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+	
+	/* Change Cycle */
+	NAND_IO_SetReadCycleTime();
+
+	/* Read User Size data from NANDFLASH */
+	res = NAND_IO_ReadUserSizeData( nDevInfo,
+									0,
+									nDevInfo->Feature.PageSize,
+									nPageBuffer );
+	if ( res != SUCCESS )
+		goto ErrorReadUserSizePage;
+
+	res = NAND_IO_ReadUserSizeData( nDevInfo,
+									0,
+									nDevInfo->Feature.SpareSize,
+									nSpareBuffer );
+	if ( res != SUCCESS )
+		goto ErrorReadUserSizePage;
+
+	/* Change Cycle */
+	NAND_IO_SetCommCycleTime();
+
+	//=============================================
+	// ECC Decode
+	//=============================================
+	res = NAND_IO_DecodeChainDataForGoldenPage( nDevInfo,
+												nPageBuffer, 
+												nSpareBuffer, 
+												ECC_ON );
+
+	
+	if ( res != SUCCESS )
+		goto ErrorReadUserSizePage;
+
+ErrorReadUserSizePage:
+	//=============================================
+	// Disable Chip Select
+	// PostProcess
+	//=============================================	
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+	
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_WriteSpare
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_WriteSpare( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
+								  U8* nSpareBuffer, int nEccOnOff )
+{
+	unsigned int		RowAddr, ColumnAddr;
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+
+	//=============================================
+	// PreProcess
+	// Set Setup Time and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP HIGH
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_SetNFCBusWidth(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+	{
+		res = NAND_IO_WaitBusyForInterleave( nDevInfo, nPageAddr );
+		if ( res != SUCCESS )
+			goto ErrorWritePage;	 
+	}
+	else
+	{
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+		NAND_IO_DisableWriteProtect();
+	}
+	
+	//=============================================
+	// Write Data
+	//=============================================
+	/* Generate Row and Column Address */
+	if ( nDevInfo->Feature.MediaType  & A_BIG )
+		res = NAND_IO_GenerateRowColAddrForWrite( nPageAddr, ( ( 512 + nDevInfo->EccDataSize ) << nDevInfo->ShiftPPages ), &RowAddr, &ColumnAddr, nDevInfo );
+	else
+		res = NAND_IO_GenerateRowColAddrForWrite( nPageAddr, 512, &RowAddr, &ColumnAddr, nDevInfo );
+	
+	if ( res != SUCCESS )
+		goto ErrorWritePage;
+
+	/* Command Page Program #1 [ 0x80 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8080;
+
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* Change Cycle */
+	NAND_IO_SetWriteCycleTime();
+
+	/* Write Data to NAND FLASH */
+	if ( nDevInfo->Feature.MediaType  & A_BIG )
+		res = NAND_IO_WriteSpareData( nDevInfo, nSpareBuffer, nEccOnOff );
+	else
+		res = NAND_IO_WriteUserSizeData( nDevInfo, (U16)ColumnAddr, 16, nSpareBuffer );
+	
+	/* Change Cycle */
+	NAND_IO_SetCommCycleTime();
+
+	if ( res != SUCCESS )
+		goto ErrorWritePage;
+	
+	/* Command Page Program #2 [ 0x10 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+	if ( !( ( nDevInfo->Feature.MediaType & S_IL ) || ( nDevInfo->ExtInterleaveUsable == TRUE ) ) )
+	{
+	    /* Wait until it is ready */
+	    NAND_IO_WaitBusyForProgramAndErase( nDevInfo );
+		    
+	    /* Check Status */
+	    res = NAND_IO_ReadStatus( nDevInfo );
+	    if ( res != SUCCESS )
+		{
+			nDevInfo->WriteStatus.ChipNo 			= (U8)nDevInfo->ChipNo;
+			nDevInfo->WriteStatus.BlockStatus 		= MULTI_PLANE_BAD_BLOCK;
+			nDevInfo->WriteStatus.ErrorPHYPageAddr 	= nPageAddr;
+			res = ERR_NAND_IO_FAILED_WRITE;
+			
+		    goto ErrorWritePage;
+		}
+	}
+	else
+	{
+		NAND_IO_SetInterleaveStatus( nDevInfo, nPageAddr );
+		gInterLeavePageAddr = nPageAddr;
+	}
+ErrorWritePage:
+	//=============================================
+	// FORCE TO SET WP LOW
+	// Disable Chip Select
+	// PostProcess
+	//=============================================
+	if ( !( ( nDevInfo->Feature.MediaType & S_IL ) || ( nDevInfo->ExtInterleaveUsable == TRUE  ) ) )
+		NAND_IO_EnableWriteProtect();
+	
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+	
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_WritePage
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_WritePage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
+								 U16 nStartPPage, U16 nWritePPSize,
+								 U8 *nPageBuffer, U8* nSpareBuffer, int nEccOnOff )
+{
+	unsigned int		RowAddr, ColumnAddr;	
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+		
+	if ( ( nStartPPage + nWritePPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=============================================
+	// PreProcess
+	// Set Setup Time and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP HIGH
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_SetNFCBusWidth(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+	{
+		res = NAND_IO_WaitBusyForInterleave( nDevInfo, nPageAddr );
+		if ( res != SUCCESS )
+			goto ErrorWritePage;
+	}
+	else
+	{
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+		NAND_IO_DisableWriteProtect();
+	}
+	
+	//=============================================
+	// Write Data
+	//=============================================
+
+	/* Generate Row and Column Address */
+	if ( nDevInfo->Feature.MediaType  & A_BIG )
+		res = NAND_IO_GenerateRowColAddrForWrite( nPageAddr, ( ( 512 + nDevInfo->EccDataSize ) * nStartPPage ), &RowAddr, &ColumnAddr, nDevInfo );
+	else
+		res = NAND_IO_GenerateRowColAddrForWrite( nPageAddr, ( 528 * nStartPPage ), &RowAddr, &ColumnAddr, nDevInfo );
+		
+	if ( res != SUCCESS )
+		goto ErrorWritePage;
+
+	/* Command Page Program #1 [ 0x80 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8080;
+
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* Change Cycle */
+	NAND_IO_SetWriteCycleTime();
+
+	/* Write Data to NAND FLASH */
+	if ( nDevInfo->Feature.MediaType  & A_BIG )
+	{
+		#if defined(NAND_IO_USE_DMA_DOUBLE_BUF)
+		res = NAND_IO_Write512DataDoubleBuf( nDevInfo,
+									nStartPPage,
+									nWritePPSize,
+									nPageBuffer,
+									nSpareBuffer,
+									nEccOnOff );
+		#else
+		res = NAND_IO_Write512Data( nDevInfo,
+									nStartPPage,
+									nWritePPSize,
+									nPageBuffer,
+									nSpareBuffer,
+									nEccOnOff );
+		#endif
+	}
+	else
+	{
+		res = NAND_IO_Write528Data( nDevInfo,
+									nStartPPage,
+									nWritePPSize,
+									nPageBuffer,
+									nSpareBuffer,
+									nEccOnOff );
+	}
+	
+	/* Change Cycle */
+	NAND_IO_SetCommCycleTime();
+
+	if ( res != SUCCESS )
+		goto ErrorWritePage;
+	
+	/* Command Page Program #2 [ 0x10 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+	if ( !( ( nDevInfo->Feature.MediaType & S_IL ) || ( nDevInfo->ExtInterleaveUsable == TRUE ) ) )
+	{
+	    /* Wait until it is ready */
+	    NAND_IO_WaitBusyForProgramAndErase( nDevInfo );
+		    
+	    /* Check Status */
+	    res = NAND_IO_ReadStatus( nDevInfo );
+	    if ( res != SUCCESS )
+		{
+			nDevInfo->WriteStatus.ChipNo 			= (U8)nDevInfo->ChipNo;
+			nDevInfo->WriteStatus.BlockStatus 		= MULTI_PLANE_BAD_BLOCK;
+			nDevInfo->WriteStatus.ErrorPHYPageAddr 	= nPageAddr;
+			res = ERR_NAND_IO_FAILED_WRITE;
+			
+		    goto ErrorWritePage;
+		}
+	}
+	else
+	{
+		NAND_IO_SetInterleaveStatus( nDevInfo, nPageAddr );
+		gInterLeavePageAddr = nPageAddr;		
+	}
+
+ErrorWritePage:
+	//=============================================
+	// FORCE TO SET WP LOW
+	// Disable Chip Select
+	// PostProcess
+	//=============================================
+	if ( !( ( nDevInfo->Feature.MediaType & S_IL ) || ( nDevInfo->ExtInterleaveUsable == TRUE  ) ) )
+		NAND_IO_EnableWriteProtect();
+	
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+	
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_WriteNBPage
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_WriteNBPage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
+								   U16 nStartPPage, U16 nWritePPSize,
+								   U8 *nPageBuffer, U8* nSpareBuffer, int nEccOnOff )
+{
+	unsigned int		RowAddr, ColumnAddr;	
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+		
+	if ( ( nStartPPage + nWritePPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=============================================
+	// PreProcess
+	// Set Setup Time and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP HIGH
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_SetNFCBusWidth(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+	{
+		res = NAND_IO_WaitBusyForInterleave( nDevInfo, nPageAddr );
+		if ( res != SUCCESS )
+			goto ErrorWritePage;
+	}
+	else
+	{
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+		NAND_IO_DisableWriteProtect();
+	}
+	
+	//=============================================
+	// Write Data
+	//=============================================
+	
+	/* Generate Row and Column Address */
+	if ( ( nDevInfo->Feature.MediaType  & A_MLC_8BIT )  || ( nDevInfo->Feature.MediaType  & A_MLC_12BIT ) )
+		res = NAND_IO_GenerateRowColAddrForWrite( nPageAddr, ( ( 512 + nDevInfo->EccDataSize ) * nStartPPage ), &RowAddr, &ColumnAddr, nDevInfo );
+	else
+		res = NAND_IO_GenerateRowColAddrForWrite( nPageAddr, nStartPPage * 528, &RowAddr, &ColumnAddr, nDevInfo );	
+
+	if ( res != SUCCESS )
+		goto ErrorWritePage;
+
+	/* Command Page Program #1 [ 0x80 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8080;
+
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* Change Cycle */
+	NAND_IO_SetWriteCycleTime();
+
+	/* Write Data to NAND FLASH */
+	if ( ( nDevInfo->Feature.MediaType  & A_MLC_8BIT )  || ( nDevInfo->Feature.MediaType  & A_MLC_12BIT ) )
+	{
+		#if defined(NAND_IO_USE_DMA_DOUBLE_BUF)
+		res = NAND_IO_Write512DataDoubleBuf( nDevInfo,
+											  nStartPPage,
+											  nWritePPSize,
+											  nPageBuffer,
+											  nSpareBuffer,
+											  nEccOnOff );
+		#else
+		res = NAND_IO_Write512Data( nDevInfo,
+									nStartPPage,
+									nWritePPSize,
+									nPageBuffer,
+									nSpareBuffer,
+									nEccOnOff );
+		#endif
+	}
+	else
+	{
+		res = NAND_IO_Write528Data( nDevInfo,
+									nStartPPage,
+									nWritePPSize,
+									nPageBuffer,
+									nSpareBuffer,
+									nEccOnOff );
+	}
+
+	/* Change Cycle */
+	NAND_IO_SetCommCycleTime();
+
+	if ( res != SUCCESS )
+		goto ErrorWritePage;
+	
+	/* Command Page Program #2 [ 0x10 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+	if ( !( ( nDevInfo->Feature.MediaType & S_IL ) || ( nDevInfo->ExtInterleaveUsable == TRUE ) ) )
+	{
+	    /* Wait until it is ready */
+	    NAND_IO_WaitBusyForProgramAndErase( nDevInfo );
+		    
+	    /* Check Status */
+	    res = NAND_IO_ReadStatus( nDevInfo );
+	    if ( res != SUCCESS )
+		{
+			nDevInfo->WriteStatus.ChipNo 			= (U8)nDevInfo->ChipNo;
+			nDevInfo->WriteStatus.BlockStatus 		= MULTI_PLANE_BAD_BLOCK;
+			nDevInfo->WriteStatus.ErrorPHYPageAddr 	= nPageAddr;
+			res = ERR_NAND_IO_FAILED_WRITE;
+			
+		    goto ErrorWritePage;
+		}
+	}
+	else
+	{
+		NAND_IO_SetInterleaveStatus( nDevInfo, nPageAddr );
+		gInterLeavePageAddr = nPageAddr;
+	}
+ErrorWritePage:
+	//=============================================
+	// FORCE TO SET WP LOW
+	// Disable Chip Select
+	// PostProcess
+	//=============================================
+	if ( !( ( nDevInfo->Feature.MediaType & S_IL ) || ( nDevInfo->ExtInterleaveUsable == TRUE  ) ) )
+		NAND_IO_EnableWriteProtect();
+	
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+	
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_WritePageMTD
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_WritePageMTD( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
+								 	U16 nStartPPage, U16 nWritePPSize,
+									U8 *nPageBuffer, U8* nSpareBuffer, int nEccOnOff )
+{
+	unsigned int		RowAddr, ColumnAddr;	
+	NAND_IO_ERROR		res;
+	
+	//=============================================
+	// Check Device and Parameter
+	//=============================================
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+		
+	if ( ( nStartPPage + nWritePPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=============================================
+	// PreProcess
+	// Set Setup Time and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP HIGH
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_SetNFCBusWidth(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+	{
+		res = NAND_IO_WaitBusyForInterleave( nDevInfo, nPageAddr );
+		if ( res != SUCCESS )
+			goto ErrorWritePage;
+	}
+	else
+	{
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+		NAND_IO_DisableWriteProtect();
+	}
+	
+	//=============================================
+	// Write Data
+	//=============================================
+
+	/* Generate Row and Column Address */
+	if ( nDevInfo->Feature.MediaType  & A_BIG )
+		res = NAND_IO_GenerateRowColAddrForWrite( nPageAddr, ( ( 512 + nDevInfo->EccDataSize ) * nStartPPage ), &RowAddr, &ColumnAddr, nDevInfo );
+	else
+		res = NAND_IO_GenerateRowColAddrForWrite( nPageAddr, ( 528 * nStartPPage ), &RowAddr, &ColumnAddr, nDevInfo );
+		
+	if ( res != SUCCESS )
+		goto ErrorWritePage;
+
+	/* Command Page Program #1 [ 0x80 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8080;
+
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* Change Cycle */
+	NAND_IO_SetWriteCycleTime();
+
+	/* Write Data to NAND FLASH */
+	if ( nDevInfo->Feature.MediaType  & A_BIG )
+	{
+		res = NAND_IO_Write512DataMTD( nDevInfo,
+									nStartPPage,
+									nWritePPSize,
+									nPageBuffer,
+									nSpareBuffer,
+									nEccOnOff );
+	}
+	else
+	{
+		res = NAND_IO_Write528Data( nDevInfo,
+									nStartPPage,
+									nWritePPSize,
+									nPageBuffer,
+									nSpareBuffer,
+									nEccOnOff );
+	}
+	
+	/* Change Cycle */
+	NAND_IO_SetCommCycleTime();
+
+	if ( res != SUCCESS )
+		goto ErrorWritePage;
+	
+	/* Command Page Program #2 [ 0x10 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+	if ( !( ( nDevInfo->Feature.MediaType & S_IL ) || ( nDevInfo->ExtInterleaveUsable == TRUE ) ) )
+	{
+	    /* Wait until it is ready */
+	    NAND_IO_WaitBusyForProgramAndErase( nDevInfo );
+		    
+	    /* Check Status */
+	    res = NAND_IO_ReadStatus( nDevInfo );
+	    if ( res != SUCCESS )
+		{
+			nDevInfo->WriteStatus.ChipNo 			= (U8)nDevInfo->ChipNo;
+			nDevInfo->WriteStatus.BlockStatus 		= MULTI_PLANE_BAD_BLOCK;
+			nDevInfo->WriteStatus.ErrorPHYPageAddr 	= nPageAddr;
+			res = ERR_NAND_IO_FAILED_WRITE;
+			
+		    goto ErrorWritePage;
+		}
+	}
+	else
+	{
+		NAND_IO_SetInterleaveStatus( nDevInfo, nPageAddr );
+		gInterLeavePageAddr = nPageAddr;		
+	}
+
+ErrorWritePage:
+	//=============================================
+	// FORCE TO SET WP LOW
+	// Disable Chip Select
+	// PostProcess
+	//=============================================
+	if ( !( ( nDevInfo->Feature.MediaType & S_IL ) || ( nDevInfo->ExtInterleaveUsable == TRUE  ) ) )
+		NAND_IO_EnableWriteProtect();
+	
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+	
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_WriteCachePage
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_WriteCachePage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
+									  U16 nStartPPage, U16 nWritePPSize,
+									  U8 *nPageBuffer, U8* nSpareBuffer, int nEccOnOff )
+{
+	unsigned int		RowAddr, ColumnAddr;	
+	NAND_IO_ERROR		res;
+
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+		
+	if ( ( nStartPPage + nWritePPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=============================================
+	// PreProcess
+	// Set Setup Time and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP HIGH
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_SetNFCBusWidth(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+	
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+		NAND_IO_ClearInterleaveStatus( nDevInfo );
+	else
+	{
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+		NAND_IO_DisableWriteProtect();
+	}
+
+	//=============================================
+	// Write Data
+	//=============================================
+
+	/* Generate Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForCBandCP( nPageAddr, ( ( 512 + nDevInfo->EccDataSize ) * nStartPPage ), &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorWritePage;
+
+	/* Command Page Program #1 [ 0x80 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8080;
+
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* Change Cycle */
+	NAND_IO_SetWriteCycleTime();
+
+	/* Write Data to NAND FLASH */
+	#if defined(NAND_IO_USE_DMA_DOUBLE_BUF)
+	res = NAND_IO_Write512DataDoubleBuf( nDevInfo,
+										  nStartPPage,
+										  nWritePPSize,
+										  nPageBuffer,
+										  nSpareBuffer,
+										  nEccOnOff );
+	#else
+	res = NAND_IO_Write512Data( nDevInfo,
+								nStartPPage,
+								nWritePPSize,
+								nPageBuffer,
+								nSpareBuffer,
+								nEccOnOff );
+	#endif
+	/* Change Cycle */
+	NAND_IO_SetCommCycleTime();
+
+	if ( res != SUCCESS )
+		goto ErrorWritePage;
+	
+	/* Command Page Program #2 [ 0x15 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1515;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusyForCacheProgram( nDevInfo );
+
+	/* Check Status */
+	res = NAND_IO_ReadStatusForCacheProgram( nDevInfo );
+	if ( res != SUCCESS )
+	{
+		nDevInfo->WriteStatus.ChipNo 			= (U8)nDevInfo->ChipNo;
+		nDevInfo->WriteStatus.BlockStatus 		= MULTI_PLANE_BAD_BLOCK;
+		nDevInfo->WriteStatus.ErrorPHYPageAddr 	= nPageAddr;
+		res = ERR_NAND_IO_FAILED_WRITE;
+
+		goto ErrorWritePage;
+	}
+
+ErrorWritePage:
+	//=============================================
+	// FORCE TO SET WP LOW
+	// Disable Chip Select
+	// PostProcess
+	//=============================================
+	//NAND_IO_EnableWriteProtect();
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+	
+	if ( res != SUCCESS )
+		return res;
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_WriteTwoPlanePage
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_WriteTwoPlanePage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
+									     U16 nStartPPage, U16 nWritePPSize,
+									     U8 *nPageBuffer, U8* nSpareBuffer, int nEccOnOff )
+{
+	unsigned int		RowAddr, ColumnAddr;
+	unsigned long int	dwTempPHYPageAddr;
+	NAND_IO_ERROR		res;
+
+	#ifdef WRITE_SPEED_CHECK
+	pGPIO->GPFDAT = 0;
+	NAND_IO_GPIO_Toggle(Hw7);
+	#endif
+
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+		
+	if ( ( nStartPPage + nWritePPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=============================================
+	// PreProcess
+	// Set Setup Time and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP HIGH
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_SetNFCBusWidth(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+	{
+		res = NAND_IO_WaitBusyForInterleave( nDevInfo, nPageAddr );
+		if ( res != SUCCESS )
+			goto ErrorWritePage;	
+	}
+	else
+	{
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+		NAND_IO_DisableWriteProtect();
+	}
+
+	#ifdef WRITE_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw7);
+	#endif
+	
+	//=============================================
+	// Write Data
+	//=============================================
+	if ( ( nDevInfo->Feature.DeviceID.Code[0] == SAMSUNG_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == HYNIX_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == ST_NAND_MAKER_ID ) )
+	{
+		if ( ( nDevInfo->Feature.MediaType & A_MLC ) || ( nDevInfo->Feature.MediaType & A_SLC ) )
+		{
+		    dwTempPHYPageAddr = ( ( nDevInfo->Feature.PBpV << nDevInfo->ShiftPpB ) >> 1 );
+    
+	 	    if ( nPageAddr & dwTempPHYPageAddr )
+	 		    nPageAddr = dwTempPHYPageAddr;
+		    else
+			    nPageAddr = 0;
+	    }
+	}
+
+	#ifdef WRITE_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw7);
+	#endif
+	
+	/* Generate Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForCBandCP( nPageAddr, ( ( 512 + nDevInfo->EccDataSize ) * nStartPPage ), &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorWritePage;
+
+	/* Command Page Program #1 [ 0x80 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8080;
+
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* Change Cycle */
+	NAND_IO_SetWriteCycleTime();
+
+	/* Write Data to NAND FLASH */
+	#if defined(NAND_IO_USE_DMA_DOUBLE_BUF)
+	res = NAND_IO_Write512DataDoubleBuf( nDevInfo,
+										  nStartPPage,
+										  nWritePPSize,
+										  nPageBuffer,
+										  nSpareBuffer,
+										  nEccOnOff );
+	#else
+	res = NAND_IO_Write512Data( nDevInfo,
+								nStartPPage,
+								nWritePPSize,
+								nPageBuffer,
+								nSpareBuffer,
+								nEccOnOff );
+	#endif
+	/* Change Cycle */
+	NAND_IO_SetCommCycleTime();
+
+	if ( res != SUCCESS )
+		goto ErrorWritePage;
+	
+	/* Command Multi Plane Page Program #2 [ 0x11 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1111;
+
+	if ( !( ( nDevInfo->Feature.MediaType & S_IL ) || ( nDevInfo->ExtInterleaveUsable == TRUE ) ) )
+		NAND_IO_WaitBusyForCacheProgram( nDevInfo );
+
+	#ifdef WRITE_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw7);
+	#endif
+	
+ErrorWritePage:
+	//=============================================
+	// FORCE TO SET WP LOW
+	// Disable Chip Select
+	// PostProcess
+	//=============================================
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+
+	if ( res != SUCCESS )
+		return res;
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_WriteTwoPlaneLastPage
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_WriteTwoPlaneLastPage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
+									    	 U16 nStartPPage, U16 nWritePPSize,
+									    	 U8 *nPageBuffer, U8* nSpareBuffer, int LastPage, int nEccOnOff )
+{
+	unsigned int		RowAddr, ColumnAddr;	
+	NAND_IO_ERROR		res;
+
+	#ifdef WRITE_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw6);
+	#endif
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+		
+	if ( ( nStartPPage + nWritePPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=============================================
+	// PreProcess
+	// Set Setup Time and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP HIGH
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_SetNFCBusWidth(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+	NAND_IO_DisableWriteProtect();
+
+	//=============================================
+	// Write Data
+	//=============================================
+
+	/* Generate Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForCBandCP( nPageAddr, ( ( 512 + nDevInfo->EccDataSize ) * nStartPPage ), &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorWritePage;
+
+	/* Command Page Program #1 [ 0x80 ] */
+	if ( ( nDevInfo->Feature.DeviceID.Code[0] == SAMSUNG_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == HYNIX_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == ST_NAND_MAKER_ID ) )
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8181;
+	else if ( ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID ) )
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8080;
+	
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* Change Cycle */
+	NAND_IO_SetWriteCycleTime();
+
+	/* Write Data to NAND FLASH */
+	#if defined(NAND_IO_USE_DMA_DOUBLE_BUF)
+	res = NAND_IO_Write512DataDoubleBuf( nDevInfo,
+										  nStartPPage,
+										  nWritePPSize,
+										  nPageBuffer,
+										  nSpareBuffer,
+										  nEccOnOff );
+	#else
+	res = NAND_IO_Write512Data( nDevInfo,
+								nStartPPage,
+								nWritePPSize,
+								nPageBuffer,
+								nSpareBuffer,
+								nEccOnOff );
+	#endif
+
+	/* Change Cycle */
+	NAND_IO_SetCommCycleTime();
+
+	if ( res != SUCCESS )
+		goto ErrorWritePage;
+	
+	/* Command Page Program #2 [ 0x10 ] */
+	if ( ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID )	 || ( nDevInfo->Feature.DeviceID.Code[0] == ST_NAND_MAKER_ID ) )
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+	else if ( ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID ) )	
+	{
+		if ( ( LastPage == MULTI_PLANE_LAST_PAGE ) || ( nDevInfo->ExtInterleaveUsable == TRUE ) )
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+		else if ( LastPage == MULTI_PLANE_MID_PAGE )
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1515;
+	}
+	else if ( ( nDevInfo->Feature.DeviceID.Code[0] == SAMSUNG_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == HYNIX_NAND_MAKER_ID ) )	
+	{
+		if ( nDevInfo->Feature.MediaType & S_MCP )
+		{
+			if ( LastPage == MULTI_PLANE_LAST_PAGE )
+				pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+			else if ( LastPage == MULTI_PLANE_MID_PAGE )
+				pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1515;
+		}
+		else
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+	}
+
+	if ( !( ( nDevInfo->Feature.MediaType & S_IL ) || ( nDevInfo->ExtInterleaveUsable == TRUE ) ) )
+	{
+		/* Wait until it is ready */
+		NAND_IO_WaitBusyForProgramAndErase( nDevInfo );
+			
+		/* Check Status */
+		if ( LastPage == MULTI_PLANE_LAST_PAGE )
+		{
+		    res = NAND_IO_ReadStatusForMultiPlane( nDevInfo );
+		    if ( res != SUCCESS )
+		    {
+			    nDevInfo->WriteStatus.ChipNo 			= (U8)nDevInfo->ChipNo;
+			    nDevInfo->WriteStatus.BlockStatus 		= MULTI_PLANE_BAD_BLOCK;
+			    nDevInfo->WriteStatus.ErrorPHYPageAddr 	= nPageAddr;
+			    res = ERR_NAND_IO_FAILED_WRITE;
+    
+			    goto ErrorWritePage;
+		    }
+	    }
+	}	
+	else
+	{
+		NAND_IO_SetInterleaveStatus( nDevInfo, nPageAddr );
+		gInterLeavePageAddr = nPageAddr;
+	}
+
+ErrorWritePage:
+	//=============================================
+	// FORCE TO SET WP LOW
+	// Disable Chip Select
+	// PostProcess
+	//=============================================
+	//NAND_IO_EnableWriteProtect();
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+
+	#ifdef WRITE_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw6);
+	#endif
+	
+	if ( res != SUCCESS )
+		return res;
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_WriteUserSizePage
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_WriteUserSizePage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
+										 U16 nColumnAddr, U32 nWriteSize, U8 *nWriteBuffer )
+{
+	unsigned int		RowAddr, ColumnAddr;	
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+		
+	if ( (U32)( nColumnAddr + nWriteSize ) > (U16)( nDevInfo->Feature.PageSize + nDevInfo->Feature.SpareSize ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=============================================
+	// PreProcess
+	// Set Setup Time and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP HIGH
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_SetNFCBusWidth(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+		NAND_IO_ClearInterleaveStatus( nDevInfo );
+	else
+	{
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+		NAND_IO_DisableWriteProtect();
+	}
+
+	//=============================================
+	// Write UserSize Data
+	//=============================================
+
+	/* Generate Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForWrite( nPageAddr, nColumnAddr, &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorWriteUserSizePage;
+
+	/* Command Page Program #1 [ 0x80 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8080;
+
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* Change Cycle */
+	NAND_IO_SetWriteCycleTime();
+
+	/* Write Data to NAND FLASH */
+	res = NAND_IO_WriteUserSizeData( nDevInfo,
+									 nColumnAddr,
+									 nWriteSize,
+									 nWriteBuffer );
+	/* Change Cycle */
+	NAND_IO_SetCommCycleTime();
+									 
+	if ( res != SUCCESS )
+		goto ErrorWriteUserSizePage;
+	
+	/* Command Page Program #2 [ 0x10 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusyForProgramAndErase( nDevInfo );
+
+	/* Check Status */
+	res = NAND_IO_ReadStatus( nDevInfo );
+	if ( res != SUCCESS )
+	{
+		nDevInfo->WriteStatus.ChipNo 			= (U8)nDevInfo->ChipNo;
+		nDevInfo->WriteStatus.BlockStatus 		= MULTI_PLANE_BAD_BLOCK;
+		nDevInfo->WriteStatus.ErrorPHYPageAddr 	= nPageAddr;
+		res = ERR_NAND_IO_FAILED_WRITE;
+		
+		goto ErrorWriteUserSizePage;
+	}
+
+ErrorWriteUserSizePage:
+	//=============================================
+	// FORCE TO SET WP LOW
+	// Disable Chip Select
+	// PostProcess
+	//=============================================
+	NAND_IO_EnableWriteProtect();
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+	
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_WriteChainPage
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_WriteChainPage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U8 *nPageBuffer, U8 *nSpareBuffer, int nMode )
+{
+	unsigned int		RowAddr, ColumnAddr;	
+	NAND_IO_ERROR		res;
+
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+
+	//=============================================
+	// PreProcess
+	// Set Setup Time and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP HIGH
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_SetNFCBusWidth(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+		NAND_IO_ClearInterleaveStatus( nDevInfo );
+	else
+	{
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+		NAND_IO_DisableWriteProtect();
+	}
+
+	//=============================================
+	// ECC Encording
+	//=============================================
+	res = NAND_IO_EncodeChainData( nDevInfo, nPageBuffer, nSpareBuffer, nMode, ECC_ON );
+	if ( res != SUCCESS )
+		goto ErrorWriteUserSizePage;
+
+	//=============================================
+	// Write UserSize Data
+	//=============================================
+
+	/* Generate Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForWrite( nPageAddr, 0, &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorWriteUserSizePage;
+
+	/* Command Page Program #1 [ 0x80 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8080;
+
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* Change Cycle */
+	NAND_IO_SetWriteCycleTime();
+
+	/* Write Data to NAND FLASH */
+
+	//=============================================
+	// Write Data
+	//=============================================
+	res = NAND_IO_WriteUserSizeData( nDevInfo,
+									 0,
+									 nDevInfo->Feature.PageSize,
+									 nPageBuffer );
+	if ( res != SUCCESS )
+		goto ErrorWriteUserSizePage;
+	
+	//=============================================
+	// Write ECC Code
+	//=============================================
+	res = NAND_IO_WriteUserSizeData( nDevInfo,
+									 0,
+									 nDevInfo->Feature.SpareSize,
+									 nSpareBuffer );
+	if ( res != SUCCESS )
+		goto ErrorWriteUserSizePage;
+
+	/* Change Cycle */
+	NAND_IO_SetCommCycleTime();
+
+	if ( res != SUCCESS )
+		goto ErrorWriteUserSizePage;
+	
+	/* Command Page Program #2 [ 0x10 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusyForProgramAndErase( nDevInfo );
+
+	/* Check Status */
+	res = NAND_IO_ReadStatus( nDevInfo );
+	if ( res != SUCCESS )
+	{
+		nDevInfo->WriteStatus.ChipNo 			= (U8)nDevInfo->ChipNo;
+		nDevInfo->WriteStatus.BlockStatus 		= MULTI_PLANE_BAD_BLOCK;
+		nDevInfo->WriteStatus.ErrorPHYPageAddr 	= nPageAddr;
+		res = ERR_NAND_IO_FAILED_WRITE;
+		
+		goto ErrorWriteUserSizePage;
+	}
+
+ErrorWriteUserSizePage:
+	//=============================================
+	// FORCE TO SET WP LOW
+	// Disable Chip Select
+	// PostProcess
+	//=============================================
+	NAND_IO_EnableWriteProtect();
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+	
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_WriteChainPage
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_WriteGoldenPage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U8 *nPageBuffer, U8 *nSpareBuffer )
+{
+	unsigned int		RowAddr, ColumnAddr;	
+	NAND_IO_ERROR		res;
+
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+
+	//=============================================
+	// PreProcess
+	// Set Setup Time and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP HIGH
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_SetNFCBusWidth(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+		NAND_IO_ClearInterleaveStatus( nDevInfo );
+	else
+	{
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+		NAND_IO_DisableWriteProtect();
+	}
+
+	//=============================================
+	// ECC Encording
+	//=============================================
+	res = NAND_IO_EncodeChainDataForGoldenPage( nDevInfo, nPageBuffer, nSpareBuffer, ECC_ON );
+	if ( res != SUCCESS )
+		goto ErrorWriteUserSizePage;
+
+	//=============================================
+	// Write UserSize Data
+	//=============================================
+
+	/* Generate Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForWrite( nPageAddr, 0, &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorWriteUserSizePage;
+
+	/* Command Page Program #1 [ 0x80 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8080;
+
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* Change Cycle */
+	NAND_IO_SetWriteCycleTime();
+
+	/* Write Data to NAND FLASH */
+
+	//=============================================
+	// Write Data
+	//=============================================
+	res = NAND_IO_WriteUserSizeData( nDevInfo,
+									 0,
+									 nDevInfo->Feature.PageSize,
+									 nPageBuffer );
+	if ( res != SUCCESS )
+		goto ErrorWriteUserSizePage;
+	
+	//=============================================
+	// Write ECC Code
+	//=============================================
+	res = NAND_IO_WriteUserSizeData( nDevInfo,
+									 0,
+									 nDevInfo->Feature.SpareSize,
+									 nSpareBuffer );
+	if ( res != SUCCESS )
+		goto ErrorWriteUserSizePage;
+
+	/* Change Cycle */
+	NAND_IO_SetCommCycleTime();
+
+	if ( res != SUCCESS )
+		goto ErrorWriteUserSizePage;
+	
+	/* Command Page Program #2 [ 0x10 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusyForProgramAndErase( nDevInfo );
+
+	/* Check Status */
+	res = NAND_IO_ReadStatus( nDevInfo );
+	if ( res != SUCCESS )
+	{
+		nDevInfo->WriteStatus.ChipNo 			= (U8)nDevInfo->ChipNo;
+		nDevInfo->WriteStatus.BlockStatus 		= MULTI_PLANE_BAD_BLOCK;
+		nDevInfo->WriteStatus.ErrorPHYPageAddr 	= nPageAddr;
+		res = ERR_NAND_IO_FAILED_WRITE;
+		
+		goto ErrorWriteUserSizePage;
+	}
+
+ErrorWriteUserSizePage:
+	//=============================================
+	// FORCE TO SET WP LOW
+	// Disable Chip Select
+	// PostProcess
+	//=============================================
+	NAND_IO_EnableWriteProtect();
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+	
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_CopyBackPage
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_CopyBackPage( NAND_IO_DEVINFO *nDevInfo, U32 nDesPageAddr, U32 nSrcPageAddr )
+{
+	unsigned int		RowAddr, ColumnAddr;	
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+		
+	//=============================================
+	// PreProcess
+	// Set Setup Time and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP HIGH
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_SetNFCBusWidth(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+	NAND_IO_DisableWriteProtect();
+
+	//=============================================
+	// Read Source Page Address
+	//=============================================
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+	
+	/* Generate Src Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForCBandCP( nSrcPageAddr, 0, &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorCopyBackPage;
+
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* CopyBack Command #1 [ 0x35 ] */
+	if ( nDevInfo->Feature.MediaType & A_BIG )
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3535;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	//=============================================
+	// Copy Destination Page Address
+	//=============================================
+	/* CopyBack Command #2 */
+	if ( nDevInfo->Feature.MediaType & A_SMALL )
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8A8A;
+	else
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8585;
+
+	/* Generate Des Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForCBandCP( nDesPageAddr, 0, &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorCopyBackPage;
+
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* Waiting TADL Time 200nS */
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+
+	/* CopyBack Command #3 */
+	if ( nDevInfo->Feature.MediaType & A_SMALL )
+	{
+		// [ 32MB] K9F5608U0C, k9F5608U0B, K9F5608U0A
+		// [ 32MB] K9F5608Q0C, K9F5608Q0B
+		if (( nDevInfo->Feature.DeviceID.Code[0] == SAMSUNG_NAND_MAKER_ID ) &&
+			(( nDevInfo->Feature.DeviceID.Code[1] == 0x75 ) || ( nDevInfo->Feature.DeviceID.Code[1] == 0x35 )))
+		{
+			// Nothing
+		}
+		else
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+	}
+	else
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusyForProgramAndErase( nDevInfo );
+		
+	/* Check Status */
+	res = NAND_IO_ReadStatus( nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorCopyBackPage;
+
+ErrorCopyBackPage:
+	//=============================================
+	// FORCE TO SET WP LOW
+	// Disable Chip Select
+	// PostProcess
+	//=============================================
+	NAND_IO_EnableWriteProtect();
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+		
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_CopyBackTwoPlanePage
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_CopyBackTwoPlanePage( NAND_IO_DEVINFO *nDevInfo, U32 nDesPageAddr, U32 nSrcPageAddr )
+{
+	unsigned int		nReBlockPageAddr;
+	unsigned int		RowAddr, ColumnAddr;	
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+		
+	//=============================================
+	// PreProcess
+	// Set Setup Time and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP HIGH
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_SetNFCBusWidth(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+	NAND_IO_DisableWriteProtect();
+
+	//=============================================
+	// Read Source Page Address #1
+	//=============================================
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+	
+	/* Generate Src Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForCBandCP( nSrcPageAddr, 0, &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorCopyBackPage;
+
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* CopyBack Command #1 [ 0x35 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3535;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	//=============================================
+	// Read Source Page Address #2
+	//=============================================
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+	
+	/* Generate Src Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForCBandCP( nSrcPageAddr + nDevInfo->Feature.PpB, 0, &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorCopyBackPage;
+
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* CopyBack Command #1 [ 0x35 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3535;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	//=============================================
+	// Copy Destination Page Address
+	//=============================================
+	/* CopyBack Command #2 */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8585;
+
+	if ( nDesPageAddr & ( nDevInfo->Feature.PBpV / 2) * nDevInfo->Feature.PpB )
+		nReBlockPageAddr = (( nDevInfo->Feature.PBpV / 2) * nDevInfo->Feature.PpB);
+	else
+		nReBlockPageAddr = 0;
+		
+	/* Generate Des Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForCBandCP( nReBlockPageAddr, 0, &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorCopyBackPage;
+
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* Waiting TADL Time 200nS */
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+
+
+	/* CopyBack Command #3 */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1111;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusyForProgramAndErase( nDevInfo );
+		
+	/* Check Status */
+	res = NAND_IO_ReadStatus( nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorCopyBackPage;
+
+	//=============================================
+	// Copy Destination Page Address
+	//=============================================
+	/* CopyBack Command #2 */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8181;
+
+	/* Generate Des Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForCBandCP( nDesPageAddr+ nDevInfo->Feature.PpB, 0, &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorCopyBackPage;
+
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* Waiting TADL Time 200nS */
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+
+
+	/* CopyBack Command #3 */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusyForProgramAndErase( nDevInfo );
+		
+	/* Check Status */
+	res = NAND_IO_ReadStatus( nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorCopyBackPage;
+
+ErrorCopyBackPage:
+	//=============================================
+	// FORCE TO SET WP LOW
+	// Disable Chip Select
+	// PostProcess
+	//=============================================
+	NAND_IO_EnableWriteProtect();
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+		
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_EraseBlock
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_EraseBlock( NAND_IO_DEVINFO *nDevInfo, U32 nBlockPageAddr, int nFormatMode )
+{
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+
+	//=============================================
+	// PreProcess
+	// Set Setup Time and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP HIGH
+	//=============================================
+	NAND_IO_PreProcess();
+	NAND_IO_SetNFCBusWidth(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+		NAND_IO_WaitBusyForInterleave( nDevInfo, nBlockPageAddr );
+	else
+	{
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+		NAND_IO_DisableWriteProtect();
+	}
+
+	//=============================================
+	// Erase Block
+	//=============================================
+
+	/* Command Block Erase #1 [ 0x60 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x6060;
+
+	/* Write Block Address */
+	NAND_IO_WriteBlockPageAddr( nBlockPageAddr, nDevInfo );
+
+	/* Command Erase Block #2 [ 0xD0 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0xD0D0;
+
+	if ( !( ( nDevInfo->Feature.MediaType & S_IL ) || ( nDevInfo->ExtInterleaveUsable == TRUE ) ) || ( nFormatMode == INTER_LEAVE_OFF ) )
+	{
+	    /* Wait until it is ready */
+	    NAND_IO_WaitBusyForProgramAndErase( nDevInfo );
+    
+	    /* Check Status */
+	    res = NAND_IO_ReadStatus( nDevInfo );
+	    if ( res != SUCCESS )
+	    {
+			nDevInfo->BadBlockInfo.BlockStatus[nDevInfo->ChipNo] 	= MULTI_PLANE_BAD_BLOCK;
+			nDevInfo->BadBlockInfo.BadBlkPHYAddr[nDevInfo->ChipNo]	= nBlockPageAddr;
+		    goto ErrorEraseBlock;
+		}
+	}
+	else
+	{
+		NAND_IO_SetInterleaveStatus( nDevInfo, nBlockPageAddr );
+		if ( nDevInfo->BadBlockInfo.BlockStatus[nDevInfo->ChipNo]  != MULTI_PLANE_BAD_BLOCK )
+			nDevInfo->BadBlockInfo.BadBlkPHYAddr[nDevInfo->ChipNo]	= nBlockPageAddr;
+		res = (NAND_IO_ERROR)SUCCESS;
+	}
+ErrorEraseBlock:
+	//=============================================
+	// FORCE TO SET WP LOW
+	// Disable Chip Select
+	// PostProcess
+	//=============================================
+	if ( !( ( nDevInfo->Feature.MediaType & S_IL ) || ( nDevInfo->ExtInterleaveUsable == TRUE  ) ) )
+		NAND_IO_EnableWriteProtect();
+
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_EraseBlockForTwoPlane
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_EraseBlockForTwoPlane( NAND_IO_DEVINFO *nDevInfo, U32 nBlockPageAddr, int nFormatMode )
+{
+	unsigned int		nReBlockPageAddr;
+	unsigned long int	dwTempBlockPageAddr, dwAddSecondPageAddr;
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+
+	res = (NAND_IO_ERROR)SUCCESS;
+
+	//=============================================
+	// PreProcess
+	// Set Setup Time and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP HIGH
+	//=============================================
+	NAND_IO_PreProcess();
+	NAND_IO_SetNFCBusWidth(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+		NAND_IO_WaitBusyForInterleave( nDevInfo, nBlockPageAddr );
+	else
+	{
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+		NAND_IO_DisableWriteProtect();
+	}
+
+	//=============================================
+	// Erase Block
+	//=============================================
+    /* Command Block Erase #1 [ 0x60 ] */
+    pNFC->NFC_CMD = nDevInfo->CmdMask & 0x6060;
+
+	if ( ( nDevInfo->Feature.DeviceID.Code[0] == SAMSUNG_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == HYNIX_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == ST_NAND_MAKER_ID ) )
+    {
+	    dwTempBlockPageAddr = ( ( nDevInfo->Feature.PBpV << nDevInfo->ShiftPpB ) >> 1 );
+
+ 	    if ( nBlockPageAddr & dwTempBlockPageAddr )
+ 		    nReBlockPageAddr = dwTempBlockPageAddr;
+	    else
+		    nReBlockPageAddr = 0;
+
+	    dwAddSecondPageAddr = nDevInfo->Feature.PpB;
+    }
+    else if ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID ) 
+    {
+	    nReBlockPageAddr = nBlockPageAddr;
+		dwAddSecondPageAddr = ( nDevInfo->DistrictNum << nDevInfo->ShiftPpB );
+    }
+	else if ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID ) 
+	{
+		nReBlockPageAddr = nBlockPageAddr;
+		dwAddSecondPageAddr = nDevInfo->Feature.PpB;
+	}
+	else
+	{
+		// Local variable Init
+		nReBlockPageAddr = 0;
+		dwAddSecondPageAddr = 0;
+
+		res = ERR_NAND_IO_WRONG_PARAMETER;
+		goto ErrorEraseBlock;
+	}
+    
+    /* Write Block Address */
+    NAND_IO_WriteBlockPageAddr( nReBlockPageAddr, nDevInfo ); // <==  1st Block
+
+    /* Command Block Erase #1 [ 0x60 ] */
+    pNFC->NFC_CMD = nDevInfo->CmdMask & 0x6060;
+
+    /* Write Block Address */
+    NAND_IO_WriteBlockPageAddr( nBlockPageAddr + dwAddSecondPageAddr, nDevInfo );	// <==  2nd Block
+
+    /* Command Erase Block #2 [ 0xD0 ] */
+    pNFC->NFC_CMD = nDevInfo->CmdMask & 0xD0D0;
+
+    if ( !( ( nDevInfo->Feature.MediaType & S_IL ) || ( nDevInfo->ExtInterleaveUsable == TRUE ) ) || ( nFormatMode == INTER_LEAVE_OFF ) )
+    {
+	    /* Wait until it is ready */
+	    NAND_IO_WaitBusyForProgramAndErase( nDevInfo );
+
+	    /* Check Status */
+	    res = NAND_IO_ReadStatusForMultiPlane( nDevInfo );
+	    if ( res != SUCCESS )
+		{
+			if ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID )
+			{
+				if ( res == NAND_IO_DISTRICT_0 )
+				{
+					nDevInfo->BadBlockInfo.BlockStatus[0]	= MULTI_PLANE_BAD_BLOCK;
+					nDevInfo->BadBlockInfo.BadBlkPHYAddr[0] = nBlockPageAddr;
+				}
+				else if ( res == NAND_IO_DISTRICT_1 )
+				{
+					nDevInfo->BadBlockInfo.BlockStatus[1] 	= MULTI_PLANE_BAD_BLOCK;
+					nDevInfo->BadBlockInfo.BadBlkPHYAddr[1] = ( nBlockPageAddr + dwAddSecondPageAddr );
+				}
+			}
+			else
+			{
+				nDevInfo->BadBlockInfo.BlockStatus[0]	= MULTI_PLANE_BAD_BLOCK;
+				nDevInfo->BadBlockInfo.BadBlkPHYAddr[0] = nBlockPageAddr;
+				nDevInfo->BadBlockInfo.BlockStatus[1] 	= MULTI_PLANE_BAD_BLOCK;
+				nDevInfo->BadBlockInfo.BadBlkPHYAddr[1] = ( nBlockPageAddr + dwAddSecondPageAddr );
+			}
+			
+			goto ErrorEraseBlock;
+		}
+	}
+    else
+    {
+	    NAND_IO_SetInterleaveStatus( nDevInfo, nBlockPageAddr );
+
+		if ( nDevInfo->Feature.MediaType & S_IL )
+		{
+			//=============================================	
+			// Inter Leave
+			//=============================================	
+			if ( nBlockPageAddr < (U32)( ( nDevInfo->Feature.PBpV >> 1 ) << nDevInfo->ShiftPpB ) )
+			{
+				if ( nDevInfo->BadBlockInfo.BlockStatus[0] != MULTI_PLANE_BAD_BLOCK )
+					nDevInfo->BadBlockInfo.BadBlkPHYAddr[0] = nBlockPageAddr;
+
+				if ( nDevInfo->BadBlockInfo.BlockStatus[1] != MULTI_PLANE_BAD_BLOCK )
+					nDevInfo->BadBlockInfo.BadBlkPHYAddr[1] = ( nBlockPageAddr + dwAddSecondPageAddr );
+			}
+			else
+			{
+				if ( nDevInfo->BadBlockInfo.BlockStatus[2] != MULTI_PLANE_BAD_BLOCK )
+					nDevInfo->BadBlockInfo.BadBlkPHYAddr[2] = nBlockPageAddr;
+
+				if ( nDevInfo->BadBlockInfo.BlockStatus[3] != MULTI_PLANE_BAD_BLOCK )
+					nDevInfo->BadBlockInfo.BadBlkPHYAddr[3] = ( nBlockPageAddr + dwAddSecondPageAddr );
+			}
+		}
+		else if ( nDevInfo->ExtInterleaveUsable == TRUE )
+		{
+			if ( nDevInfo->BadBlockInfo.BlockStatus[0] != MULTI_PLANE_BAD_BLOCK )
+				nDevInfo->BadBlockInfo.BadBlkPHYAddr[0] = nBlockPageAddr;
+
+			if ( nDevInfo->BadBlockInfo.BlockStatus[1] != MULTI_PLANE_BAD_BLOCK )
+				nDevInfo->BadBlockInfo.BadBlkPHYAddr[1] = ( nBlockPageAddr + dwAddSecondPageAddr );
+		}
+    }
+
+ErrorEraseBlock:
+	//=============================================
+	// FORCE TO SET WP LOW
+	// Disable Chip Select
+	// PostProcess
+	//=============================================
+	if ( !( ( nDevInfo->Feature.MediaType & S_IL ) || ( nDevInfo->ExtInterleaveUsable == TRUE  ) ) )
+		NAND_IO_EnableWriteProtect();
+
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+
+	if ( res != SUCCESS )
+		return res;
+
+	return (NAND_IO_ERROR)SUCCESS;
+	
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_GetFactoryBadMarkOfPBlock
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_GetFactoryBadMarkOfPBlock( NAND_IO_DEVINFO *nDevInfo, U32 nBlockPageAddr )
+{
+    unsigned short int	i;	
+	unsigned short int	wPageSize, wReadSize;
+	unsigned short int	wColumnAddr;
+	unsigned short int	wPageAddr;
+	unsigned char		cBSA[512];
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+
+	//=============================================	
+	// Get Factory Bad Mark Page Default 
+	//=============================================	
+	if ( nDevInfo->Feature.MediaType & A_MLC )
+		wPageAddr = nDevInfo->Feature.PpB - 1; /*last page*/
+	else
+		wPageAddr = 0;  /*First Page*/ 
+
+	//=============================================	
+	// Setting ReadSize & Column Address 
+	//=============================================	
+	wReadSize = 1; 
+	wPageSize = nDevInfo->Feature.PageSize;
+
+	//=============================================
+	// Exception: Micron  
+	//=============================================
+	if ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID )
+	{
+		if ( ( nDevInfo->Feature.MediaType & A_MLC_8BIT ) || ( nDevInfo->Feature.MediaType & A_MLC_12BIT ) )
+		{	
+		wPageAddr = 0;
+			wReadSize = nDevInfo->Feature.SpareSize;
+		}
+		else 
+	{
+			/*SLC, MLC(4BIT/12BIT)*/
+		wPageAddr = 0;
+			wReadSize = 1;
+		}
+	}
+
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+	{
+		wPageSize = ( wPageSize >> 1 );
+		wReadSize = ( wReadSize << 1 );
+	}
+	
+	if ( wPageSize == 512 )			/* SMALL BLOCK NANDFLASH */
+		wColumnAddr = 517;
+	else if ( wPageSize == 2048 )	/* BIG BLOCK NANDFLAHS */
+		wColumnAddr = 2048;
+	else if ( wPageSize == 4096 )	/* 4K Page BIG BLOCK NANDFLASH */
+		wColumnAddr = 4096;
+	else
+		return ERR_NAND_IO_FAILED_GET_FACTORY_BAD_MARK_OF_PBLOCK;
+	
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		wColumnAddr = ( wColumnAddr << 1 );
+
+	/* Read BSA */
+	res = NAND_IO_ReadUserSizePage( nDevInfo,
+									nBlockPageAddr + wPageAddr,
+									wColumnAddr,
+									wReadSize,
+									&cBSA[0] );
+	if ( res != SUCCESS )
+		return res;
+
+	/* Check BSA */
+	res = (NAND_IO_ERROR)SUCCESS;
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+	{
+		//============================================
+		//PARALLEL: Check Signature(00h) of BadBlock 
+		//============================================
+		for( i = 0 ; i < wReadSize; i += 2 )
+		{
+			if ( cBSA[i] != 0xFF )
+				res |= NAND_IO_STATUS_FAIL_CS0_PARALLEL;
+			if ( cBSA[i+1] != 0xFF )	
+				res |= NAND_IO_STATUS_FAIL_CS1_PARALLEL;
+
+            if( res != SUCCESS )
+                return res; 			
+		}
+	}
+	else
+	{
+		//============================================
+		//SERIAL: Check Signature(00h) of BadBlock   
+		//============================================
+		for( i = 0 ; i < wReadSize; ++ i )
+		{
+			if ( cBSA[i] != 0xFF )
+				res |= NAND_IO_STATUS_FAIL_CS0_SERIAL;
+
+            if ( res != SUCCESS )
+                return res;
+		}
+	}
+
+	return res;
+
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_GetUID
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_GetUID( NAND_IO_DEVINFO *nDevInfo, U16 *nCmd, U8 *rReadData )
+{
+	unsigned int		i;
+	unsigned int		RowAddr, ColumnAddr;
+	unsigned char		cTempBuffer[512];
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+
+	//=============================================
+	// PreProcess
+	// Set Setup and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP LOW
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_SetNFCBusWidth(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+	NAND_IO_EnableWriteProtect();
+
+	/* Command #1 */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & *nCmd;
+	/* Command #2 */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & *(nCmd+1);
+
+	/* Generate Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForRead( 0, 0, &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorGetUID;
+
+	/* Write Row and Column Address	*/
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* Command READ2 [ 0x30 ] for Advance NandFlash */
+	if ( nDevInfo->Feature.MediaType & A_BIG )
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+	
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	/* Read Data */
+	res = NAND_IO_ReadUserSizeData( nDevInfo,
+									0,
+									512,
+									cTempBuffer );
+	if ( res != SUCCESS )
+		goto ErrorGetUID;
+
+	/* Copy Read Data */
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+	{
+		for ( i = 0; i < 256; ++ i )
+			rReadData[i] = cTempBuffer[i*2+0];
+	}
+	else
+	{
+		for ( i = 0; i < 256; ++ i )
+			rReadData[i] = cTempBuffer[i];
+	}
+
+ErrorGetUID:
+	//=============================================
+	// FORCE TO SET WP LOW
+	// Disable Chip Select
+	// PostProcess
+	//=============================================
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+
+	//=============================================
+	// Reset Chip
+	//=============================================	
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_Reset( nDevInfo->ChipNo, NAND_IO_PARALLEL_COMBINATION_MODE );
+	else
+		NAND_IO_Reset( nDevInfo->ChipNo, NAND_IO_SERIAL_COMBINATION_MODE );
+
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+
+}
+
+//*****************************************************************************
+//*
+//*
+//*					[ MISCELLANEOUS Functions of NAND IO ]
+//*
+//*
+//*****************************************************************************
+static __inline void NAND_IO_SetDataWidth( U32 width )
+{
+	if ( width == NAND_IO_DATA_WITDH_8BIT )
+		BITCLR( pNFC->NFC_CTRL, HwNFC_CTRL_BW_16 );
+	else
+		BITSET( pNFC->NFC_CTRL, HwNFC_CTRL_BW_16 );
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_PortControl( void );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			None
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_PortControl( int nOnOff )  
+{
+	if ( !( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+	{
+		if ( gNAND_GPIO_ON_OFF == ENABLE )
+		{
+			if ( nOnOff == ENABLE )
+			{
+				#if defined(TCC83XX)
+				NAND_IO_SEL_REG = gNANDIO_GSELReg;
+				#endif
+				#if defined(TCC79X)
+				// PORTCFG5 Configuration  ( TCC7930S B[0]~B[6] is reserved )
+				// B[0] = NDXD[0]
+				// B[1] = NDXD[1]
+				// B[2] = NDXD[2]
+				// B[3] = NDXD[3]
+				// B[4] = NDXD[4]
+				// B[5] = NDXD[5]
+				// B[6] = NDXD[6]
+				HwPORTCFG5 &= (0xF0000000);
+				HwPORTCFG5 |= (0x01111111);
+
+				// PORTCFG6 Configuration
+				// B[7] = NDXD[7]				
+				BITCSET( HwPORTCFG6, HwPORTCFG6_GPIOB7(15), HwPORTCFG6_GPIOB7(1));
+				
+		        #ifndef NAND_8BIT_ONLY
+				// PORTCFG2 Configuration
+				// F[15:12] = NDXD[15:12]
+				BITCSET( HwPORTCFG2, HwPORTCFG2_HPXD11(15), HwPORTCFG2_HPXD11(2));
+				// F[11:8]  = NDXD[11:8]
+				BITCSET( HwPORTCFG2, HwPORTCFG2_HPXD15(15), HwPORTCFG2_HPXD15(2));
+				#endif
+				#endif
+			}
+			else
+			{
+				#if defined(TCC83XX)
+				NAND_IO_SEL_REG = 0;
+				NAND_IO_IOCON_REG |= gNANDIO_GIOCONReg;
+				NAND_IO_GDATA 	  |= gNANDIO_GDATASet;
+				#endif
+				#if defined(TCC79X)
+				// PORTCFG5 Configuration  ( TCC7930S B[0]~B[6] is reserved )
+				// B[0] = NDXD[0]
+				// B[1] = NDXD[1]
+				// B[2] = NDXD[2]
+				// B[3] = NDXD[3]
+				// B[4] = NDXD[4]
+				// B[5] = NDXD[5]
+				// B[6] = NDXD[6]
+				HwPORTCFG5 &= (0xF0000000);
+
+				// PORTCFG6 Configuration
+				// B[7] = NDXD[7]				
+				BITCSET( HwPORTCFG6, HwPORTCFG6_GPIOB7(15), HwPORTCFG6_GPIOB7(0));
+				HwGPBEN		|= 0x000000FF;
+				HwGPBDAT	|= 0x000000FF;
+				
+		        #ifndef NAND_8BIT_ONLY
+				// PORTCFG2 Configuration 
+				// F[11:8]  = NDXD[11:8]
+				BITCSET( HwPORTCFG2, HwPORTCFG2_HPXD11(15), HwPORTCFG2_HPXD11(1));
+				// F[15:12] = NDXD[15:12]
+				BITCSET( HwPORTCFG2, HwPORTCFG2_HPXD15(15), HwPORTCFG2_HPXD15(1));
+				HwGPFEN		|= 0x0000FF00;
+				HwGPFDAT 	|= 0x0000FF00;				
+				#endif
+				#endif
+			}
+		}
+	}
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_PreProcess( void );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			None
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_PreProcess( void )
+{
+	NAND_IO_PortControl( ENABLE );
+	
+	//IO_CKC_EnableBUS( IO_CKC_BUS_NFC );
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_PostProcess( void );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			None
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_PostProcess( void )
+{
+	//IO_CKC_DisableBUS( IO_CKC_BUS_NFC );
+		
+	NAND_IO_PortControl( DISABLE );
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_SetBasicCycleTime( void );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			None
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_SetBasicCycleTime( void )
+{
+	/* SETUP 1 PW 5 HOLD 1 */
+	BITCSET( pNFC->NFC_CTRL, 0xFFF, 0xFFF );
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_SetCommCycleTime(void);
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			None
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_SetCommCycleTime(void)
+{
+	BITCSET( pNFC->NFC_CTRL, 0xFFF, CommCycleTime.RegValue );
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_SetWriteCycleTime(void);
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			None
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_SetWriteCycleTime(void)
+{
+	BITCSET( pNFC->NFC_CTRL, 0xFFF, WriteCycleTime.RegValue );
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_SetReadCycleTime(void);
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			None
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_SetReadCycleTime(void)
+{
+	BITCSET( pNFC->NFC_CTRL, 0xFFF, ReadCycleTime.RegValue );
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_SetNFCBusWidth(NAND_IO_DEVINFO *nDevInfo);
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			NAND_IO_DEVINFO Structure Variable Pointer
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_SetNFCBusWidth( NAND_IO_DEVINFO *nDevInfo )
+{
+	if ( nDevInfo->Feature.MediaType & A_08BIT )	
+		BITCLR( pNFC->NFC_CTRL, HwNFC_CTRL_MASK_EN );
+	else
+		BITSET( pNFC->NFC_CTRL, HwNFC_CTRL_MASK_EN );
+
+}
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_EnableChipSelect( U16 nChipNo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nChipNo	= 
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_EnableChipSelect( U16 nChipNo )
+{
+	if ( nChipNo == 0 )
+	{
+		/* NAND_IO_SUPPORT_4CS */
+		#if defined(NAND_2CS_ONLY)
+		BITSCLR( pNFC->NFC_CTRL, HwNFC_CTRL_CFG_nCS1, HwNFC_CTRL_CFG_nCS0 );
+		#else
+		BITSCLR( pNFC->NFC_CTRL, HwNFC_CTRL_CFG_NOACT, HwNFC_CTRL_CFG_nCS0 );
+		#endif
+	}
+	else if ( nChipNo == 1 )
+	{
+		/* NAND_IO_SUPPORT_4CS */
+		#if defined(NAND_2CS_ONLY)
+		BITSCLR( pNFC->NFC_CTRL, HwNFC_CTRL_CFG_nCS0, HwNFC_CTRL_CFG_nCS1 );
+		#else
+		BITSCLR( pNFC->NFC_CTRL, HwNFC_CTRL_CFG_NOACT, HwNFC_CTRL_CFG_nCS1 );
+		#endif
+	}
+	else if ( nChipNo == 2 )
+	{
+		/* NAND_IO_SUPPORT_4CS */
+		BITSCLR( pNFC->NFC_CTRL, HwNFC_CTRL_CFG_NOACT, HwNFC_CTRL_CFG_nCS2 );
+	}
+	else if ( nChipNo == 3 )
+	{
+		/* NAND_IO_SUPPORT_4CS */
+		BITSCLR( pNFC->NFC_CTRL, HwNFC_CTRL_CFG_NOACT, HwNFC_CTRL_CFG_nCS3 );
+	}
+
+	#if defined(_WINCE_) || defined(_LINUX_)
+	//NAND_IO_Delay();
+    #endif
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_DisableChipSelect( void );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			None
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_DisableChipSelect( void )
+{
+	/* NAND_IO_SUPPORT_4CS */
+	#if defined(NAND_2CS_ONLY)
+	BITSET( pNFC->NFC_CTRL, ( HwNFC_CTRL_CFG_nCS0 | HwNFC_CTRL_CFG_nCS1 ) ); 
+	#else
+	BITSET( pNFC->NFC_CTRL, HwNFC_CTRL_CFG_NOACT );
+	#endif
+
+	#if defined(_WINCE_) || defined(_LINUX_)
+	//NAND_IO_Delay();
+    #endif
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_EnableWriteProtect( void );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			None
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_EnableWriteProtect( void )
+{
+	#if defined(USE_V_ADDRESS)
+		#if defined(_WINCE_)
+		BITCLR( pGPIO->GPBDAT, NAND_IO_NFC_nWPBit );
+        #else
+        BITCLR( NAND_IO_NFC_nWP, NAND_IO_NFC_nWPBit );
+		#endif
+	#else
+	BITCLR( NAND_IO_NFC_nWP, NAND_IO_NFC_nWPBit );
+	#endif
+
+	#if defined(_WINCE_) || defined(_LINUX_)
+	//NAND_IO_Delay();
+    #endif
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_DisableWriteProtect( void );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			None
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_DisableWriteProtect( void )
+{
+	#if defined(USE_V_ADDRESS)
+		#if defined(_WINCE_)
+		BITSET( pGPIO->GPBDAT, NAND_IO_NFC_nWPBit );
+        #else
+	    BITSET( NAND_IO_NFC_nWP, NAND_IO_NFC_nWPBit );        
+		#endif
+	#else
+	BITSET( NAND_IO_NFC_nWP, NAND_IO_NFC_nWPBit );
+	#endif
+	
+	#if defined(_WINCE_) || defined(_LINUX_)
+	//NAND_IO_Delay();
+    #endif
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline U32 NAND_IO_CheckReadyAndBusy( U16 nChipNo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nChipNo	= 
+*  
+*  OUTPUT:	U32 - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline U32 NAND_IO_CheckReadyAndBusy( U16 nChipNo )
+{
+	nChipNo = 0;	// Warning
+
+	#if defined(TCC89_92_BOARD)
+	return ISZERO( pNFC->NFC_CTRL, HwNFC_CTRL_RDY_RDY );
+	#else	// TCC9200S_BOARD
+	return ISZERO( HwGPIOB->GPDAT, Hw31);
+	#endif
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_WaitBusy( U16 nChipNo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nChipNo	= 
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_WaitBusy( U16 nChipNo )
+{
+	// Misc. Configuration Register(MCFG)
+   	// 0 : represent that READY pin is low
+   	// 1 :                             high
+   	// Delay : 200nS
+
+	#ifdef READ_SPEED_CHECK   	
+	NAND_IO_GPIO_Toggle(Hw13);
+	#endif
+	
+   	NAND_IO_Delay();
+
+	#ifdef READ_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw13);
+	#endif
+	
+	while (NAND_IO_CheckReadyAndBusy( nChipNo ));
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_WaitBusyForProgramAndErase( NAND_IO_DEVINFO *nDevInfo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nDevInfo	= 
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_WaitBusyForProgramAndErase( NAND_IO_DEVINFO *nDevInfo )
+{
+	// Misc. Configuration Register(MCFG)
+   	// 0 : represent that READY pin is low
+   	// 1 :                             high
+   	// Delay : 200nS
+   	NAND_IO_Delay();
+
+	while (NAND_IO_CheckReadyAndBusy( nDevInfo->ChipNo ))
+	{
+		#ifndef FWDN_DOWNLOADER_INCLUDE
+		TCC7XX_USBDRV_WriteToQueue();
+		#endif
+	}
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_WaitBusyForCacheProgram( NAND_IO_DEVINFO *nDevInfo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nDevInfo	= 
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_WaitBusyForCacheProgram( NAND_IO_DEVINFO *nDevInfo )
+{
+	// Misc. Configuration Register(MCFG)
+   	// 0 : represent that READY pin is low
+   	// 1 :                             high
+   	// Delay : 200nS
+   	NAND_IO_Delay();
+
+	while (NAND_IO_CheckReadyAndBusy( nDevInfo->ChipNo ))
+	{
+		#ifndef FWDN_DOWNLOADER_INCLUDE
+		TCC7XX_USBDRV_WriteToQueue();
+		#endif
+	}
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_WaitBusyForInterleave( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nDevInfo	= 
+*			nPageAddr	= 
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_WaitBusyForInterleave( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr )
+{
+	unsigned int		ChipNum = 0;
+	NAND_IO_ERROR		res;
+
+	NAND_IO_Delay();
+	gInterLeaveWriteStatus = MULTI_PLANE_GOOD_BLOCK;
+
+	if ( gDevInfo->Feature.MediaType & S_IL )
+	{
+		//=============================================	
+		// Inter Leave
+		//=============================================	
+		if ( gInterLeaveCSNum != nDevInfo->ChipNo )
+		{
+			NAND_IO_EnableChipSelect( (U16)gInterLeaveCSNum );
+			NAND_IO_DisableWriteProtect();
+			nDevInfo->WriteStatus.ChipNo = (U8)gDevInfo->ChipNo;
+
+			while ( NAND_IO_ReadStatusForInterleaveClear( gDevInfo ) )
+			{
+				#ifndef FWDN_DOWNLOADER_INCLUDE
+				TCC7XX_USBDRV_WriteToQueue();
+				#endif
+			}
+	  	}
+		else
+		{
+			NAND_IO_EnableChipSelect( (U16)gInterLeaveCSNum );
+			NAND_IO_DisableWriteProtect();
+			nDevInfo->WriteStatus.ChipNo = (U8)nDevInfo->ChipNo;
+
+			   	while ( NAND_IO_ReadStatusForInterleave( gDevInfo, nPageAddr ) )
+			{
+				#ifndef FWDN_DOWNLOADER_INCLUDE
+				TCC7XX_USBDRV_WriteToQueue();
+				#endif
+			}
+		}
+
+		NAND_IO_DisableChipSelect();
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+	}
+	else if ( nDevInfo->ExtInterleaveUsable == TRUE )
+	{
+		//=============================================	
+		// External Inter Leave
+		//=============================================	
+		if ( nDevInfo->ChipNo == 0 )
+			ChipNum = NAND_IO_STATUS_INTERLEAVING_CHIP1;
+		else if ( nDevInfo->ChipNo == 1 )
+			ChipNum = NAND_IO_STATUS_INTERLEAVING_CHIP2;
+		else if ( nDevInfo->ChipNo == 2 )
+			ChipNum = NAND_IO_STATUS_INTERLEAVING_CHIP3;
+		else if ( nDevInfo->ChipNo == 3 )
+			ChipNum = NAND_IO_STATUS_INTERLEAVING_CHIP4;
+
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+		NAND_IO_DisableWriteProtect();
+
+		if ( gInterLeaveIoStatus & (U16)ChipNum )
+		{
+			NAND_IO_WaitBusyForProgramAndErase( gDevInfo );
+		    res = NAND_IO_ReadStatus( gDevInfo );
+		    if ( res != SUCCESS )
+			{
+				nDevInfo->WriteStatus.ChipNo = (U8)gDevInfo->ChipNo;
+				nDevInfo->BadBlockInfo.BlockStatus[gDevInfo->ChipNo] = MULTI_PLANE_BAD_BLOCK; 
+				gInterLeaveWriteStatus = MULTI_PLANE_BAD_BLOCK;	
+			}
+			gInterLeaveIoStatus &= ~ChipNum;
+		}
+	}
+
+	if ( gInterLeaveWriteStatus == MULTI_PLANE_BAD_BLOCK )
+	{ 
+		nDevInfo->WriteStatus.BlockStatus 		= MULTI_PLANE_BAD_BLOCK;
+		nDevInfo->WriteStatus.ErrorPHYPageAddr 	= gInterLeavePageAddr;
+		gInterLeaveWriteStatus 					= MULTI_PLANE_GOOD_BLOCK;
+		res = ERR_NAND_IO_FAILED_WRITE;
+	}
+	else
+	{
+		nDevInfo->WriteStatus.BlockStatus 		= MULTI_PLANE_GOOD_BLOCK;		
+		nDevInfo->WriteStatus.ErrorPHYPageAddr 	= 0xFFFFFFFF;
+		res = (NAND_IO_ERROR)SUCCESS;
+	}
+
+	return res;
+	
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      NAND_IO_ERROR NAND_IO_WaitBusyCheckForWriteEnd( NAND_IO_DEVINFO *nDevInfo )
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nDevInfo	= 
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+NAND_IO_ERROR	NAND_IO_WaitBusyCheckForWriteEnd( NAND_IO_DEVINFO *nDevInfo )
+{
+	NAND_IO_Delay();
+	NAND_IO_PreProcess();
+ 
+	if ( nDevInfo->Feature.MediaType & S_IL )
+	{
+		//=============================================	
+		// Inter Leave
+		//=============================================	
+
+	   	if ( gInterLeaveCSNum != nDevInfo->ChipNo )
+		{
+			NAND_IO_EnableChipSelect( (U16)gInterLeaveCSNum );
+			NAND_IO_DisableWriteProtect();
+
+			while ( NAND_IO_ReadStatusForInterleaveClear( nDevInfo ) )
+			{
+				#ifndef FWDN_DOWNLOADER_INCLUDE
+				TCC7XX_USBDRV_WriteToQueue();
+				#endif
+			}
+
+			NAND_IO_DisableChipSelect();
+			NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+		}
+		else
+		{
+			NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+			NAND_IO_DisableWriteProtect();
+
+			while ( NAND_IO_ReadStatusForInterleave( nDevInfo, gInterLeavePageAddr ) )
+			{
+				#ifndef FWDN_DOWNLOADER_INCLUDE
+				TCC7XX_USBDRV_WriteToQueue();
+				#endif
+			}
+		}
+	}
+	else if ( nDevInfo->ExtInterleaveUsable == TRUE )
+	{
+		//=============================================	
+		// External Inter Leave
+		//=============================================	
+
+		if ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_CHIP1 )
+		{
+			NAND_IO_EnableChipSelect( 0 );
+			NAND_IO_DisableWriteProtect();
+			NAND_IO_WaitBusy(0);
+
+			gInterLeaveIoStatus &= ~NAND_IO_STATUS_INTERLEAVING_CHIP1;
+
+			NAND_IO_DisableChipSelect();
+		}
+
+		if ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_CHIP2 )
+		{
+			NAND_IO_EnableChipSelect( 1 );
+			NAND_IO_DisableWriteProtect();
+			NAND_IO_WaitBusy(1);
+
+			gInterLeaveIoStatus &= ~NAND_IO_STATUS_INTERLEAVING_CHIP2;
+
+			NAND_IO_DisableChipSelect();
+		}
+
+		if ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_CHIP3 )
+		{
+			NAND_IO_EnableChipSelect( 2 );
+			NAND_IO_DisableWriteProtect();
+			NAND_IO_WaitBusy(2);
+
+			gInterLeaveIoStatus &= ~NAND_IO_STATUS_INTERLEAVING_CHIP3;
+
+			NAND_IO_DisableChipSelect();
+		}
+		
+		if ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_CHIP4 )
+		{
+			NAND_IO_EnableChipSelect( 3 );
+			NAND_IO_DisableWriteProtect();
+			NAND_IO_WaitBusy(3);
+
+			gInterLeaveIoStatus &= ~NAND_IO_STATUS_INTERLEAVING_CHIP4;
+
+			NAND_IO_DisableChipSelect();
+		}
+	}
+	
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_SetInterleaveStatus( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nDevInfo	= 
+*			nPageAddr	= 
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_SetInterleaveStatus( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr )
+{
+
+	if ( nDevInfo->Feature.MediaType & S_IL )
+	{
+		//=============================================	
+		// Inter Leave
+		//=============================================	
+
+		if ( nPageAddr < (U32)(( ( nDevInfo->Feature.PBpV >> 1 ) << nDevInfo->ShiftPpB ) ))
+		{
+			gInterLeaveIoStatus |= NAND_IO_STATUS_INTERLEAVING_CHIP1;
+			gInterLeaveDie0BlockAddr = nPageAddr;
+		}
+		else
+		{
+			gInterLeaveIoStatus |= NAND_IO_STATUS_INTERLEAVING_CHIP2;
+			gInterLeaveDie1BlockAddr = nPageAddr;
+		}
+		gInterLeaveCSNum = nDevInfo->ChipNo;
+	}
+	else if ( nDevInfo->ExtInterleaveUsable == TRUE )
+	{
+		//=============================================	
+		// External Inter Leave
+		//=============================================	
+
+		if ( nDevInfo->ChipNo == 0 )
+			gInterLeaveIoStatus |= NAND_IO_STATUS_INTERLEAVING_CHIP1;
+		else if ( nDevInfo->ChipNo == 1 )
+			gInterLeaveIoStatus |= NAND_IO_STATUS_INTERLEAVING_CHIP2;
+		else if ( nDevInfo->ChipNo == 2 )
+			gInterLeaveIoStatus |= NAND_IO_STATUS_INTERLEAVING_CHIP3;
+		else if ( nDevInfo->ChipNo == 3 )
+			gInterLeaveIoStatus |= NAND_IO_STATUS_INTERLEAVING_CHIP4;
+	}
+
+	gDevInfo = (NAND_IO_DEVINFO *)nDevInfo;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_ClearInterleaveStatus( NAND_IO_DEVINFO *nDevInfo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nDevInfo	= 
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_ClearInterleaveStatus( NAND_IO_DEVINFO *nDevInfo )
+{
+	NAND_IO_Delay();
+	gInterLeaveWriteStatus = MULTI_PLANE_GOOD_BLOCK;
+
+	if ( gDevInfo->Feature.MediaType & S_IL )
+	{
+		//=============================================	
+		// Inter Leave
+		//=============================================	
+		NAND_IO_EnableChipSelect( (U16)gInterLeaveCSNum );
+		NAND_IO_DisableWriteProtect();
+				
+		while ( NAND_IO_ReadStatusForInterleaveClear( gDevInfo ) )
+		{
+			#ifndef FWDN_DOWNLOADER_INCLUDE
+		//	TCC7XX_USBDRV_WriteToQueue();
+			#endif
+		}
+		
+		NAND_IO_DisableChipSelect();
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+	}
+	else if ( gDevInfo->ExtInterleaveUsable == TRUE )
+	{
+		//=============================================	
+		// External Inter Leave
+		//=============================================	
+
+		if ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_CHIP1 )
+		{
+			NAND_IO_EnableChipSelect( 0 );
+			NAND_IO_DisableWriteProtect();
+			NAND_IO_WaitBusyForProgramAndErase( gDevInfo );	
+
+			gInterLeaveIoStatus &= ~NAND_IO_STATUS_INTERLEAVING_CHIP1;
+
+			NAND_IO_DisableChipSelect();
+		}
+
+		if ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_CHIP2 )
+		{
+			NAND_IO_EnableChipSelect( 1 );
+			NAND_IO_DisableWriteProtect();
+			NAND_IO_WaitBusyForProgramAndErase( gDevInfo );	
+
+			gInterLeaveIoStatus &= ~NAND_IO_STATUS_INTERLEAVING_CHIP2;
+
+			NAND_IO_DisableChipSelect();
+		}
+
+		if ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_CHIP3 )
+		{
+			NAND_IO_EnableChipSelect( 2 );
+			NAND_IO_DisableWriteProtect();
+			NAND_IO_WaitBusyForProgramAndErase( gDevInfo );	
+
+			gInterLeaveIoStatus &= ~NAND_IO_STATUS_INTERLEAVING_CHIP3;
+
+			NAND_IO_DisableChipSelect();
+		}
+		
+		if ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_CHIP4 )
+		{
+			NAND_IO_EnableChipSelect( 3 );
+			NAND_IO_DisableWriteProtect();
+			NAND_IO_WaitBusyForProgramAndErase( gDevInfo );	
+
+			gInterLeaveIoStatus &= ~NAND_IO_STATUS_INTERLEAVING_CHIP4;
+
+			NAND_IO_DisableChipSelect();
+		}
+
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+	}
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_Delay( void );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			None
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_Delay( void )
+{
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+ 	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_ReadStatus( NAND_IO_DEVINFO *nDevInfo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nDevInfo	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_ReadStatus( NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned int		uStatus;
+	unsigned int		uCheckBit;
+	unsigned long int	timeout;
+	NAND_IO_ERROR		res;	
+	
+	//================================
+	//	Command READ STATUS [ 0x70 ]
+	//================================
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7070;
+
+	// Delay : more than 200nS
+   	NAND_IO_Delay();
+	
+	//=============================================
+	// DATA BUS WIDTH Setting
+	//=============================================
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//================================
+	//	Read IO Status
+	//================================
+ 	timeout = 0xFFFFF;
+ 	while ( timeout )
+ 	{
+		uStatus		= nDevInfo->CmdMask & pNFC->NFC_SDATA;
+		uCheckBit	= nDevInfo->CmdMask & 0x4040;
+			
+		/* Check if it is ready */
+		if ( ( uStatus & uCheckBit ) == uCheckBit )
+			break;
+	}
+
+	if ( !timeout )
+		return ERR_NAND_IO_TIME_OUT_READ_STATUS;
+
+	//================================
+	//	Check Bit Status
+	//================================
+	uStatus		= nDevInfo->CmdMask & pNFC->NFC_SDATA;
+	uCheckBit	= nDevInfo->CmdMask & 0x0101;
+
+	res = (NAND_IO_ERROR)SUCCESS;
+	
+	if ( uStatus & uCheckBit )
+	{
+		if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		{
+			if (uStatus & ( uCheckBit & 0x0100 ) )
+				res |= NAND_IO_STATUS_FAIL_CS1_PARALLEL;
+
+			if (uStatus & ( uCheckBit & 0x0001 ) )
+				res |= NAND_IO_STATUS_FAIL_CS0_PARALLEL;
+		}
+		else
+		{
+			if (uStatus & uCheckBit )
+				res |= NAND_IO_STATUS_FAIL_CS0_SERIAL;
+		}
+	}
+	
+ 	return res;
+
+}
+	 	
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_ReadStatusForMultiPlane( NAND_IO_DEVINFO *nDevInfo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nDevInfo	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_ReadStatusForMultiPlane( NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned int		uStatus;
+	unsigned int		uCheckBit;
+	unsigned long int	timeout;
+	NAND_IO_ERROR		res;	
+	
+	//================================
+	//	Command READ STATUS [ 0x70 ]
+	//================================
+	if ( nDevInfo->Feature.DeviceID.Code[0] == SAMSUNG_NAND_MAKER_ID )
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7070;
+	else if ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID )
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7171;
+	else if ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID )
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7070;
+	else
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7070;
+
+	// Delay : more than 200nS
+   	NAND_IO_Delay();
+	
+	//=============================================
+	// DATA BUS WIDTH Setting
+	//=============================================
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//================================
+	//	Read IO Status
+	//================================
+ 	timeout = 0xFFFFF;
+ 	while ( timeout )
+ 	{
+		/* Micron MultiPlane ReadBusy Check 0x40*/
+		uStatus		= nDevInfo->CmdMask & pNFC->NFC_SDATA;
+		uCheckBit = nDevInfo->CmdMask & 0x4040;
+
+		/* Check if it is ready */
+		if ( ( uStatus & uCheckBit ) == uCheckBit )
+			break;
+	}
+
+	if ( !timeout )
+		return ERR_NAND_IO_TIME_OUT_READ_STATUS;
+
+	//================================
+	//	Check Bit Status
+	//================================
+	if ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID )
+	{
+		uStatus		= nDevInfo->CmdMask & pNFC->NFC_SDATA;
+		uCheckBit	= nDevInfo->CmdMask & 0x0101;
+
+		res = (NAND_IO_ERROR)SUCCESS;
+
+		if ( uStatus & uCheckBit )
+		{
+			if ( uStatus & ( nDevInfo->CmdMask & 0x0202 ))
+				res = (NAND_IO_ERROR)NAND_IO_DISTRICT_0;
+			else if ( uStatus & ( nDevInfo->CmdMask & 0x0404 ))
+				res = (NAND_IO_ERROR)NAND_IO_DISTRICT_1;
+		}
+	}
+	else
+	{
+	    uStatus		= nDevInfo->CmdMask & pNFC->NFC_SDATA;
+	    uCheckBit	= nDevInfo->CmdMask & 0x0101;
+    
+	    res = (NAND_IO_ERROR)SUCCESS;
+	    
+	    if ( uStatus & uCheckBit )
+	    {
+		    if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		    {
+			    if (uStatus & ( uCheckBit & 0x0100 ) )
+				    res |= NAND_IO_STATUS_FAIL_CS1_PARALLEL;
+    
+			    if (uStatus & ( uCheckBit & 0x0001 ) )
+				    res |= NAND_IO_STATUS_FAIL_CS0_PARALLEL;
+		    }
+		    else
+		    {
+			    if (uStatus & uCheckBit )
+				    res |= NAND_IO_STATUS_FAIL_CS0_SERIAL;
+		    }
+	    }
+	}
+	
+ 	return res;
+
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_ReadStatusForCacheProgram( NAND_IO_DEVINFO *nDevInfo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nDevInfo	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_ReadStatusForCacheProgram( NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned int		uStatus;
+	unsigned int		uCheckBit;
+	unsigned long int	timeout;
+	NAND_IO_ERROR		res;	
+	
+	//================================
+	//	Command READ STATUS [ 0x70 ]
+	//================================
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7070;
+	
+	// Delay : more than 200nS
+   	NAND_IO_Delay();	
+
+	//=============================================
+	// DATA BUS WIDTH Setting
+	//=============================================
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//================================
+	//	Read IO Status
+	//================================
+ 	timeout = 0xFFFFF;
+ 	while ( timeout )
+ 	{
+		uStatus		= nDevInfo->CmdMask & pNFC->NFC_SDATA;
+		if ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID )
+			uCheckBit = nDevInfo->CmdMask & 0x2020;
+		else
+		uCheckBit = nDevInfo->CmdMask & 0x4040;
+		
+		/* Check if it is ready */
+		if ( ( uStatus & uCheckBit ) == uCheckBit )
+			break;
+	}
+
+	if ( !timeout )
+		return ERR_NAND_IO_TIME_OUT_READ_STATUS;
+
+	//================================
+	//	Check Bit Status
+	//================================
+	uStatus		= nDevInfo->CmdMask & pNFC->NFC_SDATA;
+	uCheckBit	= nDevInfo->CmdMask & 0x0303;
+
+	res = (NAND_IO_ERROR)SUCCESS;
+	
+	if ( uStatus & uCheckBit )
+	{
+		if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		{
+			if (uStatus & ( uCheckBit & 0x0300 ) )
+				res |= NAND_IO_STATUS_FAIL_CS1_PARALLEL;
+
+			if (uStatus & ( uCheckBit & 0x0003 ) )
+				res |= NAND_IO_STATUS_FAIL_CS0_PARALLEL;
+		}
+		else
+		{
+			if (uStatus & uCheckBit )
+				res |= NAND_IO_STATUS_FAIL_CS0_SERIAL;
+		}
+	}
+	
+ 	return res;
+
+}
+
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_ReadStatusForInterleave( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nDevInfo	= 
+*			nPageAddr	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_ReadStatusForInterleave( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr )
+{
+	unsigned int		uStatus;
+	unsigned int		uCheckBit;
+	unsigned int		ChipNum;
+	unsigned long int	timeout;
+	NAND_IO_ERROR		res;	
+
+	// Delay : more than 200nS
+   	NAND_IO_Delay();
+
+	//=============================================
+	// DATA BUS WIDTH Setting
+	//=============================================
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//================================
+	//	Command READ STATUS
+	//================================
+	if ( nPageAddr < (U32)( (nDevInfo->Feature.PBpV >> 1 ) * nDevInfo->Feature.PpB )  )
+	{
+		if ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_CHIP1 )
+		{
+			if ( nDevInfo->Feature.DeviceID.Code[0] == SAMSUNG_NAND_MAKER_ID )
+				pNFC->NFC_CMD = nDevInfo->CmdMask & 0xF1F1;
+			else if ( nDevInfo->Feature.DeviceID.Code[0] == ST_NAND_MAKER_ID )
+				pNFC->NFC_CMD = nDevInfo->CmdMask & 0xF2F2;	
+			else if ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID )
+				pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7171;
+			else if ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID )
+			{
+				pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7878;	
+				NAND_IO_WriteBlockPageAddr( gInterLeaveDie0BlockAddr, nDevInfo );
+			}
+			
+			ChipNum = NAND_IO_STATUS_INTERLEAVING_CHIP1;
+		}
+		else
+			return (NAND_IO_ERROR)SUCCESS;
+	}
+	else
+	{
+		if ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_CHIP2 )
+		{
+			if ( nDevInfo->Feature.DeviceID.Code[0] == SAMSUNG_NAND_MAKER_ID )
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0xF2F2;
+			else if ( nDevInfo->Feature.DeviceID.Code[0] == ST_NAND_MAKER_ID )
+				pNFC->NFC_CMD = nDevInfo->CmdMask & 0xF3F3;
+			else if ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID )
+				pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7171;	
+			else if ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID )
+			{
+				pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7878;
+				NAND_IO_WriteBlockPageAddr( gInterLeaveDie1BlockAddr, nDevInfo );
+			}
+			ChipNum = NAND_IO_STATUS_INTERLEAVING_CHIP2;
+		}
+		else
+			return (NAND_IO_ERROR)SUCCESS;
+	}
+
+	//================================
+	//	Read IO Status
+	//================================
+ 	timeout = 0xFFFFF;
+ 	while ( timeout )
+ 	{
+		if ( ( nDevInfo->Feature.DeviceID.Code[0] == SAMSUNG_NAND_MAKER_ID ) || 
+			 ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID )	 ||
+			 ( nDevInfo->Feature.DeviceID.Code[0] == ST_NAND_MAKER_ID ) )
+		{
+			uStatus		= nDevInfo->CmdMask & pNFC->NFC_SDATA;
+			uCheckBit = nDevInfo->CmdMask & 0x4040;
+		
+			/* Check if it is ready */
+			if ( ( uStatus & uCheckBit ) == uCheckBit )
+			{
+				uCheckBit	= nDevInfo->CmdMask & 0x0101;
+
+				/* Check if it is Fail */
+				if ( uStatus & uCheckBit )
+				{
+					if ( ChipNum == NAND_IO_STATUS_INTERLEAVING_CHIP1 )
+					{
+						if ( ( nDevInfo->Feature.MediaType & S_MP ) || ( nDevInfo->Feature.MediaType & S_MCP ) )
+						{
+							nDevInfo->BadBlockInfo.BlockStatus[0] = MULTI_PLANE_BAD_BLOCK;
+							nDevInfo->BadBlockInfo.BlockStatus[1] = MULTI_PLANE_BAD_BLOCK;
+						}
+						else
+							nDevInfo->BadBlockInfo.BlockStatus[nDevInfo->ChipNo] = MULTI_PLANE_BAD_BLOCK;
+					}
+					else if ( ChipNum == NAND_IO_STATUS_INTERLEAVING_CHIP2 )
+					{
+						if ( ( nDevInfo->Feature.MediaType & S_MP ) || ( nDevInfo->Feature.MediaType & S_MCP ) )
+						{
+							nDevInfo->BadBlockInfo.BlockStatus[2] = MULTI_PLANE_BAD_BLOCK;
+							nDevInfo->BadBlockInfo.BlockStatus[3] = MULTI_PLANE_BAD_BLOCK;
+						}
+						else
+							nDevInfo->BadBlockInfo.BlockStatus[nDevInfo->ChipNo] = MULTI_PLANE_BAD_BLOCK;
+					}
+
+					gInterLeaveWriteStatus = MULTI_PLANE_BAD_BLOCK;
+				}
+				break;
+			}
+		}
+		else if ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID )
+		{
+			uStatus	= nDevInfo->CmdMask & pNFC->NFC_SDATA;
+			uCheckBit = nDevInfo->CmdMask & 0x4040;
+
+			/* Check if it is ready */
+			if ( ( uStatus & uCheckBit ) == uCheckBit )
+			{
+				uCheckBit	= nDevInfo->CmdMask & 0x0101;
+
+				/* Check if it is Fail */
+				if ( uStatus & uCheckBit )
+				{
+					if ( ChipNum == NAND_IO_STATUS_INTERLEAVING_CHIP1 )
+					{
+				       	if ( uStatus & ( nDevInfo->CmdMask & 0x0202 ))
+					        nDevInfo->BadBlockInfo.BlockStatus[0] = MULTI_PLANE_BAD_BLOCK;
+				        else if ( uStatus & ( nDevInfo->CmdMask & 0x0404 ))
+					        nDevInfo->BadBlockInfo.BlockStatus[1] = MULTI_PLANE_BAD_BLOCK;
+					}
+					else if ( ChipNum == NAND_IO_STATUS_INTERLEAVING_CHIP2 )
+					{
+				        if ( uStatus & ( nDevInfo->CmdMask & 0x0202 ))
+					        nDevInfo->BadBlockInfo.BlockStatus[2] = MULTI_PLANE_BAD_BLOCK;
+				        else if ( uStatus & ( nDevInfo->CmdMask & 0x0404 ))
+					        nDevInfo->BadBlockInfo.BlockStatus[3] = MULTI_PLANE_BAD_BLOCK;
+			        }
+
+					gInterLeaveWriteStatus = MULTI_PLANE_BAD_BLOCK;
+				}
+				break;
+			}
+		}
+	}
+
+	if ( !timeout )
+		return ERR_NAND_IO_TIME_OUT_READ_STATUS;
+
+	//================================
+	//	SET NAND IO Status
+	//================================
+	switch(ChipNum)
+	{
+		case NAND_IO_STATUS_INTERLEAVING_CHIP1:
+			gInterLeaveIoStatus &= ~NAND_IO_STATUS_INTERLEAVING_CHIP1;
+			break;
+
+		case NAND_IO_STATUS_INTERLEAVING_CHIP2:
+			gInterLeaveIoStatus &= ~NAND_IO_STATUS_INTERLEAVING_CHIP2;
+			break;
+	}
+
+	res = (NAND_IO_ERROR)SUCCESS;
+
+ 	return res;
+
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_ReadStatusForInterleaveClear( NAND_IO_DEVINFO *nDevInfo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nDevInfo	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_ReadStatusForInterleaveClear( NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned int		uStatus;
+	unsigned int		uCheckBit;
+	unsigned long int	timeout;
+	NAND_IO_ERROR		res;
+
+	// Delay : more than 200nS
+   	NAND_IO_Delay();
+
+	res = (NAND_IO_ERROR)SUCCESS;
+
+	//=============================================
+	// DATA BUS WIDTH Setting
+	//=============================================
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//=============================================
+	//	Command READ STATUS - Interleave CHIP 1
+	//=============================================
+	if ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_CHIP1 )
+	{
+		if ( nDevInfo->Feature.DeviceID.Code[0] == SAMSUNG_NAND_MAKER_ID )
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0xF1F1;
+		else if ( nDevInfo->Feature.DeviceID.Code[0] == ST_NAND_MAKER_ID )
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0xF2F2;
+		else if ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID )
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7171;
+		else if ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID )
+		{
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7878;
+			NAND_IO_WriteBlockPageAddr( gInterLeaveDie0BlockAddr, nDevInfo );
+		}
+		
+	 	timeout = 0xFFFFF;
+	 	while ( timeout )
+	 	{
+			uStatus	  = nDevInfo->CmdMask & pNFC->NFC_SDATA;
+			uCheckBit = nDevInfo->CmdMask & 0x4040;
+			
+			/* Check if it is ready */
+			if ( ( uStatus & uCheckBit ) == uCheckBit )
+			{
+				uCheckBit	= nDevInfo->CmdMask & 0x0101;
+
+				/* Check if it is Fail */
+				if ( uStatus & uCheckBit )
+				{
+					if ( ( nDevInfo->Feature.MediaType & S_MP ) || ( nDevInfo->Feature.MediaType & S_MCP ) )
+					{
+						nDevInfo->BadBlockInfo.BlockStatus[0] = MULTI_PLANE_BAD_BLOCK;
+						nDevInfo->BadBlockInfo.BlockStatus[1] = MULTI_PLANE_BAD_BLOCK;
+					}
+					else
+						nDevInfo->BadBlockInfo.BlockStatus[nDevInfo->ChipNo] = MULTI_PLANE_BAD_BLOCK;
+
+					gInterLeaveWriteStatus = MULTI_PLANE_BAD_BLOCK;
+				}
+				break;
+			}
+		}
+
+		if ( !timeout )
+			return ERR_NAND_IO_TIME_OUT_READ_STATUS;
+
+		gInterLeaveIoStatus &= ~NAND_IO_STATUS_INTERLEAVING_CHIP1;
+	}
+
+	//=============================================
+	//	Command READ STATUS - Interleave CHIP 2
+	//=============================================
+	if ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_CHIP2 )
+	{
+		if ( nDevInfo->Feature.DeviceID.Code[0] == SAMSUNG_NAND_MAKER_ID )
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0xF2F2;
+		else if ( nDevInfo->Feature.DeviceID.Code[0] == ST_NAND_MAKER_ID )
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0xF3F3;
+		else if ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID )
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7171;
+		else if ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID )
+		{
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7878;
+			NAND_IO_WriteBlockPageAddr( gInterLeaveDie1BlockAddr, nDevInfo );
+		}
+
+	 	timeout = 0xFFFFF;
+	 	while ( timeout )
+	 	{
+			uStatus		= nDevInfo->CmdMask & pNFC->NFC_SDATA;
+			uCheckBit = nDevInfo->CmdMask & 0x4040;
+			
+			/* Check if it is ready */
+			if ( ( uStatus & uCheckBit ) == uCheckBit )
+			{
+				uCheckBit	= nDevInfo->CmdMask & 0x0101;
+
+				/* Check if it is Fail */
+				if ( uStatus & uCheckBit )
+				{
+					if ( ( nDevInfo->Feature.MediaType & S_MP ) || ( nDevInfo->Feature.MediaType & S_MCP ) )
+					{
+						nDevInfo->BadBlockInfo.BlockStatus[2] = MULTI_PLANE_BAD_BLOCK;
+						nDevInfo->BadBlockInfo.BlockStatus[3] = MULTI_PLANE_BAD_BLOCK;
+					}
+					else
+						nDevInfo->BadBlockInfo.BlockStatus[nDevInfo->ChipNo] = MULTI_PLANE_BAD_BLOCK;
+
+					gInterLeaveWriteStatus = MULTI_PLANE_BAD_BLOCK;
+				}
+				break;
+			}
+		}
+
+		if ( !timeout )
+			return ERR_NAND_IO_TIME_OUT_READ_STATUS;
+
+		gInterLeaveIoStatus &= ~NAND_IO_STATUS_INTERLEAVING_CHIP2;
+	}
+
+	if ( !(gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ))
+		res = (NAND_IO_ERROR)SUCCESS;
+	
+ 	return res;
+
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_GenerateRowColAddrForRead( U32 nPageAddr, U16 nColumnAddr,
+*      										  				  		 U32* rRowAddr, U32* rColumnAddr,
+*      														  		 NAND_IO_DEVINFO *nDevInfo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nColumnAddr	= 
+*			nDevInfo	= 
+*			nPageAddr	= 
+*			rColumnAddr	= 
+*			rRowAddr	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_GenerateRowColAddrForRead( U32 nPageAddr, U16 nColumnAddr,
+										  				  		 U32* rRowAddr, U32* rColumnAddr,
+														  		 NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned long int	RowAddr;
+	unsigned long int	ColumnAddr;
+	
+	if ( nColumnAddr > ( nDevInfo->Feature.PageSize + nDevInfo->Feature.SpareSize ) )
+		return ERR_NAND_IO_WRONG_PARAMETER_ROW_COL_ADDRESS;
+
+	//==================================================
+	// Generate Column & Row Address	
+	//==================================================
+	if ( nDevInfo->Feature.MediaType & A_SMALL )
+	{
+		// ColumnAddr	ADR[7:0]	==> nColumnAddr
+		// RowAddr		ADR[25:9]	==> (nPageAddr)*512
+		ColumnAddr	= ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )  ? (nColumnAddr>>1) : nColumnAddr;
+		RowAddr		= nPageAddr;
+
+		if ( nDevInfo->Feature.MediaType & A_08BIT )
+		{
+		    /* Command READ for SMALL NAND */
+		    if ( ColumnAddr < 256 )
+		    {
+			    pNFC->NFC_CMD	= nDevInfo->CmdMask & 0x0000;
+			    ColumnAddr	= ColumnAddr;
+		    }
+		    else if ( ColumnAddr < 512 )
+		    {
+			    pNFC->NFC_CMD	= nDevInfo->CmdMask & 0x0101;
+			    ColumnAddr  = ColumnAddr-256;
+		    }
+		    else
+		    {
+			    pNFC->NFC_CMD	= nDevInfo->CmdMask & 0x5050;
+			    ColumnAddr	= ColumnAddr-512;
+		    }
+		}
+		else if ( nDevInfo->Feature.MediaType & A_16BIT )
+		{
+			/* Command READ for SMALL NAND For 16Bit */
+			if ( ColumnAddr < 256 )
+			{
+				pNFC->NFC_CMD	= nDevInfo->CmdMask & 0x0000;
+				ColumnAddr	= ColumnAddr;
+			}
+			else
+			{
+				pNFC->NFC_CMD	= nDevInfo->CmdMask & 0x5050;
+				ColumnAddr	= ColumnAddr;
+			}
+		}		
+	}
+	else
+	{
+		/* Command READ [ 0x00 ] */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;	
+
+		// ColumnAddr   ADR[11:0]   ==> nColumnAddr
+		// RowAddr      ADR[31:12]  ==> nPageAddr
+		ColumnAddr	= ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT ) ? (nColumnAddr>>1) : nColumnAddr;
+		RowAddr		= nPageAddr;
+
+	}			
+
+	*rRowAddr		= RowAddr;
+	*rColumnAddr	= ColumnAddr;
+
+	return (NAND_IO_ERROR)SUCCESS;
+	
+}	
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_GenerateRowColAddrForWrite( U32 nPageAddr, U16 nColumnAddr,
+*      										  				  		  U32* rRowAddr, U32* rColumnAddr,
+*      														  		  NAND_IO_DEVINFO *nDevInfo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nColumnAddr	= 
+*			nDevInfo	= 
+*			nPageAddr	= 
+*			rColumnAddr	= 
+*			rRowAddr	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_GenerateRowColAddrForWrite( U32 nPageAddr, U16 nColumnAddr,
+										  				  		  U32* rRowAddr, U32* rColumnAddr,
+														  		  NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned long int	RowAddr;
+	unsigned long int	ColumnAddr;
+	
+	if ( nColumnAddr > ( nDevInfo->Feature.PageSize + nDevInfo->Feature.SpareSize ) )
+		return ERR_NAND_IO_WRONG_PARAMETER_ROW_COL_ADDRESS;
+
+	//==================================================
+	// Generate Column & Row Address	
+	//==================================================
+	if ( nDevInfo->Feature.MediaType & A_SMALL )
+	{
+		// ColumnAddr	ADR[7:0]	==> nColumnAddr
+		// RowAddr		ADR[25:9]	==> (nPageAddr)*512
+		ColumnAddr	= ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )  ? (nColumnAddr>>1) : nColumnAddr;
+		RowAddr		= nPageAddr;
+
+		if ( nDevInfo->Feature.MediaType & A_08BIT )
+		{
+		    /* Command READ for SMALL NAND */
+		    if ( ColumnAddr < 256 )
+		    {
+			    pNFC->NFC_CMD	= nDevInfo->CmdMask & 0x0000;
+			    ColumnAddr	= ColumnAddr;
+		    }
+		    else if ( ColumnAddr < 512 )
+		    {
+			    pNFC->NFC_CMD	= nDevInfo->CmdMask & 0x0101;
+			    ColumnAddr  = ColumnAddr-256;
+		    }
+		    else
+		    {
+			    pNFC->NFC_CMD	= nDevInfo->CmdMask & 0x5050;
+			    ColumnAddr	= ColumnAddr-512;
+		    }
+		}
+		else if ( nDevInfo->Feature.MediaType & A_16BIT )
+		{
+			/* Command READ for SMALL NAND */
+			if ( ColumnAddr < 256 )
+			{
+				pNFC->NFC_CMD	= nDevInfo->CmdMask & 0x0000;
+				ColumnAddr	= ColumnAddr;
+			}
+			else
+			{
+				pNFC->NFC_CMD	= nDevInfo->CmdMask & 0x5050;
+				ColumnAddr	= ColumnAddr;
+			}
+		}	
+	}
+	else
+	{
+		// ColumnAddr   ADR[11:0]   ==> nColumnAddr
+		// RowAddr      ADR[31:12]  ==> nPageAddr
+		ColumnAddr	= ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT ) ? (nColumnAddr>>1) : nColumnAddr;
+		RowAddr		= nPageAddr;
+	}			
+
+	*rRowAddr		= RowAddr;
+	*rColumnAddr	= ColumnAddr;
+
+	return (NAND_IO_ERROR)SUCCESS;
+	
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_GenerateRowColAddrForCBandCP( U32 nPageAddr, U16 nColumnAddr,
+*      										  				  			U32* rRowAddr, U32* rColumnAddr,
+*      														  			NAND_IO_DEVINFO *nDevInfo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nColumnAddr	= 
+*			nDevInfo	= 
+*			nPageAddr	= 
+*			rColumnAddr	= 
+*			rRowAddr	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_GenerateRowColAddrForCBandCP( U32 nPageAddr, U16 nColumnAddr,
+										  				  			U32* rRowAddr, U32* rColumnAddr,
+														  			NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned long int	RowAddr;
+	unsigned long int	ColumnAddr;
+	
+	if ( nColumnAddr > 0 )
+		return ERR_NAND_IO_WRONG_PARAMETER_ROW_COL_ADDRESS;
+
+	//==================================================
+	// Generate Column & Row Address	
+	//==================================================
+	if ( nDevInfo->Feature.MediaType & A_SMALL )
+	{
+		// ColumnAddr	ADR[7:0]	==> nColumnAddr
+		// RowAddr		ADR[25:9]	==> (nPageAddr)*512
+		ColumnAddr	= ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )  ? (nColumnAddr>>1) : nColumnAddr;
+		RowAddr		= nPageAddr;
+		ColumnAddr	= ColumnAddr;
+	}
+	else
+	{
+		// ColumnAddr   ADR[11:0]   ==> nColumnAddr
+		// RowAddr      ADR[31:12]  ==> nPageAddr
+		ColumnAddr	= ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT ) ? (nColumnAddr>>1) : nColumnAddr;
+		RowAddr		= nPageAddr;
+	}			
+
+	*rRowAddr		= RowAddr;
+	*rColumnAddr	= ColumnAddr;
+
+	return (NAND_IO_ERROR)SUCCESS;
+	
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_WriteRowColAddr( U32 nRowAddr, U32 nColumnAddr, NAND_IO_DEVINFO *nDevInfo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nColumnAddr	= 
+*			nDevInfo	= 
+*			nRowAddr	= 
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_WriteRowColAddr( U32 nRowAddr, U32 nColumnAddr, NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned int		nTempAddr;
+	unsigned int		i;
+	
+	//==================================================
+	// Write Column Address
+	//==================================================
+	for ( i = 0; i < nDevInfo->Feature.ColCycle; ++i )
+	{
+		#if defined(_WINCE_) || defined(_LINUX_)
+		//NAND_IO_Delay();
+        #endif
+		nTempAddr = nDevInfo->CmdMask & (((nColumnAddr<<8)&0xFF00)|(nColumnAddr&0x00FF));
+		pNFC->NFC_SADDR = nTempAddr;
+		
+		//pNFC->NFC_SADDR	= nDevInfo->CmdMask & (((nColumnAddr<<8)&0xFF00)|(nColumnAddr&0x00FF));
+		nColumnAddr = nColumnAddr >> 8;
+
+		#if defined(_WINCE_) || defined(_LINUX_)
+		//NAND_IO_Delay();
+        #endif
+	}
+
+	//==================================================
+	// Write Row Address
+	//==================================================	
+	nRowAddr = nRowAddr;
+
+	for ( i = 0; i < nDevInfo->Feature.RowCycle; ++i )
+	{
+		#if defined(_WINCE_) || defined(_LINUX_)
+		//NAND_IO_Delay();
+        #endif
+		nTempAddr = nDevInfo->CmdMask & (((nRowAddr<<8)&0xFF00)|(nRowAddr&0x00FF));
+		pNFC->NFC_SADDR = nTempAddr;
+
+
+		//pNFC->NFC_SADDR	= nDevInfo->CmdMask & (((nRowAddr<<8)&0xFF00)|(nRowAddr&0x00FF));
+		nRowAddr = nRowAddr >> 8;
+
+		#if defined(_WINCE_) || defined(_LINUX_)
+		//NAND_IO_Delay();
+        #endif
+	}
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_WriteColAddr( U32 nColumnAddr, NAND_IO_DEVINFO *nDevInfo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nColumnAddr	= 
+*			nDevInfo	= 
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_WriteColAddr( U32 nColumnAddr, NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned int		i;
+	
+	//==================================================
+	// Write Column Address
+	//==================================================
+	for ( i = 0; i < nDevInfo->Feature.ColCycle; ++i )
+	{
+		pNFC->NFC_SADDR	= nDevInfo->CmdMask & (((nColumnAddr<<8)&0xFF00)|(nColumnAddr&0x00FF));
+		nColumnAddr = nColumnAddr >> 8;
+	}
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_WriteBlockPageAddr( U32 nBlockPageAddr, NAND_IO_DEVINFO *nDevInfo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nBlockPageAddr	= 
+*			nDevInfo	= 
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_WriteBlockPageAddr( U32 nBlockPageAddr, NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned int		i;
+	
+	//==================================================
+	// Write Block Address
+	//==================================================
+	for ( i = 0; i < nDevInfo->Feature.RowCycle; ++i )
+	{
+		pNFC->NFC_SADDR	= nDevInfo->CmdMask & (((nBlockPageAddr<<8)&0xFF00)|(nBlockPageAddr&0x00FF));
+		nBlockPageAddr = nBlockPageAddr >> 8;
+	}
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      static __inline void NAND_IO_SetupDMA( void *pSRC, unsigned uSrcInc, unsigned uSrcMask, 
+*      									   void *pDST, unsigned uDstInc, unsigned uDstMask, int nMode );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			nMode	= 
+*			pDST	= 
+*			pSRC	= 
+*			uDstInc	= 
+*			uDstMask	= 
+*			uSrcInc	= 
+*			uSrcMask	= 
+*  
+*  OUTPUT:	void - Return Type
+*  
+**************************************************************************/
+static __inline void NAND_IO_SetupDMA( void *pSRC, unsigned uSrcInc, unsigned uSrcMask, 
+									   void *pDST, unsigned uDstInc, unsigned uDstMask, int nMode, int nDSize )
+{
+	unsigned int	*pDMA_PhyBuffer;
+	unsigned int	*pDMA_WorkBuffer;
+	unsigned int	nSourceAddr, nDestAddr;
+	unsigned		uCHCTRL;
+	unsigned int	uTmp;
+
+	#if defined(_WINCE_)
+	tSYSTEM_PARAM	*pSYS_Work_PARAM	= (tSYSTEM_PARAM*)(SYSTEM_PARAM_BASEADDRESS);
+	#endif
+	
+	#ifdef READ_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw15);
+	#endif
+	
+	#if defined(_WINCE_)
+	pDMA_PhyBuffer 	= (unsigned int*)pSYS_Work_PARAM->DMA2.CH0_BUFFER;	// Working Address
+	pDMA_WorkBuffer = (unsigned int*)pSYS_PARAM->DMA2.CH0_BUFFER;		// Physical Address
+	#elif defined(_LINUX_)
+	#ifdef KERNEL_DRIVER
+	pDMA_PhyBuffer 	= dma_t.dma_addr;	
+	pDMA_WorkBuffer	= (unsigned int*)dma_t.v_addr;
+	#else
+	pDMA_PhyBuffer 	= (unsigned int*)DMA_ADDR;	
+	pDMA_WorkBuffer	= (unsigned int*)DMA_ADDR;
+	#endif
+	#else		// NU
+	pDMA_PhyBuffer = 0x10003000;
+	pDMA_WorkBuffer	= 0x10003000;			
+	#endif
+
+	// Read Test
+	//pDMA_PhyBuffer = 0x10003000;
+	//pDMA_WorkBuffer	= 0x10003000;
+	
+	//pDMA_PhyBuffer = pDST;
+	//pDMA_WorkBuffer	= pDST;
+
+	if ( nMode == NAND_IO_DMA_WRITE )
+	{
+		// pSRC: Buffer Address
+		// pDST: NFC_LDATA
+
+		BITCSET(pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_8 | HwNFC_CTRL_DEN_EN | HwNFC_CTRL_PSIZE_512 );
+
+		//pSRC --> pDMA_WorkBuffer
+		memcpy( pDMA_WorkBuffer, pSRC, nDSize );
+
+		// Target Physical Address- for DMA H/W Control Set
+		nSourceAddr	= (unsigned int)pDMA_PhyBuffer;
+		nDestAddr 	= (unsigned int)pDST;
+
+		//============================================================
+		// DMA Control Register Set
+		//============================================================
+		uCHCTRL =	
+	//				HwCHCTRL_SYNC_ON		|
+	//				HwCHCTRL_HRD_W			|
+					HwCHCTRL_BST_BURST		|
+					HwCHCTRL_TYPE_SINGL		|
+				   	HwCHCTRL_HRD_WR			|
+	//				HwCHCTRL_BST_BURST		|
+					HwCHCTRL_BSIZE_8		|
+					HwCHCTRL_WSIZE_32		|
+					HwCHCTRL_FLAG			|
+					HwCHCTRL_EN_ON			|
+					0;
+
+	}
+	else	// NAND_IO_DMA_READ
+	{	
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw5);
+		#endif /* READ_SPEED_CHECK */
+	
+		// pSRC: NFC_LDATA
+		// pDST: Buffer Address
+
+		BITCSET(pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_8 | HwNFC_CTRL_DEN_EN | HwNFC_CTRL_PSIZE_512 );
+
+		nSourceAddr = (unsigned int)pSRC;				// NFC_LDATA Physical Address: ex_TCC89,92XX: 0XF050b0020
+		nDestAddr 	= (unsigned int)pDMA_PhyBuffer;
+
+		//============================================================
+		// DMA Control Register Set
+		//============================================================
+		uCHCTRL =	
+	//				HwCHCTRL_SYNC_ON		|
+	//				HwCHCTRL_HRD_W			|
+					HwCHCTRL_BST_BURST		|
+					HwCHCTRL_TYPE_SINGL		|
+				   	HwCHCTRL_HRD_RD			|
+	//				HwCHCTRL_BST_BURST		|
+					HwCHCTRL_BSIZE_8		|
+					HwCHCTRL_WSIZE_32		|
+					HwCHCTRL_FLAG			|
+					HwCHCTRL_EN_ON			|
+					0;
+	}
+
+	//============================================================
+	// Set Source Address & Source Parameter (mask + increment)
+	//============================================================
+	pNAND_DMA->ST_SADR 	= nSourceAddr;
+	#if defined(_WINCE_) || defined(_LINUX_)
+	pNAND_DMA->SPARAM[0] = (uSrcInc | (uSrcMask << 4));
+	#else
+	pNAND_DMA->SPARAM	 = (uSrcInc | (uSrcMask << 4));
+	#endif
+	//============================================================
+	// Set Dest Address & Dest Parameter (mask + increment)
+	//============================================================
+	pNAND_DMA->ST_DADR 	= nDestAddr;  
+	#if defined(_WINCE_) || defined(_LINUX_)
+	pNAND_DMA->DPARAM[0] = (uDstInc | (uDstMask << 4));
+	#else
+	pNAND_DMA->DPARAM	 = (uDstInc | (uDstMask << 4));
+	#endif
+	//============================================================
+	// Calculate byte size per 1 Hop transfer
+	//============================================================
+	uTmp	= (uCHCTRL & (Hw5+Hw4)) >> 4;			// calc log2(word size)
+	uTmp	= uTmp + ( (uCHCTRL & (Hw7+Hw6)) >> 6);	// calc log2(word * burst size)
+
+	//============================================================
+	// Set External DMA Request Register
+	//============================================================
+	pNAND_DMA->EXTREQ = Hw18;		// NFC
+
+	//============================================================
+	// Set Hcount
+	//============================================================
+	if (uTmp)
+		pNAND_DMA->HCOUNT	= (nDSize + (1 << uTmp) - 1) >> uTmp;
+	else
+		pNAND_DMA->HCOUNT	= nDSize;
+
+	//============================================================
+	// Set & Enable DMA
+	//============================================================
+	pNAND_DMA->CHCTRL		= uCHCTRL;
+
+	//============================================================
+	// Set NFC DSize & IREQ Clear
+	//============================================================
+	pNFC->NFC_DSIZE		= nDSize;
+	pNFC->NFC_IREQ		= 0x77;	// HwNFC_IREQ_FLAG1;
+
+	//============================================================
+	// DMA Transfer Start
+	//============================================================
+	if ( nMode == NAND_IO_DMA_WRITE )
+	{
+		if ( pNFC->NFC_CTRL1 & Hw31 )
+			BITCLR( pNFC->NFC_CTRL1, Hw31 );
+
+			pNFC->NFC_PSTART	= 0;
+			
+			while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));			
+
+		if ( pNFC->NFC_CTRL1 & Hw30 )
+			BITSET( pNFC->NFC_CTRL1, Hw31 );
+	}
+	else
+	{
+		pNFC->NFC_RSTART	= 0;
+		
+		while ( ISZERO(pNFC->NFC_IREQ, HwNFC_IREQ_FLAG0) );
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw5);
+		#endif /* READ_SPEED_CHECK */
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw4);
+		#endif
+
+		memcpy( pDST, pDMA_WorkBuffer, nDSize );
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw4);
+		#endif
+	}
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      static __inline void NAND_IO_SetupDMADoubleBuf(  int nMode, int nDMACh );
+*  
+*  DESCRIPTION : 
+*  
+*  INPUT:
+*			nDMACh	= 
+*			nMode	= 
+*  
+*  OUTPUT:	void - Return Type
+*  
+**************************************************************************/
+static __inline void NAND_IO_SetupDMADoubleBuf(  int nMode, int nDMACh )
+{
+	unsigned int	*pDMA_PhyBuffer;
+	unsigned int	*pDMA_WorkBuffer;
+	unsigned int	nSourceAddr, nDestAddr;
+	unsigned		uCHCTRL;
+	unsigned int	uTmp;
+	unsigned int	uSrcInc, uSrcMask;
+	unsigned int	uDstInc, uDstMask;
+
+	if ( nMode == NAND_IO_DMA_WRITE )
+	{
+		uSrcInc 	= 4;
+		uSrcMask 	= 0;
+		uDstInc		= 0;
+		uDstMask 	= 0;
+	}
+	else
+	{
+		uSrcInc 	= 0;
+		uSrcMask 	= 0;
+		uDstInc		= 4;
+		uDstMask 	= 0;
+	}
+	
+	if ( nDMACh & 1 )
+	{
+		pDMA_PhyBuffer 	= gpDMA_PhyBuffer0;			// Working Address
+		pDMA_WorkBuffer = gpDMA_WorkBuffer0;		// Physical Address
+	}
+	else
+	{
+		pDMA_PhyBuffer 	= gpDMA_PhyBuffer1;			// Working Address
+		pDMA_WorkBuffer = gpDMA_WorkBuffer1;		// Physical Address
+	}
+	
+	if ( nMode == NAND_IO_DMA_WRITE )
+	{
+		// pSRC: Buffer Address
+		// pDST: NFC_LDATA
+
+		BITCSET(pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_8 | HwNFC_CTRL_DEN_EN | HwNFC_CTRL_PSIZE_512 );
+
+		//pSRC --> pDMA_WorkBuffer
+		//memcpy( pDMA_WorkBuffer, pSRC, 512 );
+
+		// Target Physical Address- for DMA H/W Control Set
+		nSourceAddr	= (unsigned int)pDMA_PhyBuffer;
+		#if defined(_WINCE_) || defined(_LINUX_)
+		nDestAddr 	= (unsigned int)&NAND_IO_HwLDATA_PA;
+		#else
+		nDestAddr 	= (unsigned int)&pNFC->NFC_LDATA;
+		#endif
+		
+		//============================================================
+		// DMA Control Register Set
+		//============================================================
+		uCHCTRL =	
+	//				HwCHCTRL_SYNC_ON		|
+	//				HwCHCTRL_HRD_W			|
+					HwCHCTRL_BST_BURST		|
+					HwCHCTRL_TYPE_SINGL		|
+				   	HwCHCTRL_HRD_WR			|
+	//				HwCHCTRL_BST_BURST		|
+					HwCHCTRL_BSIZE_8		|
+					HwCHCTRL_WSIZE_32		|
+					HwCHCTRL_FLAG			|
+					HwCHCTRL_EN_ON			|
+					0;
+
+	}
+	else	// NAND_IO_DMA_READ
+	{	
+
+		BITCSET(pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_8 | HwNFC_CTRL_DEN_EN | HwNFC_CTRL_PSIZE_512 );
+
+		#if defined(_WINCE_) || defined(_LINUX_)
+		nSourceAddr = (unsigned int)&NAND_IO_HwLDATA_PA;				// NFC_LDATA Physical Address: ex_TCC89,92XX: 0XF050b0020
+		#else
+		nSourceAddr = (unsigned int)&pNFC->NFC_LDATA;
+		#endif
+		nDestAddr 	= (unsigned int)pDMA_PhyBuffer;
+
+		//============================================================
+		// DMA Control Register Set
+		//============================================================
+		uCHCTRL =	
+	//				HwCHCTRL_SYNC_ON		|
+	//				HwCHCTRL_HRD_W			|
+					HwCHCTRL_BST_BURST		|
+					HwCHCTRL_TYPE_SINGL		|
+				   	HwCHCTRL_HRD_RD			|
+	//				HwCHCTRL_BST_BURST		|
+					HwCHCTRL_BSIZE_8		|
+					HwCHCTRL_WSIZE_32		|
+					HwCHCTRL_FLAG			|
+					HwCHCTRL_EN_ON			|
+					0;
+	}
+
+	//============================================================
+	// Set Source Address & Source Parameter (mask + increment)
+	//============================================================
+	pNAND_DMA->ST_SADR 	= nSourceAddr;
+	#if defined(_WINCE_) || defined(_LINUX_)
+	pNAND_DMA->SPARAM[0] = (uSrcInc | (uSrcMask << 4));
+	#else
+	pNAND_DMA->SPARAM	 = (uSrcInc | (uSrcMask << 4));
+	#endif
+	//============================================================
+	// Set Dest Address & Dest Parameter (mask + increment)
+	//============================================================
+	pNAND_DMA->ST_DADR 	= nDestAddr;  
+	#if defined(_WINCE_) || defined(_LINUX_)
+	pNAND_DMA->DPARAM[0] = (uDstInc | (uDstMask << 4));
+	#else
+	pNAND_DMA->DPARAM	 = (uDstInc | (uDstMask << 4));
+	#endif
+	//============================================================
+	// Calculate byte size per 1 Hop transfer
+	//============================================================
+	uTmp	= (uCHCTRL & (Hw5+Hw4)) >> 4;			// calc log2(word size)
+	uTmp	= uTmp + ( (uCHCTRL & (Hw7+Hw6)) >> 6);	// calc log2(word * burst size)
+
+	//============================================================
+	// Set External DMA Request Register
+	//============================================================
+	pNAND_DMA->EXTREQ = Hw18;		// NFC
+
+	//============================================================
+	// Set Hcount
+	//============================================================
+	if (uTmp)
+		pNAND_DMA->HCOUNT	= (512 + (1 << uTmp) - 1) >> uTmp;
+	else
+		pNAND_DMA->HCOUNT	= 512;
+
+	//============================================================
+	// Set & Enable DMA
+	//============================================================
+	pNAND_DMA->CHCTRL		= uCHCTRL;
+
+	//============================================================
+	// Set NFC DSize & IREQ Clear
+	//============================================================
+	pNFC->NFC_DSIZE		= 512;
+	pNFC->NFC_IREQ		= 0x77;	// HwNFC_IREQ_FLAG1;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_SetupECC( U16 nEccOnOff, U16 nEncDec, U16 nEccType, U32 EccBaseAddr )
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nEccOnOff	= 
+*			nEccType	= 
+*			nEncDec	= 
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_SetupECC( U16 nEccOnOff, U16 nEncDec, U16 nEccType, U16 nAccessType, U32 EccBaseAddr )
+{
+	if ( nEccOnOff == ECC_OFF )
+	{
+		//IO_CKC_EnableBUS( IO_CKC_BUS_ECC );
+
+		BITCLR(pIOBUSCFG_T->HRSTEN0, Hw24);
+		BITSET(pIOBUSCFG_T->HRSTEN0, Hw24);
+
+		pECC->ECC_BASE = 0xF05B0010;	/* Base Address for ECC Calculation */
+		pECC->ECC_MASK	= 0x00000000;				/* Address mask for ECC area */
+		pECC->ECC_CTRL &= HwECC_CTRL_EN_DIS;
+
+		//IO_CKC_DisableBUS( IO_CKC_BUS_ECC );
+	}
+	else if ( nEccOnOff == ECC_ON )
+	{
+		//IO_CKC_EnableBUS( IO_CKC_BUS_ECC );
+
+		if ( nEncDec == ECC_DECODE )
+		{
+			pECC->ECC_CLEAR	= 0x00000000;					/* Clear ECC Block		*/
+			
+			if ( nAccessType == NAND_MCU_ACCESS )
+			{
+				#if defined(TCC83XX)
+				HwECC_SEL = HwECC_SEL_AHB_BUS;
+				#elif defined(TCC79XX)
+				BITCSET(HwSTORAGE, HwSTORAGE_ECCS_MPDBUS, HwSTORAGE_ECCS_MPDBUS);
+				#elif defined(TCC89XX) || defined(TCC92XX)
+				pIOBUSCFG_T->STORAGE = HwIOBUSCFG_STORAGE_NFC;
+				#endif
+				pECC->ECC_BASE	= (0x000FFFFF & EccBaseAddr);
+			}
+			else if ( nAccessType == NAND_DMA_ACCESS )
+			{
+				#if defined(TCC83XX)
+				HwECC_SEL = HwECC_SEL_AHB_BUS;
+				#elif defined(TCC79XX)
+				BITCSET(HwSTORAGE, HwSTORAGE_ECCS_MPDBUS, HwSTORAGE_ECCS_IOBUS);
+				#elif defined(TCC92XX) || defined(TCC89XX)
+				pIOBUSCFG_T->STORAGE = HwIOBUSCFG_STORAGE_NFC;
+				#endif
+
+				pECC->ECC_BASE	= EccBaseAddr;
+			}
+			
+			pECC->ECC_MASK	= 0x00000000;				/* Address mask for ECC area */
+
+			if ( nEccType == SLC_ECC_TYPE )
+				pECC->ECC_CTRL	|= 	HwECC_CTRL_EN_SLCDE;
+			else if (nEccType == MLC_ECC_4BIT_TYPE )
+			{
+				pECC->ECC_CTRL	|= HwECC_CTRL_IEN_MECC4_EN;				
+				pECC->ECC_CTRL	|= 	HwECC_CTRL_EN_MCL4DE;
+			}
+			else if (nEccType == MLC_ECC_8BIT_TYPE )
+			{
+				pECC->ECC_CTRL	|= HwECC_CTRL_IEN_MECC8_EN;
+				pECC->ECC_CTRL	|= 	HwECC_CTRL_EN_MCL8DE;
+			}
+			else if (nEccType == MLC_ECC_12BIT_TYPE )
+			{
+				#ifdef ECC_TYPE_BCH
+				pECC->ECC_CTRL	|= HwECC_CTRL_IEN_MECC12_EN;
+				pECC->ECC_CTRL	|= 	HwECC_CTRL_EN_MCL12DE;
+				#endif
+			}
+		}
+		else if ( nEncDec == ECC_ENCODE )
+		{
+			if ( nAccessType == NAND_MCU_ACCESS )
+			{
+				#if defined(TCC83XX)
+				HwECC_SEL = HwECC_SEL_AHB_BUS;
+				#elif defined(TCC79XX)
+				BITCSET(HwSTORAGE, HwSTORAGE_ECCS_MPDBUS, HwSTORAGE_ECCS_MPDBUS);
+				#elif defined(TCC92XX) || defined(TCC89XX)
+				pIOBUSCFG_T->STORAGE = HwIOBUSCFG_STORAGE_NFC;
+				#endif
+
+				pECC->ECC_BASE	= (0x000FFFFF &EccBaseAddr);
+			}
+			else if ( nAccessType == NAND_DMA_ACCESS )
+			{
+				#if defined(TCC83XX)
+				HwECC_SEL = HwECC_SEL_AHB_BUS;
+				#elif defined(TCC79XX)
+				BITCSET(HwSTORAGE, HwSTORAGE_ECCS_MPDBUS, HwSTORAGE_ECCS_IOBUS);
+				#elif defined(TCC92XX) || defined(TCC89XX)
+				pIOBUSCFG_T->STORAGE = HwIOBUSCFG_STORAGE_NFC;
+				#endif
+
+				pECC->ECC_BASE	= EccBaseAddr;
+			}
+
+			pECC->ECC_MASK	= 0x00000000;				/* Address mask for ECC area */
+
+			if ( nEccType == SLC_ECC_TYPE )
+				pECC->ECC_CTRL	|= 	HwECC_CTRL_EN_SLCEN;
+			else if (nEccType == MLC_ECC_4BIT_TYPE )
+				pECC->ECC_CTRL	|= 	HwECC_CTRL_EN_MCL4EN;
+			else if (nEccType == MLC_ECC_8BIT_TYPE )
+				pECC->ECC_CTRL	|= 	HwECC_CTRL_EN_MCL8EN;
+			else if (nEccType == MLC_ECC_12BIT_TYPE )
+			{
+				#ifdef ECC_TYPE_BCH
+				pECC->ECC_CTRL	|= 	HwECC_CTRL_EN_MCL12EN;		
+				#endif
+			}
+			pECC->ECC_CLEAR	= 0x00000000;					/* Clear ECC Block		*/
+
+		}
+	}
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_EncodeSLC( U8* nSpareBuffer );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nSpareBuffer	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_EncodeECC( U16 nEccType, U8* nSpareBuffer )
+{
+	unsigned int		nECC_CODE;
+	unsigned char		*pcECC;	
+	unsigned int		*pSpareDW;
+
+	if ( nEccType == SLC_ECC_TYPE )
+	{
+		//==================================================================
+		//	[ TNFTL V1.0 ]
+		//==================================================================	
+		// 520th	: P64-P8		of ECC Area-1 [ DATA 256-511 ]
+		// 521th	: P1024-P128	of ECC Area-1 [ DATA 256-511 ]
+		// 522th	: P4-P1			of ECC Area-1 [ DATA 256-511 ]
+		// 525th	: P64-P8		of ECC Area-0 [ DATA 0-255 ]
+		// 526th	: P1024-P128	of ECC Area-0 [ DATA 0-255 ]
+		// 527th	: P4-P1			of ECC Area-0 [ DATA 0-255 ]
+		//==================================================================
+		
+		pcECC = (unsigned char* )&pECC->ECC_CODE0;
+
+		/* Area-1 */
+		nSpareBuffer[10]	= pcECC[0];		// P4-P1
+		nSpareBuffer[ 9]	= pcECC[1];		// P1024-P128
+		nSpareBuffer[ 8]	= pcECC[2];		// P64-P8
+		
+		/* Area-0 */
+		nSpareBuffer[15]	= pcECC[4];		// P4-P1
+		nSpareBuffer[14]	= pcECC[5];		// P1024-128
+		nSpareBuffer[13]	= pcECC[6];		// P64-P8	
+	}
+	else
+	{
+		pSpareDW = (unsigned int *)nSpareBuffer;
+
+		nECC_CODE 	= pECC->ECC_CODE0;
+		*pSpareDW	= nECC_CODE; ++pSpareDW;
+
+		nECC_CODE 	= pECC->ECC_CODE1;
+		*pSpareDW	= nECC_CODE; ++pSpareDW;
+
+		nECC_CODE 	= pECC->ECC_CODE2;
+		*pSpareDW	= nECC_CODE; ++pSpareDW;
+
+		nECC_CODE 	= pECC->ECC_CODE3;
+		*pSpareDW	= nECC_CODE; ++pSpareDW;
+
+		nECC_CODE 	= pECC->ECC_CODE4;
+		*pSpareDW	= nECC_CODE; ++pSpareDW;
+
+		nECC_CODE 	= pECC->ECC_CODE5;
+		*pSpareDW	= nECC_CODE; ++pSpareDW;
+
+		nECC_CODE 	= pECC->ECC_CODE6;
+		*pSpareDW	= nECC_CODE; ++pSpareDW;
+	}
+	
+	return (NAND_IO_ERROR)SUCCESS;	
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      static __inline NAND_IO_ERROR NAND_IO_EncodeNBECC( U16 nEccType, U8* nSpareBuffer );
+*  
+*  DESCRIPTION : 
+*  
+*  INPUT:
+*			nEccType	= 
+*			nSpareBuffer	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+*  REMARK:	  by nemo
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_EncodeNBECC( U16 nEccType, U8* nSpareBuffer )
+{
+	unsigned char*		pcECC;
+	unsigned int		nMLC_ECC;
+
+	//IO_CKC_EnableBUS( IO_CKC_BUS_ECC );
+
+	if ( nEccType == SLC_ECC_TYPE )
+	{
+		//==================================================================
+		//	[ TNFTL V1.0 ]
+		//==================================================================	
+		// 520th	: P64-P8		of ECC Area-1 [ DATA 256-511 ]
+		// 521th	: P1024-P128	of ECC Area-1 [ DATA 256-511 ]
+		// 522th	: P4-P1			of ECC Area-1 [ DATA 256-511 ]
+		// 525th	: P64-P8		of ECC Area-0 [ DATA 0-255 ]
+		// 526th	: P1024-P128	of ECC Area-0 [ DATA 0-255 ]
+		// 527th	: P4-P1			of ECC Area-0 [ DATA 0-255 ]
+		//==================================================================
+		pcECC = (unsigned char*)&pECC->ECC_CODE0;
+
+		/* Area-1 */
+		nSpareBuffer[10]	= pcECC[0];		// P4-P1
+		nSpareBuffer[ 9]	= pcECC[1];		// P1024-P128
+		nSpareBuffer[ 8]	= pcECC[2];		// P64-P8
+		
+		/* Area-0 */
+		nSpareBuffer[15]	= pcECC[4];		// P4-P1
+		nSpareBuffer[14]	= pcECC[5];		// P1024-128
+		nSpareBuffer[13]	= pcECC[6];		// P64-P8
+	}
+	else if ( nEccType == MLC_ECC_4BIT_TYPE )
+	{
+		//==================================================================
+		//	[ TNFTL V1.0 ]
+		//==================================================================
+		// 512th	: MLC ECC 0th Byte
+		// 513th	: MLC ECC 1th Byte
+		
+		// 514th	: MLC ECC 2th Byte
+		// 515th	: MLC ECC 3th Byte
+		// 516th	: MLC ECC 4th Byte
+		// 517th	: MLC ECC 5th Byte
+		
+		// 518th	: MLC ECC 6th Byte
+		// 519th	: MLC ECC 7th Byte
+		// 520th	: MLC ECC 8th Byte
+		// 521th	: MLC ECC 9th Byte
+		//==================================================================
+
+		/* Sync Delay */
+		ASM_NOP;
+
+		nMLC_ECC = pECC->ECC_CODE0;
+		*(nSpareBuffer +  8) = (U8)nMLC_ECC;
+		*(nSpareBuffer +  9) = (U8)(nMLC_ECC >> 8);
+		*(nSpareBuffer + 10) = (U8)(nMLC_ECC >> 16);
+		*(nSpareBuffer + 11) = (U8)(nMLC_ECC >> 24);
+
+		nMLC_ECC = pECC->ECC_CODE1;
+		*(nSpareBuffer + 12) = (U8)nMLC_ECC;
+		*(nSpareBuffer + 13) = (U8)(nMLC_ECC >> 8);
+		*(nSpareBuffer + 14) = (U8)((nMLC_ECC >> 16) & 0x0F);
+	}
+
+	//IO_CKC_DisableBUS( IO_CKC_BUS_ECC );
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_CorrectionSLC( U8* nPageBuffer, U8* nSpareBuffer );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nPageBuffer	= 
+*			nSpareBuffer	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_CorrectionSLC( U8* nPageBuffer, U8* nSpareBuffer )
+{
+	unsigned int		uErrorStatus;
+	unsigned int		uSLCECC0, uSLCECC1;
+	NAND_IO_ERROR		res;
+
+	//IO_CKC_EnableBUS( IO_CKC_BUS_ECC );
+	
+	//==================================================================
+	//	[ TNFTL V1.0 ]
+	//==================================================================	
+	// 520th	: P64-P8		of ECC Area-1 [ DATA 256-511 ]
+	// 521th	: P1024-P128	of ECC Area-1 [ DATA 256-511 ]
+	// 522th	: P4-P1			of ECC Area-1 [ DATA 256-511 ]
+	// 525th	: P64-P8		of ECC Area-0 [ DATA 0-255 ]
+	// 526th	: P1024-P128	of ECC Area-0 [ DATA 0-255 ]
+	// 527th	: P4-P1			of ECC Area-0 [ DATA 0-255 ]
+	//==================================================================
+
+	/* Load SLC ECC Code for Area 1 */
+	uSLCECC0	= ( nSpareBuffer[0] << 16 ) +
+				  ( nSpareBuffer[1] <<  8 ) +
+				  ( nSpareBuffer[2] );
+				  
+	/* Load SLC ECC Code for Area 0 */
+	uSLCECC1	= ( nSpareBuffer[3] << 16 ) +
+				  ( nSpareBuffer[4] <<  8 ) +
+				  ( nSpareBuffer[5] );
+
+	res = (NAND_IO_ERROR)SUCCESS;
+	
+	/* Correction Area 0 */
+	pECC->ECC_CODE1 = uSLCECC1;
+	uErrorStatus = pECC->ERRNUM & 0x7;
+	
+	if ( uErrorStatus == HwERR_NUM_ERR1 )
+	{
+		nPageBuffer[pECC->ECC_EADDR0 >> 3] ^= (1 << (pECC->ECC_EADDR0 & 0x07));
+		res = (NAND_IO_ERROR)SUCCESS;
+	}	
+	else if ( uErrorStatus != HwERR_NUM_NOERR )
+	{
+		res	= ERR_NAND_IO_FAILED_CORRECTION_SLC_ECC;
+		goto ErrorCorrectionSLC;
+	}	
+
+	res = (NAND_IO_ERROR)SUCCESS;
+	
+	/* Correction Area 1 */
+	pECC->ECC_CODE0 = uSLCECC0;
+	uErrorStatus = pECC->ERRNUM & 0x7;
+	
+	if ( uErrorStatus == HwERR_NUM_ERR1 )
+	{
+		nPageBuffer[pECC->ECC_EADDR0 >> 3] ^= (1 << (pECC->ECC_EADDR0 & 0x07));
+		res = (NAND_IO_ERROR)SUCCESS;
+	}
+	else if ( uErrorStatus != HwERR_NUM_NOERR )
+	{
+		res = ERR_NAND_IO_FAILED_CORRECTION_SLC_ECC;
+		goto ErrorCorrectionSLC;		
+	}
+
+ErrorCorrectionSLC:
+
+	//IO_CKC_DisableBUS( IO_CKC_BUS_ECC );
+	
+	return res;
+	
+}	
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      static __inline NAND_IO_ERROR NAND_IO_CorrectionMLC12( U8* nPageBuffer, U8* nSpareBuffer, U16 nDataSize );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			nDataSize	= 
+*			nPageBuffer	= 
+*			nSpareBuffer	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+*  REMARK:	  by nemo
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_CorrectionMLC( U16 nEccType, U8* nPageBuffer, U8* nSpareBuffer, U16 nDataSize )
+{
+	unsigned int		i;
+	unsigned int		uErrAddr;
+	unsigned int		uErrorStatus;
+	unsigned int		*pSpareDW;
+	#ifdef _LINUX_
+	unsigned char		nTempBuf[30]__attribute__((aligned(8)));
+	#else
+	unsigned char		nTempBuf[30];
+	#endif	
+	NAND_IO_ECC_INFO	*pECC_Info;
+	NAND_IO_ERROR		res;
+
+	if ( nEccType == MLC_ECC_4BIT_TYPE )
+		pECC_Info = &gMLC_ECC_4Bit;
+	else if ( nEccType == MLC_ECC_8BIT_TYPE )
+		pECC_Info = &gMLC_ECC_8Bit;
+	else if ( nEccType == MLC_ECC_12BIT_TYPE )
+		pECC_Info = &gMLC_ECC_12Bit;
+	else if ( nEccType == MLC_ECC_14BIT_TYPE )
+		pECC_Info = &gMLC_ECC_14Bit;
+	else if ( nEccType == MLC_ECC_16BIT_TYPE )
+		pECC_Info = &gMLC_ECC_16Bit;
+	else
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	memset( nTempBuf, 0xFF, 30 );
+
+	//============================================
+	// Get Buffer Pointer
+	//============================================
+	if ( memcmp( nSpareBuffer, nTempBuf, 30 ) == 0 )
+	{
+		if ( nDataSize == 512 )
+			pSpareDW	= (unsigned int *)pECC_Info->All_FF_512_ECC_Code;
+		else if ( nDataSize == 12 )
+			pSpareDW	= (unsigned int *)&ALL_FF_ECC_BCH_04BIT_12;
+		else
+			pSpareDW	= (unsigned int *)&ALL_FF_ECC_BCH_04BIT_512;
+	}
+	else
+		pSpareDW	= (unsigned int *)nSpareBuffer;
+
+	//IO_CKC_EnableBUS( IO_CKC_BUS_ECC );
+	
+	pECC->ECC_CODE0	= *pSpareDW; ++pSpareDW;
+	pECC->ECC_CODE1	= *pSpareDW; ++pSpareDW;
+	pECC->ECC_CODE2	= *pSpareDW; ++pSpareDW;
+	pECC->ECC_CODE3	= *pSpareDW; ++pSpareDW;
+	pECC->ECC_CODE4	= *pSpareDW; ++pSpareDW;
+	pECC->ECC_CODE5	= *pSpareDW; ++pSpareDW;
+	pECC->ECC_CODE6	= *pSpareDW; ++pSpareDW;
+
+
+	/* Sync Delay */
+	ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP;
+
+	/* Wait MLC ECC Correction */
+	while ( !(pECC->ECC_IREQ & pECC_Info->DecodeFlag ) );
+
+	res = (NAND_IO_ERROR)SUCCESS;
+
+	/* Correction */
+	uErrorStatus = pECC->ERRNUM & 0x1F;
+
+	if ( uErrorStatus > pECC_Info->ErrorNum )
+	{
+		#ifdef NAND_IO_ECC_ERROR_LOG
+		PRINTF("\n\nErrorNum[%02d],DataSize[%03d] - Correction Fail", uErrorStatus, nDataSize );
+		#endif
+		res = ERR_NAND_IO_FAILED_CORRECTION_MLC_ECC;
+		goto ErrorCorrectionMLC;
+	}
+	else if ( uErrorStatus == HwERR_NUM_NOERR )
+	{
+		res = (NAND_IO_ERROR)SUCCESS;
+	}
+	else
+	{
+		for ( i = 0; i < uErrorStatus; ++i )
+		{
+			uErrAddr = *(unsigned long int*)(&pECC->ECC_EADDR0+i);
+
+			if ( ( uErrAddr >> 3 ) < nDataSize )
+				nPageBuffer[uErrAddr>>3] ^= (1<<(uErrAddr &0x7));
+		}
+	}
+	
+ErrorCorrectionMLC:
+	/* Disable MLC ECC */
+	//IO_CKC_DisableBUS( IO_CKC_BUS_ECC );
+	
+	return res;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_CorrectionSLC( U8* nPageBuffer, U8* nSpareBuffer );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nPageBuffer	= 
+*			nSpareBuffer	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_CorrectionSLCForNB( U8* nPageBuffer, U8* nSpareBuffer )
+{
+	unsigned int		uErrorStatus;
+	unsigned int		uSLCECC0, uSLCECC1;
+	NAND_IO_ERROR		res;
+
+	//IO_CKC_EnableBUS( IO_CKC_BUS_ECC );
+	
+	//==================================================================
+	//	[ TNFTL V1.0 ]
+	//==================================================================	
+	// 520th	: P64-P8		of ECC Area-1 [ DATA 256-511 ]
+	// 521th	: P1024-P128	of ECC Area-1 [ DATA 256-511 ]
+	// 522th	: P4-P1			of ECC Area-1 [ DATA 256-511 ]
+	// 525th	: P64-P8		of ECC Area-0 [ DATA 0-255 ]
+	// 526th	: P1024-P128	of ECC Area-0 [ DATA 0-255 ]
+	// 527th	: P4-P1			of ECC Area-0 [ DATA 0-255 ]
+	//==================================================================
+
+	/* Load SLC ECC Code for Area 1 */
+	uSLCECC0	= ( nSpareBuffer[ 8] << 16 ) +
+				  ( nSpareBuffer[ 9] <<  8 ) +
+				  ( nSpareBuffer[10] );
+				  
+	/* Load SLC ECC Code for Area 0 */
+	uSLCECC1	= ( nSpareBuffer[13] << 16 ) +
+				  ( nSpareBuffer[14] <<  8 ) +
+				  ( nSpareBuffer[15] );
+
+	res = (NAND_IO_ERROR)SUCCESS;
+	
+	/* Correction Area 0 */
+	pECC->ECC_CODE0 = uSLCECC1;
+	uErrorStatus = pECC->ERRNUM & 0x7;
+	
+	if ( uErrorStatus == HwERR_NUM_ERR1 )
+	{
+		nPageBuffer[pECC->ECC_EADDR0 >> 3] ^= (1 << (pECC->ECC_EADDR0 & 0x07));
+		res = (NAND_IO_ERROR)SUCCESS;
+	}	
+	else if ( uErrorStatus != HwERR_NUM_NOERR )
+	{
+		res	= ERR_NAND_IO_FAILED_CORRECTION_SLC_ECC;
+		goto ErrorCorrectionSLC;
+	}	
+
+	res = (NAND_IO_ERROR)SUCCESS;
+	
+	/* Correction Area 1 */
+	pECC->ECC_CODE0 = uSLCECC0;
+	uErrorStatus = pECC->ERRNUM & 0x7;	
+	
+	if ( uErrorStatus == HwERR_NUM_ERR1 )
+	{
+		nPageBuffer[pECC->ECC_EADDR0 >> 3] ^= (1 << (pECC->ECC_EADDR0 & 0x07));
+		res = (NAND_IO_ERROR)SUCCESS;
+	}
+	else if ( uErrorStatus != HwERR_NUM_NOERR )
+	{
+		res = ERR_NAND_IO_FAILED_CORRECTION_SLC_ECC;
+		goto ErrorCorrectionSLC;		
+	}
+
+ErrorCorrectionSLC:
+	
+	/* Disable SLC ECC */
+	//IO_CKC_DisableBUS( IO_CKC_BUS_ECC );
+	
+	return res;
+	
+}	
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_CorrectionMLCForNB( U8* nPageBuffer, U8* nSpareBuffer );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nPageBuffer	= 
+*			nSpareBuffer	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_CorrectionMLCForNB( U8* nPageBuffer, U8* nSpareBuffer )
+{
+	unsigned int		i;
+	unsigned int		uErrAddr;
+	unsigned int		uErrorStatus;
+	NAND_IO_ERROR		res;
+
+	//IO_CKC_EnableBUS( IO_CKC_BUS_ECC );
+
+	//==================================================================
+	//	[ TNFTL V1.0 ]
+	//==================================================================	
+	// 512th	: MLC ECC 0th Byte
+	// 513th	: MLC ECC 1th Byte
+	
+	// 520th	: MLC ECC 2th Byte
+	// 521th	: MLC ECC 3th Byte
+	// 522th	: MLC ECC 4th Byte
+	// 523th	: MLC ECC 5th Byte	
+	
+	// 524th	: MLC ECC 6th Byte	
+	// 525th	: MLC ECC 7th Byte		
+	// 526th	: MLC ECC 8th Byte		
+	// 527th	: MLC ECC 9th Byte		
+	//==================================================================
+	pECC->ECC_CODE0 = ( nSpareBuffer[8] ) +
+				   ( nSpareBuffer[9] <<  8 ) +
+				   ( nSpareBuffer[10] << 16 ) +
+				   ( nSpareBuffer[11] << 24 );
+				  
+	pECC->ECC_CODE1 = ( nSpareBuffer[12] ) +
+				   ( nSpareBuffer[13] <<  8 ) +
+				   ( ( nSpareBuffer[14] & 0x0F ) << 16 );
+				  
+	/* Sync Delay */
+	ASM_NOP;
+	
+	/* Wait MLC ECC Correction */
+	while ( !(pECC->ECC_IREQ & HwECC_IREQ_M4DF) );
+
+	res = (NAND_IO_ERROR)SUCCESS;
+
+	/* Correction */
+	uErrorStatus = pECC->ERRNUM & 0x7;
+
+	if ( uErrorStatus > HwERR_NUM_ERR4 )
+	{
+		res = ERR_NAND_IO_FAILED_CORRECTION_MLC_ECC;
+		goto ErrorCorrectionMLC;
+	}
+	else if ( uErrorStatus == HwERR_NUM_NOERR )
+	{
+		res = (NAND_IO_ERROR)SUCCESS;
+	}
+	else
+	{
+		for ( i = 0; i < uErrorStatus; ++i )
+		{
+			uErrAddr = *(unsigned long int*)(&pECC->ECC_EADDR0+i);
+
+			nPageBuffer[uErrAddr>>3] ^= (1<<(uErrAddr &0x7));
+		}
+	}	
+
+ErrorCorrectionMLC:
+
+	//IO_CKC_DisableBUS( IO_CKC_BUS_ECC );
+	
+	return res;
+}	
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_CorrectionMLCForCB( U8* nPageBuffer, U8* nSpareBuffer, U16 nDataSize, U16 nBufferMode )
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nPageBuffer	= 
+*			nSpareBuffer	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_CorrectionMLCForCB( U8* nPageBuffer, U8* nSpareBuffer, U16 nDataSize, U16 nBufferMode )
+{
+	unsigned int		i;
+	unsigned int		uErrAddr;
+	unsigned int		uErrorStatus;
+	unsigned int		wShiftBufferAddr;
+	NAND_IO_ERROR		res;
+
+	if ( nBufferMode == NAND_SERIAL_CHAIN_BUFFER )
+		wShiftBufferAddr = 1;
+	else
+		wShiftBufferAddr = 0;
+	
+	//IO_CKC_EnableBUS( IO_CKC_BUS_ECC );
+	
+	//==================================================================
+	//	[ TNFTL V1.0 ]
+	//==================================================================	
+	// 512th	: MLC ECC 0th Byte
+	// 513th	: MLC ECC 1th Byte
+	
+	// 520th	: MLC ECC 2th Byte
+	// 521th	: MLC ECC 3th Byte
+	// 522th	: MLC ECC 4th Byte
+	// 523th	: MLC ECC 5th Byte	
+	
+	// 524th	: MLC ECC 6th Byte	
+	// 525th	: MLC ECC 7th Byte		
+	// 526th	: MLC ECC 8th Byte		
+	// 527th	: MLC ECC 9th Byte		
+	//==================================================================		
+	pECC->ECC_CODE0 = ( nSpareBuffer[0] ) +
+				   ( nSpareBuffer[1] <<  8 ) +
+				   ( nSpareBuffer[2] << 16 ) +
+				   ( nSpareBuffer[3] << 24 );
+
+	pECC->ECC_CODE1 = ( nSpareBuffer[4] ) +
+				   ( nSpareBuffer[5] <<  8 ) +
+				   ( ( nSpareBuffer[6] & 0x0F ) << 16 );
+
+	/* Sync Delay */
+	ASM_NOP;
+	ASM_NOP;
+	ASM_NOP;
+	ASM_NOP;
+	ASM_NOP;
+	
+	/* Wait MLC ECC Correction */
+	while ( !(pECC->ECC_IREQ & HwECC_IREQ_M4DF) );
+
+	res = (NAND_IO_ERROR)SUCCESS;
+
+	/* Correction */
+	uErrorStatus = pECC->ERRNUM & 0x7;
+
+	if ( uErrorStatus > HwERR_NUM_ERR4 )
+	{
+		res = ERR_NAND_IO_FAILED_CORRECTION_MLC_ECC;
+		goto ErrorCorrectionMLC;
+	}
+	else if ( uErrorStatus == HwERR_NUM_NOERR )
+	{
+		res = (NAND_IO_ERROR)SUCCESS;
+	}
+	else
+	{
+		for ( i = 0; i < uErrorStatus; ++i )
+		{
+			uErrAddr = *(unsigned long int*)(&pECC->ECC_EADDR0+i);
+
+			if ( ( uErrAddr >> 3 ) < nDataSize )
+				nPageBuffer[(uErrAddr>>3)<< wShiftBufferAddr] ^= (1<<(uErrAddr &0x7));
+		}
+	}
+
+ErrorCorrectionMLC:
+
+	//IO_CKC_DisableBUS( IO_CKC_BUS_ECC );
+
+	return res;
+}
+
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_CorrectionMLCForCB( U8* nPageBuffer, U8* nSpareBuffer, U16 nDataSize, U16 nBufferMode )
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nPageBuffer	= 
+*			nSpareBuffer	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_CorrectionMLC8ForCB( U8* nPageBuffer, U8* nSpareBuffer, U16 nDataSize, U16 nBufferMode )
+{
+	unsigned int		i;
+	unsigned int		uErrAddr;
+	unsigned int		uErrorStatus;
+	unsigned int		wShiftBufferAddr;
+	//unsigned short		*pPageHW;
+	NAND_IO_ERROR		res;
+
+	if ( nBufferMode == NAND_SERIAL_CHAIN_BUFFER )
+		wShiftBufferAddr = 1;
+	else
+		wShiftBufferAddr = 0;
+	
+	//IO_CKC_EnableBUS( IO_CKC_BUS_ECC );
+	
+	//==================================================================
+	//	[ TNFTL V1.0 ]
+	//==================================================================	
+	// 512th	: MLC ECC 0th Byte
+	// 513th	: MLC ECC 1th Byte
+	
+	// 520th	: MLC ECC 2th Byte
+	// 521th	: MLC ECC 3th Byte
+	// 522th	: MLC ECC 4th Byte
+	// 523th	: MLC ECC 5th Byte	
+	
+	// 524th	: MLC ECC 6th Byte	
+	// 525th	: MLC ECC 7th Byte		
+	// 526th	: MLC ECC 8th Byte		
+	// 527th	: MLC ECC 9th Byte		
+	//==================================================================		
+
+	/* Load MLC ECC Code */
+	pECC->ECC_CODE0 = ( nSpareBuffer[ 0] ) +
+				   ( nSpareBuffer[ 1] <<  8 ) +
+				   ( nSpareBuffer[ 2] << 16 ) +
+				   ( nSpareBuffer[ 3] << 24 );
+
+	pECC->ECC_CODE1 = ( nSpareBuffer[ 4] ) +
+				   ( nSpareBuffer[ 5] <<  8 ) +
+				   ( nSpareBuffer[ 6] << 16 ) +
+				   ( nSpareBuffer[ 7] << 24 );
+
+	pECC->ECC_CODE2 = ( nSpareBuffer[ 8] ) +
+				   ( nSpareBuffer[ 9] <<  8 ) +
+				   ( nSpareBuffer[10] << 16 ) +
+				   ( nSpareBuffer[11] << 24 );
+
+	pECC->ECC_CODE3 = ( nSpareBuffer[12] );
+	
+	/* Sync Delay */
+	ASM_NOP;
+
+	/* Wait MLC ECC Correction */
+	while ( !(pECC->ECC_IREQ & HwECC_IREQ_M8DF) );
+
+	res = (NAND_IO_ERROR)SUCCESS;
+	
+	/* Correction */
+	uErrorStatus = pECC->ERRNUM & 0x1F;
+	
+	if ( uErrorStatus > HwERR_NUM_ERR8 )
+	{
+		res = ERR_NAND_IO_FAILED_CORRECTION_MLC_ECC;
+		goto ErrorCorrectionMLC;
+	}	
+	else if ( uErrorStatus == HwERR_NUM_NOERR )
+	{
+		res = (NAND_IO_ERROR)SUCCESS;
+	}
+	else
+	{
+		for ( i = 0; i < uErrorStatus; ++i )
+		{
+			uErrAddr = *(unsigned long int*)(&pECC->ECC_EADDR0+i);
+
+			if ( ( uErrAddr >> 3 ) < nDataSize )
+				nPageBuffer[(uErrAddr>>3) << wShiftBufferAddr] ^= (1<<(uErrAddr &0x7));
+		}
+	}
+
+ErrorCorrectionMLC:
+
+	//IO_CKC_DisableBUS( IO_CKC_BUS_ECC );
+
+	return res;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_CorrectionMLCForCB( U8* nPageBuffer, U8* nSpareBuffer, U16 nDataSize, U16 nBufferMode )
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nPageBuffer	= 
+*			nSpareBuffer	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_CorrectionMLC12ForCB( U8* nPageBuffer, U8* nSpareBuffer, U16 nDataSize, U16 nBufferMode )
+{
+	NAND_IO_ERROR		res = (NAND_IO_ERROR)SUCCESS;
+	unsigned int		i;
+	unsigned int		uErrAddr;
+	unsigned int		uErrorStatus;
+	unsigned int		wShiftBufferAddr;
+	unsigned int		*pSpareDW;
+
+	if ( nBufferMode == NAND_SERIAL_CHAIN_BUFFER )
+		wShiftBufferAddr = 1;
+	else
+		wShiftBufferAddr = 0;
+	
+	//IO_CKC_EnableBUS( IO_CKC_BUS_ECC );
+	
+	/* Load MLC ECC Code */
+	pSpareDW	= (unsigned int *)nSpareBuffer;
+
+	pECC->ECC_CODE0	= *pSpareDW; ++pSpareDW;
+	pECC->ECC_CODE1	= *pSpareDW; ++pSpareDW;
+	pECC->ECC_CODE2	= *pSpareDW; ++pSpareDW;
+	pECC->ECC_CODE3	= *pSpareDW; ++pSpareDW;
+	pECC->ECC_CODE4	= *pSpareDW; ++pSpareDW;
+	pECC->ECC_CODE5	= *pSpareDW; ++pSpareDW;
+	pECC->ECC_CODE6	= *pSpareDW; ++pSpareDW;
+
+	
+	/* Sync Delay */
+	ASM_NOP;
+
+	/* Wait MLC ECC Correction */
+	while ( !(pECC->ECC_IREQ & HwECC_IREQ_M12DF) );
+
+	res = (NAND_IO_ERROR)SUCCESS;
+
+	/* Correction */
+	uErrorStatus = pECC->ERRNUM & 0x1F;
+
+	if ( uErrorStatus > HwERR_NUM_ERR12 )
+	{
+		res = ERR_NAND_IO_FAILED_CORRECTION_MLC_ECC;
+		goto ErrorCorrectionMLC;
+	}
+	else if ( uErrorStatus == HwERR_NUM_NOERR )
+	{
+		res = (NAND_IO_ERROR)SUCCESS;
+	}
+	else
+	{
+		for ( i = 0; i < uErrorStatus; ++i )
+		{
+			uErrAddr = *(unsigned long int*)(&pECC->ECC_EADDR0+i);
+
+			if ( ( uErrAddr >> 3 ) < nDataSize )
+				nPageBuffer[(uErrAddr>>3) <<wShiftBufferAddr ] ^= (1<<(uErrAddr &0x7));
+		}
+	}
+	
+ErrorCorrectionMLC:
+
+	//IO_CKC_DisableBUS( IO_CKC_BUS_ECC );
+	
+	return res;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      static __inline NAND_IO_ERROR NAND_IO_EncodeChainData( NAND_IO_DEVINFO *nDevInfo, U8 *nPageBuffer, U8 *nSpareBuffer, int nMode, int nEccOnOff );
+*  
+*  DESCRIPTION : 
+*  
+*  INPUT:
+*			nDevInfo	= 
+*			nEccOnOff	= 
+*			nMode	= 
+*			nPageBuffer	= 
+*			nSpareBuffer	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+*  REMARK:	  by nemo
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_EncodeChainData( NAND_IO_DEVINFO *nDevInfo, U8 *nPageBuffer, U8 *nSpareBuffer, int nMode, int nEccOnOff )
+{
+	unsigned short int	i, j;
+	unsigned short int	nECCDataSize;
+	unsigned char		bAlignAddr;
+	#ifdef _LINUX_
+	unsigned char		nECCBuffer[30]__attribute__((aligned(8)));
+	#else
+	unsigned char		nECCBuffer[30];
+	#endif
+	unsigned char		*pPageB, *pSpareB;
+	unsigned char		*pDataBuffer,*pSpareBuffer;
+	unsigned char		*pDataBuffer2,*pSpareBuffer2;
+	unsigned char		*pEccB;
+	DWORD_BYTE			uDWordByte;
+	NAND_IO_ERROR		res;
+
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	if ( nEccOnOff == ECC_OFF )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	res = (NAND_IO_ERROR)SUCCESS;
+
+	//=========================================================================
+	// Buffer Mode Setting
+	//=========================================================================
+	nECCDataSize = nDevInfo->EccDataSize;
+
+	if ( ( nDevInfo->Feature.MediaType & A_PARALLEL ) && ( nMode == NAND_SERIAL_CHAIN_BUFFER ) )
+	{
+		bAlignAddr = 1;
+
+	    if ( ( ( nDevInfo->Feature.MediaType & A_MLC ) || (nDevInfo->Feature.MediaType & A_SLC ) ) && ( nDevInfo->Feature.MediaType & A_BIG ) )
+			nECCDataSize -= 2;
+	}
+	else
+		bAlignAddr = 0;
+
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================
+	//if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+	//	NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	//else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//=========================================================================
+	// Get Buffer Pointer
+	//=========================================================================
+	pPageB		= (unsigned char*)nPageBuffer;
+	pSpareB		= (unsigned char*)nSpareBuffer;
+
+	/* Get Data Buffer */
+	pDataBuffer = (unsigned char*)pPageB;
+	pDataBuffer2  = pDataBuffer + 1;
+
+	/* Get Spare Buffer */
+	pSpareBuffer = (unsigned char*)pSpareB;
+	pSpareBuffer2 = pSpareBuffer + 1;
+
+	//----------------------------------------------
+	//	Write Data as 512Bytes repeatly 
+	//----------------------------------------------
+	for ( j = 0; j < nDevInfo->PPages; ++j )
+	{
+		if ( ( j == ( nDevInfo->PPages >> 1 ) ) && ( bAlignAddr == 1 ) )
+		{
+			pPageB = pDataBuffer2;
+			pSpareBuffer = pSpareBuffer2;
+		}
+		
+		//####################################################
+		//#	Write 512 Page Data
+		//####################################################
+		if (!( pNFC->NFC_CTRL1 & Hw30 ))
+		{
+			/* Setup ECC Block */
+			if ( nEccOnOff == ECC_ON )
+			{
+				#if defined(_WINCE_) || defined(_LINUX_)
+				NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+				#else
+				NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&pNFC->NFC_LDATA );
+				#endif
+				pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );		// Data Size...		
+				pECC->ECC_CLEAR	= 0x00000000;				
+			}
+			
+			/* Write 512 Data Area */
+			BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
+			pNFC->NFC_DSIZE	= 512;
+			pNFC->NFC_IREQ = 0x77;	// pNFC->NFC_IREQ_FLAG1;		
+			pNFC->NFC_PSTART = 0;
+			
+			i = 128;
+			do {
+				while (!( pNFC->NFC_CTRL & HwNFC_CTRL_FS_RDY ));
+				
+				if ( bAlignAddr == 0 )
+				{
+					uDWordByte.BYTE[0] = *pPageB;++pPageB;
+					uDWordByte.BYTE[1] = *pPageB;++pPageB;
+					uDWordByte.BYTE[2] = *pPageB;++pPageB;
+					uDWordByte.BYTE[3] = *pPageB;++pPageB;
+					pNFC->NFC_LDATA	= uDWordByte.DWORD;
+				}
+				else if ( bAlignAddr == 1 )
+				{
+					uDWordByte.BYTE[0] = *pPageB;pPageB += 2;
+					uDWordByte.BYTE[1] = *pPageB;pPageB += 2;
+					uDWordByte.BYTE[2] = *pPageB;pPageB += 2;
+					uDWordByte.BYTE[3] = *pPageB;pPageB += 2;
+					pNFC->NFC_LDATA	= uDWordByte.DWORD;
+				}
+			}while(--i);
+
+			while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));			
+		}
+		else
+		{
+			/* Setup ECC Block */
+			if ( nEccOnOff == ECC_ON )
+			{
+				#if defined(_WINCE_) || defined(_LINUX_)
+				NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&NAND_IO_HwDATA_PA );
+				#else
+				NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&pNFC->NFC_WDATA );
+				#endif
+				pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );		// Data Size...		
+				pECC->ECC_CLEAR	= 0x00000000;
+			}
+			
+			i = 128;
+			do {
+				if ( bAlignAddr == 0 )
+				{
+					uDWordByte.BYTE[0] = *pPageB;++pPageB;
+					uDWordByte.BYTE[1] = *pPageB;++pPageB;
+					uDWordByte.BYTE[2] = *pPageB;++pPageB;
+					uDWordByte.BYTE[3] = *pPageB;++pPageB;
+					pNFC->NFC_WDATA	= uDWordByte.DWORD;
+				}
+				else if ( bAlignAddr == 1 )
+				{
+					uDWordByte.BYTE[0] = *pPageB;pPageB += 2;
+					uDWordByte.BYTE[1] = *pPageB;pPageB += 2;
+					uDWordByte.BYTE[2] = *pPageB;pPageB += 2;
+					uDWordByte.BYTE[3] = *pPageB;pPageB += 2;
+					pNFC->NFC_WDATA	= uDWordByte.DWORD;
+				}
+			}while(--i);			
+		}
+
+		//####################################################
+		//####################################################
+
+		/* Adapt type of address */
+		pEccB = (unsigned char*)nECCBuffer;
+
+		/*	Load ECC code from ECC block */
+		if ( nEccOnOff == ECC_ON )
+		{
+			res = NAND_IO_EncodeECC( nDevInfo->EccType, pEccB );
+			if ( res != SUCCESS )
+				goto ErrorWrite512Data;
+		}
+
+		if ( bAlignAddr == 0 )
+		{
+			for ( i = 0; i < nECCDataSize; ++i )
+			{
+				*pSpareBuffer = nECCBuffer[i];
+				pSpareBuffer += 1;
+			}
+		}
+		else if ( bAlignAddr == 1 )
+		{
+			for ( i = 0; i < nECCDataSize; ++i )
+			{
+				*pSpareBuffer = nECCBuffer[i];
+				pSpareBuffer += 2;
+			}			
+		}
+	}
+
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+
+ErrorWrite512Data:
+	return res;
+
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      static __inline NAND_IO_ERROR NAND_IO_EncodeChainDataForGoldenPage( NAND_IO_DEVINFO *nDevInfo, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+*  
+*  DESCRIPTION : 
+*  
+*  INPUT:
+*			nDevInfo	= 
+*			nEccOnOff	= 
+*			nPageBuffer	= 
+*			nSpareBuffer	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+*  REMARK:	  by nemo
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_EncodeChainDataForGoldenPage( NAND_IO_DEVINFO *nDevInfo, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff )
+{
+	unsigned int		i;
+	#ifdef _LINUX_
+	unsigned char		nECCBuffer[30]__attribute__((aligned(8)));
+	#else
+	unsigned char		nECCBuffer[30];
+	#endif
+	unsigned char		*pPageB, *pSpareB;
+	unsigned char		*pDataBuffer,*pSpareBuffer;
+	unsigned char		*pEccB;
+	DWORD_BYTE			uDWordByte;
+	NAND_IO_ERROR		res;
+
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	//if ( nEccOnOff == ECC_OFF )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	res = (NAND_IO_ERROR)SUCCESS;
+
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//=========================================================================
+	// Get Buffer Pointer
+	//=========================================================================
+	/* Adapt type of address */
+	pPageB		= (unsigned char*)nPageBuffer;
+	pSpareB		= (unsigned char*)nSpareBuffer;
+
+	/* Get Buffer pointer */
+	pDataBuffer = (unsigned char*)pPageB;
+	pSpareBuffer = (unsigned char*)pSpareB;
+
+	//####################################################
+	//#	Dummy Write Page Data
+	//####################################################
+
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		pDataBuffer += ( 528 * ( nDevInfo->PPages - 2 ));
+	else
+		pDataBuffer += ( 528 * ( nDevInfo->PPages - 1 ));
+
+	if (!( pNFC->NFC_CTRL1 & Hw30 ))
+	{
+		/* Setup ECC Block */
+		if ( nEccOnOff == ECC_ON )
+		{
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&pNFC->NFC_LDATA );
+			#endif
+			pECC->ECC_CTRL	|= ( 256 << ECC_SHIFT_DATASIZE );		// Data Size...		
+			pECC->ECC_CLEAR	= 0x00000000;
+		}
+
+		/* Write 256 Page Data */
+		BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
+		pNFC->NFC_DSIZE	= 256;
+		pNFC->NFC_IREQ = 0x77;	// pNFC->NFC_IREQ_FLAG1;		
+		pNFC->NFC_PSTART = 0;
+
+		i = ( 64 ); // 256 byte
+		do {
+				while (!( pNFC->NFC_CTRL & HwNFC_CTRL_FS_RDY ));
+				uDWordByte.BYTE[0] = *pDataBuffer;++pDataBuffer;
+				uDWordByte.BYTE[1] = *pDataBuffer;++pDataBuffer;
+				uDWordByte.BYTE[2] = *pDataBuffer;++pDataBuffer;
+				uDWordByte.BYTE[3] = *pDataBuffer;++pDataBuffer;
+				pNFC->NFC_LDATA	= uDWordByte.DWORD;
+		}while(--i);
+		while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));		
+	}
+	else
+	{
+		/* Setup ECC Block */
+		if ( nEccOnOff == ECC_ON )
+		{
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&NAND_IO_HwDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&pNFC->NFC_WDATA );
+			#endif
+			pECC->ECC_CTRL	|= ( 256 << ECC_SHIFT_DATASIZE );		// Data Size...		
+			pECC->ECC_CLEAR	= 0x00000000;
+		}
+
+		i = ( 64 ); // 256 byte
+		do {
+				uDWordByte.BYTE[0] = *pDataBuffer;++pDataBuffer;
+				uDWordByte.BYTE[1] = *pDataBuffer;++pDataBuffer;
+				uDWordByte.BYTE[2] = *pDataBuffer;++pDataBuffer;
+				uDWordByte.BYTE[3] = *pDataBuffer;++pDataBuffer;
+				pNFC->NFC_WDATA	= uDWordByte.DWORD;
+		}while(--i);		
+	}
+
+	/* Adapt type of address */
+	pEccB = (unsigned char*)nECCBuffer;
+	
+	/*	Load ECC code from ECC block */
+	if ( nEccOnOff == ECC_ON )
+	{
+		res = NAND_IO_EncodeECC( nDevInfo->EccType, pEccB );
+		if ( res != SUCCESS )
+			goto ErrorWrite512Data;
+
+		for ( i = 0; i < nDevInfo->EccDataSize; ++i )
+		{
+			*pDataBuffer = nECCBuffer[i];
+			pDataBuffer += 1;
+		}
+
+/*		pDataBuffer += nDevInfo->EccDataSize;*/
+	}
+
+	/* Disable ECC Block */
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	//####################################################
+	//####################################################
+
+	//####################################################
+	//#	Dummy Write Spare Data
+	//####################################################
+	if (!( pNFC->NFC_CTRL1 & Hw30 ))
+	{
+		/* Setup ECC Block */
+		if ( nEccOnOff == ECC_ON )
+		{
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&pNFC->NFC_LDATA );
+			#endif
+			pECC->ECC_CTRL	|= ( nDevInfo->Feature.SpareSize << ECC_SHIFT_DATASIZE );		// Data Size...		
+			pECC->ECC_CLEAR	= 0x00000000;
+		}
+
+		/* Write Spare Data */
+		BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
+		pNFC->NFC_DSIZE	= nDevInfo->Feature.SpareSize;
+		pNFC->NFC_IREQ = 0x77;	// pNFC->NFC_IREQ_FLAG1;		
+		pNFC->NFC_PSTART = 0;
+
+		i = ( nDevInfo->Feature.SpareSize >> 2 );
+		do {
+				while (!( pNFC->NFC_CTRL & HwNFC_CTRL_FS_RDY ));
+				uDWordByte.BYTE[0] = *pSpareB;++pSpareB;
+				uDWordByte.BYTE[1] = *pSpareB;++pSpareB;
+				uDWordByte.BYTE[2] = *pSpareB;++pSpareB;
+				uDWordByte.BYTE[3] = *pSpareB;++pSpareB;
+				pNFC->NFC_LDATA	= uDWordByte.DWORD;
+		}while(--i);
+		while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));		
+	}
+	else
+	{
+		/* Setup ECC Block */
+		if ( nEccOnOff == ECC_ON )
+		{
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&NAND_IO_HwDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&pNFC->NFC_WDATA );
+			#endif
+			pECC->ECC_CTRL	|= ( nDevInfo->Feature.SpareSize << ECC_SHIFT_DATASIZE );		// Data Size...		
+			pECC->ECC_CLEAR	= 0x00000000;
+		}
+
+		i = ( nDevInfo->Feature.SpareSize >> 2 );
+		do {
+				uDWordByte.BYTE[0] = *pSpareB;++pSpareB;
+				uDWordByte.BYTE[1] = *pSpareB;++pSpareB;
+				uDWordByte.BYTE[2] = *pSpareB;++pSpareB;
+				uDWordByte.BYTE[3] = *pSpareB;++pSpareB;
+				pNFC->NFC_WDATA	= uDWordByte.DWORD;
+		}while(--i);
+	}
+
+	//####################################################
+	//####################################################
+
+	pEccB = (unsigned char*)nECCBuffer;
+
+	/*	Load ECC code from ECC block */
+	if ( nEccOnOff == ECC_ON )
+	{
+		res = NAND_IO_EncodeECC( nDevInfo->EccType, pEccB );
+		if ( res != SUCCESS )
+			goto ErrorWrite512Data;
+
+		for ( i = 0; i < nDevInfo->EccDataSize; ++i )
+		{
+			*pDataBuffer = nECCBuffer[i];
+			pDataBuffer += 1;
+		}
+	}
+
+	/* Disable ECC Block */
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+	
+	//=========================================================================
+	// Return
+	//=========================================================================
+
+ErrorWrite512Data:
+	return res;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      static __inline NAND_IO_ERROR NAND_IO_DecodeChainData( NAND_IO_DEVINFO *nDevInfo, U8 *nPageBuffer, U8 *nSpareBuffer, int nMode, int nEccOnOff );
+*  
+*  DESCRIPTION : 
+*  
+*  INPUT:
+*			nDevInfo	= 
+*			nEccOnOff	= 
+*			nMode	= 
+*			nPageBuffer	= 
+*			nSpareBuffer	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+*  REMARK:	  by nemo
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_DecodeChainData( NAND_IO_DEVINFO *nDevInfo, U8 *nPageBuffer, U8 *nSpareBuffer, int nMode, int nEccOnOff )
+{
+	unsigned int		i,j;
+	unsigned int		nECCDataSize;
+	unsigned char		bAlignAddr;
+	#ifdef _LINUX_
+	unsigned char		nECCBuffer[30]__attribute__((aligned(8)));
+	#else
+	unsigned char		nECCBuffer[30];
+	#endif
+	unsigned char		*pPageB, *pSpareB;
+	unsigned char		*pDataBuffer,*pSpareBuffer;
+	unsigned char		*pDataBuffer2,*pSpareBuffer2;
+	unsigned char		*pEccB;
+	DWORD_BYTE			uDWordByte;
+	NAND_IO_ERROR		res = (NAND_IO_ERROR)SUCCESS;
+	
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	//if ( nEccOnOff == ECC_OFF )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	res = (NAND_IO_ERROR)SUCCESS;
+
+	//=========================================================================
+	// Check Align of PageBuffer Address
+	//=========================================================================
+	nECCDataSize = nDevInfo->EccDataSize;
+	
+	if ( ( nDevInfo->Feature.MediaType & A_PARALLEL ) && ( nMode == NAND_SERIAL_CHAIN_BUFFER ) )
+	{
+		bAlignAddr = 1;
+		
+	    if ( ( ( nDevInfo->Feature.MediaType & A_MLC ) || (nDevInfo->Feature.MediaType & A_SLC ) ) && ( nDevInfo->Feature.MediaType & A_BIG ) )
+			nECCDataSize -= 2;
+	}
+	else
+		bAlignAddr = 0;
+	
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================	
+	//if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+	//	NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	//else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//=========================================================================
+	// Get Buffer Pointer
+	//=========================================================================
+	pPageB		= (unsigned char*)nPageBuffer;
+	pSpareB		= (unsigned char*)nSpareBuffer;
+
+	/* Get Data Buffer */
+	pDataBuffer 	= (unsigned char*)pPageB;
+	pDataBuffer2	= pDataBuffer + 1;
+
+	/* Adapt type of address */
+	pSpareBuffer	= (unsigned char*)pSpareB;
+	pSpareBuffer2	= pSpareBuffer + 1;
+
+	//----------------------------------------------
+	//	Read Data as 512Bytes repeatly
+	//----------------------------------------------
+	for ( j = 0; j < nDevInfo->PPages; ++j )
+	{
+		if ( ( j == (U32)( nDevInfo->PPages >> 1 ) ) && ( bAlignAddr == 1 ) )
+		{
+			pPageB 		 = pDataBuffer2;
+			pDataBuffer = pDataBuffer2;
+			pSpareBuffer = pSpareBuffer2;
+		}
+
+		//####################################################
+		//#	Read 512 Page Data
+		//####################################################
+		if (!( pNFC->NFC_CTRL1 & Hw30 ))
+		{
+			/* Setup ECC Block */
+			if ( nEccOnOff == ECC_ON )
+			{
+				#if defined(_WINCE_) || defined(_LINUX_)
+				NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+				#else
+				NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&pNFC->NFC_LDATA );
+				#endif
+				pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );		// Data Size...		
+				pECC->ECC_CLEAR	 = 0x00000000;						// Clear ECC Block
+			}
+
+			/* Read 512 Data Area */
+			BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
+			pNFC->NFC_DSIZE	= 512;
+			pNFC->NFC_IREQ = 0x77;	// pNFC->NFC_IREQ_FLAG1;		
+			pNFC->NFC_PSTART = 0;
+			
+			i = 128;
+			do {
+				while (!( pNFC->NFC_CTRL & HwNFC_CTRL_FS_RDY ));
+				
+				if ( bAlignAddr == 0 )
+				{
+					uDWordByte.BYTE[0] = *pPageB;++pPageB;
+					uDWordByte.BYTE[1] = *pPageB;++pPageB;
+					uDWordByte.BYTE[2] = *pPageB;++pPageB;
+					uDWordByte.BYTE[3] = *pPageB;++pPageB;
+					pNFC->NFC_LDATA	= uDWordByte.DWORD;
+				}
+				else if ( bAlignAddr == 1 )
+				{
+					uDWordByte.BYTE[0] = *pPageB;pPageB += 2;
+					uDWordByte.BYTE[1] = *pPageB;pPageB += 2;
+					uDWordByte.BYTE[2] = *pPageB;pPageB += 2;
+					uDWordByte.BYTE[3] = *pPageB;pPageB += 2;
+					pNFC->NFC_LDATA	= uDWordByte.DWORD;
+				}
+			}while(--i);
+
+			while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));			
+		}
+		else
+		{
+			/* Setup ECC Block */
+			if ( nEccOnOff == ECC_ON )
+			{
+				#if defined(_WINCE_) || defined(_LINUX_)
+				NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&NAND_IO_HwDATA_PA );
+				#else
+				NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&pNFC->NFC_WDATA );
+				#endif
+				pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );		// Data Size...		
+				pECC->ECC_CLEAR	 = 0x00000000;			/* Clear ECC Block		*/
+				
+			}
+
+			i = 128;
+			do {
+				if ( bAlignAddr == 0 )
+				{
+					uDWordByte.BYTE[0] = *pPageB;++pPageB;
+					uDWordByte.BYTE[1] = *pPageB;++pPageB;
+					uDWordByte.BYTE[2] = *pPageB;++pPageB;
+					uDWordByte.BYTE[3] = *pPageB;++pPageB;
+					pNFC->NFC_WDATA	= uDWordByte.DWORD;
+				}
+				else if ( bAlignAddr == 1 )
+				{
+					uDWordByte.BYTE[0] = *pPageB;pPageB += 2;
+					uDWordByte.BYTE[1] = *pPageB;pPageB += 2;
+					uDWordByte.BYTE[2] = *pPageB;pPageB += 2;
+					uDWordByte.BYTE[3] = *pPageB;pPageB += 2;
+					pNFC->NFC_WDATA	= uDWordByte.DWORD;
+				}
+			}while(--i);			
+		}
+		
+		//####################################################
+		//####################################################
+
+		/* Adapt type of address */
+		pEccB = (unsigned char*)nECCBuffer;
+
+		if ( bAlignAddr == 0 )
+		{
+			for ( i = 0; i < nECCDataSize; ++i )
+			{
+				nECCBuffer[i] = *pSpareBuffer;
+				pSpareBuffer += 1;
+			}
+		}
+		else if ( bAlignAddr == 1 )
+		{
+			for ( i = 0; i < nECCDataSize; ++i )
+			{
+				nECCBuffer[i] = *pSpareBuffer;
+				pSpareBuffer += 2;
+			}			
+		}
+
+		/* Check and Correct ECC code */
+		if ( nEccOnOff == ECC_ON )
+		{			
+			if ( nDevInfo->EccType == SLC_ECC_TYPE )
+			{
+				//===================================
+				//  SLC ECC Correction
+				//===================================				
+				res |= NAND_IO_CorrectionSLC( pDataBuffer, nECCBuffer );
+			}	
+			else if ( nDevInfo->EccType == MLC_ECC_4BIT_TYPE )
+			{
+				//===================================
+				// 4 Bit MLC ECC Correction
+				//===================================
+				if (( nECCBuffer[0] == 0xFF ) && ( nECCBuffer[1] == 0xFF ) &&
+					( nECCBuffer[2] == 0xFF ) && ( nECCBuffer[3] == 0xFF ) &&
+					( nECCBuffer[4] == 0xFF ) && ( nECCBuffer[5] == 0xFF ) &&
+					( nECCBuffer[6] == 0xFF ) && ( nECCBuffer[7] == 0xFF ) &&
+					( nECCBuffer[8] == 0xFF ) && ( nECCBuffer[9] == 0xFF ))
+				{
+					if ( nEccOnOff == ECC_ON )
+						NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+				}
+				else
+				{
+					if ( bAlignAddr == 0 )
+					{
+						res |= NAND_IO_CorrectionMLCForCB( pDataBuffer, nECCBuffer, 512, NAND_NORMAL_BUFFER );
+						pDataBuffer += 512;
+					}
+					else if ( bAlignAddr == 1 )
+					{
+						res |= NAND_IO_CorrectionMLCForCB( pDataBuffer, nECCBuffer, 512, NAND_SERIAL_CHAIN_BUFFER );
+					}
+				}
+			}
+			else if ( nDevInfo->EccType == MLC_ECC_8BIT_TYPE )
+			{
+				//===================================
+				// 8 Bit MLC ECC Correction
+				//===================================
+				if (( nECCBuffer[ 0] == 0xFF ) && ( nECCBuffer[ 1] == 0xFF ) &&
+					( nECCBuffer[ 2] == 0xFF ) && ( nECCBuffer[ 3] == 0xFF ) &&
+					( nECCBuffer[ 4] == 0xFF ) && ( nECCBuffer[ 5] == 0xFF ) &&
+					( nECCBuffer[ 6] == 0xFF ) && ( nECCBuffer[ 7] == 0xFF ) &&
+					( nECCBuffer[ 8] == 0xFF ) && ( nECCBuffer[ 9] == 0xFF ) &&
+					( nECCBuffer[10] == 0xFF ) && ( nECCBuffer[11] == 0xFF ) &&
+					( nECCBuffer[12] == 0xFF ) && ( nECCBuffer[13] == 0xFF ) &&
+					( nECCBuffer[14] == 0xFF ) && ( nECCBuffer[15] == 0xFF ) &&
+					( nECCBuffer[16] == 0xFF ) && ( nECCBuffer[17] == 0xFF ) &&
+					( nECCBuffer[18] == 0xFF ) && ( nECCBuffer[19] == 0xFF ))
+				{
+					if ( nEccOnOff == ECC_ON )
+						NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+				}
+				else
+				{
+					if ( bAlignAddr == 0 )
+					{
+						res |= NAND_IO_CorrectionMLC8ForCB( pDataBuffer, nECCBuffer, 512, NAND_NORMAL_BUFFER );
+						pDataBuffer += 512;
+					}
+					else if ( bAlignAddr == 1 )
+					{
+						res |= NAND_IO_CorrectionMLC8ForCB( pDataBuffer, nECCBuffer, 512, NAND_SERIAL_CHAIN_BUFFER );
+						pDataBuffer += 1024;						
+					}
+				}
+			}
+			else if ( nDevInfo->EccType == MLC_ECC_12BIT_TYPE )
+			{
+				//===================================
+				// 8 Bit MLC ECC Correction
+				//===================================
+				if (( nECCBuffer[ 0] == 0xFF ) && ( nECCBuffer[ 1] == 0xFF ) &&
+					( nECCBuffer[ 2] == 0xFF ) && ( nECCBuffer[ 3] == 0xFF ) &&
+					( nECCBuffer[ 4] == 0xFF ) && ( nECCBuffer[ 5] == 0xFF ) &&
+					( nECCBuffer[ 6] == 0xFF ) && ( nECCBuffer[ 7] == 0xFF ) &&
+					( nECCBuffer[ 8] == 0xFF ) && ( nECCBuffer[ 9] == 0xFF ) &&
+					( nECCBuffer[10] == 0xFF ) && ( nECCBuffer[11] == 0xFF ) &&
+					( nECCBuffer[12] == 0xFF ) && ( nECCBuffer[13] == 0xFF ) &&
+					( nECCBuffer[14] == 0xFF ) && ( nECCBuffer[15] == 0xFF ) &&
+					( nECCBuffer[16] == 0xFF ) && ( nECCBuffer[17] == 0xFF ) &&
+					( nECCBuffer[18] == 0xFF ) && ( nECCBuffer[19] == 0xFF ))
+				{
+					if ( nEccOnOff == ECC_ON )
+						NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+				}
+				else
+				{
+					if ( bAlignAddr == 0 )
+					{
+						res |= NAND_IO_CorrectionMLC12ForCB( pDataBuffer, nECCBuffer, 512, NAND_NORMAL_BUFFER );
+						pDataBuffer += 512;
+					}
+					else if ( bAlignAddr == 1 )
+					{
+						res |= NAND_IO_CorrectionMLC12ForCB( pDataBuffer, nECCBuffer, 512, NAND_SERIAL_CHAIN_BUFFER );
+						pDataBuffer += 1024;
+					}
+				}
+			}
+		}
+	}
+
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+
+	return res;
+
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      static __inline NAND_IO_ERROR NAND_IO_DecodeChainDataForGoldenPage( NAND_IO_DEVINFO *nDevInfo, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+*  
+*  DESCRIPTION : 
+*  
+*  INPUT:
+*			nDevInfo	= 
+*			nEccOnOff	= 
+*			nPageBuffer	= 
+*			nSpareBuffer	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+*  REMARK:	  by nemo
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_DecodeChainDataForGoldenPage( NAND_IO_DEVINFO *nDevInfo, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff )
+{
+	unsigned int		i;
+	unsigned char		*pPageB, *pSpareB;
+	unsigned char		*pDataBuffer,*pSpareBuffer;
+	unsigned char		*pDataBuffer2,*pSpareBuffer2;
+	DWORD_BYTE			uDWordByte;
+	NAND_IO_ERROR		res = (NAND_IO_ERROR)SUCCESS;
+	
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	//if ( nEccOnOff == ECC_OFF )
+	NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	res = (NAND_IO_ERROR)SUCCESS;
+	
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================	
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//=========================================================================
+	// Get Buffer Pointer
+	//=========================================================================
+	/* Adapt type of address */
+	pPageB		= (unsigned char*)nPageBuffer;
+	pSpareB		= (unsigned char*)nSpareBuffer;
+
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		pPageB	+= ( 528 * ( nDevInfo->PPages - 2 ));
+	else
+		pPageB	+= ( 528 * ( nDevInfo->PPages - 1 ));
+
+	/* Get Data Buffer */
+	pDataBuffer	 = (unsigned char*)pPageB;
+	pDataBuffer2 = pDataBuffer + 1;
+
+	/* Adapt type of address */
+	pSpareBuffer  = (unsigned char*)pSpareB;
+	pSpareBuffer2 = pSpareBuffer + 1;
+
+	//####################################################
+	//#	Dummy Write Page Data
+	//####################################################
+	if (!( pNFC->NFC_CTRL1 & Hw30 ))
+	{
+		/* Setup ECC Block */
+		if ( nEccOnOff == ECC_ON )
+		{
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&pNFC->NFC_LDATA );
+			#endif
+			pECC->ECC_CTRL	|= ( 256 << ECC_SHIFT_DATASIZE );		// Data Size...		
+			pECC->ECC_CLEAR	= 0x00000000;
+		}
+
+		/* Dummy Write */
+		BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
+		pNFC->NFC_DSIZE	= 256;
+		pNFC->NFC_IREQ = 0x77;	// pNFC->NFC_IREQ_FLAG1;		
+		pNFC->NFC_PSTART = 0;
+		
+		i = (64);
+		do {
+				while (!( pNFC->NFC_CTRL & HwNFC_CTRL_FS_RDY ));
+				uDWordByte.BYTE[0] = *pDataBuffer;++pDataBuffer;
+				uDWordByte.BYTE[1] = *pDataBuffer;++pDataBuffer;
+				uDWordByte.BYTE[2] = *pDataBuffer;++pDataBuffer;
+				uDWordByte.BYTE[3] = *pDataBuffer;++pDataBuffer;
+				pNFC->NFC_LDATA = uDWordByte.DWORD;
+		}while(--i);
+
+		while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));		
+	}
+	else
+	{
+		/* Setup ECC Block */
+		if ( nEccOnOff == ECC_ON )
+		{
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&NAND_IO_HwDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&pNFC->NFC_WDATA );
+			#endif
+			pECC->ECC_CTRL	|= ( 256 << ECC_SHIFT_DATASIZE );		// Data Size...		
+			pECC->ECC_CLEAR	= 0x00000000;
+		}
+
+		i = (64);
+		do {
+			uDWordByte.BYTE[0] = *pDataBuffer;++pDataBuffer;
+			uDWordByte.BYTE[1] = *pDataBuffer;++pDataBuffer;
+			uDWordByte.BYTE[2] = *pDataBuffer;++pDataBuffer;
+			uDWordByte.BYTE[3] = *pDataBuffer;++pDataBuffer;
+			pNFC->NFC_WDATA = uDWordByte.DWORD;
+		}while(--i);
+		
+	}
+
+	//####################################################
+	//####################################################
+
+	/* Check and Correct ECC code */
+	if ( nEccOnOff == ECC_ON )
+	{			
+		if ( nDevInfo->EccType == SLC_ECC_TYPE )
+		{
+			//===================================
+			// SLC ECC Correction
+			//===================================
+			res |= NAND_IO_CorrectionSLC( pPageB, pDataBuffer );
+
+			pDataBuffer += nDevInfo->EccDataSize;			
+		}	
+		else if ( nDevInfo->EccType == MLC_ECC_4BIT_TYPE )
+		{
+			//===================================
+			// 4 Bit MLC ECC Correction
+			//===================================
+			if (( pDataBuffer[0] == 0xFF ) && ( pDataBuffer[1] == 0xFF ) &&
+				( pDataBuffer[2] == 0xFF ) && ( pDataBuffer[3] == 0xFF ) &&
+				( pDataBuffer[4] == 0xFF ) && ( pDataBuffer[5] == 0xFF ) &&
+				( pDataBuffer[6] == 0xFF ) && ( pDataBuffer[7] == 0xFF ) &&
+				( pDataBuffer[8] == 0xFF ) && ( pDataBuffer[9] == 0xFF ))
+			{
+				pDataBuffer += nDevInfo->EccDataSize;
+
+				NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+				ASM_NOP;
+			}
+			else
+			{
+				res |= NAND_IO_CorrectionMLCForCB( pPageB, pDataBuffer, 256, NAND_NORMAL_BUFFER );
+
+				pDataBuffer += nDevInfo->EccDataSize;
+			}
+		}
+		else if ( nDevInfo->EccType == MLC_ECC_8BIT_TYPE )
+		{
+			//===================================
+			// 8 Bit MLC ECC Correction
+			//===================================
+			if (( pDataBuffer[ 0] == 0xFF ) && ( pDataBuffer[ 1] == 0xFF ) &&
+				( pDataBuffer[ 2] == 0xFF ) && ( pDataBuffer[ 3] == 0xFF ) &&
+				( pDataBuffer[ 4] == 0xFF ) && ( pDataBuffer[ 5] == 0xFF ) &&
+				( pDataBuffer[ 6] == 0xFF ) && ( pDataBuffer[ 7] == 0xFF ) &&
+				( pDataBuffer[ 8] == 0xFF ) && ( pDataBuffer[ 9] == 0xFF ) &&
+				( pDataBuffer[10] == 0xFF ) && ( pDataBuffer[11] == 0xFF ) &&
+				( pDataBuffer[12] == 0xFF ) && ( pDataBuffer[13] == 0xFF ) &&
+				( pDataBuffer[14] == 0xFF ) && ( pDataBuffer[15] == 0xFF ) &&
+				( pDataBuffer[16] == 0xFF ) && ( pDataBuffer[17] == 0xFF ) &&
+				( pDataBuffer[18] == 0xFF ) && ( pDataBuffer[19] == 0xFF ))
+			{
+				pDataBuffer += nDevInfo->EccDataSize;			
+
+				NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+						
+				ASM_NOP;
+			}
+			else
+			{
+				res |= NAND_IO_CorrectionMLC8ForCB( pPageB, pDataBuffer, 256, NAND_NORMAL_BUFFER );
+
+				pDataBuffer += nDevInfo->EccDataSize;			
+			}
+		}
+		else if ( nDevInfo->EccType == MLC_ECC_12BIT_TYPE )
+		{
+			//===================================
+			// 8 Bit MLC ECC Correction
+			//===================================
+			if (( pDataBuffer[ 0] == 0xFF ) && ( pDataBuffer[ 1] == 0xFF ) &&
+				( pDataBuffer[ 2] == 0xFF ) && ( pDataBuffer[ 3] == 0xFF ) &&
+				( pDataBuffer[ 4] == 0xFF ) && ( pDataBuffer[ 5] == 0xFF ) &&
+				( pDataBuffer[ 6] == 0xFF ) && ( pDataBuffer[ 7] == 0xFF ) &&
+				( pDataBuffer[ 8] == 0xFF ) && ( pDataBuffer[ 9] == 0xFF ) &&
+				( pDataBuffer[10] == 0xFF ) && ( pDataBuffer[11] == 0xFF ) &&
+				( pDataBuffer[12] == 0xFF ) && ( pDataBuffer[13] == 0xFF ) &&
+				( pDataBuffer[14] == 0xFF ) && ( pDataBuffer[15] == 0xFF ) &&
+				( pDataBuffer[16] == 0xFF ) && ( pDataBuffer[17] == 0xFF ) &&
+				( pDataBuffer[18] == 0xFF ) && ( pDataBuffer[19] == 0xFF ))
+			{
+				pDataBuffer += nDevInfo->EccDataSize;			
+
+				NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+						
+				ASM_NOP;
+			}
+			else
+			{
+				res |= NAND_IO_CorrectionMLC12ForCB( pPageB, pDataBuffer, 256, NAND_NORMAL_BUFFER );
+				pDataBuffer += nDevInfo->EccDataSize;			
+			}
+		}		
+	}
+	/* Disable ECC Block */
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	//####################################################
+	//#	Dummy Write Spare Data
+	//####################################################
+	/* Setup ECC Block */
+	if (!( pNFC->NFC_CTRL1 & Hw30 ))
+	{
+		if ( nEccOnOff == ECC_ON )
+		{
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&pNFC->NFC_LDATA );
+			#endif
+			pECC->ECC_CTRL	|= ( nDevInfo->Feature.SpareSize << ECC_SHIFT_DATASIZE );		// Data Size...		
+			pECC->ECC_CLEAR	= 0x00000000;
+		}
+
+		/* Dummy Write */
+		BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
+		pNFC->NFC_DSIZE	= nDevInfo->Feature.SpareSize;
+		pNFC->NFC_IREQ = 0x77;	// pNFC->NFC_IREQ_FLAG1;		
+		pNFC->NFC_PSTART = 0;
+		
+		i = ( nDevInfo->Feature.SpareSize >> 2 );
+		do {
+				while (!( pNFC->NFC_CTRL & HwNFC_CTRL_FS_RDY ));
+				
+				uDWordByte.BYTE[0] = *pSpareB;++pSpareB;
+				uDWordByte.BYTE[1] = *pSpareB;++pSpareB;
+				uDWordByte.BYTE[2] = *pSpareB;++pSpareB;
+				uDWordByte.BYTE[3] = *pSpareB;++pSpareB;
+				pNFC->NFC_LDATA	= uDWordByte.DWORD;
+		}while(--i);
+
+		while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));		
+	}
+	else
+	{
+		if ( nEccOnOff == ECC_ON )
+		{
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&NAND_IO_HwDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&pNFC->NFC_WDATA );
+			#endif
+			pECC->ECC_CTRL	|= ( nDevInfo->Feature.SpareSize << ECC_SHIFT_DATASIZE );		// Data Size...		
+			pECC->ECC_CLEAR	= 0x00000000;
+		}
+		
+		i =  ( nDevInfo->Feature.SpareSize >> 2 );
+		do {
+			uDWordByte.BYTE[0] = *pSpareB;++pSpareB;
+			uDWordByte.BYTE[1] = *pSpareB;++pSpareB;
+			uDWordByte.BYTE[2] = *pSpareB;++pSpareB;
+			uDWordByte.BYTE[3] = *pSpareB;++pSpareB;
+			pNFC->NFC_WDATA = uDWordByte.DWORD;
+		}while(--i);		
+	}
+
+	//####################################################
+	//####################################################
+
+	/* Check and Correct ECC code */
+	if ( nEccOnOff == ECC_ON )
+	{
+		if ( nDevInfo->EccType == SLC_ECC_TYPE )
+		{
+			//===================================
+			// SLC ECC Correction
+			//===================================
+			res |= NAND_IO_CorrectionSLC( nSpareBuffer, pPageB );
+		}
+		else if ( nDevInfo->EccType == MLC_ECC_4BIT_TYPE )
+		{
+			//===================================
+			// 4 Bit MLC ECC Correction
+			//===================================
+			if (( pDataBuffer[0] == 0xFF ) && ( pDataBuffer[1] == 0xFF ) &&
+				( pDataBuffer[2] == 0xFF ) && ( pDataBuffer[3] == 0xFF ) &&
+				( pDataBuffer[4] == 0xFF ) && ( pDataBuffer[5] == 0xFF ) &&
+				( pDataBuffer[6] == 0xFF ) && ( pDataBuffer[7] == 0xFF ) &&
+				( pDataBuffer[8] == 0xFF ) && ( pDataBuffer[9] == 0xFF ))
+			{
+				ASM_NOP;
+			}
+			else
+			{
+				res |= NAND_IO_CorrectionMLCForCB( nSpareBuffer, pDataBuffer, nDevInfo->Feature.SpareSize, NAND_NORMAL_BUFFER );
+			}
+		}
+		else if ( nDevInfo->EccType == MLC_ECC_8BIT_TYPE )
+		{
+			//===================================
+			// 8 Bit MLC ECC Correction
+			//===================================
+			if (( pDataBuffer[ 0] == 0xFF ) && ( pDataBuffer[ 1] == 0xFF ) &&
+				( pDataBuffer[ 2] == 0xFF ) && ( pDataBuffer[ 3] == 0xFF ) &&
+				( pDataBuffer[ 4] == 0xFF ) && ( pDataBuffer[ 5] == 0xFF ) &&
+				( pDataBuffer[ 6] == 0xFF ) && ( pDataBuffer[ 7] == 0xFF ) &&
+				( pDataBuffer[ 8] == 0xFF ) && ( pDataBuffer[ 9] == 0xFF ) &&
+				( pDataBuffer[10] == 0xFF ) && ( pDataBuffer[11] == 0xFF ) &&
+				( pDataBuffer[12] == 0xFF ) && ( pDataBuffer[13] == 0xFF ) &&
+				( pDataBuffer[14] == 0xFF ) && ( pDataBuffer[15] == 0xFF ) &&
+				( pDataBuffer[16] == 0xFF ) && ( pDataBuffer[17] == 0xFF ) &&
+				( pDataBuffer[18] == 0xFF ) && ( pDataBuffer[19] == 0xFF ))
+			{
+				ASM_NOP;
+			}
+			else
+			{
+				res |= NAND_IO_CorrectionMLC8ForCB( nSpareBuffer, pDataBuffer, nDevInfo->Feature.SpareSize, NAND_NORMAL_BUFFER );
+			}
+		}
+		else if ( nDevInfo->EccType == MLC_ECC_12BIT_TYPE )
+		{
+			//===================================
+			// 8 Bit MLC ECC Correction
+			//===================================
+			if (( pDataBuffer[ 0] == 0xFF ) && ( pDataBuffer[ 1] == 0xFF ) &&
+				( pDataBuffer[ 2] == 0xFF ) && ( pDataBuffer[ 3] == 0xFF ) &&
+				( pDataBuffer[ 4] == 0xFF ) && ( pDataBuffer[ 5] == 0xFF ) &&
+				( pDataBuffer[ 6] == 0xFF ) && ( pDataBuffer[ 7] == 0xFF ) &&
+				( pDataBuffer[ 8] == 0xFF ) && ( pDataBuffer[ 9] == 0xFF ) &&
+				( pDataBuffer[10] == 0xFF ) && ( pDataBuffer[11] == 0xFF ) &&
+				( pDataBuffer[12] == 0xFF ) && ( pDataBuffer[13] == 0xFF ) &&
+				( pDataBuffer[14] == 0xFF ) && ( pDataBuffer[15] == 0xFF ) &&
+				( pDataBuffer[16] == 0xFF ) && ( pDataBuffer[17] == 0xFF ) &&
+				( pDataBuffer[18] == 0xFF ) && ( pDataBuffer[19] == 0xFF ))
+			{
+				ASM_NOP;
+			}
+			else
+			{
+				res |= NAND_IO_CorrectionMLC12ForCB( nSpareBuffer, pDataBuffer, nDevInfo->Feature.SpareSize, NAND_NORMAL_BUFFER );
+			}
+		}
+	}
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+	/* Disable ECC Block */
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	return res;
+
+}
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_ReadSpareData( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nReadPPSize,
+*      													 U8 *nSpareBuffer );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nDevInfo	= 
+*			nReadPPSize	= 
+*			nSpareBuffer	= 
+*			nStartPPage	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_ReadSpareData( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nReadPPSize,
+													 U8 *nSpareBuffer )
+{
+	unsigned int		i,j;
+	unsigned char		*pSpareB;
+	DWORD_BYTE			uDWordByte;
+	NAND_IO_ERROR		res;
+	
+	if ( ( nStartPPage + nReadPPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+		
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	res = (NAND_IO_ERROR)SUCCESS;
+
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================	
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//=========================================================================
+	// Read Spare Data
+	//=========================================================================
+	pSpareB = (unsigned char*)nSpareBuffer;
+
+	//----------------------------------------------
+	//	Read Spare Data as 16Bytes repeatly
+	//----------------------------------------------		
+	for ( j = 0; j < nReadPPSize; ++j )
+	{
+		/* Read 512 Data Area */
+		if ( j != 0 )
+		{
+		    i = 128;
+		    do {
+			    uDWordByte.DWORD = pNFC->NFC_WDATA;
+		    } while(--i);
+		}
+
+		/* Read 16Bytes spare data */
+		i = 4;
+		do {
+			uDWordByte.DWORD = pNFC->NFC_WDATA;
+			*pSpareB = uDWordByte.BYTE[0];++pSpareB;
+			*pSpareB = uDWordByte.BYTE[1];++pSpareB;
+			*pSpareB = uDWordByte.BYTE[2];++pSpareB;
+			*pSpareB = uDWordByte.BYTE[3];++pSpareB;
+		}while(--i);
+	}
+
+	return res;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      static __inline NAND_IO_ERROR NAND_IO_ReadSpareDataECC( NAND_IO_DEVINFO *nDevInfo, U8 *nSpareBuffer, int nEccOnOff );
+*  
+*  DESCRIPTION : 
+*  
+*  INPUT:
+*			nDevInfo	= 
+*			nEccOnOff	= 
+*			nSpareBuffer	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+*  REMARK:	  by nemo
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_ReadSpareDataMTD( NAND_IO_DEVINFO *nDevInfo, U8 *nSpareBuffer, int nPageEccOnOff )
+{
+	unsigned int		i;
+	unsigned int		nSpareTotalSize;
+	unsigned int		nECCDataSize;
+	unsigned char		bAlignAddr;
+	unsigned char		*pSpareB = 0;
+	unsigned int		*pSpareDW = 0;
+	unsigned char		*pSpareBuffer;
+	DWORD_BYTE			uDWordByte;
+	NAND_IO_ERROR		res;
+
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	res = (NAND_IO_ERROR)SUCCESS;
+
+	nSpareTotalSize = 32;
+
+	//=========================================================================
+	// Check Align of PageBuffer Address
+	//=========================================================================
+	bAlignAddr = ( (unsigned int)nSpareBuffer & 3 ) ? 0 : 1;
+
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================	
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//=========================================================================
+	// Get Buffer Pointer
+	//=========================================================================
+	/* Adapt type of address */
+	if ( bAlignAddr )
+		pSpareDW	= (unsigned int*)nSpareBuffer;
+	else
+		pSpareB		= (unsigned char*)nSpareBuffer;
+
+	if ( nDevInfo->Feature.MediaType & A_SMALL )
+	{
+		//----------------------------------------------
+		//	Read Small Page Spare Data: 16Byte
+		//----------------------------------------------
+		i = 4;
+		
+		do {
+			if ( bAlignAddr )
+			{
+				*pSpareDW = pNFC->NFC_WDATA;++pSpareDW;
+			}	
+			else
+			{
+				uDWordByte.DWORD = pNFC->NFC_WDATA;
+				*pSpareB = uDWordByte.BYTE[0];++pSpareB;
+				*pSpareB = uDWordByte.BYTE[1];++pSpareB;
+				*pSpareB = uDWordByte.BYTE[2];++pSpareB;
+				*pSpareB = uDWordByte.BYTE[3];++pSpareB;
+			}
+		}while(--i);
+
+		if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		{
+			if ( nPageEccOnOff == PAGE_ECC_ON )
+			{
+				memset( gNAND_IO_ShareEccBuffer, 0xFF, 16 );
+				
+				//=========================================================================
+				// Check Align of PageBuffer Address
+				//=========================================================================
+				bAlignAddr = ( (unsigned int)&gNAND_IO_ShareEccBuffer & 3 ) ? 0 : 1;
+				
+				//=========================================================================
+				// Get Buffer Pointer
+				//=========================================================================
+				/* Adapt type of address */
+				if ( bAlignAddr )
+					pSpareDW	= (unsigned int*)&gNAND_IO_ShareEccBuffer[0];
+				else
+					pSpareB		= (unsigned char*)&gNAND_IO_ShareEccBuffer[0];
+				
+				//----------------------------------------------
+				//	Read Spare Data
+				//----------------------------------------------
+				i = 4;
+				do {
+					if ( bAlignAddr )
+					{
+						*pSpareDW = pNFC->NFC_WDATA;++pSpareDW;
+					}
+					else
+					{
+						uDWordByte.DWORD = pNFC->NFC_WDATA;
+						*pSpareB = uDWordByte.BYTE[0];++pSpareB;
+						*pSpareB = uDWordByte.BYTE[1];++pSpareB;
+						*pSpareB = uDWordByte.BYTE[2];++pSpareB;
+						*pSpareB = uDWordByte.BYTE[3];++pSpareB;
+					}
+				}while(--i);
+			}
+		}
+
+		return SUCCESS;
+	}
+
+	///* Setup ECC Block */
+	//#if defined(_WINCE_) || defined(_LINUX_)
+	//NAND_IO_SetupECC( ECC_ON, ECC_DECODE, MLC_ECC_4BIT_TYPE, NAND_MCU_ACCESS, (U32)&NAND_IO_HwDATA_PA );
+	//#else
+	//NAND_IO_SetupECC( ECC_ON, ECC_DECODE, MLC_ECC_4BIT_TYPE, NAND_MCU_ACCESS, (U32)&pNFC->NFC_WDATA );
+	//#endif
+	//pECC->ECC_CTRL	|= ( nSpareTotalSize << ECC_SHIFT_DATASIZE );
+	//pECC->ECC_CLEAR	= 0x00000000;		// Clear ECC Block
+	
+	/* Set Spare Buffer */
+	pSpareBuffer = ( bAlignAddr ) ? (unsigned char*)pSpareDW : (unsigned char*)pSpareB;
+
+	//----------------------------------------------
+	//	Read Spare Data
+	//----------------------------------------------
+	i = ( nSpareTotalSize >> 2 );
+	do {
+		if ( bAlignAddr )
+		{
+			*pSpareDW = pNFC->NFC_WDATA;++pSpareDW;
+		}	
+		else
+		{
+			uDWordByte.DWORD = pNFC->NFC_WDATA;
+			*pSpareB = uDWordByte.BYTE[0];++pSpareB;
+			*pSpareB = uDWordByte.BYTE[1];++pSpareB;
+			*pSpareB = uDWordByte.BYTE[2];++pSpareB;
+			*pSpareB = uDWordByte.BYTE[3];++pSpareB;
+		}
+	}while(--i);
+
+	/* Read 4Bit ECC data */
+	//nReadSize = 8;
+	//
+	///* Adapt type of address */
+	//pEccB = (unsigned char*)nECCBuffer;
+
+	//----------------------------------------------
+	// Read ECC Code
+	//----------------------------------------------
+	//while ( nReadSize )
+	//{
+	//	/* Read as DWORD */
+	//	if ( nReadSize >= 4 )
+	//	{
+	//		uDWordByte.DWORD = WORD_OF(pNFC->NFC_WDATA);
+	//		*pEccB = uDWordByte.BYTE[0];++pEccB;
+	//		*pEccB = uDWordByte.BYTE[1];++pEccB;
+	//		*pEccB = uDWordByte.BYTE[2];++pEccB;
+	//		*pEccB = uDWordByte.BYTE[3];++pEccB;
+	//		nReadSize -= 4;
+	//	}
+	//	/* Read as WORD */
+	//	else if ( nReadSize >= 2 )
+	//	{
+	//		*pEccB = (unsigned char)pNFC->NFC_SDATA; ++pEccB;
+	//		*pEccB = (unsigned char)pNFC->NFC_SDATA; ++pEccB;			
+	//		nReadSize -= 2;
+	//	}
+	//	/* Read as BYTE */
+	//	else
+	//	{
+	//		*pEccB = (unsigned char)pNFC->NFC_SDATA; ++pEccB;			
+	//		nReadSize -= 1;
+	//	}
+	//}
+	//
+	///* Check and Correct ECC code */
+	////===================================
+	//// 4 Bit MLC ECC Correction
+	////===================================
+	//if ( ( nECCBuffer[0] == 0x00 ) && ( nECCBuffer[1] == 0x00 ) &&
+	//	 ( nECCBuffer[2] == 0x00 ) && ( nECCBuffer[3] == 0x00 ) &&
+	//	 ( nECCBuffer[4] == 0x00 ) && ( nECCBuffer[5] == 0x00 ) &&
+	//	 ( nECCBuffer[6] == 0x00 ) && ( nECCBuffer[7] == 0x00 ))
+	//{
+	//	res |= NAND_IO_CorrectionMLC( MLC_ECC_4BIT_TYPE, pSpareBuffer, nECCBuffer, nSpareTotalSize );
+	// 	res |= ERR_NAND_IO_FAILED_CORRECTION_MLC_ECC;
+	//}
+	//else if ( ( nECCBuffer[0] == 0xFF ) && ( nECCBuffer[1] == 0xFF ) &&
+	//	 	  ( nECCBuffer[2] == 0xFF ) && ( nECCBuffer[3] == 0xFF ) &&
+	//	 	  ( nECCBuffer[4] == 0xFF ) && ( nECCBuffer[5] == 0xFF ) &&
+	//	 	  ( nECCBuffer[6] == 0xFF ) && ( nECCBuffer[7] == 0xFF ))
+ //	{
+	//	ASM_NOP;
+	//}
+	//else
+	//{
+	//	res |= NAND_IO_CorrectionMLC( MLC_ECC_4BIT_TYPE, pSpareBuffer, nECCBuffer, nSpareTotalSize );
+	//}
+
+	//=========================================================================
+	// Ecc Clear
+	//=========================================================================
+	//NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+	if ( nDevInfo->Feature.MediaType & A_MLC )
+		nECCDataSize = 8;
+	else if ( ( nDevInfo->Feature.MediaType & A_MLC_8BIT ) || ( nDevInfo->Feature.MediaType & A_MLC_12BIT ) )
+		nECCDataSize = 20;
+
+	if ( nPageEccOnOff == PAGE_ECC_ON )
+	{
+		memset( gNAND_IO_ShareEccBuffer, 0xFF, ( nECCDataSize << 2 ) );
+		
+		//=========================================================================
+		// Check Align of PageBuffer Address
+		//=========================================================================
+		bAlignAddr = ( (unsigned int)&gNAND_IO_ShareEccBuffer & 3 ) ? 0 : 1;
+		
+		//=========================================================================
+		// Get Buffer Pointer
+		//=========================================================================
+		/* Adapt type of address */
+		if ( bAlignAddr )
+			pSpareDW	= (unsigned int*)&gNAND_IO_ShareEccBuffer[0];
+		else
+			pSpareB		= (unsigned char*)&gNAND_IO_ShareEccBuffer[0];
+		
+		//----------------------------------------------
+		//	Read Spare Data
+		//----------------------------------------------
+		i = ( ( nECCDataSize << 2) >> 2 );
+		do {
+			if ( bAlignAddr )
+			{
+				*pSpareDW = pNFC->NFC_WDATA;++pSpareDW;
+			}	
+			else
+			{
+				uDWordByte.DWORD = pNFC->NFC_WDATA;
+				*pSpareB = uDWordByte.BYTE[0];++pSpareB;
+				*pSpareB = uDWordByte.BYTE[1];++pSpareB;
+				*pSpareB = uDWordByte.BYTE[2];++pSpareB;
+				*pSpareB = uDWordByte.BYTE[3];++pSpareB;
+			}
+		}while(--i);
+	}
+
+	return res;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      static __inline NAND_IO_ERROR NAND_IO_ReadSpareDataECC( NAND_IO_DEVINFO *nDevInfo, U8 *nSpareBuffer, int nEccOnOff );
+*  
+*  DESCRIPTION : 
+*  
+*  INPUT:
+*			nDevInfo	= 
+*			nEccOnOff	= 
+*			nSpareBuffer	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+*  REMARK:	  by nemo
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_ReadSpareDataECC( NAND_IO_DEVINFO *nDevInfo, U8 *nSpareBuffer, int nEccOnOff )
+{
+	unsigned int		i;
+	unsigned int		nReadSize;	
+	unsigned char		bAlignAddr;
+	unsigned char		*pSpareB = 0, *pEccB;
+	unsigned int		*pSpareDW = 0;
+	unsigned char		*pSpareBuffer;
+	#ifdef _LINUX_
+	unsigned char		nECCBuffer[30]__attribute__((aligned(8)));
+	#else
+	unsigned char		nECCBuffer[30];
+	#endif
+	DWORD_BYTE			uDWordByte;
+	NAND_IO_ERROR		res;
+
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	res = (NAND_IO_ERROR)SUCCESS;
+
+	//=========================================================================
+	// Check Align of PageBuffer Address
+	//=========================================================================
+	bAlignAddr = ( (unsigned int)nSpareBuffer & 3 ) ? 0 : 1;
+
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	// Clear Buffer
+	memset( nSpareBuffer, 0xFF, 16 );
+	memset( nECCBuffer, 0xFF, 30 );
+	
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================	
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//=========================================================================
+	// Get Buffer Pointer
+	//=========================================================================
+	/* Adapt type of address */
+	if ( bAlignAddr )
+		pSpareDW	= (unsigned int*)nSpareBuffer;
+	else
+		pSpareB		= (unsigned char*)nSpareBuffer;
+
+	/* Setup ECC Block */
+	if ( nEccOnOff == ECC_ON )
+	{
+		#if defined(_WINCE_) || defined(_LINUX_)
+		NAND_IO_SetupECC( ECC_ON, ECC_DECODE, MLC_ECC_4BIT_TYPE, NAND_MCU_ACCESS, (U32)&NAND_IO_HwDATA_PA );
+		#else
+		NAND_IO_SetupECC( ECC_ON, ECC_DECODE, MLC_ECC_4BIT_TYPE, NAND_MCU_ACCESS, (U32)&pNFC->NFC_WDATA );
+		#endif
+		pECC->ECC_CTRL	|= ( 12 << ECC_SHIFT_DATASIZE );
+		pECC->ECC_CLEAR	= 0x00000000;		// Clear ECC Block
+	}
+	
+	/* Set Spare Buffer */
+	pSpareBuffer = ( bAlignAddr ) ? (unsigned char*)pSpareDW : (unsigned char*)pSpareB;
+
+	//----------------------------------------------
+	//	Read Spare Data
+	//----------------------------------------------
+	i = 3;
+	do {
+		if ( bAlignAddr )
+		{
+			*pSpareDW = pNFC->NFC_WDATA;++pSpareDW;
+		}	
+		else
+		{
+			uDWordByte.DWORD = pNFC->NFC_WDATA;
+			*pSpareB = uDWordByte.BYTE[0];++pSpareB;
+			*pSpareB = uDWordByte.BYTE[1];++pSpareB;
+			*pSpareB = uDWordByte.BYTE[2];++pSpareB;
+			*pSpareB = uDWordByte.BYTE[3];++pSpareB;
+		}
+	}while(--i);
+
+	/* Read 4Bit ECC data */
+	nReadSize = 10;
+	
+	/* Adapt type of address */
+	pEccB = (unsigned char*)nECCBuffer;
+
+	if ( nEccOnOff == ECC_ON )
+	{	
+		//----------------------------------------------
+		// Read ECC Code
+		//----------------------------------------------
+		while ( nReadSize )
+		{
+			/* Read as DWORD */
+			if ( nReadSize >= 4 )
+			{
+				uDWordByte.DWORD = WORD_OF(pNFC->NFC_WDATA);
+				*pEccB = uDWordByte.BYTE[0];++pEccB;
+				*pEccB = uDWordByte.BYTE[1];++pEccB;
+				*pEccB = uDWordByte.BYTE[2];++pEccB;
+				*pEccB = uDWordByte.BYTE[3];++pEccB;
+				nReadSize -= 4;
+			}
+			/* Read as WORD */
+			else if ( nReadSize >= 2 )
+			{
+				*pEccB = (unsigned char)pNFC->NFC_SDATA; ++pEccB;
+				*pEccB = (unsigned char)pNFC->NFC_SDATA; ++pEccB;			
+				nReadSize -= 2;
+			}
+			/* Read as BYTE */
+			else
+			{
+				*pEccB = (unsigned char)pNFC->NFC_SDATA; ++pEccB;			
+				nReadSize -= 1;
+			}
+		}
+
+		/* Check and Correct ECC code */
+		if ( nEccOnOff == ECC_ON )
+		{
+			//===================================
+			// 4 Bit MLC ECC Correction
+			//===================================
+			if ( ( nECCBuffer[0] == 0x00 ) && ( nECCBuffer[1] == 0x00 ) &&
+				 ( nECCBuffer[2] == 0x00 ) && ( nECCBuffer[3] == 0x00 ) &&
+				 ( nECCBuffer[4] == 0x00 ) && ( nECCBuffer[5] == 0x00 ) &&
+				 ( nECCBuffer[6] == 0x00 ) && ( nECCBuffer[7] == 0x00 ) &&
+				 ( nECCBuffer[8] == 0x00 ) && ( nECCBuffer[9] == 0x00 ))
+			{
+				res |= NAND_IO_CorrectionMLC( MLC_ECC_4BIT_TYPE, pSpareBuffer, nECCBuffer, 12 );
+			 	res |= ERR_NAND_IO_FAILED_CORRECTION_MLC_ECC;
+			}
+			else
+			{
+				res |= NAND_IO_CorrectionMLC( MLC_ECC_4BIT_TYPE, pSpareBuffer, nECCBuffer, 12 );
+			}
+		}
+	}
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	res = (NAND_IO_ERROR)SUCCESS;	// ECC Error Check Pass.
+	return res;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_Read512DataDoubleBuf( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nReadPPSize,
+*      												   			   U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nDevInfo	= 
+*			nEccOnOff	= 
+*			nPageBuffer	= 
+*			nReadPPSize	= 
+*			nSpareBuffer	= 
+*			nStartPPage	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_Read512DataDoubleBuf( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nReadPPSize,
+												   			U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff, int nSpareOnOff )
+{
+	unsigned int		i, j;
+	unsigned char		bAlignAddr;
+	unsigned char		*pPageB = 0, *pSpareB, *pEccB;
+	unsigned int		*pPageDW = 0, *pSpareDW;
+	unsigned char		*pDataBuffer;
+
+	unsigned char		*pPrDataBuffer;
+
+	#ifdef _LINUX_
+	unsigned char		nECCBuffer[30]__attribute__((aligned(8)));
+	#else
+	unsigned char		nECCBuffer[30];
+	#endif
+	DWORD_BYTE			uDWordByte;
+	NAND_IO_ERROR		res = (NAND_IO_ERROR)SUCCESS;
+	
+	if ( ( nStartPPage + nReadPPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	#ifdef READ_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw6);
+	#endif /* READ_SPEED_CHECK */
+
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	res = (NAND_IO_ERROR)SUCCESS;
+	nSpareOnOff = TNFTL_READ_SPARE_ON;
+
+	//=========================================================================
+	// Check Align of PageBuffer Address
+	//=========================================================================
+	bAlignAddr = ( (unsigned int)nPageBuffer & 3 ) ? 0 : 1;
+
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================	
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	#ifdef READ_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw6);	//----------------------->> ECC Setup
+	#endif /* READ_SPEED_CHECK */
+
+	//=========================================================================
+	// Get Buffer Pointer
+	//=========================================================================
+	/* Adapt type of address */
+	if ( bAlignAddr )
+	{
+		pPageDW		= (unsigned int*)nPageBuffer;
+		pSpareDW	= (unsigned int*)nSpareBuffer;
+	}
+	else
+	{
+		pPageB		= (unsigned char*)nPageBuffer;
+		pSpareB		= (unsigned char*)nSpareBuffer;
+	}
+	
+	//----------------------------------------------
+	//	Read Data as 512Bytes repeatly
+	//----------------------------------------------
+	for ( j = 0; j < nReadPPSize; ++j )
+	{
+		/* Set Data Buffer */
+		pDataBuffer = ( bAlignAddr ) ? (unsigned char*)pPageDW : (unsigned char*)pPageB;
+
+		//####################################################
+		//#	Read 512 Page Data
+		//####################################################
+		//----------------------------------------------
+		//	MCU ACCESS
+		//----------------------------------------------
+		#if defined( NAND_IO_USE_MCU_ACCESS )
+		/* Setup ECC Block */
+		if ( nEccOnOff == ECC_ON )
+		{
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&NAND_IO_HwDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&pNFC->NFC_WDATA );
+			#endif
+			pECC->ECC_CTRL		|= ( 512 << ECC_SHIFT_DATASIZE );
+			pECC->ECC_CLEAR	 = 0x00000000;			/* Clear ECC Block		*/
+		}
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw5);
+		#endif
+
+		/* Read 512 Data Area */
+		i = 128;
+		do {
+			if ( bAlignAddr )
+			{
+				*pPageDW = pNFC->NFC_WDATA;++pPageDW;
+			}
+			else
+			{
+				uDWordByte.DWORD = pNFC->NFC_WDATA;
+				*pPageB = uDWordByte.BYTE[0];++pPageB;
+				*pPageB = uDWordByte.BYTE[1];++pPageB;
+				*pPageB = uDWordByte.BYTE[2];++pPageB;
+				*pPageB = uDWordByte.BYTE[3];++pPageB;
+			}
+		}while(--i);
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw5);
+		#endif
+		//----------------------------------------------
+		//	DMA ACCESS
+		//----------------------------------------------
+		#elif defined( NAND_IO_USE_DMA_ACCESS )		
+		/* Setup ECC Block */
+		if ( nEccOnOff == ECC_ON )
+		{
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&pNFC->NFC_LDATA );
+			#endif
+			pECC->ECC_CTRL		|= ( 512 << ECC_SHIFT_DATASIZE );
+			pECC->ECC_CLEAR	 	= 0x00000000;			/* Clear ECC Block		*/
+		}
+		
+		/* Disable DMA Ahead */
+		/* Start DMA on NFC BUS */
+		NAND_IO_SetupDMADoubleBuf( NAND_IO_DMA_READ, j );
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw6);
+		#endif
+
+		pNFC->NFC_RSTART	= 0;
+		
+		if ( j != 0 )
+		{
+			if ( j & 1 )
+				memcpy( pPrDataBuffer, gpDMA_WorkBuffer1, 512 );
+			else
+				memcpy( pPrDataBuffer, gpDMA_WorkBuffer0, 512 );
+		}
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw6);
+		#endif
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw5);
+		#endif
+		while ( ISZERO(pNFC->NFC_IREQ, HwNFC_IREQ_FLAG0) );
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw5);
+		#endif
+
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw4);
+		#endif		
+		if ( j == ( nReadPPSize - 1 ) )
+		{
+			if ( j & 1 )
+				memcpy( pDataBuffer, gpDMA_WorkBuffer0, 512 );
+			else
+				memcpy( pDataBuffer, gpDMA_WorkBuffer1, 512 );
+		}
+		else
+		{
+			pPrDataBuffer = pDataBuffer;	// Buffer Pointer Backup
+
+			if ( j & 1 )
+				pDataBuffer =(unsigned char *)gpDMA_WorkBuffer0;			
+			else
+				pDataBuffer =(unsigned char *)gpDMA_WorkBuffer1;
+		}
+		
+		if ( bAlignAddr )
+			pPageDW += 128;
+		else
+			pPageB += 512;
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw4);
+		#endif
+		
+		#endif
+		//####################################################
+		//####################################################
+
+		/* Read 'n'Bytes ECC data */
+		i  = nDevInfo->EccDataSize;
+
+		// Clear ECC Buffer
+		memset( nECCBuffer, 0xFF, 30 );
+		
+		/* Adapt type of address */
+		pEccB = (unsigned char*)nECCBuffer;
+
+		while ( i )
+		{
+			/* Read as DWORD */
+			if ( i >= 4 )
+			{
+				uDWordByte.DWORD = WORD_OF(pNFC->NFC_WDATA);
+				*pEccB = uDWordByte.BYTE[0];++pEccB;
+				*pEccB = uDWordByte.BYTE[1];++pEccB;
+				*pEccB = uDWordByte.BYTE[2];++pEccB;
+				*pEccB = uDWordByte.BYTE[3];++pEccB;
+				i -= 4;
+			}
+			/* Read as WORD */
+			else if ( i >= 2 )
+			{
+				*pEccB = (unsigned char)pNFC->NFC_SDATA; ++pEccB;
+				*pEccB = (unsigned char)pNFC->NFC_SDATA; ++pEccB;			
+				i -= 2;
+			}
+			/* Read as BYTE */
+			else
+			{
+				*pEccB = (unsigned char)pNFC->NFC_SDATA; ++pEccB;			
+				i -= 1;
+			}
+		}
+
+		/* Check and Correct ECC code */
+		if ( nEccOnOff == ECC_ON )
+		{
+			if ( nDevInfo->EccType == SLC_ECC_TYPE )
+			{
+				//===================================
+				// SLC ECC Correction
+				//===================================				
+				res |= NAND_IO_CorrectionSLC( pDataBuffer, nECCBuffer );
+			}
+			else
+			{
+				res |= NAND_IO_CorrectionMLC( nDevInfo->EccType, pDataBuffer, nECCBuffer, 512 );
+			}
+		}
+
+		
+	}
+
+	if ( ( nStartPPage + nReadPPSize ) == ( nDevInfo->PPages ) )
+	//if ( nSpareOnOff == TNFTL_READ_SPARE_ON )
+	{
+		//=========================================================================
+		// Read Spare
+		//=========================================================================
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw6);
+		#endif
+
+		res |= NAND_IO_ReadSpareDataECC( nDevInfo, nSpareBuffer, nEccOnOff );
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw6);
+		#endif
+
+	}
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	return res;
+
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_Read528Data( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nReadPPSize,
+*      												   U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nDevInfo	= 
+*			nEccOnOff	= 
+*			nPageBuffer	= 
+*			nReadPPSize	= 
+*			nSpareBuffer	= 
+*			nStartPPage	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_Read512Data( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nReadPPSize,
+												   U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff, int nSpareOnOff )
+{
+	unsigned int		i, j;
+	unsigned char		bAlignAddr;
+	unsigned char		*pPageB = 0, *pSpareB, *pEccB;
+	unsigned int		*pPageDW = 0, *pSpareDW;
+	unsigned char		*pDataBuffer;
+	#ifdef _LINUX_
+	unsigned char		nECCBuffer[30]__attribute__((aligned(8)));
+	#else
+	unsigned char		nECCBuffer[30];
+	#endif
+	DWORD_BYTE			uDWordByte;
+	NAND_IO_ERROR		res = (NAND_IO_ERROR)SUCCESS;
+	
+	if ( ( nStartPPage + nReadPPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	#ifdef READ_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw6);
+	#endif /* READ_SPEED_CHECK */
+
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	res = (NAND_IO_ERROR)SUCCESS;
+	nSpareOnOff = TNFTL_READ_SPARE_ON;
+
+	//=========================================================================
+	// Check Align of PageBuffer Address
+	//=========================================================================
+	bAlignAddr = ( (unsigned int)nPageBuffer & 3 ) ? 0 : 1;
+
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================	
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	#ifdef READ_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw6);	//----------------------->> ECC Setup
+	#endif /* READ_SPEED_CHECK */
+
+	//=========================================================================
+	// Get Buffer Pointer
+	//=========================================================================
+	/* Adapt type of address */
+	if ( bAlignAddr )
+	{
+		pPageDW		= (unsigned int*)nPageBuffer;
+		pSpareDW	= (unsigned int*)nSpareBuffer;
+	}
+	else
+	{
+		pPageB		= (unsigned char*)nPageBuffer;
+		pSpareB		= (unsigned char*)nSpareBuffer;
+	}
+	
+	//----------------------------------------------
+	//	Read Data as 512Bytes repeatly
+	//----------------------------------------------
+	for ( j = 0; j < nReadPPSize; ++j )
+	{
+		/* Set Data Buffer */
+		pDataBuffer = ( bAlignAddr ) ? (unsigned char*)pPageDW : (unsigned char*)pPageB;
+
+		//####################################################
+		//#	Read 512 Page Data
+		//####################################################
+		//----------------------------------------------
+		//	MCU ACCESS
+		//----------------------------------------------
+		#if defined( NAND_IO_USE_MCU_ACCESS )
+		/* Setup ECC Block */
+		if ( nEccOnOff == ECC_ON )
+		{
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&NAND_IO_HwDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&pNFC->NFC_WDATA );
+			#endif
+			pECC->ECC_CTRL		|= ( 512 << ECC_SHIFT_DATASIZE );
+			pECC->ECC_CLEAR	 = 0x00000000;			/* Clear ECC Block		*/
+		}
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw5);
+		#endif
+
+		/* Read 512 Data Area */
+		i = 128;
+		do {
+			if ( bAlignAddr )
+			{
+				*pPageDW = pNFC->NFC_WDATA;++pPageDW;
+			}
+			else
+			{
+				uDWordByte.DWORD = pNFC->NFC_WDATA;
+				*pPageB = uDWordByte.BYTE[0];++pPageB;
+				*pPageB = uDWordByte.BYTE[1];++pPageB;
+				*pPageB = uDWordByte.BYTE[2];++pPageB;
+				*pPageB = uDWordByte.BYTE[3];++pPageB;
+			}
+		}while(--i);
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw5);
+		#endif
+		//----------------------------------------------
+		//	DMA ACCESS
+		//----------------------------------------------
+		#elif defined( NAND_IO_USE_DMA_ACCESS )		
+		/* Setup ECC Block */
+		if ( nEccOnOff == ECC_ON )
+		{
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&pNFC->NFC_LDATA );
+			#endif
+			pECC->ECC_CTRL		|= ( 512 << ECC_SHIFT_DATASIZE );
+			pECC->ECC_CLEAR	 = 0x00000000;			/* Clear ECC Block		*/
+		}
+		
+		/* Disable DMA Ahead */
+		/* Start DMA on NFC BUS */
+		#if defined(_LINUX_) || defined(_WINCE_)
+		NAND_IO_SetupDMA( (void*)&NAND_IO_HwLDATA_PA, 0, 0,
+						  (void*)pDataBuffer, 4, 0,
+						  NAND_IO_DMA_READ, 512 );
+		#else
+		NAND_IO_SetupDMA( (void*)&pNFC->NFC_LDATA, 0, 0,
+						  (void*)pDataBuffer, 4, 0,
+						  NAND_IO_DMA_READ, 512 );
+		#endif
+
+		if ( bAlignAddr )
+			pPageDW += 128;
+		else
+			pPageB += 512;
+		#endif
+		//####################################################
+		//####################################################
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw4);
+		#endif
+
+		/* Read 'n'Bytes ECC data */
+		i  = nDevInfo->EccDataSize;
+
+		// Clear ECC Buffer
+		memset( nECCBuffer, 0xFF, 30 );
+		
+		/* Adapt type of address */
+		pEccB = (unsigned char*)nECCBuffer;
+
+		while ( i )
+		{
+			/* Read as DWORD */
+			if ( i >= 4 )
+			{
+				uDWordByte.DWORD = WORD_OF(pNFC->NFC_WDATA);
+				*pEccB = uDWordByte.BYTE[0];++pEccB;
+				*pEccB = uDWordByte.BYTE[1];++pEccB;
+				*pEccB = uDWordByte.BYTE[2];++pEccB;
+				*pEccB = uDWordByte.BYTE[3];++pEccB;
+				i -= 4;
+			}
+			/* Read as WORD */
+			else if ( i >= 2 )
+			{
+				*pEccB = (unsigned char)pNFC->NFC_SDATA; ++pEccB;
+				*pEccB = (unsigned char)pNFC->NFC_SDATA; ++pEccB;			
+				i -= 2;
+			}
+			/* Read as BYTE */
+			else
+			{
+				*pEccB = (unsigned char)pNFC->NFC_SDATA; ++pEccB;			
+				i -= 1;
+			}
+		}
+
+		/* Check and Correct ECC code */
+		if ( nEccOnOff == ECC_ON )
+		{
+			if ( nDevInfo->EccType == SLC_ECC_TYPE )
+			{
+				//===================================
+				// SLC ECC Correction
+				//===================================				
+				res |= NAND_IO_CorrectionSLC( pDataBuffer, nECCBuffer );
+			}
+			else
+			{
+				res |= NAND_IO_CorrectionMLC( nDevInfo->EccType, pDataBuffer, nECCBuffer, 512 );
+			}
+		}
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw4);		//--------------------------------->> ECC Correction
+		#endif		
+	}
+
+	if ( ( nStartPPage + nReadPPSize ) == ( nDevInfo->PPages ) )
+	//if ( nSpareOnOff == TNFTL_READ_SPARE_ON )
+	{
+		//=========================================================================
+		// Read Spare
+		//=========================================================================
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw6);
+		#endif
+
+		res |= NAND_IO_ReadSpareDataECC( nDevInfo, nSpareBuffer, nEccOnOff );
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw6);
+		#endif
+
+	}
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	return res;
+
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_Read528Data( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nReadPPSize,
+*      												   U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nDevInfo	= 
+*			nEccOnOff	= 
+*			nPageBuffer	= 
+*			nReadPPSize	= 
+*			nSpareBuffer	= 
+*			nStartPPage	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_Read528Data( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nReadPPSize,
+												   U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff )
+{
+	unsigned int		i, j;
+	unsigned char		bAlignAddr;
+	unsigned char		*pPageB = 0, *pSpareB = 0;
+	unsigned int		*pPageDW = 0, *pSpareDW = 0;
+	unsigned char		*pDataBuffer, *pSpareBuffer;
+	DWORD_BYTE			uDWordByte;
+	NAND_IO_ERROR		res;
+	
+	if ( ( nStartPPage + nReadPPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+		
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	res = (NAND_IO_ERROR)SUCCESS;
+
+	//=========================================================================
+	// Check Align of PageBuffer Address
+	//=========================================================================
+	bAlignAddr = ( (unsigned int)nPageBuffer & 3 ) ? 0 : 1;
+	
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================	
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+	//=========================================================================
+	// Read Data as 512+16Bytes
+	//=========================================================================
+	/* Adapt type of address */
+	if ( bAlignAddr )
+	{
+		pPageDW		= (unsigned int*)nPageBuffer;
+		pSpareDW	= (unsigned int*)nSpareBuffer;
+	}	
+	else
+	{
+		pPageB		= (unsigned char*)nPageBuffer;
+		pSpareB		= (unsigned char*)nSpareBuffer;
+	}	
+
+	//----------------------------------------------
+	//	Read Data as 512Bytes repeatly
+	//----------------------------------------------		
+	for ( j = 0; j < nReadPPSize; ++j )
+	{
+		/* Set Data Buffer */
+		pDataBuffer = ( bAlignAddr ) ? (unsigned char*)pPageDW : (unsigned char*)pPageB;
+
+		//####################################################
+		//#	Read 512 Page Data
+		//####################################################
+		//----------------------------------------------
+		//	MCU ACCESS
+		//----------------------------------------------
+		#if defined( NAND_IO_USE_MCU_ACCESS )
+
+		if ( nEccOnOff == ECC_ON )
+		{
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&NAND_IO_HwDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&pNFC->NFC_WDATA );
+			#endif
+			pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );
+			pECC->ECC_CLEAR	= 0x00000000;		// Clear ECC Block
+		}
+		
+		/* Read 512 Data Area */
+		i = 128;
+		do {
+			if ( bAlignAddr )
+			{
+				*pPageDW = pNFC->NFC_WDATA;++pPageDW;
+			}	
+			else
+			{
+				uDWordByte.DWORD = pNFC->NFC_WDATA;
+				*pPageB = uDWordByte.BYTE[0];++pPageB;
+				*pPageB = uDWordByte.BYTE[1];++pPageB;
+				*pPageB = uDWordByte.BYTE[2];++pPageB;
+				*pPageB = uDWordByte.BYTE[3];++pPageB;
+			}
+		}while(--i);
+		//----------------------------------------------
+		//	DMA ACCESS
+		//----------------------------------------------
+		#elif defined( NAND_IO_USE_DMA_ACCESS )
+
+		if ( nEccOnOff == ECC_ON )
+		{
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&pNFC->NFC_LDATA );
+			#endif
+			pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );
+			pECC->ECC_CLEAR	= 0x00000000;		// Clear ECC Block
+		}
+
+		/* Disable DMA Ahead */
+		//IO_DMA_SetCTRL( IO_DMA_CH2, 0 );
+		//IO_INT_HwICLR = IO_INT_HwDMA_CH2;
+
+		/* Start DMA on NFC BUS */
+		#if defined(_LINUX_) || defined(_WINCE_)
+		NAND_IO_SetupDMA( (void*)&NAND_IO_HwLDATA_PA, 0, 0,
+						  (void*)pDataBuffer, 4, 0,
+						  NAND_IO_DMA_READ, 512 );
+		#else
+		NAND_IO_SetupDMA( (void*)&pNFC->NFC_LDATA, 0, 0,
+						  (void*)pDataBuffer, 4, 0,
+						  NAND_IO_DMA_READ, 512 );
+		#endif
+
+		//if ( ISZERO(pDataBuffer,3) ) {
+		//	#if defined(_WINCE_)
+		//		memcpy( pDataBuffer, (void*)IO_NFC_BUFFER0_BASE, 512 );
+		//	#elif defined(_LINUX_)
+		//		#ifndef KERNEL_DRIVER
+		//	    memcpy(pDataBuffer, (void*)IO_NFC_BUFFER0_BASE, 512);
+		//	    #else
+		//	    memcpy(pDataBuffer, virtadr, 512);
+		//		#endif
+		//	#else
+		//	fmemcpy16( pDataBuffer, (void*)IO_NFC_BUFFER0_BASE, 512 );
+		//	#endif
+		//} else {
+		//	#if defined(_WINCE_)
+		//		memcpy( pDataBuffer, (void*)IO_NFC_BUFFER0_BASE, 512 );
+		//	#elif defined(_LINUX_)
+		//	    #ifndef KERNEL_DRIVER
+		//	    memcpy(pDataBuffer, (void*)IO_NFC_BUFFER0_BASE, 512);
+		//	    #else
+		//	    memcpy(pDataBuffer, virtadr, 512);
+		//	    #endif
+		//	#else
+		//	memcpy( pDataBuffer, (void*)IO_NFC_BUFFER0_BASE, 512 );
+		//	#endif
+		//}
+
+		if ( bAlignAddr )
+			pPageDW += 128;
+		else
+			pPageB += 512;
+			
+		#endif
+		//####################################################
+		//####################################################
+
+		/* Set Spare Buffer */
+		pSpareBuffer = ( bAlignAddr ) ? (unsigned char*)pSpareDW : (unsigned char*)pSpareB;
+
+		/* Read 16Bytes spare data */
+		i = 4;
+		do {
+			if ( bAlignAddr )
+			{
+				*pSpareDW = pNFC->NFC_WDATA;++pSpareDW;
+			}	
+			else
+			{
+				uDWordByte.DWORD = pNFC->NFC_WDATA;
+				*pSpareB = uDWordByte.BYTE[0];++pSpareB;
+				*pSpareB = uDWordByte.BYTE[1];++pSpareB;
+				*pSpareB = uDWordByte.BYTE[2];++pSpareB;
+				*pSpareB = uDWordByte.BYTE[3];++pSpareB;
+			}
+		}while(--i);
+
+		/* Check and Correct ECC code */
+		if ( nEccOnOff == ECC_ON )
+		{
+			//----------------------------------------------------------------------
+			//	0	1	2	3	4		5	6	7	8	9	10	11	12	13	14	15	
+			//----------------------------------------------------------------------
+			//	MLC ECC	Block	Block	BSA	BAA		SLC ECC Area 0	SLC ECC Area 1
+			//	[0:1] 	Param	Type		[0:1]	MLC ECC [2:5]	MLC ECC [6:9]
+			//----------------------------------------------------------------------
+			if ( nDevInfo->EccType == SLC_ECC_TYPE )
+			{
+				res |= NAND_IO_CorrectionSLCForNB( pDataBuffer, pSpareBuffer );
+			}	
+			else if ( nDevInfo->EccType == MLC_ECC_4BIT_TYPE )
+			{
+				if (( pSpareBuffer[ 0] == 0xFF ) && ( pSpareBuffer[ 1] == 0xFF ) &&
+					( pSpareBuffer[ 8] == 0xFF ) && ( pSpareBuffer[ 9] == 0xFF ) &&
+					( pSpareBuffer[10] == 0xFF ) && ( pSpareBuffer[11] == 0xFF ) &&
+					( pSpareBuffer[12] == 0xFF ) && ( pSpareBuffer[13] == 0xFF ) &&
+					( pSpareBuffer[14] == 0xFF ) && ( pSpareBuffer[15] == 0xFF ))
+				{
+					if ( nEccOnOff == ECC_ON )
+						NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+				}
+				else if ( ( pSpareBuffer[ 0] == 0x00 ) &&( pSpareBuffer[ 1] == 0x00 ) &&
+						  ( pSpareBuffer[ 2] == 0x00 ) &&( pSpareBuffer[ 3] == 0x00 ) &&
+						  ( pSpareBuffer[ 4] == 0x00 ) &&( pSpareBuffer[ 5] == 0x00 ) &&
+						  ( pSpareBuffer[ 6] == 0x00 ) &&( pSpareBuffer[ 7] == 0x00 ) &&
+						  ( pSpareBuffer[ 8] == 0x00 ) &&( pSpareBuffer[ 9] == 0x00 ) &&
+						  ( pSpareBuffer[10] == 0x00 ) &&( pSpareBuffer[11] == 0x00 ) &&
+						  ( pSpareBuffer[12] == 0x00 ) &&( pSpareBuffer[13] == 0x00 ) &&
+						  ( pSpareBuffer[14] == 0x00 ) &&( pSpareBuffer[15] == 0x00 ))
+				{
+				 	res |= ERR_NAND_IO_FAILED_CORRECTION_MLC_ECC;					
+				}				
+				else
+				{
+					res |= NAND_IO_CorrectionMLCForNB( pDataBuffer, pSpareBuffer );
+				}
+			}
+		}
+	}
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	return res;
+
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_Read512DataMTD( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nReadPPSize,
+*      												   U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nDevInfo	= 
+*			nEccOnOff	= 
+*			nPageBuffer	= 
+*			nReadPPSize	= 
+*			nSpareBuffer	= 
+*			nStartPPage	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_Read512DataMTD( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nReadPPSize,
+												  	 U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff, int nSpareOnOff )
+{
+	unsigned int		i, j;
+	unsigned char		bAlignAddr;
+	unsigned int		nECCDataSize;
+	unsigned char		*pPageB = 0, *pSpareB;
+	unsigned int		*pPageDW = 0, *pSpareDW;
+	unsigned char		*pDataBuffer, *pSpareBuffer;
+	DWORD_BYTE			uDWordByte;
+	NAND_IO_ERROR		res = (NAND_IO_ERROR)SUCCESS;
+	
+	if ( ( nStartPPage + nReadPPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	res = (NAND_IO_ERROR)SUCCESS;
+	nSpareOnOff = TNFTL_READ_SPARE_ON;
+
+	//=========================================================================
+	// Check Align of PageBuffer Address
+	//=========================================================================
+	bAlignAddr = ( (unsigned int)nPageBuffer & 3 ) ? 0 : 1;
+
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================	
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	if ( nDevInfo->Feature.MediaType & A_MLC )
+		nECCDataSize = 8;
+	else if ( ( nDevInfo->Feature.MediaType & A_MLC_8BIT ) || ( nDevInfo->Feature.MediaType & A_MLC_12BIT ) )
+		nECCDataSize = 20;
+	
+	//=========================================================================
+	// Get Buffer Pointer
+	//=========================================================================
+	/* Adapt type of address */
+	if ( bAlignAddr )
+	{
+		pPageDW		= (unsigned int*)nPageBuffer;
+		pSpareDW	= (unsigned int*)nSpareBuffer;		
+	}
+	else
+	{
+		pPageB		= (unsigned char*)nPageBuffer;
+		pSpareB		= (unsigned char*)nSpareBuffer;
+	}
+
+	// Set SpareBuffer Pointer =>> ECCBuffer
+	if ( ( nDevInfo->Feature.MediaType  & A_BIG ) || (( nDevInfo->Feature.MediaType  & A_SMALL ) && ( nDevInfo->Feature.MediaType  & A_PARALLEL )))
+	{
+		//pSpareB	= (unsigned char*)nSpareBuffer;
+		//pSpareB += NAND_IO_SPARE_SIZE_BIG;
+		
+		pSpareB		= (unsigned char*)&gNAND_IO_ShareEccBuffer[0];
+		
+		//=========================================================================
+		// Empty Page ECCBuffer Pointer Increment
+		//=========================================================================
+		for ( j = 0; j < nStartPPage; ++j )
+			pSpareB += nECCDataSize;
+	}
+	
+	//----------------------------------------------
+	//	Read Data as 512Bytes repeatly
+	//----------------------------------------------
+	for ( j = 0; j < nReadPPSize; ++j )
+	{
+		/* Set Data Buffer */
+		pDataBuffer = ( bAlignAddr ) ? (unsigned char*)pPageDW : (unsigned char*)pPageB;
+
+		//####################################################
+		//#	Read 512 Page Data
+		//####################################################
+		//----------------------------------------------
+		//	MCU ACCESS
+		//----------------------------------------------
+		#if defined( NAND_IO_USE_MCU_ACCESS )
+		/* Setup ECC Block */
+		if ( nEccOnOff == ECC_ON )
+		{
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&NAND_IO_HwDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&pNFC->NFC_WDATA );
+			#endif
+			pECC->ECC_CTRL		|= ( 512 << ECC_SHIFT_DATASIZE );
+			pECC->ECC_CLEAR  = 0x00000000;					// Clear ECC Block
+		}
+
+		/* Read 512 Data Area */
+		i = 128;
+		do {
+			if ( bAlignAddr )
+			{
+				*pPageDW = pNFC->NFC_WDATA;++pPageDW;
+			}
+			else
+			{
+				uDWordByte.DWORD = pNFC->NFC_WDATA;
+				*pPageB = uDWordByte.BYTE[0];++pPageB;
+				*pPageB = uDWordByte.BYTE[1];++pPageB;
+				*pPageB = uDWordByte.BYTE[2];++pPageB;
+				*pPageB = uDWordByte.BYTE[3];++pPageB;
+			}
+		}while(--i);
+
+		//----------------------------------------------
+		//	DMA ACCESS
+		//----------------------------------------------
+		#elif defined( NAND_IO_USE_DMA_ACCESS )		
+		/* Setup ECC Block */
+		if ( nEccOnOff == ECC_ON )
+		{
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&pNFC->NFC_LDATA );
+			#endif
+			pECC->ECC_CTRL		|= ( 512 << ECC_SHIFT_DATASIZE );
+			pECC->ECC_CLEAR	 = 0x00000000;			// Clear ECC Block
+		}
+		
+
+		/* Start DMA on NFC BUS */
+		#if defined(_LINUX_) || defined(_WINCE_)
+		NAND_IO_SetupDMA( (void*)&NAND_IO_HwLDATA_PA, 0, 0,
+						  (void*)pDataBuffer, 4, 0,
+						  NAND_IO_DMA_READ, 512 );
+		#else
+		NAND_IO_SetupDMA( (void*)&pNFC->NFC_LDATA, 0, 0,
+						  (void*)pDataBuffer, 4, 0,
+						  NAND_IO_DMA_READ, 512 );
+		#endif
+
+		if ( bAlignAddr )
+			pPageDW += 128;
+		else
+			pPageB += 512;
+
+
+		#endif
+		//####################################################
+		//####################################################
+
+		if ( ( nDevInfo->Feature.MediaType  & A_BIG ) || (( nDevInfo->Feature.MediaType  & A_SMALL ) && ( nDevInfo->Feature.MediaType  & A_PARALLEL )))
+		{
+			// NOP	
+		}
+		else if ( nDevInfo->Feature.MediaType & A_SMALL )
+		{
+			/* Set Spare Buffer */
+			pSpareBuffer = ( bAlignAddr ) ? (unsigned char*)pSpareDW : (unsigned char*)pSpareB;
+
+			/* Read 16Bytes spare data */
+			i = 4;
+			do {
+				if ( bAlignAddr )
+				{
+					*pSpareDW = pNFC->NFC_WDATA;++pSpareDW;
+				}	
+				else
+				{
+					uDWordByte.DWORD = pNFC->NFC_WDATA;
+					*pSpareB = uDWordByte.BYTE[0];++pSpareB;
+					*pSpareB = uDWordByte.BYTE[1];++pSpareB;
+					*pSpareB = uDWordByte.BYTE[2];++pSpareB;
+					*pSpareB = uDWordByte.BYTE[3];++pSpareB;
+				}
+			}while(--i);
+
+			pSpareB = (unsigned char*)pSpareBuffer;
+			pSpareB +=	NAND_IO_SPARE_SIZE_SMALL;
+		}
+
+		/* Check and Correct ECC code */
+		if ( nEccOnOff == ECC_ON )
+		{
+			if ( nDevInfo->EccType == SLC_ECC_TYPE )
+			{
+				//===================================
+				// SLC ECC Correction
+				//===================================				
+				pSpareBuffer += NAND_IO_SPARE_SIZE_SMALL;
+				res |= NAND_IO_CorrectionSLC( pDataBuffer, pSpareBuffer );
+			}
+			else
+			{
+				res |= NAND_IO_CorrectionMLC( nDevInfo->EccType, pDataBuffer, pSpareB, 512 );
+
+				pSpareB += nECCDataSize;
+			}
+		}
+	
+	}
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	return res;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_ReadUserSizeData( NAND_IO_DEVINFO *nDevInfo, U16 nColumnAddr, U32 nReadSize, U8 *nReadBuffer );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nColumnAddr	= 
+*			nDevInfo	= 
+*			nReadBuffer	= 
+*			nReadSize	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_ReadUserSizeData( NAND_IO_DEVINFO *nDevInfo, U16 nColumnAddr, U32 nReadSize, U8 *nReadBuffer )
+{
+	unsigned int		*pSpareDW = 0;
+	unsigned char		*pPageB = 0;
+	DWORD_BYTE			uDWordByte;
+	
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	//=========================================================================
+	// Check Parameter
+	//=========================================================================
+	if ( (U32)( nColumnAddr + nReadSize ) > (U16)( nDevInfo->Feature.PageSize + nDevInfo->Feature.SpareSize ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================	
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//=========================================================================
+	// Read UserSize Data
+	//=========================================================================
+
+	/* Adapt type of address */
+	pPageB = (unsigned char*)nReadBuffer;
+	pSpareDW= (unsigned int*)nReadBuffer;
+	if ( nReadSize >= 4 )
+	{
+		#ifdef USE_NFC_LDATA		/* 08.12.17 */
+		/* Read 512 Data Area */
+		BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
+		pNFC->NFC_DSIZE		= nReadSize;
+		pNFC->NFC_IREQ	 	= 0x77;	// pNFC->NFC_IREQ_FLAG1;
+		pNFC->NFC_PSTART 	= 0;	
+
+		do {
+			while (!( pNFC->NFC_CTRL & HwNFC_CTRL_FS_RDY ));
+			
+			{
+				uDWordByte.DWORD = pNFC->NFC_LDATA;
+				*pPageB = uDWordByte.BYTE[0];++pPageB;
+				*pPageB = uDWordByte.BYTE[1];++pPageB;
+				*pPageB = uDWordByte.BYTE[2];++pPageB;
+				*pPageB = uDWordByte.BYTE[3];++pPageB;
+			}
+
+			nReadSize -= 4;
+
+		}while(nReadSize);
+
+		while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+	}
+	else
+	{
+		#endif
+		while ( nReadSize )
+		{
+			/* Read as DWORD */
+			if ( nReadSize >= 4 )
+			{
+				uDWordByte.DWORD = WORD_OF(pNFC->NFC_WDATA);
+				*pPageB = uDWordByte.BYTE[0];++pPageB;
+				*pPageB = uDWordByte.BYTE[1];++pPageB;
+				*pPageB = uDWordByte.BYTE[2];++pPageB;
+				*pPageB = uDWordByte.BYTE[3];++pPageB;
+				nReadSize -= 4;
+			}
+			/* Read as WORD */
+			else if ( nReadSize >= 2 )
+			{
+				uDWordByte.WORD[0] = HWORD_OF(pNFC->NFC_WDATA);
+				*pPageB = uDWordByte.BYTE[0];++pPageB;
+				*pPageB = uDWordByte.BYTE[1];++pPageB;
+				nReadSize -= 2;
+			}
+			/* Read as BYTE */
+			else
+			{
+				uDWordByte.BYTE[0] = BYTE_OF(pNFC->NFC_WDATA);
+				*pPageB = uDWordByte.BYTE[0];++pPageB;
+				nReadSize -= 1;
+			}
+		}
+	}
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+	return (NAND_IO_ERROR)SUCCESS;
+
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      static __inline NAND_IO_ERROR NAND_IO_WriteSpareData( NAND_IO_DEVINFO *nDevInfo, U8 *nSpareBuffer, int nEccOnOff );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			nDevInfo	= 
+*			nEccOnOff	= 
+*			nSpareBuffer	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+*  REMARK:	  by nemo
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_WriteSpareData( NAND_IO_DEVINFO *nDevInfo, U8 *nSpareBuffer, int nEccOnOff )
+{
+	unsigned int		i;
+	unsigned int		nWriteSize;
+	unsigned char		bAlignAddr;
+	unsigned char		*pSpareB = 0;
+	unsigned int		*pSpareDW = 0;
+	unsigned char		*pEccB;
+	#ifdef _LINUX_
+	unsigned char		nECCBuffer[30]__attribute__((aligned(8)));
+	#else
+	unsigned char		nECCBuffer[30];
+	#endif
+	DWORD_BYTE			uDWordByte;
+	NAND_IO_ERROR		res;
+
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	res = (NAND_IO_ERROR)SUCCESS;
+
+	//=========================================================================
+	// Check Align of nSpareBuffer Address
+	//=========================================================================
+	bAlignAddr		= ( (unsigned int)nSpareBuffer & 3 ) ? 0 : 1;
+
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	//=========================================================================
+	// Get Buffer Pointer
+	//=========================================================================
+	/* Adapt type of address */
+	if ( bAlignAddr )
+		pSpareDW	= (unsigned int*)nSpareBuffer;
+	else
+		pSpareB		= (unsigned char*)nSpareBuffer;
+
+	//==============================================================
+	// Write Spare
+	//==============================================================
+	if (!( pNFC->NFC_CTRL1 & Hw30 ))
+	{
+		/* Setup ECC Block */
+		if ( nEccOnOff == ECC_ON )
+		{
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, MLC_ECC_4BIT_TYPE, NAND_MCU_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, MLC_ECC_4BIT_TYPE, NAND_MCU_ACCESS, (U32)&pNFC->NFC_LDATA );
+			#endif
+			pECC->ECC_CTRL	|= ( 12 << ECC_SHIFT_DATASIZE );
+			pECC->ECC_CLEAR	= 0x00000000;
+		}
+
+		/* Write 12Bytes spare data */
+		BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
+		pNFC->NFC_DSIZE		= 12;
+		pNFC->NFC_IREQ	 	= 0x77;	// pNFC->NFC_IREQ_FLAG1;
+		pNFC->NFC_PSTART 	= 0;	
+		
+		i = 3;
+		do {
+			while (!( pNFC->NFC_CTRL & HwNFC_CTRL_FS_RDY ));
+			
+			if ( bAlignAddr )
+			{
+				pNFC->NFC_LDATA = *pSpareDW;++pSpareDW;
+			}
+			else
+			{
+				uDWordByte.BYTE[0]	= *pSpareB;++pSpareB;
+				uDWordByte.BYTE[1]	= *pSpareB;++pSpareB;
+				uDWordByte.BYTE[2]	= *pSpareB;++pSpareB;
+				uDWordByte.BYTE[3]	= *pSpareB;++pSpareB;
+				pNFC->NFC_LDATA = uDWordByte.DWORD;
+			}
+		}while(--i);
+
+		while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));		
+	}
+	else
+	{
+		/* Setup ECC Block */
+		if ( nEccOnOff == ECC_ON )
+		{
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, MLC_ECC_4BIT_TYPE, NAND_MCU_ACCESS, (U32)&NAND_IO_HwDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, MLC_ECC_4BIT_TYPE, NAND_MCU_ACCESS, (U32)&pNFC->NFC_WDATA );
+			#endif
+			pECC->ECC_CTRL	|= ( 12 << ECC_SHIFT_DATASIZE );
+			pECC->ECC_CLEAR	= 0x00000000;
+		}
+
+		i = 3;
+		do {
+			if ( bAlignAddr )
+			{
+				pNFC->NFC_WDATA = *pSpareDW;++pSpareDW;
+			}
+			else
+			{
+				uDWordByte.BYTE[0]	= *pSpareB;++pSpareB;
+				uDWordByte.BYTE[1]	= *pSpareB;++pSpareB;
+				uDWordByte.BYTE[2]	= *pSpareB;++pSpareB;
+				uDWordByte.BYTE[3]	= *pSpareB;++pSpareB;
+				pNFC->NFC_WDATA = uDWordByte.DWORD;
+			}
+		}while(--i);		
+	}
+
+	// Clear ECC Buffer
+	memset( nECCBuffer, 0xFF, 30 );
+
+	/* Adapt type of address */
+	pEccB = (unsigned char*)nECCBuffer;
+
+	/*	Load ECC code from ECC block */
+	if ( nEccOnOff == ECC_ON )
+	{
+		res = NAND_IO_EncodeECC( MLC_ECC_4BIT_TYPE, pEccB );
+		if ( res != SUCCESS )
+			goto ErrorWriteSpareData;
+	}
+	
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	/* Write 4Bit ECC data */
+	if ( nEccOnOff == ECC_ON )
+	{
+		nWriteSize = 10;
+
+		while ( nWriteSize )
+		{
+			/* Write as DWORD */
+			if ( nWriteSize >= 4 )
+			{
+				uDWordByte.BYTE[0] = *pEccB;++pEccB;
+				uDWordByte.BYTE[1] = *pEccB;++pEccB;
+				uDWordByte.BYTE[2] = *pEccB;++pEccB;
+				uDWordByte.BYTE[3] = *pEccB;++pEccB;
+				pNFC->NFC_WDATA = uDWordByte.DWORD;
+				nWriteSize -= 4;
+			}
+			/* Write as WORD */
+			else if ( nWriteSize >= 2 )
+			{
+				pNFC->NFC_SDATA = *pEccB;++pEccB;
+				pNFC->NFC_SDATA = *pEccB;++pEccB;
+				nWriteSize -= 2;
+			}
+			/* Write as BYTE */
+			else
+			{
+				pNFC->NFC_SDATA = *pEccB;++pEccB;
+				nWriteSize -= 1;
+			}
+		}
+	}
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+
+ErrorWriteSpareData:
+	return res;
+
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      static __inline NAND_IO_ERROR NAND_IO_WriteSpareData( NAND_IO_DEVINFO *nDevInfo, U8 *nSpareBuffer, int nEccOnOff );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			nDevInfo	= 
+*			nEccOnOff	= 
+*			nSpareBuffer	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+*  REMARK:	  by nemo
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_WriteSpareDataMTD( NAND_IO_DEVINFO *nDevInfo, U8 *nSpareBuffer, int nPageEccOnOff )
+{
+	unsigned int		i;
+	unsigned int		nSpareTotalSize;
+	unsigned int		nECCDataSize;
+	unsigned char		bAlignAddr;
+	unsigned char		*pSpareB = 0;
+	unsigned int		*pSpareDW = 0;
+	DWORD_BYTE			uDWordByte;
+	NAND_IO_ERROR		res;
+
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	res = (NAND_IO_ERROR)SUCCESS;
+	
+	//if ( nDevInfo->Feature.MediaType & A_BIG )
+	//	nSpareTotalSize = ( NAND_IO_SPARE_SIZE_BIG + nDevInfo->EccWholeDataSize );
+	//else
+	nSpareTotalSize = 32;
+	
+	//=========================================================================
+	// Check Align of nSpareBuffer Address
+	//=========================================================================
+	bAlignAddr		= ( (unsigned int)nSpareBuffer & 3 ) ? 0 : 1;
+		
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	//=========================================================================
+	// Get Buffer Pointer
+	//=========================================================================
+	/* Adapt type of address */
+	if ( bAlignAddr )
+		pSpareDW	= (unsigned int*)nSpareBuffer;
+	else
+		pSpareB		= (unsigned char*)nSpareBuffer;
+
+	if ( nDevInfo->Feature.MediaType & A_MLC )
+		nECCDataSize = 8;
+	else if ( ( nDevInfo->Feature.MediaType & A_MLC_8BIT ) || ( nDevInfo->Feature.MediaType & A_MLC_12BIT ) )
+		nECCDataSize = 20;
+
+	//==============================================================
+	// Write Spare
+	//==============================================================
+	if ( nDevInfo->Feature.MediaType & A_BIG )
+	{
+		///* Setup ECC Block */
+		//#if defined(_WINCE_) || defined(_LINUX_)
+		//NAND_IO_SetupECC( (U16)ECC_ON, ECC_ENCODE, MLC_ECC_4BIT_TYPE, NAND_MCU_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+		//#else
+		//NAND_IO_SetupECC( (U16)ECC_ON, ECC_ENCODE, MLC_ECC_4BIT_TYPE, NAND_MCU_ACCESS, (U32)&pNFC->NFC_LDATA );
+		//#endif
+		//pECC->ECC_CTRL	|= ( nSpareTotalSize << ECC_SHIFT_DATASIZE );
+		//pECC->ECC_CLEAR	= 0x00000000;
+
+		/* Write 12Bytes spare data */
+		BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
+		pNFC->NFC_DSIZE		= nSpareTotalSize;
+		pNFC->NFC_IREQ	 	= 0x77;	// pNFC->NFC_IREQ_FLAG1;
+		pNFC->NFC_PSTART 	= 0;
+
+		i = ( nSpareTotalSize >> 2 );
+		do {
+			while (!( pNFC->NFC_CTRL & HwNFC_CTRL_FS_RDY ));
+			
+			if ( bAlignAddr )
+			{
+				pNFC->NFC_LDATA = *pSpareDW;++pSpareDW;
+			}
+			else
+			{
+				uDWordByte.BYTE[0]	= *pSpareB;++pSpareB;
+				uDWordByte.BYTE[1]	= *pSpareB;++pSpareB;
+				uDWordByte.BYTE[2]	= *pSpareB;++pSpareB;
+				uDWordByte.BYTE[3]	= *pSpareB;++pSpareB;
+				pNFC->NFC_LDATA = uDWordByte.DWORD;
+			}
+		}while(--i);
+
+		while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+
+
+		//// Clear ECC Buffer
+		//memset( nECCBuffer, 0xFF, 8 );
+		//
+		///* Adapt type of address */
+		//pEccB = (unsigned char*)nECCBuffer;
+		//
+		///*	Load ECC code from ECC block */
+		//res = NAND_IO_EncodeECC( MLC_ECC_4BIT_TYPE, pEccB );
+		//if ( res != SUCCESS )
+		//	goto ErrorWriteSpareData;
+		//
+		//NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+		//
+		///* Write 4Bit ECC data */
+		//nWriteSize = 8;
+		//
+		//while ( nWriteSize )
+		//{
+		//	/* Write as DWORD */
+		//	if ( nWriteSize >= 4 )
+		//	{
+		//		uDWordByte.BYTE[0] = *pEccB;++pEccB;
+		//		uDWordByte.BYTE[1] = *pEccB;++pEccB;
+		//		uDWordByte.BYTE[2] = *pEccB;++pEccB;
+		//		uDWordByte.BYTE[3] = *pEccB;++pEccB;
+		//		pNFC->NFC_WDATA = uDWordByte.DWORD;
+		//		nWriteSize -= 4;
+		//	}
+		//	/* Write as WORD */
+		//	else if ( nWriteSize >= 2 )
+		//	{
+		//		pNFC->NFC_SDATA = *pEccB;++pEccB;
+		//		pNFC->NFC_SDATA = *pEccB;++pEccB;
+		//		nWriteSize -= 2;
+		//	}
+		//	/* Write as BYTE */
+		//	else
+		//	{
+		//		pNFC->NFC_SDATA = *pEccB;++pEccB;
+		//		nWriteSize -= 1;
+		//	}
+		//}
+
+		if ( nPageEccOnOff == PAGE_ECC_ON )
+		{
+			//=========================================================================
+			// Check Align of PageBuffer Address
+			//=========================================================================
+			bAlignAddr = ( (unsigned int)&gNAND_IO_ShareEccBuffer & 3 ) ? 0 : 1;
+			
+			//=========================================================================
+			// Get Buffer Pointer
+			//=========================================================================
+			/* Adapt type of address */
+			if ( bAlignAddr )
+				pSpareDW	= (unsigned int*)&gNAND_IO_ShareEccBuffer[0];
+			else
+				pSpareB		= (unsigned char*)&gNAND_IO_ShareEccBuffer[0];
+			
+			//----------------------------------------------
+			//	Read Spare Data
+			//----------------------------------------------
+			i = ( ( nECCDataSize << 2 ) >> 2 );
+			do {
+				if ( bAlignAddr )
+				{
+					pNFC->NFC_WDATA = *pSpareDW;++pSpareDW;
+				}	
+				else
+				{
+					uDWordByte.BYTE[0] = *pSpareB;++pSpareB;
+					uDWordByte.BYTE[1] = *pSpareB;++pSpareB;
+					uDWordByte.BYTE[2] = *pSpareB;++pSpareB;
+					uDWordByte.BYTE[3] = *pSpareB;++pSpareB;
+					pNFC->NFC_WDATA = uDWordByte.DWORD;
+				}
+			}while(--i);
+		}
+	}
+	else
+	{
+		i = ( nSpareTotalSize >> 2 );
+		do {
+			if ( bAlignAddr )
+			{
+				pNFC->NFC_WDATA = *pSpareDW;++pSpareDW;
+			}
+			else
+			{
+				uDWordByte.BYTE[0]	= *pSpareB;++pSpareB;
+				uDWordByte.BYTE[1]	= *pSpareB;++pSpareB;
+				uDWordByte.BYTE[2]	= *pSpareB;++pSpareB;
+				uDWordByte.BYTE[3]	= *pSpareB;++pSpareB;
+				pNFC->NFC_WDATA = uDWordByte.DWORD;
+			}
+		}while(--i);
+
+		if (( nDevInfo->Feature.MediaType & A_SMALL ) && ( nDevInfo->Feature.MediaType & A_PARALLEL ))
+		{
+			if ( nPageEccOnOff == PAGE_ECC_ON )
+			{
+				//=========================================================================
+				// Check Align of PageBuffer Address
+				//=========================================================================
+				bAlignAddr = ( (unsigned int)&gNAND_IO_ShareEccBuffer & 3 ) ? 0 : 1;
+				
+				//=========================================================================
+				// Get Buffer Pointer
+				//=========================================================================
+				/* Adapt type of address */
+				if ( bAlignAddr )
+					pSpareDW	= (unsigned int*)&gNAND_IO_ShareEccBuffer[0];
+				else
+					pSpareB		= (unsigned char*)&gNAND_IO_ShareEccBuffer[0];
+				
+				//----------------------------------------------
+				//	Read Spare Data
+				//----------------------------------------------
+				i = ( ( 8 << nDevInfo->ShiftPPages) >> 2 );
+				do {
+					if ( bAlignAddr )
+					{
+						pNFC->NFC_WDATA = *pSpareDW;++pSpareDW;
+					}	
+					else
+					{
+						uDWordByte.BYTE[0] = *pSpareB;++pSpareB;
+						uDWordByte.BYTE[1] = *pSpareB;++pSpareB;
+						uDWordByte.BYTE[2] = *pSpareB;++pSpareB;
+						uDWordByte.BYTE[3] = *pSpareB;++pSpareB;
+						pNFC->NFC_WDATA = uDWordByte.DWORD;
+					}
+				}while(--i);
+			}			
+		}
+	}
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+
+	return res;
+
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      static __inline NAND_IO_ERROR NAND_IO_Write512DataDoubleBuf( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nWritePPSize,
+*      																U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			nDevInfo	= 
+*			nEccOnOff	= 
+*			nPageBuffer	= 
+*			nSpareBuffer	= 
+*			nStartPPage	= 
+*			nWritePPSize	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+*  REMARK:	  by nemo
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_Write512DataDoubleBuf( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nWritePPSize,
+															 U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff )
+{
+	unsigned int		i, j;
+	unsigned char		bAlignAddr;
+	#ifdef _LINUX_
+	unsigned char 		nDummyPageBuffer[512]__attribute__((aligned(8)));
+	unsigned char		nECCBuffer[30]__attribute__((aligned(8)));
+	#else
+	unsigned char 		nDummyPageBuffer[512];
+	unsigned char		nECCBuffer[30];
+	#endif
+	unsigned char		*pPageB = 0, *pSpareB = 0;
+	unsigned int		*pPageDW = 0, *pSpareDW = 0;
+	unsigned char		*pDataBuffer;
+	unsigned char		*pEccB;
+	DWORD_BYTE			uDWordByte;
+	NAND_IO_ERROR		res;
+
+	if ( ( nStartPPage + nWritePPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	res = (NAND_IO_ERROR)SUCCESS;
+
+	//=========================================================================
+	// Check Align of PageBuffer Address
+	//=========================================================================
+	bAlignAddr		= ( (unsigned int)nPageBuffer & 3 ) ? 0 : 1;
+
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	//=========================================================================
+	// Get Buffer Pointer
+	//=========================================================================
+	/* Adapt type of address */
+	if ( bAlignAddr )
+	{
+		pPageDW		= (unsigned int*)nPageBuffer;
+		pSpareDW	= (unsigned int*)nSpareBuffer;
+	}	
+	else
+	{
+		pPageB		= (unsigned char*)nPageBuffer;
+		pSpareB		= (unsigned char*)nSpareBuffer;
+	}	
+
+	//----------------------------------------------
+	//	Write Data as 512Bytes repeatly
+	//----------------------------------------------
+	for ( j = 0; j < nWritePPSize; ++j )
+	{
+		/* Get Data Buffer */
+		pDataBuffer = ( bAlignAddr ) ? (unsigned char*)pPageDW : (unsigned char*)pPageB;
+
+		//####################################################
+		//#	Write 512 Page Data
+		//####################################################
+		//----------------------------------------------
+		//	MCU ACCESS
+		//----------------------------------------------
+		#if defined( NAND_IO_USE_MCU_ACCESS )
+		if ( nEccOnOff == ECC_ON )
+		{
+			/* Setup ECC Block */
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&pNFC->NFC_LDATA );
+			#endif
+			pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );
+			pECC->ECC_CLEAR	= 0x00000000;
+		}
+
+		/* Write 512 Data Area */
+		BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
+		pNFC->NFC_DSIZE		= 512;
+		pNFC->NFC_IREQ 		= 0x77;	// pNFC->NFC_IREQ_FLAG1;		
+		pNFC->NFC_PSTART 	= 0;
+		
+		i = 128;
+		do {
+			while (!( pNFC->NFC_CTRL & HwNFC_CTRL_FS_RDY ));
+			
+			if ( bAlignAddr )
+			{
+				pNFC->NFC_LDATA = *pPageDW;++pPageDW;
+			}	
+			else
+			{
+				uDWordByte.BYTE[0] = *pPageB;++pPageB;
+				uDWordByte.BYTE[1] = *pPageB;++pPageB;
+				uDWordByte.BYTE[2] = *pPageB;++pPageB;
+				uDWordByte.BYTE[3] = *pPageB;++pPageB;
+				pNFC->NFC_LDATA	= uDWordByte.DWORD;
+			}
+		}while(--i);
+		
+		while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+
+		//----------------------------------------------
+		//	DMA ACCESS
+		//----------------------------------------------
+		#elif defined( NAND_IO_USE_DMA_ACCESS )
+		if ( nEccOnOff == ECC_ON )
+		{
+			/* Setup ECC Block */
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&pNFC->NFC_LDATA );
+			#endif
+			pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );
+			pECC->ECC_CLEAR	= 0x00000000;
+		}
+
+		if ( j == 0 )
+			memcpy( gpDMA_WorkBuffer1, pDataBuffer, 512 );
+
+		NAND_IO_SetupDMADoubleBuf( NAND_IO_DMA_WRITE, j );
+
+		if ( pNFC->NFC_CTRL1 & Hw31 )
+			BITCLR( pNFC->NFC_CTRL1, Hw31 );
+
+		pNFC->NFC_PSTART	= 0;
+
+		if ( j != ( nWritePPSize - 1 ) ) 
+		{
+			if ( j & 1 )
+				memcpy( gpDMA_WorkBuffer1, (void *)(pDataBuffer + 512), 512 );
+			else
+				memcpy( gpDMA_WorkBuffer0, (void *)(pDataBuffer + 512), 512 );
+		}
+
+		while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+
+		if ( pNFC->NFC_CTRL1 & Hw30 )
+			BITSET( pNFC->NFC_CTRL1, Hw31 );
+
+		if ( bAlignAddr )
+			pPageDW += 128;
+		else
+			pPageB += 512;
+
+		#endif
+		//####################################################
+		//####################################################
+
+		// Clear ECC Buffer
+		memset( nECCBuffer, 0xFF, 30 );
+
+		/* Adapt type of address */
+		pEccB = (unsigned char*)nECCBuffer;
+
+		/*	Load ECC code from ECC block */
+		if ( nEccOnOff == ECC_ON )
+		{
+			res = NAND_IO_EncodeECC( nDevInfo->EccType, pEccB );
+			if ( res != SUCCESS )
+				goto ErrorWrite512Data;
+		}
+
+		/* Write 'n'Bytes ECC data */
+		i = nDevInfo->EccDataSize;
+
+		while ( i )
+		{
+			/* Write as DWORD */
+			if ( i >= 4 )
+			{
+				uDWordByte.BYTE[0] = *pEccB;++pEccB;
+				uDWordByte.BYTE[1] = *pEccB;++pEccB;
+				uDWordByte.BYTE[2] = *pEccB;++pEccB;
+				uDWordByte.BYTE[3] = *pEccB;++pEccB;
+				pNFC->NFC_WDATA = uDWordByte.DWORD;
+				i -= 4;
+			}
+			/* Write as WORD */
+			else if ( i >= 2 )
+			{
+				pNFC->NFC_SDATA = *pEccB;++pEccB;
+				pNFC->NFC_SDATA = *pEccB;++pEccB;
+				i -= 2;
+			}
+			/* Write as BYTE */
+			else
+			{
+				pNFC->NFC_SDATA = *pEccB;++pEccB;
+				i -= 1;
+			}
+		}
+	}
+
+	//=========================================================================
+	// Empty PPage Write
+	//=========================================================================
+	if ( ( nStartPPage + nWritePPSize ) != ( nDevInfo->PPages ) )
+	{
+		memset( nDummyPageBuffer, 0xFF, 512 );
+		//Write Dummy Data
+		for ( j = 0; j < (U16)( nDevInfo->PPages - ( nStartPPage + nWritePPSize ) ); ++j )
+		{
+			//####################################################
+			//#	Write 512 Page Data
+			//####################################################
+			//----------------------------------------------
+			//	MCU ACCESS
+			//----------------------------------------------
+			#if defined( NAND_IO_USE_MCU_ACCESS )
+			/* Setup ECC Block */
+			if ( nEccOnOff == ECC_ON )
+			{
+				#if defined(_WINCE_) || defined(_LINUX_)
+				NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+				#else
+				NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&pNFC->NFC_LDATA );
+				#endif
+				pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );		// Data Size...
+				pECC->ECC_CLEAR	= 0x00000000;
+			}
+
+			/* Write 512 Data Area */
+			BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
+			pNFC->NFC_DSIZE	= 512;
+			pNFC->NFC_IREQ = 0x77;	// pNFC->NFC_IREQ_FLAG1;		
+			pNFC->NFC_PSTART = 0;
+			
+			i = 128;
+			do
+			{
+				while (!( pNFC->NFC_CTRL & HwNFC_CTRL_FS_RDY ));
+				pNFC->NFC_LDATA = 0xFFFFFFFF;
+			}while(--i);
+			
+			while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+			
+			//----------------------------------------------
+			//	DMA ACCESS
+			//----------------------------------------------
+			#elif defined( NAND_IO_USE_DMA_ACCESS )
+			/* Setup ECC Block */
+			if ( nEccOnOff == ECC_ON )
+			{
+				#if defined(_WINCE_) || defined(_LINUX_)
+				NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+				#else
+				NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&pNFC->NFC_LDATA );
+				#endif
+				pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );		// Data Size...
+				pECC->ECC_CLEAR	= 0x00000000;
+			}
+
+			#if defined(_LINUX_) || defined(_WINCE_)
+			NAND_IO_SetupDMA( (void*)nDummyPageBuffer, 4, 0,
+							  (void*)&NAND_IO_HwLDATA_PA, 0, 0,
+							  NAND_IO_DMA_WRITE, 512 );
+			#else
+			NAND_IO_SetupDMA( (void*)nDummyPageBuffer, 4, 0,
+							  (void*)&pNFC->NFC_LDATA, 0, 0,
+							  NAND_IO_DMA_WRITE, 512 );
+			#endif
+
+			#endif
+			//####################################################
+			//####################################################
+
+			// Clear ECC Buffer
+			memset( nECCBuffer, 0xFF, 30 );
+
+			/* Adapt type of address */
+			pEccB = (unsigned char*)nECCBuffer;
+
+			/*	Load ECC code from ECC block */
+			if ( nEccOnOff == ECC_ON )
+			{
+				res = NAND_IO_EncodeECC( nDevInfo->EccType, pEccB );
+				if ( res != SUCCESS )
+					goto ErrorWrite512Data;
+			}
+
+			/* Write 'n'Bytes ECC data */
+			i = nDevInfo->EccDataSize;
+
+			while ( i )
+			{
+				if ( i >= 4 )
+				{
+					uDWordByte.BYTE[0] = *pEccB;++pEccB;
+					uDWordByte.BYTE[1] = *pEccB;++pEccB;
+					uDWordByte.BYTE[2] = *pEccB;++pEccB;
+					uDWordByte.BYTE[3] = *pEccB;++pEccB;
+					pNFC->NFC_WDATA = uDWordByte.DWORD;
+					i -= 4;
+				}
+				else if ( i >= 2 )
+				{
+					pNFC->NFC_SDATA = *pEccB;++pEccB;
+					pNFC->NFC_SDATA = *pEccB;++pEccB;
+					i -= 2;
+				}
+				else
+				{
+					pNFC->NFC_SDATA = *pEccB;++pEccB;
+					i -= 1;
+				}
+			}		
+		}
+	}
+	
+	//=========================================================================
+	// Write Spare Data
+	//=========================================================================
+	NAND_IO_WriteSpareData ( nDevInfo, nSpareBuffer, nEccOnOff );
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+
+ErrorWrite512Data:
+	return res;
+
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      static __inline NAND_IO_ERROR NAND_IO_Write512Data( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nWritePPSize,
+*      													U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			nDevInfo	= 
+*			nEccOnOff	= 
+*			nPageBuffer	= 
+*			nSpareBuffer	= 
+*			nStartPPage	= 
+*			nWritePPSize	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+*  REMARK:	  by nemo
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_Write512Data( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nWritePPSize,
+													U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff )
+{
+	unsigned int		i, j;
+	unsigned char		bAlignAddr;
+	#ifdef _LINUX_
+	unsigned char 		nDummyPageBuffer[512]__attribute__((aligned(8)));
+	unsigned char		nECCBuffer[30]__attribute__((aligned(8)));
+	#else
+	unsigned char 		nDummyPageBuffer[512];
+	unsigned char		nECCBuffer[30];
+	#endif
+	unsigned char		*pPageB = 0, *pSpareB = 0;
+	unsigned int		*pPageDW = 0, *pSpareDW = 0;
+	unsigned char		*pDataBuffer;
+	unsigned char		*pEccB;
+	DWORD_BYTE			uDWordByte;
+	NAND_IO_ERROR		res;
+
+	if ( ( nStartPPage + nWritePPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	res = (NAND_IO_ERROR)SUCCESS;
+
+	//=========================================================================
+	// Check Align of PageBuffer Address
+	//=========================================================================
+	bAlignAddr		= ( (unsigned int)nPageBuffer & 3 ) ? 0 : 1;
+
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	//=========================================================================
+	// Get Buffer Pointer
+	//=========================================================================
+	/* Adapt type of address */
+	if ( bAlignAddr )
+	{
+		pPageDW		= (unsigned int*)nPageBuffer;
+		pSpareDW	= (unsigned int*)nSpareBuffer;
+	}	
+	else
+	{
+		pPageB		= (unsigned char*)nPageBuffer;
+		pSpareB		= (unsigned char*)nSpareBuffer;
+	}	
+
+	//----------------------------------------------
+	//	Write Data as 512Bytes repeatly
+	//----------------------------------------------
+	for ( j = 0; j < nWritePPSize; ++j )
+	{
+		/* Get Data Buffer */
+		pDataBuffer = ( bAlignAddr ) ? (unsigned char*)pPageDW : (unsigned char*)pPageB;
+
+		//####################################################
+		//#	Write 512 Page Data
+		//####################################################
+		//----------------------------------------------
+		//	MCU ACCESS
+		//----------------------------------------------
+		#if defined( NAND_IO_USE_MCU_ACCESS )
+		if ( nEccOnOff == ECC_ON )
+		{
+			/* Setup ECC Block */
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&pNFC->NFC_LDATA );
+			#endif
+			pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );
+			pECC->ECC_CLEAR	= 0x00000000;
+		}
+
+		/* Write 512 Data Area */
+		BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
+		pNFC->NFC_DSIZE		= 512;
+		pNFC->NFC_IREQ 		= 0x77;	// pNFC->NFC_IREQ_FLAG1;		
+		pNFC->NFC_PSTART 		= 0;
+		
+		i = 128;
+		do {
+			while (!( pNFC->NFC_CTRL & HwNFC_CTRL_FS_RDY ));
+			
+			if ( bAlignAddr )
+			{
+				pNFC->NFC_LDATA = *pPageDW;++pPageDW;
+			}	
+			else
+			{
+				uDWordByte.BYTE[0] = *pPageB;++pPageB;
+				uDWordByte.BYTE[1] = *pPageB;++pPageB;
+				uDWordByte.BYTE[2] = *pPageB;++pPageB;
+				uDWordByte.BYTE[3] = *pPageB;++pPageB;
+				pNFC->NFC_LDATA	= uDWordByte.DWORD;
+			}
+		}while(--i);
+		
+		while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+
+		//----------------------------------------------
+		//	DMA ACCESS
+		//----------------------------------------------
+		#elif defined( NAND_IO_USE_DMA_ACCESS )
+		if ( nEccOnOff == ECC_ON )
+		{
+			/* Setup ECC Block */
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&pNFC->NFC_LDATA );
+			#endif
+			pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );
+			pECC->ECC_CLEAR	= 0x00000000;
+		}
+		
+		#if defined(_LINUX_) || defined(_WINCE_)
+		NAND_IO_SetupDMA( (void*)pDataBuffer, 4, 0,
+						  (void*)&NAND_IO_HwLDATA_PA, 0, 0,
+						  NAND_IO_DMA_WRITE, 512 );
+		#else
+		NAND_IO_SetupDMA( (void*)pDataBuffer, 4, 0,
+						  (void*)&pNFC->NFC_LDATA, 0, 0,
+						  NAND_IO_DMA_WRITE, 512 );
+		#endif
+	
+		if ( bAlignAddr )
+			pPageDW += 128;
+		else
+			pPageB += 512;
+
+		#endif
+		//####################################################
+		//####################################################
+
+		// Clear ECC Buffer
+		memset( nECCBuffer, 0xFF, 30 );
+
+		/* Adapt type of address */
+		pEccB = (unsigned char*)nECCBuffer;
+
+		/*	Load ECC code from ECC block */
+		if ( nEccOnOff == ECC_ON )
+		{
+			res = NAND_IO_EncodeECC( nDevInfo->EccType, pEccB );
+			if ( res != SUCCESS )
+				goto ErrorWrite512Data;
+		}
+
+		/* Write 'n'Bytes ECC data */
+		i = nDevInfo->EccDataSize;
+
+		while ( i )
+		{
+			/* Write as DWORD */
+			if ( i >= 4 )
+			{
+				uDWordByte.BYTE[0] = *pEccB;++pEccB;
+				uDWordByte.BYTE[1] = *pEccB;++pEccB;
+				uDWordByte.BYTE[2] = *pEccB;++pEccB;
+				uDWordByte.BYTE[3] = *pEccB;++pEccB;
+				pNFC->NFC_WDATA = uDWordByte.DWORD;
+				i -= 4;
+			}
+			/* Write as WORD */
+			else if ( i >= 2 )
+			{
+				pNFC->NFC_SDATA = *pEccB;++pEccB;
+				pNFC->NFC_SDATA = *pEccB;++pEccB;
+				i -= 2;
+			}
+			/* Write as BYTE */
+			else
+			{
+				pNFC->NFC_SDATA = *pEccB;++pEccB;
+				i -= 1;
+			}
+		}
+	}
+
+	//=========================================================================
+	// Empty PPage Write
+	//=========================================================================
+	if ( ( nStartPPage + nWritePPSize ) != ( nDevInfo->PPages ) )
+	{
+		memset( nDummyPageBuffer, 0xFF, 512 );
+		//Write Dummy Data
+		for ( j = 0; j < (U16)( nDevInfo->PPages - ( nStartPPage + nWritePPSize ) ); ++j )
+		{
+			//####################################################
+			//#	Write 512 Page Data
+			//####################################################
+			//----------------------------------------------
+			//	MCU ACCESS
+			//----------------------------------------------
+			#if defined( NAND_IO_USE_MCU_ACCESS )
+			/* Setup ECC Block */
+			if ( nEccOnOff == ECC_ON )
+			{
+				#if defined(_WINCE_) || defined(_LINUX_)
+				NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+				#else
+				NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&pNFC->NFC_LDATA );
+				#endif
+				pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );		// Data Size...
+				pECC->ECC_CLEAR	= 0x00000000;
+			}
+
+			/* Write 512 Data Area */
+			BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
+			pNFC->NFC_DSIZE	= 512;
+			pNFC->NFC_IREQ = 0x77;	// pNFC->NFC_IREQ_FLAG1;		
+			pNFC->NFC_PSTART = 0;
+			
+			i = 128;
+			do
+			{
+				while (!( pNFC->NFC_CTRL & HwNFC_CTRL_FS_RDY ));
+				pNFC->NFC_LDATA = 0xFFFFFFFF;
+			}while(--i);
+			
+			while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+			
+			//----------------------------------------------
+			//	DMA ACCESS
+			//----------------------------------------------
+			#elif defined( NAND_IO_USE_DMA_ACCESS )
+			/* Setup ECC Block */
+			if ( nEccOnOff == ECC_ON )
+			{
+				#if defined(_WINCE_) || defined(_LINUX_)
+				NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+				#else
+				NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&pNFC->NFC_LDATA );
+				#endif
+				pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );		// Data Size...
+				pECC->ECC_CLEAR	= 0x00000000;
+			}
+			
+			/* Disable DMA Ahead */
+			//IO_DMA_SetCTRL( IO_DMA_CH2, 0 );
+			//IO_INT_HwICLR = IO_INT_HwDMA_CH2;
+
+			///* Prepare data */
+		 //   if ( ISZERO( nDummyPageBuffer, 3 ) ) {
+			//    #if defined(_WINCE_)
+			//	    memcpy( (void*)IO_NFC_BUFFER0_BASE, nDummyPageBuffer, 512 );
+			//    #elif defined(_LINUX_)
+			//        #ifndef KERNEL_DRIVER
+			//        memcpy( (void*)IO_NFC_BUFFER0_BASE, nDummyPageBuffer, 512 );
+			//        #else
+			//        memcpy( virtadr, nDummyPageBuffer, 512 );
+			//        #endif
+			//    #else
+			//	fmemcpy16( (void*)IO_NFC_BUFFER0_BASE, nDummyPageBuffer, 512 );
+			//	#endif
+		 //   } else {
+			//    #if defined(_WINCE_)
+			//	    memcpy( (void*)IO_NFC_BUFFER0_BASE, nDummyPageBuffer, 512 );
+			//    #elif defined(_LINUX_)
+			//        #ifndef KERNEL_DRIVER
+			//        memcpy( (void*)IO_NFC_BUFFER0_BASE, nDummyPageBuffer, 512 );
+			//        #else
+			//        memcpy( virtadr, nDummyPageBuffer, 512 );
+			//        #endif
+			//    #else
+			//	memcpy( (void*)IO_NFC_BUFFER0_BASE, nDummyPageBuffer, 512 );
+			//	#endif
+		 //   }
+
+			#if defined(_LINUX_) || defined(_WINCE_)
+			NAND_IO_SetupDMA( (void*)nDummyPageBuffer, 4, 0,
+							  (void*)&NAND_IO_HwLDATA_PA, 0, 0,
+							  NAND_IO_DMA_WRITE, 512 );
+			#else
+			NAND_IO_SetupDMA( (void*)nDummyPageBuffer, 4, 0,
+							  (void*)&pNFC->NFC_LDATA, 0, 0,
+							  NAND_IO_DMA_WRITE, 512 );
+			#endif
+
+			#endif
+			//####################################################
+			//####################################################
+
+			// Clear ECC Buffer
+			memset( nECCBuffer, 0xFF, 30 );
+
+			/* Adapt type of address */
+			pEccB = (unsigned char*)nECCBuffer;
+
+			/*	Load ECC code from ECC block */
+			if ( nEccOnOff == ECC_ON )
+			{
+				res = NAND_IO_EncodeECC( nDevInfo->EccType, pEccB );
+				if ( res != SUCCESS )
+					goto ErrorWrite512Data;
+			}
+
+			/* Write 'n'Bytes ECC data */
+			i = nDevInfo->EccDataSize;
+
+			while ( i )
+			{
+				if ( i >= 4 )
+				{
+					uDWordByte.BYTE[0] = *pEccB;++pEccB;
+					uDWordByte.BYTE[1] = *pEccB;++pEccB;
+					uDWordByte.BYTE[2] = *pEccB;++pEccB;
+					uDWordByte.BYTE[3] = *pEccB;++pEccB;
+					pNFC->NFC_WDATA = uDWordByte.DWORD;
+					i -= 4;
+				}
+				else if ( i >= 2 )
+				{
+					pNFC->NFC_SDATA = *pEccB;++pEccB;
+					pNFC->NFC_SDATA = *pEccB;++pEccB;
+					i -= 2;
+				}
+				else
+				{
+					pNFC->NFC_SDATA = *pEccB;++pEccB;
+					i -= 1;
+				}
+			}		
+		}
+	}
+	
+	//=========================================================================
+	// Write Spare Data
+	//=========================================================================
+	NAND_IO_WriteSpareData ( nDevInfo, nSpareBuffer, nEccOnOff );
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+
+ErrorWrite512Data:
+	return res;
+
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_Write528Data( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nWritePPSize,
+*      													U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nDevInfo	= 
+*			nEccOnOff	= 
+*			nPageBuffer	= 
+*			nSpareBuffer	= 
+*			nStartPPage	= 
+*			nWritePPSize	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_Write528Data( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nWritePPSize,
+													U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff )
+{
+	unsigned int		i, j;
+	unsigned char		bAlignAddr;
+	unsigned char		*pPageB = 0, *pSpareB = 0;
+	unsigned int		*pPageDW = 0, *pSpareDW = 0;
+	unsigned char		*pDataBuffer, *pSpareBuffer;
+	DWORD_BYTE			uDWordByte;
+	NAND_IO_ERROR		res;
+	
+	if ( ( nStartPPage + nWritePPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	res = (NAND_IO_ERROR)SUCCESS;
+	
+	//=========================================================================
+	// Check Align of PageBuffer Address
+	//=========================================================================
+	bAlignAddr		= ( (unsigned int)nPageBuffer & 3 ) ? 0 : 1;
+
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================	
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+	//=========================================================================
+	// Write Data as 528Bytes
+	//=========================================================================
+
+	/* Adapt type of address */
+	if ( bAlignAddr )
+	{
+		pPageDW		= (unsigned int*)nPageBuffer;
+		pSpareDW	= (unsigned int*)nSpareBuffer;
+	}	
+	else
+	{
+		pPageB		= (unsigned char*)nPageBuffer;
+		pSpareB		= (unsigned char*)nSpareBuffer;
+	}	
+
+	//----------------------------------------------
+	//	Write Data as 512Bytes repeatly
+	//----------------------------------------------		
+	for ( j = 0; j < nWritePPSize; ++j )
+	{
+		/* Get Data Buffer */
+		pDataBuffer = ( bAlignAddr ) ? (unsigned char*)pPageDW : (unsigned char*)pPageB;
+
+		//####################################################
+		//#	Write 512 Page Data
+		//####################################################
+		//----------------------------------------------
+		//	MCU ACCESS
+		//----------------------------------------------
+		#if defined( NAND_IO_USE_MCU_ACCESS )
+		
+		/* Setup ECC Block */
+		if ( nEccOnOff == ECC_ON )
+		{
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&pNFC->NFC_LDATA );			
+			#endif
+			pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );
+			pECC->ECC_CLEAR	= 0x00000000;
+		}
+
+		/* Write 512 Data Area */	
+		BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
+		pNFC->NFC_DSIZE	= 512;
+		pNFC->NFC_IREQ = 0x77;	// pNFC->NFC_IREQ_FLAG1;
+		pNFC->NFC_PSTART = 0;
+		
+		i = 128;
+		do {
+			while (!( pNFC->NFC_CTRL & HwNFC_CTRL_FS_RDY ));
+			
+			if ( bAlignAddr )
+			{
+				pNFC->NFC_LDATA = *pPageDW;++pPageDW;
+			}	
+			else
+			{
+				uDWordByte.BYTE[0] = *pPageB;++pPageB;
+				uDWordByte.BYTE[1] = *pPageB;++pPageB;
+				uDWordByte.BYTE[2] = *pPageB;++pPageB;
+				uDWordByte.BYTE[3] = *pPageB;++pPageB;
+				pNFC->NFC_LDATA	= uDWordByte.DWORD;					
+			}
+		}while(--i);
+
+		while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+		
+		//----------------------------------------------
+		//	DMA ACCESS
+		//----------------------------------------------
+		#elif defined( NAND_IO_USE_DMA_ACCESS )
+		/* Setup ECC Block */
+		if ( nEccOnOff == ECC_ON )
+		{
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&pNFC->NFC_LDATA );
+			#endif
+			pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );
+			pECC->ECC_CLEAR	= 0x00000000;
+		}
+
+		#if defined(_LINUX_) || defined(_WINCE_)
+		NAND_IO_SetupDMA( (void*)pDataBuffer, 4, 0,
+						  (void*)&NAND_IO_HwLDATA_PA, 0, 0,
+						  NAND_IO_DMA_WRITE, 512 );
+		#else
+		NAND_IO_SetupDMA( (void*)pDataBuffer, 4, 0,
+						  (void*)&pNFC->NFC_LDATA, 0, 0,
+						  NAND_IO_DMA_WRITE, 512 );
+		#endif
+
+		if ( bAlignAddr ) 
+			pPageDW += 128;
+		else
+			pPageB += 512;
+
+		#endif
+		//####################################################
+		//####################################################
+
+		/* Get Spare Buffer */
+		pSpareBuffer = ( bAlignAddr ) ? (unsigned char*)pSpareDW : (unsigned char*)pSpareB;
+
+		/*	Load ECC code from ECC block */
+		if ( nEccOnOff == ECC_ON )
+		{
+			res = NAND_IO_EncodeNBECC( nDevInfo->EccType, pSpareBuffer );
+			if ( res != SUCCESS )
+				goto ErrorWrite528Data;
+		}
+
+		/* Write 16Bytes spare data */
+		i = 4;
+		do {
+			if ( bAlignAddr )
+			{
+				pNFC->NFC_WDATA = *pSpareDW;++pSpareDW;
+			}	
+			else
+			{
+				uDWordByte.BYTE[0]	= *pSpareB;++pSpareB;
+				uDWordByte.BYTE[1]	= *pSpareB;++pSpareB;
+				uDWordByte.BYTE[2]	= *pSpareB;++pSpareB;
+				uDWordByte.BYTE[3]	= *pSpareB;++pSpareB;
+				pNFC->NFC_WDATA = uDWordByte.DWORD;
+			}
+		}while(--i);
+	}
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+ErrorWrite528Data:
+	return res;
+
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      static __inline NAND_IO_ERROR NAND_IO_Write512DataMTD( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nWritePPSize,
+*      													U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			nDevInfo	= 
+*			nEccOnOff	= 
+*			nPageBuffer	= 
+*			nSpareBuffer	= 
+*			nStartPPage	= 
+*			nWritePPSize	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+*  REMARK:	  by nemo
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_Write512DataMTD( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nWritePPSize,
+												       U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff )
+{
+	unsigned int		i, j;
+	unsigned char		bAlignAddr;
+	unsigned int		nECCDataSize;
+	#ifdef _LINUX_
+	unsigned char 		nDummyPageBuffer[512]__attribute__((aligned(8)));
+	#else
+	unsigned char 		nDummyPageBuffer[512];
+	#endif
+	unsigned int		ColumnAddr;
+	unsigned char		*pPageB = 0, *pSpareB = 0;
+	unsigned int		*pPageDW = 0, *pSpareDW = 0;
+	unsigned char		*pDataBuffer;
+	DWORD_BYTE			uDWordByte;
+	NAND_IO_ECC_INFO	*pECC_Info;	
+	NAND_IO_ERROR		res;
+
+	if ( ( nStartPPage + nWritePPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	res = (NAND_IO_ERROR)SUCCESS;
+
+	//=========================================================================
+	// Check Align of PageBuffer Address
+	//=========================================================================
+	bAlignAddr		= ( (unsigned int)nPageBuffer & 3 ) ? 0 : 1;
+
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	//=========================================================================
+	// Get Buffer Pointer
+	//=========================================================================
+	/* Adapt type of address */
+	if ( bAlignAddr )
+		pPageDW		= (unsigned int*)nPageBuffer;
+	else
+		pPageB		= (unsigned char*)nPageBuffer;
+
+	if ( nDevInfo->Feature.MediaType & A_MLC )
+		nECCDataSize = 8;
+	else if ( ( nDevInfo->Feature.MediaType & A_MLC_8BIT ) || ( nDevInfo->Feature.MediaType & A_MLC_12BIT ) )
+		nECCDataSize = 20;
+	
+	// Set SpareBuffer Pointer =>> ECCBuffer
+	if ( ( nDevInfo->Feature.MediaType  & A_BIG ) || (( nDevInfo->Feature.MediaType  & A_SMALL ) && ( nDevInfo->Feature.MediaType  & A_PARALLEL )))
+	{
+		memset( gNAND_IO_ShareEccBuffer, 0xFF, nECCDataSize << 2 );		
+		pSpareB		= (unsigned char*)&gNAND_IO_ShareEccBuffer[0];
+	}
+	else
+	{
+		pSpareB		= (unsigned char*)nSpareBuffer;
+		pSpareB 	+= NAND_IO_SPARE_SIZE_SMALL;
+	}
+
+	//=========================================================================
+	// Empty Page ECCBuffer Pointer Increment
+	//=========================================================================
+	for ( j = 0; j < nStartPPage; ++j )
+	{
+		if ( nDevInfo->EccType == MLC_ECC_4BIT_TYPE )
+			pECC_Info = &gMLC_ECC_4Bit;
+		else if ( nDevInfo->EccType == MLC_ECC_8BIT_TYPE )
+			pECC_Info = &gMLC_ECC_8Bit;
+		else if ( nDevInfo->EccType == MLC_ECC_12BIT_TYPE )
+			pECC_Info = &gMLC_ECC_12Bit;
+		else if ( nDevInfo->EccType == MLC_ECC_14BIT_TYPE )
+			pECC_Info = &gMLC_ECC_14Bit;
+		else if ( nDevInfo->EccType == MLC_ECC_16BIT_TYPE )
+			pECC_Info = &gMLC_ECC_16Bit;
+		else
+			return ERR_NAND_IO_WRONG_PARAMETER;
+
+		memcpy(	(void*)pSpareB, (void*)pECC_Info->All_FF_512_ECC_Code, nECCDataSize);
+
+		pSpareB += nECCDataSize;
+	}
+
+	//----------------------------------------------
+	//	Write Data as 512Bytes repeatly
+	//----------------------------------------------
+	for ( j = 0; j < nWritePPSize; ++j )
+	{
+		/* Get Data Buffer */
+		pDataBuffer = ( bAlignAddr ) ? (unsigned char*)pPageDW : (unsigned char*)pPageB;
+
+		//####################################################
+		//#	Write 512 Page Data
+		//####################################################
+		//----------------------------------------------
+		//	MCU ACCESS
+		//----------------------------------------------
+		#if defined( NAND_IO_USE_MCU_ACCESS )
+		if ( nEccOnOff == ECC_ON )
+		{
+			/* Setup ECC Block */
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&pNFC->NFC_LDATA );
+			#endif
+			pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );
+			pECC->ECC_CLEAR	= 0x00000000;
+		}
+
+		/* Write 512 Data Area */
+		BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
+		pNFC->NFC_DSIZE		= 512;
+		pNFC->NFC_IREQ 		= 0x77;	// pNFC->NFC_IREQ_FLAG1;		
+		pNFC->NFC_PSTART 	= 0;
+		
+		i = 128;
+		do {
+			while (!( pNFC->NFC_CTRL & HwNFC_CTRL_FS_RDY ));
+			
+			if ( bAlignAddr )
+			{
+				pNFC->NFC_LDATA = *pPageDW;++pPageDW;
+			}	
+			else
+			{
+				uDWordByte.BYTE[0] = *pPageB;++pPageB;
+				uDWordByte.BYTE[1] = *pPageB;++pPageB;
+				uDWordByte.BYTE[2] = *pPageB;++pPageB;
+				uDWordByte.BYTE[3] = *pPageB;++pPageB;
+				pNFC->NFC_LDATA	= uDWordByte.DWORD;
+			}
+		}while(--i);
+		
+		while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+
+		//----------------------------------------------
+		//	DMA ACCESS
+		//----------------------------------------------
+		#elif defined( NAND_IO_USE_DMA_ACCESS )
+		if ( nEccOnOff == ECC_ON )
+		{
+			/* Setup ECC Block */
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&pNFC->NFC_LDATA );
+			#endif
+			pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );
+			pECC->ECC_CLEAR	= 0x00000000;
+		}
+
+		#if defined(_LINUX_) || defined(_WINCE_)
+		NAND_IO_SetupDMA( (void*)pDataBuffer, 4, 0,
+						  (void*)&NAND_IO_HwLDATA_PA, 0, 0,
+						  NAND_IO_DMA_WRITE, 512 );
+		#else
+		NAND_IO_SetupDMA( (void*)pDataBuffer, 4, 0,
+						  (void*)&pNFC->NFC_LDATA, 0, 0,
+						  NAND_IO_DMA_WRITE, 512 );
+		#endif
+	
+		if ( bAlignAddr )
+			pPageDW += 128;
+		else
+			pPageB += 512;
+
+		#endif
+		//####################################################
+		//####################################################
+
+		/*	Load ECC code from ECC block */
+		if ( nEccOnOff == ECC_ON )
+		{
+			res = NAND_IO_EncodeECC( nDevInfo->EccType, pSpareB );
+			if ( res != SUCCESS )
+				goto ErrorWrite512Data;
+		}
+
+		pSpareB += nECCDataSize;
+	}
+
+	//=========================================================================
+	// Empty PPage Write
+	//=========================================================================
+	if ( ( nStartPPage + nWritePPSize ) != ( nDevInfo->PPages ) )
+	{
+		if ( nDevInfo->Feature.MediaType & A_BIG )
+		{
+			/* Change Cycle */
+			NAND_IO_SetCommCycleTime();
+			
+			//---------------------------------
+			// Random Data Input [ 0x85 ]
+			//---------------------------------
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8585;
+
+			//---------------------------------
+			// Write Column Address
+			//---------------------------------
+			ColumnAddr = nDevInfo->Feature.PageSize;
+			ColumnAddr	= ( nDevInfo->Feature.MediaType & A_PARALLEL ) ? (ColumnAddr >> 1) : ColumnAddr;
+			NAND_IO_WriteColAddr( ColumnAddr, nDevInfo );
+
+			//---------------------------------
+			// ECC Data Clear
+			//---------------------------------
+			for ( j = 0; j < (U16)( nDevInfo->PPages - ( nStartPPage + nWritePPSize ) ); ++j )
+			{
+				if ( nDevInfo->EccType == MLC_ECC_4BIT_TYPE )
+					pECC_Info = &gMLC_ECC_4Bit;
+				else if ( nDevInfo->EccType == MLC_ECC_8BIT_TYPE )
+					pECC_Info = &gMLC_ECC_8Bit;
+				else if ( nDevInfo->EccType == MLC_ECC_12BIT_TYPE )
+					pECC_Info = &gMLC_ECC_12Bit;
+				else if ( nDevInfo->EccType == MLC_ECC_14BIT_TYPE )
+					pECC_Info = &gMLC_ECC_14Bit;
+				else if ( nDevInfo->EccType == MLC_ECC_16BIT_TYPE )
+					pECC_Info = &gMLC_ECC_16Bit;
+				else
+					return ERR_NAND_IO_WRONG_PARAMETER;
+
+				memcpy(	(void*)pSpareB, (void*)pECC_Info->All_FF_512_ECC_Code, nECCDataSize);
+
+				pSpareB += nECCDataSize;	
+			}
+		}
+		else
+		{
+			memset( nDummyPageBuffer, 0xFF, 512 );
+			//Write Dummy Data
+			for ( j = 0; j < (U16)( nDevInfo->PPages - ( nStartPPage + nWritePPSize ) ); ++j )
+			{
+				//####################################################
+				//#	Write 512 Page Data
+				//####################################################
+				//----------------------------------------------
+				//	MCU ACCESS
+				//----------------------------------------------
+				#if defined( NAND_IO_USE_MCU_ACCESS )
+				/* Setup ECC Block */
+				if ( nEccOnOff == ECC_ON )
+				{
+					#if defined(_WINCE_) || defined(_LINUX_)
+					NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+					#else
+					NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&pNFC->NFC_LDATA );
+					#endif
+					pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );		// Data Size...
+					pECC->ECC_CLEAR	= 0x00000000;
+				}
+
+				/* Write 512 Data Area */
+				BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
+				pNFC->NFC_DSIZE	= 512;
+				pNFC->NFC_IREQ = 0x77;	// pNFC->NFC_IREQ_FLAG1;		
+				pNFC->NFC_PSTART = 0;
+				
+				i = 128;
+				do
+				{
+					while (!( pNFC->NFC_CTRL & HwNFC_CTRL_FS_RDY ));
+					pNFC->NFC_LDATA = 0xFFFFFFFF;
+				}while(--i);
+				
+				while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+				
+				//----------------------------------------------
+				//	DMA ACCESS
+				//----------------------------------------------
+				#elif defined( NAND_IO_USE_DMA_ACCESS )
+				/* Setup ECC Block */
+				if ( nEccOnOff == ECC_ON )
+				{
+					#if defined(_WINCE_) || defined(_LINUX_)
+					NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+					#else
+					NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&pNFC->NFC_LDATA );
+					#endif
+					pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );		// Data Size...
+					pECC->ECC_CLEAR	= 0x00000000;
+				}
+				
+				#if defined(_LINUX_) || defined(_WINCE_)
+				NAND_IO_SetupDMA( (void*)nDummyPageBuffer, 4, 0,
+								  (void*)&NAND_IO_HwLDATA_PA, 0, 0,
+								  NAND_IO_DMA_WRITE, 512 );
+				#else
+				NAND_IO_SetupDMA( (void*)nDummyPageBuffer, 4, 0,
+								  (void*)&pNFC->NFC_LDATA, 0, 0,
+								  NAND_IO_DMA_WRITE, 512 );
+				#endif
+
+				#endif
+				//####################################################
+				//####################################################
+				/*	Load ECC code from ECC block */
+				if ( nEccOnOff == ECC_ON )
+				{
+					res = NAND_IO_EncodeECC( nDevInfo->EccType, pSpareB );
+					if ( res != SUCCESS )
+						goto ErrorWrite512Data;
+				}
+
+				pSpareB += nECCDataSize;		
+			}			
+		}
+	}
+	
+	//=========================================================================
+	// Write Spare Data
+	//=========================================================================
+	/* Change Cycle */
+	NAND_IO_SetWriteCycleTime();
+
+	NAND_IO_WriteSpareDataMTD( nDevInfo, nSpareBuffer, PAGE_ECC_ON );
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+
+ErrorWrite512Data:
+	return res;
+
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_WriteUserSizeData( NAND_IO_DEVINFO *nDevInfo, U16 nColumnAddr, U32 nWriteSize, U8 *nWriteBuffer );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nColumnAddr	= 
+*			nDevInfo	= 
+*			nWriteBuffer	= 
+*			nWriteSize	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_WriteUserSizeData( NAND_IO_DEVINFO *nDevInfo, U16 nColumnAddr, U32 nWriteSize, U8 *nWriteBuffer )
+{
+	unsigned int		*dwPageB;
+	unsigned char		*pPageB;
+	DWORD_BYTE			uDWordByte;
+	
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+	
+	//=========================================================================
+	// Check Parameter
+	//=========================================================================
+	if ( (U32)( nColumnAddr + nWriteSize ) > (U32)( nDevInfo->Feature.PageSize + nDevInfo->Feature.SpareSize ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================	
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//=========================================================================
+	// Write UserSize Data
+	//=========================================================================
+	pPageB = (unsigned char*)nWriteBuffer;
+	dwPageB = (unsigned int*)nWriteBuffer;
+
+	if ( nWriteSize >= 4 )
+	{
+		#ifdef USE_NFC_LDATA		/* 08.12.17 */
+		BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
+		pNFC->NFC_DSIZE		= nWriteSize;
+		pNFC->NFC_IREQ	 	= 0x77;	// pNFC->NFC_IREQ_FLAG1;
+		pNFC->NFC_PSTART 	= 0;		
+
+		do {
+			while (!( pNFC->NFC_IREQ & HwNFC_CTRL_FS_RDY ));
+			
+			{
+				uDWordByte.BYTE[0] = *pPageB;++pPageB;
+				uDWordByte.BYTE[1] = *pPageB;++pPageB;
+				uDWordByte.BYTE[2] = *pPageB;++pPageB;
+				uDWordByte.BYTE[3] = *pPageB;++pPageB;
+				pNFC->NFC_LDATA	= uDWordByte.DWORD;
+			}
+			nWriteSize -= 4;
+		}while(nWriteSize);
+		
+		while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+	}
+	else
+	{
+		#endif
+
+		if ( pNFC->NFC_CTRL1 & Hw31 )
+			BITCLR( pNFC->NFC_CTRL1, Hw31 );
+
+		while ( nWriteSize )
+		{
+			/* Write as DWORD */
+			if ( nWriteSize >= 4 )
+			{
+				uDWordByte.BYTE[0] = *pPageB;++pPageB;
+				uDWordByte.BYTE[1] = *pPageB;++pPageB;
+				uDWordByte.BYTE[2] = *pPageB;++pPageB;
+				uDWordByte.BYTE[3] = *pPageB;++pPageB;
+				WORD_OF(pNFC->NFC_WDATA) = uDWordByte.DWORD;
+				nWriteSize -= 4;
+			}
+			/* Write as WORD */
+			else if ( nWriteSize >= 2 )
+			{
+				uDWordByte.BYTE[0] = *pPageB;++pPageB;
+				uDWordByte.BYTE[1] = *pPageB;++pPageB;
+				HWORD_OF(pNFC->NFC_WDATA) = uDWordByte.WORD[0];
+				nWriteSize -= 2;
+			}
+			/* Write as BYTE */			
+			else
+			{
+				uDWordByte.BYTE[0] = *pPageB;++pPageB;
+				BYTE_OF(pNFC->NFC_WDATA) = uDWordByte.BYTE[0];
+				nWriteSize -= 1;
+			}
+		}
+
+		if ( pNFC->NFC_CTRL1 & Hw30 )
+			BITSET( pNFC->NFC_CTRL1, Hw31 );
+		
+	}
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+	return (NAND_IO_ERROR)SUCCESS;
+
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_GetShiftValueForFastMultiPly( U16 nValue, U16* rFactor );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nValue	= 
+*			rFactor	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_GetShiftValueForFastMultiPly( U16 nValue, U16* rFactor )
+{
+	unsigned short int	i;
+
+	*rFactor = 0;
+	
+	for ( i = 0; i < NAND_IO_MAX_SHIFT_FACTOR_FOR_MULTIPLY; ++i )
+	{
+		if ( NAND_IO_ShiftFactorForMultiplay[i] == nValue )
+		{
+			*rFactor = i;
+			break;
+		}
+	}
+
+	if ( i >= NAND_IO_MAX_SHIFT_FACTOR_FOR_MULTIPLY )
+		return ERR_NAND_IO_FAILED_GET_SHIFT_FACTOR_FOR_MULTIPLY;
+
+	return (NAND_IO_ERROR)SUCCESS;	
+}	
+
+NAND_IO_ERROR NAND_IO_LBA_SetCallBackHandler( NAND_LBA_CALLBACK_HANDLER pCallBackHandler )
+{
+	NAND_IO_LBA_CallBackLcdDisplay = pCallBackHandler;
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_GetDeviceInfo( NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned short int		j,k,l;
+	unsigned char			bFindMedia;
+	unsigned char			bFindMakerNo;
+	unsigned char			bMatchCount;
+	unsigned char			rBootMode, rRebootCmd;
+	NAND_IO_DEVID			sDeviceCode;
+	NAND_IO_FEATURE			*sTempFeatureInfo;
+	NAND_IO_FEATURE			*sFindFeatureInfo;
+	NAND_IO_ERROR			res;
+
+	bFindMedia 				= FALSE;
+	sTempFeatureInfo		= (NAND_IO_FEATURE*)LBA_NAND_SupportMakerInfo.DevInfo[0];
+	sFindFeatureInfo		= (NAND_IO_FEATURE*)LBA_NAND_SupportMakerInfo.DevInfo[0];
+
+	NAND_IO_LBA_DeviceReboot( nDevInfo );
+ 	res = NAND_IO_GetDeviceInfo( 0, nDevInfo );
+	if ( res != SUCCESS )
+		return ERR_NAND_IO_FAILED_GET_DEVICE_INFO;
+
+	if (!( nDevInfo->Feature.MediaType & S_LBA ))
+		return ERR_NAND_IO_FAILED_GET_DEVICE_INFO;
+
+	res = NAND_IO_LBA_ModeChange( nDevInfo, NAND_LBA_BCM );
+	if ( res != SUCCESS )
+	{
+		NAND_IO_LBA_DeviceReboot( nDevInfo );
+		res = NAND_IO_LBA_ModeChange( nDevInfo, NAND_LBA_BCM );
+		if ( res != SUCCESS )
+			return res;
+	}
+	
+	NAND_IO_LBA_GetPersistentFunction( nDevInfo, &rBootMode, &rRebootCmd );
+
+	if ( ( rBootMode != 0x22 ) || ( rRebootCmd != 0xAF ))
+	{
+		rBootMode = 0x22;
+		rRebootCmd = 0xAF;
+
+		NAND_IO_LBA_SetBootModeChange( nDevInfo, rBootMode );
+		NAND_IO_LBA_SetRebootCmdChange( nDevInfo, rRebootCmd );		
+		NAND_IO_LBA_DeviceReboot( nDevInfo );
+	}
+
+	NAND_IO_LBA_ModeChange( nDevInfo, NAND_LBA_MDP );
+	NAND_IO_LBA_SetTransferProtocol( nDevInfo, 0x04, 0x00 );
+	
+	nDevInfo->LBAInfo.Usable = DISABLE;
+	//=====================================================================
+	// Search Matched NANDFLASH
+	//=====================================================================
+	for ( j = 0; j < 3; ++j )	/* Check Read ID during 3 turn */
+	{
+		/* Read Device CODE */
+		NAND_IO_LBA_ReadID( nDevInfo, &sDeviceCode);
+
+		/* Check Maker ID */
+		bFindMakerNo = 0xFF;
+		for ( k = 0; k < MAX_SUPPORT_MAKER_LBA_NAND; ++k )
+		{
+			if ( sDeviceCode.Code[0] == LBA_NAND_SupportMakerInfo.MakerID[k] )
+			{
+				bFindMakerNo		= (unsigned char)k;
+				sTempFeatureInfo	= (NAND_IO_FEATURE*)LBA_NAND_SupportMakerInfo.DevInfo[k];
+				break;
+			}
+		}
+
+		if ( bFindMakerNo >= MAX_SUPPORT_MAKER_NAND )
+			continue;
+
+		/* Check Device ID */
+		for ( k = 0; k < LBA_NAND_SupportMakerInfo.MaxSupportNAND[bFindMakerNo]; ++k )
+		{
+			bMatchCount = 0;
+			
+			for ( l = 0; l < 4; ++l )
+			{
+				if ( sTempFeatureInfo->DeviceID.Code[l+1] == 0x00 )
+					++bMatchCount;
+				else if ( sDeviceCode.Code[l+1] == sTempFeatureInfo->DeviceID.Code[l+1] )
+					++bMatchCount;
+			}
+
+			/* Found NAND Device */
+			if ( bMatchCount >= 4 )
+			{
+				bFindMedia = TRUE;
+				sFindFeatureInfo = sTempFeatureInfo;
+				break;
+			}
+			else
+				++sTempFeatureInfo;
+		}
+
+		/* Found NAND Device */
+		if ( bFindMedia == TRUE )
+			break;
+	}
+
+	if ( bFindMedia == TRUE )
+		return (NAND_IO_ERROR)SUCCESS;
+	//=====================================================================
+	// Not Found
+	//=====================================================================
+	else
+		return ERR_NAND_IO_FAILED_GET_DEVICE_INFO;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_Init( NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned short int		j,k,l;
+	unsigned char			bFindMedia;
+	unsigned char			bFindMakerNo;
+	unsigned char			bMatchCount;
+	unsigned char			rBootMode, rRebootCmd;
+	NAND_IO_DEVID			sDeviceCode;
+	NAND_IO_FEATURE			*sTempFeatureInfo;
+	NAND_IO_FEATURE			*sFindFeatureInfo;
+	NAND_IO_ERROR			res;
+	
+	bFindMedia 				= FALSE;
+	sTempFeatureInfo		= (NAND_IO_FEATURE*)LBA_NAND_SupportMakerInfo.DevInfo[0];
+	sFindFeatureInfo		= (NAND_IO_FEATURE*)LBA_NAND_SupportMakerInfo.DevInfo[0];
+
+	NAND_IO_LBA_DeviceReboot( nDevInfo );
+ 	NAND_IO_GetDeviceInfo( 0, nDevInfo );
+
+	res = NAND_IO_LBA_ModeChange( nDevInfo, NAND_LBA_BCM );
+	if ( res != SUCCESS )
+	{
+		NAND_IO_LBA_DeviceReboot( nDevInfo );
+		res = NAND_IO_LBA_ModeChange( nDevInfo, NAND_LBA_BCM );
+		if ( res != SUCCESS )
+			return res;
+	}
+	
+	NAND_IO_LBA_GetPersistentFunction( nDevInfo, &rBootMode, &rRebootCmd );
+
+	if ( ( rBootMode != 0x22 ) || ( rRebootCmd != 0xAF ))
+	{
+		rBootMode = 0x22;
+		rRebootCmd = 0xAF;
+
+		NAND_IO_LBA_SetBootModeChange( nDevInfo, rBootMode );
+		NAND_IO_LBA_SetRebootCmdChange( nDevInfo, rRebootCmd );		
+		NAND_IO_LBA_DeviceReboot( nDevInfo );
+	}
+
+	NAND_IO_LBA_ModeChange( nDevInfo, NAND_LBA_MDP );
+	NAND_IO_LBA_SetTransferProtocol( nDevInfo, 0x04, 0x00 );
+	
+	nDevInfo->LBAInfo.Usable = DISABLE;
+	//=====================================================================
+	// Search Matched NANDFLASH
+	//=====================================================================
+	for ( j = 0; j < 3; ++j )	/* Check Read ID during 3 turn */
+	{
+		/* Read Device CODE */
+		NAND_IO_LBA_ReadID( nDevInfo, &sDeviceCode);
+
+		/* Check Maker ID */
+		bFindMakerNo = 0xFF;
+		for ( k = 0; k < MAX_SUPPORT_MAKER_LBA_NAND; ++k )
+		{
+			if ( sDeviceCode.Code[0] == LBA_NAND_SupportMakerInfo.MakerID[k] )
+			{
+				bFindMakerNo		= (unsigned char)k;
+				sTempFeatureInfo	= (NAND_IO_FEATURE*)LBA_NAND_SupportMakerInfo.DevInfo[k];
+				break;
+			}
+		}
+
+		if ( bFindMakerNo >= MAX_SUPPORT_MAKER_NAND )
+			continue;
+
+		/* Check Device ID */
+		for ( k = 0; k < LBA_NAND_SupportMakerInfo.MaxSupportNAND[bFindMakerNo]; ++k )
+		{
+			bMatchCount = 0;
+			
+			for ( l = 0; l < 4; ++l )
+			{
+				if ( sTempFeatureInfo->DeviceID.Code[l+1] == 0x00 )
+					++bMatchCount;
+				else if ( sDeviceCode.Code[l+1] == sTempFeatureInfo->DeviceID.Code[l+1] )
+					++bMatchCount;
+			}
+
+			/* Found NAND Device */
+			if ( bMatchCount >= 4 )
+			{
+				bFindMedia = TRUE;
+				sFindFeatureInfo = sTempFeatureInfo;
+				break;
+			}
+			else
+				++sTempFeatureInfo;
+		}
+
+		/* Found NAND Device */
+		if ( bFindMedia == TRUE )
+			break;
+	}
+
+	if ( bFindMedia == TRUE )
+	{
+		// Get Protocol
+		NAND_IO_LBA_GetTransferProtocol( nDevInfo, &nDevInfo->LBAInfo.TransProtocol1, &nDevInfo->LBAInfo.TransProtocol2 );
+
+		// Data Format
+		if ( nDevInfo->LBAInfo.TransProtocol1 & NAND_PROT1_SPARE_INCLUDE )
+			nDevInfo->LBAInfo.DataTransferCheck = ENABLE;
+		else
+			nDevInfo->LBAInfo.DataTransferCheck = DISABLE;
+
+		// Sector Count
+		nDevInfo->LBAInfo.SectorCount = ( nDevInfo->LBAInfo.TransProtocol1 & NAND_PROT1_SECTOR_COUNT_MASK );
+
+		if ( nDevInfo->LBAInfo.SectorCount != 1 )
+			nDevInfo->LBAInfo.SectorCount = nDevInfo->LBAInfo.SectorCount << 1;
+		
+		// Set Power Save Mode
+		NAND_IO_LBA_PowerSaveMode( nDevInfo, DISABLE );
+
+		// Set High Speed Mode
+		NAND_IO_LBA_HighSpeedMode( nDevInfo, ENABLE );
+
+		NAND_IO_LBA_VFPGetTotalSectorSize( nDevInfo, (U32 *)&nDevInfo->LBAInfo.VFPSectorSize );
+		if ( ( nDevInfo->LBAInfo.VFPSectorSize << 9 ) < gMAX_ROMSIZE )
+		{
+			// LBA Factory Setting values : 8 Mbyte
+			res = NAND_IO_LBA_VFPChangeSectorSize( nDevInfo, gMAX_ROMSIZE >> 9 );
+			if ( res != SUCCESS )
+				return res;
+
+			NAND_IO_LBA_VFPGetTotalSectorSize( nDevInfo, (U32 *)&nDevInfo->LBAInfo.VFPSectorSize );		
+		}
+
+		// Get Size Info
+		NAND_IO_LBA_MDPGetTotalSectorSize( nDevInfo, (unsigned long int *)&nDevInfo->LBAInfo.MDPSectorSize );
+
+		res = NAND_IO_LBA_VFPInitArea( nDevInfo );
+		if ( res != SUCCESS )
+			return res;
+
+		nDevInfo->LBAInfo.Usable = ENABLE;		
+	}
+	//=====================================================================
+	// Not Found
+	//=====================================================================
+	else
+	{
+		return ERR_NAND_IO_FAILED_GET_DEVICE_INFO;
+	}
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+U32 NAND_IO_LBA_GetSerialNumber( NAND_IO_DEVINFO *nDevInfo, U8* nPageBuffer, U8* rSerialNumber, U16 nSize )
+{
+	unsigned int		j;
+	unsigned int		dwIDSize;
+	unsigned char		ucTempData[64];
+	unsigned char		*cPageBuffer;
+	unsigned char		*cSpareBuffer;
+	NAND_IO_ERROR		res;
+
+	cPageBuffer		= &nPageBuffer[0];
+	cSpareBuffer	= &nPageBuffer[nDevInfo->Feature.PageSize];
+	nSize = 0;
+
+	NAND_IO_LBA_ModeChange( nDevInfo, NAND_LBA_BCM );
+
+	res = NAND_IO_ReadGoldenPage( nDevInfo, 0, cPageBuffer, cSpareBuffer );
+	if ( res != SUCCESS)
+		return ERR_NAND_IO_WRONG_PARAMETER;
+	
+	memcpy( ucTempData, &nPageBuffer[ ( 512 + 16 ) * ( nDevInfo->PPages - 1 ) ], 64 );
+
+	dwIDSize = 32;
+	
+	for ( j = 0; j < dwIDSize; ++j )
+		rSerialNumber[j] = ucTempData[j];
+
+	return dwIDSize;	
+}
+
+NAND_IO_ERROR NAND_IO_LBA_GetTotalSecAndCHS( NAND_IO_DEVINFO *nDevInfo, int nPartition, U32 *rTotalSec, U16 *rCylinder, U16 *rHead, U8 *rSector )
+{
+	unsigned long int		nTotalSectorSize;
+	unsigned short int		wCurrHead;
+	unsigned short int		wCurrCylinder;
+
+	if ( nPartition == NAND_LBA_DATA_AREA )
+		nTotalSectorSize = nDevInfo->LBAInfo.DTAreaSectorSize;
+	else if ( nPartition == NAND_LBA_HIDDEN_AREA )
+		nTotalSectorSize = nDevInfo->LBAInfo.HDAreaSectorSize;
+	else if ( nPartition == NAND_LBA_MDP )
+		nTotalSectorSize = nDevInfo->LBAInfo.MDPSectorSize;
+	else if ( nPartition == NAND_LBA_VFP )
+		nTotalSectorSize = nDevInfo->LBAInfo.VFPSectorSize;
+	else
+		nTotalSectorSize = 0;
+
+	if ( nTotalSectorSize == 0 )
+	{
+	    *rTotalSec	= 0;
+	    *rCylinder	= 0;
+	    *rHead		= 0;
+	    *rSector	= 0;
+		
+		return (NAND_IO_ERROR)SUCCESS;
+	}
+		
+	if  ( nTotalSectorSize >= (U32)( 1024 * 256 * 64 ) )
+	{
+	    *rTotalSec	= nTotalSectorSize;
+	    *rCylinder	= (U16)(nTotalSectorSize / ( 256 * 64 ));
+	    *rHead		= 256;
+	    *rSector	= 64;
+	}
+	else
+	{
+		for ( wCurrHead = 2; wCurrHead <= 256; wCurrHead *= 2 )
+		{
+			wCurrCylinder = (U16)(nTotalSectorSize / ( wCurrHead * 64 ));
+
+			if ( wCurrCylinder > 1024 )
+				continue;
+
+			*rTotalSec	= (U32)( wCurrCylinder * wCurrHead * 64 );
+			*rCylinder	= wCurrCylinder;
+			*rHead		= wCurrHead;
+			*rSector	= 64;
+
+			break;
+		}
+	}
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_ReadSectorBy4Byte( NAND_IO_DEVINFO *nDevInfo, U8 nPartition, U32 nSectorAddr, U16 nOffset, U16 nReadSize, U8 *nReadBuffer )
+{
+	unsigned short int		wCurrPPSize;
+	unsigned short int		wFlagFirstSector;
+	unsigned long int 		dwSectorAddr;
+	unsigned long int		dwTotalReadSecSize;
+	unsigned long int		nTotalSectorSize;
+	unsigned long int		dwSectorAddrOffSet;
+	unsigned char			cReadBuffer[512];
+	unsigned char			cSpareBuffer[16];
+	unsigned char			*pReadBuffer;
+	unsigned char			cPartition;	
+	NAND_IO_ERROR			res;
+
+	//######################################################
+	//# Check Parameter
+	//######################################################
+	if ( nDevInfo->LBAInfo.Usable != ENABLE )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	cPartition = nPartition & 0x0F;
+
+	if ( nDevInfo->LBAInfo.CurrentMode != cPartition )
+		NAND_IO_LBA_ModeChange( nDevInfo, cPartition );
+	
+	if ( nPartition == NAND_LBA_DATA_AREA )
+	{
+		nTotalSectorSize 	= nDevInfo->LBAInfo.DTAreaSectorSize;
+		dwSectorAddrOffSet 	= 0;		
+	}
+	else if ( nPartition == NAND_LBA_HIDDEN_AREA )
+	{
+		nTotalSectorSize = nDevInfo->LBAInfo.HDAreaSectorSize;
+		dwSectorAddrOffSet 	= nDevInfo->LBAInfo.HDAreaAddrOffSet;
+	}
+	else if ( nPartition == NAND_LBA_MULTI_HIDDEN_AREA_0 )
+	{
+		nTotalSectorSize 	= nDevInfo->LBAInfo.MHDAreaSectorSize[0];
+		dwSectorAddrOffSet 	= nDevInfo->LBAInfo.MHDAreaAddrOffSet[0];
+	}	
+	else if ( nPartition == NAND_LBA_MDP )
+	{
+		nTotalSectorSize = nDevInfo->LBAInfo.MDPSectorSize;
+		dwSectorAddrOffSet 	= 0;
+	}
+	else if ( nPartition == NAND_LBA_VFP )
+	{
+		nTotalSectorSize = nDevInfo->LBAInfo.VFPSectorSize;
+		dwSectorAddrOffSet 	= 1;
+	}
+	else
+	{
+		nTotalSectorSize = 0;
+		dwSectorAddrOffSet 	= 0;
+		return ERR_NAND_IO_WRONG_PARAMETER;
+	}
+	
+	if ( ( nSectorAddr + 1 ) > nTotalSectorSize )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	if (( !nReadSize ) || (( nOffset + nReadSize ) > 128 ))
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	pReadBuffer			= nReadBuffer;
+
+	wFlagFirstSector = TRUE;
+	
+	/* Pre Process */
+	NAND_IO_PreProcess();
+	
+	/* Set Setuo Time and Hold Time */
+	NAND_IO_SetCommCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	//NAND_IO_DisableWriteProtect();
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//######################################################
+	//# Get Info of Parameter
+	//######################################################
+	dwSectorAddr		= nSectorAddr;
+	dwSectorAddr		+= dwSectorAddrOffSet;	
+	dwTotalReadSecSize  = 1;
+
+	if ( dwTotalReadSecSize < nDevInfo->LBAInfo.SectorCount )
+		wCurrPPSize = (U16)dwTotalReadSecSize;
+	else
+		wCurrPPSize = nDevInfo->LBAInfo.SectorCount ;
+	
+	//######################################################
+	//# Write Total Sector
+	//######################################################
+
+	while ( dwTotalReadSecSize )
+	{	
+		/* Command Page Program #1 [ 0x80 ] */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+
+		if ( wFlagFirstSector == TRUE )
+		{
+			/* Write Sector Size & Sector Address */
+			pNFC->NFC_SADDR= ( 1 & 0xFF );					// Write Sector Num : SC0
+			pNFC->NFC_SADDR= ( ( 1 >> 8 ) & 0xFF );			// Write Sector Num : SC1
+			pNFC->NFC_SADDR= ( dwSectorAddr & 0xFF );				// Write Sector Addr: AD0
+			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 8 ) & 0xFF );		// Write Sector Addr: AD1
+			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 16 ) & 0xFF );		// Write Sector Addr: AD2
+		}
+
+		/* Command Page Program #2 [ 0x10 ] */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+		
+		/* Wait until it is ready */
+		NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+		NAND_IO_SetReadCycleTime();
+		/* Write Data to NAND FLASH */
+		res = NAND_IO_LBA_ReadData( nDevInfo, wCurrPPSize, cReadBuffer, cSpareBuffer );
+		if ( res != SUCCESS )
+			return res;
+
+		NAND_IO_SetCommCycleTime();
+
+		/* Decrease Write Size */
+		dwTotalReadSecSize 	-= wCurrPPSize;
+
+		/* Increase Buffer Address */
+		nReadBuffer			+= ( nDevInfo->LBAInfo.SectorCount << 9 );
+		
+		/* Count Next Page Size */
+		if ( dwTotalReadSecSize < nDevInfo->LBAInfo.SectorCount )
+			wCurrPPSize = (U16)dwTotalReadSecSize;
+		else
+			wCurrPPSize = nDevInfo->LBAInfo.SectorCount;
+
+		if ( nDevInfo->LBAInfo.TransProtocol2 & NAND_PROT2_WRITE_TYPE_B )
+			wFlagFirstSector = FALSE;
+	}
+
+	memcpy( pReadBuffer, &cReadBuffer[nOffset << 2], nReadSize << 2 );
+
+	/* FORCE TO SET WP LOW */
+	//NAND_IO_EnableWriteProtect();
+	
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+	
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_ReadSector( NAND_IO_DEVINFO *nDevInfo, U8 nPartition, U32 nSectorAddr, U16 nSecSize, U8 *nReadBuffer )
+{
+	unsigned short int		wCurrPPSize;
+	unsigned short int		wFlagFirstSector;
+	unsigned long int 		dwSectorAddr;
+	unsigned long int		dwSectorAddrOffSet;
+	unsigned long int		dwTotalReadSecSize;
+	unsigned long int		nTotalSectorSize;
+	unsigned char			cPartition;
+	unsigned char			cSpareBuffer[16];
+	NAND_IO_ERROR			res;
+
+	//######################################################
+	//# Check Parameter
+	//######################################################
+	if ( nDevInfo->LBAInfo.Usable != ENABLE )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	cPartition = nPartition & 0x0F;
+
+	if ( nDevInfo->LBAInfo.CurrentMode != cPartition )
+		NAND_IO_LBA_ModeChange( nDevInfo, cPartition );
+	
+	if ( nPartition == NAND_LBA_DATA_AREA )
+	{
+		nTotalSectorSize 	= nDevInfo->LBAInfo.DTAreaSectorSize;
+		dwSectorAddrOffSet 	= 0;		
+	}
+	else if ( nPartition == NAND_LBA_HIDDEN_AREA )
+	{
+		nTotalSectorSize = nDevInfo->LBAInfo.HDAreaSectorSize;
+		dwSectorAddrOffSet 	= nDevInfo->LBAInfo.HDAreaAddrOffSet;
+	}
+	else if ( nPartition == NAND_LBA_MULTI_HIDDEN_AREA_0 )
+	{
+		nTotalSectorSize 	= nDevInfo->LBAInfo.MHDAreaSectorSize[0];
+		dwSectorAddrOffSet 	= nDevInfo->LBAInfo.MHDAreaAddrOffSet[0];
+	}	
+	else if ( nPartition == NAND_LBA_MDP )
+	{
+		nTotalSectorSize = nDevInfo->LBAInfo.MDPSectorSize;
+		dwSectorAddrOffSet 	= 0;
+	}
+	else if ( nPartition == NAND_LBA_VFP )
+	{
+		nTotalSectorSize = nDevInfo->LBAInfo.VFPSectorSize;
+		dwSectorAddrOffSet 	= 1;
+	}
+	else
+	{
+		nTotalSectorSize = 0;
+		dwSectorAddrOffSet 	= 0;
+		return ERR_NAND_IO_WRONG_PARAMETER;
+	}
+	
+	if ( ( nSectorAddr + nSecSize ) > nTotalSectorSize )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	wFlagFirstSector = TRUE;
+	
+	/* Pre Process */
+	NAND_IO_PreProcess();
+	
+	/* Set Setuo Time and Hold Time */
+	NAND_IO_SetCommCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	//NAND_IO_DisableWriteProtect();
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//######################################################
+	//# Get Info of Parameter
+	//######################################################
+	dwSectorAddr		= nSectorAddr;
+	dwSectorAddr		+= dwSectorAddrOffSet;
+	dwTotalReadSecSize  = nSecSize;
+
+	if ( dwTotalReadSecSize < nDevInfo->LBAInfo.SectorCount )
+		wCurrPPSize = (U16)dwTotalReadSecSize;
+	else
+		wCurrPPSize = nDevInfo->LBAInfo.SectorCount ;
+	
+	//######################################################
+	//# Write Total Sector
+	//######################################################
+
+	while ( dwTotalReadSecSize )
+	{	
+		/* Command Page Program #1 [ 0x80 ] */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+
+		if ( wFlagFirstSector == TRUE )
+		{
+			/* Write Sector Size & Sector Address */
+			pNFC->NFC_SADDR= ( nSecSize & 0xFF );					// Write Sector Num : SC0
+			pNFC->NFC_SADDR= ( ( nSecSize >> 8 ) & 0xFF );			// Write Sector Num : SC1
+			pNFC->NFC_SADDR= ( dwSectorAddr & 0xFF );				// Write Sector Addr: AD0
+			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 8 ) & 0xFF );		// Write Sector Addr: AD1
+			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 16 ) & 0xFF );		// Write Sector Addr: AD2
+		}
+
+		/* Command Page Program #2 [ 0x10 ] */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+		
+		/* Wait until it is ready */
+		NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+		NAND_IO_SetReadCycleTime();
+		/* Write Data to NAND FLASH */
+		res = NAND_IO_LBA_ReadData( nDevInfo, wCurrPPSize, nReadBuffer, cSpareBuffer );
+		if ( res != SUCCESS )
+			return res;
+
+		NAND_IO_SetCommCycleTime();
+
+		/* Decrease Write Size */
+		dwTotalReadSecSize 	-= wCurrPPSize;
+
+		/* Increase Buffer Address */
+		nReadBuffer			+= ( nDevInfo->LBAInfo.SectorCount << 9 );
+		
+		/* Count Next Page Size */
+		if ( dwTotalReadSecSize < nDevInfo->LBAInfo.SectorCount )
+			wCurrPPSize = (U16)dwTotalReadSecSize;
+		else
+			wCurrPPSize = nDevInfo->LBAInfo.SectorCount;
+
+		if ( nDevInfo->LBAInfo.TransProtocol2 & NAND_PROT2_WRITE_TYPE_B )
+			wFlagFirstSector = FALSE;
+	}
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0xFBFB;
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	/* FORCE TO SET WP LOW */
+	//NAND_IO_EnableWriteProtect();
+
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_AREAClear( NAND_IO_DEVINFO *nDevInfo, U8 nPartition )
+{
+	unsigned int			nSectorAddr;
+	unsigned short int		wCurrPPSize;
+	unsigned short int		wFlagFirstSector;
+
+	unsigned short int		wOldProcessRate;		
+	unsigned short int		wProcessRate;
+	unsigned long int		nProCessWriteSectorSize;
+
+	unsigned long int 		dwSectorAddr;
+	unsigned long int		dwSectorAddrOffSet;
+	unsigned short int		wOnceWriteSectorCount;
+	unsigned long int		dwTotalWriteSecSize;
+	unsigned long int		nTotalSectorSize;
+	unsigned long int		nWriteSectorSize;
+	unsigned char			cPartition;
+	NAND_IO_ERROR			res;
+
+	//######################################################
+	//# Check Parameter
+	//######################################################
+	if ( nDevInfo->LBAInfo.Usable != ENABLE )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	cPartition = nPartition & 0x0F;
+
+	if ( nDevInfo->LBAInfo.CurrentMode != cPartition )
+		NAND_IO_LBA_ModeChange( nDevInfo, cPartition );
+
+	if ( nPartition == NAND_LBA_DATA_AREA )
+	{
+		nTotalSectorSize 	= nDevInfo->LBAInfo.DTAreaSectorSize;
+		dwSectorAddrOffSet 	= 0;
+	}
+	else if ( nPartition == NAND_LBA_HIDDEN_AREA )
+	{
+		nTotalSectorSize 	= nDevInfo->LBAInfo.HDAreaSectorSize;
+		dwSectorAddrOffSet 	= nDevInfo->LBAInfo.HDAreaAddrOffSet;
+	}
+	else if ( nPartition == NAND_LBA_MULTI_HIDDEN_AREA_0 )
+	{
+		nTotalSectorSize 	= nDevInfo->LBAInfo.MHDAreaSectorSize[0];
+		dwSectorAddrOffSet 	= nDevInfo->LBAInfo.MHDAreaAddrOffSet[0];
+	}
+	else if ( nPartition == NAND_LBA_MDP )
+	{
+		nTotalSectorSize 	= nDevInfo->LBAInfo.MDPSectorSize;
+		dwSectorAddrOffSet 	= 0;
+	}
+	else if ( nPartition == NAND_LBA_VFP )
+	{
+		nTotalSectorSize 	= nDevInfo->LBAInfo.VFPSectorSize;
+		dwSectorAddrOffSet 	= 1;
+	}
+	else
+	{
+		nTotalSectorSize 	= 0;
+		dwSectorAddrOffSet 	= 0;
+		return ERR_NAND_IO_WRONG_PARAMETER;
+	}
+
+	// Set Area Clear Sector Address, Size
+	nSectorAddr = 0;
+
+	wFlagFirstSector = TRUE;
+	
+	/* Pre Process */
+	NAND_IO_PreProcess();
+	
+	/* Set Setuo Time and Hold Time */
+	NAND_IO_SetCommCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	//NAND_IO_DisableWriteProtect();
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//######################################################
+	//# Get Info of Parameter
+	//######################################################
+	dwSectorAddr		= nSectorAddr;
+	dwSectorAddr 		+= dwSectorAddrOffSet;
+	dwTotalWriteSecSize = nTotalSectorSize;
+
+	if ( dwTotalWriteSecSize < nDevInfo->LBAInfo.SectorCount )
+		wCurrPPSize = (U16)dwTotalWriteSecSize;
+	else
+		wCurrPPSize = nDevInfo->LBAInfo.SectorCount;
+	
+	//######################################################
+	//# Write Total Sector
+	//######################################################
+	wOldProcessRate = 0xFFFF;
+	nWriteSectorSize = 0;
+	nProCessWriteSectorSize = 0;
+	// [ LCD ROUTINE ] ---------------------------------------------------------------------------------------
+	if ( NAND_IO_LBA_CallBackLcdDisplay )
+		NAND_IO_LBA_CallBackLcdDisplay( 0, 0x03, nTotalSectorSize );
+	//--------------------------------------------------------------------------------------------------------
+
+	if ( dwTotalWriteSecSize >= 0x10000 )
+		wOnceWriteSectorCount = 0; // 0x10000
+	else
+		wOnceWriteSectorCount = (U16)dwTotalWriteSecSize;
+	
+	while ( dwTotalWriteSecSize )
+	{
+		if ( nWriteSectorSize == 0x10000 )
+		{			
+			if ( dwTotalWriteSecSize >= 0x10000 )
+				wOnceWriteSectorCount = 0;
+			else
+				wOnceWriteSectorCount = (U16)dwTotalWriteSecSize;			
+
+			nWriteSectorSize = 0;
+			wFlagFirstSector = TRUE;
+		}
+			
+		/* Command Page Program #1 [ 0x80 ] */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8080;
+
+		if ( wFlagFirstSector == TRUE )
+		{
+			/* Write Sector Size & Sector Address */
+			pNFC->NFC_SADDR= ( wOnceWriteSectorCount & 0xFF );					// Write Sector Num : SC0
+			pNFC->NFC_SADDR= ( ( wOnceWriteSectorCount >> 8 ) & 0xFF );			// Write Sector Num : SC1
+			pNFC->NFC_SADDR= ( dwSectorAddr & 0xFF );							// Write Sector Addr: AD0
+			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 8 ) & 0xFF );					// Write Sector Addr: AD1
+			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 16 ) & 0xFF );					// Write Sector Addr: AD2
+		}
+
+		NAND_IO_SetWriteCycleTime();
+		/* Write Data to NAND FLASH */
+		
+		res = NAND_IO_LBA_WriteDummyData( nDevInfo, wCurrPPSize );
+		if ( res != SUCCESS )
+			return res;
+
+		NAND_IO_SetCommCycleTime();
+		
+		/* Command Page Program #2 [ 0x10 ] */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+
+		/* Wait until it is ready */
+		NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+		/* Decrease Write Size */
+		dwTotalWriteSecSize -= wCurrPPSize;
+
+		/* Increase Buffer Address */
+		//nWriteBuffer		+= ( nDevInfo->LBAInfo.SectorCount << 9 );
+		dwSectorAddr		+= wCurrPPSize;
+		nWriteSectorSize	+= wCurrPPSize;
+		
+		/* Count Next Page Size */
+		if ( dwTotalWriteSecSize < nDevInfo->LBAInfo.SectorCount )
+			wCurrPPSize = (U16)dwTotalWriteSecSize;
+		else
+			wCurrPPSize = nDevInfo->LBAInfo.SectorCount;
+
+		if ( nDevInfo->LBAInfo.TransProtocol2 & NAND_PROT2_WRITE_TYPE_B )
+			wFlagFirstSector = FALSE;
+
+		wProcessRate = (U16)(( ( nProCessWriteSectorSize + 1 ) * 100 ) / ( nTotalSectorSize + 1 ));
+
+		if ( wOldProcessRate != wProcessRate )
+		{
+			// [ LCD ROUTINE ] ---------------------------------------------------------------------------------------
+			if ( NAND_IO_LBA_CallBackLcdDisplay )
+				NAND_IO_LBA_CallBackLcdDisplay( 0, NAND_LBA_CALLBACK_LCD_FORMAT_PROCESS, wProcessRate );
+			//--------------------------------------------------------------------------------------------------------
+
+			wOldProcessRate = wProcessRate;
+		}
+
+		nProCessWriteSectorSize += wCurrPPSize;
+	}
+
+	// [ LCD ROUTINE ] ---------------------------------------------------------------------------------------
+	if ( NAND_IO_LBA_CallBackLcdDisplay )
+		NAND_IO_LBA_CallBackLcdDisplay( 0, 0x05, 0 );
+	//--------------------------------------------------------------------------------------------------------
+	
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0xFBFB;
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	/* FORCE TO SET WP LOW */
+	//NAND_IO_EnableWriteProtect();
+	
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	/* Cache Flush */
+	NAND_IO_LBA_CacheFlush( nDevInfo );
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_WriteSector( NAND_IO_DEVINFO *nDevInfo, U8 nPartition, U32 nSectorAddr, U16 nSecSize, U8 *nWriteBuffer )
+{
+	unsigned short int		wCurrPPSize;
+	unsigned short int		wFlagFirstSector;
+	unsigned long int 		dwSectorAddr;
+	unsigned long int		dwSectorAddrOffSet;
+	unsigned long int		dwTotalWriteSecSize;
+	unsigned long int		nTotalSectorSize;
+	unsigned char			cPartition;
+	unsigned char			cSpareBuffer[16];
+	NAND_IO_ERROR			res;
+
+	//######################################################
+	//# Check Parameter
+	//######################################################
+	if ( nDevInfo->LBAInfo.Usable != ENABLE )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	cPartition = nPartition & 0x0F;
+
+	if ( nDevInfo->LBAInfo.CurrentMode != cPartition )
+		NAND_IO_LBA_ModeChange( nDevInfo, cPartition );
+
+	if ( nPartition == NAND_LBA_DATA_AREA )
+	{
+		nTotalSectorSize 	= nDevInfo->LBAInfo.DTAreaSectorSize;
+		dwSectorAddrOffSet 	= 0;
+	}
+	else if ( nPartition == NAND_LBA_HIDDEN_AREA )
+	{
+		nTotalSectorSize 	= nDevInfo->LBAInfo.HDAreaSectorSize;
+		dwSectorAddrOffSet 	= nDevInfo->LBAInfo.HDAreaAddrOffSet;
+	}
+	else if ( nPartition == NAND_LBA_MULTI_HIDDEN_AREA_0 )
+	{
+		nTotalSectorSize 	= nDevInfo->LBAInfo.MHDAreaSectorSize[0];
+		dwSectorAddrOffSet 	= nDevInfo->LBAInfo.MHDAreaAddrOffSet[0];
+	}
+	else if ( nPartition == NAND_LBA_MDP )
+	{
+		nTotalSectorSize 	= nDevInfo->LBAInfo.MDPSectorSize;
+		dwSectorAddrOffSet 	= 0;
+	}
+	else if ( nPartition == NAND_LBA_VFP )
+	{
+		nTotalSectorSize 	= nDevInfo->LBAInfo.VFPSectorSize;
+		dwSectorAddrOffSet 	= 1;
+	}
+	else
+	{
+		nTotalSectorSize 	= 0;
+		dwSectorAddrOffSet 	= 0;
+		return ERR_NAND_IO_WRONG_PARAMETER;
+	}
+
+	if ( ( nSectorAddr + nSecSize ) > nTotalSectorSize )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	wFlagFirstSector = TRUE;
+	
+	/* Pre Process */
+	NAND_IO_PreProcess();
+	
+	/* Set Setuo Time and Hold Time */
+	NAND_IO_SetCommCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	//NAND_IO_DisableWriteProtect();
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//######################################################
+	//# Get Info of Parameter
+	//######################################################
+	dwSectorAddr		= nSectorAddr;
+	dwSectorAddr 		+= dwSectorAddrOffSet;
+	dwTotalWriteSecSize = nSecSize;
+
+	if ( dwTotalWriteSecSize < nDevInfo->LBAInfo.SectorCount )
+		wCurrPPSize = (U16)dwTotalWriteSecSize;
+	else
+		wCurrPPSize = nDevInfo->LBAInfo.SectorCount ;
+	
+	//######################################################
+	//# Write Total Sector
+	//######################################################
+
+	while ( dwTotalWriteSecSize )
+	{
+		/* Command Page Program #1 [ 0x80 ] */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8080;
+
+		if ( wFlagFirstSector == TRUE )
+		{
+			/* Write Sector Size & Sector Address */
+			pNFC->NFC_SADDR= ( nSecSize & 0xFF );					// Write Sector Num : SC0
+			pNFC->NFC_SADDR= ( ( nSecSize >> 8 ) & 0xFF );			// Write Sector Num : SC1
+			pNFC->NFC_SADDR= ( dwSectorAddr & 0xFF );				// Write Sector Addr: AD0
+			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 8 ) & 0xFF );		// Write Sector Addr: AD1
+			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 16 ) & 0xFF );		// Write Sector Addr: AD2
+		}
+
+		NAND_IO_SetWriteCycleTime();
+		/* Write Data to NAND FLASH */
+		res = NAND_IO_LBA_WriteData( nDevInfo, wCurrPPSize, nWriteBuffer, cSpareBuffer );
+		if ( res != SUCCESS )
+			return res;
+		
+		NAND_IO_SetCommCycleTime();
+		
+		/* Command Page Program #2 [ 0x10 ] */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+
+		/* Decrease Write Size */
+		dwTotalWriteSecSize -= wCurrPPSize;
+
+		/* Increase Buffer Address */
+		nWriteBuffer		+= ( nDevInfo->LBAInfo.SectorCount << 9 );
+		
+		/* Count Next Page Size */
+		if ( dwTotalWriteSecSize < nDevInfo->LBAInfo.SectorCount )
+			wCurrPPSize = (U16)dwTotalWriteSecSize;
+		else
+			wCurrPPSize = nDevInfo->LBAInfo.SectorCount;
+
+		if ( nDevInfo->LBAInfo.TransProtocol2 & NAND_PROT2_WRITE_TYPE_B )
+			wFlagFirstSector = FALSE;
+
+		/* Wait until it is ready */
+		NAND_IO_WaitBusy( nDevInfo->ChipNo );
+	}
+	
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0xFBFB;
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	/* FORCE TO SET WP LOW */
+	//NAND_IO_EnableWriteProtect();
+	
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	/* Cache Flush */
+//	NAND_IO_LBA_CacheFlush( nDevInfo );
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_VFPInitArea( NAND_IO_DEVINFO *nDevInfo )
+{
+	NAND_IO_ERROR	res;
+	
+	res = NAND_IO_LBA_ScanHeaderOfVFP( nDevInfo );
+	if ( res != SUCCESS )
+	{
+		res = NAND_IO_LBA_MakeHeaderOfVFP( nDevInfo );
+		if ( res != SUCCESS )
+			return res;
+
+		res = NAND_IO_LBA_ScanHeaderOfVFP( nDevInfo );
+		if ( res != SUCCESS )
+			return res;
+	}
+	
+	return res;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_ScanHeaderOfVFP( NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned int			i;
+	unsigned short int		wCurrPPSize;
+	unsigned short int		wFlagCheckSize;
+	unsigned short int		wFlagFirstSector;
+	unsigned long int		nHeaderInfoSize;
+	unsigned long int		nHeaderAddress;
+	unsigned long int 		dwSectorAddr;
+	unsigned long int		nTotalSectorSize;
+	unsigned short int		nInfoOffSet;
+	unsigned int			*pPageDW;
+	unsigned char			cPageBuffer[512];
+	unsigned char			cSpareBuffer[16];
+	unsigned long int		dwTotalSectorSize;
+	NAND_IO_ERROR			res;
+
+	//######################################################
+	//# Check Parameter
+	//######################################################
+	NAND_IO_LBA_ModeChange( nDevInfo, NAND_LBA_VFP );
+
+	/* Pre Process */
+	NAND_IO_PreProcess();
+	
+	/* Set Setuo Time and Hold Time */
+	NAND_IO_SetCommCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	NAND_IO_DisableWriteProtect();
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	wFlagFirstSector = TRUE;
+	nInfoOffSet 		= 32;
+	nHeaderInfoSize 	= 1;
+	nHeaderAddress		= 0;
+	
+	//######################################################
+	//# Get Info of Parameter
+	//######################################################
+	dwSectorAddr		= nHeaderAddress;
+	nTotalSectorSize  	= nHeaderInfoSize;
+
+	if ( nTotalSectorSize < nDevInfo->LBAInfo.SectorCount )
+		wCurrPPSize = (U16)nTotalSectorSize;
+	else
+		wCurrPPSize = nDevInfo->LBAInfo.SectorCount ;
+	
+	//######################################################
+	//# Write Total Sector
+	//######################################################
+	while ( nTotalSectorSize )
+	{	
+		/* Command Page Program #1 [ 0x80 ] */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+
+		if ( wFlagFirstSector == TRUE )
+		{
+			/* Write Sector Size & Sector Address */
+			pNFC->NFC_SADDR= ( nHeaderInfoSize & 0xFF );					// Write Sector Num : SC0
+			pNFC->NFC_SADDR= ( ( nHeaderInfoSize >> 8 ) & 0xFF );			// Write Sector Num : SC1
+			pNFC->NFC_SADDR= ( dwSectorAddr & 0xFF );				// Write Sector Addr: AD0
+			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 8 ) & 0xFF );		// Write Sector Addr: AD1
+			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 16 ) & 0xFF );		// Write Sector Addr: AD2
+		}
+
+		/* Command Page Program #2 [ 0x10 ] */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+		
+		/* Wait until it is ready */
+		NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+		NAND_IO_SetReadCycleTime();
+		/* Write Data to NAND FLASH */
+		res = NAND_IO_LBA_ReadData( nDevInfo, wCurrPPSize, cPageBuffer, cSpareBuffer );
+		if ( res != SUCCESS )
+			return res;
+
+		NAND_IO_SetCommCycleTime();
+
+		/* Decrease Write Size */
+		nTotalSectorSize 	-= wCurrPPSize;
+
+		/* Increase Buffer Address */
+		//cPageBuffer			+= ( nDevInfo->LBAInfo.SectorCount << 9 );
+		
+		/* Count Next Page Size */
+		if ( nTotalSectorSize < nDevInfo->LBAInfo.SectorCount )
+			wCurrPPSize = (U16)nTotalSectorSize;
+		else
+			wCurrPPSize = nDevInfo->LBAInfo.SectorCount;
+
+		if ( nDevInfo->LBAInfo.TransProtocol2 & NAND_PROT2_WRITE_TYPE_B )
+			wFlagFirstSector = FALSE;
+	}
+
+	/* FORCE TO SET WP LOW */
+	NAND_IO_EnableWriteProtect();
+	
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	wFlagCheckSize = FALSE;
+
+	// Signature
+	if ( !memcmp( cPageBuffer, (void *)NAND_LBA_VFP_AREA_Signature, sizeof(NAND_LBA_VFP_AREA_Signature) ) )
+	{
+		pPageDW		= (U32 *)&cPageBuffer[nInfoOffSet];
+		//==============================================		
+		// VFP Size			[  4Byte ]	0
+		// MDP Size			[  4Byte ]	1
+		// Hidden Size		[  4Byte ]	2
+		// Multi-Hidden Num [  4Byte ]	3
+		// Multi-Hidden Size[  4Byte ]	4~10
+		//==============================================
+		dwTotalSectorSize = 0;
+
+		if ( nDevInfo->LBAInfo.VFPSectorSize == pPageDW[ENUM_LBA_VFP_SECTOR_SIZE] )
+		{
+			if ( nDevInfo->LBAInfo.FlagOfChangeTotalSectorSize == ENABLE )
+			{
+				if ( ( nDevInfo->LBAInfo.MDPSectorSize == pPageDW[ENUM_LBA_MDP_SECTOR_SIZE] ) &&
+					 ( nDevInfo->LBAInfo.HDAreaSectorSize == pPageDW[ENUM_LBA_HIDDEN_SECTOR_SIZE] ) &&
+					 ( nDevInfo->LBAInfo.MHDAreaNums == pPageDW[ENUM_LBA_MULTI_HIDDEN_NUM] ) )
+				{
+ 					wFlagCheckSize = TRUE;
+
+					if ( nDevInfo->LBAInfo.MHDAreaNums > NAND_LBA_MAX_SUPPORT_MHD_AREA_NUM )
+						return ERR_NAND_IO_WRONG_PARAMETER;
+
+					for ( i = 0; i < nDevInfo->LBAInfo.MHDAreaNums; ++i )
+					{
+						if ( nDevInfo->LBAInfo.MHDAreaSectorSize[i] != pPageDW[ENUM_LBA_MULTI_HIDDEN_SIZE_0 + i] )
+							wFlagCheckSize = FALSE;				
+					}
+				}
+				else
+					wFlagCheckSize = FALSE;
+			}
+			else		// NAND VFP Info Read Only
+			{
+				nDevInfo->LBAInfo.HDAreaSectorSize 	= pPageDW[ENUM_LBA_HIDDEN_SECTOR_SIZE];
+				nDevInfo->LBAInfo.MHDAreaNums 		= pPageDW[ENUM_LBA_MULTI_HIDDEN_NUM];
+
+				if ( nDevInfo->LBAInfo.MHDAreaNums > NAND_LBA_MAX_SUPPORT_MHD_AREA_NUM )
+					return ERR_NAND_IO_WRONG_PARAMETER;
+
+				for ( i = 0; i < nDevInfo->LBAInfo.MHDAreaNums; ++i )
+					nDevInfo->LBAInfo.MHDAreaSectorSize[i] = pPageDW[ENUM_LBA_MULTI_HIDDEN_SIZE_0 + i];
+
+				wFlagCheckSize = TRUE;
+			}
+		}
+		else
+		{
+			NAND_IO_LBA_VFPChangeSectorSize( nDevInfo, nDevInfo->LBAInfo.VFPSectorSize );
+		}
+	}
+
+	dwTotalSectorSize  = nDevInfo->LBAInfo.HDAreaSectorSize;
+	for ( i = 0; i < nDevInfo->LBAInfo.MHDAreaNums; ++i )
+		dwTotalSectorSize += nDevInfo->LBAInfo.MHDAreaSectorSize[i];
+
+	if ( dwTotalSectorSize > nDevInfo->LBAInfo.MDPSectorSize )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	if ( wFlagCheckSize == FALSE )
+		return ERR_NAND_IO_NOT_EXIST_LBA_HEADBLOCK;
+
+	//==================================
+	// Area Address Offset Setting
+	//==================================
+	// Data Area Address Offset = 0
+	// 0 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~MDP Size
+	// [ Data Area | Multi Hidden[n], Multi Hidden[n-1], Multi Hidden[0] | Hidden Area ]
+
+	nDevInfo->LBAInfo.DTAreaSectorSize = nDevInfo->LBAInfo.MDPSectorSize;
+	
+	nDevInfo->LBAInfo.DTAreaSectorSize -= nDevInfo->LBAInfo.HDAreaSectorSize;
+	nDevInfo->LBAInfo.HDAreaAddrOffSet = nDevInfo->LBAInfo.DTAreaSectorSize;
+
+	for ( i = 0; i < nDevInfo->LBAInfo.MHDAreaNums; ++i )
+	{
+		nDevInfo->LBAInfo.DTAreaSectorSize -= nDevInfo->LBAInfo.MHDAreaSectorSize[i];
+		nDevInfo->LBAInfo.MHDAreaAddrOffSet[i] = nDevInfo->LBAInfo.DTAreaSectorSize;
+	}
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_MakeHeaderOfVFP( NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned int			i;
+	unsigned short int		wCurrPPSize;
+	unsigned short int		wFlagFirstSector;
+	unsigned long int		nHeaderInfoSize;
+	unsigned long int		nHeaderAddress;
+	unsigned long int 		dwSectorAddr;
+	unsigned long int		nTotalSectorSize;
+	unsigned short int		nInfoOffSet;
+	unsigned int			*pPageDW;
+	unsigned char			cPageBuffer[512];
+	unsigned char			cSpareBuffer[16];
+	NAND_IO_ERROR			res;
+
+	//######################################################
+	//# Check Parameter
+	//######################################################
+	NAND_IO_LBA_ModeChange( nDevInfo, NAND_LBA_VFP );
+		
+	/* Pre Process */
+	NAND_IO_PreProcess();
+	
+	/* Set Setuo Time and Hold Time */
+	NAND_IO_SetCommCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	NAND_IO_DisableWriteProtect();
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+	wFlagFirstSector = TRUE;
+	nInfoOffSet 		= 32;
+	nHeaderInfoSize 	= 1;
+	nHeaderAddress		= 0;
+
+	//==============================================
+	// Hidden Signature [ 32Byte ]
+	// VFP Size			[  4Byte ]	0
+	// MDP Size			[  4Byte ]	1
+	// Hidden Size		[  4Byte ]	2
+	// Multi-Hidden Num [  4Byte ]	3
+	// Multi-Hidden Size[  4Byte ]	4~10
+	//==============================================
+	
+	// Page Clear
+	memset( (void*)cPageBuffer, 0xFF, 512 );
+
+	// Signature
+	memcpy( (void*)cPageBuffer, (void*)NAND_LBA_VFP_AREA_Signature, sizeof(NAND_LBA_VFP_AREA_Signature) );
+
+	pPageDW		= (U32 *)&cPageBuffer[nInfoOffSet];
+
+	// VFP Size
+	pPageDW[ENUM_LBA_VFP_SECTOR_SIZE] 	= nDevInfo->LBAInfo.VFPSectorSize;
+
+	// MDP Size
+	pPageDW[ENUM_LBA_MDP_SECTOR_SIZE] 	= nDevInfo->LBAInfo.MDPSectorSize;
+
+	// Hidden Size
+	pPageDW[ENUM_LBA_HIDDEN_SECTOR_SIZE]= nDevInfo->LBAInfo.HDAreaSectorSize;
+
+	// Multi-Hidden Area Num
+	pPageDW[ENUM_LBA_MULTI_HIDDEN_NUM] 	= nDevInfo->LBAInfo.MHDAreaNums;
+
+	if ( nDevInfo->LBAInfo.MHDAreaNums > NAND_LBA_MAX_SUPPORT_MHD_AREA_NUM )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	// Multi-Hidden Area Size
+	for ( i = 0; i < nDevInfo->LBAInfo.MHDAreaNums; ++i )
+		pPageDW[ENUM_LBA_MULTI_HIDDEN_SIZE_0 + i] 	= nDevInfo->LBAInfo.MHDAreaSectorSize[i];
+
+	//######################################################
+	//# Get Info of Parameter
+	//######################################################
+	dwSectorAddr		= nHeaderAddress;
+	nTotalSectorSize	= nHeaderInfoSize;
+	wFlagFirstSector = TRUE;
+
+	if ( nTotalSectorSize < nDevInfo->LBAInfo.SectorCount )
+		wCurrPPSize = (U16)nTotalSectorSize;
+	else
+		wCurrPPSize = nDevInfo->LBAInfo.SectorCount ;
+	
+	while ( nTotalSectorSize )
+	{
+		/* Command Page Program #1 [ 0x80 ] */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8080;
+
+		if ( wFlagFirstSector == TRUE )
+		{
+			/* Write Sector Size & Sector Address */
+			pNFC->NFC_SADDR= ( nHeaderInfoSize & 0xFF );					// Write Sector Num : SC0
+			pNFC->NFC_SADDR= ( ( nHeaderInfoSize >> 8 ) & 0xFF );			// Write Sector Num : SC1
+			pNFC->NFC_SADDR= ( dwSectorAddr & 0xFF );				// Write Sector Addr: AD0
+			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 8 ) & 0xFF );		// Write Sector Addr: AD1
+			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 16 ) & 0xFF );		// Write Sector Addr: AD2
+		}
+
+		NAND_IO_SetWriteCycleTime();
+		/* Write Data to NAND FLASH */
+		res = NAND_IO_LBA_WriteData( nDevInfo, wCurrPPSize, cPageBuffer, cSpareBuffer );
+		if ( res != SUCCESS )
+			return res;
+		
+		NAND_IO_SetCommCycleTime();
+		
+		/* Command Page Program #2 [ 0x10 ] */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+
+		/* Decrease Write Size */
+		nTotalSectorSize -= wCurrPPSize;
+
+		/* Increase Buffer Address */
+		//cPageBuffer		+= ( nDevInfo->LBAInfo.SectorCount << 9 );
+		
+		/* Count Next Page Size */
+		if ( nTotalSectorSize < nDevInfo->LBAInfo.SectorCount )
+			wCurrPPSize = (U16)nTotalSectorSize;
+		else
+			wCurrPPSize = nDevInfo->LBAInfo.SectorCount;
+
+		if ( nDevInfo->LBAInfo.TransProtocol2 & NAND_PROT2_WRITE_TYPE_B )
+			wFlagFirstSector = FALSE;
+
+		/* Wait until it is ready */
+		NAND_IO_WaitBusy( nDevInfo->ChipNo );
+	}
+	
+	nDevInfo->LBAInfo.HDAreaAddrOffSet = nDevInfo->LBAInfo.MDPSectorSize - nDevInfo->LBAInfo.HDAreaSectorSize;
+	nDevInfo->LBAInfo.DTAreaSectorSize = nDevInfo->LBAInfo.MDPSectorSize - nDevInfo->LBAInfo.HDAreaSectorSize;
+
+	/* FORCE TO SET WP LOW */
+	NAND_IO_EnableWriteProtect();
+	
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	NAND_IO_LBA_CacheFlush( nDevInfo );
+
+	return (NAND_IO_ERROR)SUCCESS;	
+}
+
+NAND_IO_ERROR NAND_IO_LBA_MDPGetTotalSectorSize( NAND_IO_DEVINFO *nDevInfo, unsigned long int *rTotalSector )
+{
+	unsigned long int	wTotalSector;
+	unsigned char		nTemp;
+	/* Pre Process */
+	NAND_IO_PreProcess();
+
+	/* Set Setup Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+	pNFC->NFC_SADDR= 0xB0;
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x5757;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+	
+	/* Parallel Composition */
+	wTotalSector = (U8)( pNFC->NFC_SDATA & 0xFF );
+	wTotalSector |= ((U8)( pNFC->NFC_SDATA & 0xFF ) << 8 );
+	wTotalSector |= ((U8)( pNFC->NFC_SDATA & 0xFF ) << 16 );
+	wTotalSector |= ((U8)( pNFC->NFC_SDATA & 0xFF ) << 24 );
+//	wTotalSector |= ((U8)( pNFC->NFC_SDATA & 0xFF ) << 32 );
+	nTemp = (U8)( pNFC->NFC_SDATA & 0xFF );
+	
+	*rTotalSector = wTotalSector;
+	
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_VFPGetTotalSectorSize( NAND_IO_DEVINFO *nDevInfo, U32 *rTotalSector )
+{
+	unsigned int	dwTotalSector;
+
+	dwTotalSector  = 0;
+	*rTotalSector  = 0;
+	
+	/* Pre Process */
+	NAND_IO_PreProcess();
+
+	/* Set Setup Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+	pNFC->NFC_SADDR= 0xB5;
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x5757;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+	
+	/* Parallel Composition */
+	dwTotalSector = (U8)( pNFC->NFC_SDATA & 0xFF );
+	dwTotalSector |= ((U8)( pNFC->NFC_SDATA & 0xFF ) << 8 );
+
+	if ( dwTotalSector == 0 ) 
+		dwTotalSector = 0x10000;
+	
+	*rTotalSector = dwTotalSector;
+	
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_VFPChangeSectorSize( NAND_IO_DEVINFO *nDevInfo, U32 nTotalSector )
+{
+	unsigned int	dwTotalSector;
+
+	//======================================================================================
+	//
+	// The available rage for the VFP size: [40][00]h(8 Mbyte) ~ [01][00][00]h(32 Mbyte)
+	// VFP AreaSize Min: 16,384 ~ Max: 65,536 sector / 512 sector resolution
+	//
+	// "VFP/MDP ratio = (+1)/(-2)" VFP increases by 1MB, the DMP decreases by 2MB.
+	//
+	//======================================================================================
+	if ( ( nTotalSector < 0x4000 ) || ( nTotalSector > 0x10000 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+	
+	/* VFP Size Change Command can only be executed in the VFP mode */
+	NAND_IO_LBA_ModeChange( nDevInfo, NAND_LBA_VFP );
+	
+	/* Pre Process */
+	NAND_IO_PreProcess();
+
+	/* Set Setup Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus Witdh */
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+	
+	//==============================================
+	// Arrange Sector Resolution
+	//==============================================
+	dwTotalSector = ( ( nTotalSector + 511 ) >> 9 );
+	dwTotalSector = dwTotalSector << 9;
+
+	if ( ( dwTotalSector < 0x4000 ) || ( dwTotalSector > 0x10000 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+	
+	//==============================================
+	// Set VFP Size
+	//==============================================
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+	pNFC->NFC_SADDR= 0x22;
+	
+	pNFC->NFC_SADDR= ( dwTotalSector & 0xFF );						// VFP_Size0: LSB
+	pNFC->NFC_SADDR= ( ( dwTotalSector >> 8 ) & 0xFF );				// VFP_Size1: MSB
+	pNFC->NFC_SADDR= ( 0xFF - ( dwTotalSector & 0xFF ) );			// Inversion of [VFP_Size0] for verification
+	pNFC->NFC_SADDR= ( 0xFF - ( ( dwTotalSector >> 8 ) & 0xFF ) );	// Inversion of [VFP_Size1] fot verification
+	
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x5757;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+	
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_SetTransferProtocol( NAND_IO_DEVINFO *nDevInfo, U8 nProtocol1, U8 nProtocol2 )
+{
+	/* Pre Process */
+	NAND_IO_PreProcess();
+	
+	/* Set Setuo Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//==============================================
+	// Get Protocol 1
+	//==============================================
+	/* Command Partition Change to PNP */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+
+	pNFC->NFC_SADDR= 0xA2;		// cmd
+	pNFC->NFC_SADDR= nProtocol1;	// Parameter
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x5757;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	//==============================================
+	// Get Protocol 2
+	//==============================================
+	/* Command Partition Change to PNP */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+
+	pNFC->NFC_SADDR= 0xA3;		// cmd
+	pNFC->NFC_SADDR= nProtocol2;	// Parameter
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x5757;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+	
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_SetBootModeChange( NAND_IO_DEVINFO *nDevInfo, U8 nBootMode )
+{
+	/* Pre Process */
+	NAND_IO_PreProcess();
+	
+	/* Set Setuo Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//==============================================
+	// Get Protocol 1
+	//==============================================
+	/* Command Partition Change to PNP */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= nBootMode;	// Parameter
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+	
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_SetRebootCmdChange( NAND_IO_DEVINFO *nDevInfo, U8 nRebootCmd )
+{
+	/* Pre Process */
+	NAND_IO_PreProcess();
+	
+	/* Set Setuo Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//==============================================
+	// Get Protocol 1
+	//==============================================
+	/* Command Partition Change to PNP */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= nRebootCmd;	// Parameter
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+	
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_GetPersistentFunction( NAND_IO_DEVINFO *nDevInfo, U8 *rBootMode, U8 *rRebootCmd )
+{
+	unsigned char	nParameter;
+
+	*rBootMode = 0;
+	*rRebootCmd = 0;
+	
+	/* Pre Process */
+	NAND_IO_PreProcess();
+	
+	/* Set Setuo Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//==============================================
+	// Get Protocol 1
+	//==============================================
+	/* Command Partition Change to PNP */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x99;		// CMD
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	nParameter = (U8)( pNFC->NFC_SDATA & 0xFF );
+
+	*rBootMode = nParameter;
+
+	nParameter = (U8)( pNFC->NFC_SDATA & 0xFF );
+
+	*rRebootCmd = nParameter;
+
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+	
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_GetTransferProtocol( NAND_IO_DEVINFO *nDevInfo, U8 *rProtocol1, U8 *rProtocol2 )
+{
+	unsigned char	nParameter;
+
+	*rProtocol1 = 0;
+	*rProtocol2 = 0;
+	
+	/* Pre Process */
+	NAND_IO_PreProcess();
+	
+	/* Set Setuo Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//==============================================
+	// Get Protocol 1
+	//==============================================
+	/* Command Partition Change to PNP */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+
+	pNFC->NFC_SADDR= 0xB2;		// cmd
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x5757;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	nParameter = (U8)( pNFC->NFC_SDATA & 0xFF );
+
+	*rProtocol1 = nParameter;
+
+	//==============================================
+	// Get Protocol 2
+	//==============================================
+	/* Command Partition Change to PNP */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+
+	pNFC->NFC_SADDR= 0xB3;		// cmd
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x5757;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	nParameter = (U8)( pNFC->NFC_SDATA & 0xFF );
+
+	*rProtocol2 = nParameter;
+
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+	
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_GetBusyTime( NAND_IO_DEVINFO *nDevInfo, U8 *rBusyTime )
+{
+	unsigned char	dwBusyTime;
+
+	dwBusyTime  = 0;
+	*rBusyTime	= 0;
+	
+	/* Pre Process */
+	NAND_IO_PreProcess();
+
+	/* Set Setup Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+	pNFC->NFC_SADDR= 0xB4;
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x5757;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+	
+	/* Parallel Composition */
+	dwBusyTime = (U8)( pNFC->NFC_SDATA & 0xFF );
+
+	*rBusyTime = dwBusyTime;
+	
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_SetBusyTime( NAND_IO_DEVINFO *nDevInfo, U8 nBusyTime )
+{
+	/* Pre Process */
+	NAND_IO_PreProcess();
+
+	/* Set Setup Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+	pNFC->NFC_SADDR= nBusyTime;
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x5757;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+		
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_GetBootMode( NAND_IO_DEVINFO *nDevInfo, U8 *rBootMode )
+{
+	unsigned char	dwBootMode;
+
+	dwBootMode  = 0;
+	*rBootMode	= 0;
+	
+	/* Pre Process */
+	NAND_IO_PreProcess();
+
+	/* Set Setup Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+	pNFC->NFC_SADDR= 0x00;
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x99;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+	
+	/* Parallel Composition */
+	dwBootMode = (U8)( pNFC->NFC_SDATA & 0xFF );
+
+	*rBootMode = dwBootMode;
+	
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_PowerSaveMode( NAND_IO_DEVINFO *nDevInfo, int nOnOff )
+{
+	//Power Save Mode En,Disable	
+	/* Pre Process */
+	NAND_IO_PreProcess();
+
+	/* Set Setup Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+
+	if ( nOnOff == ENABLE )
+		pNFC->NFC_SADDR= 0xBA;
+	else
+		pNFC->NFC_SADDR= 0xBB;
+		
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x5757;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+	
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+	
+NAND_IO_ERROR NAND_IO_LBA_HighSpeedMode( NAND_IO_DEVINFO *nDevInfo, int nOnOff )
+{
+	// High Speed Write Mode En,Disable
+	/* Pre Process */
+	NAND_IO_PreProcess();
+
+	/* Set Setup Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+
+	if ( nOnOff == ENABLE )
+		pNFC->NFC_SADDR= 0xBC;
+	else
+		pNFC->NFC_SADDR= 0xBD;
+		
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x5757;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+	
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	if ( nOnOff == ENABLE )
+		nDevInfo->LBAInfo.HighSpeedMode	= ENABLE;
+	else
+		nDevInfo->LBAInfo.HighSpeedMode	= DISABLE;
+			
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_CacheFlush( NAND_IO_DEVINFO *nDevInfo )
+{ 
+	/* Pre Process */
+	NAND_IO_PreProcess();
+
+	/* Set Setup Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	if ( nDevInfo->LBAInfo.CurrentMode == NAND_LBA_BCM )
+	{
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;			
+		pNFC->NFC_SADDR= 0x00;		// Dummy Write
+		pNFC->NFC_SADDR= 0x00;		// Dummy Write
+		pNFC->NFC_SADDR= 0x00;		// Dummy Write
+		pNFC->NFC_SADDR= 0xF9;		// Dummy Write
+		pNFC->NFC_SADDR= 0x00;		// Dummy Write
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+	}
+	else
+	{
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0xF9F9;
+	}
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+	
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_DeviceReboot( NAND_IO_DEVINFO *nDevInfo )
+{
+	/* Pre Process */
+	NAND_IO_PreProcess();
+
+	/* Set Setup Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	if ( nDevInfo->LBAInfo.CurrentMode == NAND_LBA_BCM )
+	{
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8080;			
+		pNFC->NFC_SADDR= 0x00;		// Dummy Write
+		pNFC->NFC_SADDR= 0x00;		// Dummy Write
+		pNFC->NFC_SADDR= 0x00;		// Dummy Write
+		pNFC->NFC_SADDR= 0xFD;		// CMD
+		pNFC->NFC_SADDR= 0x00;		// Dummy Write
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+	}
+	else
+	{
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0xFDFD;
+	}
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+	
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	nDevInfo->LBAInfo.CurrentMode = NAND_LBA_PNP;
+	
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_ReadID( NAND_IO_DEVINFO *nDevInfo, NAND_IO_DEVID *nDeviceCode )
+{
+	/* Pre Process */
+	NAND_IO_PreProcess();
+
+	/* Set Setup Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x9292;
+	pNFC->NFC_SADDR	= 0x0000;	/* Address [ 0x00 ] */
+	
+	/* Delay : tAR1[READID] Max 200nS */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+	//ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+
+	/* Parallel Composition */
+	nDeviceCode->Code[0] = (U16)( pNFC->NFC_SDATA & nDevInfo->CmdMask );
+	nDeviceCode->Code[1] = (U16)( pNFC->NFC_SDATA & nDevInfo->CmdMask );
+	nDeviceCode->Code[2] = (U16)( pNFC->NFC_SDATA & nDevInfo->CmdMask );
+	nDeviceCode->Code[3] = (U16)( pNFC->NFC_SDATA & nDevInfo->CmdMask );
+	nDeviceCode->Code[4] = (U16)( pNFC->NFC_SDATA & nDevInfo->CmdMask );
+
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_Reset( NAND_IO_DEVINFO *nDevInfo )
+{
+	/* Pre Process */
+	NAND_IO_PreProcess();
+
+	/* Set Setup Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0xFFFF;
+	/* Delay : tAR1[READID] Max 200nS */
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0xFDFD;
+	/* Delay : tAR1[READID] Max 200nS */
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+	
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	nDevInfo->LBAInfo.CurrentMode = NAND_LBA_PNP;
+	
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_ModeChange( NAND_IO_DEVINFO *nDevInfo, int nMode )
+{
+	/* Pre Process */
+	NAND_IO_PreProcess();
+	
+	/* Set Setuo Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	if ( nMode == NAND_LBA_PNP )
+	{
+		// Change to BCM 
+		if ( ( nDevInfo->LBAInfo.CurrentMode == NAND_LBA_PNP ) || ( nDevInfo->LBAInfo.CurrentMode == NAND_LBA_BCM ) )
+		{
+			//==============================================
+			// Directly Enter BCM (Boot Code Maintenance)
+			//==============================================
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+
+			pNFC->NFC_SADDR= 0x00;		// Dummy Write 
+			pNFC->NFC_SADDR= 0x00;		// Dummy Write
+			pNFC->NFC_SADDR= 0x00;		// Dummy Write
+			pNFC->NFC_SADDR= 0xFC;		// cmd
+			pNFC->NFC_SADDR= 0x00;		// Dummy Write
+
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;			
+		}
+		else
+		{
+			/* Command Partition Change to BCM */
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+			
+			pNFC->NFC_SADDR= 0xBF;		// cmd
+			pNFC->NFC_SADDR= 0x00;		// PassWord 0
+			pNFC->NFC_SADDR= 0x00;		// PassWord 1
+			pNFC->NFC_SADDR= 0x00;		// Dummy Write
+			pNFC->NFC_SADDR= 0x00;		// Dummy Write
+
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x5757;			
+		}
+		/* Wait until it is ready */
+		NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+		// Exit from BCM
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8080;
+
+		pNFC->NFC_SADDR= 0x00;		// Dummy Write 
+		pNFC->NFC_SADDR= 0x00;		// Dummy Write
+		pNFC->NFC_SADDR= 0x00;		// Dummy Write
+		pNFC->NFC_SADDR= 0xFD;		// cmd
+		pNFC->NFC_SADDR= 0x00;		// Dummy Write
+
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+	}
+	else if ( nMode == NAND_LBA_BCM )
+	{
+		if ( ( nDevInfo->LBAInfo.CurrentMode == NAND_LBA_PNP ) || ( nDevInfo->LBAInfo.CurrentMode == NAND_LBA_BCM ) )
+		{
+			//==============================================
+			// Directly Enter BCM (Boot Code Maintenance)
+			//==============================================
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+
+			pNFC->NFC_SADDR= 0x00;		// Dummy Write 
+			pNFC->NFC_SADDR= 0x00;		// Dummy Write
+			pNFC->NFC_SADDR= 0x00;		// Dummy Write
+			pNFC->NFC_SADDR= 0xFC;		// cmd
+			pNFC->NFC_SADDR= 0x00;		// Dummy Write
+
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;			
+		}
+		else
+		{
+			/* Command Partition Change to BCM */
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+			
+			pNFC->NFC_SADDR= 0xBF;		// cmd
+			pNFC->NFC_SADDR= 0x00;		// PassWord 0
+			pNFC->NFC_SADDR= 0x00;		// PassWord 1
+			pNFC->NFC_SADDR= 0x00;		// Dummy Write
+			pNFC->NFC_SADDR= 0x00;		// Dummy Write
+
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x5757;			
+		}
+	}
+	else if ( nMode == NAND_LBA_MDP )
+	{
+		/* Command Partition Change to MDP */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0xFCFC;
+	}
+	else if ( nMode == NAND_LBA_VFP )
+	{
+		/* Command Partition Change to VFP */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+		
+		pNFC->NFC_SADDR= 0xBE;		// cmd
+		pNFC->NFC_SADDR= 0xFF;		// PassWord 0
+		pNFC->NFC_SADDR= 0xFF;		// PassWord 1
+		pNFC->NFC_SADDR= 0x00;		// Dummy Write
+		pNFC->NFC_SADDR= 0x00;		// Dummy Write
+
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x5757;
+	}
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	/* Read Status */
+	NAND_IO_LBA_Read2Status( nDevInfo );
+	if ( nDevInfo->LBAInfo.CurrentMode != nMode )
+		return ERR_NAND_IO_FAILED_LBA_PARTITION_CHANGE;
+
+	if ( nMode == NAND_LBA_MDP )
+	{
+		nDevInfo->LBAInfo.CurrentMode = NAND_LBA_MDP;
+		NAND_IO_LBA_MDPGetTotalSectorSize( nDevInfo, &nDevInfo->LBAInfo.CurrentSectorSize );
+	}
+	else if ( nMode == NAND_LBA_VFP )
+	{		
+		nDevInfo->LBAInfo.CurrentMode = NAND_LBA_VFP;
+		NAND_IO_LBA_VFPGetTotalSectorSize( nDevInfo, (U32 *)&nDevInfo->LBAInfo.CurrentSectorSize );
+	}
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_Read2Status( NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned int		uStatus;
+	NAND_IO_ERROR		res;
+
+	res = (NAND_IO_ERROR)SUCCESS;
+	
+	/* Pre Process */
+	NAND_IO_PreProcess();
+	
+	/* Set Setuo Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+	
+	//================================
+	//	Command READ STATUS [ 0x70 ]
+	//================================
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7171;
+
+	// Delay : more than 200nS
+   	NAND_IO_Delay();
+	
+	//=============================================
+	// DATA BUS WIDTH Setting
+	//=============================================
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//================================
+	//	Read IO Status
+	//================================
+	uStatus	= nDevInfo->CmdMask & pNFC->NFC_SDATA;
+	uStatus = uStatus & 0x06;
+	
+	if ( uStatus == NAND_LBA_PNP )
+		nDevInfo->LBAInfo.CurrentMode = NAND_LBA_PNP;
+	else if ( uStatus == NAND_LBA_BCM )
+		nDevInfo->LBAInfo.CurrentMode = NAND_LBA_BCM;
+	else if ( uStatus == NAND_LBA_VFP )
+		nDevInfo->LBAInfo.CurrentMode = NAND_LBA_VFP;
+	else if ( uStatus == NAND_LBA_MDP )
+		nDevInfo->LBAInfo.CurrentMode = NAND_LBA_MDP;
+	else
+		res = ERR_NAND_IO_FAILED_LBA_PARTITION_CHANGE;
+
+	if ( nDevInfo->LBAInfo.CurrentMode != NAND_LBA_PNP )
+	{
+		if ( uStatus & NAND_POWER_SAVE_ENABLE )
+			nDevInfo->LBAInfo.PowerSaveMode = ENABLE;
+		else
+			nDevInfo->LBAInfo.PowerSaveMode = DISABLE;
+
+		if ( uStatus & NAND_HIGH_SPEED_ENABLE )
+			nDevInfo->LBAInfo.HighSpeedMode = ENABLE;
+		else
+			nDevInfo->LBAInfo.HighSpeedMode = DISABLE;		
+	}
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+	
+	return res;
+}
+
+static __inline NAND_IO_ERROR NAND_IO_LBA_ReadData( NAND_IO_DEVINFO *nDevInfo, U16 nReadPPSize,
+												    U8 *nPageBuffer, U8 *nSpareBuffer )
+{
+	unsigned int		i, j;
+	unsigned char		bAlignAddr;
+	unsigned char		*pPageB = 0, *pSpareB = 0;
+	unsigned int		*pPageDW = 0, *pSpareDW = 0;
+	unsigned char		*pDataBuffer;
+	DWORD_BYTE			uDWordByte;
+	NAND_IO_ERROR		res;
+	
+	if ( nReadPPSize > nDevInfo->LBAInfo.SectorCount )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+		
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	res = (NAND_IO_ERROR)SUCCESS;
+
+	//=========================================================================
+	// Check Align of PageBuffer Address
+	//=========================================================================
+	bAlignAddr = ( (unsigned int)nPageBuffer & 3 ) ? 0 : 1;
+	
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================	
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//=========================================================================
+	// Read Data as 512+16Bytes
+	//=========================================================================
+	/* Adapt type of address */
+	if ( bAlignAddr )
+	{
+		pPageDW		= (unsigned int*)nPageBuffer;
+		pSpareDW	= (unsigned int*)nSpareBuffer;
+	}	
+	else
+	{
+		pPageB		= (unsigned char*)nPageBuffer;
+		pSpareB		= (unsigned char*)nSpareBuffer;
+	}	
+
+	//----------------------------------------------
+	//	Read Data as 512Bytes repeatly
+	//----------------------------------------------		
+	for ( j = 0; j < nReadPPSize; ++j )
+	{
+		/* Set Data Buffer */
+		pDataBuffer = ( bAlignAddr ) ? (unsigned char*)pPageDW : (unsigned char*)pPageB;
+
+		//####################################################
+		//#	Read 512 Page Data
+		//####################################################
+		//----------------------------------------------
+		//	MCU ACCESS
+		//----------------------------------------------
+		#if defined( NAND_IO_USE_MCU_ACCESS )
+		
+		/* Read 512 Data Area */
+		i = 128;
+		do {
+			if ( bAlignAddr )
+			{
+				*pPageDW = pNFC->NFC_WDATA;++pPageDW;
+			}	
+			else
+			{
+				uDWordByte.DWORD = pNFC->NFC_WDATA;
+				*pPageB = uDWordByte.BYTE[0];++pPageB;
+				*pPageB = uDWordByte.BYTE[1];++pPageB;
+				*pPageB = uDWordByte.BYTE[2];++pPageB;
+				*pPageB = uDWordByte.BYTE[3];++pPageB;
+			}
+		}while(--i);
+		//----------------------------------------------
+		//	DMA ACCESS
+		//----------------------------------------------
+		#elif defined( NAND_IO_USE_DMA_ACCESS )
+
+		/* Disable DMA Ahead */
+		//IO_DMA_SetCTRL( IO_DMA_CH2, 0 );
+		//IO_INT_HwICLR = IO_INT_HwDMA_CH2;
+
+		/* Start DMA on NFC BUS */
+		#if defined(_LINUX_) || defined(_WINCE_)
+		NAND_IO_SetupDMA( (void*)&NAND_IO_HwLDATA_PA, 0, 0,
+						  (void*)pDataBuffer, 4, 0,
+						  NAND_IO_DMA_READ, 512 );
+		#else
+		NAND_IO_SetupDMA( (void*)&pNFC->NFC_LDATA, 0, 0,
+						  (void*)pDataBuffer, 4, 0,
+						  NAND_IO_DMA_READ, 512 );
+		#endif
+
+		//if ( ISZERO(pDataBuffer,3) ) {
+		//	#if defined(_WINCE_)
+		//		memcpy( pDataBuffer, (void*)IO_NFC_BUFFER0_BASE, 512 );
+		//	#elif defined(_LINUX_)
+		//		#ifndef KERNEL_DRIVER
+		//	    memcpy(pDataBuffer, (void*)IO_NFC_BUFFER0_BASE, 512);
+		//	    #else
+		//	    memcpy(pDataBuffer, virtadr, 512);
+		//		#endif
+		//	#else
+		//	fmemcpy16( pDataBuffer, (void*)IO_NFC_BUFFER0_BASE, 512 );
+		//	#endif
+		//} else {
+		//	#if defined(_WINCE_)
+		//		memcpy( pDataBuffer, (void*)IO_NFC_BUFFER0_BASE, 512 );
+		//	#elif defined(_LINUX_)
+		//	    #ifndef KERNEL_DRIVER
+		//	    memcpy(pDataBuffer, (void*)IO_NFC_BUFFER0_BASE, 512);
+		//	    #else
+		//	    memcpy(pDataBuffer, virtadr, 512);
+		//	    #endif
+		//	#else
+		//	memcpy( pDataBuffer, (void*)IO_NFC_BUFFER0_BASE, 512 );
+		//	#endif
+		//}
+
+		if ( bAlignAddr )
+			pPageDW += 128;
+		else
+			pPageB += 512;
+			
+		#endif
+		//####################################################
+		//####################################################
+		if ( nDevInfo->LBAInfo.DataTransferCheck == ENABLE )
+		{
+			/* Read 16Bytes spare data */
+			i = 4;
+			do {
+				if ( bAlignAddr )
+				{
+					*pSpareDW = pNFC->NFC_WDATA;++pSpareDW;
+				}	
+				else
+				{
+					uDWordByte.DWORD = pNFC->NFC_WDATA;
+					*pSpareB = uDWordByte.BYTE[0];++pSpareB;
+					*pSpareB = uDWordByte.BYTE[1];++pSpareB;
+					*pSpareB = uDWordByte.BYTE[2];++pSpareB;
+					*pSpareB = uDWordByte.BYTE[3];++pSpareB;
+				}
+			}while(--i);
+
+			/* Adapt type of address */
+			if ( bAlignAddr )
+				pSpareDW	= (unsigned int*)nSpareBuffer;
+			else
+				pSpareB		= (unsigned char*)nSpareBuffer;				
+		}
+	}
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+	return res;
+}
+
+static __inline NAND_IO_ERROR NAND_IO_LBA_WriteData( NAND_IO_DEVINFO *nDevInfo, U16 nWritePPSize,
+													 U8 *nPageBuffer, U8 *nSpareBuffer )
+{
+	unsigned int		i, j;
+	unsigned char		bAlignAddr;
+	unsigned char		*pPageB = 0, *pSpareB = 0;
+	unsigned int		*pPageDW = 0, *pSpareDW = 0;
+	unsigned char		*pDataBuffer;
+	DWORD_BYTE			uDWordByte;
+	NAND_IO_ERROR		res;
+	
+	if ( nWritePPSize > nDevInfo->LBAInfo.SectorCount )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	res = (NAND_IO_ERROR)SUCCESS;
+	
+	//=========================================================================
+	// Check Align of PageBuffer Address
+	//=========================================================================
+	bAlignAddr		= ( (unsigned int)nPageBuffer & 3 ) ? 0 : 1;
+
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================	
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//=========================================================================
+	// Write Data as 528Bytes
+	//=========================================================================
+
+	/* Adapt type of address */
+	if ( bAlignAddr )
+	{
+		pPageDW		= (unsigned int*)nPageBuffer;
+		pSpareDW	= (unsigned int*)nSpareBuffer;
+	}	
+	else
+	{
+		pPageB		= (unsigned char*)nPageBuffer;
+		pSpareB		= (unsigned char*)nSpareBuffer;
+	}	
+
+	//----------------------------------------------
+	//	Write Data as 512Bytes repeatly
+	//----------------------------------------------		
+	for ( j = 0; j < nWritePPSize; ++j )
+	{
+		/* Get Data Buffer */
+		pDataBuffer = ( bAlignAddr ) ? (unsigned char*)pPageDW : (unsigned char*)pPageB;
+
+		//####################################################
+		//#	Write 512 Page Data
+		//####################################################
+		//----------------------------------------------
+		//	MCU ACCESS
+		//----------------------------------------------
+		#if defined( NAND_IO_USE_MCU_ACCESS )
+
+		/* Write 512 Data Area */	
+		BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
+		pNFC->NFC_DSIZE	= 512;
+		pNFC->NFC_IREQ = 0x77;	// pNFC->NFC_IREQ_FLAG1;
+		pNFC->NFC_PSTART = 0;
+		
+		i = 128;
+		do {
+			while (!( pNFC->NFC_CTRL & HwNFC_CTRL_FS_RDY ));
+			
+			if ( bAlignAddr )
+			{
+				pNFC->NFC_LDATA = *pPageDW;++pPageDW;
+			}	
+			else
+			{
+				uDWordByte.BYTE[0] = *pPageB;++pPageB;
+				uDWordByte.BYTE[1] = *pPageB;++pPageB;
+				uDWordByte.BYTE[2] = *pPageB;++pPageB;
+				uDWordByte.BYTE[3] = *pPageB;++pPageB;
+				pNFC->NFC_LDATA	= uDWordByte.DWORD;					
+			}
+		}while(--i);
+
+		while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+		
+		//----------------------------------------------
+		//	DMA ACCESS
+		//----------------------------------------------
+		#elif defined( NAND_IO_USE_DMA_ACCESS )
+		/* Disable DMA Ahead */
+		//IO_DMA_SetCTRL( IO_DMA_CH2, 0 );
+		//IO_INT_HwICLR = IO_INT_HwDMA_CH2;
+
+		/* Prepare data */
+		//if (ISZERO( pDataBuffer, 3 )) {
+		//	#if defined(_WINCE_)
+		//		memcpy( (void*)IO_NFC_BUFFER0_BASE, pDataBuffer, 512 );
+		//	#elif defined(_LINUX_)
+		//	    #ifndef KERNEL_DRIVER
+		//	    memcpy( (void*)IO_NFC_BUFFER0_BASE, pDataBuffer, 512 );
+		//	    #else
+		//	    memcpy( virtadr, pDataBuffer, 512 );
+		//	    #endif
+		//	#else
+		//	fmemcpy16( (void*)IO_NFC_BUFFER0_BASE, pDataBuffer, 512 );
+		//	#endif
+		//} else {
+		//	#if defined(_WINCE_)
+		//		memcpy( (void*)IO_NFC_BUFFER0_BASE, pDataBuffer, 512 );
+		//	#elif defined(_LINUX_)
+		//	    #ifndef KERNEL_DRIVER
+		//	    memcpy( (void*)IO_NFC_BUFFER0_BASE, pDataBuffer, 512 );
+		//	    #else
+		//	    memcpy( virtadr, pDataBuffer, 512 );
+		//	    #endif
+		//	#else
+		//	memcpy( (void*)IO_NFC_BUFFER0_BASE, pDataBuffer, 512 );
+		//	#endif
+		//}
+			
+		#if defined(_LINUX_) || defined(_WINCE_)
+		NAND_IO_SetupDMA( (void*)pDataBuffer, 4, 0,
+						  (void*)&NAND_IO_HwLDATA_PA, 0, 0,
+						  NAND_IO_DMA_WRITE, 512 );
+		#else
+		NAND_IO_SetupDMA( (void*)pDataBuffer, 4, 0,
+						  (void*)&pNFC->NFC_LDATA, 0, 0,
+						  NAND_IO_DMA_WRITE, 512 );
+		#endif
+
+		if ( bAlignAddr ) 
+			pPageDW += 128;
+		else
+			pPageB += 512;
+
+		#endif
+		//####################################################
+		//####################################################
+		if ( nDevInfo->LBAInfo.DataTransferCheck == ENABLE )
+		{
+			/* Write 16Bytes spare data */
+			i = 4;
+			do {
+				if ( bAlignAddr )
+				{
+					pNFC->NFC_WDATA = *pSpareDW;++pSpareDW;
+				}	
+				else
+				{
+					uDWordByte.BYTE[0]	= *pSpareB;++pSpareB;
+					uDWordByte.BYTE[1]	= *pSpareB;++pSpareB;
+					uDWordByte.BYTE[2]	= *pSpareB;++pSpareB;
+					uDWordByte.BYTE[3]	= *pSpareB;++pSpareB;
+					pNFC->NFC_WDATA = uDWordByte.DWORD;
+				}
+			}while(--i);
+
+			/* Adapt type of address */
+			if ( bAlignAddr )
+				pSpareDW	= (unsigned int*)nSpareBuffer;
+			else
+				pSpareB		= (unsigned char*)nSpareBuffer;			
+		}
+	}
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+	return res;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      static __inline NAND_IO_ERROR NAND_IO_LBA_WriteDummyData( NAND_IO_DEVINFO *nDevInfo, U16 nWritePPSize );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			nDevInfo	= 
+*			nWritePPSize	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_LBA_WriteDummyData( NAND_IO_DEVINFO *nDevInfo, U16 nWritePPSize )
+{
+	unsigned int		i, j;
+	unsigned char		nTempBuffer[512];
+	NAND_IO_ERROR		res;
+	
+	if ( nWritePPSize > nDevInfo->LBAInfo.SectorCount )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	res = (NAND_IO_ERROR)SUCCESS;
+
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================	
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//----------------------------------------------
+	//	Write Data as 512Bytes repeatly
+	//----------------------------------------------		
+	for ( j = 0; j < nWritePPSize; ++j )
+	{
+		//####################################################
+		//#	Write 512 Page Data
+		//####################################################
+		//----------------------------------------------
+		//	MCU ACCESS
+		//----------------------------------------------
+		#if defined( NAND_IO_USE_MCU_ACCESS )
+
+		/* Write 512 Data Area */	
+		BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
+		pNFC->NFC_DSIZE	= 512;
+		pNFC->NFC_IREQ = 0x77;	// pNFC->NFC_IREQ_FLAG1;
+		pNFC->NFC_PSTART = 0;
+		
+		i = 128;
+		do {
+			while (!( pNFC->NFC_CTRL & HwNFC_CTRL_FS_RDY ));
+			pNFC->NFC_LDATA = 0xFFFFFFFF;
+		}while(--i);
+
+		while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+		
+		//----------------------------------------------
+		//	DMA ACCESS
+		//----------------------------------------------
+		#elif defined( NAND_IO_USE_DMA_ACCESS )
+		/* Disable DMA Ahead */
+		//IO_DMA_SetCTRL( IO_DMA_CH2, 0 );
+		//IO_INT_HwICLR = IO_INT_HwDMA_CH2;
+
+		#if defined(_LINUX_) || defined(_WINCE_)
+		NAND_IO_SetupDMA( (void*)nTempBuffer, 4, 0,
+						  (void*)&NAND_IO_HwLDATA_PA, 0, 0,
+						  NAND_IO_DMA_WRITE, 512 );
+		#else
+		NAND_IO_SetupDMA( (void*)nTempBuffer, 4, 0,
+						  (void*)&pNFC->NFC_LDATA, 0, 0,
+						  NAND_IO_DMA_WRITE, 512 );
+		#endif
+
+		#endif
+		//####################################################
+		//####################################################
+		if ( nDevInfo->LBAInfo.DataTransferCheck == ENABLE )
+		{
+			/* Write 16Bytes spare data */
+			i = 4;
+			do {
+				pNFC->NFC_WDATA = 0xFFFFFFFF;
+			}while(--i);
+		}
+	}
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+	return res;
+}
+
+#endif	// WITHOUT_FILESYSTEM
+
+/* end of file */
diff --git a/drivers/block/tcc/nand_io_v7.c b/drivers/block/tcc/nand_io_v7.c
new file mode 100644
index 0000000..46c6713
--- /dev/null
+++ b/drivers/block/tcc/nand_io_v7.c
@@ -0,0 +1,13049 @@
+//=============================================================================
+//*   FileName    : Nand_io_v7.c
+//*   Description : 
+//=============================================================================
+//*
+//*   TCC Version 1.0
+//*   Copyright (c) Telechips, Inc.
+//*   ALL RIGHTS RESERVED
+//*
+//=============================================================================
+#ifndef WITHOUT_FILESYSTEM
+
+#if defined(_LINUX_) || defined(_WINCE_)
+#include "IO_TCCXXX.h"
+#include "nand_io_v7.h"
+#else
+#include "main.h"
+#include "IO_TCCXXX.h"
+#include "nand_io_v7.h"
+#endif
+
+#if defined(_WINCE_)
+#if defined(USE_V_ADDRESS)
+#include "Tcc_ckc.h"
+#include "tcc_gpio.h"
+#else
+#include "Tca_ckc.h"
+#endif
+#include "bsp.h"
+#include "args.h"
+#elif defined(_LINUX_)
+#if defined(USE_V_ADDRESS)
+#include <mach/tca_ckc.h>
+#else
+#include "ckc.h"
+#endif
+#endif
+
+#if defined(TCC89XX) || defined(TCC92XX)
+#if defined(_LINUX_) || defined(_WINCE_)
+#include "TC_DRV.h"
+#else
+#include "TC_DRV.h"
+#endif
+#endif
+
+#if defined(_WINCE_)
+#include "stdlib.h"
+#endif
+
+//=============================================================================
+//
+// Version Signature
+//
+//=============================================================================
+#define NAND_IO_VERSION		'V','7','0','0','3'
+
+static const unsigned char 	NANDIO_Library_Version[] = 
+{ 	
+	SIGBYAHONG, 
+	NAND_IO_SIGNATURE, 
+	SIGN_OS, 
+	SIGN_CHIPSET, 
+	NAND_IO_VERSION, 
+	NULL
+};
+
+#ifdef UARTCON_INCLUDE
+//#define NAND_IO_ECC_ERROR_LOG
+//#define NAND_IO_UART_MEASURE
+#endif
+
+#if defined(_LINUX_)
+#ifdef KERNEL_DRIVER
+#include <linux/kernel.h>
+#include <linux/string.h>
+struct dma_buf {
+	void *v_addr;
+	unsigned int dma_addr;
+	int buf_size;
+};
+extern struct dma_buf dma_t;
+#else
+#define DMA_ADDR	(BSS_OFFSET - 0x00700000)
+#endif
+#else
+extern unsigned char *gpNandBuffer;
+#endif
+
+#if defined(_LINUX_)
+#define ASM_NOP {					\
+	__asm__ __volatile__ ("nop");	\
+	__asm__ __volatile__ ("nop");	\
+	__asm__ __volatile__ ("nop");	\
+	__asm__ __volatile__ ("nop");	\
+	__asm__ __volatile__ ("nop");	\
+	__asm__ __volatile__ ("nop");	\
+}
+#elif defined(_WINCE_)
+volatile int __asm_nop_count = 0;
+#define ASM_NOP { __asm_nop_count++; }
+#else
+#define ASM_NOP { __asm{ NOP }; __asm{ NOP };  __asm{ NOP }; __asm{ NOP }; __asm{ NOP }; __asm{ NOP };}
+#endif
+
+#if defined(_WINCE_)
+#define NAND_IO_USE_DMA_ACCESS
+#elif defined(_LINUX_)
+	#ifdef KERNEL_DRIVER
+		#define NAND_IO_USE_DMA_ACCESS
+	#else
+#define NAND_IO_USE_DMA_ACCESS
+//#define NAND_IO_USE_MCU_ACCESS
+	#endif
+#else
+#define NAND_IO_USE_DMA_ACCESS
+#endif
+
+#ifdef NAND_IO_USE_DMA_ACCESS
+#define NAND_IO_USE_DMA_DOUBLE_BUF
+#define NAND_IO_USE_DMA_DOUBLE_BUF_WRITE
+#endif
+
+//=============================================================================
+//*
+//*
+//*                           [ CONST DATA DEFINE ]
+//*
+//*
+//=============================================================================
+const NAND_IO_FEATURE	TOSHIBA_NAND_DevInfo[] =
+{
+   //*=======================================================================================================================================================
+    //*[        DEVICE CODE       ][           SIZE            ][               Cycle                     ][               		   ATTRIBUTE                 ]
+    //*-------------------------------------------------------------------------------------------------------------------------------------------------------
+    //* 1st, 2nd,  3rd,  4th,  5th,  6th,  PBpV,BBpZ, PpB, Page,Spare,Col,Low,Twc, Ws, Wp, Wh, Rs, Rp, Rh
+    //*=======================================================================================================================================================
+    // [ 32MB] TC58DVM82A1FT
+    { 0x98, 0x75, 0x00, 0x00, 0x00, 0x00, 2048,  20,  32,  512,   16,  1,  2, 50,	 0, 25, 15,  0, 25, 15, A_08BIT|A_SLC	  	|A_SMALL|S_NOR			   	},
+    // [ 64MB] TC58DVM92A1FT
+    { 0x98, 0x76, 0x00, 0x00, 0x00, 0x00, 4096,  20,  32,  512,   16,  1,  3, 50,	 0, 25, 15,  0, 25, 15, A_08BIT|A_SLC	  	|A_SMALL|S_NOR			  	},
+    // [ 64MB] TC58NWM9S3B
+    { 0x98, 0xF0, 0x00, 0x00, 0x00, 0x00,  512,  10,  64, 2048,   64,  2,  2, 50,	 0, 25, 15,  0, 25, 15, A_08BIT|A_SLC	  	|A_BIG  |S_NOR			   	},
+    // [128MB] TC58DVG02A1FT
+    { 0x98, 0x79, 0x00, 0x00, 0x00, 0x00, 8192,  20,  32,  512,   16,  1,  3, 50,	 0, 25, 15,  0, 25, 15, A_08BIT|A_SLC	  	|A_SMALL|S_NOR			   	},	
+    // [128MB] TC58NVG0S3AFT
+    { 0x98, 0xF1, 0x00, 0x00, 0x00, 0x00, 1024,  20,  64, 2048,   64,  2,  2, 50,	 0, 25, 15,  0, 25, 15, A_08BIT|A_SLC	  	|A_BIG  |S_NOR			   	},	
+    // [256MB] TH58NVG1S3AFT
+    { 0x98, 0xDA, 0x00, 0x00, 0x00, 0x00, 2048,  20,  64, 2048,   64,  2,  3, 50,	 0, 25, 15,  0, 25, 15, A_08BIT|A_SLC	  	|A_BIG  |S_NOR			   	},
+    // [512MB] THGVN0G4D1DTG00
+    { 0x98, 0xDC, 0x00, 0x15, 0x00, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 50,	 0, 25, 15,  0, 35, 15, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_LBA		},
+    // [512MB] TH58NYG2S8C
+    { 0x98, 0xBC, 0x91, 0xD5, 0x49, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 50,	 0, 25, 15,  0, 35, 15, A_16BIT|A_SLC	  	|A_BIG  |S_NOR			   	},
+    // [512MB] TH58NVG2D4CTG00
+    { 0x98, 0xDC, 0x84, 0xA5, 0x60, 0x00, 2048,  40, 128, 2048,   64,  2,  3, 50,	 0, 25, 15,  0, 25, 15, A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP2	   	},
+    // [512MB] TH58NVG2D4BFT00
+    { 0x98, 0xDC, 0x84, 0xA5, 0x54, 0x00, 2048,  40, 128, 2048,   64,  2,  3, 50,	 0, 25, 15,  0, 25, 15, A_08BIT|A_MLC	  	|A_BIG  |S_NOR			   	},
+    // [  1GB] TH58NVG3D4BFT00
+    { 0x98, 0xD3, 0x85, 0xA5, 0x58, 0x00, 4096,  40, 128, 2048,   64,  2,  3, 50,	 0, 25, 15,  0, 25, 15, A_08BIT|A_MLC	  	|A_BIG  |S_NOR		  	    },
+    // [  1GB] TC58NVG3D4CTG00
+    { 0x98, 0xD3, 0x84, 0xA5, 0x66, 0x00, 4096,  40, 128, 2048,   64,  2,  3, 30,	 0, 20, 10,  0, 20, 10, A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP	 		},
+    // [  2GB] TH58NVG4D4CFT00	[  4GB] TH58NVG5D4CTG20
+    { 0x98, 0xD5, 0x85, 0xA5, 0x00, 0x00, 8192,  40, 128, 2048,   64,  2,  3, 30,	 0, 20, 10,  0, 20, 10, A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP     	},
+    // [  1GB] TH58NVG3D1DTG00	// 4k Page
+    { 0x98, 0xD3, 0x94, 0xBA, 0x64, 0x00, 2048,  40, 128, 4096,  218,  2,  3, 30,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC_8BIT	|A_BIG  |S_NOR|S_MP			},
+	// [  2GB] TH58NVG4D1DTG00	[  4GB] TH58NVG5D1DTG20	
+    { 0x98, 0xD5, 0x94, 0x00, 0x00, 0x00, 4096,  40, 128, 4096,  218,  2,  3, 30,	 0, 20, 10,  0, 15, 15, A_08BIT|A_MLC_8BIT	|A_BIG  |S_NOR|S_MP			},
+    // [  8GB] TH58NVG6D1DTG20	// 4k Page
+    { 0x98, 0xD7, 0x00, 0x00, 0x00, 0x00, 8192,  40, 128, 4096,  218,  2,  3, 30,	 0, 20, 10,  0, 15, 15, A_08BIT|A_MLC_8BIT	|A_BIG  |S_NOR|S_MP 		}
+};
+
+const NAND_IO_FEATURE	TOSHIBA_LBA_NAND_DevInfo[] =
+{
+    //*=======================================================================================================================================================
+    //*[        DEVICE CODE       ][           SIZE            ][               Cycle                     ][               		   ATTRIBUTE                 ]
+    //*-------------------------------------------------------------------------------------------------------------------------------------------------------
+    //* 1st, 2nd,  3rd,  4th,  5th,  6th,  PBpV,BBpZ, PpB, Page,Spare,Col,Low,Twc, Ws, Wp, Wh, Rs, Rp, Rh
+    //*=======================================================================================================================================================
+    // [  2GB] THGVN0G4D1DTG00
+    { 0x98, 0x21, 0x01, 0x55, 0xAA, 0x00, 8192,  40, 128, 4096,  218,  2,  3, 30,	 0, 20, 10,  0, 15, 15, A_08BIT|A_MLC_8BIT	|A_BIG  |S_NOR|S_MP			},
+    // [  8GB] THGVN1G6D4ELA02
+    { 0x98, 0x21, 0x03, 0x55, 0xAA, 0x00, 8192,  40, 128, 4096,  218,  2,  3, 30,	 0, 20, 10,  0, 15, 15, A_08BIT|A_MLC_8BIT	|A_BIG  |S_NOR|S_MP			},
+    // [  16GB] THGVN1G7D8ELA09
+    { 0x98, 0x21, 0x04, 0x55, 0xAA, 0x00, 8192,  40, 128, 4096,  218,  2,  3, 30,	 0, 20, 10,  0, 15, 15, A_08BIT|A_MLC_8BIT	|A_BIG  |S_NOR|S_MP			}
+};
+
+const NAND_IO_FEATURE	HYNIX_NAND_DevInfo[] =
+{
+    //*=======================================================================================================================================================
+    //*[        DEVICE CODE       ][           SIZE            ][               Cycle                     ][               		   ATTRIBUTE                 ]
+    //*-------------------------------------------------------------------------------------------------------------------------------------------------------
+    //* 1st, 2nd,  3rd,  4th,  5th,  6th,  PBpV,BBpZ, PpB, Page,Spare,Col,Low,Twc, Ws, Wp, Wh, Rs, Rp, Rh
+    //*=======================================================================================================================================================
+    // [ 32MB] HY27US08561M
+    { 0xAD, 0x75, 0x00, 0x00, 0x00, 0x00, 2048,  20,  32,  512,   16,  1,  2, 50,	 0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	  	|A_SMALL|S_NOR|S_CB        	},
+    // [ 64MB] HY27US08121M
+    { 0xAD, 0x76, 0x00, 0x00, 0x00, 0x00, 4096,  20,  32,  512,   16,  1,  3, 60,	 0, 40, 20,  0, 40, 20, A_08BIT|A_SLC	  	|A_SMALL|S_NOR|S_CB        	},
+	// [ 64MB] HY27SS16122A
+    { 0xAD, 0x46, 0xAD, 0x46, 0xAD, 0x00, 4096,  20,  32,  512,   16,  1,  3, 60,	 0, 40, 20,  0, 50, 20, A_16BIT|A_SLC	  	|A_SMALL|S_NOR|S_CB	       	},
+    // [128MB] HY27UA081G1M
+    { 0xAD, 0x79, 0x00, 0x00, 0x00, 0x00, 8192,  20,  32,  512,   16,  1,  3, 60,	 0, 40, 15,  0, 40, 15, A_08BIT|A_SLC	  	|A_SMALL|S_NOR|S_CB	    	},
+    // [128MB] HY27UF081G2M, HY27UF081G2A 
+    { 0xAD, 0xF1, 0x00, 0x00, 0x00, 0x00, 1024,  20,  64, 2048,   64,  2,  2, 50,	 0, 35, 20,  0, 35, 20, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP   	},
+	// [256MB] HY27UF082G2M, HY27UG082G2M
+	{ 0xAD, 0xDA, 0x80, 0x15, 0x00, 0x00, 2048,  20,  64, 2048,   64,  2,  3, 50,	 0, 35, 20,  0, 35, 20, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP   	},
+	// [256MB] HY27UF082G2A
+	{ 0xAD, 0xDA, 0x80, 0x1D, 0x00, 0x00, 2048,  20,  64, 2048,   64,  2,  3, 50,	 0, 35, 20,  0, 35, 20, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP   	},
+	// [256MB] HY27UF082G2B
+	{ 0xAD, 0xDA, 0x10, 0x95, 0x44, 0x00, 2048,  20,  64, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_MP			},
+    // [512MB] HY27UF084G2M
+    { 0xAD, 0xDC, 0x80, 0x95, 0x00, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 30,	 0, 20, 10,  0, 20, 10, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP   	},
+	// [512MB] HY27UF084G2B
+    { 0xAD, 0xDC, 0x10, 0x95, 0x00, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_MP	},
+    // [512MB] HY27UG084G2M, HY27UH084G2M
+    { 0xAD, 0xDC, 0x80, 0x15, 0x00, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 60,	 0, 35, 20,  0, 35, 20, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP   	},
+    // [512MB] HY27UT084G2M
+    { 0xAD, 0xDC, 0x84, 0x25, 0x00, 0x00, 2048,  40, 128, 2048,   64,  2,  3, 50,	 0, 35, 15,  0, 35, 15, A_08BIT|A_MLC	  	|A_BIG  |S_NOR				},
+    // [512MB] HY27UT084G2A
+    { 0xAD, 0xDC, 0x14, 0xA5, 0x24, 0x00, 2048,  25, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP			},
+    // [  1GB] HY27UH088G2M
+    { 0xAD, 0xD3, 0x80, 0x15, 0x00, 0x00, 8192,  20,  64, 2048,   64,  2,  3, 60,	 0, 35, 20,  0, 35, 20, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP   	},
+    // [  1GB] HY27UG088G2M  	[  2GB] HY27UH08AG5M
+    { 0xAD, 0xD3, 0xC1, 0x95, 0x00, 0x00, 8192,  20,  64, 2048,   64,  2,  3, 30,	 0, 20, 10,  0, 20, 10, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP 	},
+    // [  1GB] H27U8G8F2M
+    { 0xAD, 0xD3, 0x10, 0xA6, 0x34, 0x00, 4096,  20,  64, 4096,  128,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_MP	 	 	},	
+    // [  1GB] HY27UU088G2M
+    { 0xAD, 0xD3, 0x85, 0x25, 0x00, 0x00, 4096,  40, 128, 2048,   64,  2,  3, 50,	 0, 35, 15,  0, 35, 15, A_08BIT|A_MLC	  	|A_BIG  |S_NOR				},
+    // [  1GB] HY27UT088G2M  	[  2GB] HY27UU08AG5M
+    { 0xAD, 0xD3, 0x14, 0xA5, 0x64, 0xAD, 4096,  25, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP			},
+    // [  1GB] HY27UT088G2A
+    { 0xAD, 0xD3, 0x14, 0xA5, 0x34, 0x00, 4096,  25, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP			},
+    // [  4GB] HY27UV08BG5M	 	[  8GB] HY27UW08CGFM
+    { 0xAD, 0xD5, 0x55, 0xA5, 0x68,	0x00, 8192,  25, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP			},
+    // [  4GB] HY27UV08BG5A	 
+    { 0xAD, 0xD5, 0x55, 0xA5, 0x38,	0x00, 8192,  25, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP			},
+	// [  2GB] HY27UAG8T2MTR
+    { 0xAD, 0xD5, 0x14, 0xB6, 0x44,	0x00, 4096,  25, 128, 4096,  128,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP		 	},
+    // [  8GB] HY27UCG8V5MTR
+    { 0xAD, 0xD7, 0x55, 0xB6, 0x48,	0x00, 8192,  25, 128, 4096,  128,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP			},
+	// [  4GB] HY27UBG8U5A
+    { 0xAD, 0xD5, 0x94, 0x25, 0x44,	0x41, 4096,  25, 128, 4096,  224,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC_12BIT |A_BIG  |S_NOR|S_MCP		},
+	// [  8GB] HY27UCG8V5A
+    { 0xAD, 0xD7, 0x95, 0x25, 0x48,	0x41, 8192,  25, 128, 4096,  224,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC_12BIT |A_BIG  |S_NOR|S_MCP		}
+};
+
+const NAND_IO_FEATURE	ST_NAND_DevInfo[] =
+{
+    //*=======================================================================================================================================================
+    //*[        DEVICE CODE       ][           SIZE            ][               Cycle                     ][               		   ATTRIBUTE                 ]
+    //*-------------------------------------------------------------------------------------------------------------------------------------------------------
+    //* 1st, 2nd,  3rd,  4th,  5th,  6th,  PBpV,BBpZ, PpB, Page,Spare,Col,Low,Twc, Ws, Wp, Wh, Rs, Rp, Rh
+    //*=======================================================================================================================================================
+    // [ 32MB] NAND256W3A
+    { 0x20, 0x75, 0x00, 0x00, 0x00, 0x00, 2048,  20,  32,  512,   16,  1,  2, 50,  	 0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	  	|A_SMALL|S_NOR			   	},
+    // [ 64MB] NAND512W3A
+    { 0x20, 0x76, 0x00, 0x00, 0x00, 0x00, 4096,  20,  32,  512,   16,  1,  3, 50,	 0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	  	|A_SMALL|S_NOR			   	},
+    // [128MB] NAND01GW3A
+    { 0x20, 0x79, 0x00, 0x00, 0x00, 0x00, 8192,  20,  32,  512,   16,  1,  3, 50,	 0, 35, 20,  0, 25, 20, A_08BIT|A_SLC	  	|A_SMALL|S_NOR|S_CB|S_CP   	},
+    // [128MB] NAND01GW3B2C
+    { 0x20, 0xF1, 0x00, 0x1D, 0x00, 0x00, 1024,  20,  64, 2048,   64,  2,  2, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_SLC	  	|A_BIG  |S_NOR			 	},
+    // [128MB] NAND01GW3B
+    { 0x20, 0xF1, 0x00, 0x00, 0x00, 0x00, 1024,  20,  64, 2048,   64,  2,  2, 50,	 0, 35, 20,  0, 35, 20, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP   	},
+	// [256MB] NAND02GW3B2D
+    { 0x20, 0xDA, 0x10, 0x95, 0x44, 0x00, 2048,  20,  64, 2048,   64,  2,  3, 45,	 0, 25, 20,  0, 25, 20, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_MP		   	},
+    // [256MB] NAND02GW3B
+    { 0x20, 0xDA, 0x00, 0x00, 0x00, 0x00, 2048,  20,  64, 2048,   64,  2,  3, 50,	 0, 35, 20,  0, 35, 20, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP   	},
+	// [512MB] NAND04GW3B2D
+    { 0x20, 0xDC, 0x10, 0x95, 0x54, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_MP		  	},
+    // [512MB] NAND04GW3B
+    { 0x20, 0xDC, 0x80, 0x95, 0x00, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 50,	 0, 35, 20,  0, 35, 20, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP   	},
+    // [512MB] NAND04GW3C2A
+    { 0x20, 0xDC, 0x84, 0x25, 0x00, 0x00, 2048,  40, 128, 2048,   64,  2,  3, 60,	 0, 40, 20,  0, 40, 20, A_08BIT|A_MLC	  	|A_BIG  |S_NOR				},
+	// [  1GB] NAND08GW3B2CN6
+    { 0x20, 0xD3, 0x51, 0x95, 0x58, 0x00, 8192,  20,  64, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_MP	|S_IL	},
+    // [  1GB] NAND08GW3B
+    { 0x20, 0xD3, 0x85, 0x25, 0x00, 0x00, 8192,  20,  64, 2048,   64,  2,  3, 50,	 0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP   	},
+	// [  1GB] NAND08GW3C2A,	[ 2GB] NAND16GW3C4A 
+    { 0x20, 0xD3, 0x14, 0xA5, 0x00, 0x00, 4096,  20, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP		  	}
+};
+
+const NAND_IO_FEATURE	SAMSUNG_NAND_DevInfo[] =
+{
+    //*=======================================================================================================================================================
+    //*[        DEVICE CODE       ][           SIZE            ][               Cycle                     ][               		   ATTRIBUTE                 ]
+	//*-------------------------------------------------------------------------------------------------------------------------------------------------------
+    //* 1st, 2nd,  3rd,  4th,  5th,  6th,  PBpV,BBpZ, PpB, Page,Spare,Col,Low,Twc, Ws, Wp, Wh, Rs, Rp, Rh
+    //*=======================================================================================================================================================
+	// [ 32MB] K9F5608U0B/C/D ~TEST(C) ~TEST(D)   
+    { 0xEC, 0x75, 0x00, 0x00, 0x00, 0x00, 2048,  20,  32,  512,   16,  1,  2, 50,  	0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	 	|A_SMALL|S_NOR|S_CB        	},
+    // [ 64MB] K9F1208U0M/A/B
+    { 0xEC, 0x76, 0xA5, 0xC0, 0x00, 0x00, 4096,  20,  32,  512,   16,  1,  3, 50,  	0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	 	|A_SMALL|S_NOR|S_CB    	 	},
+    // [ 64MB] K9F1208U0C: ~TEST(C) WC: 42 WP: 21 WH: 15 
+    { 0xEC, 0x76, 0x5A, 0x3F, 0x00, 0x00, 4096,  20,  32,  512,   16,  1,  3, 50,  	0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	 	|A_SMALL|S_NOR		   	 	},
+    // [128MB] K9K1G08U0M/A/B: ~TEST(B) 
+    { 0xEC, 0x79, 0xA5, 0xC0, 0x00, 0x00, 8192,  20,  32,  512,   16,  1,  3, 50,  	0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	 	|A_SMALL|S_NOR|S_CB    	 	},
+    // [128MB] K9F1G08U0M,A
+    { 0xEC, 0xF1, 0x80, 0x15, 0x40, 0x00, 1024,  20,  64, 2048,   64,  2,  2, 50,  	0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	 	|A_BIG  |S_NOR|S_CB|S_CP	},
+    // [128MB] K9F1G08U0C	K9F1G08U0B[ Twc:50 Ws: 0 Wp: 35 Wh: 15]
+    { 0xEC, 0xF1, 0x00, 0x95, 0x40, 0x00, 1024,  20,  64, 2048,   64,  2,  2, 25,  	0, 15, 10,  0, 15, 10, A_08BIT|A_SLC	 	|A_BIG  |S_NOR|S_CB	 	  	},
+    // [256MB] KBE00S00AB	MCP MEMORY - Supply Voltage: Vcc 2.5 ~ 2.9 
+    { 0xEC, 0x71, 0x5A, 0x3F, 0x00, 0x00,16384,  20,  32,  512,   16,  1,  3, 50,  	0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	 	|A_SMALL|S_NOR	    	 	},
+	// [256MB] K9F2G08U0M, K9K2G08U0M/A ~TEST(A)
+    { 0xEC, 0xDA, 0x00, 0x15, 0x00, 0x00, 2048,  20,  64, 2048,   64,  2,  3, 50,  	0, 35, 15,  0, 35, 15, A_08BIT|A_SLC	 	|A_BIG  |S_NOR|S_CB|S_CP 	},
+	// [256MB] K9F2G08U0A
+    { 0xEC, 0xDA, 0x10, 0x95, 0x44, 0x00, 2048,  20,  64, 2048,   64,  2,  3, 25,  	0, 15, 10,  0, 15, 10, A_08BIT|A_SLC     	|A_BIG  |S_NOR|S_MP	  		},
+    // [512MB] K9K4G08U0M
+    { 0xEC, 0xDC, 0xC1, 0x15, 0x00, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 30,  	0, 20, 10,  0, 20, 10, A_08BIT|A_SLC	 	|A_BIG  |S_NOR|S_CB|S_CP   	},
+    // [512MB] K9F4G08U0M
+    { 0xEC, 0xDC, 0x10, 0x95, 0x00, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 25,  	0, 15, 10,  0, 15, 10, A_08BIT|A_SLC	 	|A_BIG  |S_NOR|S_CB		    },
+    // [256MB] K9G2G08U0M
+	{ 0xEC, 0xDA, 0x14, 0x25, 0x44, 0x00, 1024,  25, 128, 2048,   64,  2,  3, 30,  	0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	 	|A_BIG  |S_NOR|S_MP	 		},	
+    // [512MB] K9G4G08U0M/A		[  1GB] K9L8G08U1M
+    { 0xEC, 0xDC, 0x14, 0x25, 0x54, 0x00, 2048,  40, 128, 2048,   64,  2,  3, 30,  	0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	 	|A_BIG  |S_NOR|S_MP	    	},
+    // [512MB] K9G4G08U0B
+    { 0xEC, 0xDC, 0x14, 0xA5, 0x54, 0x00, 2048,  25, 128, 2048,   64,  2,  3, 25,  	0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	 	|A_BIG  |S_NOR|S_MP	    	},
+    // [  1GB] K9K8G08UOM		[  2GB] K9WAG08U1M 	
+    { 0xEC, 0xD3, 0x51, 0x95, 0x00, 0x00, 8192,  20,  64, 2048,   64,  2,  3, 25,  	0, 15, 10,  0, 15, 10, A_08BIT|A_SLC	 	|A_BIG  |S_NOR|S_CB			},
+    // [  1GB] K9L8G08UOM		[  2GB] K9HAG08U1M
+    { 0xEC, 0xD3, 0x55, 0x25, 0x00, 0x00, 4096,  40, 128, 2048,   64,  2,  3, 35,  	0, 25, 10,  0, 25, 10, A_08BIT|A_MLC	 	|A_BIG  |S_NOR|S_MP|S_IL   	},
+    // [  1GB] K9G8G08UOM		[  2GB] K9LAG08U1M 
+    { 0xEC, 0xD3, 0x14, 0x25, 0x64, 0x00, 4096,  40, 128, 2048,   64,  2,  3, 35,  	0, 25, 10,  0, 25, 10, A_08BIT|A_MLC	 	|A_BIG  |S_NOR|S_MP			},
+    // [  1GB] K9G8G08UOA/B		[  2GB] K9LAG08U1A 
+    { 0xEC, 0xD3, 0x14, 0xA5, 0x64, 0x00, 4096,  25, 128, 2048,   64,  2,  3, 50,  	0, 30, 20,  0, 30, 20, A_08BIT|A_MLC	 	|A_BIG  |S_NOR|S_MP			},	
+    // [  2GB] K9LAG08UOM	  	[  4GB] K9HBG08U1M	  [  8GB] K9MCG08U5M
+    { 0xEC, 0xD5, 0x55, 0x25, 0x68, 0x00, 8192,  40, 128, 2048,   64,  2,  3, 30,  	0, 20, 10,  0, 20, 10, A_08BIT|A_MLC	 	|A_BIG  |S_NOR|S_MP|S_IL	},
+	// [  2GB] K9LAG08UOA/B	 
+	{ 0xEC, 0xD5, 0x55, 0xA5, 0x68, 0x00, 8192,  25, 128, 2048,   64,  2,  3, 25,  	0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	 	|A_BIG  |S_NOR|S_MP|S_IL	},
+    // [  2GB] K9GAG08UOM	// 4K Page
+    { 0xEC, 0xD5, 0x14, 0xB6, 0x74, 0x00, 4096,  25, 128, 4096,  128,  2,  3, 25,  	0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	 	|A_BIG  |S_NOR|S_MP			},
+    // [  4GB] K9LBG08UOM		[  8GB] K9HCG08U1M    [ 16G] K9MDG08U5M
+    { 0xEC, 0xD7, 0x55, 0xB6, 0x78, 0x00, 8192,  25, 128, 4096,  128,  2,  3, 25,  	0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	 	|A_BIG  |S_NOR|S_MP|S_IL	},
+    // [  2GB] K9GAG08UOD		[ 4GB] K9LBG08U1D	  [ 8GB] K9HCG08U5D
+    { 0xEC, 0xD5, 0x94, 0x29, 0x34, 0x41, 4096,  25, 128, 4096,  218,  2,  3, 30,   0, 15, 10,  0, 15, 10, A_08BIT|A_MLC_8BIT	|A_BIG  |S_NOR|S_MCP		},
+    // [  4GB] K9LBG08UOD		[  8GB] K9HCG08U1D	  [ 16G] K9MDG08U5D   [ 32G] K9PDG08U5D
+    { 0xEC, 0xD7, 0xD5, 0x29, 0x38, 0x41, 8192,  25, 128, 4096,  218,  2,  3, 30,  	0, 20, 10,  0, 20, 10, A_08BIT|A_MLC_8BIT	|A_BIG  |S_NOR|S_MP|S_IL	}
+};
+
+const NAND_IO_FEATURE	MICRON_NAND_DevInfo[] =
+{
+    //*=======================================================================================================================================================
+    //*[        DEVICE CODE       ][           SIZE            ][               Cycle                     ][               		   ATTRIBUTE                 ]
+    //*-------------------------------------------------------------------------------------------------------------------------------------------------------
+    //* 1st, 2nd,  3rd,  4th,  5th,  6th,  PBpV,BBpZ, PpB, Page,Spare,Col,Low,Twc, Ws, Wp, Wh, Rs, Rp, Rh
+    //*=======================================================================================================================================================
+    // [256MB] 29F2G08AAC		
+    { 0x2C, 0xDA, 0x00, 0x00, 0x00, 0x00, 2048,  20,  64, 2048,   64,  2,  3, 30,	 0, 25, 15,  0, 25, 15, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CP    	    },
+    // [512MB] 29F4G08BAC,		[  1GB] 29F8G08FAC
+    { 0x2C, 0xDC, 0x80, 0x15, 0x50, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 30,	 0, 25, 15,  0, 25, 15, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CP		    },
+    // [512MB] 29F4G08AAA/C		[  1GB] 29F8G08DAA
+    { 0x2C, 0xDC, 0x90, 0x95, 0x54, 0x00, 4096,  20,  64, 2048,   64,  2,  3, 30,	 0, 25, 15,  0, 25, 15, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_MP			},
+    // [  2GB] 29F16G08FAA
+    { 0x2C, 0xD3, 0xD1, 0x95, 0x58, 0x00, 8192,  20,  64, 2048,   64,  2,  3, 30,	 0, 25, 15,  0, 25, 15, A_08BIT|A_SLC	  	|A_BIG  |S_NOR|S_CB|S_CP	},
+    // [  1GB] 29F08G08MAA   	[  2GB] 29F16G08QAA
+    { 0x2C, 0xD3, 0x94, 0xA5, 0x64, 0x00, 4096,  40, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP			},
+    // [  4GB] 29F32G08TAA
+    { 0x2C, 0xD5, 0xD5, 0xA5, 0x68, 0x00, 8192,  40, 128, 2048,   64,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC	  	|A_BIG  |S_NOR|S_MP			},
+    // [  2GB] 29F16G08MAA		[  4GB] 29F32G08QAA 
+	{ 0x2C, 0xD5, 0x94, 0x3E, 0x74, 0x00, 4096,  25, 128, 4096,  218,  2,  3, 30,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC_8BIT	|A_BIG  |S_NOR|S_MP			},
+	// [  8GB] 29F64G08TAA
+	{ 0x2C, 0xD7, 0xD5, 0x3E, 0x78, 0x00, 8192,  25, 128, 4096,  218,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC_8BIT	|A_BIG  |S_NOR|S_MP|S_IL	},
+	// [  4GB] 29F32G08CBAAA, 	[  8GB] 29F64G08CFAAA 
+	{ 0x2C, 0xD7, 0x94, 0x3E, 0x84, 0x00, 8192,  25, 128, 4096,  218,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC_12BIT	|A_BIG  |S_NOR|S_MCP		},
+	// [ 16GB] 29F128G08CJAA 
+	{ 0x2C, 0xD9, 0xD5, 0x3E, 0x88, 0x00,16384,  25, 128, 4096,  218,  2,  3, 25,	 0, 15, 10,  0, 15, 10, A_08BIT|A_MLC_12BIT	|A_BIG  |S_NOR|S_MP|S_IL	}	
+};
+
+const NAND_IO_MAKERINFO	NAND_SupportMakerInfo =
+ {
+	// MAXIMUM SUPPORT NANDFLASH
+	MAX_SUPPORT_SAMSUNG_NAND,
+	MAX_SUPPORT_TOSHIBA_NAND,
+	MAX_SUPPORT_HYNIX_NAND,
+	MAX_SUPPORT_ST_NAND,
+	MAX_SUPPORT_MICRON_NAND,
+	// NAND MAKER ID
+	SAMSUNG_NAND_MAKER_ID,
+	TOSHIBA_NAND_MAKER_ID,
+	HYNIX_NAND_MAKER_ID,
+	ST_NAND_MAKER_ID,
+	MICRON_NAND_MAKER_ID,
+	// POINTER OF NANDFLASH INFOMATION
+	(NAND_IO_FEATURE*)SAMSUNG_NAND_DevInfo,
+	(NAND_IO_FEATURE*)TOSHIBA_NAND_DevInfo,
+	(NAND_IO_FEATURE*)HYNIX_NAND_DevInfo,
+	(NAND_IO_FEATURE*)ST_NAND_DevInfo,
+	(NAND_IO_FEATURE*)MICRON_NAND_DevInfo	
+};
+
+const NAND_IO_LBA_MAKERINFO	LBA_NAND_SupportMakerInfo =
+ {
+	// MAXIMUM SUPPORT NANDFLASH
+	MAX_SUPPORT_TOSHIBA_LBA_NAND,
+	// NAND MAKER ID
+	TOSHIBA_NAND_MAKER_ID,
+	// POINTER OF NANDFLASH INFOMATION
+	(NAND_IO_FEATURE*)TOSHIBA_LBA_NAND_DevInfo
+};
+
+const unsigned char NAND_LBA_VFP_AREA_Signature[] =
+{
+	"NANDLBASIGNATURE"
+};
+
+#define NAND_IO_MAX_SHIFT_FACTOR_FOR_MULTIPLY	16
+
+#if defined (_LINUX_)		/* 09.07.24 */
+const unsigned short int    NAND_IO_ShiftFactorForMultiplay[NAND_IO_MAX_SHIFT_FACTOR_FOR_MULTIPLY] __attribute__((aligned(8))) =
+{
+    1,      //     1 = 2^0
+    2,      //     2 = 2^1
+    4,      //     4 = 2^2
+    8,      //     8 = 2^3
+    16,     //    16 = 2^4
+    32,     //    32 = 2^5
+    64,     //    64 = 2^6
+    128,    //   128 = 2^7
+    256,    //   256 = 2^8
+    512,    //   512 = 2^9
+    1024,   //  1024 = 2^10
+    2048,   //  2048 = 2^11
+    4096,   //  4096 = 2^12
+    8192,   //  8192 = 2^13
+    16384,  // 16384 = 2^14
+    32768	// 32768 = 2^15
+};
+
+const unsigned char	ALL_FF_ECC_BCH_04BIT_12[28] __attribute__((aligned(8))) =
+{ 
+	0x48,0xF6,0x3C,0xC9,0xAA,0x45,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00	
+};
+
+const unsigned char	ALL_FF_ECC_BCH_04BIT_16[28] __attribute__((aligned(8))) =
+{ 
+	0xC4,0x2A,0xDC,0xB4,0x25,0xCC,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+};
+
+// BCH 4bit Code: 6.5 Byte
+const unsigned char	ALL_FF_ECC_BCH_04BIT_512[28] __attribute__((aligned(8))) =
+{ 
+	0xEB,0x37,0xCC,0x63,0x96,0xCA,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+};
+
+// BCH 8bit Code:  13 Byte
+const unsigned char	ALL_FF_ECC_BCH_08BIT_512[28] __attribute__((aligned(8))) =
+{ 
+	0x08,0x75,0x8B,0x6F,0x48,0x36,0xA6,0xBC,0x16,0x61,0x58,0xDB,0x52,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+};
+
+// BCH 12bit Code:  19.5 Byte
+const unsigned char	ALL_FF_ECC_BCH_12BIT_512[28] __attribute__((aligned(8)))= 
+{ 
+	0x81,0xEC,0xE8,0x4E,0xE3,0x46,0x44,0xA1,0x3F,0x8A,0x29,0x06,0xD0,0x90,
+	0x06,0x76,0x21,0x32,0x3E,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+};
+
+// BCH 14bit Code:  23 Byte
+const unsigned char	ALL_FF_ECC_BCH_14BIT_512[28] __attribute__((aligned(8)))= 
+{ 
+	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
+	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
+};  
+
+// BCH 16bit Code:  26 Byte
+const unsigned char	ALL_FF_ECC_BCH_16BIT_512[28] __attribute__((aligned(8)))= 
+{ 
+	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
+	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
+};
+
+#else
+
+const unsigned short int    NAND_IO_ShiftFactorForMultiplay[NAND_IO_MAX_SHIFT_FACTOR_FOR_MULTIPLY] =
+{
+    1,      //     1 = 2^0
+    2,      //     2 = 2^1
+    4,      //     4 = 2^2
+    8,      //     8 = 2^3
+    16,     //    16 = 2^4
+    32,     //    32 = 2^5
+    64,     //    64 = 2^6
+    128,    //   128 = 2^7
+    256,    //   256 = 2^8
+    512,    //   512 = 2^9
+    1024,   //  1024 = 2^10
+    2048,   //  2048 = 2^11
+    4096,   //  4096 = 2^12
+    8192,   //  8192 = 2^13
+    16384,  // 16384 = 2^14
+    32768	// 32768 = 2^15
+};
+
+const unsigned char	ALL_FF_ECC_BCH_04BIT_12[28] =
+{ 
+	0x48,0xF6,0x3C,0xC9,0xAA,0x45,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+};
+
+const unsigned char	ALL_FF_ECC_BCH_04BIT_16[28] =
+{ 
+	0xC4,0x2A,0xDC,0xB4,0x25,0xCC,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+};
+
+// BCH 4bit Code: 6.5 Byte
+const unsigned char	ALL_FF_ECC_BCH_04BIT_512[28] =
+{ 
+	0xEB,0x37,0xCC,0x63,0x96,0xCA,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+};
+
+// BCH 8bit Code:  13 Byte
+const unsigned char	ALL_FF_ECC_BCH_08BIT_512[28] =
+{ 
+	0x08,0x75,0x8B,0x6F,0x48,0x36,0xA6,0xBC,0x16,0x61,0x58,0xDB,0x52,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+};
+
+// BCH 12bit Code:  19.5 Byte
+const unsigned char	ALL_FF_ECC_BCH_12BIT_512[28] = 
+{ 
+	0x81,0xEC,0xE8,0x4E,0xE3,0x46,0x44,0xA1,0x3F,0x8A,0x29,0x06,0xD0,0x90,
+	0x06,0x76,0x21,0x32,0x3E,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+};
+
+// BCH 14bit Code:  23 Byte
+const unsigned char	ALL_FF_ECC_BCH_14BIT_512[28] = 
+{ 
+	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
+	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
+};  
+
+// BCH 16bit Code:  26 Byte
+const unsigned char	ALL_FF_ECC_BCH_16BIT_512[28] = 
+{ 
+	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
+	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
+};
+
+#endif
+
+//=============================================================================
+//*
+//*
+//*                           [ GLOBAL VARIABLE DEFINE ]
+//*
+//*
+//=============================================================================
+NAND_IO_CYCLE		WriteCycleTime;
+NAND_IO_CYCLE		ReadCycleTime;
+NAND_IO_CYCLE		CommCycleTime;
+unsigned int		gMaxBusClkMHZ;
+unsigned int		gCycleTick;
+
+NAND_IO_ECC_INFO	gMLC_ECC_4Bit;
+NAND_IO_ECC_INFO	gMLC_ECC_8Bit;
+NAND_IO_ECC_INFO	gMLC_ECC_12Bit;
+NAND_IO_ECC_INFO	gMLC_ECC_14Bit;
+NAND_IO_ECC_INFO	gMLC_ECC_16Bit;
+
+	
+unsigned int		gNAND_IO_DataBusType;
+
+PGPIO 				pGPIO;
+PNFC				pNFC;
+PECC				pECC;
+PIOBUSCFG			pIOBUSCFG_T;
+#if defined(_WINCE_)
+tSYSTEM_PARAM  		*pSYS_PARAM;
+#endif
+PGDMANCTRL			pNAND_DMA;
+
+unsigned int		gInterLeavePageAddr;
+unsigned int		gInterLeaveCSNum;
+unsigned short int	gInterLeaveIoStatus;
+unsigned int		gInterLeaveWriteStatus;
+
+/* Micron Interleaver */
+unsigned int		gInterLeaveDie0BlockAddr;
+unsigned int		gInterLeaveDie1BlockAddr;
+
+unsigned int		gNANDIO_GSELReg;
+unsigned int		gNANDIO_GIOCONReg;
+unsigned int		gNANDIO_GDATASet;
+unsigned int		gNAND_GPIO_ON_OFF = ENABLE;
+
+unsigned int		*gpDMA_PhyBuffer0;
+unsigned int		*gpDMA_WorkBuffer0;
+unsigned int		*gpDMA_PhyBuffer1;
+unsigned int		*gpDMA_WorkBuffer1;
+
+NAND_IO_DEVINFO 	*gDevInfo;
+NAND_IO_DEVINFO 	rDevInfo;
+
+#if defined(TCC89XX) || defined(TCC92XX)
+int					gDRV_GDMA_Handle_NAND;
+sDRV_GDMA			gDRV_GDMA_NAND	=
+{
+	0 | DRV_GDMA_CFG_StartByHwReqLevel
+	| DRV_GDMA_CFG_AckAtRead
+	| DRV_GDMA_CFG_Arbitration//| DRV_GDMA_CFG_NoArbitration
+	| DRV_GDMA_CFG_BufNum_1
+	| DRV_GDMA_CFG_1HopUnit_16Byte
+	| DRV_GDMA_CFG_ReadBW_32Bit
+	| DRV_GDMA_CFG_WriteBW_32Bit
+	, DRV_GDMA_HwREQ_NFC
+	, 0,
+};
+#endif
+
+//#define SPEED_CHECK
+#if defined(SPEED_CHECK)
+//#define READ_SPEED_CHECK
+//#define WRITE_SPEED_CHECK
+#endif
+
+#if defined(_WINCE_)
+#pragma pack(8)
+unsigned char				gNAND_IO_ShareEccBuffer[ 512 ];
+unsigned char				gNAND_IO_TempBuffer[ 32 ];
+#pragma pack()
+#elif defined(_LINUX_)
+unsigned char				gNAND_IO_ShareEccBuffer[ 512 ] __attribute__((aligned(8)));
+unsigned char				gNAND_IO_TempBuffer[ 32 ] __attribute__((aligned(8)));
+#else
+__align(8) unsigned char	gNAND_IO_ShareEccBuffer[ 512 ];
+__align(8) unsigned char	gNAND_IO_TempBuffer[ 32 ];
+#endif
+
+NAND_LBA_CALLBACK_HANDLER	NAND_IO_LBA_CallBackLcdDisplay;
+
+//=============================================================================
+//*
+//*
+//*                           [ LOCAL FUNCTIONS DEFINE ]
+//*
+//*
+//=============================================================================
+static __inline void				NAND_IO_SetDataWidth( U32 width );
+static __inline void				NAND_IO_PreProcess( void );
+static __inline void				NAND_IO_PostProcess( void );
+static __inline void				NAND_IO_SetBasicCycleTime( void );
+static __inline void				NAND_IO_SetCommCycleTime( void );
+static __inline void				NAND_IO_SetWriteCycleTime(void);
+static __inline void				NAND_IO_SetReadCycleTime(void);
+static __inline void				NAND_IO_EnableChipSelect( U16 nChipNo );
+static __inline void				NAND_IO_DisableChipSelect( void );
+static __inline void				NAND_IO_EnableWriteProtect( void );
+static __inline void				NAND_IO_DisableWriteProtect( void );
+static __inline U32					NAND_IO_CheckReadyAndBusy( U16 nChipNo);
+static __inline void				NAND_IO_WaitBusy( U16 nChipNo );
+static __inline void				NAND_IO_WaitBusyForProgramAndErase( NAND_IO_DEVINFO *nDevInfo );
+static __inline void				NAND_IO_WaitBusyForCacheProgram( NAND_IO_DEVINFO *nDevInfo );
+
+static __inline void 				NAND_IO_ClearInterleaveStatus( NAND_IO_DEVINFO *nDevInfo );
+static __inline void 				NAND_IO_SetInterleaveStatus( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr );
+
+static __inline void				NAND_IO_Delay( void );
+
+static __inline NAND_IO_ERROR  		NAND_IO_WaitBusyForInterleave( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr );
+static __inline NAND_IO_ERROR		NAND_IO_ReadStatus( NAND_IO_DEVINFO *nDevInfo );
+static __inline NAND_IO_ERROR		NAND_IO_ReadStatusForMultiPlane( NAND_IO_DEVINFO *nDevInfo );
+static __inline NAND_IO_ERROR		NAND_IO_ReadStatusForCacheProgram( NAND_IO_DEVINFO *nDevInfo );
+static __inline NAND_IO_ERROR		NAND_IO_ReadStatusForInterleave( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr );
+static __inline NAND_IO_ERROR		NAND_IO_ReadStatusForInterleaveClear( NAND_IO_DEVINFO *nDevInfo );
+
+static __inline NAND_IO_ERROR		NAND_IO_GenerateRowColAddrForRead( U32 nPageAddr, U16 nColumnAddr, U32* rRowAddr, U32* rColumnAddr, NAND_IO_DEVINFO *nDevInfo );
+static __inline NAND_IO_ERROR		NAND_IO_GenerateRowColAddrForWrite( U32 nPageAddr, U16 nColumnAddr, U32* rRowAddr, U32* rColumnAddr, NAND_IO_DEVINFO *nDevInfo );
+static __inline NAND_IO_ERROR		NAND_IO_GenerateRowColAddrForCBandCP( U32 nPageAddr, U16 nColumnAddr, U32* rRowAddr, U32* rColumnAddr, NAND_IO_DEVINFO *nDevInfo );
+static __inline void				NAND_IO_WriteRowColAddr( U32 nRowAddr, U32 nColumnAddr, NAND_IO_DEVINFO *nDevInfo );
+static __inline void 				NAND_IO_WriteColAddr( U32 nColumnAddr, NAND_IO_DEVINFO *nDevInfo );
+static __inline void				NAND_IO_WriteBlockPageAddr( U32 nBlockPageAddr, NAND_IO_DEVINFO *nDevInfo );
+static __inline void				NAND_IO_BusControl( NAND_IO_DEVINFO *nDevInfo );
+
+#if defined(NAND_IO_USE_DMA_ACCESS)
+static __inline void 				NAND_IO_SetupDMA(void * pSRC, unsigned uSrcInc, unsigned uSrcMask, void * pDST, unsigned uDstInc, unsigned uDstMask, int nMode, int nDSize );
+static __inline void 				NAND_IO_SetupDMADoubleBuf(  int nMode, int nDMACh );
+#endif
+static __inline void				NAND_IO_SetupECC( U16 nEccOnOff, U16 nEncDec, U16 nEccType, U16 nAccessType, U32 EccBaseAddr );
+static __inline NAND_IO_ERROR 		NAND_IO_EncodeECC( U16 nEccType, U8* nSpareBuffer );
+static __inline NAND_IO_ERROR		NAND_IO_CorrectionSLC( U8* nPageBuffer, U8* nSpareBuffer );
+static __inline NAND_IO_ERROR 		NAND_IO_CorrectionMLC( U16 nEccType, U8* nPageBuffer, U8* nSpareBuffer, U16 nDataSize );
+static __inline NAND_IO_ERROR 		NAND_IO_EncodeBootBinary( NAND_IO_DEVINFO *nDevInfo, U8 *nPageBuffer, int nEccOnOff );
+
+static __inline NAND_IO_ERROR 		NAND_IO_ReadSpareData( NAND_IO_DEVINFO *nDevInfo, U8 *nSpareBuffer, int nPageEccOnOff );
+static __inline NAND_IO_ERROR		NAND_IO_Read512DataDoubleBuf( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nReadPPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff, int nSpareOnOff );
+static __inline NAND_IO_ERROR		NAND_IO_Read512Data( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nReadPPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff, int nSpareOnOff );
+static __inline NAND_IO_ERROR 		NAND_IO_ReadSpareDataMTD( NAND_IO_DEVINFO *nDevInfo, U8 *nSpareBuffer, int nPageEccOnOff );
+static __inline NAND_IO_ERROR		NAND_IO_ReadUserSizeData( NAND_IO_DEVINFO *nDevInfo, U16 nColumnAddr, U32 nReadSize, U8 *nReadBuffer );
+static __inline NAND_IO_ERROR 		NAND_IO_Read512DataMTD( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nReadPPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff, int nSpareOnOff );
+
+static __inline NAND_IO_ERROR 		NAND_IO_WriteSpareData( NAND_IO_DEVINFO *nDevInfo, U8 *nSpareBuffer, int nPageEccOnOff );
+static __inline NAND_IO_ERROR		NAND_IO_Write512DataDoubleBuf( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nWritePPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+static __inline NAND_IO_ERROR		NAND_IO_Write512Data( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nWritePPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+static __inline NAND_IO_ERROR		NAND_IO_WriteUserSizeData( NAND_IO_DEVINFO *nDevInfo, U16 nColumnAddr, U32 nWriteSize, U8 *nWriteBuffer );
+static __inline NAND_IO_ERROR 		NAND_IO_Write512DataMTD( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nWritePPSize, U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+
+static __inline NAND_IO_ERROR		NAND_IO_GetShiftValueForFastMultiPly( U16 nValue, U16* rFactor );
+
+#if defined (NAND_LBA_INCLUDE)
+static __inline NAND_IO_ERROR 		NAND_IO_LBA_ReadData( NAND_IO_DEVINFO *nDevInfo, U16 nReadPPSize, U8 *nPageBuffer, U8 *nSpareBuffer );
+static __inline NAND_IO_ERROR 		NAND_IO_LBA_WriteData( NAND_IO_DEVINFO *nDevInfo, U16 nWritePPSize, U8 *nPageBuffer, U8 *nSpareBuffer );
+static __inline NAND_IO_ERROR 		NAND_IO_LBA_WriteDummyData( NAND_IO_DEVINFO *nDevInfo, U16 nWritePPSize );
+
+NAND_IO_ERROR 						NAND_IO_LBA_VFPInitArea( NAND_IO_DEVINFO *nDevInfo );
+NAND_IO_ERROR						NAND_IO_LBA_MDPGetTotalSectorSize(NAND_IO_DEVINFO * nDevInfo, unsigned long int * rTotalSector);
+NAND_IO_ERROR						NAND_IO_LBA_VFPGetTotalSectorSize(NAND_IO_DEVINFO * nDevInfo, U32 * rTotalSector);
+NAND_IO_ERROR						NAND_IO_LBA_VFPChangeSectorSize(NAND_IO_DEVINFO * nDevInfo, U32 nTotalSector);
+NAND_IO_ERROR						NAND_IO_LBA_SetTransferProtocol(NAND_IO_DEVINFO * nDevInfo, U8 nProtocol1, U8 nProtocol2);
+NAND_IO_ERROR 						NAND_IO_LBA_SetBootModeChange( NAND_IO_DEVINFO *nDevInfo, U8 nBootMode );
+NAND_IO_ERROR 						NAND_IO_LBA_SetRebootCmdChange( NAND_IO_DEVINFO *nDevInfo, U8 nRebootCmd );
+NAND_IO_ERROR 						NAND_IO_LBA_GetPersistentFunction( NAND_IO_DEVINFO *nDevInfo, U8 *rBootMode, U8 *rRebootCmd );
+NAND_IO_ERROR 						NAND_IO_LBA_GetTransferProtocol( NAND_IO_DEVINFO *nDevInfo, U8 *rProtocol1, U8 *rProtocol2 );
+NAND_IO_ERROR 						NAND_IO_LBA_GetBootMode( NAND_IO_DEVINFO *nDevInfo, U8 *rBootMode );
+NAND_IO_ERROR		 				NAND_IO_LBA_HighSpeedMode( NAND_IO_DEVINFO *nDevInfo, int nOnOff );
+NAND_IO_ERROR 						NAND_IO_LBA_ReadID( NAND_IO_DEVINFO *nDevInfo, NAND_IO_DEVID *nDeviceCode );
+NAND_IO_ERROR 						NAND_IO_LBA_Reset( NAND_IO_DEVINFO *nDevInfo );
+#endif
+
+//=============================================================================
+//*
+//*
+//*                     [ EXTERN VARIABLE & FUNCTIONS DEFINE ]
+//*
+//*
+//=============================================================================
+#if defined(_LINUX_) || defined(_WINCE_)
+int						TCC7XX_USBDRV_WriteToQueue( void ){ return 0;}
+extern unsigned int		gMAX_ROMSIZE;
+#else
+extern void				memcpy(void *pvDest, const void *pvSrc, unsigned long iCount);
+extern void				memset(void *pvDest, char cChar, unsigned long iCount);
+extern int				memcmp(const void *pvSrc1, const void *pvSrc2, unsigned long iCount);
+extern int				TCC7XX_USBDRV_WriteToQueue( void );
+extern unsigned int		gMAX_ROMSIZE;
+#endif
+
+extern unsigned			CRC32_TABLE[];
+
+#ifndef _LINUX_
+extern unsigned			fmemcpy16(void *dest, void *src, unsigned length);
+#endif
+
+#ifdef SPEED_CHECK
+void NAND_IO_GPIO_Toggle( U32 nBitNum )
+{
+	if( pGPIO->GPFDAT & nBitNum )
+		BITCLR(pGPIO->GPFDAT, nBitNum);
+	else
+		BITSET(pGPIO->GPFDAT, nBitNum);
+}
+#endif
+
+#if defined(_WINCE_)
+extern void B_RETAILMSG(const char * fmt, ...);
+#endif
+
+/******************************************************************************
+*
+*	unsigned char*	NAND_IO_TellLibraryVersion
+*
+*	Input	: NONE
+*	Output	: NONE
+*	Return	: NONE
+*
+*	Description :
+*
+*******************************************************************************/
+unsigned char*	NAND_IO_TellLibraryVersion( void )
+{
+	return (unsigned char*)NANDIO_Library_Version;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      NAND_IO_ERROR NAND_IO_NANDGPIOControlFlag( unsigned int on_off );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			on_off	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+*  REMARK:	  by nemo
+**************************************************************************/
+NAND_IO_ERROR NAND_IO_NANDGPIOControlFlag( unsigned int on_off )
+{
+	gNAND_GPIO_ON_OFF = on_off;
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_CallBackChangeWCtime
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_CallBackChangeWCtime( unsigned short int TotalMediaNum, NAND_IO_DEVINFO *nDevInfo )
+{
+	if ( nDevInfo->IoStatus == ENABLE )
+	{
+		//**************************************************************
+		// Case on K9NBG08U5M Samsung NANDFLASH
+		//**************************************************************
+		if ( nDevInfo->Feature.DeviceID.Code[0] == 0xEC &&
+			 nDevInfo->Feature.DeviceID.Code[1] == 0xD3 &&
+			 nDevInfo->Feature.DeviceID.Code[2] == 0x51 &&
+			 nDevInfo->Feature.DeviceID.Code[3] == 0x95 )
+		{
+			if ( TotalMediaNum == 4 )
+			{
+				nDevInfo->Feature.WCtime 	= 45;
+
+				nDevInfo->Feature.WriteSTP 	= 0;
+				nDevInfo->Feature.WriteWP 	= 30;
+				nDevInfo->Feature.WriteHLD 	= 15;
+
+				nDevInfo->Feature.ReadSTP	= 0;
+				nDevInfo->Feature.ReadPW 	= 30;
+				nDevInfo->Feature.ReadHLD 	= 15;
+				
+				NAND_IO_SetCycle( nDevInfo );
+			}
+		}
+		//**************************************************************
+		// Case on K9MBG08U5M Samsung NANDFLASH
+		//**************************************************************
+		else if ( nDevInfo->Feature.DeviceID.Code[0] == 0xEC &&
+			 	  nDevInfo->Feature.DeviceID.Code[1] == 0xD3 &&
+				  nDevInfo->Feature.DeviceID.Code[2] == 0x55 &&
+				  nDevInfo->Feature.DeviceID.Code[3] == 0x25 )
+		{
+			if ( TotalMediaNum == 4 )
+			{
+				nDevInfo->Feature.WCtime = 45;
+
+				nDevInfo->Feature.WriteSTP 	= 0;
+				nDevInfo->Feature.WriteWP 	= 30;
+				nDevInfo->Feature.WriteHLD 	= 15;
+
+				nDevInfo->Feature.ReadSTP	= 0;
+				nDevInfo->Feature.ReadPW 	= 30;
+				nDevInfo->Feature.ReadHLD 	= 15;
+
+				NAND_IO_SetCycle( nDevInfo );
+			}
+		}
+		//**************************************************************
+		// Case on K9MCG08U5M Samsung NANDFLASH
+		//**************************************************************
+		else if ( nDevInfo->Feature.DeviceID.Code[0] == 0xEC &&
+			 	  nDevInfo->Feature.DeviceID.Code[1] == 0xD5 &&
+			 	  nDevInfo->Feature.DeviceID.Code[2] == 0x55 &&
+			 	  nDevInfo->Feature.DeviceID.Code[3] == 0x25 &&
+			 	  nDevInfo->Feature.DeviceID.Code[4] == 0x68 )
+		{
+			if ( TotalMediaNum == 4 )
+			{
+				nDevInfo->Feature.WCtime = 45;
+
+				nDevInfo->Feature.WriteSTP 	= 0;
+				nDevInfo->Feature.WriteWP 	= 30;
+				nDevInfo->Feature.WriteHLD 	= 15;
+
+				nDevInfo->Feature.ReadSTP	= 0;
+				nDevInfo->Feature.ReadPW 	= 30;
+				nDevInfo->Feature.ReadHLD 	= 15;
+
+				NAND_IO_SetCycle( nDevInfo );
+			}
+		}
+		//**************************************************************
+		// Case on K9MDG08U5M Samsung NANDFLASH
+		//**************************************************************
+		else if ( nDevInfo->Feature.DeviceID.Code[0] == 0xEC &&
+			 	  nDevInfo->Feature.DeviceID.Code[1] == 0xD7 &&
+			 	  nDevInfo->Feature.DeviceID.Code[2] == 0x55 &&
+			 	  nDevInfo->Feature.DeviceID.Code[3] == 0xB6 &&
+			 	  nDevInfo->Feature.DeviceID.Code[4] == 0x78 )
+		{
+			if ( TotalMediaNum == 4 )
+			{
+				nDevInfo->Feature.WCtime = 45;
+
+				nDevInfo->Feature.WriteSTP 	= 0;
+				nDevInfo->Feature.WriteWP 	= 30;
+				nDevInfo->Feature.WriteHLD 	= 15;
+
+				nDevInfo->Feature.ReadSTP	= 0;
+				nDevInfo->Feature.ReadPW 	= 30;
+				nDevInfo->Feature.ReadHLD 	= 15;
+
+				NAND_IO_SetCycle( nDevInfo );
+			}
+		}
+		//**************************************************************
+		// Case on K9MDG08U5D Samsung NANDFLASH
+		//**************************************************************
+		else if ( nDevInfo->Feature.DeviceID.Code[0] == 0xEC &&
+			 	  nDevInfo->Feature.DeviceID.Code[1] == 0xD7 &&
+			 	  nDevInfo->Feature.DeviceID.Code[2] == 0xD5 &&
+			 	  nDevInfo->Feature.DeviceID.Code[3] == 0x29 &&
+			 	  nDevInfo->Feature.DeviceID.Code[4] == 0x38 )
+		{
+			if ( TotalMediaNum == 2 )
+			{
+				nDevInfo->Feature.WCtime = 45;
+
+				nDevInfo->Feature.WriteSTP 	= 0;
+				nDevInfo->Feature.WriteWP 	= 30;
+				nDevInfo->Feature.WriteHLD 	= 15;
+
+				nDevInfo->Feature.ReadSTP	= 0;
+				nDevInfo->Feature.ReadPW 	= 30;
+				nDevInfo->Feature.ReadHLD 	= 15;
+
+				NAND_IO_SetCycle( nDevInfo );
+			}
+		}
+		//**************************************************************
+		// Case on TH58NVG5D4CTG20 Toshiba NANDFLASH
+		//**************************************************************
+		else if ( nDevInfo->Feature.DeviceID.Code[0] == 0x98 &&
+			 	  nDevInfo->Feature.DeviceID.Code[1] == 0xD5 &&
+			 	  nDevInfo->Feature.DeviceID.Code[2] == 0x85 &&
+			 	  nDevInfo->Feature.DeviceID.Code[3] == 0xA5 )
+		{
+			if ( TotalMediaNum == 2 )
+			{
+				nDevInfo->Feature.WCtime = 30;
+
+				nDevInfo->Feature.WriteSTP 	= 0;
+				nDevInfo->Feature.WriteWP 	= 20;
+				nDevInfo->Feature.WriteHLD 	= 10;
+
+				nDevInfo->Feature.ReadSTP	= 0;
+				nDevInfo->Feature.ReadPW 	= 20;
+				nDevInfo->Feature.ReadHLD 	= 10;
+
+				NAND_IO_SetCycle( nDevInfo );
+			}
+		}
+	}
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_SetCycle
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_SetCycle( NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned int	nMaxBusClk;
+	unsigned int	nMaxBusClkMHZ;
+	unsigned int	nCycleTick;
+	unsigned int	nTickRange = 10;
+	unsigned int	nDevSTP, nDevPW, nDevHLD;
+	unsigned int	nMCycleSTP, nMCyclePW, nMCycleHLD;
+	unsigned int	nSCycleSTP, nSCyclePW, nSCycleHLD;
+	int				nRemainSTP, nRemainPW, nRemainHLD;
+	int				nTempResult;
+	unsigned int	nReCompRatioSTP, nReCompRatioHLD, nReCompRatioPW;
+	unsigned int	nWrCompRatioSTP, nWrCompRatioHLD, nWrCompRatioPW;
+	unsigned int	nCoCompRatioSTP, nCoCompRatioHLD, nCoCompRatioPW;	
+	unsigned int	nReGateDelay, nWrGateDelay;
+
+	//===================================
+	// Get Max Bus CLK
+	//===================================
+	#ifdef FWDN_DOWNLOADER_INCLUDE
+	nMaxBusClk = 1000000;	// 100MHZ
+	#elif defined(TCC89XX) || defined(TCC92XX)
+	{
+		#if defined(_WINCE_)
+			#if defined(USE_V_ADDRESS)
+			nMaxBusClk = tcc_ckc_getfbusctrl(CLKCTRL4);		
+			#else
+			tca_ckc_init();
+			nMaxBusClk = tca_ckc_getfbusctrl(CLKCTRL4);
+			#endif
+		#elif defined(_LINUX_)
+			tca_ckc_init();
+			nMaxBusClk = tca_ckc_getfbusctrl(CLKCTRL4);
+		#else
+		    //#ifdef CLOCK_ADJUST_ENABLE
+		    //nMaxBusClk	= IO_CKC_GetCurrentBUSClock4Cycle();
+		    //#else
+		    //nMaxBusClk = IO_CKC_Fmaxbus;	// frequency of 100Hz unit
+		    //#endif
+			nMaxBusClk = 1660000;		
+		#endif
+	}
+	#endif
+
+	if ( nMaxBusClk  == 0 )
+		nMaxBusClk = 1660000;
+
+	/* Convert MHZ Value of Max Bus Clock */
+	if (!( nMaxBusClk / 10000 ))
+		return ERR_NAND_IO_WRONG_PARAMETER;
+	nMaxBusClkMHZ = ( nMaxBusClk / 10000 );
+
+	/* Get Cycke Tick */
+	nCycleTick = ( 1000 * nTickRange ) / nMaxBusClkMHZ;
+	if (( 1000 * nTickRange ) % nMaxBusClkMHZ )
+		++nCycleTick;
+
+	//===================================
+	// Set Cycle
+	//===================================
+
+	/* Basis Setting */
+	#if defined(TCC89XX) || defined(TCC92XX)	
+	nReGateDelay	= 15;	
+	nWrGateDelay	= 0;
+	#else
+	nReGateDelay	= 15;	
+	nWrGateDelay	= 0;
+	#endif
+
+	nReCompRatioSTP	= 6;
+	nReCompRatioHLD	= 0;
+	nReCompRatioPW	= 0;
+	
+	nWrCompRatioSTP	= 6;
+	nWrCompRatioHLD	= 0;
+	nWrCompRatioPW	= 0;
+
+	nCoCompRatioSTP	= 0;
+	nCoCompRatioHLD	= 0;
+	nCoCompRatioPW	= 0;
+
+	/* Read Cycle */
+	nDevSTP				= nDevInfo->Feature.ReadSTP * nTickRange;
+	nDevPW				= nDevInfo->Feature.ReadPW * nTickRange;
+	nDevHLD				= nDevInfo->Feature.ReadHLD * nTickRange;
+	
+	nMCycleSTP			= ( nDevSTP / nCycleTick ) + (( nDevSTP && !( nDevSTP / nCycleTick )) ? 1 : 0 );
+	nMCycleHLD			= ( nDevHLD / nCycleTick ) + (( nDevHLD && !( nDevHLD / nCycleTick )) ? 1 : 0 );
+	nRemainSTP			= ( nMCycleSTP * nCycleTick ) - nDevSTP;
+	nRemainHLD			= ( nMCycleHLD * nCycleTick ) - nDevHLD;
+	nSCycleSTP			= (( nRemainSTP < 0 ) && ((( nRemainSTP >= 0 ) ? nRemainSTP : -nRemainSTP ) > (int)(( nCycleTick / 10 ) * nReCompRatioSTP ))) ? 1 : 0;
+	nSCycleHLD			= (( nRemainHLD < 0 ) && ((( nRemainHLD >= 0 ) ? nRemainHLD : -nRemainHLD ) > (int)(( nCycleTick / 10 ) * nReCompRatioHLD ))) ? 1 : 0;
+	nTempResult			= ( nDevPW + ( nReGateDelay * nTickRange )) + (( nRemainSTP >= 0 ) ? 0 : -nRemainSTP ) + (( nRemainHLD >= 0 ) ? 0 : -nRemainHLD );
+	nMCyclePW			= ( nTempResult >= (int)nCycleTick ) ? ( nTempResult / nCycleTick ) : 1;
+	nRemainPW			= ( nMCyclePW * nCycleTick ) - ( nDevPW + ( nReGateDelay * nTickRange ));
+	nSCyclePW			= (( nRemainPW < 0 ) && ((( nRemainPW >= 0 ) ? nRemainPW : -nRemainPW ) > (int)(( nCycleTick / 10 ) * nReCompRatioPW ))) ? 1 : 0;
+
+	ReadCycleTime.STP	= (U8)(nMCycleSTP + nSCycleSTP);
+	ReadCycleTime.HLD	= (U8)(nMCycleHLD + nSCycleHLD);
+	ReadCycleTime.PW	= (U8)(nMCyclePW + nSCyclePW + (( nDevInfo->Feature.MediaType & A_PARALLEL ) ? 1: 0 ));
+
+	/* Write Cycle */
+	nDevSTP				= nDevInfo->Feature.WriteSTP * nTickRange;
+	nDevPW				= nDevInfo->Feature.WriteWP * nTickRange;
+	nDevHLD				= nDevInfo->Feature.WriteHLD * nTickRange;
+	
+	nMCycleSTP			= ( nDevSTP / nCycleTick ) + (( nDevSTP && !( nDevSTP / nCycleTick )) ? 1 : 0 );
+	nMCycleHLD			= ( nDevHLD / nCycleTick ) + (( nDevHLD && !( nDevHLD / nCycleTick )) ? 1 : 0 );
+	nRemainSTP			= ( nMCycleSTP * nCycleTick ) - nDevSTP;
+	nRemainHLD			= ( nMCycleHLD * nCycleTick ) - nDevHLD;
+	nSCycleSTP			= (( nRemainSTP < 0 ) && ((( nRemainSTP >= 0 ) ? nRemainSTP : -nRemainSTP ) > (int)(( nCycleTick / 10 ) * nWrCompRatioSTP ))) ? 1 : 0;
+	nSCycleHLD			= (( nRemainHLD < 0 ) && ((( nRemainHLD >= 0 ) ? nRemainHLD : -nRemainHLD ) > (int)(( nCycleTick / 10 ) * nWrCompRatioHLD ))) ? 1 : 0;
+	nTempResult			= ( nDevPW + ( nWrGateDelay * nTickRange )) + (( nRemainSTP >= 0 ) ? 0 : -nRemainSTP ) + (( nRemainHLD >= 0 ) ? 0 : -nRemainHLD );
+	nMCyclePW			= ( nTempResult >= (int)nCycleTick ) ? ( nTempResult / nCycleTick ) : 1;
+	nRemainPW			= ( nMCyclePW * nCycleTick ) - ( nDevPW + ( nWrGateDelay * nTickRange ));
+	nSCyclePW			= (( nRemainPW < 0 ) && ((( nRemainPW >= 0 ) ? nRemainPW : -nRemainPW ) > (int)(( nCycleTick / 10 ) * nWrCompRatioPW ))) ? 1 : 0;
+
+	WriteCycleTime.STP	= (U8)(nMCycleSTP + nSCycleSTP);
+	WriteCycleTime.HLD	= (U8)(nMCycleHLD + nSCycleHLD);
+	WriteCycleTime.PW	= (U8)(nMCyclePW + nSCyclePW);
+	
+	/* Comm Cycle */
+	nDevSTP				= 10 * nTickRange;
+	nDevPW				= 80 * nTickRange;
+	nDevHLD				= 40 * nTickRange;
+	
+	nMCycleSTP			= ( nDevSTP / nCycleTick ) + (( nDevSTP && !( nDevSTP / nCycleTick )) ? 1 : 0 );
+	nMCycleHLD			= ( nDevHLD / nCycleTick ) + (( nDevHLD && !( nDevHLD / nCycleTick )) ? 1 : 0 );
+	nRemainSTP			= ( nMCycleSTP * nCycleTick ) - nDevSTP;
+	nRemainHLD			= ( nMCycleHLD * nCycleTick ) - nDevHLD;
+	nSCycleSTP			= (( nRemainSTP < 0 ) && ((( nRemainSTP >= 0 ) ? nRemainSTP : -nRemainSTP ) > (int)(( nCycleTick / 10 ) * nCoCompRatioSTP ))) ? 1 : 0;
+	nSCycleHLD			= (( nRemainHLD < 0 ) && ((( nRemainHLD >= 0 ) ? nRemainHLD : -nRemainHLD ) > (int)(( nCycleTick / 10 ) * nCoCompRatioHLD ))) ? 1 : 0;
+	nTempResult			= ( nDevPW + ( nReGateDelay * nTickRange )) + (( nRemainSTP >= 0 ) ? 0 : -nRemainSTP ) + (( nRemainHLD >= 0 ) ? 0 : -nRemainHLD );
+	nMCyclePW			= ( nTempResult >= (int)nCycleTick ) ? ( nTempResult / nCycleTick ) : 1;
+	nRemainPW			= ( nMCyclePW * nCycleTick ) - ( nDevPW + ( nReGateDelay * nTickRange ));
+	nSCyclePW			= (( nRemainPW < 0 ) && ((( nRemainPW >= 0 ) ? nRemainPW : -nRemainPW ) > (int)(( nCycleTick / 10 ) * nCoCompRatioPW ))) ? 1 : 0;
+
+	CommCycleTime.STP	= (U8)(nMCycleSTP + nSCycleSTP);
+	CommCycleTime.HLD	= (U8)(nMCycleHLD + nSCycleHLD);
+	CommCycleTime.PW	= (U8)(nMCyclePW + nSCyclePW);
+
+	if (WriteCycleTime.STP >= 16)
+		WriteCycleTime.STP	= 15;
+	if (WriteCycleTime.PW >= 16)
+		WriteCycleTime.PW	= 15;
+	if (WriteCycleTime.HLD >= 16)
+		WriteCycleTime.HLD	= 15;
+	if (WriteCycleTime.HLD == 0)
+		WriteCycleTime.HLD	= 1;	
+
+	if (ReadCycleTime.STP >= 16)
+		ReadCycleTime.STP	= 15;
+	if (ReadCycleTime.PW >= 16)
+		ReadCycleTime.PW	= 15;
+	if (ReadCycleTime.HLD >= 16)
+		ReadCycleTime.HLD	= 15;
+
+	if (CommCycleTime.STP >= 16)
+		CommCycleTime.STP	= 15;
+	if (CommCycleTime.PW >= 16)
+		CommCycleTime.PW	= 15;
+	if (CommCycleTime.HLD >= 16)
+		CommCycleTime.HLD	= 15;
+
+	if ( gNAND_IO_DataBusType == NAND_IO_NFC_BUS )
+	{
+		WriteCycleTime.RegValue	= ( WriteCycleTime.STP << 8 ) + ( WriteCycleTime.PW << 4 ) + WriteCycleTime.HLD;
+		ReadCycleTime.RegValue	= ( ReadCycleTime.STP << 8 ) + ( ReadCycleTime.PW << 4 ) + ReadCycleTime.HLD;
+		CommCycleTime.RegValue	= ( CommCycleTime.STP << 8 ) + ( CommCycleTime.PW << 4 ) + CommCycleTime.HLD;
+	}
+	else if ( gNAND_IO_DataBusType == NAND_IO_MEM_BUS )
+	{
+		#if defined(TCC860x)
+			WriteCycleTime.RegValue	= ( WriteCycleTime.STP << 6 ) + ( WriteCycleTime.PW << 3 ) + WriteCycleTime.HLD;
+			ReadCycleTime.RegValue	= ( ReadCycleTime.STP << 6 ) + ( ReadCycleTime.PW << 3 ) + ReadCycleTime.HLD;
+			CommCycleTime.RegValue	= ( CommCycleTime.STP << 6 ) + ( CommCycleTime.PW << 3 ) + CommCycleTime.HLD;
+		#else
+		    WriteCycleTime.RegValue	= ( WriteCycleTime.STP << 11 ) + (( WriteCycleTime.PW - 1 ) << 3 ) + WriteCycleTime.HLD;
+		    ReadCycleTime.RegValue	= ( ReadCycleTime.STP << 11 ) + (( ReadCycleTime.PW - 1 ) << 3 ) + ReadCycleTime.HLD;
+		    CommCycleTime.RegValue	= ( CommCycleTime.STP << 11 ) + (( CommCycleTime.PW - 1 ) << 3 ) + CommCycleTime.HLD;
+		#endif
+	}
+
+	gMaxBusClkMHZ = nMaxBusClkMHZ;
+	gCycleTick = nCycleTick;
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_GetDeviceInfo
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_GetDeviceInfo( U16 nChipNo, NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned short int		j,k,l;
+	unsigned char			bFindMedia;
+	unsigned char			bFindMakerNo;
+	unsigned char			bMatchCount;
+	NAND_IO_DEVID			sDeviceCode1,sDeviceCode2;
+	NAND_IO_FEATURE			*sTempFeatureInfo;
+	NAND_IO_FEATURE			*sFindFeatureInfo;
+	NAND_IO_ERROR			res;
+
+	bFindMedia 				= FALSE;
+	nDevInfo->IoStatus		= 0; 
+	nDevInfo->ChipNo		= 0xFF;
+	gInterLeaveCSNum 		= 0;
+	gInterLeaveIoStatus		= 0;
+	gInterLeaveWriteStatus	= MULTI_PLANE_GOOD_BLOCK;
+
+	// Init Variable
+	sTempFeatureInfo	= (NAND_IO_FEATURE*)NAND_SupportMakerInfo.DevInfo[0];
+	sFindFeatureInfo	= (NAND_IO_FEATURE*)NAND_SupportMakerInfo.DevInfo[0];
+
+	//=====================================================================
+	// Search Matched NANDFLASH (x8 Bit Serial NAND)
+	//=====================================================================
+	for ( j = 0; j < 3; ++j )	/* Check Read ID during 3 turn */
+	{
+		//IO_CKC_EnableBUS( IO_CKC_BUS_NFC );
+		// 16Bit NAND Mask Disable
+		BITCLR( pNFC->NFC_CTRL, HwNFC_CTRL_MASK_EN );
+
+		/* Read Device CODE */
+		NAND_IO_ResetForReadID( nChipNo, NAND_IO_SERIAL_COMBINATION_MODE );			// x8 Bit NAND Search
+		NAND_IO_ReadID( nChipNo, &sDeviceCode1, NAND_IO_SERIAL_COMBINATION_MODE );	// x8 Bit NAND Search
+
+		/* Check Maker ID */
+		bFindMakerNo = 0xFF;
+		for ( k = 0; k < MAX_SUPPORT_MAKER_NAND; ++k )
+		{
+			if ( sDeviceCode1.Code[0] == NAND_SupportMakerInfo.MakerID[k] )
+			{
+				bFindMakerNo		= (unsigned char)k;
+				sTempFeatureInfo	= (NAND_IO_FEATURE*)NAND_SupportMakerInfo.DevInfo[k];
+				break;
+			}	
+		}
+			
+		if ( bFindMakerNo >= MAX_SUPPORT_MAKER_NAND )
+			continue;
+
+		/* Check Device ID */
+		for ( k = 0; k < NAND_SupportMakerInfo.MaxSupportNAND[bFindMakerNo]; ++k )
+		{
+			bMatchCount = 0;
+			
+			for ( l = 0; l < 5; ++l )
+			{
+				if ( sTempFeatureInfo->DeviceID.Code[l+1] == 0x00 )
+					++bMatchCount;
+				else if ( sDeviceCode1.Code[l+1] == sTempFeatureInfo->DeviceID.Code[l+1] )
+					++bMatchCount;
+			}
+
+			/* Found NAND Device */
+			if ( bMatchCount >= 5 )
+			{
+				bFindMedia = TRUE;
+				sFindFeatureInfo = sTempFeatureInfo;
+				break;
+			}
+			else
+				++sTempFeatureInfo;
+		}
+
+		/* Found NAND Device */
+		if ( bFindMedia == TRUE )
+			break;
+	}
+
+	if ( bFindMedia != TRUE )
+	{
+		//=====================================================================
+		// Search Matched NANDFLASH (x16 Bit Serial NAND)
+		//=====================================================================
+		for ( j = 0; j < 3; ++j )	/* Check Read ID during 3 turn */
+		{
+			//IO_CKC_EnableBUS( IO_CKC_BUS_NFC );
+			// 16Bit NAND Mask Enable
+			BITSET( pNFC->NFC_CTRL, HwNFC_CTRL_MASK_EN );
+
+			/* Read Device CODE */
+			NAND_IO_ResetForReadID( nChipNo, NAND_IO_PARALLEL_COMBINATION_MODE );			// x16 Bit NAND Command
+			NAND_IO_ReadID( nChipNo, &sDeviceCode1, NAND_IO_PARALLEL_COMBINATION_MODE );	// x16 Bit NAND Search
+
+			/* Check Maker ID */
+			bFindMakerNo = 0xFF;
+			for ( k = 0; k < MAX_SUPPORT_MAKER_NAND; ++k )
+			{
+				if ( sDeviceCode1.Code[0] == NAND_SupportMakerInfo.MakerID[k] )
+				{
+					bFindMakerNo		= (unsigned char)k;
+					sTempFeatureInfo	= (NAND_IO_FEATURE*)NAND_SupportMakerInfo.DevInfo[k];
+					break;
+				}	
+			}
+				
+			if ( bFindMakerNo >= MAX_SUPPORT_MAKER_NAND )
+				continue;
+
+			/* Check Device ID */
+			for ( k = 0; k < NAND_SupportMakerInfo.MaxSupportNAND[bFindMakerNo]; ++k )
+			{
+				bMatchCount = 0;
+				
+				for ( l = 0; l < 5; ++l )
+				{
+					if ( sTempFeatureInfo->DeviceID.Code[l+1] == 0x00 )
+						++bMatchCount;
+					else if ( sDeviceCode1.Code[l+1] == sTempFeatureInfo->DeviceID.Code[l+1] )
+						++bMatchCount;
+				}
+
+				/* Found NAND Device */
+				if ( bMatchCount >= 5 )
+				{
+					bFindMedia = TRUE;
+					sFindFeatureInfo = sTempFeatureInfo;
+					break;
+				}
+				else
+					++sTempFeatureInfo;
+			}
+
+			/* Found NAND Device */
+			if ( bFindMedia == TRUE )
+				break;
+		}
+	}
+
+	//=====================================================================
+	// If Media is founded
+	//=====================================================================
+	if ( bFindMedia == TRUE )
+	{
+		/* Get NAND Feature Info */
+		memcpy( (void*)&nDevInfo->Feature,
+			 	(void*)sFindFeatureInfo,
+				sizeof(NAND_IO_FEATURE) );
+
+		/* Get ECC Type Info */
+		if ( nDevInfo->Feature.MediaType & A_SLC )
+		{
+			nDevInfo->EccType = TYPE_ECC_FOR_1BIT_SLC_NANDFLASH;
+			nDevInfo->EccDataSize = 8;
+		}
+		else if ( nDevInfo->Feature.MediaType & A_MLC )
+		{
+			nDevInfo->EccType = TYPE_ECC_FOR_4BIT_MLC_NANDFLASH;
+			nDevInfo->EccDataSize = 8;
+		}
+		else if ( nDevInfo->Feature.MediaType & A_MLC_8BIT )
+		{
+			nDevInfo->EccType = TYPE_ECC_FOR_8BIT_MLC_NANDFLASH;
+			nDevInfo->EccDataSize = 20;
+			nDevInfo->Feature.SpareSize = 192;
+		}
+		else if ( nDevInfo->Feature.MediaType & A_MLC_12BIT )
+		{
+			nDevInfo->EccType = TYPE_ECC_FOR_12BIT_MLC_NANDFLASH;
+			nDevInfo->EccDataSize = 20;
+			nDevInfo->Feature.SpareSize = 192;
+		}
+			
+		if ( nDevInfo->Feature.PageSize == 4096 )
+			nDevInfo->DistrictNum = 1024;
+		else
+			nDevInfo->DistrictNum = 2048;
+		
+		//=====================================================================
+		//EXCEPTION: TH58NVG4D1D/5D1DTG20 TH58NVG6D1DTG20
+		//=====================================================================
+		if ( ( nDevInfo->Feature.DeviceID.Code[0]== 0x98 ) &&  ( nDevInfo->Feature.DeviceID.Code[1] == 0xD5 ) && ( nDevInfo->Feature.DeviceID.Code[2] == 0x94 ))
+			nDevInfo->DistrictNum = 2048;
+
+		if ( ( nDevInfo->Feature.DeviceID.Code[0]== 0x98 ) &&  ( nDevInfo->Feature.DeviceID.Code[1] == 0xD7 ) )
+			nDevInfo->DistrictNum = 2048;
+
+		if ( nDevInfo->Feature.MediaType & A_08BIT )
+		{
+		    #ifndef NAND_8BIT_ONLY
+		    /* Check if compositin of NAND is parallel or serial */
+		    NAND_IO_ResetForReadID( nChipNo, NAND_IO_PARALLEL_COMBINATION_MODE );
+		    NAND_IO_ReadID( nChipNo, &sDeviceCode2, NAND_IO_PARALLEL_COMBINATION_MODE );
+    
+		    if ( ((sDeviceCode2.Code[0] & 0xFF) == ((sDeviceCode2.Code[0] >> 8) & 0xFF)) &&
+			     ((sDeviceCode2.Code[1] & 0xFF) == ((sDeviceCode2.Code[1] >> 8) & 0xFF)) &&
+			     ((sDeviceCode2.Code[2] & 0xFF) == ((sDeviceCode2.Code[2] >> 8) & 0xFF)) &&
+			     ((sDeviceCode2.Code[3] & 0xFF) == ((sDeviceCode2.Code[3] >> 8) & 0xFF)) &&
+			     ((sDeviceCode2.Code[4] & 0xFF) == ((sDeviceCode2.Code[4] >> 8) & 0xFF)) )
+		    {
+			    nDevInfo->Feature.MediaType |= A_PARALLEL;
+				nDevInfo->Feature.MediaType |= A_DATA_WITDH_16BIT;
+			    nDevInfo->Feature.PageSize 	*= 2;
+			    nDevInfo->Feature.SpareSize *= 2;			    
+			    nDevInfo->CmdMask 	= 0xFFFF;
+		    }
+		    else
+		    {
+				nDevInfo->Feature.MediaType |= A_DATA_WITDH_08BIT;				
+			    nDevInfo->CmdMask 	= 0x00FF;
+		    }
+    
+		    #else
+				nDevInfo->Feature.MediaType |= A_DATA_WITDH_08BIT;				
+			    nDevInfo->CmdMask 	= 0x00FF;
+		    #endif
+		}
+		else
+		{
+			//IO_CKC_EnableBUS( IO_CKC_BUS_NFC );
+			// 16Bit NAND Mask Enable
+			BITSET( pNFC->NFC_CTRL, HwNFC_CTRL_MASK_EN );
+			nDevInfo->Feature.MediaType |= A_DATA_WITDH_16BIT;
+			nDevInfo->CmdMask = 0x00FF;
+		}
+		
+		/* Get Total Partial Page [512+16Bytes] */
+		nDevInfo->PPages = ( nDevInfo->Feature.PageSize / 512 );
+		
+		/* Get Shift Factors of PBpV, PpB, PageSize, SpareSize, PPages */
+		res = (NAND_IO_ERROR)SUCCESS;
+		res |= NAND_IO_GetShiftValueForFastMultiPly( nDevInfo->Feature.PBpV, &nDevInfo->ShiftPBpV );
+		res |= NAND_IO_GetShiftValueForFastMultiPly( nDevInfo->Feature.PpB, &nDevInfo->ShiftPpB );
+		res |= NAND_IO_GetShiftValueForFastMultiPly( nDevInfo->Feature.PageSize, &nDevInfo->ShiftPageSize );
+		res |= NAND_IO_GetShiftValueForFastMultiPly( nDevInfo->PPages, &nDevInfo->ShiftPPages );
+		res |= NAND_IO_GetShiftValueForFastMultiPly( nDevInfo->DistrictNum, &nDevInfo->ShiftDistrictNum );
+
+		nDevInfo->EccWholeDataSize =  ( nDevInfo->EccDataSize << nDevInfo->ShiftPPages );
+
+		if ( res != SUCCESS )
+			return res;
+		
+		for ( j = 0; j < 4; ++j )
+		{
+			nDevInfo->BadBlockInfo.BlockStatus[j] 	= MULTI_PLANE_GOOD_BLOCK;
+			nDevInfo->BadBlockInfo.BadBlkPHYAddr[j] = 0xFFFFFFFF;
+		}
+
+		NAND_IO_SetCycle( nDevInfo );
+	}
+	//=====================================================================
+	// Not Found
+	//=====================================================================
+	else
+	{
+		#if defined(USE_V_ADDRESS) && defined(_WINCE_)
+		#else
+		if ( nChipNo == 0 )
+		{
+			ND_TRACE("\n[NAND        ] No NAND device found!!! ID:");
+			for ( j = 0; j < 4; ++j )
+				ND_TRACE("0x%x ", ( sDeviceCode1.Code[j] & 0xFF ) );
+		}
+		#endif
+
+		return ERR_NAND_IO_FAILED_GET_DEVICE_INFO;
+	}
+
+	nDevInfo->IoStatus	= NAND_IO_STATUS_ENABLE;
+	nDevInfo->ChipNo	= nChipNo;
+
+	//=====================================================================
+	// gDevInfo( Global Variable ) Initialize 
+	//=====================================================================
+	if ( nDevInfo->ChipNo == 0 )
+		gDevInfo = (NAND_IO_DEVINFO *)nDevInfo;
+	
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	U32		NAND_IO_GetBUSTypeOfDataIO( void )
+*
+*	Input	: NONE
+*	Output	: NONE
+*	Return	: NONE
+*
+*	Description : Initialize NAND IO Layer
+*
+*******************************************************************************/
+U32 NAND_IO_GetBUSTypeOfDataIO( void )
+{
+	return gNAND_IO_DataBusType;
+}
+
+void NAND_IO_ECC_InfoInit( void )
+{
+	gMLC_ECC_4Bit.EccDataSize 			= 7;
+	gMLC_ECC_4Bit.EncodeFlag			= HwECC_IREQ_M4EF;
+	gMLC_ECC_4Bit.DecodeFlag			= HwECC_IREQ_M4DF;
+	gMLC_ECC_4Bit.ErrorNum				= 4;
+	gMLC_ECC_4Bit.All_FF_512_ECC_Code	= (U8 *)&ALL_FF_ECC_BCH_04BIT_512;
+		
+	gMLC_ECC_8Bit.EccDataSize 			= 13;
+	gMLC_ECC_8Bit.EncodeFlag			= HwECC_IREQ_M8EF;
+	gMLC_ECC_8Bit.DecodeFlag			= HwECC_IREQ_M8DF;
+	gMLC_ECC_8Bit.ErrorNum				= 8;
+	gMLC_ECC_8Bit.All_FF_512_ECC_Code	= (U8 *)&ALL_FF_ECC_BCH_08BIT_512;
+
+	gMLC_ECC_12Bit.EccDataSize 		= 20;
+	gMLC_ECC_12Bit.EncodeFlag			= HwECC_IREQ_M12EF;
+	gMLC_ECC_12Bit.DecodeFlag			= HwECC_IREQ_M12DF;
+	gMLC_ECC_12Bit.ErrorNum 			= 12;
+	gMLC_ECC_12Bit.All_FF_512_ECC_Code	= (U8 *)&ALL_FF_ECC_BCH_12BIT_512;
+
+	gMLC_ECC_14Bit.EccDataSize 		= 23;
+	gMLC_ECC_14Bit.EncodeFlag			= HwECC_IREQ_M14EF;
+	gMLC_ECC_14Bit.DecodeFlag			= HwECC_IREQ_M14DF;
+	gMLC_ECC_14Bit.ErrorNum 			= 14;
+	gMLC_ECC_14Bit.All_FF_512_ECC_Code	= (U8 *)&ALL_FF_ECC_BCH_14BIT_512;
+
+	gMLC_ECC_16Bit.EccDataSize 		= 26;
+	gMLC_ECC_16Bit.EncodeFlag			= HwECC_IREQ_M16EF;
+	gMLC_ECC_16Bit.DecodeFlag			= HwECC_IREQ_M16DF;
+	gMLC_ECC_16Bit.ErrorNum 			= 16;
+	gMLC_ECC_16Bit.All_FF_512_ECC_Code	= (U8 *)&ALL_FF_ECC_BCH_16BIT_512;
+
+	memset( gNAND_IO_TempBuffer, 0xFF, 32 );
+}
+
+void NAND_IO_InitDMABuffer( void )
+{
+	#if defined(_WINCE_)
+	tSYSTEM_PARAM	*pSYS_Work_PARAM	= (tSYSTEM_PARAM*)(SYSTEM_PARAM_BASEADDRESS);
+	#endif
+	
+	#if defined(_WINCE_)
+	gpDMA_PhyBuffer0 	= (unsigned int*)pSYS_Work_PARAM->DMA2.CH0_BUFFER;	// Working Address
+	gpDMA_WorkBuffer0 	= (unsigned int*)pSYS_PARAM->DMA2.CH0_BUFFER;		// Physical Address
+	gpDMA_PhyBuffer1 	= (unsigned int*)pSYS_Work_PARAM->DMA2.CH1_BUFFER;	// Working Address
+	gpDMA_WorkBuffer1 	= (unsigned int*)pSYS_PARAM->DMA2.CH1_BUFFER;		// Physical Address	
+	#elif defined(_LINUX_)
+	#ifdef KERNEL_DRIVER
+	gpDMA_PhyBuffer0 	= dma_t.dma_addr;
+	gpDMA_WorkBuffer0	= (unsigned int*)dma_t.v_addr;
+	gpDMA_PhyBuffer1 	= (unsigned char*)gpDMA_PhyBuffer0 + 512;
+	gpDMA_WorkBuffer1	= (unsigned char*)gpDMA_WorkBuffer0 + 512;
+	#else
+	gpDMA_PhyBuffer0 	= (unsigned int*)DMA_ADDR;
+	gpDMA_WorkBuffer0	= (unsigned int*)DMA_ADDR;
+	gpDMA_PhyBuffer1 	= (unsigned int*)DMA_ADDR + 512;
+	gpDMA_WorkBuffer1	= (unsigned int*)DMA_ADDR + 512;	
+	#endif
+	#else		// NU
+	gpDMA_PhyBuffer0 	= (unsigned int*)gpNandBuffer;
+	gpDMA_WorkBuffer0	= (unsigned int*)gpNandBuffer;
+	gpDMA_PhyBuffer1 	= (unsigned char*)gpDMA_PhyBuffer0 + 512;
+	gpDMA_WorkBuffer1	= (unsigned char*)gpDMA_WorkBuffer0 + 512;
+	#endif
+}
+
+/******************************************************************************
+*
+*	void    NAND_IO_Init( void )
+*
+*	Input	: NONE
+*	Output	: NONE
+*	Return	: NONE
+*
+*	Description : Initialize NAND IO Layer
+*
+*******************************************************************************/
+void NAND_IO_Init( void )
+{
+	unsigned int		i;
+	PEDI				pEDI;
+	PPIC 				pPIC;
+	NAND_IO_DEVINFO		sDevInfo;
+	NAND_IO_ERROR		res;
+	
+	memset( &sDevInfo, 0x00, sizeof(NAND_IO_DEVINFO));
+
+#if defined(USE_V_ADDRESS)
+	#if defined(_LINUX_)
+	pGPIO 		= (PGPIO)(&HwGPIO_BASE);
+	pEDI 		= (PEDI)(&HwEDI_BASE);
+	pNFC 		= (PNFC)(&HwNFC_BASE);
+	pECC 		= (PECC)(&HwECC_BASE);
+	pIOBUSCFG_T = (PIOBUSCFG)(&HwIOBUSCFG_BASE);
+	pNAND_DMA	= (PGDMANCTRL)(&HwGDMA2_BASE);
+	#if defined(_WINCE_)
+	pSYS_PARAM	= (ptSYSTEM_PARAM)(&SYSTEM_PARAM_BASEADDRESS);
+	#endif
+	pPIC		= (PPIC)(&HwPIC_BASE);
+	#elif defined(_WINCE_)
+	pGPIO 		= (PGPIO)tcc_allocbaseaddress((unsigned int)&HwGPIO_BASE);
+	pEDI 		= (PEDI)tcc_allocbaseaddress((unsigned int)&HwEDI_BASE);
+	pNFC 		= (PNFC)tcc_allocbaseaddress((unsigned int)&HwNFC_BASE);
+	pECC 		= (PECC)tcc_allocbaseaddress((unsigned int)&HwECC_BASE);
+	pIOBUSCFG_T = (PIOBUSCFG)tcc_allocbaseaddress((unsigned int)&HwIOBUSCFG_BASE);
+	pPIC		= (PPIC)tcc_allocbaseaddress((unsigned int)&HwPIC_BASE);
+	pSYS_PARAM	= (tSYSTEM_PARAM*)tcc_allocbaseaddress((unsigned int)SYSTEM_PARAM_BASEADDRESS);
+	pNAND_DMA	= (PGDMANCTRL)tcc_allocbaseaddress((unsigned int)&HwGDMA2_BASE);
+	#endif
+#else
+	pGPIO 		= (PGPIO)(&HwGPIO_BASE);
+	pEDI 		= (PEDI)(&HwEDI_BASE);
+	pNFC 		= (PNFC)(&HwNFC_BASE);
+	pECC 		= (PECC)(&HwECC_BASE);
+	pIOBUSCFG_T = (PIOBUSCFG)(&HwIOBUSCFG_BASE);
+	pPIC		= (PPIC)(&HwPIC_BASE);
+	#if defined(_WINCE_)
+	pSYS_PARAM	= (tSYSTEM_PARAM*)(SYSTEM_PARAM_BASEADDRESS);
+	#endif
+	pNAND_DMA	= (PGDMANCTRL)(&HwGDMA2_BASE);
+#endif
+
+	/*************************************/
+	/*Don't remove NAND_IO_Delay Function*/
+	/*************************************/
+	for( i = 0; i < 5000; ++i )
+		NAND_IO_Delay();
+
+	for ( i = 0; i < 2; ++i )
+	{
+		/***********************************/
+		/* Setting NANDFLASH on Memory Bus */
+		/***********************************/		
+		if ( i == 0 )
+		{
+			ASM_NOP;
+		}
+		/********************************/
+		/* Setting NANDFLASH on NFC Bus */
+		/********************************/		
+		else
+		{
+			pEDI->EDI_RDYCFG 	= 0x00000001;
+			//pEDI->EDI_CSNCFG0	= 0x00403265;
+			BITCSET(pEDI->EDI_CSNCFG0, 0xFFFF, 0x8765 );
+			
+			#ifdef NAND_8BIT_ONLY
+			pGPIO->GPBFN0 		= 0x11110000;	//NANDXD[7:4]
+			pGPIO->GPBFN1		= 0x00001111;	//NANDXD[3:0]
+			#else
+			pGPIO->GPBFN0 		= 0x11111111;	//NANDXD[11:8],[7:4]
+			pGPIO->GPBFN1 		= 0x11111111;	//NANDXD[15:12],[3:0]
+			#endif
+			pGPIO->GPBFN2 		= 0x11111111;	//{CSN0,XA2,XA1,XA0,OEN1,OEN0,WEN1,WEN0}
+			pGPIO->GPBFN3 		= 0x01011111;  	//{GPIOB[31],CSN1,RDY1,RDY0,XX,XX,XX,XX}
+
+			//=================================================
+			// NAND Write Portect Pin Set
+			//=================================================
+			#if defined(TCC89_92_BOARD)
+			pGPIO->GPBFN3 &= ~0x10000000;		// ND_WP: GPIO_B31
+			#else	// TCC9200S_BOARD
+			pGPIO->GPBFN2 &= ~0x01000000;		// ND_WP: GPIO_B22
+			#endif
+			// Write Protect Pin: Output Mode
+			BITSET( pGPIO->GPBEN, NAND_IO_NFC_nWPBit );
+
+			//=================================================
+			// TCC9200S_BOARD NAND Ready/Busy Pin Set
+			/* ND_RDY: GPIO_B31 */
+			//=================================================
+			#if defined(TCC9200S_BOARD)
+			pGPIO->GPBFN3 &= ~0x10000000;		// ND_RDY: GPIO_B31			
+			BITCLR(pGPIO->GPBEN, Hw31);
+			#endif
+	    
+		    gNAND_IO_DataBusType	= NAND_IO_NFC_BUS;
+
+		    /* Make Reset */
+		    pNFC->NFC_RST = 0;
+
+		    /* Set Default NFC Configuration */
+		    pNFC->NFC_CTRL	= HwNFC_CTRL_DEN_EN		|
+					          HwNFC_CTRL_CFG_NOACT	|
+					          HwNFC_CTRL_BSIZE_1	|
+						      (4 << 4)				|		// pw = 5
+					          (1 << 0);						// hold = 1
+
+			/* GPIO B Arbitration ENABLE */
+			pNFC->NFC_CTRL1 |= Hw31;
+			pNFC->NFC_CTRL1 |= Hw30;
+
+		    /* Enable Interrupt */
+			pNFC->NFC_IREQ 	= 0x77;				// Clear Interrupt
+			pPIC->CLR1		= HwINT1_NFC;
+		    BITSET( pPIC->SEL1, HwINT1_NFC);	// Set NFC as IRQ interrupt
+		    BITSET( pPIC->MODE1, HwINT1_NFC );	// Level type for NFC interrupt, IO_INT_HwNFC );	// Level type for NFC interrupt
+
+		    //IO_CKC_DisableBUS( IO_CKC_BUS_NFC );
+
+		    /* Searching NANDFLASH */
+		    res = NAND_IO_GetDeviceInfo( 0, &sDevInfo );
+
+			#ifdef SPEED_CHECK
+			{
+				pGPIO->GPFFN0 = 0xFFFFFFFF;
+				pGPIO->GPFEN  = 0xFFFFFFFF;
+				//pGPIO->GPFDAT = 0xFFFFFFFF;
+				pGPIO->GPFDAT = HwZERO;
+			}
+			#endif
+
+		    if ( res == SUCCESS )
+	    		break;	
+		}
+	}
+
+	/* Setup Variable about ECC */
+	//IO_CKC_EnableBUS( IO_CKC_BUS_ECC );
+	pECC->ECC_CTRL	= 0x04000000;		/* ECC Control Register */
+	pECC->ECC_BASE	= pNFC->NFC_WDATA;	/* Base Address for ECC Calculation */
+	pECC->ECC_MASK	= 0x00000000;		/* Address mask for ECC area */
+	//IO_CKC_DisableBUS( IO_CKC_BUS_ECC );	
+	
+	memcpy( &rDevInfo, &sDevInfo, sizeof(NAND_IO_DEVINFO) );
+
+	NAND_IO_ECC_InfoInit();
+
+	#ifdef NAND_IO_USE_DMA_ACCESS
+	NAND_IO_InitDMABuffer();
+	#endif
+}
+
+/******************************************************************************
+*
+*	void    NAND_IO_Reset
+*
+*	Input	: Chip Select Number
+*	Output	: NONE
+*	Return	: NONE
+*
+*	Description : Reset NANDFLASH
+*
+*******************************************************************************/
+void NAND_IO_Reset( U16 nChipNo, int nMode )
+{
+	/* Pre Process */
+	NAND_IO_PreProcess();
+	
+	/* Set Setuo Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nChipNo );
+
+	/* Set Data Bus as 16Bit */
+	NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	
+	/* Command RESET [ 0xFF ] */
+	if ( nMode == NAND_IO_PARALLEL_COMBINATION_MODE )
+		pNFC->NFC_CMD = 0xFFFF;
+	else
+		pNFC->NFC_CMD = 0x00FF;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nChipNo );
+
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+	
+}
+
+/******************************************************************************
+*
+*	void    NAND_IO_ResetForReadID
+*
+*	Input	: Chip Select Number
+*	Output	: NONE
+*	Return	: NONE
+*
+*	Description : Reset NANDFLASH
+*
+*******************************************************************************/
+void NAND_IO_ResetForReadID( U16 nChipNo, int nMode )
+{
+	unsigned int	i,j;
+	
+	/* Pre Process */
+	NAND_IO_PreProcess();
+	
+	/* Set Setuo Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nChipNo );
+
+	/* Set Data Bus as 16Bit */
+	NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+
+	/* Command RESET [ 0xFF ] */
+	if ( nMode == NAND_IO_PARALLEL_COMBINATION_MODE )
+		pNFC->NFC_CMD = 0xFFFF;
+	else
+		pNFC->NFC_CMD = 0x00FF;
+
+	/* Wait until it is ready */
+	for ( i = 0; i < 0x100; ++i )
+	{
+		for ( j = 0; j < 0x80; ++j )
+		{
+			ASM_NOP;
+		}
+	}
+
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+	
+}
+
+/******************************************************************************
+*
+*	void    NAND_IO_ReadID
+*
+*	Input	: Chip Select Number
+*			  Mode : 0 => Serial Composition , 1 => Parallel Composition
+*	Output	: NANDFLASH Device Code
+*	Return	: NONE
+*
+*	Description : Get Device Code of NANDFLASH
+*
+*******************************************************************************/
+void NAND_IO_ReadID( U16 nChipNo, NAND_IO_DEVID *nDeviceCode, int nMode )
+{
+	/* Pre Process */
+	NAND_IO_PreProcess();
+
+	/* Set Setup Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nChipNo );
+
+	/* Set Data Bus as 16Bit */
+	NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	
+	/* Parallel Composition */
+	if ( nMode == NAND_IO_PARALLEL_COMBINATION_MODE )
+	{
+		pNFC->NFC_CMD	= 0x9090;	/* Command READ ID [ 0x90 ] */
+		pNFC->NFC_SADDR	= 0x0000;	/* Address [ 0x00 ] */
+	}
+	/* Serial Composition */
+	else
+	{
+		pNFC->NFC_CMD	= 0x0090;	/* Command READ ID [ 0x90 ] */
+		pNFC->NFC_SADDR	= 0x0000;	/* Address [ 0x00 ] */
+	}
+	
+	/* Delay : tAR1[READID] Max 200nS */
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+
+	/* Parallel Composition */
+	if ( nMode == NAND_IO_PARALLEL_COMBINATION_MODE )
+	{
+		nDeviceCode->Code[0] = (U16)pNFC->NFC_SDATA;
+		nDeviceCode->Code[1] = (U16)pNFC->NFC_SDATA;
+		nDeviceCode->Code[2] = (U16)pNFC->NFC_SDATA;
+		nDeviceCode->Code[3] = (U16)pNFC->NFC_SDATA;
+		nDeviceCode->Code[4] = (U16)pNFC->NFC_SDATA;
+		nDeviceCode->Code[5] = (U16)pNFC->NFC_SDATA;
+	}	
+	/* Serial Composition */
+	else
+	{
+		nDeviceCode->Code[0] = (U8)( pNFC->NFC_SDATA & 0xFF );
+		nDeviceCode->Code[1] = (U8)( pNFC->NFC_SDATA & 0xFF );
+		nDeviceCode->Code[2] = (U8)( pNFC->NFC_SDATA & 0xFF );
+		nDeviceCode->Code[3] = (U8)( pNFC->NFC_SDATA & 0xFF );
+		nDeviceCode->Code[4] = (U8)( pNFC->NFC_SDATA & 0xFF );
+		nDeviceCode->Code[5] = (U8)( pNFC->NFC_SDATA & 0xFF );
+	}	
+
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+	
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_ReadSpare
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_ReadSpare( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U8 *nSpareBuffer )
+{
+	unsigned int		RowAddr, ColumnAddr;
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+
+	//=============================================
+	// PreProcess
+	// Set Setup and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP LOW
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_BusControl(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+		NAND_IO_ClearInterleaveStatus( nDevInfo );
+	else
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	NAND_IO_EnableWriteProtect();
+
+	//=============================================
+	// Read Data
+	//=============================================	
+	/* Generate Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForRead( nPageAddr, nDevInfo->Feature.PageSize, &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorReadSpare;
+
+	/* Write Row and Column Address	*/
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* Command READ2 [ 0x30 ] for Advance NandFlash */
+	if ( nDevInfo->Feature.MediaType & A_BIG )
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+	
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+	
+	/* Read Spare data from NANDFLASH */
+	res = NAND_IO_ReadSpareData( nDevInfo, 
+								 nSpareBuffer, 
+								 PAGE_ECC_OFF );
+	if ( res != SUCCESS )
+		goto ErrorReadSpare;
+							
+ErrorReadSpare:
+	//=============================================
+	// Disable Chip Select
+	// PostProcess
+	//=============================================	
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+	
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_ReadPage
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_ReadPage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
+								U16 nStartPPage, U16 nReadPPSize,
+								U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff )
+{
+	unsigned int		RowAddr, ColumnAddr;
+	unsigned int		nSpareOnOff;
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ) )
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+
+	if ( ( nStartPPage + nReadPPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+	
+	//=============================================
+	// PreProcess
+	// Set Setup and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP LOW
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_BusControl(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+	
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+		NAND_IO_ClearInterleaveStatus( nDevInfo );
+	else
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	NAND_IO_EnableWriteProtect();
+
+	#ifdef READ_SPEED_CHECK
+	BITCLR(pGPIO->GPBDAT, Hw13);
+	BITCLR(pGPIO->GPBDAT, Hw15);
+	#endif
+
+	//=============================================
+	// Read Data
+	//=============================================	
+	/* Generate Row and Column Address */
+	if ( ( nDevInfo->Feature.MediaType  & A_BIG ) || (( nDevInfo->Feature.MediaType  & A_SMALL ) && ( nDevInfo->Feature.MediaType  & A_PARALLEL )))
+		res = NAND_IO_GenerateRowColAddrForRead( nPageAddr, nDevInfo->Feature.PageSize, &RowAddr, &ColumnAddr, nDevInfo );
+	else
+		res = NAND_IO_GenerateRowColAddrForRead( nPageAddr, ( nStartPPage << 9 ), &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorReadPage;
+
+	/* Write Row and Column Address	*/
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* Command READ2 [ 0x30 ] for Advance NandFlash */
+	if ( nDevInfo->Feature.MediaType & A_BIG )
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+
+	#ifdef READ_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw15);
+	#endif
+	
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	#ifdef READ_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw15);
+	#endif
+	
+	/* Change Cycle */
+	NAND_IO_SetReadCycleTime();
+
+	/* Read Page Size data from NANDFLASH */
+	nSpareOnOff = TNFTL_READ_SPARE_ON;
+
+	if ( nDevInfo->Feature.MediaType & A_BIG )
+	{
+		res = NAND_IO_ReadSpareData( nDevInfo, nSpareBuffer, PAGE_ECC_ON );
+		if ( res != SUCCESS )
+			goto ErrorReadPage;
+
+		/* Change Cycle */
+		NAND_IO_SetCommCycleTime();
+		
+		/* Command Random Data Output [ 0x05 ] for Advance NandFlash */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0505;
+		
+		ColumnAddr = ( nStartPPage << 9 );
+		ColumnAddr	= ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT ) ? (ColumnAddr >> 1) : ColumnAddr;
+
+		NAND_IO_WriteColAddr( ColumnAddr, nDevInfo );
+
+		/* Command Random Data Output [ 0xE0 ] for Advance NandFlash */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0xE0E0;
+
+		/* Change Cycle */
+		NAND_IO_SetReadCycleTime();
+	}
+	else if (( nDevInfo->Feature.MediaType  & A_SMALL ) && ( nDevInfo->Feature.MediaType  & A_PARALLEL ))
+	{
+		res = NAND_IO_ReadSpareData( nDevInfo, nSpareBuffer, PAGE_ECC_ON );
+		if ( res != SUCCESS )
+			goto ErrorReadPage;
+
+		/* Change Cycle */
+		NAND_IO_SetCommCycleTime();
+
+		res = NAND_IO_GenerateRowColAddrForRead( nPageAddr, ( nStartPPage << 9 ), &RowAddr, &ColumnAddr, nDevInfo );
+		if ( res != SUCCESS )
+			goto ErrorReadPage;
+
+		/* Write Row and Column Address	*/
+		NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+		/* Wait until it is ready */
+		NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+		/* Change Cycle */
+		NAND_IO_SetReadCycleTime();
+	}
+
+	#ifdef READ_SPEED_CHECK
+	BITCLR(pGPIO->GPBDAT, Hw15);
+	NAND_IO_GPIO_Toggle(Hw15);
+	#endif
+
+	#if defined(NAND_IO_USE_DMA_DOUBLE_BUF)
+	res = NAND_IO_Read512DataDoubleBuf( nDevInfo,
+									    nStartPPage,
+									    nReadPPSize,
+									    nPageBuffer,
+									    nSpareBuffer,
+									    nEccOnOff,
+									    TNFTL_READ_SPARE_ON );
+	#else	
+	res = NAND_IO_Read512Data( nDevInfo,
+							   nStartPPage,
+							   nReadPPSize,
+							   nPageBuffer,
+							   nSpareBuffer,
+							   nEccOnOff,
+							   TNFTL_READ_SPARE_ON );		
+	#endif
+	
+	#ifdef READ_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw15);
+	#endif
+
+	/* Change Cycle */
+	NAND_IO_SetCommCycleTime();
+							
+ErrorReadPage:
+	//=============================================
+	// Disable Chip Select
+	// PostProcess
+	//=============================================	
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+	
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_ReadPageMTD
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_ReadPageMTD( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
+								   U16 nStartPPage, U16 nReadPPSize,
+								   U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff )
+{
+	unsigned int		RowAddr, ColumnAddr;
+	unsigned int		nSpareOnOff;
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ) )
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+
+	if ( ( nStartPPage + nReadPPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+	
+	//=============================================
+	// PreProcess
+	// Set Setup and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP LOW
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_BusControl(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+	
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+		NAND_IO_ClearInterleaveStatus( nDevInfo );
+	else
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	NAND_IO_EnableWriteProtect();
+
+	//=============================================	
+	// Read Data
+	//=============================================
+	/* Generate Row and Column Address */
+	if ( ( nDevInfo->Feature.MediaType  & A_BIG ) || (( nDevInfo->Feature.MediaType  & A_SMALL ) && ( nDevInfo->Feature.MediaType  & A_PARALLEL )))
+		res = NAND_IO_GenerateRowColAddrForRead( nPageAddr, nDevInfo->Feature.PageSize, &RowAddr, &ColumnAddr, nDevInfo );
+	else
+		res = NAND_IO_GenerateRowColAddrForRead( nPageAddr, ( nStartPPage << 9 ), &RowAddr, &ColumnAddr, nDevInfo );
+
+	if ( res != SUCCESS )
+		goto ErrorReadPage;
+
+	/* Write Row and Column Address	*/
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* Command READ2 [ 0x30 ] for Advance NandFlash */
+	if ( nDevInfo->Feature.MediaType & A_BIG )
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	/* Change Cycle */
+	NAND_IO_SetReadCycleTime();
+
+	/* Read Page Size data from NANDFLASH */
+	nSpareOnOff = TNFTL_READ_SPARE_ON;
+
+	if ( nDevInfo->Feature.MediaType & A_BIG )
+	{
+		res = NAND_IO_ReadSpareDataMTD( nDevInfo, nSpareBuffer, PAGE_ECC_ON );
+		if ( res != SUCCESS )
+			goto ErrorReadPage;
+
+		/* Change Cycle */
+		NAND_IO_SetCommCycleTime();
+		
+		/* Command Random Data Output [ 0x05 ] for Advance NandFlash */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0505;
+		
+		ColumnAddr = ( nStartPPage << 9 );
+		ColumnAddr	= ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT ) ? (ColumnAddr >> 1) : ColumnAddr;
+
+		NAND_IO_WriteColAddr( ColumnAddr, nDevInfo );
+
+		/* Command Random Data Output [ 0xE0 ] for Advance NandFlash */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0xE0E0;
+
+		/* Change Cycle */
+		NAND_IO_SetReadCycleTime();
+	}
+	else if (( nDevInfo->Feature.MediaType  & A_SMALL ) && ( nDevInfo->Feature.MediaType  & A_PARALLEL ))
+	{
+		res = NAND_IO_ReadSpareDataMTD( nDevInfo, nSpareBuffer, PAGE_ECC_ON );
+		if ( res != SUCCESS )
+			goto ErrorReadPage;
+
+		/* Change Cycle */
+		NAND_IO_SetCommCycleTime();
+
+		res = NAND_IO_GenerateRowColAddrForRead( nPageAddr, ( nStartPPage << 9 ), &RowAddr, &ColumnAddr, nDevInfo );
+		if ( res != SUCCESS )
+			goto ErrorReadPage;
+
+		/* Write Row and Column Address	*/
+		NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+		/* Wait until it is ready */
+		NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+		/* Change Cycle */
+		NAND_IO_SetReadCycleTime();
+	}
+
+	res = NAND_IO_Read512DataMTD( nDevInfo,
+								  nStartPPage,
+								  nReadPPSize,
+								  nPageBuffer,
+								  nSpareBuffer,
+								  nEccOnOff,
+								  TNFTL_READ_SPARE_ON );
+	/* Change Cycle */
+	NAND_IO_SetCommCycleTime();
+							
+ErrorReadPage:
+	//=============================================
+	// Disable Chip Select
+	// PostProcess
+	//=============================================	
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+	
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_ReadTwoPlanePage
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_ReadTwoPlanePage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr, U32 nSecondPageAddr,
+										U16 nStartPPage, U16 nReadPPSize,
+										U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff )
+{
+	unsigned int		RowAddr, ColumnAddr;
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ) )
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+
+	if ( ( nStartPPage + nReadPPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=============================================
+	// PreProcess
+	// Set Setup and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP LOW
+	//=============================================
+	NAND_IO_PreProcess();
+	NAND_IO_BusControl(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) &&
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+		NAND_IO_WaitBusyForInterleave( nDevInfo, nPageAddr );
+	else
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	NAND_IO_EnableWriteProtect();
+
+	//=============================================
+	// PRE-Operation
+	//=============================================
+	/* Generate Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForCBandCP( nPageAddr, ( ( 512 + nDevInfo->EccDataSize ) * nStartPPage ), &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorReadPage;
+
+	/* Two-Plane Page Read Command [0x60] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x6060;
+
+	/* Write Row Address: Fixed 'Low' */
+	NAND_IO_WriteBlockPageAddr( 0, nDevInfo );
+
+	/* Two-Plane Page Read Command 2 [0x60] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x6060;
+
+	NAND_IO_WriteBlockPageAddr( nSecondPageAddr, nDevInfo );
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	//=============================================
+	// Read Data
+	//=============================================	
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+
+	/* Write Col & Row Address: Fixed 'Low' */
+	NAND_IO_WriteRowColAddr( 0, 0, nDevInfo );
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0505;
+
+	/* Write Col Address: Valid */
+	NAND_IO_WriteColAddr( ColumnAddr, nDevInfo );
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0xE0E0;
+
+	/* Change Cycle */
+	NAND_IO_SetReadCycleTime();
+
+	/* Read Page Size data from NANDFLASH */
+	#if defined(NAND_IO_USE_DMA_DOUBLE_BUF)
+	res = NAND_IO_Read512DataDoubleBuf( nDevInfo,
+									    nStartPPage,
+									    nReadPPSize,
+									    nPageBuffer,
+									    nSpareBuffer,
+									    nEccOnOff,
+									    TNFTL_READ_SPARE_ON );
+	#else
+	res = NAND_IO_Read512Data( nDevInfo,
+							   nStartPPage,
+							   nReadPPSize,
+							   nPageBuffer,
+							   nSpareBuffer,
+							   nEccOnOff,
+							   TNFTL_READ_SPARE_ON );
+	#endif
+
+	/* Change Cycle */
+	NAND_IO_SetCommCycleTime();
+							
+ErrorReadPage:
+	//=============================================
+	// Disable Chip Select
+	// PostProcess
+	//=============================================	
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+	
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_ReadTwoPlaneLastPage
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_ReadTwoPlaneLastPage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
+											U16 nStartPPage, U16 nReadPPSize,
+											U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff )
+{
+	unsigned int		RowAddr, ColumnAddr;
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ) )
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+
+	if ( ( nStartPPage + nReadPPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=============================================
+	// PreProcess
+	// Set Setup and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP LOW
+	//=============================================
+	NAND_IO_PreProcess();
+	NAND_IO_BusControl(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) &&
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+		NAND_IO_ClearInterleaveStatus( nDevInfo );
+	else
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	NAND_IO_EnableWriteProtect();
+
+	//=============================================
+	// Read Data
+	//=============================================	
+	/* Generate Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForRead( nPageAddr, ( ( 512 + nDevInfo->EccDataSize ) * nStartPPage ), &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorReadPage;
+
+	/* Write Col & Row Address: Col Addr = Fixed 'Low' */
+	NAND_IO_WriteRowColAddr( RowAddr, 0, nDevInfo );
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0505;
+
+	/* Write Col Address: Valid */
+	NAND_IO_WriteColAddr( ColumnAddr, nDevInfo );
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0xE0E0;
+
+	/* Change Cycle */
+	NAND_IO_SetReadCycleTime();
+
+	/* Read Page Size data from NANDFLASH */
+	#if defined(NAND_IO_USE_DMA_DOUBLE_BUF)
+	res = NAND_IO_Read512DataDoubleBuf( nDevInfo,
+									    nStartPPage,
+									    nReadPPSize,
+									    nPageBuffer,
+									    nSpareBuffer,
+									    nEccOnOff,
+									    TNFTL_READ_SPARE_ON );
+	#else
+	res = NAND_IO_Read512Data( nDevInfo,
+							   nStartPPage,
+							   nReadPPSize,
+							   nPageBuffer,
+							   nSpareBuffer,
+							   nEccOnOff,
+							   TNFTL_READ_SPARE_ON );
+	#endif
+	/* Change Cycle */
+	NAND_IO_SetCommCycleTime();
+							
+ErrorReadPage:
+	//=============================================
+	// Disable Chip Select
+	// PostProcess
+	//=============================================	
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+	
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_ReadUserSizePage
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_ReadUserSizePage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
+										U16 nColumnAddr, U32 nReadSize, U8 *nReadBuffer )
+{
+	unsigned int		RowAddr, ColumnAddr;
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+
+	if ( (U32)( nColumnAddr + nReadSize ) > (U16)( nDevInfo->Feature.PageSize + nDevInfo->Feature.SpareSize ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=============================================
+	// PreProcess
+	// Set Setup Time and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP LOW	
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_BusControl(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+		NAND_IO_ClearInterleaveStatus( nDevInfo );
+	else
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	NAND_IO_EnableWriteProtect();
+		
+	//=============================================
+	// Read UserSize Data
+	//=============================================
+
+	/* Generate Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForRead( nPageAddr, nColumnAddr, &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorReadUserSizePage;
+
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+	
+	/* Command READ2 [ 0x30 ] for Advance NandFlash */
+	if ( nDevInfo->Feature.MediaType & A_BIG )
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+	
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	/* Change Cycle */
+	NAND_IO_SetReadCycleTime();
+
+	/* Read User Size data from NANDFLASH */
+	res = NAND_IO_ReadUserSizeData( nDevInfo,
+									nColumnAddr,
+									nReadSize,
+									nReadBuffer );
+	/* Change Cycle */
+	NAND_IO_SetCommCycleTime();
+
+	if ( res != SUCCESS )
+		goto ErrorReadUserSizePage;
+	
+ErrorReadUserSizePage:
+	//=============================================
+	// Disable Chip Select
+	// PostProcess
+	//=============================================	
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+	
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_WriteSpare
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_WriteSpare( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
+								  U8* nSpareBuffer, int nEccOnOff )
+{
+	unsigned int		RowAddr, ColumnAddr;
+	NAND_IO_ERROR		res;
+
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+
+	nEccOnOff = 0;
+	//=============================================
+	// PreProcess
+	// Set Setup Time and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP HIGH
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_BusControl(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+	{
+		res = NAND_IO_WaitBusyForInterleave( nDevInfo, nPageAddr );
+		if ( res != SUCCESS )
+			goto ErrorWritePage;	 
+	}
+	else
+	{
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+		NAND_IO_DisableWriteProtect();
+	}
+	
+	//=============================================
+	// Write Data
+	//=============================================
+	/* Generate Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForWrite( nPageAddr, nDevInfo->Feature.PageSize, &RowAddr, &ColumnAddr, nDevInfo );	
+	if ( res != SUCCESS )
+		goto ErrorWritePage;
+
+	/* Command Page Program #1 [ 0x80 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8080;
+
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* Change Cycle */
+	NAND_IO_SetWriteCycleTime();
+
+	/* Write Data to NAND FLASH */
+	res = NAND_IO_WriteSpareData( nDevInfo, nSpareBuffer, PAGE_ECC_OFF );
+	
+	/* Change Cycle */
+	NAND_IO_SetCommCycleTime();
+
+	if ( res != SUCCESS )
+		goto ErrorWritePage;
+	
+	/* Command Page Program #2 [ 0x10 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+	if ( !( ( nDevInfo->Feature.MediaType & S_IL ) || ( nDevInfo->ExtInterleaveUsable == TRUE ) ) )
+	{
+	    /* Wait until it is ready */
+	    NAND_IO_WaitBusyForProgramAndErase( nDevInfo );
+		    
+	    /* Check Status */
+	    res = NAND_IO_ReadStatus( nDevInfo );
+	    if ( res != SUCCESS )
+		{
+			nDevInfo->WriteStatus.ChipNo 			= (U8)nDevInfo->ChipNo;
+			nDevInfo->WriteStatus.BlockStatus 		= MULTI_PLANE_BAD_BLOCK;
+			nDevInfo->WriteStatus.ErrorPHYPageAddr 	= nPageAddr;
+			res = ERR_NAND_IO_FAILED_WRITE;
+			
+		    goto ErrorWritePage;
+		}
+	}
+	else
+	{
+		NAND_IO_SetInterleaveStatus( nDevInfo, nPageAddr );
+		gInterLeavePageAddr = nPageAddr;
+	}
+ErrorWritePage:
+	//=============================================
+	// FORCE TO SET WP LOW
+	// Disable Chip Select
+	// PostProcess
+	//=============================================
+	if ( !( ( nDevInfo->Feature.MediaType & S_IL ) || ( nDevInfo->ExtInterleaveUsable == TRUE  ) ) )
+		NAND_IO_EnableWriteProtect();
+	
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+	
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_WritePage
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_WritePage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
+								 U16 nStartPPage, U16 nWritePPSize,
+								 U8 *nPageBuffer, U8* nSpareBuffer, int nEccOnOff )
+{
+	unsigned int		RowAddr, ColumnAddr;	
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+		
+	if ( ( nStartPPage + nWritePPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=============================================
+	// PreProcess
+	// Set Setup Time and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP HIGH
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_BusControl(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+	{
+		res = NAND_IO_WaitBusyForInterleave( nDevInfo, nPageAddr );
+		if ( res != SUCCESS )
+			goto ErrorWritePage;
+	}
+	else
+	{
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+		NAND_IO_DisableWriteProtect();
+	}
+	
+	//=============================================
+	// Write Data
+	//=============================================
+	/* Generate Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForWrite( nPageAddr, ( nStartPPage << 9 ), &RowAddr, &ColumnAddr, nDevInfo );
+		
+	if ( res != SUCCESS )
+		goto ErrorWritePage;
+
+	/* Command Page Program #1 [ 0x80 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8080;
+
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* Change Cycle */
+	NAND_IO_SetWriteCycleTime();
+
+	/* Write Data to NAND FLASH */
+	#if defined(NAND_IO_USE_DMA_DOUBLE_BUF_WRITE)
+	res = NAND_IO_Write512DataDoubleBuf( nDevInfo,
+										 nStartPPage,
+										 nWritePPSize,
+										 nPageBuffer,
+										 nSpareBuffer,
+										 nEccOnOff );
+	#else
+	res = NAND_IO_Write512Data( nDevInfo,
+								nStartPPage,
+								nWritePPSize,
+								nPageBuffer,
+								nSpareBuffer,
+								nEccOnOff );
+	#endif
+	
+	/* Change Cycle */
+	NAND_IO_SetCommCycleTime();
+
+	if ( res != SUCCESS )
+		goto ErrorWritePage;
+	
+	/* Command Page Program #2 [ 0x10 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+	
+	if ( !( ( nDevInfo->Feature.MediaType & S_IL ) || ( nDevInfo->ExtInterleaveUsable == TRUE ) ) )
+	{
+	    /* Wait until it is ready */
+	    NAND_IO_WaitBusyForProgramAndErase( nDevInfo );
+		    
+	    /* Check Status */
+	    res = NAND_IO_ReadStatus( nDevInfo );
+	    if ( res != SUCCESS )
+		{
+			nDevInfo->WriteStatus.ChipNo 			= (U8)nDevInfo->ChipNo;
+			nDevInfo->WriteStatus.BlockStatus 		= MULTI_PLANE_BAD_BLOCK;
+			nDevInfo->WriteStatus.ErrorPHYPageAddr 	= nPageAddr;
+			res = ERR_NAND_IO_FAILED_WRITE;
+			
+		    goto ErrorWritePage;
+		}
+	}
+	else
+	{
+		NAND_IO_SetInterleaveStatus( nDevInfo, nPageAddr );
+		gInterLeavePageAddr = nPageAddr;		
+	}
+
+ErrorWritePage:
+	//=============================================
+	// FORCE TO SET WP LOW
+	// Disable Chip Select
+	// PostProcess
+	//=============================================
+	if ( !( ( nDevInfo->Feature.MediaType & S_IL ) || ( nDevInfo->ExtInterleaveUsable == TRUE  ) ) )
+		NAND_IO_EnableWriteProtect();
+	
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+	
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_WritePageMTD
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_WritePageMTD( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
+								 	U16 nStartPPage, U16 nWritePPSize,
+									U8 *nPageBuffer, U8* nSpareBuffer, int nEccOnOff )
+{
+	unsigned int		RowAddr, ColumnAddr;	
+	NAND_IO_ERROR		res;
+	
+	//=============================================
+	// Check Device and Parameter
+	//=============================================
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+		
+	if ( ( nStartPPage + nWritePPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=============================================
+	// PreProcess
+	// Set Setup Time and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP HIGH
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_BusControl(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+	{
+		res = NAND_IO_WaitBusyForInterleave( nDevInfo, nPageAddr );
+		if ( res != SUCCESS )
+			goto ErrorWritePage;
+	}
+	else
+	{
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+		NAND_IO_DisableWriteProtect();
+	}
+	
+	//=============================================
+	// Write Data
+	//=============================================
+
+	/* Generate Row and Column Address */
+	if ( nDevInfo->Feature.MediaType  & A_BIG )
+		res = NAND_IO_GenerateRowColAddrForWrite( nPageAddr, ( ( 512 + nDevInfo->EccDataSize ) * nStartPPage ), &RowAddr, &ColumnAddr, nDevInfo );
+	else
+		res = NAND_IO_GenerateRowColAddrForWrite( nPageAddr, ( 528 * nStartPPage ), &RowAddr, &ColumnAddr, nDevInfo );
+		
+	if ( res != SUCCESS )
+		goto ErrorWritePage;
+
+	/* Command Page Program #1 [ 0x80 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8080;
+
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* Change Cycle */
+	NAND_IO_SetWriteCycleTime();
+
+	/* Write Data to NAND FLASH */
+	res = NAND_IO_Write512DataMTD( nDevInfo,
+								   nStartPPage,
+								   nWritePPSize,
+								   nPageBuffer,
+								   nSpareBuffer,
+								   nEccOnOff );
+	
+	/* Change Cycle */
+	NAND_IO_SetCommCycleTime();
+
+	if ( res != SUCCESS )
+		goto ErrorWritePage;
+	
+	/* Command Page Program #2 [ 0x10 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+	if ( !( ( nDevInfo->Feature.MediaType & S_IL ) || ( nDevInfo->ExtInterleaveUsable == TRUE ) ) )
+	{
+	    /* Wait until it is ready */
+	    NAND_IO_WaitBusyForProgramAndErase( nDevInfo );
+		    
+	    /* Check Status */
+	    res = NAND_IO_ReadStatus( nDevInfo );
+	    if ( res != SUCCESS )
+		{
+			nDevInfo->WriteStatus.ChipNo 			= (U8)nDevInfo->ChipNo;
+			nDevInfo->WriteStatus.BlockStatus 		= MULTI_PLANE_BAD_BLOCK;
+			nDevInfo->WriteStatus.ErrorPHYPageAddr 	= nPageAddr;
+			res = ERR_NAND_IO_FAILED_WRITE;
+			
+		    goto ErrorWritePage;
+		}
+	}
+	else
+	{
+		NAND_IO_SetInterleaveStatus( nDevInfo, nPageAddr );
+		gInterLeavePageAddr = nPageAddr;		
+	}
+
+ErrorWritePage:
+	//=============================================
+	// FORCE TO SET WP LOW
+	// Disable Chip Select
+	// PostProcess
+	//=============================================
+	if ( !( ( nDevInfo->Feature.MediaType & S_IL ) || ( nDevInfo->ExtInterleaveUsable == TRUE  ) ) )
+		NAND_IO_EnableWriteProtect();
+	
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+	
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_WriteCachePage
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_WriteCachePage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
+									  U16 nStartPPage, U16 nWritePPSize,
+									  U8 *nPageBuffer, U8* nSpareBuffer, int nEccOnOff )
+{
+	unsigned int		RowAddr, ColumnAddr;	
+	NAND_IO_ERROR		res;
+
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+		
+	if ( ( nStartPPage + nWritePPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=============================================
+	// PreProcess
+	// Set Setup Time and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP HIGH
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_BusControl(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+	
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+		NAND_IO_ClearInterleaveStatus( nDevInfo );
+	else
+	{
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+		NAND_IO_DisableWriteProtect();
+	}
+
+	//=============================================
+	// Write Data
+	//=============================================
+
+	/* Generate Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForCBandCP( nPageAddr, ( nStartPPage << 9 ), &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorWritePage;
+
+	/* Command Page Program #1 [ 0x80 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8080;
+
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* Change Cycle */
+	NAND_IO_SetWriteCycleTime();
+
+	/* Write Data to NAND FLASH */
+	#if defined(NAND_IO_USE_DMA_DOUBLE_BUF_WRITE)
+	res = NAND_IO_Write512DataDoubleBuf( nDevInfo,
+										 nStartPPage,
+										 nWritePPSize,
+										 nPageBuffer,
+										 nSpareBuffer,
+										 nEccOnOff );
+	#else
+	res = NAND_IO_Write512Data( nDevInfo,
+								nStartPPage,
+								nWritePPSize,
+								nPageBuffer,
+								nSpareBuffer,
+								nEccOnOff );
+	#endif
+	
+	/* Change Cycle */
+	NAND_IO_SetCommCycleTime();
+
+	if ( res != SUCCESS )
+		goto ErrorWritePage;
+	
+	/* Command Page Program #2 [ 0x15 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1515;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusyForCacheProgram( nDevInfo );
+
+	/* Check Status */
+	res = NAND_IO_ReadStatusForCacheProgram( nDevInfo );
+	if ( res != SUCCESS )
+	{
+		nDevInfo->WriteStatus.ChipNo 			= (U8)nDevInfo->ChipNo;
+		nDevInfo->WriteStatus.BlockStatus 		= MULTI_PLANE_BAD_BLOCK;
+		nDevInfo->WriteStatus.ErrorPHYPageAddr 	= nPageAddr;
+		res = ERR_NAND_IO_FAILED_WRITE;
+
+		goto ErrorWritePage;
+	}
+
+ErrorWritePage:
+	//=============================================
+	// FORCE TO SET WP LOW
+	// Disable Chip Select
+	// PostProcess
+	//=============================================
+	//NAND_IO_EnableWriteProtect();
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+	
+	if ( res != SUCCESS )
+		return res;
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_WriteTwoPlanePage
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_WriteTwoPlanePage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
+									     U16 nStartPPage, U16 nWritePPSize,
+									     U8 *nPageBuffer, U8* nSpareBuffer, int nEccOnOff )
+{
+	unsigned int		RowAddr, ColumnAddr;
+	unsigned long int	dwTempPHYPageAddr;
+	NAND_IO_ERROR		res;
+
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+		
+	if ( ( nStartPPage + nWritePPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=============================================
+	// PreProcess
+	// Set Setup Time and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP HIGH
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_BusControl(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+	{
+		res = NAND_IO_WaitBusyForInterleave( nDevInfo, nPageAddr );
+		if ( res != SUCCESS )
+			goto ErrorWritePage;	
+	}
+	else
+	{
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+		NAND_IO_DisableWriteProtect();
+	}
+
+	//=============================================
+	// Write Data
+	//=============================================
+	if ( ( nDevInfo->Feature.DeviceID.Code[0] == SAMSUNG_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == HYNIX_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == ST_NAND_MAKER_ID ) )
+	{
+		if ( ( nDevInfo->Feature.MediaType & A_MLC ) || ( nDevInfo->Feature.MediaType & A_SLC ) || ( nDevInfo->Feature.MediaType & A_MLC_12BIT ) )
+		{
+		    dwTempPHYPageAddr = ( ( nDevInfo->Feature.PBpV << nDevInfo->ShiftPpB ) >> 1 );
+    
+	 	    if ( nPageAddr & dwTempPHYPageAddr )
+	 		    nPageAddr = dwTempPHYPageAddr;
+		    else
+			    nPageAddr = 0;
+	    }
+	}
+		
+	/* Generate Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForCBandCP( nPageAddr, ( nStartPPage << 9 ), &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorWritePage;
+
+	/* Command Page Program #1 [ 0x80 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8080;
+
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* Change Cycle */
+	NAND_IO_SetWriteCycleTime();
+
+	/* Write Data to NAND FLASH */
+	#if defined(NAND_IO_USE_DMA_DOUBLE_BUF_WRITE)
+	res = NAND_IO_Write512DataDoubleBuf( nDevInfo,
+										  nStartPPage,
+										  nWritePPSize,
+										  nPageBuffer,
+										  nSpareBuffer,
+										  nEccOnOff );
+	#else
+	res = NAND_IO_Write512Data( nDevInfo,
+								nStartPPage,
+								nWritePPSize,
+								nPageBuffer,
+								nSpareBuffer,
+								nEccOnOff );
+	#endif
+	
+	/* Change Cycle */
+	NAND_IO_SetCommCycleTime();
+
+	if ( res != SUCCESS )
+		goto ErrorWritePage;
+	
+	/* Command Multi Plane Page Program #2 [ 0x11 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1111;
+
+	if ( !( ( nDevInfo->Feature.MediaType & S_IL ) || ( nDevInfo->ExtInterleaveUsable == TRUE ) ) )
+		NAND_IO_WaitBusyForCacheProgram( nDevInfo );
+
+ErrorWritePage:
+	//=============================================
+	// FORCE TO SET WP LOW
+	// Disable Chip Select
+	// PostProcess
+	//=============================================
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+	
+	if ( res != SUCCESS )
+		return res;
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_WriteTwoPlaneLastPage
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_WriteTwoPlaneLastPage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
+									    	 U16 nStartPPage, U16 nWritePPSize,
+									    	 U8 *nPageBuffer, U8* nSpareBuffer, int LastPage, int nEccOnOff )
+{
+	unsigned int		RowAddr, ColumnAddr;	
+	NAND_IO_ERROR		res;
+
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+		
+	if ( ( nStartPPage + nWritePPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=============================================
+	// PreProcess
+	// Set Setup Time and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP HIGH
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_BusControl(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+	NAND_IO_DisableWriteProtect();
+
+	//=============================================
+	// Write Data
+	//=============================================
+
+	/* Generate Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForCBandCP( nPageAddr, ( nStartPPage << 9 ), &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorWritePage;
+
+	/* Command Page Program #1 [ 0x80 ] */
+	if ( ( nDevInfo->Feature.DeviceID.Code[0] == SAMSUNG_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == HYNIX_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == ST_NAND_MAKER_ID ) )
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8181;
+	else if ( ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID ) )
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8080;
+	
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* Change Cycle */
+	NAND_IO_SetWriteCycleTime();
+
+	/* Write Data to NAND FLASH */
+	#if defined(NAND_IO_USE_DMA_DOUBLE_BUF_WRITE)
+	res = NAND_IO_Write512DataDoubleBuf( nDevInfo,
+										  nStartPPage,
+										  nWritePPSize,
+										  nPageBuffer,
+										  nSpareBuffer,
+										  nEccOnOff );
+	#else
+	res = NAND_IO_Write512Data( nDevInfo,
+								nStartPPage,
+								nWritePPSize,
+								nPageBuffer,
+								nSpareBuffer,
+								nEccOnOff );
+	#endif
+	
+	/* Change Cycle */
+	NAND_IO_SetCommCycleTime();
+
+	if ( res != SUCCESS )
+		goto ErrorWritePage;
+	
+	/* Command Page Program #2 [ 0x10 ] */
+	if ( ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID )	 || ( nDevInfo->Feature.DeviceID.Code[0] == ST_NAND_MAKER_ID ) )
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+	else if ( ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID ) )	
+	{
+		if ( ( LastPage == MULTI_PLANE_LAST_PAGE ) || ( nDevInfo->ExtInterleaveUsable == TRUE ) )
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+		else if ( LastPage == MULTI_PLANE_MID_PAGE )
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1515;
+	}
+	else if ( ( nDevInfo->Feature.DeviceID.Code[0] == SAMSUNG_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == HYNIX_NAND_MAKER_ID ) )	
+	{
+		if ( nDevInfo->Feature.MediaType & S_MCP )
+		{
+			if ( LastPage == MULTI_PLANE_LAST_PAGE )
+				pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+			else if ( LastPage == MULTI_PLANE_MID_PAGE )
+				pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1515;
+		}
+		else
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+	}
+
+	if ( !( ( nDevInfo->Feature.MediaType & S_IL ) || ( nDevInfo->ExtInterleaveUsable == TRUE ) ) )
+	{
+		/* Wait until it is ready */
+		NAND_IO_WaitBusyForProgramAndErase( nDevInfo );
+			
+		/* Check Status */
+		if ( LastPage == MULTI_PLANE_LAST_PAGE )
+		{
+		    res = NAND_IO_ReadStatusForMultiPlane( nDevInfo );
+		    if ( res != SUCCESS )
+		    {
+			    nDevInfo->WriteStatus.ChipNo 			= (U8)nDevInfo->ChipNo;
+			    nDevInfo->WriteStatus.BlockStatus 		= MULTI_PLANE_BAD_BLOCK;
+			    nDevInfo->WriteStatus.ErrorPHYPageAddr 	= nPageAddr;
+			    res = ERR_NAND_IO_FAILED_WRITE;
+    
+			    goto ErrorWritePage;
+		    }
+	    }
+	}	
+	else
+	{
+		NAND_IO_SetInterleaveStatus( nDevInfo, nPageAddr );
+		gInterLeavePageAddr = nPageAddr;
+	}
+
+ErrorWritePage:
+	//=============================================
+	// FORCE TO SET WP LOW
+	// Disable Chip Select
+	// PostProcess
+	//=============================================
+	//NAND_IO_EnableWriteProtect();
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+	
+	if ( res != SUCCESS )
+		return res;
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_WriteUserSizePage
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_WriteUserSizePage( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr,
+										 U16 nColumnAddr, U32 nWriteSize, U8 *nWriteBuffer )
+{
+	unsigned int		RowAddr, ColumnAddr;	
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+		
+	if ( (U32)( nColumnAddr + nWriteSize ) > (U16)( nDevInfo->Feature.PageSize + nDevInfo->Feature.SpareSize ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=============================================
+	// PreProcess
+	// Set Setup Time and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP HIGH
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_BusControl(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+		NAND_IO_ClearInterleaveStatus( nDevInfo );
+	else
+	{
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+		NAND_IO_DisableWriteProtect();
+	}
+
+	//=============================================
+	// Write UserSize Data
+	//=============================================
+
+	/* Generate Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForWrite( nPageAddr, nColumnAddr, &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorWriteUserSizePage;
+
+	/* Command Page Program #1 [ 0x80 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8080;
+
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* Change Cycle */
+	NAND_IO_SetWriteCycleTime();
+
+	/* Write Data to NAND FLASH */
+	res = NAND_IO_WriteUserSizeData( nDevInfo,
+									 nColumnAddr,
+									 nWriteSize,
+									 nWriteBuffer );
+	/* Change Cycle */
+	NAND_IO_SetCommCycleTime();
+									 
+	if ( res != SUCCESS )
+		goto ErrorWriteUserSizePage;
+	
+	/* Command Page Program #2 [ 0x10 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusyForProgramAndErase( nDevInfo );
+
+	/* Check Status */
+	res = NAND_IO_ReadStatus( nDevInfo );
+	if ( res != SUCCESS )
+	{
+		nDevInfo->WriteStatus.ChipNo 			= (U8)nDevInfo->ChipNo;
+		nDevInfo->WriteStatus.BlockStatus 		= MULTI_PLANE_BAD_BLOCK;
+		nDevInfo->WriteStatus.ErrorPHYPageAddr 	= nPageAddr;
+		res = ERR_NAND_IO_FAILED_WRITE;
+		
+		goto ErrorWriteUserSizePage;
+	}
+
+ErrorWriteUserSizePage:
+	//=============================================
+	// FORCE TO SET WP LOW
+	// Disable Chip Select
+	// PostProcess
+	//=============================================
+	NAND_IO_EnableWriteProtect();
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+	
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_MakeBootBinary
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_MakeBootBinary( NAND_IO_DEVINFO *nDevInfo, U8 *nPageBuffer )
+{
+	NAND_IO_ERROR		res;
+
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+
+	//=============================================
+	// PreProcess
+	// Set Setup Time and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP HIGH
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_BusControl(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+		NAND_IO_ClearInterleaveStatus( nDevInfo );
+	else
+	{
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+		NAND_IO_DisableWriteProtect();
+	}
+
+	//=============================================
+	// ECC Encording
+	//=============================================
+	res = NAND_IO_EncodeBootBinary( nDevInfo, nPageBuffer, ECC_ON );
+
+	//=============================================
+	// FORCE TO SET WP LOW
+	// Disable Chip Select
+	// PostProcess
+	//=============================================
+	NAND_IO_EnableWriteProtect();
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+	
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_CopyBackPage
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_CopyBackPage( NAND_IO_DEVINFO *nDevInfo, U32 nDesPageAddr, U32 nSrcPageAddr )
+{
+	unsigned int		RowAddr, ColumnAddr;	
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+		
+	//=============================================
+	// PreProcess
+	// Set Setup Time and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP HIGH
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_BusControl(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+	NAND_IO_DisableWriteProtect();
+
+	//=============================================
+	// Read Source Page Address
+	//=============================================
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+	
+	/* Generate Src Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForCBandCP( nSrcPageAddr, 0, &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorCopyBackPage;
+
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* CopyBack Command #1 [ 0x35 ] */
+	if ( nDevInfo->Feature.MediaType & A_BIG )
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3535;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	//=============================================
+	// Copy Destination Page Address
+	//=============================================
+	/* CopyBack Command #2 */
+	if ( nDevInfo->Feature.MediaType & A_SMALL )
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8A8A;
+	else
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8585;
+
+	/* Generate Des Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForCBandCP( nDesPageAddr, 0, &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorCopyBackPage;
+
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* Waiting TADL Time 200nS */
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+
+	/* CopyBack Command #3 */
+	if ( nDevInfo->Feature.MediaType & A_SMALL )
+	{
+		// [ 32MB] K9F5608U0C, k9F5608U0B, K9F5608U0A
+		// [ 32MB] K9F5608Q0C, K9F5608Q0B
+		if (( nDevInfo->Feature.DeviceID.Code[0] == SAMSUNG_NAND_MAKER_ID ) &&
+			(( nDevInfo->Feature.DeviceID.Code[1] == 0x75 ) || ( nDevInfo->Feature.DeviceID.Code[1] == 0x35 )))
+		{
+			// Nothing
+		}
+		else
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+	}
+	else
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusyForProgramAndErase( nDevInfo );
+		
+	/* Check Status */
+	res = NAND_IO_ReadStatus( nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorCopyBackPage;
+
+ErrorCopyBackPage:
+	//=============================================
+	// FORCE TO SET WP LOW
+	// Disable Chip Select
+	// PostProcess
+	//=============================================
+	NAND_IO_EnableWriteProtect();
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+		
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_CopyBackTwoPlanePage
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_CopyBackTwoPlanePage( NAND_IO_DEVINFO *nDevInfo, U32 nDesPageAddr, U32 nSrcPageAddr )
+{
+	unsigned int		nReBlockPageAddr;
+	unsigned int		RowAddr, ColumnAddr;	
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+		
+	//=============================================
+	// PreProcess
+	// Set Setup Time and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP HIGH
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_BusControl(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+	NAND_IO_DisableWriteProtect();
+
+	//=============================================
+	// Read Source Page Address #1
+	//=============================================
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+	
+	/* Generate Src Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForCBandCP( nSrcPageAddr, 0, &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorCopyBackPage;
+
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* CopyBack Command #1 [ 0x35 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3535;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	//=============================================
+	// Read Source Page Address #2
+	//=============================================
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+	
+	/* Generate Src Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForCBandCP( nSrcPageAddr + nDevInfo->Feature.PpB, 0, &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorCopyBackPage;
+
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* CopyBack Command #1 [ 0x35 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3535;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	//=============================================
+	// Copy Destination Page Address
+	//=============================================
+	/* CopyBack Command #2 */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8585;
+
+	if ( nDesPageAddr & ( nDevInfo->Feature.PBpV / 2) * nDevInfo->Feature.PpB )
+		nReBlockPageAddr = (( nDevInfo->Feature.PBpV / 2) * nDevInfo->Feature.PpB);
+	else
+		nReBlockPageAddr = 0;
+		
+	/* Generate Des Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForCBandCP( nReBlockPageAddr, 0, &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorCopyBackPage;
+
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* Waiting TADL Time 200nS */
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+
+
+	/* CopyBack Command #3 */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1111;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusyForProgramAndErase( nDevInfo );
+		
+	/* Check Status */
+	res = NAND_IO_ReadStatus( nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorCopyBackPage;
+
+	//=============================================
+	// Copy Destination Page Address
+	//=============================================
+	/* CopyBack Command #2 */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8181;
+
+	/* Generate Des Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForCBandCP( nDesPageAddr+ nDevInfo->Feature.PpB, 0, &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorCopyBackPage;
+
+	/* Write Row and Column Address */
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* Waiting TADL Time 200nS */
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+
+
+	/* CopyBack Command #3 */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusyForProgramAndErase( nDevInfo );
+		
+	/* Check Status */
+	res = NAND_IO_ReadStatus( nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorCopyBackPage;
+
+ErrorCopyBackPage:
+	//=============================================
+	// FORCE TO SET WP LOW
+	// Disable Chip Select
+	// PostProcess
+	//=============================================
+	NAND_IO_EnableWriteProtect();
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+		
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_EraseBlock
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_EraseBlock( NAND_IO_DEVINFO *nDevInfo, U32 nBlockPageAddr, int nFormatMode )
+{
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+
+	//=============================================
+	// PreProcess
+	// Set Setup Time and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP HIGH
+	//=============================================
+	NAND_IO_PreProcess();
+	NAND_IO_BusControl(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+		NAND_IO_WaitBusyForInterleave( nDevInfo, nBlockPageAddr );
+	else
+	{
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+		NAND_IO_DisableWriteProtect();
+	}
+
+	//=============================================
+	// Erase Block
+	//=============================================
+
+	/* Command Block Erase #1 [ 0x60 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x6060;
+
+	/* Write Block Address */
+	NAND_IO_WriteBlockPageAddr( nBlockPageAddr, nDevInfo );
+
+	/* Command Erase Block #2 [ 0xD0 ] */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0xD0D0;
+
+	if ( !( ( nDevInfo->Feature.MediaType & S_IL ) || ( nDevInfo->ExtInterleaveUsable == TRUE ) ) || ( nFormatMode == INTER_LEAVE_OFF ) )
+	{
+	    /* Wait until it is ready */
+	    NAND_IO_WaitBusyForProgramAndErase( nDevInfo );
+    
+	    /* Check Status */
+	    res = NAND_IO_ReadStatus( nDevInfo );
+	    if ( res != SUCCESS )
+	    {
+			nDevInfo->BadBlockInfo.BlockStatus[nDevInfo->ChipNo] 	= MULTI_PLANE_BAD_BLOCK;
+			nDevInfo->BadBlockInfo.BadBlkPHYAddr[nDevInfo->ChipNo]	= nBlockPageAddr;
+		    goto ErrorEraseBlock;
+		}
+	}
+	else
+	{
+		NAND_IO_SetInterleaveStatus( nDevInfo, nBlockPageAddr );
+		if ( nDevInfo->BadBlockInfo.BlockStatus[nDevInfo->ChipNo]  != MULTI_PLANE_BAD_BLOCK )
+			nDevInfo->BadBlockInfo.BadBlkPHYAddr[nDevInfo->ChipNo]	= nBlockPageAddr;
+		res = (NAND_IO_ERROR)SUCCESS;
+	}
+ErrorEraseBlock:
+	//=============================================
+	// FORCE TO SET WP LOW
+	// Disable Chip Select
+	// PostProcess
+	//=============================================
+	if ( !( ( nDevInfo->Feature.MediaType & S_IL ) || ( nDevInfo->ExtInterleaveUsable == TRUE  ) ) )
+		NAND_IO_EnableWriteProtect();
+
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_EraseBlockForTwoPlane
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_EraseBlockForTwoPlane( NAND_IO_DEVINFO *nDevInfo, U32 nBlockPageAddr, int nFormatMode )
+{
+	unsigned int		nReBlockPageAddr;
+	unsigned long int	dwTempBlockPageAddr, dwAddSecondPageAddr;
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+
+	res = (NAND_IO_ERROR)SUCCESS;
+
+	//=============================================
+	// PreProcess
+	// Set Setup Time and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP HIGH
+	//=============================================
+	NAND_IO_PreProcess();
+	NAND_IO_BusControl(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+
+	//=============================================
+	// Read Status
+	//=============================================
+	/*  Wait until it is ready */
+	if ( ( ( gDevInfo->Feature.MediaType & S_IL ) || ( gDevInfo->ExtInterleaveUsable == TRUE ) ) && 
+	   ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+		NAND_IO_WaitBusyForInterleave( nDevInfo, nBlockPageAddr );
+	else
+	{
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+		NAND_IO_DisableWriteProtect();
+	}
+
+	//=============================================
+	// Erase Block
+	//=============================================
+    /* Command Block Erase #1 [ 0x60 ] */
+    pNFC->NFC_CMD = nDevInfo->CmdMask & 0x6060;
+
+	if ( ( nDevInfo->Feature.DeviceID.Code[0] == SAMSUNG_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == HYNIX_NAND_MAKER_ID ) || ( nDevInfo->Feature.DeviceID.Code[0] == ST_NAND_MAKER_ID ) )
+    {
+	    dwTempBlockPageAddr = ( ( nDevInfo->Feature.PBpV << nDevInfo->ShiftPpB ) >> 1 );
+
+ 	    if ( ( nDevInfo->Feature.MediaType & A_MLC ) || ( nDevInfo->Feature.MediaType & A_MLC_12BIT ) )
+		{	
+			//---------------------------------------------
+			//	SAMSUNG MLC(4BIT) ROW ADDR: FIXED LOW
+			//	HYNIX MLC(4BIT, 12BIT) ROW ADDR: FIXED LOW
+			//---------------------------------------------
+ 	    if ( nBlockPageAddr & dwTempBlockPageAddr )
+ 		    nReBlockPageAddr = dwTempBlockPageAddr;
+	    else
+		    nReBlockPageAddr = 0;
+		}
+		else if ( nDevInfo->Feature.MediaType & A_MLC_8BIT )
+		{
+			//---------------------------------------------
+			// SAMSUNG MLC(8BIT) ROW ADDR: REAL ADDR
+			//---------------------------------------------
+			nReBlockPageAddr = nBlockPageAddr;
+		}
+	    dwAddSecondPageAddr = nDevInfo->Feature.PpB;
+    }
+    else if ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID ) 
+    {
+	    nReBlockPageAddr = nBlockPageAddr;
+		dwAddSecondPageAddr = ( nDevInfo->DistrictNum << nDevInfo->ShiftPpB );
+    }
+	else if ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID ) 
+	{
+		nReBlockPageAddr = nBlockPageAddr;
+		dwAddSecondPageAddr = nDevInfo->Feature.PpB;
+	}
+	else
+	{
+		// Local variable Init
+		nReBlockPageAddr = 0;
+		dwAddSecondPageAddr = 0;
+
+		res = ERR_NAND_IO_WRONG_PARAMETER;
+		goto ErrorEraseBlock;
+	}
+    
+    /* Write Block Address */
+    NAND_IO_WriteBlockPageAddr( nReBlockPageAddr, nDevInfo ); // <==  1st Block
+
+    /* Command Block Erase #1 [ 0x60 ] */
+    pNFC->NFC_CMD = nDevInfo->CmdMask & 0x6060;
+
+    /* Write Block Address */
+    NAND_IO_WriteBlockPageAddr( nBlockPageAddr + dwAddSecondPageAddr, nDevInfo );	// <==  2nd Block
+
+    /* Command Erase Block #2 [ 0xD0 ] */
+    pNFC->NFC_CMD = nDevInfo->CmdMask & 0xD0D0;
+
+    if ( !( ( nDevInfo->Feature.MediaType & S_IL ) || ( nDevInfo->ExtInterleaveUsable == TRUE ) ) || ( nFormatMode == INTER_LEAVE_OFF ) )
+    {
+	    /* Wait until it is ready */
+	    NAND_IO_WaitBusyForProgramAndErase( nDevInfo );
+
+	    /* Check Status */
+	    res = NAND_IO_ReadStatusForMultiPlane( nDevInfo );
+	    if ( res != SUCCESS )
+		{
+			if ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID )
+			{
+				if ( res == NAND_IO_DISTRICT_0 )
+				{
+					nDevInfo->BadBlockInfo.BlockStatus[0]	= MULTI_PLANE_BAD_BLOCK;
+					nDevInfo->BadBlockInfo.BadBlkPHYAddr[0] = nBlockPageAddr;
+				}
+				else if ( res == NAND_IO_DISTRICT_1 )
+				{
+					nDevInfo->BadBlockInfo.BlockStatus[1] 	= MULTI_PLANE_BAD_BLOCK;
+					nDevInfo->BadBlockInfo.BadBlkPHYAddr[1] = ( nBlockPageAddr + dwAddSecondPageAddr );
+				}
+			}
+			else
+			{
+				nDevInfo->BadBlockInfo.BlockStatus[0]	= MULTI_PLANE_BAD_BLOCK;
+				nDevInfo->BadBlockInfo.BadBlkPHYAddr[0] = nBlockPageAddr;
+				nDevInfo->BadBlockInfo.BlockStatus[1] 	= MULTI_PLANE_BAD_BLOCK;
+				nDevInfo->BadBlockInfo.BadBlkPHYAddr[1] = ( nBlockPageAddr + dwAddSecondPageAddr );
+			}
+			
+			goto ErrorEraseBlock;
+		}
+	}
+    else
+    {
+	    NAND_IO_SetInterleaveStatus( nDevInfo, nBlockPageAddr );
+
+		if ( nDevInfo->Feature.MediaType & S_IL )
+		{
+			//=============================================	
+			// Inter Leave
+			//=============================================	
+			if ( nBlockPageAddr < (U32)( ( nDevInfo->Feature.PBpV >> 1 ) << nDevInfo->ShiftPpB ) )
+			{
+				if ( nDevInfo->BadBlockInfo.BlockStatus[0] != MULTI_PLANE_BAD_BLOCK )
+					nDevInfo->BadBlockInfo.BadBlkPHYAddr[0] = nBlockPageAddr;
+
+				if ( nDevInfo->BadBlockInfo.BlockStatus[1] != MULTI_PLANE_BAD_BLOCK )
+					nDevInfo->BadBlockInfo.BadBlkPHYAddr[1] = ( nBlockPageAddr + dwAddSecondPageAddr );
+			}
+			else
+			{
+				if ( nDevInfo->BadBlockInfo.BlockStatus[2] != MULTI_PLANE_BAD_BLOCK )
+					nDevInfo->BadBlockInfo.BadBlkPHYAddr[2] = nBlockPageAddr;
+
+				if ( nDevInfo->BadBlockInfo.BlockStatus[3] != MULTI_PLANE_BAD_BLOCK )
+					nDevInfo->BadBlockInfo.BadBlkPHYAddr[3] = ( nBlockPageAddr + dwAddSecondPageAddr );
+			}
+		}
+		else if ( nDevInfo->ExtInterleaveUsable == TRUE )
+		{
+			if ( nDevInfo->BadBlockInfo.BlockStatus[0] != MULTI_PLANE_BAD_BLOCK )
+				nDevInfo->BadBlockInfo.BadBlkPHYAddr[0] = nBlockPageAddr;
+
+			if ( nDevInfo->BadBlockInfo.BlockStatus[1] != MULTI_PLANE_BAD_BLOCK )
+				nDevInfo->BadBlockInfo.BadBlkPHYAddr[1] = ( nBlockPageAddr + dwAddSecondPageAddr );
+		}
+    }
+
+ErrorEraseBlock:
+	//=============================================
+	// FORCE TO SET WP LOW
+	// Disable Chip Select
+	// PostProcess
+	//=============================================
+	if ( !( ( nDevInfo->Feature.MediaType & S_IL ) || ( nDevInfo->ExtInterleaveUsable == TRUE  ) ) )
+		NAND_IO_EnableWriteProtect();
+
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+
+	if ( res != SUCCESS )
+		return res;
+
+	return (NAND_IO_ERROR)SUCCESS;
+	
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_GetFactoryBadMarkOfPBlock
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_GetFactoryBadMarkOfPBlock( NAND_IO_DEVINFO *nDevInfo, U32 nBlockPageAddr )
+{
+    unsigned short int	i;	
+	unsigned short int	wPageSize, wReadSize;
+	unsigned short int	wColumnAddr;
+	unsigned short int	wPageAddr;
+	unsigned char		cBSA[512];
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+
+	//=============================================	
+	// Get Factory Bad Mark Page Default 
+	//=============================================	
+	if ( ( nDevInfo->Feature.MediaType & A_MLC )	  || 
+		 ( nDevInfo->Feature.MediaType & A_MLC_8BIT ) || 
+		 ( nDevInfo->Feature.MediaType & A_MLC_12BIT )  )
+		wPageAddr = nDevInfo->Feature.PpB - 1; /*last page*/
+	else
+		wPageAddr = 0;  /*First Page*/ 
+
+	//=============================================	
+	// Setting ReadSize & Column Address 
+	//=============================================	
+	wReadSize = 1; 
+	wPageSize = nDevInfo->Feature.PageSize;
+
+	//=============================================
+	// Exception: Micron  
+	//=============================================
+	if ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID )
+	{
+		if ( ( nDevInfo->Feature.MediaType & A_MLC_8BIT ) || ( nDevInfo->Feature.MediaType & A_MLC_12BIT ) )
+		{	
+			wPageAddr = 0;
+			wReadSize = nDevInfo->Feature.SpareSize;
+		}
+		else 
+		{
+			/*SLC, MLC*/
+			wPageAddr = 0;
+			wReadSize = 1;
+		}
+	}
+
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+	{
+		wPageSize = ( wPageSize >> 1 );
+		wReadSize = ( wReadSize << 1 );
+	}
+	
+	if ( wPageSize == 512 )			/* SMALL BLOCK NANDFLASH */
+		wColumnAddr = 517;
+	else if ( wPageSize == 2048 )	/* BIG BLOCK NANDFLAHS */
+		wColumnAddr = 2048;
+	else if ( wPageSize == 4096 )	/* 4K Page BIG BLOCK NANDFLASH */
+		wColumnAddr = 4096;
+	else
+		return ERR_NAND_IO_FAILED_GET_FACTORY_BAD_MARK_OF_PBLOCK;
+	
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		wColumnAddr = ( wColumnAddr << 1 );
+
+	/* Read BSA */
+	res = NAND_IO_ReadUserSizePage( nDevInfo,
+									nBlockPageAddr + wPageAddr,
+									wColumnAddr,
+									wReadSize,
+									&cBSA[0] );
+	if ( res != SUCCESS )
+		return res;
+
+	/* Check BSA */
+	res = (NAND_IO_ERROR)SUCCESS;
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+	{
+		//============================================
+		//PARALLEL: Check Signature(00h) of BadBlock 
+		//============================================
+		for( i = 0 ; i < wReadSize; i += 2 )
+		{
+			if ( cBSA[i] != 0xFF )
+				res |= NAND_IO_STATUS_FAIL_CS0_PARALLEL;
+			if ( cBSA[i+1] != 0xFF )	
+				res |= NAND_IO_STATUS_FAIL_CS1_PARALLEL;
+
+            if( res != SUCCESS )
+                return res; 			
+		}
+	}
+	else
+	{
+		//============================================
+		//SERIAL: Check Signature(00h) of BadBlock   
+		//============================================
+		for( i = 0 ; i < wReadSize; ++ i )
+		{
+			if ( cBSA[i] != 0xFF )
+				res |= NAND_IO_STATUS_FAIL_CS0_SERIAL;
+
+            if ( res != SUCCESS )
+                return res;
+		}
+	}
+
+	return res;
+
+}
+
+/******************************************************************************
+*
+*	NAND_IO_ERROR	NAND_IO_GetUID
+*
+*	Input	:
+*	Output	:
+*	Return	:
+*
+*	Description :
+*
+*******************************************************************************/
+NAND_IO_ERROR NAND_IO_GetUID( NAND_IO_DEVINFO *nDevInfo, U16 *nCmd, U8 *rReadData )
+{
+	unsigned int		i;
+	unsigned int		RowAddr, ColumnAddr;
+	unsigned char		cTempBuffer[512];
+	NAND_IO_ERROR		res;
+	
+	//=============================================	
+	// Check Device and Parameter
+	//=============================================	
+	if ( !( nDevInfo->IoStatus & NAND_IO_STATUS_ENABLE ))
+		return ERR_NAND_IO_NOT_READY_DEVICE_IO;
+
+	//=============================================
+	// PreProcess
+	// Set Setup and Hold Time
+	// Enable Chip Select
+	// FORCE TO SET WP LOW
+	//=============================================	
+	NAND_IO_PreProcess();
+	NAND_IO_BusControl(nDevInfo);
+	NAND_IO_SetCommCycleTime();
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+	NAND_IO_EnableWriteProtect();
+
+	/* Command #1 */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & *nCmd;
+	/* Command #2 */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & *(nCmd+1);
+
+	/* Generate Row and Column Address */
+	res = NAND_IO_GenerateRowColAddrForRead( 0, 0, &RowAddr, &ColumnAddr, nDevInfo );
+	if ( res != SUCCESS )
+		goto ErrorGetUID;
+
+	/* Write Row and Column Address	*/
+	NAND_IO_WriteRowColAddr( RowAddr, ColumnAddr, nDevInfo );
+
+	/* Command READ2 [ 0x30 ] for Advance NandFlash */
+	if ( nDevInfo->Feature.MediaType & A_BIG )
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+	
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	/* Read Data */
+	res = NAND_IO_ReadUserSizeData( nDevInfo,
+									0,
+									512,
+									cTempBuffer );
+	if ( res != SUCCESS )
+		goto ErrorGetUID;
+
+	/* Copy Read Data */
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+	{
+		for ( i = 0; i < 256; ++ i )
+			rReadData[i] = cTempBuffer[i*2+0];
+	}
+	else
+	{
+		for ( i = 0; i < 256; ++ i )
+			rReadData[i] = cTempBuffer[i];
+	}
+
+ErrorGetUID:
+	//=============================================
+	// FORCE TO SET WP LOW
+	// Disable Chip Select
+	// PostProcess
+	//=============================================
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+
+	//=============================================
+	// Reset Chip
+	//=============================================	
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_Reset( nDevInfo->ChipNo, NAND_IO_PARALLEL_COMBINATION_MODE );
+	else
+		NAND_IO_Reset( nDevInfo->ChipNo, NAND_IO_SERIAL_COMBINATION_MODE );
+
+	if ( res != SUCCESS )
+		return res;
+
+   	return (NAND_IO_ERROR)SUCCESS;
+
+}
+
+//*****************************************************************************
+//*
+//*
+//*					[ MISCELLANEOUS Functions of NAND IO ]
+//*
+//*
+//*****************************************************************************
+static __inline void NAND_IO_SetDataWidth( U32 width )
+{
+	if ( width == NAND_IO_DATA_WITDH_8BIT )
+		BITCLR( pNFC->NFC_CTRL, HwNFC_CTRL_BW_16 );
+	else
+		BITSET( pNFC->NFC_CTRL, HwNFC_CTRL_BW_16 );
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_PortControl( void );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			None
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_PortControl( int nOnOff )  
+{
+	if ( !( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ) )
+	{
+		if ( gNAND_GPIO_ON_OFF == ENABLE )
+		{
+			if ( nOnOff == ENABLE )
+			{
+				#if defined(TCC83XX)
+				NAND_IO_SEL_REG = gNANDIO_GSELReg;
+				#endif
+				#if defined(TCC79X)
+				// PORTCFG5 Configuration  ( TCC7930S B[0]~B[6] is reserved )
+				// B[0] = NDXD[0]
+				// B[1] = NDXD[1]
+				// B[2] = NDXD[2]
+				// B[3] = NDXD[3]
+				// B[4] = NDXD[4]
+				// B[5] = NDXD[5]
+				// B[6] = NDXD[6]
+				HwPORTCFG5 &= (0xF0000000);
+				HwPORTCFG5 |= (0x01111111);
+
+				// PORTCFG6 Configuration
+				// B[7] = NDXD[7]				
+				BITCSET( HwPORTCFG6, HwPORTCFG6_GPIOB7(15), HwPORTCFG6_GPIOB7(1));
+				
+		        #ifndef NAND_8BIT_ONLY
+				// PORTCFG2 Configuration
+				// F[15:12] = NDXD[15:12]
+				BITCSET( HwPORTCFG2, HwPORTCFG2_HPXD11(15), HwPORTCFG2_HPXD11(2));
+				// F[11:8]  = NDXD[11:8]
+				BITCSET( HwPORTCFG2, HwPORTCFG2_HPXD15(15), HwPORTCFG2_HPXD15(2));
+				#endif
+				#endif
+			}
+			else
+			{
+				#if defined(TCC83XX)
+				NAND_IO_SEL_REG = 0;
+				NAND_IO_IOCON_REG |= gNANDIO_GIOCONReg;
+				NAND_IO_GDATA 	  |= gNANDIO_GDATASet;
+				#endif
+				#if defined(TCC79X)
+				// PORTCFG5 Configuration  ( TCC7930S B[0]~B[6] is reserved )
+				// B[0] = NDXD[0]
+				// B[1] = NDXD[1]
+				// B[2] = NDXD[2]
+				// B[3] = NDXD[3]
+				// B[4] = NDXD[4]
+				// B[5] = NDXD[5]
+				// B[6] = NDXD[6]
+				HwPORTCFG5 &= (0xF0000000);
+
+				// PORTCFG6 Configuration
+				// B[7] = NDXD[7]				
+				BITCSET( HwPORTCFG6, HwPORTCFG6_GPIOB7(15), HwPORTCFG6_GPIOB7(0));
+				HwGPBEN		|= 0x000000FF;
+				HwGPBDAT	|= 0x000000FF;
+				
+		        #ifndef NAND_8BIT_ONLY
+				// PORTCFG2 Configuration 
+				// F[11:8]  = NDXD[11:8]
+				BITCSET( HwPORTCFG2, HwPORTCFG2_HPXD11(15), HwPORTCFG2_HPXD11(1));
+				// F[15:12] = NDXD[15:12]
+				BITCSET( HwPORTCFG2, HwPORTCFG2_HPXD15(15), HwPORTCFG2_HPXD15(1));
+				HwGPFEN		|= 0x0000FF00;
+				HwGPFDAT 	|= 0x0000FF00;				
+				#endif
+				#endif
+			}
+		}
+	}
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_PreProcess( void );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			None
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_PreProcess( void )
+{
+	NAND_IO_PortControl( ENABLE );
+	
+	//IO_CKC_EnableBUS( IO_CKC_BUS_NFC );
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_PostProcess( void );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			None
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_PostProcess( void )
+{
+	//IO_CKC_DisableBUS( IO_CKC_BUS_NFC );
+		
+	NAND_IO_PortControl( DISABLE );
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_SetBasicCycleTime( void );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			None
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_SetBasicCycleTime( void )
+{
+	/* SETUP 1 PW 5 HOLD 1 */
+	BITCSET( pNFC->NFC_CTRL, 0xFFF, 0xEEE );
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_SetCommCycleTime(void);
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			None
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_SetCommCycleTime(void)
+{
+	BITCSET( pNFC->NFC_CTRL, 0xFFF, CommCycleTime.RegValue );
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_SetWriteCycleTime(void);
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			None
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_SetWriteCycleTime(void)
+{
+	BITCSET( pNFC->NFC_CTRL, 0xFFF, WriteCycleTime.RegValue );
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_SetReadCycleTime(void);
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			None
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_SetReadCycleTime(void)
+{
+	BITCSET( pNFC->NFC_CTRL, 0xFFF, ReadCycleTime.RegValue );
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_BusControl(NAND_IO_DEVINFO *nDevInfo);
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			NAND_IO_DEVINFO Structure Variable Pointer
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_BusControl( NAND_IO_DEVINFO *nDevInfo )
+{	
+	unsigned int	nMaxBusClk;
+	unsigned int	nMaxBusClkMHZ;
+
+	//==============================================
+	// SET NAND I/O CYCLE
+	//==============================================
+	if ( nDevInfo->IoStatus == NAND_IO_STATUS_ENABLE )
+	{
+		#ifdef FWDN_DOWNLOADER_INCLUDE
+		nMaxBusClk = 1000000;	// 100MHZ
+		#elif defined(TCC89XX) || defined(TCC92XX)
+		{
+			#if defined(_WINCE_)
+				#if defined(USE_V_ADDRESS)
+				nMaxBusClk = tcc_ckc_getfbusctrl(CLKCTRL4);		
+				#else
+				tca_ckc_init();
+				nMaxBusClk = tca_ckc_getfbusctrl(CLKCTRL4);
+				#endif
+			#elif defined(_LINUX_)
+				tca_ckc_init();
+				nMaxBusClk = tca_ckc_getfbusctrl(CLKCTRL4);
+			#else
+				nMaxBusClk = 1660000;		
+			#endif
+		}
+		#endif
+
+		if ( nMaxBusClk  == 0 )
+			nMaxBusClk = 1660000;
+
+		nMaxBusClkMHZ = ( nMaxBusClk / 10000 );
+		
+		if ( ( gMaxBusClkMHZ != 0 ) && ( nMaxBusClkMHZ != gMaxBusClkMHZ ) )
+			NAND_IO_SetCycle( nDevInfo );
+	}
+	//==============================================
+	// SET NFC BUS WIDTH
+	//==============================================
+	if ( nDevInfo->Feature.MediaType & A_08BIT )	
+		BITCLR( pNFC->NFC_CTRL, HwNFC_CTRL_MASK_EN );
+	else
+		BITSET( pNFC->NFC_CTRL, HwNFC_CTRL_MASK_EN );
+
+}
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_EnableChipSelect( U16 nChipNo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nChipNo	= 
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_EnableChipSelect( U16 nChipNo )
+{
+	if ( nChipNo == 0 )
+	{
+		/* NAND_IO_SUPPORT_4CS */
+		#if defined(NAND_2CS_ONLY)
+		BITSCLR( pNFC->NFC_CTRL, HwNFC_CTRL_CFG_nCS1, HwNFC_CTRL_CFG_nCS0 );
+		#else
+		BITSCLR( pNFC->NFC_CTRL, HwNFC_CTRL_CFG_NOACT, HwNFC_CTRL_CFG_nCS0 );
+		#endif
+	}
+	else if ( nChipNo == 1 )
+	{
+		/* NAND_IO_SUPPORT_4CS */
+		#if defined(NAND_2CS_ONLY)
+		BITSCLR( pNFC->NFC_CTRL, HwNFC_CTRL_CFG_nCS0, HwNFC_CTRL_CFG_nCS1 );
+		#else
+		BITSCLR( pNFC->NFC_CTRL, HwNFC_CTRL_CFG_NOACT, HwNFC_CTRL_CFG_nCS1 );
+		#endif
+	}
+	else if ( nChipNo == 2 )
+	{
+		/* NAND_IO_SUPPORT_4CS */
+		BITSCLR( pNFC->NFC_CTRL, HwNFC_CTRL_CFG_NOACT, HwNFC_CTRL_CFG_nCS2 );
+	}
+	else if ( nChipNo == 3 )
+	{
+		/* NAND_IO_SUPPORT_4CS */
+		BITSCLR( pNFC->NFC_CTRL, HwNFC_CTRL_CFG_NOACT, HwNFC_CTRL_CFG_nCS3 );
+	}
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_DisableChipSelect( void );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			None
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_DisableChipSelect( void )
+{
+	/* NAND_IO_SUPPORT_4CS */
+	#if defined(NAND_2CS_ONLY)
+	BITSET( pNFC->NFC_CTRL, ( HwNFC_CTRL_CFG_nCS0 | HwNFC_CTRL_CFG_nCS1 ) ); 
+	#else
+	BITSET( pNFC->NFC_CTRL, HwNFC_CTRL_CFG_NOACT );
+	#endif
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_EnableWriteProtect( void );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			None
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_EnableWriteProtect( void )
+{
+	#if defined(USE_V_ADDRESS)
+		#if defined(_WINCE_)
+		BITCLR( pGPIO->GPBDAT, NAND_IO_NFC_nWPBit );
+        #else
+        BITCLR( NAND_IO_NFC_nWP, NAND_IO_NFC_nWPBit );
+		#endif
+	#else
+	BITCLR( NAND_IO_NFC_nWP, NAND_IO_NFC_nWPBit );
+	#endif
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_DisableWriteProtect( void );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			None
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_DisableWriteProtect( void )
+{
+	#if defined(USE_V_ADDRESS)
+		#if defined(_WINCE_)
+		BITSET( pGPIO->GPBDAT, NAND_IO_NFC_nWPBit );
+        #else
+	    BITSET( NAND_IO_NFC_nWP, NAND_IO_NFC_nWPBit );        
+		#endif
+	#else
+	BITSET( NAND_IO_NFC_nWP, NAND_IO_NFC_nWPBit );
+	#endif
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline U32 NAND_IO_CheckReadyAndBusy( U16 nChipNo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nChipNo	= 
+*  
+*  OUTPUT:	U32 - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline U32 NAND_IO_CheckReadyAndBusy( U16 nChipNo )
+{
+	nChipNo = 0;	// Warning
+
+	#if defined(TCC89_92_BOARD)
+	return ISZERO( pNFC->NFC_CTRL, HwNFC_CTRL_RDY_RDY );
+	#else	// TCC9200S_BOARD
+	return ISZERO( HwGPIOB->GPDAT, Hw31);
+	#endif
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_WaitBusy( U16 nChipNo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nChipNo	= 
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_WaitBusy( U16 nChipNo )
+{
+	// Misc. Configuration Register(MCFG)
+   	// 0 : represent that READY pin is low
+   	// 1 :                             high
+   	// Delay : 200nS
+
+	#ifdef READ_SPEED_CHECK   	
+	NAND_IO_GPIO_Toggle(Hw13);
+	#endif
+	
+   	NAND_IO_Delay();
+
+	#ifdef READ_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw13);
+	#endif
+	
+	while (NAND_IO_CheckReadyAndBusy( nChipNo ));
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_WaitBusyForProgramAndErase( NAND_IO_DEVINFO *nDevInfo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nDevInfo	= 
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_WaitBusyForProgramAndErase( NAND_IO_DEVINFO *nDevInfo )
+{
+	// Misc. Configuration Register(MCFG)
+   	// 0 : represent that READY pin is low
+   	// 1 :                             high
+   	// Delay : 200nS
+   	NAND_IO_Delay();
+
+	while (NAND_IO_CheckReadyAndBusy( nDevInfo->ChipNo ))
+	{
+		#ifndef FWDN_DOWNLOADER_INCLUDE
+		TCC7XX_USBDRV_WriteToQueue();
+		#endif
+	}
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_WaitBusyForCacheProgram( NAND_IO_DEVINFO *nDevInfo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nDevInfo	= 
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_WaitBusyForCacheProgram( NAND_IO_DEVINFO *nDevInfo )
+{
+	// Misc. Configuration Register(MCFG)
+   	// 0 : represent that READY pin is low
+   	// 1 :                             high
+   	// Delay : 200nS
+   	NAND_IO_Delay();
+
+	while (NAND_IO_CheckReadyAndBusy( nDevInfo->ChipNo ))
+	{
+		#ifndef FWDN_DOWNLOADER_INCLUDE
+		TCC7XX_USBDRV_WriteToQueue();
+		#endif
+	}
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_WaitBusyForInterleave( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nDevInfo	= 
+*			nPageAddr	= 
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_WaitBusyForInterleave( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr )
+{
+	unsigned int		ChipNum = 0;
+	NAND_IO_ERROR		res;
+
+	NAND_IO_Delay();
+	gInterLeaveWriteStatus = MULTI_PLANE_GOOD_BLOCK;
+
+	if ( gDevInfo->Feature.MediaType & S_IL )
+	{
+		//=============================================	
+		// Inter Leave
+		//=============================================	
+		if ( gInterLeaveCSNum != nDevInfo->ChipNo )
+		{
+			NAND_IO_EnableChipSelect( (U16)gInterLeaveCSNum );
+			NAND_IO_DisableWriteProtect();
+			nDevInfo->WriteStatus.ChipNo = (U8)gDevInfo->ChipNo;
+
+			while ( NAND_IO_ReadStatusForInterleaveClear( gDevInfo ) )
+			{
+				#ifndef FWDN_DOWNLOADER_INCLUDE
+				TCC7XX_USBDRV_WriteToQueue();
+				#endif
+			}
+	  	}
+		else
+		{
+			NAND_IO_EnableChipSelect( (U16)gInterLeaveCSNum );
+			NAND_IO_DisableWriteProtect();
+			nDevInfo->WriteStatus.ChipNo = (U8)nDevInfo->ChipNo;
+
+			   	while ( NAND_IO_ReadStatusForInterleave( gDevInfo, nPageAddr ) )
+			{
+				#ifndef FWDN_DOWNLOADER_INCLUDE
+				TCC7XX_USBDRV_WriteToQueue();
+				#endif
+			}
+		}
+
+		NAND_IO_DisableChipSelect();
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+	}
+	else if ( nDevInfo->ExtInterleaveUsable == TRUE )
+	{
+		//=============================================	
+		// External Inter Leave
+		//=============================================	
+		if ( nDevInfo->ChipNo == 0 )
+			ChipNum = NAND_IO_STATUS_INTERLEAVING_CHIP1;
+		else if ( nDevInfo->ChipNo == 1 )
+			ChipNum = NAND_IO_STATUS_INTERLEAVING_CHIP2;
+		else if ( nDevInfo->ChipNo == 2 )
+			ChipNum = NAND_IO_STATUS_INTERLEAVING_CHIP3;
+		else if ( nDevInfo->ChipNo == 3 )
+			ChipNum = NAND_IO_STATUS_INTERLEAVING_CHIP4;
+
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+		NAND_IO_DisableWriteProtect();
+			
+		if ( gInterLeaveIoStatus & (U16)ChipNum )
+		{
+			NAND_IO_WaitBusyForProgramAndErase( gDevInfo );	
+		    res = NAND_IO_ReadStatus( gDevInfo );
+		    if ( res != SUCCESS )
+			{
+				nDevInfo->WriteStatus.ChipNo = (U8)gDevInfo->ChipNo;
+				nDevInfo->BadBlockInfo.BlockStatus[gDevInfo->ChipNo] = MULTI_PLANE_BAD_BLOCK; 
+				gInterLeaveWriteStatus = MULTI_PLANE_BAD_BLOCK;	
+			}
+			gInterLeaveIoStatus &= ~ChipNum;
+		}
+	}
+
+	if ( gInterLeaveWriteStatus == MULTI_PLANE_BAD_BLOCK )
+	{ 
+		nDevInfo->WriteStatus.BlockStatus 		= MULTI_PLANE_BAD_BLOCK;
+		nDevInfo->WriteStatus.ErrorPHYPageAddr 	= gInterLeavePageAddr;
+		gInterLeaveWriteStatus 					= MULTI_PLANE_GOOD_BLOCK;
+		res = ERR_NAND_IO_FAILED_WRITE;
+	}
+	else
+	{
+		nDevInfo->WriteStatus.BlockStatus 		= MULTI_PLANE_GOOD_BLOCK;		
+		nDevInfo->WriteStatus.ErrorPHYPageAddr 	= 0xFFFFFFFF;
+		res = (NAND_IO_ERROR)SUCCESS;
+	}
+
+	return res;
+	
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      NAND_IO_ERROR NAND_IO_WaitBusyCheckForWriteEnd( NAND_IO_DEVINFO *nDevInfo )
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nDevInfo	= 
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+NAND_IO_ERROR	NAND_IO_WaitBusyCheckForWriteEnd( NAND_IO_DEVINFO *nDevInfo )
+{
+	NAND_IO_Delay();
+	NAND_IO_PreProcess();
+ 
+	if ( nDevInfo->Feature.MediaType & S_IL )
+	{
+		//=============================================	
+		// Inter Leave
+		//=============================================	
+
+	   	if ( gInterLeaveCSNum != nDevInfo->ChipNo )
+		{
+			NAND_IO_EnableChipSelect( (U16)gInterLeaveCSNum );
+			NAND_IO_DisableWriteProtect();
+
+			while ( NAND_IO_ReadStatusForInterleaveClear( nDevInfo ) )
+			{
+				#ifndef FWDN_DOWNLOADER_INCLUDE
+				TCC7XX_USBDRV_WriteToQueue();
+				#endif
+			}
+
+			NAND_IO_DisableChipSelect();
+			NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+		}
+		else
+		{
+			NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+			NAND_IO_DisableWriteProtect();
+
+			while ( NAND_IO_ReadStatusForInterleave( nDevInfo, gInterLeavePageAddr ) )
+			{
+				#ifndef FWDN_DOWNLOADER_INCLUDE
+				TCC7XX_USBDRV_WriteToQueue();
+				#endif
+			}
+		}
+	}
+	else if ( nDevInfo->ExtInterleaveUsable == TRUE )
+	{
+		//=============================================	
+		// External Inter Leave
+		//=============================================	
+
+		if ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_CHIP1 )
+		{
+			NAND_IO_EnableChipSelect( 0 );
+			NAND_IO_DisableWriteProtect();
+			NAND_IO_WaitBusy(0);
+
+			gInterLeaveIoStatus &= ~NAND_IO_STATUS_INTERLEAVING_CHIP1;
+
+			NAND_IO_DisableChipSelect();
+		}
+
+		if ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_CHIP2 )
+		{
+			NAND_IO_EnableChipSelect( 1 );
+			NAND_IO_DisableWriteProtect();
+			NAND_IO_WaitBusy(1);
+
+			gInterLeaveIoStatus &= ~NAND_IO_STATUS_INTERLEAVING_CHIP2;
+
+			NAND_IO_DisableChipSelect();
+		}
+
+		if ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_CHIP3 )
+		{
+			NAND_IO_EnableChipSelect( 2 );
+			NAND_IO_DisableWriteProtect();
+			NAND_IO_WaitBusy(2);
+
+			gInterLeaveIoStatus &= ~NAND_IO_STATUS_INTERLEAVING_CHIP3;
+
+			NAND_IO_DisableChipSelect();
+		}
+		
+		if ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_CHIP4 )
+		{
+			NAND_IO_EnableChipSelect( 3 );
+			NAND_IO_DisableWriteProtect();
+			NAND_IO_WaitBusy(3);
+
+			gInterLeaveIoStatus &= ~NAND_IO_STATUS_INTERLEAVING_CHIP4;
+
+			NAND_IO_DisableChipSelect();
+		}
+	}
+	
+	NAND_IO_DisableChipSelect();
+	NAND_IO_PostProcess();
+
+   	return (NAND_IO_ERROR)SUCCESS;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_SetInterleaveStatus( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nDevInfo	= 
+*			nPageAddr	= 
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_SetInterleaveStatus( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr )
+{
+
+	if ( nDevInfo->Feature.MediaType & S_IL )
+	{
+		//=============================================	
+		// Inter Leave
+		//=============================================	
+
+		if ( nPageAddr < (U32)(( ( nDevInfo->Feature.PBpV >> 1 ) << nDevInfo->ShiftPpB ) ))
+		{
+			gInterLeaveIoStatus |= NAND_IO_STATUS_INTERLEAVING_CHIP1;
+			gInterLeaveDie0BlockAddr = nPageAddr;
+		}
+		else
+		{
+			gInterLeaveIoStatus |= NAND_IO_STATUS_INTERLEAVING_CHIP2;
+			gInterLeaveDie1BlockAddr = nPageAddr;
+		}
+		gInterLeaveCSNum = nDevInfo->ChipNo;
+	}
+	else if ( nDevInfo->ExtInterleaveUsable == TRUE )
+	{
+		//=============================================	
+		// External Inter Leave
+		//=============================================	
+
+		if ( nDevInfo->ChipNo == 0 )
+			gInterLeaveIoStatus |= NAND_IO_STATUS_INTERLEAVING_CHIP1;
+		else if ( nDevInfo->ChipNo == 1 )
+			gInterLeaveIoStatus |= NAND_IO_STATUS_INTERLEAVING_CHIP2;
+		else if ( nDevInfo->ChipNo == 2 )
+			gInterLeaveIoStatus |= NAND_IO_STATUS_INTERLEAVING_CHIP3;
+		else if ( nDevInfo->ChipNo == 3 )
+			gInterLeaveIoStatus |= NAND_IO_STATUS_INTERLEAVING_CHIP4;
+	}
+
+	gDevInfo = (NAND_IO_DEVINFO *)nDevInfo;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_ClearInterleaveStatus( NAND_IO_DEVINFO *nDevInfo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nDevInfo	= 
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_ClearInterleaveStatus( NAND_IO_DEVINFO *nDevInfo )
+{
+	NAND_IO_Delay();
+	gInterLeaveWriteStatus = MULTI_PLANE_GOOD_BLOCK;
+
+	if ( gDevInfo->Feature.MediaType & S_IL )
+	{
+		//=============================================	
+		// Inter Leave
+		//=============================================	
+		NAND_IO_EnableChipSelect( (U16)gInterLeaveCSNum );
+		NAND_IO_DisableWriteProtect();
+				
+		while ( NAND_IO_ReadStatusForInterleaveClear( gDevInfo ) )
+		{
+			#ifndef FWDN_DOWNLOADER_INCLUDE
+		//	TCC7XX_USBDRV_WriteToQueue();
+			#endif
+		}
+		
+		NAND_IO_DisableChipSelect();
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+	}
+	else if ( gDevInfo->ExtInterleaveUsable == TRUE )
+	{
+		//=============================================	
+		// External Inter Leave
+		//=============================================	
+
+		if ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_CHIP1 )
+		{
+			NAND_IO_EnableChipSelect( 0 );
+			NAND_IO_DisableWriteProtect();
+			NAND_IO_WaitBusyForProgramAndErase( gDevInfo );	
+
+			gInterLeaveIoStatus &= ~NAND_IO_STATUS_INTERLEAVING_CHIP1;
+
+			NAND_IO_DisableChipSelect();
+		}
+
+		if ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_CHIP2 )
+		{
+			NAND_IO_EnableChipSelect( 1 );
+			NAND_IO_DisableWriteProtect();
+			NAND_IO_WaitBusyForProgramAndErase( gDevInfo );	
+
+			gInterLeaveIoStatus &= ~NAND_IO_STATUS_INTERLEAVING_CHIP2;
+
+			NAND_IO_DisableChipSelect();
+		}
+
+		if ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_CHIP3 )
+		{
+			NAND_IO_EnableChipSelect( 2 );
+			NAND_IO_DisableWriteProtect();
+			NAND_IO_WaitBusyForProgramAndErase( gDevInfo );	
+
+			gInterLeaveIoStatus &= ~NAND_IO_STATUS_INTERLEAVING_CHIP3;
+
+			NAND_IO_DisableChipSelect();
+		}
+		
+		if ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_CHIP4 )
+		{
+			NAND_IO_EnableChipSelect( 3 );
+			NAND_IO_DisableWriteProtect();
+			NAND_IO_WaitBusyForProgramAndErase( gDevInfo );	
+
+			gInterLeaveIoStatus &= ~NAND_IO_STATUS_INTERLEAVING_CHIP4;
+
+			NAND_IO_DisableChipSelect();
+		}
+
+		NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+	}
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_Delay( void );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			None
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_Delay( void )
+{
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+ 	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_ReadStatus( NAND_IO_DEVINFO *nDevInfo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nDevInfo	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_ReadStatus( NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned int		uStatus;
+	unsigned int		uCheckBit;
+	unsigned long int	timeout;
+	NAND_IO_ERROR		res;	
+	
+	//================================
+	//	Command READ STATUS [ 0x70 ]
+	//================================
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7070;
+
+	// Delay : more than 200nS
+   	NAND_IO_Delay();
+	
+	//=============================================
+	// DATA BUS WIDTH Setting
+	//=============================================
+	if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//================================
+	//	Read IO Status
+	//================================
+ 	timeout = 0xFFFFF;
+ 	while ( timeout )
+ 	{
+		uStatus		= nDevInfo->CmdMask & pNFC->NFC_SDATA;
+		uCheckBit	= nDevInfo->CmdMask & 0x4040;
+			
+		/* Check if it is ready */
+		if ( ( uStatus & uCheckBit ) == uCheckBit )
+			break;
+	}
+
+	if ( !timeout )
+		return ERR_NAND_IO_TIME_OUT_READ_STATUS;
+
+	//================================
+	//	Check Bit Status
+	//================================
+	uStatus		= nDevInfo->CmdMask & pNFC->NFC_SDATA;
+	uCheckBit	= nDevInfo->CmdMask & 0x0101;
+
+	res = (NAND_IO_ERROR)SUCCESS;
+	
+	if ( uStatus & uCheckBit )
+	{
+		if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		{
+			if (uStatus & ( uCheckBit & 0x0100 ) )
+				res |= NAND_IO_STATUS_FAIL_CS1_PARALLEL;
+
+			if (uStatus & ( uCheckBit & 0x0001 ) )
+				res |= NAND_IO_STATUS_FAIL_CS0_PARALLEL;
+		}
+		else
+		{
+			if (uStatus & uCheckBit )
+				res |= NAND_IO_STATUS_FAIL_CS0_SERIAL;
+		}
+	}
+	
+ 	return res;
+
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_ReadStatusForMultiPlane( NAND_IO_DEVINFO *nDevInfo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nDevInfo	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_ReadStatusForMultiPlane( NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned int		uStatus;
+	unsigned int		uCheckBit;
+	unsigned long int	timeout;
+	NAND_IO_ERROR		res;	
+	
+	//================================
+	//	Command READ STATUS [ 0x70 ]
+	//================================
+	if ( nDevInfo->Feature.DeviceID.Code[0] == SAMSUNG_NAND_MAKER_ID )
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7070;
+	else if ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID )
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7171;
+	else if ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID )
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7070;
+	else
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7070;
+
+	// Delay : more than 200nS
+   	NAND_IO_Delay();
+	
+	//=============================================
+	// DATA BUS WIDTH Setting
+	//=============================================
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//================================
+	//	Read IO Status
+	//================================
+ 	timeout = 0xFFFFF;
+ 	while ( timeout )
+ 	{
+		/* Micron MultiPlane ReadBusy Check 0x40*/
+		uStatus		= nDevInfo->CmdMask & pNFC->NFC_SDATA;
+		uCheckBit = nDevInfo->CmdMask & 0x4040;
+
+		/* Check if it is ready */
+		if ( ( uStatus & uCheckBit ) == uCheckBit )
+			break;
+	}
+
+	if ( !timeout )
+		return ERR_NAND_IO_TIME_OUT_READ_STATUS;
+
+	//================================
+	//	Check Bit Status
+	//================================
+	if ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID )
+	{
+		uStatus		= nDevInfo->CmdMask & pNFC->NFC_SDATA;
+		uCheckBit	= nDevInfo->CmdMask & 0x0101;
+
+		res = (NAND_IO_ERROR)SUCCESS;
+
+		if ( uStatus & uCheckBit )
+		{
+			if ( uStatus & ( nDevInfo->CmdMask & 0x0202 ))
+				res = (NAND_IO_ERROR)NAND_IO_DISTRICT_0;
+			else if ( uStatus & ( nDevInfo->CmdMask & 0x0404 ))
+				res = (NAND_IO_ERROR)NAND_IO_DISTRICT_1;
+		}
+	}
+	else
+	{
+	    uStatus		= nDevInfo->CmdMask & pNFC->NFC_SDATA;
+	    uCheckBit	= nDevInfo->CmdMask & 0x0101;
+    
+	    res = (NAND_IO_ERROR)SUCCESS;
+	    
+	    if ( uStatus & uCheckBit )
+	    {
+		    if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		    {
+			    if (uStatus & ( uCheckBit & 0x0100 ) )
+				    res |= NAND_IO_STATUS_FAIL_CS1_PARALLEL;
+    
+			    if (uStatus & ( uCheckBit & 0x0001 ) )
+				    res |= NAND_IO_STATUS_FAIL_CS0_PARALLEL;
+		    }
+		    else
+		    {
+			    if (uStatus & uCheckBit )
+				    res |= NAND_IO_STATUS_FAIL_CS0_SERIAL;
+		    }
+	    }
+	}
+	
+ 	return res;
+
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_ReadStatusForCacheProgram( NAND_IO_DEVINFO *nDevInfo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nDevInfo	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_ReadStatusForCacheProgram( NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned int		uStatus;
+	unsigned int		uCheckBit;
+	unsigned long int	timeout;
+	NAND_IO_ERROR		res;	
+	
+	//================================
+	//	Command READ STATUS [ 0x70 ]
+	//================================
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7070;
+	
+	// Delay : more than 200nS
+   	NAND_IO_Delay();	
+
+	//=============================================
+	// DATA BUS WIDTH Setting
+	//=============================================
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//================================
+	//	Read IO Status
+	//================================
+ 	timeout = 0xFFFFF;
+ 	while ( timeout )
+ 	{
+		uStatus		= nDevInfo->CmdMask & pNFC->NFC_SDATA;
+		
+		if ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID )
+			uCheckBit = nDevInfo->CmdMask & 0x2020;
+		else
+			uCheckBit = nDevInfo->CmdMask & 0x4040;
+		
+		/* Check if it is ready */
+		if ( ( uStatus & uCheckBit ) == uCheckBit )
+			break;
+	}
+
+	if ( !timeout )
+		return ERR_NAND_IO_TIME_OUT_READ_STATUS;
+
+	//================================
+	//	Check Bit Status
+	//================================
+	uStatus		= nDevInfo->CmdMask & pNFC->NFC_SDATA;
+	uCheckBit	= nDevInfo->CmdMask & 0x0303;
+
+	res = (NAND_IO_ERROR)SUCCESS;
+	
+	if ( uStatus & uCheckBit )
+	{
+		if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		{
+			if (uStatus & ( uCheckBit & 0x0300 ) )
+				res |= NAND_IO_STATUS_FAIL_CS1_PARALLEL;
+
+			if (uStatus & ( uCheckBit & 0x0003 ) )
+				res |= NAND_IO_STATUS_FAIL_CS0_PARALLEL;
+		}
+		else
+		{
+			if (uStatus & uCheckBit )
+				res |= NAND_IO_STATUS_FAIL_CS0_SERIAL;
+		}
+	}
+	
+ 	return res;
+
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_ReadStatusForInterleave( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nDevInfo	= 
+*			nPageAddr	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_ReadStatusForInterleave( NAND_IO_DEVINFO *nDevInfo, U32 nPageAddr )
+{
+	unsigned int		uStatus;
+	unsigned int		uCheckBit;
+	unsigned int		ChipNum;
+	unsigned long int	timeout;
+	NAND_IO_ERROR		res;	
+
+	// Delay : more than 200nS
+   	NAND_IO_Delay();
+
+	//=============================================
+	// DATA BUS WIDTH Setting
+	//=============================================
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//================================
+	//	Command READ STATUS
+	//================================
+	if ( nPageAddr < (U32)( ( nDevInfo->Feature.PBpV >> 1 ) * nDevInfo->Feature.PpB ) )
+	{
+		if ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_CHIP1 )
+		{
+			if ( nDevInfo->Feature.DeviceID.Code[0] == SAMSUNG_NAND_MAKER_ID )
+				pNFC->NFC_CMD = nDevInfo->CmdMask & 0xF1F1;
+			else if ( nDevInfo->Feature.DeviceID.Code[0] == ST_NAND_MAKER_ID )
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0xF2F2;					
+			else if ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID )
+				pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7171;
+			else if ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID )
+			{
+				pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7878;	
+				NAND_IO_WriteBlockPageAddr( gInterLeaveDie0BlockAddr, nDevInfo );
+			}
+			
+			ChipNum = NAND_IO_STATUS_INTERLEAVING_CHIP1;
+		}
+		else
+			return (NAND_IO_ERROR)SUCCESS;
+	}
+	else
+	{
+		if ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_CHIP2 )
+		{
+			if ( nDevInfo->Feature.DeviceID.Code[0] == SAMSUNG_NAND_MAKER_ID )
+				pNFC->NFC_CMD = nDevInfo->CmdMask & 0xF2F2;
+			else if ( nDevInfo->Feature.DeviceID.Code[0] == ST_NAND_MAKER_ID )
+				pNFC->NFC_CMD = nDevInfo->CmdMask & 0xF3F3;			
+			else if ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID )
+				pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7171;	
+			else if ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID )
+			{
+				pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7878;
+				NAND_IO_WriteBlockPageAddr( gInterLeaveDie1BlockAddr, nDevInfo );
+			}
+			ChipNum = NAND_IO_STATUS_INTERLEAVING_CHIP2;
+		}
+		else
+			return (NAND_IO_ERROR)SUCCESS;
+	}
+
+	//================================
+	//	Read IO Status
+	//================================
+ 	timeout = 0xFFFFF;
+ 	while ( timeout )
+ 	{
+		if ( ( nDevInfo->Feature.DeviceID.Code[0] == SAMSUNG_NAND_MAKER_ID ) || 
+			 ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID )	 ||
+			 ( nDevInfo->Feature.DeviceID.Code[0] == ST_NAND_MAKER_ID ) )
+		{
+			uStatus		= nDevInfo->CmdMask & pNFC->NFC_SDATA;
+			uCheckBit = nDevInfo->CmdMask & 0x4040;
+		
+			/* Check if it is ready */
+			if ( ( uStatus & uCheckBit ) == uCheckBit )
+			{
+				uCheckBit	= nDevInfo->CmdMask & 0x0101;
+
+				/* Check if it is Fail */
+				if ( uStatus & uCheckBit )
+				{
+					if ( ChipNum == NAND_IO_STATUS_INTERLEAVING_CHIP1 )
+					{
+						if ( ( nDevInfo->Feature.MediaType & S_MP ) || ( nDevInfo->Feature.MediaType & S_MCP ) )
+						{
+							nDevInfo->BadBlockInfo.BlockStatus[0] = MULTI_PLANE_BAD_BLOCK;
+							nDevInfo->BadBlockInfo.BlockStatus[1] = MULTI_PLANE_BAD_BLOCK;
+						}
+						else
+							nDevInfo->BadBlockInfo.BlockStatus[nDevInfo->ChipNo] = MULTI_PLANE_BAD_BLOCK;
+					}
+					else if ( ChipNum == NAND_IO_STATUS_INTERLEAVING_CHIP2 )
+					{
+						if ( ( nDevInfo->Feature.MediaType & S_MP ) || ( nDevInfo->Feature.MediaType & S_MCP ) )
+						{
+							nDevInfo->BadBlockInfo.BlockStatus[2] = MULTI_PLANE_BAD_BLOCK;
+							nDevInfo->BadBlockInfo.BlockStatus[3] = MULTI_PLANE_BAD_BLOCK;
+						}
+						else
+							nDevInfo->BadBlockInfo.BlockStatus[nDevInfo->ChipNo] = MULTI_PLANE_BAD_BLOCK;
+					}
+
+					gInterLeaveWriteStatus = MULTI_PLANE_BAD_BLOCK;
+				}
+				break;
+			}
+		}
+		else if ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID )
+		{
+			uStatus	= nDevInfo->CmdMask & pNFC->NFC_SDATA;
+			uCheckBit = nDevInfo->CmdMask & 0x4040;
+
+			/* Check if it is ready */
+			if ( ( uStatus & uCheckBit ) == uCheckBit )
+			{
+				uCheckBit	= nDevInfo->CmdMask & 0x0101;
+
+				/* Check if it is Fail */
+				if ( uStatus & uCheckBit )
+				{
+					if ( ChipNum == NAND_IO_STATUS_INTERLEAVING_CHIP1 )
+					{
+				       	if ( uStatus & ( nDevInfo->CmdMask & 0x0202 ))
+					        nDevInfo->BadBlockInfo.BlockStatus[0] = MULTI_PLANE_BAD_BLOCK;
+				        else if ( uStatus & ( nDevInfo->CmdMask & 0x0404 ))
+					        nDevInfo->BadBlockInfo.BlockStatus[1] = MULTI_PLANE_BAD_BLOCK;
+					}
+					else if ( ChipNum == NAND_IO_STATUS_INTERLEAVING_CHIP2 )
+					{
+				        if ( uStatus & ( nDevInfo->CmdMask & 0x0202 ))
+					        nDevInfo->BadBlockInfo.BlockStatus[2] = MULTI_PLANE_BAD_BLOCK;
+				        else if ( uStatus & ( nDevInfo->CmdMask & 0x0404 ))
+					        nDevInfo->BadBlockInfo.BlockStatus[3] = MULTI_PLANE_BAD_BLOCK;
+			        }
+
+					gInterLeaveWriteStatus = MULTI_PLANE_BAD_BLOCK;
+				}
+				break;
+			}
+		}
+	}
+
+	if ( !timeout )
+		return ERR_NAND_IO_TIME_OUT_READ_STATUS;
+
+	//================================
+	//	SET NAND IO Status
+	//================================
+	switch(ChipNum)
+	{
+		case NAND_IO_STATUS_INTERLEAVING_CHIP1:
+			gInterLeaveIoStatus &= ~NAND_IO_STATUS_INTERLEAVING_CHIP1;
+			break;
+
+		case NAND_IO_STATUS_INTERLEAVING_CHIP2:
+			gInterLeaveIoStatus &= ~NAND_IO_STATUS_INTERLEAVING_CHIP2;
+			break;
+	}
+
+	res = (NAND_IO_ERROR)SUCCESS;
+
+ 	return res;
+
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_ReadStatusForInterleaveClear( NAND_IO_DEVINFO *nDevInfo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nDevInfo	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_ReadStatusForInterleaveClear( NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned int		uStatus;
+	unsigned int		uCheckBit;
+	unsigned long int	timeout;
+	NAND_IO_ERROR		res;
+
+	// Delay : more than 200nS
+   	NAND_IO_Delay();
+
+	res = (NAND_IO_ERROR)SUCCESS;
+
+	//=============================================
+	// DATA BUS WIDTH Setting
+	//=============================================
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//=============================================
+	//	Command READ STATUS - Interleave CHIP 1
+	//=============================================
+	if ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_CHIP1 )
+	{
+		if ( nDevInfo->Feature.DeviceID.Code[0] == SAMSUNG_NAND_MAKER_ID )
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0xF1F1;
+		else if ( nDevInfo->Feature.DeviceID.Code[0] == ST_NAND_MAKER_ID )
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0xF2F2;		
+		else if ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID )
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7171;
+		else if ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID )
+		{
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7878;
+			NAND_IO_WriteBlockPageAddr( gInterLeaveDie0BlockAddr, nDevInfo );
+		}
+		
+	 	timeout = 0xFFFFF;
+	 	while ( timeout )
+	 	{
+			uStatus	  = nDevInfo->CmdMask & pNFC->NFC_SDATA;
+			uCheckBit = nDevInfo->CmdMask & 0x4040;
+			
+			/* Check if it is ready */
+			if ( ( uStatus & uCheckBit ) == uCheckBit )
+			{
+				uCheckBit	= nDevInfo->CmdMask & 0x0101;
+
+				/* Check if it is Fail */
+				if ( uStatus & uCheckBit )
+				{
+					if ( ( nDevInfo->Feature.MediaType & S_MP ) || ( nDevInfo->Feature.MediaType & S_MCP ) )
+					{
+						nDevInfo->BadBlockInfo.BlockStatus[0] = MULTI_PLANE_BAD_BLOCK;
+						nDevInfo->BadBlockInfo.BlockStatus[1] = MULTI_PLANE_BAD_BLOCK;
+					}
+					else
+						nDevInfo->BadBlockInfo.BlockStatus[nDevInfo->ChipNo] = MULTI_PLANE_BAD_BLOCK;
+
+					gInterLeaveWriteStatus = MULTI_PLANE_BAD_BLOCK;
+				}
+				break;
+			}
+		}
+
+		if ( !timeout )
+			return ERR_NAND_IO_TIME_OUT_READ_STATUS;
+
+		gInterLeaveIoStatus &= ~NAND_IO_STATUS_INTERLEAVING_CHIP1;
+	}
+
+	//=============================================
+	//	Command READ STATUS - Interleave CHIP 2
+	//=============================================
+	if ( gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_CHIP2 )
+	{
+		if ( nDevInfo->Feature.DeviceID.Code[0] == SAMSUNG_NAND_MAKER_ID )
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0xF2F2;
+		else if ( nDevInfo->Feature.DeviceID.Code[0] == ST_NAND_MAKER_ID )
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0xF3F3;		
+		else if ( nDevInfo->Feature.DeviceID.Code[0] == TOSHIBA_NAND_MAKER_ID )
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7171;
+		else if ( nDevInfo->Feature.DeviceID.Code[0] == MICRON_NAND_MAKER_ID )
+		{
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7878;
+			NAND_IO_WriteBlockPageAddr( gInterLeaveDie1BlockAddr, nDevInfo );
+		}
+
+	 	timeout = 0xFFFFF;
+	 	while ( timeout )
+	 	{
+			uStatus		= nDevInfo->CmdMask & pNFC->NFC_SDATA;
+			uCheckBit = nDevInfo->CmdMask & 0x4040;
+			
+			/* Check if it is ready */
+			if ( ( uStatus & uCheckBit ) == uCheckBit )
+			{
+				uCheckBit	= nDevInfo->CmdMask & 0x0101;
+
+				/* Check if it is Fail */
+				if ( uStatus & uCheckBit )
+				{
+					if ( ( nDevInfo->Feature.MediaType & S_MP ) || ( nDevInfo->Feature.MediaType & S_MCP ) )
+					{
+						nDevInfo->BadBlockInfo.BlockStatus[2] = MULTI_PLANE_BAD_BLOCK;
+						nDevInfo->BadBlockInfo.BlockStatus[3] = MULTI_PLANE_BAD_BLOCK;
+					}
+					else
+						nDevInfo->BadBlockInfo.BlockStatus[nDevInfo->ChipNo] = MULTI_PLANE_BAD_BLOCK;
+
+					gInterLeaveWriteStatus = MULTI_PLANE_BAD_BLOCK;
+				}
+				break;
+			}
+		}
+
+		if ( !timeout )
+			return ERR_NAND_IO_TIME_OUT_READ_STATUS;
+
+		gInterLeaveIoStatus &= ~NAND_IO_STATUS_INTERLEAVING_CHIP2;
+	}
+
+	if ( !(gInterLeaveIoStatus & NAND_IO_STATUS_INTERLEAVING_MASK ))
+		res = (NAND_IO_ERROR)SUCCESS;
+	
+ 	return res;
+
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_GenerateRowColAddrForRead( U32 nPageAddr, U16 nColumnAddr,
+*      										  				  		 U32* rRowAddr, U32* rColumnAddr,
+*      														  		 NAND_IO_DEVINFO *nDevInfo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nColumnAddr	= 
+*			nDevInfo	= 
+*			nPageAddr	= 
+*			rColumnAddr	= 
+*			rRowAddr	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_GenerateRowColAddrForRead( U32 nPageAddr, U16 nColumnAddr,
+										  				  		 U32* rRowAddr, U32* rColumnAddr,
+														  		 NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned long int	RowAddr;
+	unsigned long int	ColumnAddr;
+	
+	if ( nColumnAddr > ( nDevInfo->Feature.PageSize + nDevInfo->Feature.SpareSize ) )
+		return ERR_NAND_IO_WRONG_PARAMETER_ROW_COL_ADDRESS;
+
+	//==================================================
+	// Generate Column & Row Address	
+	//==================================================
+	if ( nDevInfo->Feature.MediaType & A_SMALL )
+	{
+		// ColumnAddr	ADR[7:0]	==> nColumnAddr
+		// RowAddr		ADR[25:9]	==> (nPageAddr)*512
+		ColumnAddr	= ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )  ? (nColumnAddr>>1) : nColumnAddr;
+		RowAddr		= nPageAddr;
+
+		if ( nDevInfo->Feature.MediaType & A_08BIT )
+		{
+		    /* Command READ for SMALL NAND */
+		    if ( ColumnAddr < 256 )
+		    {
+			    pNFC->NFC_CMD	= nDevInfo->CmdMask & 0x0000;
+			    ColumnAddr	= ColumnAddr;
+		    }
+		    else if ( ColumnAddr < 512 )
+		    {
+			    pNFC->NFC_CMD	= nDevInfo->CmdMask & 0x0101;
+			    ColumnAddr  = ColumnAddr-256;
+		    }
+		    else
+		    {
+			    pNFC->NFC_CMD	= nDevInfo->CmdMask & 0x5050;
+			    ColumnAddr	= ColumnAddr-512;
+		    }
+		}
+		else if ( nDevInfo->Feature.MediaType & A_16BIT )
+		{
+			/* Command READ for SMALL NAND For 16Bit */
+			if ( ColumnAddr < 256 )
+			{
+				pNFC->NFC_CMD	= nDevInfo->CmdMask & 0x0000;
+				ColumnAddr	= ColumnAddr;
+			}
+			else
+			{
+				pNFC->NFC_CMD	= nDevInfo->CmdMask & 0x5050;
+				ColumnAddr	= ColumnAddr;
+			}
+		}		
+	}
+	else
+	{
+		/* Command READ [ 0x00 ] */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;	
+
+		// ColumnAddr   ADR[11:0]   ==> nColumnAddr
+		// RowAddr      ADR[31:12]  ==> nPageAddr
+		ColumnAddr	= ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT ) ? (nColumnAddr>>1) : nColumnAddr;
+		RowAddr		= nPageAddr;
+
+	}			
+
+	*rRowAddr		= RowAddr;
+	*rColumnAddr	= ColumnAddr;
+
+	return (NAND_IO_ERROR)SUCCESS;
+	
+}	
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_GenerateRowColAddrForWrite( U32 nPageAddr, U16 nColumnAddr,
+*      										  				  		  U32* rRowAddr, U32* rColumnAddr,
+*      														  		  NAND_IO_DEVINFO *nDevInfo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nColumnAddr	= 
+*			nDevInfo	= 
+*			nPageAddr	= 
+*			rColumnAddr	= 
+*			rRowAddr	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_GenerateRowColAddrForWrite( U32 nPageAddr, U16 nColumnAddr,
+										  				  		  U32* rRowAddr, U32* rColumnAddr,
+														  		  NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned long int	RowAddr;
+	unsigned long int	ColumnAddr;
+	
+	if ( nColumnAddr > ( nDevInfo->Feature.PageSize + nDevInfo->Feature.SpareSize ) )
+		return ERR_NAND_IO_WRONG_PARAMETER_ROW_COL_ADDRESS;
+
+	//==================================================
+	// Generate Column & Row Address	
+	//==================================================
+	if ( nDevInfo->Feature.MediaType & A_SMALL )
+	{
+		// ColumnAddr	ADR[7:0]	==> nColumnAddr
+		// RowAddr		ADR[25:9]	==> (nPageAddr)*512
+		ColumnAddr	= ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )  ? (nColumnAddr>>1) : nColumnAddr;
+		RowAddr		= nPageAddr;
+
+		if ( nDevInfo->Feature.MediaType & A_08BIT )
+		{
+		    /* Command READ for SMALL NAND */
+		    if ( ColumnAddr < 256 )
+		    {
+			    pNFC->NFC_CMD	= nDevInfo->CmdMask & 0x0000;
+			    ColumnAddr	= ColumnAddr;
+		    }
+		    else if ( ColumnAddr < 512 )
+		    {
+			    pNFC->NFC_CMD	= nDevInfo->CmdMask & 0x0101;
+			    ColumnAddr  = ColumnAddr-256;
+		    }
+		    else
+		    {
+			    pNFC->NFC_CMD	= nDevInfo->CmdMask & 0x5050;
+			    ColumnAddr	= ColumnAddr-512;
+		    }
+		}
+		else if ( nDevInfo->Feature.MediaType & A_16BIT )
+		{
+			/* Command READ for SMALL NAND */
+			if ( ColumnAddr < 256 )
+			{
+				pNFC->NFC_CMD	= nDevInfo->CmdMask & 0x0000;
+				ColumnAddr	= ColumnAddr;
+			}
+			else
+			{
+				pNFC->NFC_CMD	= nDevInfo->CmdMask & 0x5050;
+				ColumnAddr	= ColumnAddr;
+			}
+		}	
+	}
+	else
+	{
+		// ColumnAddr   ADR[11:0]   ==> nColumnAddr
+		// RowAddr      ADR[31:12]  ==> nPageAddr
+		ColumnAddr	= ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT ) ? (nColumnAddr>>1) : nColumnAddr;
+		RowAddr		= nPageAddr;
+	}			
+
+	*rRowAddr		= RowAddr;
+	*rColumnAddr	= ColumnAddr;
+
+	return (NAND_IO_ERROR)SUCCESS;
+	
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_GenerateRowColAddrForCBandCP( U32 nPageAddr, U16 nColumnAddr,
+*      										  				  			U32* rRowAddr, U32* rColumnAddr,
+*      														  			NAND_IO_DEVINFO *nDevInfo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nColumnAddr	= 
+*			nDevInfo	= 
+*			nPageAddr	= 
+*			rColumnAddr	= 
+*			rRowAddr	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_GenerateRowColAddrForCBandCP( U32 nPageAddr, U16 nColumnAddr,
+										  				  			U32* rRowAddr, U32* rColumnAddr,
+														  			NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned long int	RowAddr;
+	unsigned long int	ColumnAddr;
+	
+	if ( nColumnAddr > 0 )
+		return ERR_NAND_IO_WRONG_PARAMETER_ROW_COL_ADDRESS;
+
+	//==================================================
+	// Generate Column & Row Address	
+	//==================================================
+	if ( nDevInfo->Feature.MediaType & A_SMALL )
+	{
+		// ColumnAddr	ADR[7:0]	==> nColumnAddr
+		// RowAddr		ADR[25:9]	==> (nPageAddr)*512
+		ColumnAddr	= ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )  ? (nColumnAddr>>1) : nColumnAddr;
+		RowAddr		= nPageAddr;
+		ColumnAddr	= ColumnAddr;
+	}
+	else
+	{
+		// ColumnAddr   ADR[11:0]   ==> nColumnAddr
+		// RowAddr      ADR[31:12]  ==> nPageAddr
+		ColumnAddr	= ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT ) ? (nColumnAddr>>1) : nColumnAddr;
+		RowAddr		= nPageAddr;
+	}			
+
+	*rRowAddr		= RowAddr;
+	*rColumnAddr	= ColumnAddr;
+
+	return (NAND_IO_ERROR)SUCCESS;
+	
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_WriteRowColAddr( U32 nRowAddr, U32 nColumnAddr, NAND_IO_DEVINFO *nDevInfo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nColumnAddr	= 
+*			nDevInfo	= 
+*			nRowAddr	= 
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_WriteRowColAddr( U32 nRowAddr, U32 nColumnAddr, NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned int		nTempAddr;
+	unsigned int		i;
+	
+	//==================================================
+	// Write Column Address
+	//==================================================
+	for ( i = 0; i < nDevInfo->Feature.ColCycle; ++i )
+	{
+		nTempAddr = nDevInfo->CmdMask & (((nColumnAddr<<8)&0xFF00)|(nColumnAddr&0x00FF));
+		pNFC->NFC_SADDR = nTempAddr;
+		
+		nColumnAddr = nColumnAddr >> 8;
+	}
+
+	//==================================================
+	// Write Row Address
+	//==================================================	
+	nRowAddr = nRowAddr;
+
+	for ( i = 0; i < nDevInfo->Feature.RowCycle; ++i )
+	{
+		nTempAddr = nDevInfo->CmdMask & (((nRowAddr<<8)&0xFF00)|(nRowAddr&0x00FF));
+		pNFC->NFC_SADDR = nTempAddr;
+
+		nRowAddr = nRowAddr >> 8;
+	}
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_WriteColAddr( U32 nColumnAddr, NAND_IO_DEVINFO *nDevInfo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nColumnAddr	= 
+*			nDevInfo	= 
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_WriteColAddr( U32 nColumnAddr, NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned int		i;
+	
+	//==================================================
+	// Write Column Address
+	//==================================================
+	for ( i = 0; i < nDevInfo->Feature.ColCycle; ++i )
+	{
+		pNFC->NFC_SADDR	= nDevInfo->CmdMask & (((nColumnAddr<<8)&0xFF00)|(nColumnAddr&0x00FF));
+		nColumnAddr = nColumnAddr >> 8;
+	}
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_WriteBlockPageAddr( U32 nBlockPageAddr, NAND_IO_DEVINFO *nDevInfo );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nBlockPageAddr	= 
+*			nDevInfo	= 
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_WriteBlockPageAddr( U32 nBlockPageAddr, NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned int		i;
+	
+	//==================================================
+	// Write Block Address
+	//==================================================
+	for ( i = 0; i < nDevInfo->Feature.RowCycle; ++i )
+	{
+		pNFC->NFC_SADDR	= nDevInfo->CmdMask & (((nBlockPageAddr<<8)&0xFF00)|(nBlockPageAddr&0x00FF));
+		nBlockPageAddr = nBlockPageAddr >> 8;
+	}
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      static __inline void NAND_IO_SetupDMA( void *pSRC, unsigned uSrcInc, unsigned uSrcMask, 
+*      									   void *pDST, unsigned uDstInc, unsigned uDstMask, int nMode );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			nMode	= 
+*			pDST	= 
+*			pSRC	= 
+*			uDstInc	= 
+*			uDstMask	= 
+*			uSrcInc	= 
+*			uSrcMask	= 
+*  
+*  OUTPUT:	void - Return Type
+*  
+**************************************************************************/
+static __inline void NAND_IO_SetupDMA( void *pSRC, unsigned uSrcInc, unsigned uSrcMask, 
+									   void *pDST, unsigned uDstInc, unsigned uDstMask, int nMode, int nDSize )
+{
+	unsigned int	*pDMA_PhyBuffer;
+	unsigned int	*pDMA_WorkBuffer;
+	unsigned int	nSourceAddr, nDestAddr;
+	unsigned		uCHCTRL;
+	unsigned int	uTmp;
+
+	#if defined(_WINCE_)
+	tSYSTEM_PARAM	*pSYS_Work_PARAM	= (tSYSTEM_PARAM*)(SYSTEM_PARAM_BASEADDRESS);
+	#endif
+
+	#ifdef READ_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw15);
+	#endif
+
+	#if defined(_WINCE_)
+	pDMA_PhyBuffer 	= (unsigned int*)pSYS_Work_PARAM->DMA2.CH0_BUFFER;	// Working Address
+	pDMA_WorkBuffer = (unsigned int*)pSYS_PARAM->DMA2.CH0_BUFFER;		// Physical Address
+	#elif defined(_LINUX_)
+	#ifdef KERNEL_DRIVER
+	pDMA_PhyBuffer 	= dma_t.dma_addr;	
+	pDMA_WorkBuffer	= (unsigned int*)dma_t.v_addr;
+	#else
+	pDMA_PhyBuffer 	= (unsigned int*)DMA_ADDR;	
+	pDMA_WorkBuffer	= (unsigned int*)DMA_ADDR;
+	#endif
+	#else		// NU
+	pDMA_PhyBuffer = 0x10003000;
+	pDMA_WorkBuffer	= 0x10003000;			
+	#endif
+	
+	// Read Test
+	//pDMA_PhyBuffer = 0x10003000;
+	//pDMA_WorkBuffer	= 0x10003000;
+	
+	//pDMA_PhyBuffer = pDST;
+	//pDMA_WorkBuffer	= pDST;
+
+	if ( nMode == NAND_IO_DMA_WRITE )
+	{
+		// pSRC: Buffer Address
+		// pDST: NFC_LDATA
+
+		BITCSET(pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_8 | HwNFC_CTRL_DEN_EN | HwNFC_CTRL_PSIZE_512 );
+
+		//pSRC --> pDMA_WorkBuffer
+		memcpy( pDMA_WorkBuffer, pSRC, nDSize );
+
+		// Target Physical Address- for DMA H/W Control Set
+		nSourceAddr	= (unsigned int)pDMA_PhyBuffer;
+		nDestAddr 	= (unsigned int)pDST;
+
+		//============================================================
+		// DMA Control Register Set
+		//============================================================
+		uCHCTRL =	
+	//				HwCHCTRL_SYNC_ON		|
+	//				HwCHCTRL_HRD_W			|
+					HwCHCTRL_BST_BURST		|
+					HwCHCTRL_TYPE_SINGL		|
+				   	HwCHCTRL_HRD_WR			|
+	//				HwCHCTRL_BST_BURST		|
+					HwCHCTRL_BSIZE_8		|
+					HwCHCTRL_WSIZE_32		|
+					HwCHCTRL_FLAG			|
+					HwCHCTRL_EN_ON			|
+					0;
+
+	}
+	else	// NAND_IO_DMA_READ
+	{	
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw5);
+		#endif /* READ_SPEED_CHECK */
+	
+		// pSRC: NFC_LDATA
+		// pDST: Buffer Address
+
+		BITCSET(pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_8 | HwNFC_CTRL_DEN_EN | HwNFC_CTRL_PSIZE_512 );
+
+		nSourceAddr = (unsigned int)pSRC;				// NFC_LDATA Physical Address: ex_TCC89,92XX: 0XF050b0020
+		nDestAddr 	= (unsigned int)pDMA_PhyBuffer;
+
+		//============================================================
+		// DMA Control Register Set
+		//============================================================
+		uCHCTRL =	
+	//				HwCHCTRL_SYNC_ON		|
+	//				HwCHCTRL_HRD_W			|
+					HwCHCTRL_BST_BURST		|
+					HwCHCTRL_TYPE_SINGL		|
+				   	HwCHCTRL_HRD_RD			|
+	//				HwCHCTRL_BST_BURST		|
+					HwCHCTRL_BSIZE_8		|
+					HwCHCTRL_WSIZE_32		|
+					HwCHCTRL_FLAG			|
+					HwCHCTRL_EN_ON			|
+					0;
+	}
+
+	//============================================================
+	// Set Source Address & Source Parameter (mask + increment)
+	//============================================================
+	pNAND_DMA->ST_SADR 	= nSourceAddr;
+	#if defined(_WINCE_) || defined(_LINUX_)
+	pNAND_DMA->SPARAM[0] = (uSrcInc | (uSrcMask << 4));
+	#else
+	pNAND_DMA->SPARAM	 = (uSrcInc | (uSrcMask << 4));
+	#endif
+	//============================================================
+	// Set Dest Address & Dest Parameter (mask + increment)
+	//============================================================
+	pNAND_DMA->ST_DADR 	= nDestAddr;  
+	#if defined(_WINCE_) || defined(_LINUX_)
+	pNAND_DMA->DPARAM[0] = (uDstInc | (uDstMask << 4));
+	#else
+	pNAND_DMA->DPARAM	 = (uDstInc | (uDstMask << 4));
+	#endif
+	//============================================================
+	// Calculate byte size per 1 Hop transfer
+	//============================================================
+	uTmp	= (uCHCTRL & (Hw5+Hw4)) >> 4;			// calc log2(word size)
+	uTmp	= uTmp + ( (uCHCTRL & (Hw7+Hw6)) >> 6);	// calc log2(word * burst size)
+
+	//============================================================
+	// Set External DMA Request Register
+	//============================================================
+	pNAND_DMA->EXTREQ = Hw18;		// NFC
+
+	//============================================================
+	// Set Hcount
+	//============================================================
+	if (uTmp)
+		pNAND_DMA->HCOUNT	= (nDSize + (1 << uTmp) - 1) >> uTmp;
+	else
+		pNAND_DMA->HCOUNT	= nDSize;
+
+	//============================================================
+	// Set & Enable DMA
+	//============================================================
+	pNAND_DMA->CHCTRL		= uCHCTRL;
+
+	//============================================================
+	// Set NFC DSize & IREQ Clear
+	//============================================================
+	pNFC->NFC_DSIZE		= nDSize;
+	pNFC->NFC_IREQ		= 0x77;	// HwNFC_IREQ_FLAG1;
+
+	//============================================================
+	// DMA Transfer Start
+	//============================================================
+	if ( nMode == NAND_IO_DMA_WRITE )
+	{
+		if ( pNFC->NFC_CTRL1 & Hw31 )
+			BITCLR( pNFC->NFC_CTRL1, Hw31 );
+
+		pNFC->NFC_PSTART	= 0;
+		
+		while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+
+		if ( pNFC->NFC_CTRL1 & Hw30 )
+			BITSET( pNFC->NFC_CTRL1, Hw31 );
+	}
+	else
+	{
+		pNFC->NFC_RSTART	= 0;
+		
+		while ( ISZERO(pNFC->NFC_IREQ, HwNFC_IREQ_FLAG0) );
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw5);
+		#endif /* READ_SPEED_CHECK */
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw4);
+		#endif
+
+		memcpy( pDST, pDMA_WorkBuffer, nDSize );
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw4);
+		#endif
+	}
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      static __inline void NAND_IO_SetupDMADoubleBuf(  int nMode, int nDMACh );
+*  
+*  DESCRIPTION : 
+*  
+*  INPUT:
+*			nDMACh	= 
+*			nMode	= 
+*  
+*  OUTPUT:	void - Return Type
+*  
+**************************************************************************/
+static __inline void NAND_IO_SetupDMADoubleBuf(  int nMode, int nDMACh )
+{
+	unsigned int	*pDMA_PhyBuffer;
+	unsigned int	*pDMA_WorkBuffer;
+	unsigned int	nSourceAddr, nDestAddr;
+	unsigned		uCHCTRL;
+	unsigned int	uTmp;
+	unsigned int	uSrcInc, uSrcMask;
+	unsigned int	uDstInc, uDstMask;
+
+	if ( nMode == NAND_IO_DMA_WRITE )
+	{
+		uSrcInc 	= 4;
+		uSrcMask 	= 0;
+		uDstInc		= 0;
+		uDstMask 	= 0;
+	}
+	else
+	{
+		uSrcInc 	= 0;
+		uSrcMask 	= 0;
+		uDstInc		= 4;
+		uDstMask 	= 0;
+	}
+	
+	if ( nDMACh & 1 )
+	{
+		pDMA_PhyBuffer 	= gpDMA_PhyBuffer0;			// Working Address
+		pDMA_WorkBuffer = gpDMA_WorkBuffer0;		// Physical Address
+	}
+	else
+	{
+		pDMA_PhyBuffer 	= gpDMA_PhyBuffer1;			// Working Address
+		pDMA_WorkBuffer = gpDMA_WorkBuffer1;		// Physical Address
+	}
+	
+	if ( nMode == NAND_IO_DMA_WRITE )
+	{
+		// pSRC: Buffer Address
+		// pDST: NFC_LDATA
+
+		BITCSET(pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_8 | HwNFC_CTRL_DEN_EN | HwNFC_CTRL_PSIZE_512 );
+
+		//pSRC --> pDMA_WorkBuffer
+		//memcpy( pDMA_WorkBuffer, pSRC, 512 );
+
+		// Target Physical Address- for DMA H/W Control Set
+		nSourceAddr	= (unsigned int)pDMA_PhyBuffer;
+		#if defined(_WINCE_) || defined(_LINUX_)
+		nDestAddr 	= (unsigned int)&NAND_IO_HwLDATA_PA;
+		#else
+		nDestAddr 	= (unsigned int)&pNFC->NFC_LDATA;
+		#endif
+		
+		//============================================================
+		// DMA Control Register Set
+		//============================================================
+		uCHCTRL =	
+	//				HwCHCTRL_SYNC_ON		|
+	//				HwCHCTRL_HRD_W			|
+					HwCHCTRL_BST_BURST		|
+					HwCHCTRL_TYPE_SINGL		|
+				   	HwCHCTRL_HRD_WR			|
+	//				HwCHCTRL_BST_BURST		|
+					HwCHCTRL_BSIZE_8		|
+					HwCHCTRL_WSIZE_32		|
+					HwCHCTRL_FLAG			|
+					HwCHCTRL_EN_ON			|
+					0;
+
+	}
+	else	// NAND_IO_DMA_READ
+	{	
+
+		BITCSET(pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_8 | HwNFC_CTRL_DEN_EN | HwNFC_CTRL_PSIZE_512 );
+
+		#if defined(_WINCE_) || defined(_LINUX_)
+		nSourceAddr = (unsigned int)&NAND_IO_HwLDATA_PA;				// NFC_LDATA Physical Address: ex_TCC89,92XX: 0XF050b0020
+		#else
+		nSourceAddr = (unsigned int)&pNFC->NFC_LDATA;
+		#endif
+		nDestAddr 	= (unsigned int)pDMA_PhyBuffer;
+
+		//============================================================
+		// DMA Control Register Set
+		//============================================================
+		uCHCTRL =	
+	//				HwCHCTRL_SYNC_ON		|
+	//				HwCHCTRL_HRD_W			|
+					HwCHCTRL_BST_BURST		|
+					HwCHCTRL_TYPE_SINGL		|
+				   	HwCHCTRL_HRD_RD			|
+	//				HwCHCTRL_BST_BURST		|
+					HwCHCTRL_BSIZE_8		|
+					HwCHCTRL_WSIZE_32		|
+					HwCHCTRL_FLAG			|
+					HwCHCTRL_EN_ON			|
+					0;
+	}
+
+	//============================================================
+	// Set Source Address & Source Parameter (mask + increment)
+	//============================================================
+	pNAND_DMA->ST_SADR 	= nSourceAddr;
+	#if defined(_WINCE_) || defined(_LINUX_)
+	pNAND_DMA->SPARAM[0] = (uSrcInc | (uSrcMask << 4));
+	#else
+	pNAND_DMA->SPARAM	 = (uSrcInc | (uSrcMask << 4));
+	#endif
+	//============================================================
+	// Set Dest Address & Dest Parameter (mask + increment)
+	//============================================================
+	pNAND_DMA->ST_DADR 	= nDestAddr;  
+	#if defined(_WINCE_) || defined(_LINUX_)
+	pNAND_DMA->DPARAM[0] = (uDstInc | (uDstMask << 4));
+	#else
+	pNAND_DMA->DPARAM	 = (uDstInc | (uDstMask << 4));
+	#endif
+	//============================================================
+	// Calculate byte size per 1 Hop transfer
+	//============================================================
+	uTmp	= (uCHCTRL & (Hw5+Hw4)) >> 4;			// calc log2(word size)
+	uTmp	= uTmp + ( (uCHCTRL & (Hw7+Hw6)) >> 6);	// calc log2(word * burst size)
+
+	//============================================================
+	// Set External DMA Request Register
+	//============================================================
+	pNAND_DMA->EXTREQ = Hw18;		// NFC
+
+	//============================================================
+	// Set Hcount
+	//============================================================
+	if (uTmp)
+		pNAND_DMA->HCOUNT	= (512 + (1 << uTmp) - 1) >> uTmp;
+	else
+		pNAND_DMA->HCOUNT	= 512;
+
+	//============================================================
+	// Set & Enable DMA
+	//============================================================
+	pNAND_DMA->CHCTRL		= uCHCTRL;
+
+	//============================================================
+	// Set NFC DSize & IREQ Clear
+	//============================================================
+	pNFC->NFC_DSIZE		= 512;
+	pNFC->NFC_IREQ		= 0x77;	// HwNFC_IREQ_FLAG1;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline void NAND_IO_SetupECC( U16 nEccOnOff, U16 nEncDec, U16 nEccType, U32 EccBaseAddr )
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nEccOnOff	= 
+*			nEccType	= 
+*			nEncDec	= 
+*  
+*  OUTPUT:	void - Return Type
+*  REMARK  :	
+**************************************************************************/
+static __inline void NAND_IO_SetupECC( U16 nEccOnOff, U16 nEncDec, U16 nEccType, U16 nAccessType, U32 EccBaseAddr )
+{
+	if ( nEccOnOff == ECC_OFF )
+	{
+		//IO_CKC_EnableBUS( IO_CKC_BUS_ECC );
+
+		BITCLR(pIOBUSCFG_T->HRSTEN0, Hw24);
+		BITSET(pIOBUSCFG_T->HRSTEN0, Hw24);
+
+		pECC->ECC_BASE = 0xF05B0010;	/* Base Address for ECC Calculation */
+		pECC->ECC_MASK	= 0x00000000;				/* Address mask for ECC area */
+		pECC->ECC_CTRL &= HwECC_CTRL_EN_DIS;
+
+		//IO_CKC_DisableBUS( IO_CKC_BUS_ECC );
+	}
+	else if ( nEccOnOff == ECC_ON )
+	{
+		//IO_CKC_EnableBUS( IO_CKC_BUS_ECC );
+
+		if ( nEncDec == ECC_DECODE )
+		{
+			//==========================================================
+			//
+			// ECC Decode Setup
+			//
+			//==========================================================
+			pECC->ECC_CLEAR	= 0x00000000;					/* Clear ECC Block		*/
+			
+			if ( nAccessType == NAND_MCU_ACCESS )
+			{
+				pIOBUSCFG_T->STORAGE = HwIOBUSCFG_STORAGE_NFC;
+				pECC->ECC_BASE	= (0x000FFFFF & EccBaseAddr);
+			}
+			else if ( nAccessType == NAND_DMA_ACCESS )
+			{
+				pIOBUSCFG_T->STORAGE = HwIOBUSCFG_STORAGE_NFC;
+				pECC->ECC_BASE	= EccBaseAddr;
+			}
+			
+			pECC->ECC_MASK	= 0x00000000;				/* Address mask for ECC area */
+
+			if ( nEccType == SLC_ECC_TYPE )
+				pECC->ECC_CTRL	|= 	HwECC_CTRL_EN_SLCDE;
+			else if (nEccType == MLC_ECC_4BIT_TYPE )
+			{
+				pECC->ECC_CTRL	|= HwECC_CTRL_IEN_MECC4_EN;				
+				pECC->ECC_CTRL	|= 	HwECC_CTRL_EN_MCL4DE;
+			}
+			else if (nEccType == MLC_ECC_8BIT_TYPE )
+			{
+				pECC->ECC_CTRL	|= HwECC_CTRL_IEN_MECC8_EN;
+				pECC->ECC_CTRL	|= 	HwECC_CTRL_EN_MCL8DE;
+			}
+			else if (nEccType == MLC_ECC_12BIT_TYPE )
+			{
+				pECC->ECC_CTRL	|= HwECC_CTRL_IEN_MECC12_EN;
+				pECC->ECC_CTRL	|= 	HwECC_CTRL_EN_MCL12DE;
+			}
+			else if (nEccType == MLC_ECC_16BIT_TYPE )
+			{
+				pECC->ECC_CTRL	|= HwECC_CTRL_IEN_MECC16_EN;
+				pECC->ECC_CTRL	|= 	HwECC_CTRL_EN_MCL16DE;
+			}			
+		}
+		else if ( nEncDec == ECC_ENCODE )
+		{
+			//==========================================================
+			//
+			// ECC Encode Setup
+			//
+			//==========================================================
+			if ( nAccessType == NAND_MCU_ACCESS )
+			{
+				pIOBUSCFG_T->STORAGE = HwIOBUSCFG_STORAGE_NFC;
+				pECC->ECC_BASE	= (0x000FFFFF &EccBaseAddr);
+			}
+			else if ( nAccessType == NAND_DMA_ACCESS )
+			{
+				pIOBUSCFG_T->STORAGE = HwIOBUSCFG_STORAGE_NFC;
+				pECC->ECC_BASE	= EccBaseAddr;
+			}
+
+			pECC->ECC_MASK	= 0x00000000;				/* Address mask for ECC area */
+
+			if ( nEccType == SLC_ECC_TYPE )
+				pECC->ECC_CTRL	|= 	HwECC_CTRL_EN_SLCEN;
+			else if (nEccType == MLC_ECC_4BIT_TYPE )
+				pECC->ECC_CTRL	|= 	HwECC_CTRL_EN_MCL4EN;
+			else if (nEccType == MLC_ECC_8BIT_TYPE )
+				pECC->ECC_CTRL	|= 	HwECC_CTRL_EN_MCL8EN;
+			else if (nEccType == MLC_ECC_12BIT_TYPE )
+				pECC->ECC_CTRL	|= 	HwECC_CTRL_EN_MCL12EN;
+			else if (nEccType == MLC_ECC_16BIT_TYPE )
+				pECC->ECC_CTRL	|= 	HwECC_CTRL_EN_MCL16EN;
+			
+			pECC->ECC_CLEAR	= 0x00000000;					/* Clear ECC Block		*/
+
+		}
+	}
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      static __inline NAND_IO_ERROR NAND_IO_EncodeECC( U16 nEccType, U8* nSpareBuffer );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			nEccType	= 
+*			nSpareBuffer	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_EncodeECC( U16 nEccType, U8* nSpareBuffer )
+{
+	unsigned int		nECC_CODE;
+	unsigned char		*pcECC;
+	unsigned int		*pSpareDW;
+
+	if ( nEccType == SLC_ECC_TYPE )
+	{
+		//==================================================================
+		//	[ TNFTL V1.0 ]
+		//==================================================================	
+		// 520th	: P64-P8		of ECC Area-1 [ DATA 256-511 ]
+		// 521th	: P1024-P128	of ECC Area-1 [ DATA 256-511 ]
+		// 522th	: P4-P1			of ECC Area-1 [ DATA 256-511 ]
+		// 525th	: P64-P8		of ECC Area-0 [ DATA 0-255 ]
+		// 526th	: P1024-P128	of ECC Area-0 [ DATA 0-255 ]
+		// 527th	: P4-P1			of ECC Area-0 [ DATA 0-255 ]
+		//==================================================================
+		
+		pcECC = (unsigned char* )&pECC->ECC_CODE0;
+
+		/* Area-1 */
+		nSpareBuffer[10]	= pcECC[0];		// P4-P1
+		nSpareBuffer[ 9]	= pcECC[1];		// P1024-P128
+		nSpareBuffer[ 8]	= pcECC[2];		// P64-P8
+		
+		/* Area-0 */
+		nSpareBuffer[15]	= pcECC[4];		// P4-P1
+		nSpareBuffer[14]	= pcECC[5];		// P1024-128
+		nSpareBuffer[13]	= pcECC[6];		// P64-P8	
+	}
+	else
+	{
+		pSpareDW = (unsigned int *)nSpareBuffer;
+
+		nECC_CODE 	= pECC->ECC_CODE0;
+		*pSpareDW	= nECC_CODE; ++pSpareDW;
+
+		nECC_CODE 	= pECC->ECC_CODE1;
+		*pSpareDW	= nECC_CODE; ++pSpareDW;
+
+		nECC_CODE 	= pECC->ECC_CODE2;
+		*pSpareDW	= nECC_CODE; ++pSpareDW;
+
+		nECC_CODE 	= pECC->ECC_CODE3;
+		*pSpareDW	= nECC_CODE; ++pSpareDW;
+
+		nECC_CODE 	= pECC->ECC_CODE4;
+		*pSpareDW	= nECC_CODE; ++pSpareDW;
+
+		nECC_CODE 	= pECC->ECC_CODE5;
+		*pSpareDW	= nECC_CODE; ++pSpareDW;
+
+		nECC_CODE 	= pECC->ECC_CODE6;
+		*pSpareDW	= nECC_CODE; ++pSpareDW;
+	}
+	
+	return (NAND_IO_ERROR)SUCCESS;	
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_CorrectionSLC( U8* nPageBuffer, U8* nSpareBuffer );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nPageBuffer	= 
+*			nSpareBuffer	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_CorrectionSLC( U8* nPageBuffer, U8* nSpareBuffer )
+{
+	unsigned int		uErrorStatus;
+	unsigned int		uSLCECC0, uSLCECC1;
+	NAND_IO_ERROR		res;
+
+	//IO_CKC_EnableBUS( IO_CKC_BUS_ECC );
+	
+	//==================================================================
+	//	[ TNFTL V1.0 ]
+	//==================================================================	
+	// 520th	: P64-P8		of ECC Area-1 [ DATA 256-511 ]
+	// 521th	: P1024-P128	of ECC Area-1 [ DATA 256-511 ]
+	// 522th	: P4-P1			of ECC Area-1 [ DATA 256-511 ]
+	// 525th	: P64-P8		of ECC Area-0 [ DATA 0-255 ]
+	// 526th	: P1024-P128	of ECC Area-0 [ DATA 0-255 ]
+	// 527th	: P4-P1			of ECC Area-0 [ DATA 0-255 ]
+	//==================================================================
+
+	/* Load SLC ECC Code for Area 1 */
+	uSLCECC0	= ( nSpareBuffer[0] << 16 ) +
+				  ( nSpareBuffer[1] <<  8 ) +
+				  ( nSpareBuffer[2] );
+				  
+	/* Load SLC ECC Code for Area 0 */
+	uSLCECC1	= ( nSpareBuffer[3] << 16 ) +
+				  ( nSpareBuffer[4] <<  8 ) +
+				  ( nSpareBuffer[5] );
+
+	res = (NAND_IO_ERROR)SUCCESS;
+	
+	/* Correction Area 0 */
+	pECC->ECC_CODE1 = uSLCECC1;
+	uErrorStatus = pECC->ERRNUM & 0x7;
+	
+	if ( uErrorStatus == HwERR_NUM_ERR1 )
+	{
+		nPageBuffer[pECC->ECC_EADDR0 >> 3] ^= (1 << (pECC->ECC_EADDR0 & 0x07));
+		res = (NAND_IO_ERROR)SUCCESS;
+	}	
+	else if ( uErrorStatus != HwERR_NUM_NOERR )
+	{
+		res	= ERR_NAND_IO_FAILED_CORRECTION_SLC_ECC;
+		goto ErrorCorrectionSLC;
+	}	
+
+	res = (NAND_IO_ERROR)SUCCESS;
+	
+	/* Correction Area 1 */
+	pECC->ECC_CODE0 = uSLCECC0;
+	uErrorStatus = pECC->ERRNUM & 0x7;
+	
+	if ( uErrorStatus == HwERR_NUM_ERR1 )
+	{
+		nPageBuffer[pECC->ECC_EADDR0 >> 3] ^= (1 << (pECC->ECC_EADDR0 & 0x07));
+		res = (NAND_IO_ERROR)SUCCESS;
+	}
+	else if ( uErrorStatus != HwERR_NUM_NOERR )
+	{
+		res = ERR_NAND_IO_FAILED_CORRECTION_SLC_ECC;
+		goto ErrorCorrectionSLC;		
+	}
+
+ErrorCorrectionSLC:
+
+	//IO_CKC_DisableBUS( IO_CKC_BUS_ECC );
+	
+	return res;
+	
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      static __inline NAND_IO_ERROR NAND_IO_CorrectionMLC( U16 nEccType, U8* nPageBuffer, U8* nSpareBuffer, U16 nDataSize );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			nDataSize	= 
+*			nEccType	= 
+*			nPageBuffer	= 
+*			nSpareBuffer	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_CorrectionMLC( U16 nEccType, U8* nPageBuffer, U8* nSpareBuffer, U16 nDataSize )
+{
+	unsigned int		i;
+	unsigned int		uErrAddr;
+	unsigned int		uErrorStatus;
+	unsigned int		*pSpareDW;
+	NAND_IO_ECC_INFO	*pECC_Info;
+	NAND_IO_ERROR		res;
+
+	if ( nEccType == MLC_ECC_4BIT_TYPE )
+		pECC_Info = &gMLC_ECC_4Bit;
+	else if ( nEccType == MLC_ECC_8BIT_TYPE )
+		pECC_Info = &gMLC_ECC_8Bit;
+	else if ( nEccType == MLC_ECC_12BIT_TYPE )
+		pECC_Info = &gMLC_ECC_12Bit;
+	else if ( nEccType == MLC_ECC_14BIT_TYPE )
+		pECC_Info = &gMLC_ECC_14Bit;
+	else if ( nEccType == MLC_ECC_16BIT_TYPE )
+		pECC_Info = &gMLC_ECC_16Bit;
+	else
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//============================================
+	// Get Buffer Pointer
+	//============================================
+	if ( memcmp( nSpareBuffer, gNAND_IO_TempBuffer, pECC_Info->EccDataSize ) == 0 )
+	{
+		if ( nDataSize == 512 )
+			pSpareDW	= (unsigned int *)pECC_Info->All_FF_512_ECC_Code;
+		else if ( nDataSize == 12 )
+			pSpareDW	= (unsigned int *)&ALL_FF_ECC_BCH_04BIT_12;
+		else
+			pSpareDW	= (unsigned int *)&ALL_FF_ECC_BCH_04BIT_512;
+	}
+	else
+		pSpareDW	= (unsigned int *)nSpareBuffer;
+
+	//IO_CKC_EnableBUS( IO_CKC_BUS_ECC );
+	
+	pECC->ECC_CODE0	= *pSpareDW; ++pSpareDW;
+	pECC->ECC_CODE1	= *pSpareDW; ++pSpareDW;
+	pECC->ECC_CODE2	= *pSpareDW; ++pSpareDW;
+	pECC->ECC_CODE3	= *pSpareDW; ++pSpareDW;
+	pECC->ECC_CODE4	= *pSpareDW; ++pSpareDW;
+	pECC->ECC_CODE5	= *pSpareDW; ++pSpareDW;
+	pECC->ECC_CODE6	= *pSpareDW; ++pSpareDW;
+
+
+	/* Sync Delay */
+	//ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP;
+
+	/* Wait MLC ECC Correction */
+	while ( !(pECC->ECC_IREQ & pECC_Info->DecodeFlag ) );
+
+	res = (NAND_IO_ERROR)SUCCESS;
+
+	/* Correction */
+	uErrorStatus = pECC->ERRNUM & 0x1F;
+
+	if ( uErrorStatus > pECC_Info->ErrorNum )
+	{
+		#ifdef NAND_IO_ECC_ERROR_LOG
+		PRINTF("\n\nErrorNum[%02d],DataSize[%03d] - Correction Fail", uErrorStatus, nDataSize );
+		#if defined(USE_V_ADDRESS) && defined(_WINCE_)
+		RETAILMSG(1,(	TEXT("[NAND        ] [ECC Correction Fail]\n")));
+		#else
+		ND_TRACE("[NAND        ] [ECC Correction Fail]\n" );
+		#endif
+		#endif
+		
+		res = ERR_NAND_IO_FAILED_CORRECTION_MLC_ECC;
+		goto ErrorCorrectionMLC;
+	}
+	else if ( uErrorStatus == HwERR_NUM_NOERR )
+	{
+		res = (NAND_IO_ERROR)SUCCESS;
+	}
+	else
+	{
+		for ( i = 0; i < uErrorStatus; ++i )
+		{
+			uErrAddr = *(unsigned long int*)(&pECC->ECC_EADDR0+i);
+
+			if ( ( uErrAddr >> 3 ) < nDataSize )
+				nPageBuffer[uErrAddr>>3] ^= (1<<(uErrAddr &0x7));
+		}
+	}
+	
+ErrorCorrectionMLC:
+	/* Disable MLC ECC */
+	//IO_CKC_DisableBUS( IO_CKC_BUS_ECC );
+	
+	return res;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      static __inline NAND_IO_ERROR NAND_IO_EncodeBootBinary( NAND_IO_DEVINFO *nDevInfo, U8 *nPageBuffer, int nEccOnOff );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			nDevInfo	= 
+*			nEccOnOff	= 
+*			nPageBuffer	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_EncodeBootBinary( NAND_IO_DEVINFO *nDevInfo, U8 *nPageBuffer, int nEccOnOff )
+{
+	unsigned int		i;
+	#ifdef _LINUX_
+	unsigned char		nECCBuffer[30]__attribute__((aligned(8)));
+	#else
+	unsigned char		nECCBuffer[30];
+	#endif
+	unsigned char		*pPageB;
+	unsigned char		*pDataBuffer;
+	unsigned char		*pEccB;
+	DWORD_BYTE			uDWordByte;
+	NAND_IO_ERROR		res;
+
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	//if ( nEccOnOff == ECC_OFF )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	res = (NAND_IO_ERROR)SUCCESS;
+
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================
+	NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//=========================================================================
+	// Get Buffer Pointer
+	//=========================================================================
+	/* Adapt type of address */
+	pPageB		= (unsigned char*)nPageBuffer;
+
+	/* Get Buffer pointer */
+	pDataBuffer = (unsigned char*)pPageB;
+
+	//####################################################
+	//#	Dummy Write Page Data
+	//####################################################
+#if 0		/* 09.07.15 */
+	if (!( pNFC->NFC_CTRL1 & Hw30 ))
+	{
+		/* Setup ECC Block */
+		if ( nEccOnOff == ECC_ON )
+		{
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, MLC_ECC_16BIT_TYPE, NAND_MCU_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, MLC_ECC_16BIT_TYPE, NAND_MCU_ACCESS, (U32)&pNFC->NFC_LDATA );
+			#endif
+			pECC->ECC_CTRL	|= ( NAND_SB_BOOT_PAGE_SIZE << ECC_SHIFT_DATASIZE );		// Data Size...		
+			pECC->ECC_CLEAR	 = 0x00000000;						// Clear ECC Block			
+		}
+
+		/* Write 256 Page Data */
+		BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
+		pNFC->NFC_DSIZE		= NAND_SB_BOOT_PAGE_SIZE;
+		pNFC->NFC_IREQ 		= 0x77;	// pNFC->NFC_IREQ_FLAG1;		
+		pNFC->NFC_PSTART 	= 0;
+
+		i = ( NAND_SB_BOOT_PAGE_SIZE >> 2 );
+		do {
+				while (!( pNFC->NFC_CTRL & HwNFC_CTRL_FS_RDY ));
+				uDWordByte.BYTE[0] = *pDataBuffer;++pDataBuffer;
+				uDWordByte.BYTE[1] = *pDataBuffer;++pDataBuffer;
+				uDWordByte.BYTE[2] = *pDataBuffer;++pDataBuffer;
+				uDWordByte.BYTE[3] = *pDataBuffer;++pDataBuffer;
+				pNFC->NFC_LDATA	= uDWordByte.DWORD;
+		}while(--i);
+		
+		while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+	}
+	else
+#endif /* 0 */
+	{
+		/* Setup ECC Block */
+		if ( nEccOnOff == ECC_ON )
+		{
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, MLC_ECC_16BIT_TYPE, NAND_MCU_ACCESS, (U32)&NAND_IO_HwDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, MLC_ECC_16BIT_TYPE, NAND_MCU_ACCESS, (U32)&pNFC->NFC_WDATA );
+			#endif
+			pECC->ECC_CTRL	|= ( NAND_SB_BOOT_PAGE_SIZE << ECC_SHIFT_DATASIZE );		// Data Size...	
+			pECC->ECC_CLEAR	= 0x00000000;			
+		}
+
+		i = ( NAND_SB_BOOT_PAGE_SIZE >> 2 );
+		do {
+				uDWordByte.BYTE[0] = *pDataBuffer;++pDataBuffer;
+				uDWordByte.BYTE[1] = *pDataBuffer;++pDataBuffer;
+				uDWordByte.BYTE[2] = *pDataBuffer;++pDataBuffer;
+				uDWordByte.BYTE[3] = *pDataBuffer;++pDataBuffer;
+				pNFC->NFC_WDATA	= uDWordByte.DWORD;
+		}while(--i);
+	}
+
+	/* Adapt type of address */
+	pEccB = (unsigned char*)nECCBuffer;
+	
+	/*	Load ECC code from ECC block */
+	if ( nEccOnOff == ECC_ON )
+	{
+		res = NAND_IO_EncodeECC( nDevInfo->EccType, pEccB );
+		if ( res != SUCCESS )
+			goto ErrorWrite512Data;
+
+		for ( i = 0; i < 28; ++i )	// MLC_ECC_16BIT_TYPE Data Size = 26Byte
+		{
+			*pDataBuffer = nECCBuffer[i];
+			pDataBuffer += 1;
+		}
+	}
+
+	/* Disable ECC Block */
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+ErrorWrite512Data:
+	return res;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      static __inline NAND_IO_ERROR NAND_IO_ReadSpareDataECC( NAND_IO_DEVINFO *nDevInfo, U8 *nSpareBuffer, int nEccOnOff );
+*  
+*  DESCRIPTION : 
+*  
+*  INPUT:
+*			nDevInfo	= 
+*			nEccOnOff	= 
+*			nSpareBuffer	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+*  REMARK:	  by nemo
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_ReadSpareData( NAND_IO_DEVINFO *nDevInfo, U8 *nSpareBuffer, int nPageEccOnOff )
+{
+	unsigned int		i;
+	unsigned int		nReadSize;
+	unsigned int		nSpareTotalSize;
+	unsigned char		bAlignAddr;
+	unsigned char		*pSpareB = 0, *pEccB;
+	unsigned int		*pSpareDW = 0;
+	unsigned char		*pSpareBuffer;
+	#ifdef _LINUX_
+	unsigned char		nECCBuffer[30]__attribute__((aligned(8)));
+	#else
+	unsigned char		nECCBuffer[30];
+	#endif
+	DWORD_BYTE			uDWordByte;
+	NAND_IO_ERROR		res;
+
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	res = (NAND_IO_ERROR)SUCCESS;
+	nSpareTotalSize = NAND_IO_SPARE_SIZE_BIG;
+
+	//=========================================================================
+	// Check Align of PageBuffer Address
+	//=========================================================================
+	bAlignAddr = ( (unsigned int)nSpareBuffer & 3 ) ? 0 : 1;
+
+	NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+	
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================	
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//=========================================================================
+	// Get Buffer Pointer
+	//=========================================================================
+	/* Adapt type of address */
+	if ( bAlignAddr )
+		pSpareDW	= (unsigned int*)nSpareBuffer;
+	else
+		pSpareB		= (unsigned char*)nSpareBuffer;
+
+	if ( nDevInfo->Feature.MediaType & A_SMALL )
+	{
+		//----------------------------------------------
+		//	Read Small Page Spare Data: 16Byte
+		//----------------------------------------------
+		i = 4;
+		
+		do {
+			if ( bAlignAddr )
+			{
+				*pSpareDW = pNFC->NFC_WDATA;++pSpareDW;
+			}	
+			else
+			{
+				uDWordByte.DWORD = pNFC->NFC_WDATA;
+				*pSpareB = uDWordByte.BYTE[0];++pSpareB;
+				*pSpareB = uDWordByte.BYTE[1];++pSpareB;
+				*pSpareB = uDWordByte.BYTE[2];++pSpareB;
+				*pSpareB = uDWordByte.BYTE[3];++pSpareB;
+			}
+		}while(--i);
+
+		if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		{
+			if ( nPageEccOnOff == PAGE_ECC_ON )
+			{
+				memset( gNAND_IO_ShareEccBuffer, 0xFF, 16 );
+				
+				//=========================================================================
+				// Check Align of PageBuffer Address
+				//=========================================================================
+				bAlignAddr = ( (unsigned int)&gNAND_IO_ShareEccBuffer & 3 ) ? 0 : 1;
+				
+				//=========================================================================
+				// Get Buffer Pointer
+				//=========================================================================
+				/* Adapt type of address */
+				if ( bAlignAddr )
+					pSpareDW	= (unsigned int*)&gNAND_IO_ShareEccBuffer[0];
+				else
+					pSpareB		= (unsigned char*)&gNAND_IO_ShareEccBuffer[0];
+				
+				//----------------------------------------------
+				//	Read Spare Data
+				//----------------------------------------------
+				i = 4;
+				do {
+					if ( bAlignAddr )
+					{
+						*pSpareDW = pNFC->NFC_WDATA;++pSpareDW;
+					}	
+					else
+					{
+						uDWordByte.DWORD = pNFC->NFC_WDATA;
+						*pSpareB = uDWordByte.BYTE[0];++pSpareB;
+						*pSpareB = uDWordByte.BYTE[1];++pSpareB;
+						*pSpareB = uDWordByte.BYTE[2];++pSpareB;
+						*pSpareB = uDWordByte.BYTE[3];++pSpareB;
+					}
+				}while(--i);
+			}
+		}
+
+		return SUCCESS;
+	}
+
+	/* Setup ECC Block */
+	#if defined(_WINCE_) || defined(_LINUX_)
+	NAND_IO_SetupECC( ECC_ON, ECC_DECODE, MLC_ECC_4BIT_TYPE, NAND_MCU_ACCESS, (U32)&NAND_IO_HwDATA_PA );
+	#else
+	NAND_IO_SetupECC( ECC_ON, ECC_DECODE, MLC_ECC_4BIT_TYPE, NAND_MCU_ACCESS, (U32)&pNFC->NFC_WDATA );
+	#endif
+	pECC->ECC_CTRL	|= ( nSpareTotalSize << ECC_SHIFT_DATASIZE );
+	pECC->ECC_CLEAR	= 0x00000000;		// Clear ECC Block
+	
+	/* Set Spare Buffer */
+	pSpareBuffer = ( bAlignAddr ) ? (unsigned char*)pSpareDW : (unsigned char*)pSpareB;
+
+	//----------------------------------------------
+	//	Read Spare Data
+	//----------------------------------------------
+	i = ( nSpareTotalSize >> 2 );
+	do {
+		if ( bAlignAddr )
+		{
+			*pSpareDW = pNFC->NFC_WDATA;++pSpareDW;
+		}	
+		else
+		{
+			uDWordByte.DWORD = pNFC->NFC_WDATA;
+			*pSpareB = uDWordByte.BYTE[0];++pSpareB;
+			*pSpareB = uDWordByte.BYTE[1];++pSpareB;
+			*pSpareB = uDWordByte.BYTE[2];++pSpareB;
+			*pSpareB = uDWordByte.BYTE[3];++pSpareB;
+		}
+	}while(--i);
+
+	/* Read 4Bit ECC data */
+	nReadSize = 8;
+	
+	/* Adapt type of address */
+	pEccB = (unsigned char*)nECCBuffer;
+
+	//----------------------------------------------
+	// Read ECC Code
+	//----------------------------------------------
+	while ( nReadSize )
+	{
+		/* Read as DWORD */
+		if ( nReadSize >= 4 )
+		{
+			uDWordByte.DWORD = WORD_OF(pNFC->NFC_WDATA);
+			*pEccB = uDWordByte.BYTE[0];++pEccB;
+			*pEccB = uDWordByte.BYTE[1];++pEccB;
+			*pEccB = uDWordByte.BYTE[2];++pEccB;
+			*pEccB = uDWordByte.BYTE[3];++pEccB;
+			nReadSize -= 4;
+		}
+		/* Read as WORD */
+		else if ( nReadSize >= 2 )
+		{
+			*pEccB = (unsigned char)pNFC->NFC_SDATA; ++pEccB;
+			*pEccB = (unsigned char)pNFC->NFC_SDATA; ++pEccB;			
+			nReadSize -= 2;
+		}
+		/* Read as BYTE */
+		else
+		{
+			*pEccB = (unsigned char)pNFC->NFC_SDATA; ++pEccB;			
+			nReadSize -= 1;
+		}
+	}
+
+	/* Check and Correct ECC code */
+	//===================================
+	// 4 Bit MLC ECC Correction
+	//===================================
+	if ( ( nECCBuffer[0] == 0x00 ) && ( nECCBuffer[1] == 0x00 ) &&
+		 ( nECCBuffer[2] == 0x00 ) && ( nECCBuffer[3] == 0x00 ) &&
+		 ( nECCBuffer[4] == 0x00 ) && ( nECCBuffer[5] == 0x00 ) &&
+		 ( nECCBuffer[6] == 0x00 ) && ( nECCBuffer[7] == 0x00 ))
+	{
+		res |= NAND_IO_CorrectionMLC( MLC_ECC_4BIT_TYPE, pSpareBuffer, nECCBuffer, (U16)nSpareTotalSize );
+	 	res |= ERR_NAND_IO_FAILED_CORRECTION_MLC_ECC;
+	}
+	else if ( ( nECCBuffer[0] == 0xFF ) && ( nECCBuffer[1] == 0xFF ) &&
+		 	  ( nECCBuffer[2] == 0xFF ) && ( nECCBuffer[3] == 0xFF ) &&
+		 	  ( nECCBuffer[4] == 0xFF ) && ( nECCBuffer[5] == 0xFF ) &&
+		 	  ( nECCBuffer[6] == 0xFF ) && ( nECCBuffer[7] == 0xFF ))
+ 	{
+		ASM_NOP;
+	}
+	else
+	{
+		res |= NAND_IO_CorrectionMLC( MLC_ECC_4BIT_TYPE, pSpareBuffer, nECCBuffer, (U16)nSpareTotalSize );
+	}
+
+	//=========================================================================
+	// Ecc Clear
+	//=========================================================================
+	NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	if ( nPageEccOnOff == PAGE_ECC_ON )
+	{
+		memset( gNAND_IO_ShareEccBuffer, 0xFF, nDevInfo->EccWholeDataSize );
+		
+		//=========================================================================
+		// Check Align of PageBuffer Address
+		//=========================================================================
+		bAlignAddr = ( (unsigned int)&gNAND_IO_ShareEccBuffer & 3 ) ? 0 : 1;
+		
+		//=========================================================================
+		// Get Buffer Pointer
+		//=========================================================================
+		/* Adapt type of address */
+		if ( bAlignAddr )
+			pSpareDW	= (unsigned int*)&gNAND_IO_ShareEccBuffer[0];
+		else
+			pSpareB		= (unsigned char*)&gNAND_IO_ShareEccBuffer[0];
+		
+		//----------------------------------------------
+		//	Read Spare Data
+		//----------------------------------------------
+		i = ( nDevInfo->EccWholeDataSize >> 2 );
+		do {
+			if ( bAlignAddr )
+			{
+				*pSpareDW = pNFC->NFC_WDATA;++pSpareDW;
+			}	
+			else
+			{
+				uDWordByte.DWORD = pNFC->NFC_WDATA;
+				*pSpareB = uDWordByte.BYTE[0];++pSpareB;
+				*pSpareB = uDWordByte.BYTE[1];++pSpareB;
+				*pSpareB = uDWordByte.BYTE[2];++pSpareB;
+				*pSpareB = uDWordByte.BYTE[3];++pSpareB;
+			}
+		}while(--i);
+	}
+
+	return res;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      static __inline NAND_IO_ERROR NAND_IO_ReadSpareDataECC( NAND_IO_DEVINFO *nDevInfo, U8 *nSpareBuffer, int nEccOnOff );
+*  
+*  DESCRIPTION : 
+*  
+*  INPUT:
+*			nDevInfo	= 
+*			nEccOnOff	= 
+*			nSpareBuffer	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+*  REMARK:	  by nemo
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_ReadSpareDataMTD( NAND_IO_DEVINFO *nDevInfo, U8 *nSpareBuffer, int nPageEccOnOff )
+{
+	unsigned int		i;
+	unsigned int		nSpareTotalSize;
+	unsigned int		nECCDataSize = 8;
+	unsigned char		bAlignAddr;
+	unsigned char		*pSpareB = 0;
+	unsigned int		*pSpareDW = 0;
+	unsigned char		*pSpareBuffer;
+	DWORD_BYTE			uDWordByte;
+	NAND_IO_ERROR		res;
+
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	res = (NAND_IO_ERROR)SUCCESS;
+
+	nSpareTotalSize = 32;
+
+	//=========================================================================
+	// Check Align of PageBuffer Address
+	//=========================================================================
+	bAlignAddr = ( (unsigned int)nSpareBuffer & 3 ) ? 0 : 1;
+
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================	
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//=========================================================================
+	// Get Buffer Pointer
+	//=========================================================================
+	/* Adapt type of address */
+	if ( bAlignAddr )
+		pSpareDW	= (unsigned int*)nSpareBuffer;
+	else
+		pSpareB		= (unsigned char*)nSpareBuffer;
+
+	if ( nDevInfo->Feature.MediaType & A_SMALL )
+	{
+		//----------------------------------------------
+		//	Read Small Page Spare Data: 16Byte
+		//----------------------------------------------
+		i = 4;
+		
+		do {
+			if ( bAlignAddr )
+			{
+				*pSpareDW = pNFC->NFC_WDATA;++pSpareDW;
+			}	
+			else
+			{
+				uDWordByte.DWORD = pNFC->NFC_WDATA;
+				*pSpareB = uDWordByte.BYTE[0];++pSpareB;
+				*pSpareB = uDWordByte.BYTE[1];++pSpareB;
+				*pSpareB = uDWordByte.BYTE[2];++pSpareB;
+				*pSpareB = uDWordByte.BYTE[3];++pSpareB;
+			}
+		}while(--i);
+
+		if ( nDevInfo->Feature.MediaType & A_PARALLEL )
+		{
+			if ( nPageEccOnOff == PAGE_ECC_ON )
+			{
+				memset( gNAND_IO_ShareEccBuffer, 0xFF, 16 );
+				
+				//=========================================================================
+				// Check Align of PageBuffer Address
+				//=========================================================================
+				bAlignAddr = ( (unsigned int)&gNAND_IO_ShareEccBuffer & 3 ) ? 0 : 1;
+				
+				//=========================================================================
+				// Get Buffer Pointer
+				//=========================================================================
+				/* Adapt type of address */
+				if ( bAlignAddr )
+					pSpareDW	= (unsigned int*)&gNAND_IO_ShareEccBuffer[0];
+				else
+					pSpareB		= (unsigned char*)&gNAND_IO_ShareEccBuffer[0];
+				
+				//----------------------------------------------
+				//	Read Spare Data
+				//----------------------------------------------
+				i = 4;
+				do {
+					if ( bAlignAddr )
+					{
+						*pSpareDW = pNFC->NFC_WDATA;++pSpareDW;
+					}
+					else
+					{
+						uDWordByte.DWORD = pNFC->NFC_WDATA;
+						*pSpareB = uDWordByte.BYTE[0];++pSpareB;
+						*pSpareB = uDWordByte.BYTE[1];++pSpareB;
+						*pSpareB = uDWordByte.BYTE[2];++pSpareB;
+						*pSpareB = uDWordByte.BYTE[3];++pSpareB;
+					}
+				}while(--i);
+			}
+		}
+
+		return SUCCESS;
+	}
+	
+	/* Set Spare Buffer */
+	pSpareBuffer = ( bAlignAddr ) ? (unsigned char*)pSpareDW : (unsigned char*)pSpareB;
+
+	//----------------------------------------------
+	//	Read Spare Data
+	//----------------------------------------------
+	i = ( nSpareTotalSize >> 2 );
+	do {
+		if ( bAlignAddr )
+		{
+			*pSpareDW = pNFC->NFC_WDATA;++pSpareDW;
+		}	
+		else
+		{
+			uDWordByte.DWORD = pNFC->NFC_WDATA;
+			*pSpareB = uDWordByte.BYTE[0];++pSpareB;
+			*pSpareB = uDWordByte.BYTE[1];++pSpareB;
+			*pSpareB = uDWordByte.BYTE[2];++pSpareB;
+			*pSpareB = uDWordByte.BYTE[3];++pSpareB;
+		}
+	}while(--i);
+
+	if (( nDevInfo->Feature.MediaType & A_MLC ) || ( nDevInfo->Feature.MediaType & A_SLC ))
+		nECCDataSize = 8;
+	else if ( ( nDevInfo->Feature.MediaType & A_MLC_8BIT ) || ( nDevInfo->Feature.MediaType & A_MLC_12BIT ) )
+		nECCDataSize = 20;
+
+	if ( nPageEccOnOff == PAGE_ECC_ON )
+	{
+		memset( gNAND_IO_ShareEccBuffer, 0xFF, ( nECCDataSize << 2 ) );
+		
+		//=========================================================================
+		// Check Align of PageBuffer Address
+		//=========================================================================
+		bAlignAddr = ( (unsigned int)&gNAND_IO_ShareEccBuffer & 3 ) ? 0 : 1;
+		
+		//=========================================================================
+		// Get Buffer Pointer
+		//=========================================================================
+		/* Adapt type of address */
+		if ( bAlignAddr )
+			pSpareDW	= (unsigned int*)&gNAND_IO_ShareEccBuffer[0];
+		else
+			pSpareB		= (unsigned char*)&gNAND_IO_ShareEccBuffer[0];
+		
+		//----------------------------------------------
+		//	Read Spare Data
+		//----------------------------------------------
+		i = ( ( nECCDataSize << 2) >> 2 );
+		do {
+			if ( bAlignAddr )
+			{
+				*pSpareDW = pNFC->NFC_WDATA;++pSpareDW;
+			}	
+			else
+			{
+				uDWordByte.DWORD = pNFC->NFC_WDATA;
+				*pSpareB = uDWordByte.BYTE[0];++pSpareB;
+				*pSpareB = uDWordByte.BYTE[1];++pSpareB;
+				*pSpareB = uDWordByte.BYTE[2];++pSpareB;
+				*pSpareB = uDWordByte.BYTE[3];++pSpareB;
+			}
+		}while(--i);
+	}
+
+	return res;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_Read512DataDoubleBuf( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nReadPPSize,
+*      												      		   U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff, int nSpareOnOff );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nDevInfo	= 
+*			nEccOnOff	= 
+*			nPageBuffer	= 
+*			nReadPPSize	= 
+*			nSpareBuffer	= 
+*			nStartPPage	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_Read512DataDoubleBuf( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nReadPPSize,
+												   			U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff, int nSpareOnOff )
+{
+	unsigned int		i, j;
+	unsigned char		bAlignAddr;
+	unsigned char		*pPageB = 0, *pSpareB = 0;
+	unsigned int		*pPageDW = 0, *pSpareDW = 0;
+	unsigned char		*pDataBuffer, *pSpareBuffer = 0;
+	unsigned char		*pPrDataBuffer = 0;
+	DWORD_BYTE			uDWordByte;
+	NAND_IO_ERROR		res = (NAND_IO_ERROR)SUCCESS;
+	
+	if ( ( nStartPPage + nReadPPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	#ifdef READ_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw6);
+	#endif /* READ_SPEED_CHECK */
+
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	res = (NAND_IO_ERROR)SUCCESS;
+	nSpareOnOff = TNFTL_READ_SPARE_ON;
+
+	//=========================================================================
+	// Check Align of PageBuffer Address
+	//=========================================================================
+	bAlignAddr = ( (unsigned int)nPageBuffer & 3 ) ? 0 : 1;
+
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================	
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	#ifdef READ_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw6);	//----------------------->> ECC Setup
+	#endif /* READ_SPEED_CHECK */
+
+	//=========================================================================
+	// Get Buffer Pointer
+	//=========================================================================
+	/* Adapt type of address */
+	if ( bAlignAddr )
+	{
+		pPageDW		= (unsigned int*)nPageBuffer;
+		pSpareDW	= (unsigned int*)nSpareBuffer;		
+	}
+	else
+	{
+		pPageB		= (unsigned char*)nPageBuffer;
+		pSpareB		= (unsigned char*)nSpareBuffer;
+	}
+
+	// Set SpareBuffer Pointer =>> ECCBuffer
+	if ( ( nDevInfo->Feature.MediaType  & A_BIG ) || (( nDevInfo->Feature.MediaType  & A_SMALL ) && ( nDevInfo->Feature.MediaType  & A_PARALLEL )))
+	{
+		pSpareB		= (unsigned char*)&gNAND_IO_ShareEccBuffer[0];
+		
+		//=========================================================================
+		// Empty Page ECCBuffer Pointer Increment
+		//=========================================================================
+		for ( j = 0; j < nStartPPage; ++j )
+			pSpareB += nDevInfo->EccDataSize;
+	}
+	
+	//----------------------------------------------
+	//	Read Data as 512Bytes repeatly
+	//----------------------------------------------
+	for ( j = 0; j < nReadPPSize; ++j )
+	{
+		/* Set Data Buffer */
+		pDataBuffer = ( bAlignAddr ) ? (unsigned char*)pPageDW : (unsigned char*)pPageB;
+
+		//####################################################
+		//#	Read 512 Page Data
+		//####################################################
+		//----------------------------------------------
+		//	MCU ACCESS
+		//----------------------------------------------
+		#if defined( NAND_IO_USE_MCU_ACCESS )
+		/* Setup ECC Block */
+		if ( nEccOnOff == ECC_ON )
+		{
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&NAND_IO_HwDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&pNFC->NFC_WDATA );
+			#endif
+			pECC->ECC_CTRL		|= ( 512 << ECC_SHIFT_DATASIZE );
+			pECC->ECC_CLEAR	 = 0x00000000;			/* Clear ECC Block		*/
+		}
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw5);
+		#endif
+
+		/* Read 512 Data Area */
+		i = 128;
+		do {
+			if ( bAlignAddr )
+			{
+				*pPageDW = pNFC->NFC_WDATA;++pPageDW;
+			}
+			else
+			{
+				uDWordByte.DWORD = pNFC->NFC_WDATA;
+				*pPageB = uDWordByte.BYTE[0];++pPageB;
+				*pPageB = uDWordByte.BYTE[1];++pPageB;
+				*pPageB = uDWordByte.BYTE[2];++pPageB;
+				*pPageB = uDWordByte.BYTE[3];++pPageB;
+			}
+		}while(--i);
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw5);
+		#endif
+		//----------------------------------------------
+		//	DMA ACCESS
+		//----------------------------------------------
+		#elif defined( NAND_IO_USE_DMA_ACCESS )		
+		/* Setup ECC Block */
+		if ( nEccOnOff == ECC_ON )
+		{
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&pNFC->NFC_LDATA );
+			#endif
+			pECC->ECC_CTRL		|= ( 512 << ECC_SHIFT_DATASIZE );
+			pECC->ECC_CLEAR	 = 0x00000000;			/* Clear ECC Block		*/
+		}
+		
+		/* Disable DMA Ahead */
+		/* Start DMA on NFC BUS */
+		NAND_IO_SetupDMADoubleBuf( NAND_IO_DMA_READ, j );
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw6);
+		#endif
+
+		pNFC->NFC_RSTART	= 0;
+		
+		if ( j != 0 )
+		{
+			if ( j & 1 )
+				memcpy( pPrDataBuffer, gpDMA_WorkBuffer1, 512 );
+			else
+				memcpy( pPrDataBuffer, gpDMA_WorkBuffer0, 512 );
+		}
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw6);
+		#endif
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw5);
+		#endif
+		while ( ISZERO(pNFC->NFC_IREQ, HwNFC_IREQ_FLAG0) );
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw5);
+		#endif
+
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw4);
+		#endif		
+		if ( j == (unsigned int)( nReadPPSize - 1 ) )
+		{
+			if ( j & 1 )
+				memcpy( pDataBuffer, gpDMA_WorkBuffer0, 512 );
+			else
+				memcpy( pDataBuffer, gpDMA_WorkBuffer1, 512 );
+		}
+		else
+		{
+			pPrDataBuffer = pDataBuffer;	// Buffer Pointer Backup
+
+			if ( j & 1 )
+				pDataBuffer =(unsigned char *)gpDMA_WorkBuffer0;			
+			else
+				pDataBuffer =(unsigned char *)gpDMA_WorkBuffer1;
+		}
+
+		if ( bAlignAddr )
+			pPageDW += 128;
+		else
+			pPageB += 512;
+		#ifdef READ_SPEED_CHECK		
+		NAND_IO_GPIO_Toggle(Hw4);
+		#endif
+
+		#endif
+		//####################################################
+		//####################################################
+		if ( ( nDevInfo->Feature.MediaType  & A_BIG ) || (( nDevInfo->Feature.MediaType  & A_SMALL ) && ( nDevInfo->Feature.MediaType  & A_PARALLEL )))
+		{
+			// NOP	
+		}
+		else if ( nDevInfo->Feature.MediaType & A_SMALL )
+		{
+			/* Set Spare Buffer */
+			pSpareBuffer = ( bAlignAddr ) ? (unsigned char*)pSpareDW : (unsigned char*)pSpareB;
+
+			/* Read 16Bytes spare data */
+			i = 4;
+			do {
+				if ( bAlignAddr )
+				{
+					*pSpareDW = pNFC->NFC_WDATA;++pSpareDW;
+				}	
+				else
+				{
+					uDWordByte.DWORD = pNFC->NFC_WDATA;
+					*pSpareB = uDWordByte.BYTE[0];++pSpareB;
+					*pSpareB = uDWordByte.BYTE[1];++pSpareB;
+					*pSpareB = uDWordByte.BYTE[2];++pSpareB;
+					*pSpareB = uDWordByte.BYTE[3];++pSpareB;
+				}
+			}while(--i);
+
+
+			pSpareB = (unsigned char*)pSpareBuffer;
+			pSpareB +=	NAND_IO_SPARE_SIZE_SMALL;
+		}
+
+		/* Check and Correct ECC code */
+		if ( nEccOnOff == ECC_ON )
+		{
+			if ( nDevInfo->EccType == SLC_ECC_TYPE )
+			{
+				//===================================
+				// SLC ECC Correction
+				//===================================				
+				pSpareBuffer += NAND_IO_SPARE_SIZE_SMALL;
+				res |= NAND_IO_CorrectionSLC( pDataBuffer, pSpareBuffer );
+			}
+			else
+			{
+				res |= NAND_IO_CorrectionMLC( nDevInfo->EccType, pDataBuffer, pSpareB, 512 );
+
+				pSpareB += nDevInfo->EccDataSize;
+			}
+		}
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw6);
+		#endif		
+	}
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	return res;
+
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_Read512Data( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nReadPPSize,
+*      												      U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff, int nSpareOnOff );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nDevInfo	= 
+*			nEccOnOff	= 
+*			nPageBuffer	= 
+*			nReadPPSize	= 
+*			nSpareBuffer	= 
+*			nStartPPage	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_Read512Data( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nReadPPSize,
+												   U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff, int nSpareOnOff )
+{
+	unsigned int		i, j;
+	unsigned char		bAlignAddr;
+	unsigned char		*pPageB = 0, *pSpareB;
+	unsigned int		*pPageDW = 0, *pSpareDW;
+	unsigned char		*pDataBuffer, *pSpareBuffer;
+	DWORD_BYTE			uDWordByte;
+	NAND_IO_ERROR		res = (NAND_IO_ERROR)SUCCESS;
+	
+	if ( ( nStartPPage + nReadPPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	#ifdef READ_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw13);
+	#endif /* READ_SPEED_CHECK */
+
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	res = (NAND_IO_ERROR)SUCCESS;
+	nSpareOnOff = TNFTL_READ_SPARE_ON;
+
+	//=========================================================================
+	// Check Align of PageBuffer Address
+	//=========================================================================
+	bAlignAddr = ( (unsigned int)nPageBuffer & 3 ) ? 0 : 1;
+
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================	
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	#ifdef READ_SPEED_CHECK
+	NAND_IO_GPIO_Toggle(Hw13);	//----------------------->> ECC Setup
+	#endif /* READ_SPEED_CHECK */
+
+	//=========================================================================
+	// Get Buffer Pointer
+	//=========================================================================
+	/* Adapt type of address */
+	if ( bAlignAddr )
+	{
+		pPageDW		= (unsigned int*)nPageBuffer;
+		pSpareDW	= (unsigned int*)nSpareBuffer;		
+	}
+	else
+	{
+		pPageB		= (unsigned char*)nPageBuffer;
+		pSpareB		= (unsigned char*)nSpareBuffer;
+	}
+
+	// Set SpareBuffer Pointer =>> ECCBuffer
+	if ( ( nDevInfo->Feature.MediaType  & A_BIG ) || (( nDevInfo->Feature.MediaType  & A_SMALL ) && ( nDevInfo->Feature.MediaType  & A_PARALLEL )))
+	{
+		pSpareB		= (unsigned char*)&gNAND_IO_ShareEccBuffer[0];
+		
+		//=========================================================================
+		// Empty Page ECCBuffer Pointer Increment
+		//=========================================================================
+		for ( j = 0; j < nStartPPage; ++j )
+			pSpareB += nDevInfo->EccDataSize;
+	}
+	
+	//----------------------------------------------
+	//	Read Data as 512Bytes repeatly
+	//----------------------------------------------
+	for ( j = 0; j < nReadPPSize; ++j )
+	{
+		/* Set Data Buffer */
+		pDataBuffer = ( bAlignAddr ) ? (unsigned char*)pPageDW : (unsigned char*)pPageB;
+
+		//####################################################
+		//#	Read 512 Page Data
+		//####################################################
+		//----------------------------------------------
+		//	MCU ACCESS
+		//----------------------------------------------
+		#if defined( NAND_IO_USE_MCU_ACCESS )
+		/* Setup ECC Block */
+		if ( nEccOnOff == ECC_ON )
+		{
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&NAND_IO_HwDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&pNFC->NFC_WDATA );
+			#endif
+			pECC->ECC_CTRL		|= ( 512 << ECC_SHIFT_DATASIZE );
+			pECC->ECC_CLEAR	 = 0x00000000;			/* Clear ECC Block		*/
+		}
+
+		#ifdef READ_SPEED_CHECK
+		BITCLR(pGPIO->GPBDAT, Hw15);
+
+		NAND_IO_GPIO_Toggle(Hw15);
+		#endif
+
+		/* Read 512 Data Area */
+		i = 128;
+		do {
+			if ( bAlignAddr )
+			{
+				*pPageDW = pNFC->NFC_WDATA;++pPageDW;
+			}
+			else
+			{
+				uDWordByte.DWORD = pNFC->NFC_WDATA;
+				*pPageB = uDWordByte.BYTE[0];++pPageB;
+				*pPageB = uDWordByte.BYTE[1];++pPageB;
+				*pPageB = uDWordByte.BYTE[2];++pPageB;
+				*pPageB = uDWordByte.BYTE[3];++pPageB;
+			}
+		}while(--i);
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw15);
+		#endif
+		//----------------------------------------------
+		//	DMA ACCESS
+		//----------------------------------------------
+		#elif defined( NAND_IO_USE_DMA_ACCESS )		
+		/* Setup ECC Block */
+		if ( nEccOnOff == ECC_ON )
+		{
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&pNFC->NFC_LDATA );
+			#endif
+			pECC->ECC_CTRL		|= ( 512 << ECC_SHIFT_DATASIZE );
+			pECC->ECC_CLEAR	 = 0x00000000;			/* Clear ECC Block		*/
+		}
+		
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw13);
+		#endif /* READ_SPEED_CHECK */
+
+
+		#ifdef READ_SPEED_CHECK
+		BITCLR(pGPIO->GPBDAT, Hw15);
+		#endif
+
+		/* Start DMA on NFC BUS */
+		#if defined(_LINUX_) || defined(_WINCE_)
+		NAND_IO_SetupDMA( (void*)&NAND_IO_HwLDATA_PA, 0, 0,
+						  (void*)pDataBuffer, 4, 0,
+						  NAND_IO_DMA_READ, 512 );
+		#else
+		NAND_IO_SetupDMA( (void*)&pNFC->NFC_LDATA, 0, 0,
+						  (void*)pDataBuffer, 4, 0,
+						  NAND_IO_DMA_READ, 512 );
+		#endif
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw15);
+		#endif
+
+		if ( bAlignAddr )
+			pPageDW += 128;
+		else
+			pPageB += 512;
+
+		#ifdef READ_SPEED_CHECK		
+		NAND_IO_GPIO_Toggle(Hw13);	//------------------------------------->> DMA Transfer
+		#endif
+
+		#endif
+		//####################################################
+		//####################################################
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw13);
+		#endif
+
+		if ( ( nDevInfo->Feature.MediaType  & A_BIG ) || (( nDevInfo->Feature.MediaType  & A_SMALL ) && ( nDevInfo->Feature.MediaType  & A_PARALLEL )))
+		{
+			// NOP	
+		}
+		else if ( nDevInfo->Feature.MediaType & A_SMALL )
+		{
+			/* Set Spare Buffer */
+			pSpareBuffer = ( bAlignAddr ) ? (unsigned char*)pSpareDW : (unsigned char*)pSpareB;
+
+			/* Read 16Bytes spare data */
+			i = 4;
+			do {
+				if ( bAlignAddr )
+				{
+					*pSpareDW = pNFC->NFC_WDATA;++pSpareDW;
+				}	
+				else
+				{
+					uDWordByte.DWORD = pNFC->NFC_WDATA;
+					*pSpareB = uDWordByte.BYTE[0];++pSpareB;
+					*pSpareB = uDWordByte.BYTE[1];++pSpareB;
+					*pSpareB = uDWordByte.BYTE[2];++pSpareB;
+					*pSpareB = uDWordByte.BYTE[3];++pSpareB;
+				}
+			}while(--i);
+
+
+			pSpareB = (unsigned char*)pSpareBuffer;
+			pSpareB +=	NAND_IO_SPARE_SIZE_SMALL;
+		}
+
+		/* Check and Correct ECC code */
+		if ( nEccOnOff == ECC_ON )
+		{
+			if ( nDevInfo->EccType == SLC_ECC_TYPE )
+			{
+				//===================================
+				// SLC ECC Correction
+				//===================================				
+				pSpareBuffer += NAND_IO_SPARE_SIZE_SMALL;
+				res |= NAND_IO_CorrectionSLC( pDataBuffer, pSpareBuffer );
+			}
+			else
+			{
+				res |= NAND_IO_CorrectionMLC( nDevInfo->EccType, pDataBuffer, pSpareB, 512 );
+
+				pSpareB += nDevInfo->EccDataSize;
+			}
+		}
+
+		#ifdef READ_SPEED_CHECK
+		NAND_IO_GPIO_Toggle(Hw13);		//--------------------------------->> ECC Correction
+		#endif		
+	}
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	return res;
+
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_Read512DataMTD( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nReadPPSize,
+*      												   U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nDevInfo	= 
+*			nEccOnOff	= 
+*			nPageBuffer	= 
+*			nReadPPSize	= 
+*			nSpareBuffer	= 
+*			nStartPPage	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_Read512DataMTD( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nReadPPSize,
+												  	 U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff, int nSpareOnOff )
+{
+	unsigned int		i, j;
+	unsigned char		bAlignAddr;
+	unsigned int		nECCDataSize = 8;
+	unsigned char		*pPageB = 0, *pSpareB = 0;
+	unsigned int		*pPageDW = 0, *pSpareDW = 0;
+	unsigned char		*pDataBuffer, *pSpareBuffer = 0;
+	DWORD_BYTE			uDWordByte;
+	NAND_IO_ERROR		res = (NAND_IO_ERROR)SUCCESS;
+	
+	if ( ( nStartPPage + nReadPPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	res = (NAND_IO_ERROR)SUCCESS;
+	nSpareOnOff = TNFTL_READ_SPARE_ON;
+
+	//=========================================================================
+	// Check Align of PageBuffer Address
+	//=========================================================================
+	bAlignAddr = ( (unsigned int)nPageBuffer & 3 ) ? 0 : 1;
+
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================	
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	if (( nDevInfo->Feature.MediaType & A_MLC ) ||( nDevInfo->Feature.MediaType & A_SLC ))
+		nECCDataSize = 8;
+	else if ( ( nDevInfo->Feature.MediaType & A_MLC_8BIT ) || ( nDevInfo->Feature.MediaType & A_MLC_12BIT ) )
+		nECCDataSize = 20;
+	
+	//=========================================================================
+	// Get Buffer Pointer
+	//=========================================================================
+	/* Adapt type of address */
+	if ( bAlignAddr )
+	{
+		pPageDW		= (unsigned int*)nPageBuffer;
+		pSpareDW	= (unsigned int*)nSpareBuffer;		
+	}
+	else
+	{
+		pPageB		= (unsigned char*)nPageBuffer;
+		pSpareB		= (unsigned char*)nSpareBuffer;
+	}
+
+	// Set SpareBuffer Pointer =>> ECCBuffer
+	if ( ( nDevInfo->Feature.MediaType  & A_BIG ) || (( nDevInfo->Feature.MediaType  & A_SMALL ) && ( nDevInfo->Feature.MediaType  & A_PARALLEL )))
+	{
+		pSpareB		= (unsigned char*)&gNAND_IO_ShareEccBuffer[0];
+		
+		//=========================================================================
+		// Empty Page ECCBuffer Pointer Increment
+		//=========================================================================
+		for ( j = 0; j < nStartPPage; ++j )
+			pSpareB += nECCDataSize;
+	}
+	
+	//----------------------------------------------
+	//	Read Data as 512Bytes repeatly
+	//----------------------------------------------
+	for ( j = 0; j < nReadPPSize; ++j )
+	{
+		/* Set Data Buffer */
+		pDataBuffer = ( bAlignAddr ) ? (unsigned char*)pPageDW : (unsigned char*)pPageB;
+
+		//####################################################
+		//#	Read 512 Page Data
+		//####################################################
+		//----------------------------------------------
+		//	MCU ACCESS
+		//----------------------------------------------
+		#if defined( NAND_IO_USE_MCU_ACCESS )
+		/* Setup ECC Block */
+		if ( nEccOnOff == ECC_ON )
+		{
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&NAND_IO_HwDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&pNFC->NFC_WDATA );
+			#endif
+			pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );
+			pECC->ECC_CLEAR  = 0x00000000;					// Clear ECC Block
+		}
+
+		/* Read 512 Data Area */
+		i = 128;
+		do {
+			if ( bAlignAddr )
+			{
+				*pPageDW = pNFC->NFC_WDATA;++pPageDW;
+			}
+			else
+			{
+				uDWordByte.DWORD = pNFC->NFC_WDATA;
+				*pPageB = uDWordByte.BYTE[0];++pPageB;
+				*pPageB = uDWordByte.BYTE[1];++pPageB;
+				*pPageB = uDWordByte.BYTE[2];++pPageB;
+				*pPageB = uDWordByte.BYTE[3];++pPageB;
+			}
+		}while(--i);
+
+		//----------------------------------------------
+		//	DMA ACCESS
+		//----------------------------------------------
+		#elif defined( NAND_IO_USE_DMA_ACCESS )		
+		/* Setup ECC Block */
+		if ( nEccOnOff == ECC_ON )
+		{
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_DECODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&pNFC->NFC_LDATA );
+			#endif
+			pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );
+			pECC->ECC_CLEAR	 = 0x00000000;			// Clear ECC Block
+		}
+		
+
+		/* Start DMA on NFC BUS */
+		#if defined(_LINUX_) || defined(_WINCE_)
+		NAND_IO_SetupDMA( (void*)&NAND_IO_HwLDATA_PA, 0, 0,
+						  (void*)pDataBuffer, 4, 0,
+						  NAND_IO_DMA_READ, 512 );
+		#else
+		NAND_IO_SetupDMA( (void*)&pNFC->NFC_LDATA, 0, 0,
+						  (void*)pDataBuffer, 4, 0,
+						  NAND_IO_DMA_READ, 512 );
+		#endif
+
+		if ( bAlignAddr )
+			pPageDW += 128;
+		else
+			pPageB += 512;
+
+
+		#endif
+		//####################################################
+		//####################################################
+
+		if ( ( nDevInfo->Feature.MediaType  & A_BIG ) || (( nDevInfo->Feature.MediaType  & A_SMALL ) && ( nDevInfo->Feature.MediaType  & A_PARALLEL )))
+		{
+			// NOP	
+		}
+		else if ( nDevInfo->Feature.MediaType & A_SMALL )
+		{
+			/* Set Spare Buffer */
+			pSpareBuffer = ( bAlignAddr ) ? (unsigned char*)pSpareDW : (unsigned char*)pSpareB;
+
+			/* Read 16Bytes spare data */
+			i = 4;
+			do {
+				if ( bAlignAddr )
+				{
+					*pSpareDW = pNFC->NFC_WDATA;++pSpareDW;
+				}	
+				else
+				{
+					uDWordByte.DWORD = pNFC->NFC_WDATA;
+					*pSpareB = uDWordByte.BYTE[0];++pSpareB;
+					*pSpareB = uDWordByte.BYTE[1];++pSpareB;
+					*pSpareB = uDWordByte.BYTE[2];++pSpareB;
+					*pSpareB = uDWordByte.BYTE[3];++pSpareB;
+				}
+			}while(--i);
+
+			pSpareB = (unsigned char*)pSpareBuffer;
+			pSpareB +=	NAND_IO_SPARE_SIZE_SMALL;
+		}
+
+		/* Check and Correct ECC code */
+		if ( nEccOnOff == ECC_ON )
+		{
+			if ( nDevInfo->EccType == SLC_ECC_TYPE )
+			{
+				//===================================
+				// SLC ECC Correction
+				//===================================				
+				pSpareBuffer += NAND_IO_SPARE_SIZE_SMALL;
+				res |= NAND_IO_CorrectionSLC( pDataBuffer, pSpareBuffer );
+			}
+			else
+			{
+				res |= NAND_IO_CorrectionMLC( nDevInfo->EccType, pDataBuffer, pSpareB, 512 );
+
+				pSpareB += nECCDataSize;
+			}
+		}
+	
+	}
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	return res;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_ReadUserSizeData( NAND_IO_DEVINFO *nDevInfo, U16 nColumnAddr, U32 nReadSize, U8 *nReadBuffer );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nColumnAddr	= 
+*			nDevInfo	= 
+*			nReadBuffer	= 
+*			nReadSize	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_ReadUserSizeData( NAND_IO_DEVINFO *nDevInfo, U16 nColumnAddr, U32 nReadSize, U8 *nReadBuffer )
+{
+	unsigned int		*pSpareDW = 0;
+	unsigned char		*pPageB = 0;
+	DWORD_BYTE			uDWordByte;
+	
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	//=========================================================================
+	// Check Parameter
+	//=========================================================================
+	if ( (U32)( nColumnAddr + nReadSize ) > (U16)( nDevInfo->Feature.PageSize + nDevInfo->Feature.SpareSize ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================	
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//=========================================================================
+	// Read UserSize Data
+	//=========================================================================
+
+	/* Adapt type of address */
+	pPageB = (unsigned char*)nReadBuffer;
+	pSpareDW= (unsigned int*)nReadBuffer;
+	if ( nReadSize >= 4 )
+	{
+		#ifdef USE_NFC_LDATA		/* 08.12.17 */
+		/* Read 512 Data Area */
+		BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
+		pNFC->NFC_DSIZE		= nReadSize;
+		pNFC->NFC_IREQ	 	= 0x77;	// pNFC->NFC_IREQ_FLAG1;
+		pNFC->NFC_PSTART 	= 0;	
+
+		do {
+			while (!( pNFC->NFC_CTRL & HwNFC_CTRL_FS_RDY ));
+			
+			{
+				uDWordByte.DWORD = pNFC->NFC_LDATA;
+				*pPageB = uDWordByte.BYTE[0];++pPageB;
+				*pPageB = uDWordByte.BYTE[1];++pPageB;
+				*pPageB = uDWordByte.BYTE[2];++pPageB;
+				*pPageB = uDWordByte.BYTE[3];++pPageB;
+			}
+
+			nReadSize -= 4;
+
+		}while(nReadSize);
+
+		while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+	}
+	else
+	{
+		#endif
+		while ( nReadSize )
+		{
+			/* Read as DWORD */
+			if ( nReadSize >= 4 )
+			{
+				uDWordByte.DWORD = WORD_OF(pNFC->NFC_WDATA);
+				*pPageB = uDWordByte.BYTE[0];++pPageB;
+				*pPageB = uDWordByte.BYTE[1];++pPageB;
+				*pPageB = uDWordByte.BYTE[2];++pPageB;
+				*pPageB = uDWordByte.BYTE[3];++pPageB;
+				nReadSize -= 4;
+			}
+			/* Read as WORD */
+			else if ( nReadSize >= 2 )
+			{
+				uDWordByte.WORD[0] = HWORD_OF(pNFC->NFC_WDATA);
+				*pPageB = uDWordByte.BYTE[0];++pPageB;
+				*pPageB = uDWordByte.BYTE[1];++pPageB;
+				nReadSize -= 2;
+			}
+			/* Read as BYTE */
+			else
+			{
+				uDWordByte.BYTE[0] = BYTE_OF(pNFC->NFC_WDATA);
+				*pPageB = uDWordByte.BYTE[0];++pPageB;
+				nReadSize -= 1;
+			}
+		}
+	}
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+	return (NAND_IO_ERROR)SUCCESS;
+
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      static __inline NAND_IO_ERROR NAND_IO_WriteSpareData( NAND_IO_DEVINFO *nDevInfo, U8 *nSpareBuffer, int nEccOnOff );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			nDevInfo	= 
+*			nEccOnOff	= 
+*			nSpareBuffer	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+*  REMARK:	  by nemo
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_WriteSpareData( NAND_IO_DEVINFO *nDevInfo, U8 *nSpareBuffer, int nPageEccOnOff )
+{
+	unsigned int		i;
+	unsigned int		nSpareTotalSize;
+	unsigned int		nWriteSize;
+	unsigned char		bAlignAddr;
+	unsigned char		*pSpareB = 0;
+	unsigned int		*pSpareDW = 0;
+	unsigned char		*pEccB;
+	#ifdef _LINUX_
+	unsigned char		nECCBuffer[28]__attribute__((aligned(8)));
+	#else
+	unsigned char		nECCBuffer[28];
+	#endif
+	DWORD_BYTE			uDWordByte;
+	NAND_IO_ERROR		res;
+
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	res = (NAND_IO_ERROR)SUCCESS;
+
+	nSpareTotalSize = 16;
+	
+	//=========================================================================
+	// Check Align of nSpareBuffer Address
+	//=========================================================================
+	bAlignAddr		= ( (unsigned int)nSpareBuffer & 3 ) ? 0 : 1;
+		
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	//=========================================================================
+	// Get Buffer Pointer
+	//=========================================================================
+	/* Adapt type of address */
+	if ( bAlignAddr )
+		pSpareDW	= (unsigned int*)nSpareBuffer;
+	else
+		pSpareB		= (unsigned char*)nSpareBuffer;
+
+	//==============================================================
+	// Write Spare
+	//==============================================================
+	if ( nDevInfo->Feature.MediaType & A_BIG )
+	{
+		if (!( pNFC->NFC_CTRL1 & Hw30 ))
+		{
+			/* Setup ECC Block */
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)ECC_ON, ECC_ENCODE, MLC_ECC_4BIT_TYPE, NAND_MCU_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)ECC_ON, ECC_ENCODE, MLC_ECC_4BIT_TYPE, NAND_MCU_ACCESS, (U32)&pNFC->NFC_LDATA );
+			#endif
+			pECC->ECC_CTRL	|= ( nSpareTotalSize << ECC_SHIFT_DATASIZE );
+			pECC->ECC_CLEAR	= 0x00000000;
+
+			/* Write 12Bytes spare data */
+			BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
+			pNFC->NFC_DSIZE		= nSpareTotalSize;
+			pNFC->NFC_IREQ	 	= 0x77;	// pNFC->NFC_IREQ_FLAG1;
+			pNFC->NFC_PSTART 	= 0;
+
+			i = ( nSpareTotalSize >> 2 );
+			do {
+				while (!( pNFC->NFC_CTRL & HwNFC_CTRL_FS_RDY ));
+				
+				if ( bAlignAddr )
+				{
+					pNFC->NFC_LDATA = *pSpareDW;++pSpareDW;
+				}
+				else
+				{
+					uDWordByte.BYTE[0]	= *pSpareB;++pSpareB;
+					uDWordByte.BYTE[1]	= *pSpareB;++pSpareB;
+					uDWordByte.BYTE[2]	= *pSpareB;++pSpareB;
+					uDWordByte.BYTE[3]	= *pSpareB;++pSpareB;
+					pNFC->NFC_LDATA = uDWordByte.DWORD;
+				}
+			}while(--i);
+
+			while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+		}
+		else
+		{
+			/* Setup ECC Block */
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)ECC_ON, ECC_ENCODE, MLC_ECC_4BIT_TYPE, NAND_MCU_ACCESS, (U32)&NAND_IO_HwDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)ECC_ON, ECC_ENCODE, MLC_ECC_4BIT_TYPE, NAND_MCU_ACCESS, (U32)&pNFC->NFC_WDATA );
+			#endif
+			pECC->ECC_CTRL	|= ( nSpareTotalSize << ECC_SHIFT_DATASIZE );
+			pECC->ECC_CLEAR	= 0x00000000;
+
+			i = ( nSpareTotalSize >> 2 );
+			do {
+				if ( bAlignAddr )
+				{
+					pNFC->NFC_WDATA = *pSpareDW;++pSpareDW;
+				}
+				else
+				{
+					uDWordByte.BYTE[0]	= *pSpareB;++pSpareB;
+					uDWordByte.BYTE[1]	= *pSpareB;++pSpareB;
+					uDWordByte.BYTE[2]	= *pSpareB;++pSpareB;
+					uDWordByte.BYTE[3]	= *pSpareB;++pSpareB;
+					pNFC->NFC_WDATA = uDWordByte.DWORD;
+				}
+			}while(--i);		
+		}
+
+		// Clear ECC Buffer
+		memset( nECCBuffer, 0xFF, 8 );
+
+		/* Adapt type of address */
+		pEccB = (unsigned char*)nECCBuffer;
+		
+		/*	Load ECC code from ECC block */
+		res = NAND_IO_EncodeECC( MLC_ECC_4BIT_TYPE, pEccB );
+		if ( res != SUCCESS )
+			goto ErrorWriteSpareData;
+
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+		/* Write 4Bit ECC data */
+		nWriteSize = 8;
+
+		while ( nWriteSize )
+		{
+			/* Write as DWORD */
+			if ( nWriteSize >= 4 )
+			{
+				uDWordByte.BYTE[0] = *pEccB;++pEccB;
+				uDWordByte.BYTE[1] = *pEccB;++pEccB;
+				uDWordByte.BYTE[2] = *pEccB;++pEccB;
+				uDWordByte.BYTE[3] = *pEccB;++pEccB;
+				pNFC->NFC_WDATA = uDWordByte.DWORD;
+				nWriteSize -= 4;
+			}
+			/* Write as WORD */
+			else if ( nWriteSize >= 2 )
+			{
+				pNFC->NFC_SDATA = *pEccB;++pEccB;
+				pNFC->NFC_SDATA = *pEccB;++pEccB;
+				nWriteSize -= 2;
+			}
+			/* Write as BYTE */
+			else
+			{
+				pNFC->NFC_SDATA = *pEccB;++pEccB;
+				nWriteSize -= 1;
+			}
+		}
+
+		if ( nPageEccOnOff == PAGE_ECC_ON )
+		{
+			//=========================================================================
+			// Check Align of PageBuffer Address
+			//=========================================================================
+			bAlignAddr = ( (unsigned int)&gNAND_IO_ShareEccBuffer & 3 ) ? 0 : 1;
+			
+			//=========================================================================
+			// Get Buffer Pointer
+			//=========================================================================
+			/* Adapt type of address */
+			if ( bAlignAddr )
+				pSpareDW	= (unsigned int*)&gNAND_IO_ShareEccBuffer[0];
+			else
+				pSpareB		= (unsigned char*)&gNAND_IO_ShareEccBuffer[0];
+			
+			//----------------------------------------------
+			//	Read Spare Data
+			//----------------------------------------------
+			i = ( nDevInfo->EccWholeDataSize >> 2 );
+			do {
+				if ( bAlignAddr )
+				{
+					pNFC->NFC_WDATA = *pSpareDW;++pSpareDW;
+				}	
+				else
+				{
+					uDWordByte.BYTE[0] = *pSpareB;++pSpareB;
+					uDWordByte.BYTE[1] = *pSpareB;++pSpareB;
+					uDWordByte.BYTE[2] = *pSpareB;++pSpareB;
+					uDWordByte.BYTE[3] = *pSpareB;++pSpareB;
+					pNFC->NFC_WDATA = uDWordByte.DWORD;
+				}
+			}while(--i);
+		}
+	}
+	else
+	{
+		i = ( nSpareTotalSize >> 2 );
+		do {
+			if ( bAlignAddr )
+			{
+				pNFC->NFC_WDATA = *pSpareDW;++pSpareDW;
+			}
+			else
+			{
+				uDWordByte.BYTE[0]	= *pSpareB;++pSpareB;
+				uDWordByte.BYTE[1]	= *pSpareB;++pSpareB;
+				uDWordByte.BYTE[2]	= *pSpareB;++pSpareB;
+				uDWordByte.BYTE[3]	= *pSpareB;++pSpareB;
+				pNFC->NFC_WDATA = uDWordByte.DWORD;
+			}
+		}while(--i);
+
+		if (( nDevInfo->Feature.MediaType & A_SMALL ) && ( nDevInfo->Feature.MediaType & A_PARALLEL ))
+		{
+			if ( nPageEccOnOff == PAGE_ECC_ON )
+			{
+				//=========================================================================
+				// Check Align of PageBuffer Address
+				//=========================================================================
+				bAlignAddr = ( (unsigned int)&gNAND_IO_ShareEccBuffer & 3 ) ? 0 : 1;
+				
+				//=========================================================================
+				// Get Buffer Pointer
+				//=========================================================================
+				/* Adapt type of address */
+				if ( bAlignAddr )
+					pSpareDW	= (unsigned int*)&gNAND_IO_ShareEccBuffer[0];
+				else
+					pSpareB		= (unsigned char*)&gNAND_IO_ShareEccBuffer[0];
+				
+				//----------------------------------------------
+				//	Read Spare Data
+				//----------------------------------------------
+				i = ( nDevInfo->EccWholeDataSize >> 2 );
+				do {
+					if ( bAlignAddr )
+					{
+						pNFC->NFC_WDATA = *pSpareDW;++pSpareDW;
+					}	
+					else
+					{
+						uDWordByte.BYTE[0] = *pSpareB;++pSpareB;
+						uDWordByte.BYTE[1] = *pSpareB;++pSpareB;
+						uDWordByte.BYTE[2] = *pSpareB;++pSpareB;
+						uDWordByte.BYTE[3] = *pSpareB;++pSpareB;
+						pNFC->NFC_WDATA = uDWordByte.DWORD;
+					}
+				}while(--i);
+			}			
+		}
+	}
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+
+ErrorWriteSpareData:
+	return res;
+
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      static __inline NAND_IO_ERROR NAND_IO_WriteSpareDataMTD( NAND_IO_DEVINFO *nDevInfo, U8 *nSpareBuffer, int nPageEccOnOff );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			nDevInfo	= 
+*			nPageEccOnOff	= 
+*			nSpareBuffer	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_WriteSpareDataMTD( NAND_IO_DEVINFO *nDevInfo, U8 *nSpareBuffer, int nPageEccOnOff )
+{
+	unsigned int		i;
+	unsigned int		nSpareTotalSize;
+	unsigned int		nECCDataSize = 8;
+	unsigned char		bAlignAddr;
+	unsigned char		*pSpareB = 0;
+	unsigned int		*pSpareDW = 0;
+	DWORD_BYTE			uDWordByte;
+	NAND_IO_ERROR		res;
+
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	res = (NAND_IO_ERROR)SUCCESS;
+	
+	nSpareTotalSize = 32;
+	
+	//=========================================================================
+	// Check Align of nSpareBuffer Address
+	//=========================================================================
+	bAlignAddr		= ( (unsigned int)nSpareBuffer & 3 ) ? 0 : 1;
+		
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	//=========================================================================
+	// Get Buffer Pointer
+	//=========================================================================
+	/* Adapt type of address */
+	if ( bAlignAddr )
+		pSpareDW	= (unsigned int*)nSpareBuffer;
+	else
+		pSpareB		= (unsigned char*)nSpareBuffer;
+
+	if (( nDevInfo->Feature.MediaType & A_MLC ) ||( nDevInfo->Feature.MediaType & A_SLC ))
+		nECCDataSize = 8;
+	else if ( ( nDevInfo->Feature.MediaType & A_MLC_8BIT ) || ( nDevInfo->Feature.MediaType & A_MLC_12BIT ) )
+		nECCDataSize = 20;
+
+	//==============================================================
+	// Write Spare
+	//==============================================================
+	if ( nDevInfo->Feature.MediaType & A_BIG )
+	{
+
+		i = ( nSpareTotalSize >> 2 );
+		do {
+			if ( bAlignAddr )
+			{
+				pNFC->NFC_WDATA = *pSpareDW;++pSpareDW;
+			}
+			else
+			{
+				uDWordByte.BYTE[0]	= *pSpareB;++pSpareB;
+				uDWordByte.BYTE[1]	= *pSpareB;++pSpareB;
+				uDWordByte.BYTE[2]	= *pSpareB;++pSpareB;
+				uDWordByte.BYTE[3]	= *pSpareB;++pSpareB;
+				pNFC->NFC_WDATA = uDWordByte.DWORD;
+			}
+		}while(--i);		
+
+		if ( nPageEccOnOff == PAGE_ECC_ON )
+		{
+			//=========================================================================
+			// Check Align of PageBuffer Address
+			//=========================================================================
+			bAlignAddr = ( (unsigned int)&gNAND_IO_ShareEccBuffer & 3 ) ? 0 : 1;
+			
+			//=========================================================================
+			// Get Buffer Pointer
+			//=========================================================================
+			/* Adapt type of address */
+			if ( bAlignAddr )
+				pSpareDW	= (unsigned int*)&gNAND_IO_ShareEccBuffer[0];
+			else
+				pSpareB		= (unsigned char*)&gNAND_IO_ShareEccBuffer[0];
+			
+			//----------------------------------------------
+			//	Read Spare Data
+			//----------------------------------------------
+			i = ( ( nECCDataSize << 2 ) >> 2 );
+			do {
+				if ( bAlignAddr )
+				{
+					pNFC->NFC_WDATA = *pSpareDW;++pSpareDW;
+				}	
+				else
+				{
+					uDWordByte.BYTE[0] = *pSpareB;++pSpareB;
+					uDWordByte.BYTE[1] = *pSpareB;++pSpareB;
+					uDWordByte.BYTE[2] = *pSpareB;++pSpareB;
+					uDWordByte.BYTE[3] = *pSpareB;++pSpareB;
+					pNFC->NFC_WDATA = uDWordByte.DWORD;
+				}
+			}while(--i);
+		}
+	}
+	else
+	{
+		i = ( nSpareTotalSize >> 2 );
+		do {
+			if ( bAlignAddr )
+			{
+				pNFC->NFC_WDATA = *pSpareDW;++pSpareDW;
+			}
+			else
+			{
+				uDWordByte.BYTE[0]	= *pSpareB;++pSpareB;
+				uDWordByte.BYTE[1]	= *pSpareB;++pSpareB;
+				uDWordByte.BYTE[2]	= *pSpareB;++pSpareB;
+				uDWordByte.BYTE[3]	= *pSpareB;++pSpareB;
+				pNFC->NFC_WDATA = uDWordByte.DWORD;
+			}
+		}while(--i);
+
+		if (( nDevInfo->Feature.MediaType & A_SMALL ) && ( nDevInfo->Feature.MediaType & A_PARALLEL ))
+		{
+			if ( nPageEccOnOff == PAGE_ECC_ON )
+			{
+				//=========================================================================
+				// Check Align of PageBuffer Address
+				//=========================================================================
+				bAlignAddr = ( (unsigned int)&gNAND_IO_ShareEccBuffer & 3 ) ? 0 : 1;
+				
+				//=========================================================================
+				// Get Buffer Pointer
+				//=========================================================================
+				/* Adapt type of address */
+				if ( bAlignAddr )
+					pSpareDW	= (unsigned int*)&gNAND_IO_ShareEccBuffer[0];
+				else
+					pSpareB		= (unsigned char*)&gNAND_IO_ShareEccBuffer[0];
+				
+				//----------------------------------------------
+				//	Read Spare Data
+				//----------------------------------------------
+				i = ( ( 8 << nDevInfo->ShiftPPages) >> 2 );
+				do {
+					if ( bAlignAddr )
+					{
+						pNFC->NFC_WDATA = *pSpareDW;++pSpareDW;
+					}	
+					else
+					{
+						uDWordByte.BYTE[0] = *pSpareB;++pSpareB;
+						uDWordByte.BYTE[1] = *pSpareB;++pSpareB;
+						uDWordByte.BYTE[2] = *pSpareB;++pSpareB;
+						uDWordByte.BYTE[3] = *pSpareB;++pSpareB;
+						pNFC->NFC_WDATA = uDWordByte.DWORD;
+					}
+				}while(--i);
+			}			
+		}
+	}
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+
+	return res;
+
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      static __inline NAND_IO_ERROR NAND_IO_Write512DataDoubleBuf( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nWritePPSize,
+*      												    		 U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			nDevInfo	= 
+*			nEccOnOff	= 
+*			nPageBuffer	= 
+*			nSpareBuffer	= 
+*			nStartPPage	= 
+*			nWritePPSize	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_Write512DataDoubleBuf( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nWritePPSize,
+												    		 U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff )
+{
+	unsigned int		j;
+	unsigned char		bAlignAddr;
+	#ifdef _LINUX_
+	unsigned char 		nDummyPageBuffer[512]__attribute__((aligned(8)));
+	unsigned char		nECCBuffer[30]__attribute__((aligned(8)));
+	#else
+	unsigned char 		nDummyPageBuffer[512];
+	unsigned char		nECCBuffer[30];
+	#endif
+	unsigned int		ColumnAddr;
+	unsigned char		*pPageB = 0, *pSpareB = 0;
+	unsigned int		*pPageDW = 0;
+	unsigned char		*pDataBuffer;
+	unsigned char		*pEccB;
+	#ifdef NAND_IO_USE_MCU_ACCESS
+	unsigned int		i;
+	DWORD_BYTE			uDWordByte;
+	#endif
+	NAND_IO_ECC_INFO	*pECC_Info;	
+	NAND_IO_ERROR		res;
+
+	if ( ( nStartPPage + nWritePPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	res = (NAND_IO_ERROR)SUCCESS;
+
+	//=========================================================================
+	// Check Align of PageBuffer Address
+	//=========================================================================
+	bAlignAddr		= ( (unsigned int)nPageBuffer & 3 ) ? 0 : 1;
+
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	//=========================================================================
+	// Get Buffer Pointer
+	//=========================================================================
+	/* Adapt type of address */
+	if ( bAlignAddr )
+		pPageDW		= (unsigned int*)nPageBuffer;
+	else
+		pPageB		= (unsigned char*)nPageBuffer;
+
+	// Set SpareBuffer Pointer =>> ECCBuffer
+	if ( ( nDevInfo->Feature.MediaType  & A_BIG ) || (( nDevInfo->Feature.MediaType  & A_SMALL ) && ( nDevInfo->Feature.MediaType  & A_PARALLEL )))
+	{
+		memset( gNAND_IO_ShareEccBuffer, 0xFF, nDevInfo->EccWholeDataSize );		
+		pSpareB		= (unsigned char*)&gNAND_IO_ShareEccBuffer[0];
+	}
+	else
+	{
+		pSpareB		= (unsigned char*)nSpareBuffer;
+		pSpareB 	+= NAND_IO_SPARE_SIZE_SMALL;
+	}
+
+	//=========================================================================
+	// Empty Page ECCBuffer Pointer Increment
+	//=========================================================================
+	for ( j = 0; j < nStartPPage; ++j )
+	{
+		if ( nDevInfo->EccType == MLC_ECC_4BIT_TYPE )
+			pECC_Info = &gMLC_ECC_4Bit;
+		else if ( nDevInfo->EccType == MLC_ECC_8BIT_TYPE )
+			pECC_Info = &gMLC_ECC_8Bit;
+		else if ( nDevInfo->EccType == MLC_ECC_12BIT_TYPE )
+			pECC_Info = &gMLC_ECC_12Bit;
+		else if ( nDevInfo->EccType == MLC_ECC_14BIT_TYPE )
+			pECC_Info = &gMLC_ECC_14Bit;
+		else if ( nDevInfo->EccType == MLC_ECC_16BIT_TYPE )
+			pECC_Info = &gMLC_ECC_16Bit;
+		else
+			return ERR_NAND_IO_WRONG_PARAMETER;
+
+		memcpy(	(void*)pSpareB, (void*)pECC_Info->All_FF_512_ECC_Code, nDevInfo->EccDataSize);
+
+		pSpareB += nDevInfo->EccDataSize;
+	}
+
+	//----------------------------------------------
+	//	Write Data as 512Bytes repeatly
+	//----------------------------------------------
+	for ( j = 0; j < nWritePPSize; ++j )
+	{
+		/* Get Data Buffer */
+		pDataBuffer = ( bAlignAddr ) ? (unsigned char*)pPageDW : (unsigned char*)pPageB;
+
+		//####################################################
+		//#	Write 512 Page Data
+		//####################################################
+		//----------------------------------------------
+		//	MCU ACCESS
+		//----------------------------------------------
+		#if defined( NAND_IO_USE_MCU_ACCESS )
+		if ( nEccOnOff == ECC_ON )
+		{
+			/* Setup ECC Block */
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&pNFC->NFC_LDATA );
+			#endif
+			pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );
+			pECC->ECC_CLEAR	= 0x00000000;
+		}
+
+		/* Write 512 Data Area */
+		BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
+		pNFC->NFC_DSIZE		= 512;
+		pNFC->NFC_IREQ 		= 0x77;	// pNFC->NFC_IREQ_FLAG1;		
+		pNFC->NFC_PSTART 	= 0;
+		
+		i = 128;
+		do {
+			while (!( pNFC->NFC_CTRL & HwNFC_CTRL_FS_RDY ));
+			
+			if ( bAlignAddr )
+			{
+				pNFC->NFC_LDATA = *pPageDW;++pPageDW;
+			}	
+			else
+			{
+				uDWordByte.BYTE[0] = *pPageB;++pPageB;
+				uDWordByte.BYTE[1] = *pPageB;++pPageB;
+				uDWordByte.BYTE[2] = *pPageB;++pPageB;
+				uDWordByte.BYTE[3] = *pPageB;++pPageB;
+				pNFC->NFC_LDATA	= uDWordByte.DWORD;
+			}
+		}while(--i);
+		
+		while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+
+		//----------------------------------------------
+		//	DMA ACCESS
+		//----------------------------------------------
+		#elif defined( NAND_IO_USE_DMA_ACCESS )
+		if ( nEccOnOff == ECC_ON )
+		{
+			/* Setup ECC Block */
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&pNFC->NFC_LDATA );
+			#endif
+			pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );
+			pECC->ECC_CLEAR	= 0x00000000;
+		}
+
+		if ( j == 0 )
+			memcpy( gpDMA_WorkBuffer1, pDataBuffer, 512 );
+
+		NAND_IO_SetupDMADoubleBuf( NAND_IO_DMA_WRITE, j );
+
+		if ( pNFC->NFC_CTRL1 & Hw31 )
+			BITCLR( pNFC->NFC_CTRL1, Hw31 );
+
+		pNFC->NFC_PSTART	= 0;
+
+		if ( j != (unsigned int)( nWritePPSize - 1 ) ) 
+		{
+			if ( j & 1 )
+				memcpy( gpDMA_WorkBuffer1, (void *)(pDataBuffer + 512), 512 );
+			else
+				memcpy( gpDMA_WorkBuffer0, (void *)(pDataBuffer + 512), 512 );
+		}
+
+		while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+
+		if ( pNFC->NFC_CTRL1 & Hw30 )
+			BITSET( pNFC->NFC_CTRL1, Hw31 );
+	
+		if ( bAlignAddr )
+			pPageDW += 128;
+		else
+			pPageB += 512;
+
+		#endif
+		//####################################################
+		//####################################################
+
+		/*	Load ECC code from ECC block */
+		if ( nEccOnOff == ECC_ON )
+		{
+			if ( ( nDevInfo->Feature.MediaType  & A_BIG ) || (( nDevInfo->Feature.MediaType  & A_SMALL ) && ( nDevInfo->Feature.MediaType  & A_PARALLEL )))
+			{
+				res = NAND_IO_EncodeECC( nDevInfo->EccType, pSpareB );
+			}
+			else
+			{
+				pEccB = (unsigned char*)nECCBuffer;
+				res = NAND_IO_EncodeECC( nDevInfo->EccType, pEccB );
+				memcpy( pSpareB, pEccB, NAND_IO_SPARE_SIZE_SMALL );
+			}
+			
+			if ( res != SUCCESS )
+				goto ErrorWrite512Data;				
+		}
+
+		pSpareB += nDevInfo->EccDataSize;
+	}
+
+	//=========================================================================
+	// Empty PPage Write
+	//=========================================================================
+	if ( ( nStartPPage + nWritePPSize ) != ( nDevInfo->PPages ) )
+	{
+		if ( nDevInfo->Feature.MediaType & A_BIG )
+		{
+			/* Change Cycle */
+			NAND_IO_SetCommCycleTime();
+			
+			//---------------------------------
+			// Random Data Input [ 0x85 ]
+			//---------------------------------
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8585;
+
+			//---------------------------------
+			// Write Column Address
+			//---------------------------------
+			ColumnAddr = nDevInfo->Feature.PageSize;
+			ColumnAddr	= ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT ) ? (ColumnAddr >> 1) : ColumnAddr;
+			NAND_IO_WriteColAddr( ColumnAddr, nDevInfo );
+
+			//---------------------------------
+			// ECC Data Clear
+			//---------------------------------
+			for ( j = 0; j < (U16)( nDevInfo->PPages - ( nStartPPage + nWritePPSize ) ); ++j )
+			{
+				if ( nDevInfo->EccType == MLC_ECC_4BIT_TYPE )
+					pECC_Info = &gMLC_ECC_4Bit;
+				else if ( nDevInfo->EccType == MLC_ECC_8BIT_TYPE )
+					pECC_Info = &gMLC_ECC_8Bit;
+				else if ( nDevInfo->EccType == MLC_ECC_12BIT_TYPE )
+					pECC_Info = &gMLC_ECC_12Bit;
+				else if ( nDevInfo->EccType == MLC_ECC_14BIT_TYPE )
+					pECC_Info = &gMLC_ECC_14Bit;
+				else if ( nDevInfo->EccType == MLC_ECC_16BIT_TYPE )
+					pECC_Info = &gMLC_ECC_16Bit;
+				else
+					return ERR_NAND_IO_WRONG_PARAMETER;
+
+				memcpy(	(void*)pSpareB, (void*)pECC_Info->All_FF_512_ECC_Code, nDevInfo->EccDataSize);
+
+				pSpareB += nDevInfo->EccDataSize;	
+			}
+		}
+		else
+		{
+			memset( nDummyPageBuffer, 0xFF, 512 );
+			//Write Dummy Data
+			for ( j = 0; j < (U16)( nDevInfo->PPages - ( nStartPPage + nWritePPSize ) ); ++j )
+			{
+				//####################################################
+				//#	Write 512 Page Data
+				//####################################################
+				//----------------------------------------------
+				//	MCU ACCESS
+				//----------------------------------------------
+				#if defined( NAND_IO_USE_MCU_ACCESS )
+				/* Setup ECC Block */
+				if ( nEccOnOff == ECC_ON )
+				{
+					#if defined(_WINCE_) || defined(_LINUX_)
+					NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+					#else
+					NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&pNFC->NFC_LDATA );
+					#endif
+					pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );		// Data Size...
+					pECC->ECC_CLEAR	= 0x00000000;
+				}
+
+				/* Write 512 Data Area */
+				BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
+				pNFC->NFC_DSIZE	= 512;
+				pNFC->NFC_IREQ = 0x77;	// pNFC->NFC_IREQ_FLAG1;		
+				pNFC->NFC_PSTART = 0;
+				
+				i = 128;
+				do
+				{
+					while (!( pNFC->NFC_CTRL & HwNFC_CTRL_FS_RDY ));
+					pNFC->NFC_LDATA = 0xFFFFFFFF;
+				}while(--i);
+				
+				while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+				
+				//----------------------------------------------
+				//	DMA ACCESS
+				//----------------------------------------------
+				#elif defined( NAND_IO_USE_DMA_ACCESS )
+				/* Setup ECC Block */
+				if ( nEccOnOff == ECC_ON )
+				{
+					#if defined(_WINCE_) || defined(_LINUX_)
+					NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+					#else
+					NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&pNFC->NFC_LDATA );
+					#endif
+					pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );		// Data Size...
+					pECC->ECC_CLEAR	= 0x00000000;
+				}
+				
+				#if defined(_LINUX_) || defined(_WINCE_)
+				NAND_IO_SetupDMA( (void*)nDummyPageBuffer, 4, 0,
+								  (void*)&NAND_IO_HwLDATA_PA, 0, 0,
+								  NAND_IO_DMA_WRITE, 512 );
+				#else
+				NAND_IO_SetupDMA( (void*)nDummyPageBuffer, 4, 0,
+								  (void*)&pNFC->NFC_LDATA, 0, 0,
+								  NAND_IO_DMA_WRITE, 512 );
+				#endif
+	
+				#endif
+				//####################################################
+				//####################################################
+				/*	Load ECC code from ECC block */
+				if ( nEccOnOff == ECC_ON )
+				{
+					res = NAND_IO_EncodeECC( nDevInfo->EccType, pSpareB );
+					if ( res != SUCCESS )
+						goto ErrorWrite512Data;
+				}
+
+				pSpareB += nDevInfo->EccDataSize;		
+			}			
+		}
+	}
+	
+	//=========================================================================
+	// Write Spare Data
+	//=========================================================================
+	/* Change Cycle */
+	NAND_IO_SetWriteCycleTime();
+
+	NAND_IO_WriteSpareData( nDevInfo, nSpareBuffer, PAGE_ECC_ON );
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+
+ErrorWrite512Data:
+	return res;
+
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      static __inline NAND_IO_ERROR NAND_IO_Write512Data( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nWritePPSize,
+*      													U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			nDevInfo	= 
+*			nEccOnOff	= 
+*			nPageBuffer	= 
+*			nSpareBuffer	= 
+*			nStartPPage	= 
+*			nWritePPSize	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+*  REMARK:	  by nemo
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_Write512Data( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nWritePPSize,
+												    U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff )
+{
+	unsigned int		j;
+	unsigned char		bAlignAddr;
+	#ifdef _LINUX_
+	unsigned char 		nDummyPageBuffer[512]__attribute__((aligned(8)));
+	#else
+	unsigned char 		nDummyPageBuffer[512];
+	#endif
+	unsigned int		ColumnAddr;
+	unsigned char		*pPageB = 0, *pSpareB = 0;
+	unsigned int		*pPageDW = 0;
+	unsigned char		*pDataBuffer;
+	#ifdef NAND_IO_USE_MCU_ACCESS
+	unsigned int		i;
+	DWORD_BYTE			uDWordByte;
+	#endif
+	NAND_IO_ECC_INFO	*pECC_Info;	
+	NAND_IO_ERROR		res;
+
+	if ( ( nStartPPage + nWritePPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	res = (NAND_IO_ERROR)SUCCESS;
+
+	//=========================================================================
+	// Check Align of PageBuffer Address
+	//=========================================================================
+	bAlignAddr		= ( (unsigned int)nPageBuffer & 3 ) ? 0 : 1;
+
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	//=========================================================================
+	// Get Buffer Pointer
+	//=========================================================================
+	/* Adapt type of address */
+	if ( bAlignAddr )
+		pPageDW		= (unsigned int*)nPageBuffer;
+	else
+		pPageB		= (unsigned char*)nPageBuffer;
+
+	// Set SpareBuffer Pointer =>> ECCBuffer
+	if ( ( nDevInfo->Feature.MediaType  & A_BIG ) || (( nDevInfo->Feature.MediaType  & A_SMALL ) && ( nDevInfo->Feature.MediaType  & A_PARALLEL )))
+	{
+		memset( gNAND_IO_ShareEccBuffer, 0xFF, nDevInfo->EccWholeDataSize );		
+		pSpareB		= (unsigned char*)&gNAND_IO_ShareEccBuffer[0];
+	}
+	else
+	{
+		pSpareB		= (unsigned char*)nSpareBuffer;
+		pSpareB 	+= NAND_IO_SPARE_SIZE_SMALL;
+	}
+
+	//=========================================================================
+	// Empty Page ECCBuffer Pointer Increment
+	//=========================================================================
+	for ( j = 0; j < nStartPPage; ++j )
+	{
+		if ( nDevInfo->EccType == MLC_ECC_4BIT_TYPE )
+			pECC_Info = &gMLC_ECC_4Bit;
+		else if ( nDevInfo->EccType == MLC_ECC_8BIT_TYPE )
+			pECC_Info = &gMLC_ECC_8Bit;
+		else if ( nDevInfo->EccType == MLC_ECC_12BIT_TYPE )
+			pECC_Info = &gMLC_ECC_12Bit;
+		else if ( nDevInfo->EccType == MLC_ECC_14BIT_TYPE )
+			pECC_Info = &gMLC_ECC_14Bit;
+		else if ( nDevInfo->EccType == MLC_ECC_16BIT_TYPE )
+			pECC_Info = &gMLC_ECC_16Bit;
+		else
+			return ERR_NAND_IO_WRONG_PARAMETER;
+
+		memcpy(	(void*)pSpareB, (void*)pECC_Info->All_FF_512_ECC_Code, nDevInfo->EccDataSize);
+
+		pSpareB += nDevInfo->EccDataSize;
+	}
+
+	//----------------------------------------------
+	//	Write Data as 512Bytes repeatly
+	//----------------------------------------------
+	for ( j = 0; j < nWritePPSize; ++j )
+	{
+		/* Get Data Buffer */
+		pDataBuffer = ( bAlignAddr ) ? (unsigned char*)pPageDW : (unsigned char*)pPageB;
+
+		//####################################################
+		//#	Write 512 Page Data
+		//####################################################
+		//----------------------------------------------
+		//	MCU ACCESS
+		//----------------------------------------------
+		#if defined( NAND_IO_USE_MCU_ACCESS )
+		if ( nEccOnOff == ECC_ON )
+		{
+			/* Setup ECC Block */
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&pNFC->NFC_LDATA );
+			#endif
+			pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );
+			pECC->ECC_CLEAR	= 0x00000000;
+		}
+
+		/* Write 512 Data Area */
+		BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
+		pNFC->NFC_DSIZE		= 512;
+		pNFC->NFC_IREQ 		= 0x77;	// pNFC->NFC_IREQ_FLAG1;		
+		pNFC->NFC_PSTART 	= 0;
+		
+		i = 128;
+		do {
+			while (!( pNFC->NFC_CTRL & HwNFC_CTRL_FS_RDY ));
+			
+			if ( bAlignAddr )
+			{
+				pNFC->NFC_LDATA = *pPageDW;++pPageDW;
+			}	
+			else
+			{
+				uDWordByte.BYTE[0] = *pPageB;++pPageB;
+				uDWordByte.BYTE[1] = *pPageB;++pPageB;
+				uDWordByte.BYTE[2] = *pPageB;++pPageB;
+				uDWordByte.BYTE[3] = *pPageB;++pPageB;
+				pNFC->NFC_LDATA	= uDWordByte.DWORD;
+			}
+		}while(--i);
+		
+		while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+
+		//----------------------------------------------
+		//	DMA ACCESS
+		//----------------------------------------------
+		#elif defined( NAND_IO_USE_DMA_ACCESS )
+		if ( nEccOnOff == ECC_ON )
+		{
+			/* Setup ECC Block */
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&pNFC->NFC_LDATA );
+			#endif
+			pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );
+			pECC->ECC_CLEAR	= 0x00000000;
+		}
+
+		#if defined(_LINUX_) || defined(_WINCE_)
+		NAND_IO_SetupDMA( (void*)pDataBuffer, 4, 0,
+						  (void*)&NAND_IO_HwLDATA_PA, 0, 0,
+						  NAND_IO_DMA_WRITE, 512 );
+		#else
+		NAND_IO_SetupDMA( (void*)pDataBuffer, 4, 0,
+						  (void*)&pNFC->NFC_LDATA, 0, 0,
+						  NAND_IO_DMA_WRITE, 512 );
+		#endif
+	
+		if ( bAlignAddr )
+			pPageDW += 128;
+		else
+			pPageB += 512;
+
+		#endif
+		//####################################################
+		//####################################################
+
+		/*	Load ECC code from ECC block */
+		if ( nEccOnOff == ECC_ON )
+		{
+			res = NAND_IO_EncodeECC( nDevInfo->EccType, pSpareB );
+			if ( res != SUCCESS )
+				goto ErrorWrite512Data;
+		}
+
+		pSpareB += nDevInfo->EccDataSize;
+	}
+
+	//=========================================================================
+	// Empty PPage Write
+	//=========================================================================
+	if ( ( nStartPPage + nWritePPSize ) != ( nDevInfo->PPages ) )
+	{
+		if ( nDevInfo->Feature.MediaType & A_BIG )
+		{
+			/* Change Cycle */
+			NAND_IO_SetCommCycleTime();
+			
+			//---------------------------------
+			// Random Data Input [ 0x85 ]
+			//---------------------------------
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8585;
+
+			//---------------------------------
+			// Write Column Address
+			//---------------------------------
+			ColumnAddr = nDevInfo->Feature.PageSize;
+			ColumnAddr	= ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT ) ? (ColumnAddr >> 1) : ColumnAddr;
+			NAND_IO_WriteColAddr( ColumnAddr, nDevInfo );
+
+			//---------------------------------
+			// ECC Data Clear
+			//---------------------------------
+			for ( j = 0; j < (U16)( nDevInfo->PPages - ( nStartPPage + nWritePPSize ) ); ++j )
+			{
+				if ( nDevInfo->EccType == MLC_ECC_4BIT_TYPE )
+					pECC_Info = &gMLC_ECC_4Bit;
+				else if ( nDevInfo->EccType == MLC_ECC_8BIT_TYPE )
+					pECC_Info = &gMLC_ECC_8Bit;
+				else if ( nDevInfo->EccType == MLC_ECC_12BIT_TYPE )
+					pECC_Info = &gMLC_ECC_12Bit;
+				else if ( nDevInfo->EccType == MLC_ECC_14BIT_TYPE )
+					pECC_Info = &gMLC_ECC_14Bit;
+				else if ( nDevInfo->EccType == MLC_ECC_16BIT_TYPE )
+					pECC_Info = &gMLC_ECC_16Bit;
+				else
+					return ERR_NAND_IO_WRONG_PARAMETER;
+
+				memcpy(	(void*)pSpareB, (void*)pECC_Info->All_FF_512_ECC_Code, nDevInfo->EccDataSize);
+
+				pSpareB += nDevInfo->EccDataSize;	
+			}
+		}
+		else
+		{
+			memset( nDummyPageBuffer, 0xFF, 512 );
+			//Write Dummy Data
+			for ( j = 0; j < (U16)( nDevInfo->PPages - ( nStartPPage + nWritePPSize ) ); ++j )
+			{
+				//####################################################
+				//#	Write 512 Page Data
+				//####################################################
+				//----------------------------------------------
+				//	MCU ACCESS
+				//----------------------------------------------
+				#if defined( NAND_IO_USE_MCU_ACCESS )
+				/* Setup ECC Block */
+				if ( nEccOnOff == ECC_ON )
+				{
+					#if defined(_WINCE_) || defined(_LINUX_)
+					NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+					#else
+					NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&pNFC->NFC_LDATA );
+					#endif
+					pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );		// Data Size...
+					pECC->ECC_CLEAR	= 0x00000000;
+				}
+
+				/* Write 512 Data Area */
+				BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
+				pNFC->NFC_DSIZE	= 512;
+				pNFC->NFC_IREQ = 0x77;	// pNFC->NFC_IREQ_FLAG1;		
+				pNFC->NFC_PSTART = 0;
+				
+				i = 128;
+				do
+				{
+					while (!( pNFC->NFC_CTRL & HwNFC_CTRL_FS_RDY ));
+					pNFC->NFC_LDATA = 0xFFFFFFFF;
+				}while(--i);
+				
+				while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+				
+				//----------------------------------------------
+				//	DMA ACCESS
+				//----------------------------------------------
+				#elif defined( NAND_IO_USE_DMA_ACCESS )
+				/* Setup ECC Block */
+				if ( nEccOnOff == ECC_ON )
+				{
+					#if defined(_WINCE_) || defined(_LINUX_)
+					NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+					#else
+					NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&pNFC->NFC_LDATA );
+					#endif
+					pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );		// Data Size...
+					pECC->ECC_CLEAR	= 0x00000000;
+				}
+				
+				#if defined(_LINUX_) || defined(_WINCE_)
+				NAND_IO_SetupDMA( (void*)nDummyPageBuffer, 4, 0,
+								  (void*)&NAND_IO_HwLDATA_PA, 0, 0,
+								  NAND_IO_DMA_WRITE, 512 );
+				#else
+				NAND_IO_SetupDMA( (void*)nDummyPageBuffer, 4, 0,
+								  (void*)&pNFC->NFC_LDATA, 0, 0,
+								  NAND_IO_DMA_WRITE, 512 );
+				#endif
+
+				#endif
+				//####################################################
+				//####################################################
+				/*	Load ECC code from ECC block */
+				if ( nEccOnOff == ECC_ON )
+				{
+					res = NAND_IO_EncodeECC( nDevInfo->EccType, pSpareB );
+					if ( res != SUCCESS )
+						goto ErrorWrite512Data;
+				}
+
+				pSpareB += nDevInfo->EccDataSize;		
+			}			
+		}
+	}
+	
+	//=========================================================================
+	// Write Spare Data
+	//=========================================================================
+	/* Change Cycle */
+	NAND_IO_SetWriteCycleTime();
+
+	NAND_IO_WriteSpareData( nDevInfo, nSpareBuffer, PAGE_ECC_ON );
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+
+ErrorWrite512Data:
+	return res;
+
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      static __inline NAND_IO_ERROR NAND_IO_Write512DataMTD( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nWritePPSize,
+*      													U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			nDevInfo	= 
+*			nEccOnOff	= 
+*			nPageBuffer	= 
+*			nSpareBuffer	= 
+*			nStartPPage	= 
+*			nWritePPSize	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+*  REMARK:	  by nemo
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_Write512DataMTD( NAND_IO_DEVINFO *nDevInfo, U16 nStartPPage, U16 nWritePPSize,
+												       U8 *nPageBuffer, U8 *nSpareBuffer, int nEccOnOff )
+{
+	unsigned int		j;
+	unsigned char		bAlignAddr;
+	unsigned int		nECCDataSize = 8;
+	#ifdef _LINUX_
+	unsigned char 		nDummyPageBuffer[512]__attribute__((aligned(8)));
+	#else
+	unsigned char 		nDummyPageBuffer[512];
+	#endif
+	unsigned int		ColumnAddr;
+	unsigned char		*pPageB = 0, *pSpareB = 0;
+	unsigned int		*pPageDW = 0;
+	unsigned char		*pDataBuffer;
+	#ifdef NAND_IO_USE_MCU_ACCESS
+	unsigned int		i;
+	DWORD_BYTE			uDWordByte;
+	#endif
+	NAND_IO_ECC_INFO	*pECC_Info;	
+	NAND_IO_ERROR		res;
+
+	if ( ( nStartPPage + nWritePPSize ) > ( nDevInfo->Feature.PageSize >> 9 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	res = (NAND_IO_ERROR)SUCCESS;
+
+	//=========================================================================
+	// Check Align of PageBuffer Address
+	//=========================================================================
+	bAlignAddr		= ( (unsigned int)nPageBuffer & 3 ) ? 0 : 1;
+
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	if ( nEccOnOff == ECC_ON )
+		NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+
+	//=========================================================================
+	// Get Buffer Pointer
+	//=========================================================================
+	/* Adapt type of address */
+	if ( bAlignAddr )
+		pPageDW		= (unsigned int*)nPageBuffer;
+	else
+		pPageB		= (unsigned char*)nPageBuffer;
+
+	if (( nDevInfo->Feature.MediaType & A_MLC ) ||( nDevInfo->Feature.MediaType & A_SLC ))
+		nECCDataSize = 8;
+	else if ( ( nDevInfo->Feature.MediaType & A_MLC_8BIT ) || ( nDevInfo->Feature.MediaType & A_MLC_12BIT ) )
+		nECCDataSize = 20;
+	
+	// Set SpareBuffer Pointer =>> ECCBuffer
+	if ( ( nDevInfo->Feature.MediaType  & A_BIG ) || (( nDevInfo->Feature.MediaType  & A_SMALL ) && ( nDevInfo->Feature.MediaType  & A_PARALLEL )))
+	{
+		memset( gNAND_IO_ShareEccBuffer, 0xFF, nECCDataSize << 2 );		
+		pSpareB		= (unsigned char*)&gNAND_IO_ShareEccBuffer[0];
+	}
+	else
+	{
+		pSpareB		= (unsigned char*)nSpareBuffer;
+		pSpareB 	+= NAND_IO_SPARE_SIZE_SMALL;
+	}
+
+	//=========================================================================
+	// Empty Page ECCBuffer Pointer Increment
+	//=========================================================================
+	for ( j = 0; j < nStartPPage; ++j )
+	{
+		if ( nDevInfo->EccType == MLC_ECC_4BIT_TYPE )
+			pECC_Info = &gMLC_ECC_4Bit;
+		else if ( nDevInfo->EccType == MLC_ECC_8BIT_TYPE )
+			pECC_Info = &gMLC_ECC_8Bit;
+		else if ( nDevInfo->EccType == MLC_ECC_12BIT_TYPE )
+			pECC_Info = &gMLC_ECC_12Bit;
+		else if ( nDevInfo->EccType == MLC_ECC_14BIT_TYPE )
+			pECC_Info = &gMLC_ECC_14Bit;
+		else if ( nDevInfo->EccType == MLC_ECC_16BIT_TYPE )
+			pECC_Info = &gMLC_ECC_16Bit;
+		else
+			return ERR_NAND_IO_WRONG_PARAMETER;
+
+		memcpy(	(void*)pSpareB, (void*)pECC_Info->All_FF_512_ECC_Code, nECCDataSize);
+
+		pSpareB += nECCDataSize;
+	}
+
+	//----------------------------------------------
+	//	Write Data as 512Bytes repeatly
+	//----------------------------------------------
+	for ( j = 0; j < nWritePPSize; ++j )
+	{
+		/* Get Data Buffer */
+		pDataBuffer = ( bAlignAddr ) ? (unsigned char*)pPageDW : (unsigned char*)pPageB;
+
+		//####################################################
+		//#	Write 512 Page Data
+		//####################################################
+		//----------------------------------------------
+		//	MCU ACCESS
+		//----------------------------------------------
+		#if defined( NAND_IO_USE_MCU_ACCESS )
+		if ( nEccOnOff == ECC_ON )
+		{
+			/* Setup ECC Block */
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&pNFC->NFC_LDATA );
+			#endif
+			pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );
+			pECC->ECC_CLEAR	= 0x00000000;
+		}
+
+		/* Write 512 Data Area */
+		BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
+		pNFC->NFC_DSIZE		= 512;
+		pNFC->NFC_IREQ 		= 0x77;	// pNFC->NFC_IREQ_FLAG1;		
+		pNFC->NFC_PSTART 	= 0;
+		
+		i = 128;
+		do {
+			while (!( pNFC->NFC_CTRL & HwNFC_CTRL_FS_RDY ));
+			
+			if ( bAlignAddr )
+			{
+				pNFC->NFC_LDATA = *pPageDW;++pPageDW;
+			}	
+			else
+			{
+				uDWordByte.BYTE[0] = *pPageB;++pPageB;
+				uDWordByte.BYTE[1] = *pPageB;++pPageB;
+				uDWordByte.BYTE[2] = *pPageB;++pPageB;
+				uDWordByte.BYTE[3] = *pPageB;++pPageB;
+				pNFC->NFC_LDATA	= uDWordByte.DWORD;
+			}
+		}while(--i);
+		
+		while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+
+		//----------------------------------------------
+		//	DMA ACCESS
+		//----------------------------------------------
+		#elif defined( NAND_IO_USE_DMA_ACCESS )
+		if ( nEccOnOff == ECC_ON )
+		{
+			/* Setup ECC Block */
+			#if defined(_WINCE_) || defined(_LINUX_)
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+			#else
+			NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&pNFC->NFC_LDATA );
+			#endif
+			pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );
+			pECC->ECC_CLEAR	= 0x00000000;
+		}
+
+		#if defined(_LINUX_) || defined(_WINCE_)
+		NAND_IO_SetupDMA( (void*)pDataBuffer, 4, 0,
+						  (void*)&NAND_IO_HwLDATA_PA, 0, 0,
+						  NAND_IO_DMA_WRITE, 512 );
+		#else
+		NAND_IO_SetupDMA( (void*)pDataBuffer, 4, 0,
+						  (void*)&pNFC->NFC_LDATA, 0, 0,
+						  NAND_IO_DMA_WRITE, 512 );
+		#endif
+	
+		if ( bAlignAddr )
+			pPageDW += 128;
+		else
+			pPageB += 512;
+
+		#endif
+		//####################################################
+		//####################################################
+
+		/*	Load ECC code from ECC block */
+		if ( nEccOnOff == ECC_ON )
+		{
+			res = NAND_IO_EncodeECC( nDevInfo->EccType, pSpareB );
+			if ( res != SUCCESS )
+				goto ErrorWrite512Data;
+		}
+
+		pSpareB += nECCDataSize;
+	}
+
+	//=========================================================================
+	// Empty PPage Write
+	//=========================================================================
+	if ( ( nStartPPage + nWritePPSize ) != ( nDevInfo->PPages ) )
+	{
+		if ( nDevInfo->Feature.MediaType & A_BIG )
+		{
+			/* Change Cycle */
+			NAND_IO_SetCommCycleTime();
+			
+			//---------------------------------
+			// Random Data Input [ 0x85 ]
+			//---------------------------------
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8585;
+
+			//---------------------------------
+			// Write Column Address
+			//---------------------------------
+			ColumnAddr = nDevInfo->Feature.PageSize;
+			ColumnAddr	= ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT ) ? (ColumnAddr >> 1) : ColumnAddr;
+			NAND_IO_WriteColAddr( ColumnAddr, nDevInfo );
+
+			//---------------------------------
+			// ECC Data Clear
+			//---------------------------------
+			for ( j = 0; j < (U16)( nDevInfo->PPages - ( nStartPPage + nWritePPSize ) ); ++j )
+			{
+				if ( nDevInfo->EccType == MLC_ECC_4BIT_TYPE )
+					pECC_Info = &gMLC_ECC_4Bit;
+				else if ( nDevInfo->EccType == MLC_ECC_8BIT_TYPE )
+					pECC_Info = &gMLC_ECC_8Bit;
+				else if ( nDevInfo->EccType == MLC_ECC_12BIT_TYPE )
+					pECC_Info = &gMLC_ECC_12Bit;
+				else if ( nDevInfo->EccType == MLC_ECC_14BIT_TYPE )
+					pECC_Info = &gMLC_ECC_14Bit;
+				else if ( nDevInfo->EccType == MLC_ECC_16BIT_TYPE )
+					pECC_Info = &gMLC_ECC_16Bit;
+				else
+					return ERR_NAND_IO_WRONG_PARAMETER;
+
+				memcpy(	(void*)pSpareB, (void*)pECC_Info->All_FF_512_ECC_Code, nECCDataSize);
+
+				pSpareB += nECCDataSize;	
+			}
+		}
+		else
+		{
+			memset( nDummyPageBuffer, 0xFF, 512 );
+			//Write Dummy Data
+			for ( j = 0; j < (U16)( nDevInfo->PPages - ( nStartPPage + nWritePPSize ) ); ++j )
+			{
+				//####################################################
+				//#	Write 512 Page Data
+				//####################################################
+				//----------------------------------------------
+				//	MCU ACCESS
+				//----------------------------------------------
+				#if defined( NAND_IO_USE_MCU_ACCESS )
+				/* Setup ECC Block */
+				if ( nEccOnOff == ECC_ON )
+				{
+					#if defined(_WINCE_) || defined(_LINUX_)
+					NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+					#else
+					NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_MCU_ACCESS, (U32)&pNFC->NFC_LDATA );
+					#endif
+					pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );		// Data Size...
+					pECC->ECC_CLEAR	= 0x00000000;
+				}
+
+				/* Write 512 Data Area */
+				BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
+				pNFC->NFC_DSIZE	= 512;
+				pNFC->NFC_IREQ = 0x77;	// pNFC->NFC_IREQ_FLAG1;		
+				pNFC->NFC_PSTART = 0;
+				
+				i = 128;
+				do
+				{
+					while (!( pNFC->NFC_CTRL & HwNFC_CTRL_FS_RDY ));
+					pNFC->NFC_LDATA = 0xFFFFFFFF;
+				}while(--i);
+				
+				while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+				
+				//----------------------------------------------
+				//	DMA ACCESS
+				//----------------------------------------------
+				#elif defined( NAND_IO_USE_DMA_ACCESS )
+				/* Setup ECC Block */
+				if ( nEccOnOff == ECC_ON )
+				{
+					#if defined(_WINCE_) || defined(_LINUX_)
+					NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&NAND_IO_HwLDATA_PA );
+					#else
+					NAND_IO_SetupECC( (U16)nEccOnOff, ECC_ENCODE, nDevInfo->EccType, NAND_DMA_ACCESS, (U32)&pNFC->NFC_LDATA );
+					#endif
+					pECC->ECC_CTRL	|= ( 512 << ECC_SHIFT_DATASIZE );		// Data Size...
+					pECC->ECC_CLEAR	= 0x00000000;
+				}
+				
+				#if defined(_LINUX_) || defined(_WINCE_)
+				NAND_IO_SetupDMA( (void*)nDummyPageBuffer, 4, 0,
+								  (void*)&NAND_IO_HwLDATA_PA, 0, 0,
+								  NAND_IO_DMA_WRITE, 512 );
+				#else
+				NAND_IO_SetupDMA( (void*)nDummyPageBuffer, 4, 0,
+								  (void*)&pNFC->NFC_LDATA, 0, 0,
+								  NAND_IO_DMA_WRITE, 512 );
+				#endif
+
+				#endif
+				//####################################################
+				//####################################################
+				/*	Load ECC code from ECC block */
+				if ( nEccOnOff == ECC_ON )
+				{
+					res = NAND_IO_EncodeECC( nDevInfo->EccType, pSpareB );
+					if ( res != SUCCESS )
+						goto ErrorWrite512Data;
+				}
+
+				pSpareB += nECCDataSize;		
+			}			
+		}
+	}
+	
+	//=========================================================================
+	// Write Spare Data
+	//=========================================================================
+	/* Change Cycle */
+	NAND_IO_SetWriteCycleTime();
+
+	NAND_IO_WriteSpareDataMTD( nDevInfo, nSpareBuffer, PAGE_ECC_ON );
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+
+ErrorWrite512Data:
+	return res;
+
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_WriteUserSizeData( NAND_IO_DEVINFO *nDevInfo, U16 nColumnAddr, U32 nWriteSize, U8 *nWriteBuffer );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nColumnAddr	= 
+*			nDevInfo	= 
+*			nWriteBuffer	= 
+*			nWriteSize	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_WriteUserSizeData( NAND_IO_DEVINFO *nDevInfo, U16 nColumnAddr, U32 nWriteSize, U8 *nWriteBuffer )
+{
+	unsigned int		*dwPageB;
+	unsigned char		*pPageB;
+	DWORD_BYTE			uDWordByte;
+	
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	NAND_IO_SetupECC( ECC_OFF, 0, 0, 0, 0 );
+	
+	//=========================================================================
+	// Check Parameter
+	//=========================================================================
+	if ( (U32)( nColumnAddr + nWriteSize ) > (U32)( nDevInfo->Feature.PageSize + nDevInfo->Feature.SpareSize ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================	
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//=========================================================================
+	// Write UserSize Data
+	//=========================================================================
+	pPageB = (unsigned char*)nWriteBuffer;
+	dwPageB = (unsigned int*)nWriteBuffer;
+
+	if ( nWriteSize >= 4 )
+	{
+		#ifdef USE_NFC_LDATA		/* 08.12.17 */
+		BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
+		pNFC->NFC_DSIZE		= nWriteSize;
+		pNFC->NFC_IREQ	 	= 0x77;	// pNFC->NFC_IREQ_FLAG1;
+		pNFC->NFC_PSTART 	= 0;		
+
+		do {
+			while (!( pNFC->NFC_IREQ & HwNFC_CTRL_FS_RDY ));
+			
+			{
+				uDWordByte.BYTE[0] = *pPageB;++pPageB;
+				uDWordByte.BYTE[1] = *pPageB;++pPageB;
+				uDWordByte.BYTE[2] = *pPageB;++pPageB;
+				uDWordByte.BYTE[3] = *pPageB;++pPageB;
+				pNFC->NFC_LDATA	= uDWordByte.DWORD;
+			}
+			nWriteSize -= 4;
+		}while(nWriteSize);
+		
+		while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));		
+	}
+	else
+	{
+		#endif
+		while ( nWriteSize )
+		{
+			/* Write as DWORD */
+			if ( nWriteSize >= 4 )
+			{
+				uDWordByte.BYTE[0] = *pPageB;++pPageB;
+				uDWordByte.BYTE[1] = *pPageB;++pPageB;
+				uDWordByte.BYTE[2] = *pPageB;++pPageB;
+				uDWordByte.BYTE[3] = *pPageB;++pPageB;
+				WORD_OF(pNFC->NFC_WDATA) = uDWordByte.DWORD;
+				nWriteSize -= 4;
+			}
+			/* Write as WORD */
+			else if ( nWriteSize >= 2 )
+			{
+				uDWordByte.BYTE[0] = *pPageB;++pPageB;
+				uDWordByte.BYTE[1] = *pPageB;++pPageB;
+				HWORD_OF(pNFC->NFC_WDATA) = uDWordByte.WORD[0];
+				nWriteSize -= 2;
+			}
+			/* Write as BYTE */			
+			else
+			{
+				uDWordByte.BYTE[0] = *pPageB;++pPageB;
+				BYTE_OF(pNFC->NFC_WDATA) = uDWordByte.BYTE[0];
+				nWriteSize -= 1;
+			}
+		}
+	}
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+	return (NAND_IO_ERROR)SUCCESS;
+
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*      static __inline NAND_IO_ERROR NAND_IO_GetShiftValueForFastMultiPly( U16 nValue, U16* rFactor );
+*  
+*  DESCRIPTION : 
+*  INPUT:
+*			nValue	= 
+*			rFactor	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  REMARK  :	
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_GetShiftValueForFastMultiPly( U16 nValue, U16* rFactor )
+{
+	unsigned short int	i;
+
+	*rFactor = 0;
+	
+	for ( i = 0; i < NAND_IO_MAX_SHIFT_FACTOR_FOR_MULTIPLY; ++i )
+	{
+		if ( NAND_IO_ShiftFactorForMultiplay[i] == nValue )
+		{
+			*rFactor = i;
+			break;
+		}
+	}
+
+	if ( i >= NAND_IO_MAX_SHIFT_FACTOR_FOR_MULTIPLY )
+		return ERR_NAND_IO_FAILED_GET_SHIFT_FACTOR_FOR_MULTIPLY;
+
+	return (NAND_IO_ERROR)SUCCESS;	
+}	
+
+#if defined (NAND_LBA_INCLUDE)
+NAND_IO_ERROR NAND_IO_LBA_SetCallBackHandler( NAND_LBA_CALLBACK_HANDLER pCallBackHandler )
+{
+	NAND_IO_LBA_CallBackLcdDisplay = pCallBackHandler;
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_GetDeviceInfo( NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned short int		j,k,l;
+	unsigned char			bFindMedia;
+	unsigned char			bFindMakerNo;
+	unsigned char			bMatchCount;
+	unsigned char			rBootMode, rRebootCmd;
+	NAND_IO_DEVID			sDeviceCode;
+	NAND_IO_FEATURE			*sTempFeatureInfo;
+	NAND_IO_FEATURE			*sFindFeatureInfo;
+	NAND_IO_ERROR			res;
+
+	bFindMedia 				= FALSE;
+	sTempFeatureInfo		= (NAND_IO_FEATURE*)LBA_NAND_SupportMakerInfo.DevInfo[0];
+	sFindFeatureInfo		= (NAND_IO_FEATURE*)LBA_NAND_SupportMakerInfo.DevInfo[0];
+
+	NAND_IO_LBA_DeviceReboot( nDevInfo );
+ 	res = NAND_IO_GetDeviceInfo( 0, nDevInfo );
+	if ( res != SUCCESS )
+		return ERR_NAND_IO_FAILED_GET_DEVICE_INFO;
+
+	if (!( nDevInfo->Feature.MediaType & S_LBA ))
+		return ERR_NAND_IO_FAILED_GET_DEVICE_INFO;
+
+	res = NAND_IO_LBA_ModeChange( nDevInfo, NAND_LBA_BCM );
+	if ( res != SUCCESS )
+	{
+		NAND_IO_LBA_DeviceReboot( nDevInfo );
+		res = NAND_IO_LBA_ModeChange( nDevInfo, NAND_LBA_BCM );
+		if ( res != SUCCESS )
+			return res;
+	}
+	
+	NAND_IO_LBA_GetPersistentFunction( nDevInfo, &rBootMode, &rRebootCmd );
+
+	if ( ( rBootMode != 0x22 ) || ( rRebootCmd != 0xAF ))
+	{
+		rBootMode = 0x22;
+		rRebootCmd = 0xAF;
+
+		NAND_IO_LBA_SetBootModeChange( nDevInfo, rBootMode );
+		NAND_IO_LBA_SetRebootCmdChange( nDevInfo, rRebootCmd );		
+		NAND_IO_LBA_DeviceReboot( nDevInfo );
+	}
+
+	NAND_IO_LBA_ModeChange( nDevInfo, NAND_LBA_MDP );
+	NAND_IO_LBA_SetTransferProtocol( nDevInfo, 0x04, 0x00 );
+	
+	nDevInfo->LBAInfo.Usable = DISABLE;
+	//=====================================================================
+	// Search Matched NANDFLASH
+	//=====================================================================
+	for ( j = 0; j < 3; ++j )	/* Check Read ID during 3 turn */
+	{
+		/* Read Device CODE */
+		NAND_IO_LBA_ReadID( nDevInfo, &sDeviceCode);
+
+		/* Check Maker ID */
+		bFindMakerNo = 0xFF;
+		for ( k = 0; k < MAX_SUPPORT_MAKER_LBA_NAND; ++k )
+		{
+			if ( sDeviceCode.Code[0] == LBA_NAND_SupportMakerInfo.MakerID[k] )
+			{
+				bFindMakerNo		= (unsigned char)k;
+				sTempFeatureInfo	= (NAND_IO_FEATURE*)LBA_NAND_SupportMakerInfo.DevInfo[k];
+				break;
+			}
+		}
+
+		if ( bFindMakerNo >= MAX_SUPPORT_MAKER_NAND )
+			continue;
+
+		/* Check Device ID */
+		for ( k = 0; k < LBA_NAND_SupportMakerInfo.MaxSupportNAND[bFindMakerNo]; ++k )
+		{
+			bMatchCount = 0;
+			
+			for ( l = 0; l < 4; ++l )
+			{
+				if ( sTempFeatureInfo->DeviceID.Code[l+1] == 0x00 )
+					++bMatchCount;
+				else if ( sDeviceCode.Code[l+1] == sTempFeatureInfo->DeviceID.Code[l+1] )
+					++bMatchCount;
+			}
+
+			/* Found NAND Device */
+			if ( bMatchCount >= 4 )
+			{
+				bFindMedia = TRUE;
+				sFindFeatureInfo = sTempFeatureInfo;
+				break;
+			}
+			else
+				++sTempFeatureInfo;
+		}
+
+		/* Found NAND Device */
+		if ( bFindMedia == TRUE )
+			break;
+	}
+
+	if ( bFindMedia == TRUE )
+		return (NAND_IO_ERROR)SUCCESS;
+	//=====================================================================
+	// Not Found
+	//=====================================================================
+	else
+		return ERR_NAND_IO_FAILED_GET_DEVICE_INFO;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_Init( NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned short int		j,k,l;
+	unsigned char			bFindMedia;
+	unsigned char			bFindMakerNo;
+	unsigned char			bMatchCount;
+	unsigned char			rBootMode, rRebootCmd;
+	NAND_IO_DEVID			sDeviceCode;
+	NAND_IO_FEATURE			*sTempFeatureInfo;
+	NAND_IO_FEATURE			*sFindFeatureInfo;
+	NAND_IO_ERROR			res;
+	
+	bFindMedia 				= FALSE;
+	sTempFeatureInfo		= (NAND_IO_FEATURE*)LBA_NAND_SupportMakerInfo.DevInfo[0];
+	sFindFeatureInfo		= (NAND_IO_FEATURE*)LBA_NAND_SupportMakerInfo.DevInfo[0];
+
+	NAND_IO_LBA_DeviceReboot( nDevInfo );
+ 	NAND_IO_GetDeviceInfo( 0, nDevInfo );
+
+	res = NAND_IO_LBA_ModeChange( nDevInfo, NAND_LBA_BCM );
+	if ( res != SUCCESS )
+	{
+		NAND_IO_LBA_DeviceReboot( nDevInfo );
+		res = NAND_IO_LBA_ModeChange( nDevInfo, NAND_LBA_BCM );
+		if ( res != SUCCESS )
+			return res;
+	}
+	
+	NAND_IO_LBA_GetPersistentFunction( nDevInfo, &rBootMode, &rRebootCmd );
+
+	if ( ( rBootMode != 0x22 ) || ( rRebootCmd != 0xAF ))
+	{
+		rBootMode = 0x22;
+		rRebootCmd = 0xAF;
+
+		NAND_IO_LBA_SetBootModeChange( nDevInfo, rBootMode );
+		NAND_IO_LBA_SetRebootCmdChange( nDevInfo, rRebootCmd );		
+		NAND_IO_LBA_DeviceReboot( nDevInfo );
+	}
+
+	NAND_IO_LBA_ModeChange( nDevInfo, NAND_LBA_MDP );
+	NAND_IO_LBA_SetTransferProtocol( nDevInfo, 0x04, 0x00 );
+	
+	nDevInfo->LBAInfo.Usable = DISABLE;
+	//=====================================================================
+	// Search Matched NANDFLASH
+	//=====================================================================
+	for ( j = 0; j < 3; ++j )	/* Check Read ID during 3 turn */
+	{
+		/* Read Device CODE */
+		NAND_IO_LBA_ReadID( nDevInfo, &sDeviceCode);
+
+		/* Check Maker ID */
+		bFindMakerNo = 0xFF;
+		for ( k = 0; k < MAX_SUPPORT_MAKER_LBA_NAND; ++k )
+		{
+			if ( sDeviceCode.Code[0] == LBA_NAND_SupportMakerInfo.MakerID[k] )
+			{
+				bFindMakerNo		= (unsigned char)k;
+				sTempFeatureInfo	= (NAND_IO_FEATURE*)LBA_NAND_SupportMakerInfo.DevInfo[k];
+				break;
+			}
+		}
+
+		if ( bFindMakerNo >= MAX_SUPPORT_MAKER_NAND )
+			continue;
+
+		/* Check Device ID */
+		for ( k = 0; k < LBA_NAND_SupportMakerInfo.MaxSupportNAND[bFindMakerNo]; ++k )
+		{
+			bMatchCount = 0;
+			
+			for ( l = 0; l < 4; ++l )
+			{
+				if ( sTempFeatureInfo->DeviceID.Code[l+1] == 0x00 )
+					++bMatchCount;
+				else if ( sDeviceCode.Code[l+1] == sTempFeatureInfo->DeviceID.Code[l+1] )
+					++bMatchCount;
+			}
+
+			/* Found NAND Device */
+			if ( bMatchCount >= 4 )
+			{
+				bFindMedia = TRUE;
+				sFindFeatureInfo = sTempFeatureInfo;
+				break;
+			}
+			else
+				++sTempFeatureInfo;
+		}
+
+		/* Found NAND Device */
+		if ( bFindMedia == TRUE )
+			break;
+	}
+
+	if ( bFindMedia == TRUE )
+	{
+		// Get Protocol
+		NAND_IO_LBA_GetTransferProtocol( nDevInfo, &nDevInfo->LBAInfo.TransProtocol1, &nDevInfo->LBAInfo.TransProtocol2 );
+
+		// Data Format
+		if ( nDevInfo->LBAInfo.TransProtocol1 & NAND_PROT1_SPARE_INCLUDE )
+			nDevInfo->LBAInfo.DataTransferCheck = ENABLE;
+		else
+			nDevInfo->LBAInfo.DataTransferCheck = DISABLE;
+
+		// Sector Count
+		nDevInfo->LBAInfo.SectorCount = ( nDevInfo->LBAInfo.TransProtocol1 & NAND_PROT1_SECTOR_COUNT_MASK );
+
+		if ( nDevInfo->LBAInfo.SectorCount != 1 )
+			nDevInfo->LBAInfo.SectorCount = nDevInfo->LBAInfo.SectorCount << 1;
+		
+		// Set Power Save Mode
+		NAND_IO_LBA_PowerSaveMode( nDevInfo, DISABLE );
+
+		// Set High Speed Mode
+		NAND_IO_LBA_HighSpeedMode( nDevInfo, ENABLE );
+
+		NAND_IO_LBA_VFPGetTotalSectorSize( nDevInfo, (U32 *)&nDevInfo->LBAInfo.VFPSectorSize );
+		if ( ( nDevInfo->LBAInfo.VFPSectorSize << 9 ) < gMAX_ROMSIZE )
+		{
+			// LBA Factory Setting values : 8 Mbyte
+			res = NAND_IO_LBA_VFPChangeSectorSize( nDevInfo, gMAX_ROMSIZE >> 9 );
+			if ( res != SUCCESS )
+				return res;
+
+			NAND_IO_LBA_VFPGetTotalSectorSize( nDevInfo, (U32 *)&nDevInfo->LBAInfo.VFPSectorSize );		
+		}
+
+		// Get Size Info
+		NAND_IO_LBA_MDPGetTotalSectorSize( nDevInfo, (unsigned long int *)&nDevInfo->LBAInfo.MDPSectorSize );
+
+		res = NAND_IO_LBA_VFPInitArea( nDevInfo );
+		if ( res != SUCCESS )
+			return res;
+
+		nDevInfo->LBAInfo.Usable = ENABLE;		
+	}
+	//=====================================================================
+	// Not Found
+	//=====================================================================
+	else
+	{
+		return ERR_NAND_IO_FAILED_GET_DEVICE_INFO;
+	}
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+U32 NAND_IO_LBA_GetSerialNumber( NAND_IO_DEVINFO *nDevInfo, U8* nPageBuffer, U8* rSerialNumber, U16 nSize )
+{
+	unsigned int		j;
+	unsigned int		dwIDSize;
+	unsigned char		ucTempData[64];
+	unsigned char		*cPageBuffer;
+	unsigned char		*cSpareBuffer;
+	NAND_IO_ERROR		res;
+
+	cPageBuffer		= &nPageBuffer[0];
+	cSpareBuffer	= &nPageBuffer[nDevInfo->Feature.PageSize];
+	nSize = 0;
+
+	NAND_IO_LBA_ModeChange( nDevInfo, NAND_LBA_BCM );
+
+	res = NAND_IO_ReadGoldenPage( nDevInfo, 0, cPageBuffer, cSpareBuffer );
+	if ( res != SUCCESS)
+		return ERR_NAND_IO_WRONG_PARAMETER;
+	
+	memcpy( ucTempData, &nPageBuffer[ ( 512 + 16 ) * ( nDevInfo->PPages - 1 ) ], 64 );
+
+	dwIDSize = 32;
+	
+	for ( j = 0; j < dwIDSize; ++j )
+		rSerialNumber[j] = ucTempData[j];
+
+	return dwIDSize;	
+}
+
+NAND_IO_ERROR NAND_IO_LBA_GetTotalSecAndCHS( NAND_IO_DEVINFO *nDevInfo, int nPartition, U32 *rTotalSec, U16 *rCylinder, U16 *rHead, U8 *rSector )
+{
+	unsigned long int		nTotalSectorSize;
+	unsigned short int		wCurrHead;
+	unsigned short int		wCurrCylinder;
+
+	if ( nPartition == NAND_LBA_DATA_AREA )
+		nTotalSectorSize = nDevInfo->LBAInfo.DTAreaSectorSize;
+	else if ( nPartition == NAND_LBA_HIDDEN_AREA )
+		nTotalSectorSize = nDevInfo->LBAInfo.HDAreaSectorSize;
+	else if ( nPartition == NAND_LBA_MDP )
+		nTotalSectorSize = nDevInfo->LBAInfo.MDPSectorSize;
+	else if ( nPartition == NAND_LBA_VFP )
+		nTotalSectorSize = nDevInfo->LBAInfo.VFPSectorSize;
+	else
+		nTotalSectorSize = 0;
+
+	if ( nTotalSectorSize == 0 )
+	{
+	    *rTotalSec	= 0;
+	    *rCylinder	= 0;
+	    *rHead		= 0;
+	    *rSector	= 0;
+		
+		return (NAND_IO_ERROR)SUCCESS;
+	}
+		
+	if  ( nTotalSectorSize >= (U32)( 1024 * 256 * 64 ) )
+	{
+	    *rTotalSec	= nTotalSectorSize;
+	    *rCylinder	= (U16)(nTotalSectorSize / ( 256 * 64 ));
+	    *rHead		= 256;
+	    *rSector	= 64;
+	}
+	else
+	{
+		for ( wCurrHead = 2; wCurrHead <= 256; wCurrHead *= 2 )
+		{
+			wCurrCylinder = (U16)(nTotalSectorSize / ( wCurrHead * 64 ));
+
+			if ( wCurrCylinder > 1024 )
+				continue;
+
+			*rTotalSec	= (U32)( wCurrCylinder * wCurrHead * 64 );
+			*rCylinder	= wCurrCylinder;
+			*rHead		= wCurrHead;
+			*rSector	= 64;
+
+			break;
+		}
+	}
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_ReadSectorBy4Byte( NAND_IO_DEVINFO *nDevInfo, U8 nPartition, U32 nSectorAddr, U16 nOffset, U16 nReadSize, U8 *nReadBuffer )
+{
+	unsigned short int		wCurrPPSize;
+	unsigned short int		wFlagFirstSector;
+	unsigned long int 		dwSectorAddr;
+	unsigned long int		dwTotalReadSecSize;
+	unsigned long int		nTotalSectorSize;
+	unsigned long int		dwSectorAddrOffSet;
+	unsigned char			cReadBuffer[512];
+	unsigned char			cSpareBuffer[16];
+	unsigned char			*pReadBuffer;
+	unsigned char			cPartition;	
+	NAND_IO_ERROR			res;
+
+	//######################################################
+	//# Check Parameter
+	//######################################################
+	if ( nDevInfo->LBAInfo.Usable != ENABLE )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	cPartition = nPartition & 0x0F;
+
+	if ( nDevInfo->LBAInfo.CurrentMode != cPartition )
+		NAND_IO_LBA_ModeChange( nDevInfo, cPartition );
+	
+	if ( nPartition == NAND_LBA_DATA_AREA )
+	{
+		nTotalSectorSize 	= nDevInfo->LBAInfo.DTAreaSectorSize;
+		dwSectorAddrOffSet 	= 0;		
+	}
+	else if ( nPartition == NAND_LBA_HIDDEN_AREA )
+	{
+		nTotalSectorSize = nDevInfo->LBAInfo.HDAreaSectorSize;
+		dwSectorAddrOffSet 	= nDevInfo->LBAInfo.HDAreaAddrOffSet;
+	}
+	else if ( nPartition == NAND_LBA_MULTI_HIDDEN_AREA_0 )
+	{
+		nTotalSectorSize 	= nDevInfo->LBAInfo.MHDAreaSectorSize[0];
+		dwSectorAddrOffSet 	= nDevInfo->LBAInfo.MHDAreaAddrOffSet[0];
+	}	
+	else if ( nPartition == NAND_LBA_MDP )
+	{
+		nTotalSectorSize = nDevInfo->LBAInfo.MDPSectorSize;
+		dwSectorAddrOffSet 	= 0;
+	}
+	else if ( nPartition == NAND_LBA_VFP )
+	{
+		nTotalSectorSize = nDevInfo->LBAInfo.VFPSectorSize;
+		dwSectorAddrOffSet 	= 1;
+	}
+	else
+	{
+		nTotalSectorSize = 0;
+		dwSectorAddrOffSet 	= 0;
+		return ERR_NAND_IO_WRONG_PARAMETER;
+	}
+	
+	if ( ( nSectorAddr + 1 ) > nTotalSectorSize )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	if (( !nReadSize ) || (( nOffset + nReadSize ) > 128 ))
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	pReadBuffer			= nReadBuffer;
+
+	wFlagFirstSector = TRUE;
+	
+	/* Pre Process */
+	NAND_IO_PreProcess();
+	
+	/* Set Setuo Time and Hold Time */
+	NAND_IO_SetCommCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	//NAND_IO_DisableWriteProtect();
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//######################################################
+	//# Get Info of Parameter
+	//######################################################
+	dwSectorAddr		= nSectorAddr;
+	dwSectorAddr		+= dwSectorAddrOffSet;	
+	dwTotalReadSecSize  = 1;
+
+	if ( dwTotalReadSecSize < nDevInfo->LBAInfo.SectorCount )
+		wCurrPPSize = (U16)dwTotalReadSecSize;
+	else
+		wCurrPPSize = nDevInfo->LBAInfo.SectorCount ;
+	
+	//######################################################
+	//# Write Total Sector
+	//######################################################
+
+	while ( dwTotalReadSecSize )
+	{	
+		/* Command Page Program #1 [ 0x80 ] */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+
+		if ( wFlagFirstSector == TRUE )
+		{
+			/* Write Sector Size & Sector Address */
+			pNFC->NFC_SADDR= ( 1 & 0xFF );					// Write Sector Num : SC0
+			pNFC->NFC_SADDR= ( ( 1 >> 8 ) & 0xFF );			// Write Sector Num : SC1
+			pNFC->NFC_SADDR= ( dwSectorAddr & 0xFF );				// Write Sector Addr: AD0
+			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 8 ) & 0xFF );		// Write Sector Addr: AD1
+			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 16 ) & 0xFF );		// Write Sector Addr: AD2
+		}
+
+		/* Command Page Program #2 [ 0x10 ] */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+		
+		/* Wait until it is ready */
+		NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+		NAND_IO_SetReadCycleTime();
+		/* Write Data to NAND FLASH */
+		res = NAND_IO_LBA_ReadData( nDevInfo, wCurrPPSize, cReadBuffer, cSpareBuffer );
+		if ( res != SUCCESS )
+			return res;
+
+		NAND_IO_SetCommCycleTime();
+
+		/* Decrease Write Size */
+		dwTotalReadSecSize 	-= wCurrPPSize;
+
+		/* Increase Buffer Address */
+		nReadBuffer			+= ( nDevInfo->LBAInfo.SectorCount << 9 );
+		
+		/* Count Next Page Size */
+		if ( dwTotalReadSecSize < nDevInfo->LBAInfo.SectorCount )
+			wCurrPPSize = (U16)dwTotalReadSecSize;
+		else
+			wCurrPPSize = nDevInfo->LBAInfo.SectorCount;
+
+		if ( nDevInfo->LBAInfo.TransProtocol2 & NAND_PROT2_WRITE_TYPE_B )
+			wFlagFirstSector = FALSE;
+	}
+
+	memcpy( pReadBuffer, &cReadBuffer[nOffset << 2], nReadSize << 2 );
+
+	/* FORCE TO SET WP LOW */
+	//NAND_IO_EnableWriteProtect();
+	
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+	
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_ReadSector( NAND_IO_DEVINFO *nDevInfo, U8 nPartition, U32 nSectorAddr, U16 nSecSize, U8 *nReadBuffer )
+{
+	unsigned short int		wCurrPPSize;
+	unsigned short int		wFlagFirstSector;
+	unsigned long int 		dwSectorAddr;
+	unsigned long int		dwSectorAddrOffSet;
+	unsigned long int		dwTotalReadSecSize;
+	unsigned long int		nTotalSectorSize;
+	unsigned char			cPartition;
+	unsigned char			cSpareBuffer[16];
+	NAND_IO_ERROR			res;
+
+	//######################################################
+	//# Check Parameter
+	//######################################################
+	if ( nDevInfo->LBAInfo.Usable != ENABLE )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	cPartition = nPartition & 0x0F;
+
+	if ( nDevInfo->LBAInfo.CurrentMode != cPartition )
+		NAND_IO_LBA_ModeChange( nDevInfo, cPartition );
+	
+	if ( nPartition == NAND_LBA_DATA_AREA )
+	{
+		nTotalSectorSize 	= nDevInfo->LBAInfo.DTAreaSectorSize;
+		dwSectorAddrOffSet 	= 0;		
+	}
+	else if ( nPartition == NAND_LBA_HIDDEN_AREA )
+	{
+		nTotalSectorSize = nDevInfo->LBAInfo.HDAreaSectorSize;
+		dwSectorAddrOffSet 	= nDevInfo->LBAInfo.HDAreaAddrOffSet;
+	}
+	else if ( nPartition == NAND_LBA_MULTI_HIDDEN_AREA_0 )
+	{
+		nTotalSectorSize 	= nDevInfo->LBAInfo.MHDAreaSectorSize[0];
+		dwSectorAddrOffSet 	= nDevInfo->LBAInfo.MHDAreaAddrOffSet[0];
+	}	
+	else if ( nPartition == NAND_LBA_MDP )
+	{
+		nTotalSectorSize = nDevInfo->LBAInfo.MDPSectorSize;
+		dwSectorAddrOffSet 	= 0;
+	}
+	else if ( nPartition == NAND_LBA_VFP )
+	{
+		nTotalSectorSize = nDevInfo->LBAInfo.VFPSectorSize;
+		dwSectorAddrOffSet 	= 1;
+	}
+	else
+	{
+		nTotalSectorSize = 0;
+		dwSectorAddrOffSet 	= 0;
+		return ERR_NAND_IO_WRONG_PARAMETER;
+	}
+	
+	if ( ( nSectorAddr + nSecSize ) > nTotalSectorSize )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	wFlagFirstSector = TRUE;
+	
+	/* Pre Process */
+	NAND_IO_PreProcess();
+	
+	/* Set Setuo Time and Hold Time */
+	NAND_IO_SetCommCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	//NAND_IO_DisableWriteProtect();
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//######################################################
+	//# Get Info of Parameter
+	//######################################################
+	dwSectorAddr		= nSectorAddr;
+	dwSectorAddr		+= dwSectorAddrOffSet;
+	dwTotalReadSecSize  = nSecSize;
+
+	if ( dwTotalReadSecSize < nDevInfo->LBAInfo.SectorCount )
+		wCurrPPSize = (U16)dwTotalReadSecSize;
+	else
+		wCurrPPSize = nDevInfo->LBAInfo.SectorCount ;
+	
+	//######################################################
+	//# Write Total Sector
+	//######################################################
+
+	while ( dwTotalReadSecSize )
+	{	
+		/* Command Page Program #1 [ 0x80 ] */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+
+		if ( wFlagFirstSector == TRUE )
+		{
+			/* Write Sector Size & Sector Address */
+			pNFC->NFC_SADDR= ( nSecSize & 0xFF );					// Write Sector Num : SC0
+			pNFC->NFC_SADDR= ( ( nSecSize >> 8 ) & 0xFF );			// Write Sector Num : SC1
+			pNFC->NFC_SADDR= ( dwSectorAddr & 0xFF );				// Write Sector Addr: AD0
+			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 8 ) & 0xFF );		// Write Sector Addr: AD1
+			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 16 ) & 0xFF );		// Write Sector Addr: AD2
+		}
+
+		/* Command Page Program #2 [ 0x10 ] */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+		
+		/* Wait until it is ready */
+		NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+		NAND_IO_SetReadCycleTime();
+		/* Write Data to NAND FLASH */
+		res = NAND_IO_LBA_ReadData( nDevInfo, wCurrPPSize, nReadBuffer, cSpareBuffer );
+		if ( res != SUCCESS )
+			return res;
+
+		NAND_IO_SetCommCycleTime();
+
+		/* Decrease Write Size */
+		dwTotalReadSecSize 	-= wCurrPPSize;
+
+		/* Increase Buffer Address */
+		nReadBuffer			+= ( nDevInfo->LBAInfo.SectorCount << 9 );
+		
+		/* Count Next Page Size */
+		if ( dwTotalReadSecSize < nDevInfo->LBAInfo.SectorCount )
+			wCurrPPSize = (U16)dwTotalReadSecSize;
+		else
+			wCurrPPSize = nDevInfo->LBAInfo.SectorCount;
+
+		if ( nDevInfo->LBAInfo.TransProtocol2 & NAND_PROT2_WRITE_TYPE_B )
+			wFlagFirstSector = FALSE;
+	}
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0xFBFB;
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	/* FORCE TO SET WP LOW */
+	//NAND_IO_EnableWriteProtect();
+
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_AREAClear( NAND_IO_DEVINFO *nDevInfo, U8 nPartition )
+{
+	unsigned int			nSectorAddr;
+	unsigned short int		wCurrPPSize;
+	unsigned short int		wFlagFirstSector;
+
+	unsigned short int		wOldProcessRate;		
+	unsigned short int		wProcessRate;
+	unsigned long int		nProCessWriteSectorSize;
+
+	unsigned long int 		dwSectorAddr;
+	unsigned long int		dwSectorAddrOffSet;
+	unsigned short int		wOnceWriteSectorCount;
+	unsigned long int		dwTotalWriteSecSize;
+	unsigned long int		nTotalSectorSize;
+	unsigned long int		nWriteSectorSize;
+	unsigned char			cPartition;
+	NAND_IO_ERROR			res;
+
+	//######################################################
+	//# Check Parameter
+	//######################################################
+	if ( nDevInfo->LBAInfo.Usable != ENABLE )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	cPartition = nPartition & 0x0F;
+
+	if ( nDevInfo->LBAInfo.CurrentMode != cPartition )
+		NAND_IO_LBA_ModeChange( nDevInfo, cPartition );
+
+	if ( nPartition == NAND_LBA_DATA_AREA )
+	{
+		nTotalSectorSize 	= nDevInfo->LBAInfo.DTAreaSectorSize;
+		dwSectorAddrOffSet 	= 0;
+	}
+	else if ( nPartition == NAND_LBA_HIDDEN_AREA )
+	{
+		nTotalSectorSize 	= nDevInfo->LBAInfo.HDAreaSectorSize;
+		dwSectorAddrOffSet 	= nDevInfo->LBAInfo.HDAreaAddrOffSet;
+	}
+	else if ( nPartition == NAND_LBA_MULTI_HIDDEN_AREA_0 )
+	{
+		nTotalSectorSize 	= nDevInfo->LBAInfo.MHDAreaSectorSize[0];
+		dwSectorAddrOffSet 	= nDevInfo->LBAInfo.MHDAreaAddrOffSet[0];
+	}
+	else if ( nPartition == NAND_LBA_MDP )
+	{
+		nTotalSectorSize 	= nDevInfo->LBAInfo.MDPSectorSize;
+		dwSectorAddrOffSet 	= 0;
+	}
+	else if ( nPartition == NAND_LBA_VFP )
+	{
+		nTotalSectorSize 	= nDevInfo->LBAInfo.VFPSectorSize;
+		dwSectorAddrOffSet 	= 1;
+	}
+	else
+	{
+		nTotalSectorSize 	= 0;
+		dwSectorAddrOffSet 	= 0;
+		return ERR_NAND_IO_WRONG_PARAMETER;
+	}
+
+	// Set Area Clear Sector Address, Size
+	nSectorAddr = 0;
+
+	wFlagFirstSector = TRUE;
+	
+	/* Pre Process */
+	NAND_IO_PreProcess();
+	
+	/* Set Setuo Time and Hold Time */
+	NAND_IO_SetCommCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	//NAND_IO_DisableWriteProtect();
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//######################################################
+	//# Get Info of Parameter
+	//######################################################
+	dwSectorAddr		= nSectorAddr;
+	dwSectorAddr 		+= dwSectorAddrOffSet;
+	dwTotalWriteSecSize = nTotalSectorSize;
+
+	if ( dwTotalWriteSecSize < nDevInfo->LBAInfo.SectorCount )
+		wCurrPPSize = (U16)dwTotalWriteSecSize;
+	else
+		wCurrPPSize = nDevInfo->LBAInfo.SectorCount;
+	
+	//######################################################
+	//# Write Total Sector
+	//######################################################
+	wOldProcessRate = 0xFFFF;
+	nWriteSectorSize = 0;
+	nProCessWriteSectorSize = 0;
+	// [ LCD ROUTINE ] ---------------------------------------------------------------------------------------
+	if ( NAND_IO_LBA_CallBackLcdDisplay )
+		NAND_IO_LBA_CallBackLcdDisplay( 0, 0x03, nTotalSectorSize );
+	//--------------------------------------------------------------------------------------------------------
+
+	if ( dwTotalWriteSecSize >= 0x10000 )
+		wOnceWriteSectorCount = 0; // 0x10000
+	else
+		wOnceWriteSectorCount = (U16)dwTotalWriteSecSize;
+	
+	while ( dwTotalWriteSecSize )
+	{
+		if ( nWriteSectorSize == 0x10000 )
+		{			
+			if ( dwTotalWriteSecSize >= 0x10000 )
+				wOnceWriteSectorCount = 0;
+			else
+				wOnceWriteSectorCount = (U16)dwTotalWriteSecSize;			
+
+			nWriteSectorSize = 0;
+			wFlagFirstSector = TRUE;
+		}
+			
+		/* Command Page Program #1 [ 0x80 ] */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8080;
+
+		if ( wFlagFirstSector == TRUE )
+		{
+			/* Write Sector Size & Sector Address */
+			pNFC->NFC_SADDR= ( wOnceWriteSectorCount & 0xFF );					// Write Sector Num : SC0
+			pNFC->NFC_SADDR= ( ( wOnceWriteSectorCount >> 8 ) & 0xFF );			// Write Sector Num : SC1
+			pNFC->NFC_SADDR= ( dwSectorAddr & 0xFF );							// Write Sector Addr: AD0
+			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 8 ) & 0xFF );					// Write Sector Addr: AD1
+			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 16 ) & 0xFF );					// Write Sector Addr: AD2
+		}
+
+		NAND_IO_SetWriteCycleTime();
+		/* Write Data to NAND FLASH */
+		
+		res = NAND_IO_LBA_WriteDummyData( nDevInfo, wCurrPPSize );
+		if ( res != SUCCESS )
+			return res;
+
+		NAND_IO_SetCommCycleTime();
+		
+		/* Command Page Program #2 [ 0x10 ] */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+
+		/* Wait until it is ready */
+		NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+		/* Decrease Write Size */
+		dwTotalWriteSecSize -= wCurrPPSize;
+
+		/* Increase Buffer Address */
+		//nWriteBuffer		+= ( nDevInfo->LBAInfo.SectorCount << 9 );
+		dwSectorAddr		+= wCurrPPSize;
+		nWriteSectorSize	+= wCurrPPSize;
+		
+		/* Count Next Page Size */
+		if ( dwTotalWriteSecSize < nDevInfo->LBAInfo.SectorCount )
+			wCurrPPSize = (U16)dwTotalWriteSecSize;
+		else
+			wCurrPPSize = nDevInfo->LBAInfo.SectorCount;
+
+		if ( nDevInfo->LBAInfo.TransProtocol2 & NAND_PROT2_WRITE_TYPE_B )
+			wFlagFirstSector = FALSE;
+
+		wProcessRate = (U16)(( ( nProCessWriteSectorSize + 1 ) * 100 ) / ( nTotalSectorSize + 1 ));
+
+		if ( wOldProcessRate != wProcessRate )
+		{
+			// [ LCD ROUTINE ] ---------------------------------------------------------------------------------------
+			if ( NAND_IO_LBA_CallBackLcdDisplay )
+				NAND_IO_LBA_CallBackLcdDisplay( 0, NAND_LBA_CALLBACK_LCD_FORMAT_PROCESS, wProcessRate );
+			//--------------------------------------------------------------------------------------------------------
+
+			wOldProcessRate = wProcessRate;
+		}
+
+		nProCessWriteSectorSize += wCurrPPSize;
+	}
+
+	// [ LCD ROUTINE ] ---------------------------------------------------------------------------------------
+	if ( NAND_IO_LBA_CallBackLcdDisplay )
+		NAND_IO_LBA_CallBackLcdDisplay( 0, 0x05, 0 );
+	//--------------------------------------------------------------------------------------------------------
+	
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0xFBFB;
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	/* FORCE TO SET WP LOW */
+	//NAND_IO_EnableWriteProtect();
+	
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	/* Cache Flush */
+	NAND_IO_LBA_CacheFlush( nDevInfo );
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_WriteSector( NAND_IO_DEVINFO *nDevInfo, U8 nPartition, U32 nSectorAddr, U16 nSecSize, U8 *nWriteBuffer )
+{
+	unsigned short int		wCurrPPSize;
+	unsigned short int		wFlagFirstSector;
+	unsigned long int 		dwSectorAddr;
+	unsigned long int		dwSectorAddrOffSet;
+	unsigned long int		dwTotalWriteSecSize;
+	unsigned long int		nTotalSectorSize;
+	unsigned char			cPartition;
+	unsigned char			cSpareBuffer[16];
+	NAND_IO_ERROR			res;
+
+	//######################################################
+	//# Check Parameter
+	//######################################################
+	if ( nDevInfo->LBAInfo.Usable != ENABLE )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	cPartition = nPartition & 0x0F;
+
+	if ( nDevInfo->LBAInfo.CurrentMode != cPartition )
+		NAND_IO_LBA_ModeChange( nDevInfo, cPartition );
+
+	if ( nPartition == NAND_LBA_DATA_AREA )
+	{
+		nTotalSectorSize 	= nDevInfo->LBAInfo.DTAreaSectorSize;
+		dwSectorAddrOffSet 	= 0;
+	}
+	else if ( nPartition == NAND_LBA_HIDDEN_AREA )
+	{
+		nTotalSectorSize 	= nDevInfo->LBAInfo.HDAreaSectorSize;
+		dwSectorAddrOffSet 	= nDevInfo->LBAInfo.HDAreaAddrOffSet;
+	}
+	else if ( nPartition == NAND_LBA_MULTI_HIDDEN_AREA_0 )
+	{
+		nTotalSectorSize 	= nDevInfo->LBAInfo.MHDAreaSectorSize[0];
+		dwSectorAddrOffSet 	= nDevInfo->LBAInfo.MHDAreaAddrOffSet[0];
+	}
+	else if ( nPartition == NAND_LBA_MDP )
+	{
+		nTotalSectorSize 	= nDevInfo->LBAInfo.MDPSectorSize;
+		dwSectorAddrOffSet 	= 0;
+	}
+	else if ( nPartition == NAND_LBA_VFP )
+	{
+		nTotalSectorSize 	= nDevInfo->LBAInfo.VFPSectorSize;
+		dwSectorAddrOffSet 	= 1;
+	}
+	else
+	{
+		nTotalSectorSize 	= 0;
+		dwSectorAddrOffSet 	= 0;
+		return ERR_NAND_IO_WRONG_PARAMETER;
+	}
+
+	if ( ( nSectorAddr + nSecSize ) > nTotalSectorSize )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	wFlagFirstSector = TRUE;
+	
+	/* Pre Process */
+	NAND_IO_PreProcess();
+	
+	/* Set Setuo Time and Hold Time */
+	NAND_IO_SetCommCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	//NAND_IO_DisableWriteProtect();
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//######################################################
+	//# Get Info of Parameter
+	//######################################################
+	dwSectorAddr		= nSectorAddr;
+	dwSectorAddr 		+= dwSectorAddrOffSet;
+	dwTotalWriteSecSize = nSecSize;
+
+	if ( dwTotalWriteSecSize < nDevInfo->LBAInfo.SectorCount )
+		wCurrPPSize = (U16)dwTotalWriteSecSize;
+	else
+		wCurrPPSize = nDevInfo->LBAInfo.SectorCount ;
+	
+	//######################################################
+	//# Write Total Sector
+	//######################################################
+
+	while ( dwTotalWriteSecSize )
+	{
+		/* Command Page Program #1 [ 0x80 ] */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8080;
+
+		if ( wFlagFirstSector == TRUE )
+		{
+			/* Write Sector Size & Sector Address */
+			pNFC->NFC_SADDR= ( nSecSize & 0xFF );					// Write Sector Num : SC0
+			pNFC->NFC_SADDR= ( ( nSecSize >> 8 ) & 0xFF );			// Write Sector Num : SC1
+			pNFC->NFC_SADDR= ( dwSectorAddr & 0xFF );				// Write Sector Addr: AD0
+			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 8 ) & 0xFF );		// Write Sector Addr: AD1
+			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 16 ) & 0xFF );		// Write Sector Addr: AD2
+		}
+
+		NAND_IO_SetWriteCycleTime();
+		/* Write Data to NAND FLASH */
+		res = NAND_IO_LBA_WriteData( nDevInfo, wCurrPPSize, nWriteBuffer, cSpareBuffer );
+		if ( res != SUCCESS )
+			return res;
+		
+		NAND_IO_SetCommCycleTime();
+		
+		/* Command Page Program #2 [ 0x10 ] */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+
+		/* Decrease Write Size */
+		dwTotalWriteSecSize -= wCurrPPSize;
+
+		/* Increase Buffer Address */
+		nWriteBuffer		+= ( nDevInfo->LBAInfo.SectorCount << 9 );
+		
+		/* Count Next Page Size */
+		if ( dwTotalWriteSecSize < nDevInfo->LBAInfo.SectorCount )
+			wCurrPPSize = (U16)dwTotalWriteSecSize;
+		else
+			wCurrPPSize = nDevInfo->LBAInfo.SectorCount;
+
+		if ( nDevInfo->LBAInfo.TransProtocol2 & NAND_PROT2_WRITE_TYPE_B )
+			wFlagFirstSector = FALSE;
+
+		/* Wait until it is ready */
+		NAND_IO_WaitBusy( nDevInfo->ChipNo );
+	}
+	
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0xFBFB;
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	/* FORCE TO SET WP LOW */
+	//NAND_IO_EnableWriteProtect();
+	
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	/* Cache Flush */
+//	NAND_IO_LBA_CacheFlush( nDevInfo );
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_VFPInitArea( NAND_IO_DEVINFO *nDevInfo )
+{
+	NAND_IO_ERROR	res;
+	
+	res = NAND_IO_LBA_ScanHeaderOfVFP( nDevInfo );
+	if ( res != SUCCESS )
+	{
+		res = NAND_IO_LBA_MakeHeaderOfVFP( nDevInfo );
+		if ( res != SUCCESS )
+			return res;
+
+		res = NAND_IO_LBA_ScanHeaderOfVFP( nDevInfo );
+		if ( res != SUCCESS )
+			return res;
+	}
+	
+	return res;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_ScanHeaderOfVFP( NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned int			i;
+	unsigned short int		wCurrPPSize;
+	unsigned short int		wFlagCheckSize;
+	unsigned short int		wFlagFirstSector;
+	unsigned long int		nHeaderInfoSize;
+	unsigned long int		nHeaderAddress;
+	unsigned long int 		dwSectorAddr;
+	unsigned long int		nTotalSectorSize;
+	unsigned short int		nInfoOffSet;
+	unsigned int			*pPageDW;
+	unsigned char			cPageBuffer[512];
+	unsigned char			cSpareBuffer[16];
+	unsigned long int		dwTotalSectorSize;
+	NAND_IO_ERROR			res;
+
+	//######################################################
+	//# Check Parameter
+	//######################################################
+	NAND_IO_LBA_ModeChange( nDevInfo, NAND_LBA_VFP );
+
+	/* Pre Process */
+	NAND_IO_PreProcess();
+	
+	/* Set Setuo Time and Hold Time */
+	NAND_IO_SetCommCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	NAND_IO_DisableWriteProtect();
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	wFlagFirstSector = TRUE;
+	nInfoOffSet 		= 32;
+	nHeaderInfoSize 	= 1;
+	nHeaderAddress		= 0;
+	
+	//######################################################
+	//# Get Info of Parameter
+	//######################################################
+	dwSectorAddr		= nHeaderAddress;
+	nTotalSectorSize  	= nHeaderInfoSize;
+
+	if ( nTotalSectorSize < nDevInfo->LBAInfo.SectorCount )
+		wCurrPPSize = (U16)nTotalSectorSize;
+	else
+		wCurrPPSize = nDevInfo->LBAInfo.SectorCount ;
+	
+	//######################################################
+	//# Write Total Sector
+	//######################################################
+	while ( nTotalSectorSize )
+	{	
+		/* Command Page Program #1 [ 0x80 ] */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+
+		if ( wFlagFirstSector == TRUE )
+		{
+			/* Write Sector Size & Sector Address */
+			pNFC->NFC_SADDR= ( nHeaderInfoSize & 0xFF );					// Write Sector Num : SC0
+			pNFC->NFC_SADDR= ( ( nHeaderInfoSize >> 8 ) & 0xFF );			// Write Sector Num : SC1
+			pNFC->NFC_SADDR= ( dwSectorAddr & 0xFF );				// Write Sector Addr: AD0
+			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 8 ) & 0xFF );		// Write Sector Addr: AD1
+			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 16 ) & 0xFF );		// Write Sector Addr: AD2
+		}
+
+		/* Command Page Program #2 [ 0x10 ] */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+		
+		/* Wait until it is ready */
+		NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+		NAND_IO_SetReadCycleTime();
+		/* Write Data to NAND FLASH */
+		res = NAND_IO_LBA_ReadData( nDevInfo, wCurrPPSize, cPageBuffer, cSpareBuffer );
+		if ( res != SUCCESS )
+			return res;
+
+		NAND_IO_SetCommCycleTime();
+
+		/* Decrease Write Size */
+		nTotalSectorSize 	-= wCurrPPSize;
+
+		/* Increase Buffer Address */
+		//cPageBuffer			+= ( nDevInfo->LBAInfo.SectorCount << 9 );
+		
+		/* Count Next Page Size */
+		if ( nTotalSectorSize < nDevInfo->LBAInfo.SectorCount )
+			wCurrPPSize = (U16)nTotalSectorSize;
+		else
+			wCurrPPSize = nDevInfo->LBAInfo.SectorCount;
+
+		if ( nDevInfo->LBAInfo.TransProtocol2 & NAND_PROT2_WRITE_TYPE_B )
+			wFlagFirstSector = FALSE;
+	}
+
+	/* FORCE TO SET WP LOW */
+	NAND_IO_EnableWriteProtect();
+	
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	wFlagCheckSize = FALSE;
+
+	// Signature
+	if ( !memcmp( cPageBuffer, (void *)NAND_LBA_VFP_AREA_Signature, sizeof(NAND_LBA_VFP_AREA_Signature) ) )
+	{
+		pPageDW		= (U32 *)&cPageBuffer[nInfoOffSet];
+		//==============================================		
+		// VFP Size			[  4Byte ]	0
+		// MDP Size			[  4Byte ]	1
+		// Hidden Size		[  4Byte ]	2
+		// Multi-Hidden Num [  4Byte ]	3
+		// Multi-Hidden Size[  4Byte ]	4~10
+		//==============================================
+		dwTotalSectorSize = 0;
+
+		if ( nDevInfo->LBAInfo.VFPSectorSize == pPageDW[ENUM_LBA_VFP_SECTOR_SIZE] )
+		{
+			if ( nDevInfo->LBAInfo.FlagOfChangeTotalSectorSize == ENABLE )
+			{
+				if ( ( nDevInfo->LBAInfo.MDPSectorSize == pPageDW[ENUM_LBA_MDP_SECTOR_SIZE] ) &&
+					 ( nDevInfo->LBAInfo.HDAreaSectorSize == pPageDW[ENUM_LBA_HIDDEN_SECTOR_SIZE] ) &&
+					 ( nDevInfo->LBAInfo.MHDAreaNums == pPageDW[ENUM_LBA_MULTI_HIDDEN_NUM] ) )
+				{
+ 					wFlagCheckSize = TRUE;
+
+					if ( nDevInfo->LBAInfo.MHDAreaNums > NAND_LBA_MAX_SUPPORT_MHD_AREA_NUM )
+						return ERR_NAND_IO_WRONG_PARAMETER;
+
+					for ( i = 0; i < nDevInfo->LBAInfo.MHDAreaNums; ++i )
+					{
+						if ( nDevInfo->LBAInfo.MHDAreaSectorSize[i] != pPageDW[ENUM_LBA_MULTI_HIDDEN_SIZE_0 + i] )
+							wFlagCheckSize = FALSE;				
+					}
+				}
+				else
+					wFlagCheckSize = FALSE;
+			}
+			else		// NAND VFP Info Read Only
+			{
+				nDevInfo->LBAInfo.HDAreaSectorSize 	= pPageDW[ENUM_LBA_HIDDEN_SECTOR_SIZE];
+				nDevInfo->LBAInfo.MHDAreaNums 		= pPageDW[ENUM_LBA_MULTI_HIDDEN_NUM];
+
+				if ( nDevInfo->LBAInfo.MHDAreaNums > NAND_LBA_MAX_SUPPORT_MHD_AREA_NUM )
+					return ERR_NAND_IO_WRONG_PARAMETER;
+
+				for ( i = 0; i < nDevInfo->LBAInfo.MHDAreaNums; ++i )
+					nDevInfo->LBAInfo.MHDAreaSectorSize[i] = pPageDW[ENUM_LBA_MULTI_HIDDEN_SIZE_0 + i];
+
+				wFlagCheckSize = TRUE;
+			}
+		}
+		else
+		{
+			NAND_IO_LBA_VFPChangeSectorSize( nDevInfo, nDevInfo->LBAInfo.VFPSectorSize );
+		}
+	}
+
+	dwTotalSectorSize  = nDevInfo->LBAInfo.HDAreaSectorSize;
+	for ( i = 0; i < nDevInfo->LBAInfo.MHDAreaNums; ++i )
+		dwTotalSectorSize += nDevInfo->LBAInfo.MHDAreaSectorSize[i];
+
+	if ( dwTotalSectorSize > nDevInfo->LBAInfo.MDPSectorSize )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	if ( wFlagCheckSize == FALSE )
+		return ERR_NAND_IO_NOT_EXIST_LBA_HEADBLOCK;
+
+	//==================================
+	// Area Address Offset Setting
+	//==================================
+	// Data Area Address Offset = 0
+	// 0 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~MDP Size
+	// [ Data Area | Multi Hidden[n], Multi Hidden[n-1], Multi Hidden[0] | Hidden Area ]
+
+	nDevInfo->LBAInfo.DTAreaSectorSize = nDevInfo->LBAInfo.MDPSectorSize;
+	
+	nDevInfo->LBAInfo.DTAreaSectorSize -= nDevInfo->LBAInfo.HDAreaSectorSize;
+	nDevInfo->LBAInfo.HDAreaAddrOffSet = nDevInfo->LBAInfo.DTAreaSectorSize;
+
+	for ( i = 0; i < nDevInfo->LBAInfo.MHDAreaNums; ++i )
+	{
+		nDevInfo->LBAInfo.DTAreaSectorSize -= nDevInfo->LBAInfo.MHDAreaSectorSize[i];
+		nDevInfo->LBAInfo.MHDAreaAddrOffSet[i] = nDevInfo->LBAInfo.DTAreaSectorSize;
+	}
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_MakeHeaderOfVFP( NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned int			i;
+	unsigned short int		wCurrPPSize;
+	unsigned short int		wFlagFirstSector;
+	unsigned long int		nHeaderInfoSize;
+	unsigned long int		nHeaderAddress;
+	unsigned long int 		dwSectorAddr;
+	unsigned long int		nTotalSectorSize;
+	unsigned short int		nInfoOffSet;
+	unsigned int			*pPageDW;
+	unsigned char			cPageBuffer[512];
+	unsigned char			cSpareBuffer[16];
+	NAND_IO_ERROR			res;
+
+	//######################################################
+	//# Check Parameter
+	//######################################################
+	NAND_IO_LBA_ModeChange( nDevInfo, NAND_LBA_VFP );
+		
+	/* Pre Process */
+	NAND_IO_PreProcess();
+	
+	/* Set Setuo Time and Hold Time */
+	NAND_IO_SetCommCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	NAND_IO_DisableWriteProtect();
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+	wFlagFirstSector = TRUE;
+	nInfoOffSet 		= 32;
+	nHeaderInfoSize 	= 1;
+	nHeaderAddress		= 0;
+
+	//==============================================
+	// Hidden Signature [ 32Byte ]
+	// VFP Size			[  4Byte ]	0
+	// MDP Size			[  4Byte ]	1
+	// Hidden Size		[  4Byte ]	2
+	// Multi-Hidden Num [  4Byte ]	3
+	// Multi-Hidden Size[  4Byte ]	4~10
+	//==============================================
+	
+	// Page Clear
+	memset( (void*)cPageBuffer, 0xFF, 512 );
+
+	// Signature
+	memcpy( (void*)cPageBuffer, (void*)NAND_LBA_VFP_AREA_Signature, sizeof(NAND_LBA_VFP_AREA_Signature) );
+
+	pPageDW		= (U32 *)&cPageBuffer[nInfoOffSet];
+
+	// VFP Size
+	pPageDW[ENUM_LBA_VFP_SECTOR_SIZE] 	= nDevInfo->LBAInfo.VFPSectorSize;
+
+	// MDP Size
+	pPageDW[ENUM_LBA_MDP_SECTOR_SIZE] 	= nDevInfo->LBAInfo.MDPSectorSize;
+
+	// Hidden Size
+	pPageDW[ENUM_LBA_HIDDEN_SECTOR_SIZE]= nDevInfo->LBAInfo.HDAreaSectorSize;
+
+	// Multi-Hidden Area Num
+	pPageDW[ENUM_LBA_MULTI_HIDDEN_NUM] 	= nDevInfo->LBAInfo.MHDAreaNums;
+
+	if ( nDevInfo->LBAInfo.MHDAreaNums > NAND_LBA_MAX_SUPPORT_MHD_AREA_NUM )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	// Multi-Hidden Area Size
+	for ( i = 0; i < nDevInfo->LBAInfo.MHDAreaNums; ++i )
+		pPageDW[ENUM_LBA_MULTI_HIDDEN_SIZE_0 + i] 	= nDevInfo->LBAInfo.MHDAreaSectorSize[i];
+
+	//######################################################
+	//# Get Info of Parameter
+	//######################################################
+	dwSectorAddr		= nHeaderAddress;
+	nTotalSectorSize	= nHeaderInfoSize;
+	wFlagFirstSector = TRUE;
+
+	if ( nTotalSectorSize < nDevInfo->LBAInfo.SectorCount )
+		wCurrPPSize = (U16)nTotalSectorSize;
+	else
+		wCurrPPSize = nDevInfo->LBAInfo.SectorCount ;
+	
+	while ( nTotalSectorSize )
+	{
+		/* Command Page Program #1 [ 0x80 ] */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8080;
+
+		if ( wFlagFirstSector == TRUE )
+		{
+			/* Write Sector Size & Sector Address */
+			pNFC->NFC_SADDR= ( nHeaderInfoSize & 0xFF );					// Write Sector Num : SC0
+			pNFC->NFC_SADDR= ( ( nHeaderInfoSize >> 8 ) & 0xFF );			// Write Sector Num : SC1
+			pNFC->NFC_SADDR= ( dwSectorAddr & 0xFF );				// Write Sector Addr: AD0
+			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 8 ) & 0xFF );		// Write Sector Addr: AD1
+			pNFC->NFC_SADDR= ( ( dwSectorAddr >> 16 ) & 0xFF );		// Write Sector Addr: AD2
+		}
+
+		NAND_IO_SetWriteCycleTime();
+		/* Write Data to NAND FLASH */
+		res = NAND_IO_LBA_WriteData( nDevInfo, wCurrPPSize, cPageBuffer, cSpareBuffer );
+		if ( res != SUCCESS )
+			return res;
+		
+		NAND_IO_SetCommCycleTime();
+		
+		/* Command Page Program #2 [ 0x10 ] */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+
+		/* Decrease Write Size */
+		nTotalSectorSize -= wCurrPPSize;
+
+		/* Increase Buffer Address */
+		//cPageBuffer		+= ( nDevInfo->LBAInfo.SectorCount << 9 );
+		
+		/* Count Next Page Size */
+		if ( nTotalSectorSize < nDevInfo->LBAInfo.SectorCount )
+			wCurrPPSize = (U16)nTotalSectorSize;
+		else
+			wCurrPPSize = nDevInfo->LBAInfo.SectorCount;
+
+		if ( nDevInfo->LBAInfo.TransProtocol2 & NAND_PROT2_WRITE_TYPE_B )
+			wFlagFirstSector = FALSE;
+
+		/* Wait until it is ready */
+		NAND_IO_WaitBusy( nDevInfo->ChipNo );
+	}
+	
+	nDevInfo->LBAInfo.HDAreaAddrOffSet = nDevInfo->LBAInfo.MDPSectorSize - nDevInfo->LBAInfo.HDAreaSectorSize;
+	nDevInfo->LBAInfo.DTAreaSectorSize = nDevInfo->LBAInfo.MDPSectorSize - nDevInfo->LBAInfo.HDAreaSectorSize;
+
+	/* FORCE TO SET WP LOW */
+	NAND_IO_EnableWriteProtect();
+	
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	NAND_IO_LBA_CacheFlush( nDevInfo );
+
+	return (NAND_IO_ERROR)SUCCESS;	
+}
+
+NAND_IO_ERROR NAND_IO_LBA_MDPGetTotalSectorSize( NAND_IO_DEVINFO *nDevInfo, unsigned long int *rTotalSector )
+{
+	unsigned long int	wTotalSector;
+	unsigned char		nTemp;
+	/* Pre Process */
+	NAND_IO_PreProcess();
+
+	/* Set Setup Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+	pNFC->NFC_SADDR= 0xB0;
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x5757;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+	
+	/* Parallel Composition */
+	wTotalSector = (U8)( pNFC->NFC_SDATA & 0xFF );
+	wTotalSector |= ((U8)( pNFC->NFC_SDATA & 0xFF ) << 8 );
+	wTotalSector |= ((U8)( pNFC->NFC_SDATA & 0xFF ) << 16 );
+	wTotalSector |= ((U8)( pNFC->NFC_SDATA & 0xFF ) << 24 );
+//	wTotalSector |= ((U8)( pNFC->NFC_SDATA & 0xFF ) << 32 );
+	nTemp = (U8)( pNFC->NFC_SDATA & 0xFF );
+	
+	*rTotalSector = wTotalSector;
+	
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_VFPGetTotalSectorSize( NAND_IO_DEVINFO *nDevInfo, U32 *rTotalSector )
+{
+	unsigned int	dwTotalSector;
+
+	dwTotalSector  = 0;
+	*rTotalSector  = 0;
+	
+	/* Pre Process */
+	NAND_IO_PreProcess();
+
+	/* Set Setup Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+	pNFC->NFC_SADDR= 0xB5;
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x5757;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+	
+	/* Parallel Composition */
+	dwTotalSector = (U8)( pNFC->NFC_SDATA & 0xFF );
+	dwTotalSector |= ((U8)( pNFC->NFC_SDATA & 0xFF ) << 8 );
+
+	if ( dwTotalSector == 0 ) 
+		dwTotalSector = 0x10000;
+	
+	*rTotalSector = dwTotalSector;
+	
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_VFPChangeSectorSize( NAND_IO_DEVINFO *nDevInfo, U32 nTotalSector )
+{
+	unsigned int	dwTotalSector;
+
+	//======================================================================================
+	//
+	// The available rage for the VFP size: [40][00]h(8 Mbyte) ~ [01][00][00]h(32 Mbyte)
+	// VFP AreaSize Min: 16,384 ~ Max: 65,536 sector / 512 sector resolution
+	//
+	// "VFP/MDP ratio = (+1)/(-2)" VFP increases by 1MB, the DMP decreases by 2MB.
+	//
+	//======================================================================================
+	if ( ( nTotalSector < 0x4000 ) || ( nTotalSector > 0x10000 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+	
+	/* VFP Size Change Command can only be executed in the VFP mode */
+	NAND_IO_LBA_ModeChange( nDevInfo, NAND_LBA_VFP );
+	
+	/* Pre Process */
+	NAND_IO_PreProcess();
+
+	/* Set Setup Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus Witdh */
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+	
+	//==============================================
+	// Arrange Sector Resolution
+	//==============================================
+	dwTotalSector = ( ( nTotalSector + 511 ) >> 9 );
+	dwTotalSector = dwTotalSector << 9;
+
+	if ( ( dwTotalSector < 0x4000 ) || ( dwTotalSector > 0x10000 ) )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+	
+	//==============================================
+	// Set VFP Size
+	//==============================================
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+	pNFC->NFC_SADDR= 0x22;
+	
+	pNFC->NFC_SADDR= ( dwTotalSector & 0xFF );						// VFP_Size0: LSB
+	pNFC->NFC_SADDR= ( ( dwTotalSector >> 8 ) & 0xFF );				// VFP_Size1: MSB
+	pNFC->NFC_SADDR= ( 0xFF - ( dwTotalSector & 0xFF ) );			// Inversion of [VFP_Size0] for verification
+	pNFC->NFC_SADDR= ( 0xFF - ( ( dwTotalSector >> 8 ) & 0xFF ) );	// Inversion of [VFP_Size1] fot verification
+	
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x5757;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+	
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_SetTransferProtocol( NAND_IO_DEVINFO *nDevInfo, U8 nProtocol1, U8 nProtocol2 )
+{
+	/* Pre Process */
+	NAND_IO_PreProcess();
+	
+	/* Set Setuo Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//==============================================
+	// Get Protocol 1
+	//==============================================
+	/* Command Partition Change to PNP */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+
+	pNFC->NFC_SADDR= 0xA2;		// cmd
+	pNFC->NFC_SADDR= nProtocol1;	// Parameter
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x5757;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	//==============================================
+	// Get Protocol 2
+	//==============================================
+	/* Command Partition Change to PNP */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+
+	pNFC->NFC_SADDR= 0xA3;		// cmd
+	pNFC->NFC_SADDR= nProtocol2;	// Parameter
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x5757;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+	
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_SetBootModeChange( NAND_IO_DEVINFO *nDevInfo, U8 nBootMode )
+{
+	/* Pre Process */
+	NAND_IO_PreProcess();
+	
+	/* Set Setuo Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//==============================================
+	// Get Protocol 1
+	//==============================================
+	/* Command Partition Change to PNP */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= nBootMode;	// Parameter
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+	
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_SetRebootCmdChange( NAND_IO_DEVINFO *nDevInfo, U8 nRebootCmd )
+{
+	/* Pre Process */
+	NAND_IO_PreProcess();
+	
+	/* Set Setuo Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//==============================================
+	// Get Protocol 1
+	//==============================================
+	/* Command Partition Change to PNP */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= nRebootCmd;	// Parameter
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+	
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_GetPersistentFunction( NAND_IO_DEVINFO *nDevInfo, U8 *rBootMode, U8 *rRebootCmd )
+{
+	unsigned char	nParameter;
+
+	*rBootMode = 0;
+	*rRebootCmd = 0;
+	
+	/* Pre Process */
+	NAND_IO_PreProcess();
+	
+	/* Set Setuo Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//==============================================
+	// Get Protocol 1
+	//==============================================
+	/* Command Partition Change to PNP */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x99;		// CMD
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	nParameter = (U8)( pNFC->NFC_SDATA & 0xFF );
+
+	*rBootMode = nParameter;
+
+	nParameter = (U8)( pNFC->NFC_SDATA & 0xFF );
+
+	*rRebootCmd = nParameter;
+
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+	
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_GetTransferProtocol( NAND_IO_DEVINFO *nDevInfo, U8 *rProtocol1, U8 *rProtocol2 )
+{
+	unsigned char	nParameter;
+
+	*rProtocol1 = 0;
+	*rProtocol2 = 0;
+	
+	/* Pre Process */
+	NAND_IO_PreProcess();
+	
+	/* Set Setuo Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//==============================================
+	// Get Protocol 1
+	//==============================================
+	/* Command Partition Change to PNP */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+
+	pNFC->NFC_SADDR= 0xB2;		// cmd
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x5757;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	nParameter = (U8)( pNFC->NFC_SDATA & 0xFF );
+
+	*rProtocol1 = nParameter;
+
+	//==============================================
+	// Get Protocol 2
+	//==============================================
+	/* Command Partition Change to PNP */
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+
+	pNFC->NFC_SADDR= 0xB3;		// cmd
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x5757;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	nParameter = (U8)( pNFC->NFC_SDATA & 0xFF );
+
+	*rProtocol2 = nParameter;
+
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+	
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_GetBusyTime( NAND_IO_DEVINFO *nDevInfo, U8 *rBusyTime )
+{
+	unsigned char	dwBusyTime;
+
+	dwBusyTime  = 0;
+	*rBusyTime	= 0;
+	
+	/* Pre Process */
+	NAND_IO_PreProcess();
+
+	/* Set Setup Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+	pNFC->NFC_SADDR= 0xB4;
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x5757;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+	
+	/* Parallel Composition */
+	dwBusyTime = (U8)( pNFC->NFC_SDATA & 0xFF );
+
+	*rBusyTime = dwBusyTime;
+	
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_SetBusyTime( NAND_IO_DEVINFO *nDevInfo, U8 nBusyTime )
+{
+	/* Pre Process */
+	NAND_IO_PreProcess();
+
+	/* Set Setup Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+	pNFC->NFC_SADDR= nBusyTime;
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x5757;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+		
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_GetBootMode( NAND_IO_DEVINFO *nDevInfo, U8 *rBootMode )
+{
+	unsigned char	dwBootMode;
+
+	dwBootMode  = 0;
+	*rBootMode	= 0;
+	
+	/* Pre Process */
+	NAND_IO_PreProcess();
+
+	/* Set Setup Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+	pNFC->NFC_SADDR= 0x00;
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x99;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+	
+	/* Parallel Composition */
+	dwBootMode = (U8)( pNFC->NFC_SDATA & 0xFF );
+
+	*rBootMode = dwBootMode;
+	
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_PowerSaveMode( NAND_IO_DEVINFO *nDevInfo, int nOnOff )
+{
+	//Power Save Mode En,Disable	
+	/* Pre Process */
+	NAND_IO_PreProcess();
+
+	/* Set Setup Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+
+	if ( nOnOff == ENABLE )
+		pNFC->NFC_SADDR= 0xBA;
+	else
+		pNFC->NFC_SADDR= 0xBB;
+		
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x5757;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+	
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+	
+NAND_IO_ERROR NAND_IO_LBA_HighSpeedMode( NAND_IO_DEVINFO *nDevInfo, int nOnOff )
+{
+	// High Speed Write Mode En,Disable
+	/* Pre Process */
+	NAND_IO_PreProcess();
+
+	/* Set Setup Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+
+	if ( nOnOff == ENABLE )
+		pNFC->NFC_SADDR= 0xBC;
+	else
+		pNFC->NFC_SADDR= 0xBD;
+		
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_SADDR= 0x00;		// Dummy Write
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x5757;
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+	
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	if ( nOnOff == ENABLE )
+		nDevInfo->LBAInfo.HighSpeedMode	= ENABLE;
+	else
+		nDevInfo->LBAInfo.HighSpeedMode	= DISABLE;
+			
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_CacheFlush( NAND_IO_DEVINFO *nDevInfo )
+{ 
+	/* Pre Process */
+	NAND_IO_PreProcess();
+
+	/* Set Setup Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	if ( nDevInfo->LBAInfo.CurrentMode == NAND_LBA_BCM )
+	{
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;			
+		pNFC->NFC_SADDR= 0x00;		// Dummy Write
+		pNFC->NFC_SADDR= 0x00;		// Dummy Write
+		pNFC->NFC_SADDR= 0x00;		// Dummy Write
+		pNFC->NFC_SADDR= 0xF9;		// Dummy Write
+		pNFC->NFC_SADDR= 0x00;		// Dummy Write
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;
+	}
+	else
+	{
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0xF9F9;
+	}
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+	
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_DeviceReboot( NAND_IO_DEVINFO *nDevInfo )
+{
+	/* Pre Process */
+	NAND_IO_PreProcess();
+
+	/* Set Setup Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	if ( nDevInfo->LBAInfo.CurrentMode == NAND_LBA_BCM )
+	{
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8080;			
+		pNFC->NFC_SADDR= 0x00;		// Dummy Write
+		pNFC->NFC_SADDR= 0x00;		// Dummy Write
+		pNFC->NFC_SADDR= 0x00;		// Dummy Write
+		pNFC->NFC_SADDR= 0xFD;		// CMD
+		pNFC->NFC_SADDR= 0x00;		// Dummy Write
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+	}
+	else
+	{
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0xFDFD;
+	}
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+	
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	nDevInfo->LBAInfo.CurrentMode = NAND_LBA_PNP;
+	
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_ReadID( NAND_IO_DEVINFO *nDevInfo, NAND_IO_DEVID *nDeviceCode )
+{
+	/* Pre Process */
+	NAND_IO_PreProcess();
+
+	/* Set Setup Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x9292;
+	pNFC->NFC_SADDR	= 0x0000;	/* Address [ 0x00 ] */
+	
+	/* Delay : tAR1[READID] Max 200nS */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+	//ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+
+	/* Parallel Composition */
+	nDeviceCode->Code[0] = (U16)( pNFC->NFC_SDATA & nDevInfo->CmdMask );
+	nDeviceCode->Code[1] = (U16)( pNFC->NFC_SDATA & nDevInfo->CmdMask );
+	nDeviceCode->Code[2] = (U16)( pNFC->NFC_SDATA & nDevInfo->CmdMask );
+	nDeviceCode->Code[3] = (U16)( pNFC->NFC_SDATA & nDevInfo->CmdMask );
+	nDeviceCode->Code[4] = (U16)( pNFC->NFC_SDATA & nDevInfo->CmdMask );
+
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_Reset( NAND_IO_DEVINFO *nDevInfo )
+{
+	/* Pre Process */
+	NAND_IO_PreProcess();
+
+	/* Set Setup Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0xFFFF;
+	/* Delay : tAR1[READID] Max 200nS */
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0xFDFD;
+	/* Delay : tAR1[READID] Max 200nS */
+	ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;ASM_NOP;
+
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+	
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	nDevInfo->LBAInfo.CurrentMode = NAND_LBA_PNP;
+	
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_ModeChange( NAND_IO_DEVINFO *nDevInfo, int nMode )
+{
+	/* Pre Process */
+	NAND_IO_PreProcess();
+	
+	/* Set Setuo Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	if ( nMode == NAND_LBA_PNP )
+	{
+		// Change to BCM 
+		if ( ( nDevInfo->LBAInfo.CurrentMode == NAND_LBA_PNP ) || ( nDevInfo->LBAInfo.CurrentMode == NAND_LBA_BCM ) )
+		{
+			//==============================================
+			// Directly Enter BCM (Boot Code Maintenance)
+			//==============================================
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+
+			pNFC->NFC_SADDR= 0x00;		// Dummy Write 
+			pNFC->NFC_SADDR= 0x00;		// Dummy Write
+			pNFC->NFC_SADDR= 0x00;		// Dummy Write
+			pNFC->NFC_SADDR= 0xFC;		// cmd
+			pNFC->NFC_SADDR= 0x00;		// Dummy Write
+
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;			
+		}
+		else
+		{
+			/* Command Partition Change to BCM */
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+			
+			pNFC->NFC_SADDR= 0xBF;		// cmd
+			pNFC->NFC_SADDR= 0x00;		// PassWord 0
+			pNFC->NFC_SADDR= 0x00;		// PassWord 1
+			pNFC->NFC_SADDR= 0x00;		// Dummy Write
+			pNFC->NFC_SADDR= 0x00;		// Dummy Write
+
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x5757;			
+		}
+		/* Wait until it is ready */
+		NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+		// Exit from BCM
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x8080;
+
+		pNFC->NFC_SADDR= 0x00;		// Dummy Write 
+		pNFC->NFC_SADDR= 0x00;		// Dummy Write
+		pNFC->NFC_SADDR= 0x00;		// Dummy Write
+		pNFC->NFC_SADDR= 0xFD;		// cmd
+		pNFC->NFC_SADDR= 0x00;		// Dummy Write
+
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x1010;
+	}
+	else if ( nMode == NAND_LBA_BCM )
+	{
+		if ( ( nDevInfo->LBAInfo.CurrentMode == NAND_LBA_PNP ) || ( nDevInfo->LBAInfo.CurrentMode == NAND_LBA_BCM ) )
+		{
+			//==============================================
+			// Directly Enter BCM (Boot Code Maintenance)
+			//==============================================
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+
+			pNFC->NFC_SADDR= 0x00;		// Dummy Write 
+			pNFC->NFC_SADDR= 0x00;		// Dummy Write
+			pNFC->NFC_SADDR= 0x00;		// Dummy Write
+			pNFC->NFC_SADDR= 0xFC;		// cmd
+			pNFC->NFC_SADDR= 0x00;		// Dummy Write
+
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x3030;			
+		}
+		else
+		{
+			/* Command Partition Change to BCM */
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+			
+			pNFC->NFC_SADDR= 0xBF;		// cmd
+			pNFC->NFC_SADDR= 0x00;		// PassWord 0
+			pNFC->NFC_SADDR= 0x00;		// PassWord 1
+			pNFC->NFC_SADDR= 0x00;		// Dummy Write
+			pNFC->NFC_SADDR= 0x00;		// Dummy Write
+
+			pNFC->NFC_CMD = nDevInfo->CmdMask & 0x5757;			
+		}
+	}
+	else if ( nMode == NAND_LBA_MDP )
+	{
+		/* Command Partition Change to MDP */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0xFCFC;
+	}
+	else if ( nMode == NAND_LBA_VFP )
+	{
+		/* Command Partition Change to VFP */
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x0000;
+		
+		pNFC->NFC_SADDR= 0xBE;		// cmd
+		pNFC->NFC_SADDR= 0xFF;		// PassWord 0
+		pNFC->NFC_SADDR= 0xFF;		// PassWord 1
+		pNFC->NFC_SADDR= 0x00;		// Dummy Write
+		pNFC->NFC_SADDR= 0x00;		// Dummy Write
+
+		pNFC->NFC_CMD = nDevInfo->CmdMask & 0x5757;
+	}
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+
+	/* Read Status */
+	NAND_IO_LBA_Read2Status( nDevInfo );
+	if ( nDevInfo->LBAInfo.CurrentMode != nMode )
+		return ERR_NAND_IO_FAILED_LBA_PARTITION_CHANGE;
+
+	if ( nMode == NAND_LBA_MDP )
+	{
+		nDevInfo->LBAInfo.CurrentMode = NAND_LBA_MDP;
+		NAND_IO_LBA_MDPGetTotalSectorSize( nDevInfo, &nDevInfo->LBAInfo.CurrentSectorSize );
+	}
+	else if ( nMode == NAND_LBA_VFP )
+	{		
+		nDevInfo->LBAInfo.CurrentMode = NAND_LBA_VFP;
+		NAND_IO_LBA_VFPGetTotalSectorSize( nDevInfo, (U32 *)&nDevInfo->LBAInfo.CurrentSectorSize );
+	}
+
+	return (NAND_IO_ERROR)SUCCESS;
+}
+
+NAND_IO_ERROR NAND_IO_LBA_Read2Status( NAND_IO_DEVINFO *nDevInfo )
+{
+	unsigned int		uStatus;
+	NAND_IO_ERROR		res;
+
+	res = (NAND_IO_ERROR)SUCCESS;
+	
+	/* Pre Process */
+	NAND_IO_PreProcess();
+	
+	/* Set Setuo Time and Hold Time */
+	NAND_IO_SetBasicCycleTime();
+
+	/* Enable Chip Select */
+	NAND_IO_EnableChipSelect( nDevInfo->ChipNo );
+
+	/* Set Data Bus as 16Bit */
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+	
+	//================================
+	//	Command READ STATUS [ 0x70 ]
+	//================================
+	pNFC->NFC_CMD = nDevInfo->CmdMask & 0x7171;
+
+	// Delay : more than 200nS
+   	NAND_IO_Delay();
+	
+	//=============================================
+	// DATA BUS WIDTH Setting
+	//=============================================
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//================================
+	//	Read IO Status
+	//================================
+	uStatus	= nDevInfo->CmdMask & pNFC->NFC_SDATA;
+	uStatus = uStatus & 0x06;
+	
+	if ( uStatus == NAND_LBA_PNP )
+		nDevInfo->LBAInfo.CurrentMode = NAND_LBA_PNP;
+	else if ( uStatus == NAND_LBA_BCM )
+		nDevInfo->LBAInfo.CurrentMode = NAND_LBA_BCM;
+	else if ( uStatus == NAND_LBA_VFP )
+		nDevInfo->LBAInfo.CurrentMode = NAND_LBA_VFP;
+	else if ( uStatus == NAND_LBA_MDP )
+		nDevInfo->LBAInfo.CurrentMode = NAND_LBA_MDP;
+	else
+		res = ERR_NAND_IO_FAILED_LBA_PARTITION_CHANGE;
+
+	if ( nDevInfo->LBAInfo.CurrentMode != NAND_LBA_PNP )
+	{
+		if ( uStatus & NAND_POWER_SAVE_ENABLE )
+			nDevInfo->LBAInfo.PowerSaveMode = ENABLE;
+		else
+			nDevInfo->LBAInfo.PowerSaveMode = DISABLE;
+
+		if ( uStatus & NAND_HIGH_SPEED_ENABLE )
+			nDevInfo->LBAInfo.HighSpeedMode = ENABLE;
+		else
+			nDevInfo->LBAInfo.HighSpeedMode = DISABLE;		
+	}
+
+	/* Wait until it is ready */
+	NAND_IO_WaitBusy( nDevInfo->ChipNo );
+
+	/* Disable Chip Select */
+	NAND_IO_DisableChipSelect();
+
+	/* Post Process */
+	NAND_IO_PostProcess();
+	
+	return res;
+}
+
+static __inline NAND_IO_ERROR NAND_IO_LBA_ReadData( NAND_IO_DEVINFO *nDevInfo, U16 nReadPPSize,
+												    U8 *nPageBuffer, U8 *nSpareBuffer )
+{
+	unsigned int		i, j;
+	unsigned char		bAlignAddr;
+	unsigned char		*pPageB = 0, *pSpareB = 0;
+	unsigned int		*pPageDW = 0, *pSpareDW = 0;
+	unsigned char		*pDataBuffer;
+	DWORD_BYTE			uDWordByte;
+	NAND_IO_ERROR		res;
+	
+	if ( nReadPPSize > nDevInfo->LBAInfo.SectorCount )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+		
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	res = (NAND_IO_ERROR)SUCCESS;
+
+	//=========================================================================
+	// Check Align of PageBuffer Address
+	//=========================================================================
+	bAlignAddr = ( (unsigned int)nPageBuffer & 3 ) ? 0 : 1;
+	
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================	
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//=========================================================================
+	// Read Data as 512+16Bytes
+	//=========================================================================
+	/* Adapt type of address */
+	if ( bAlignAddr )
+	{
+		pPageDW		= (unsigned int*)nPageBuffer;
+		pSpareDW	= (unsigned int*)nSpareBuffer;
+	}	
+	else
+	{
+		pPageB		= (unsigned char*)nPageBuffer;
+		pSpareB		= (unsigned char*)nSpareBuffer;
+	}	
+
+	//----------------------------------------------
+	//	Read Data as 512Bytes repeatly
+	//----------------------------------------------		
+	for ( j = 0; j < nReadPPSize; ++j )
+	{
+		/* Set Data Buffer */
+		pDataBuffer = ( bAlignAddr ) ? (unsigned char*)pPageDW : (unsigned char*)pPageB;
+
+		//####################################################
+		//#	Read 512 Page Data
+		//####################################################
+		//----------------------------------------------
+		//	MCU ACCESS
+		//----------------------------------------------
+		#if defined( NAND_IO_USE_MCU_ACCESS )
+		
+		/* Read 512 Data Area */
+		i = 128;
+		do {
+			if ( bAlignAddr )
+			{
+				*pPageDW = pNFC->NFC_WDATA;++pPageDW;
+			}	
+			else
+			{
+				uDWordByte.DWORD = pNFC->NFC_WDATA;
+				*pPageB = uDWordByte.BYTE[0];++pPageB;
+				*pPageB = uDWordByte.BYTE[1];++pPageB;
+				*pPageB = uDWordByte.BYTE[2];++pPageB;
+				*pPageB = uDWordByte.BYTE[3];++pPageB;
+			}
+		}while(--i);
+		//----------------------------------------------
+		//	DMA ACCESS
+		//----------------------------------------------
+		#elif defined( NAND_IO_USE_DMA_ACCESS )
+
+		/* Disable DMA Ahead */
+		//IO_DMA_SetCTRL( IO_DMA_CH2, 0 );
+		//IO_INT_HwICLR = IO_INT_HwDMA_CH2;
+
+		/* Start DMA on NFC BUS */
+		#if defined(_LINUX_) || defined(_WINCE_)
+		NAND_IO_SetupDMA( (void*)&NAND_IO_HwLDATA_PA, 0, 0,
+						  (void*)pDataBuffer, 4, 0,
+						  NAND_IO_DMA_READ, 512 );
+		#else
+		NAND_IO_SetupDMA( (void*)&pNFC->NFC_LDATA, 0, 0,
+						  (void*)pDataBuffer, 4, 0,
+						  NAND_IO_DMA_READ, 512 );
+		#endif
+
+		//if ( ISZERO(pDataBuffer,3) ) {
+		//	#if defined(_WINCE_)
+		//		memcpy( pDataBuffer, (void*)IO_NFC_BUFFER0_BASE, 512 );
+		//	#elif defined(_LINUX_)
+		//		#ifndef KERNEL_DRIVER
+		//	    memcpy(pDataBuffer, (void*)IO_NFC_BUFFER0_BASE, 512);
+		//	    #else
+		//	    memcpy(pDataBuffer, virtadr, 512);
+		//		#endif
+		//	#else
+		//	fmemcpy16( pDataBuffer, (void*)IO_NFC_BUFFER0_BASE, 512 );
+		//	#endif
+		//} else {
+		//	#if defined(_WINCE_)
+		//		memcpy( pDataBuffer, (void*)IO_NFC_BUFFER0_BASE, 512 );
+		//	#elif defined(_LINUX_)
+		//	    #ifndef KERNEL_DRIVER
+		//	    memcpy(pDataBuffer, (void*)IO_NFC_BUFFER0_BASE, 512);
+		//	    #else
+		//	    memcpy(pDataBuffer, virtadr, 512);
+		//	    #endif
+		//	#else
+		//	memcpy( pDataBuffer, (void*)IO_NFC_BUFFER0_BASE, 512 );
+		//	#endif
+		//}
+
+		if ( bAlignAddr )
+			pPageDW += 128;
+		else
+			pPageB += 512;
+			
+		#endif
+		//####################################################
+		//####################################################
+		if ( nDevInfo->LBAInfo.DataTransferCheck == ENABLE )
+		{
+			/* Read 16Bytes spare data */
+			i = 4;
+			do {
+				if ( bAlignAddr )
+				{
+					*pSpareDW = pNFC->NFC_WDATA;++pSpareDW;
+				}	
+				else
+				{
+					uDWordByte.DWORD = pNFC->NFC_WDATA;
+					*pSpareB = uDWordByte.BYTE[0];++pSpareB;
+					*pSpareB = uDWordByte.BYTE[1];++pSpareB;
+					*pSpareB = uDWordByte.BYTE[2];++pSpareB;
+					*pSpareB = uDWordByte.BYTE[3];++pSpareB;
+				}
+			}while(--i);
+
+			/* Adapt type of address */
+			if ( bAlignAddr )
+				pSpareDW	= (unsigned int*)nSpareBuffer;
+			else
+				pSpareB		= (unsigned char*)nSpareBuffer;				
+		}
+	}
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+	return res;
+}
+
+static __inline NAND_IO_ERROR NAND_IO_LBA_WriteData( NAND_IO_DEVINFO *nDevInfo, U16 nWritePPSize,
+													 U8 *nPageBuffer, U8 *nSpareBuffer )
+{
+	unsigned int		i, j;
+	unsigned char		bAlignAddr;
+	unsigned char		*pPageB = 0, *pSpareB = 0;
+	unsigned int		*pPageDW = 0, *pSpareDW = 0;
+	unsigned char		*pDataBuffer;
+	DWORD_BYTE			uDWordByte;
+	NAND_IO_ERROR		res;
+	
+	if ( nWritePPSize > nDevInfo->LBAInfo.SectorCount )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	res = (NAND_IO_ERROR)SUCCESS;
+	
+	//=========================================================================
+	// Check Align of PageBuffer Address
+	//=========================================================================
+	bAlignAddr		= ( (unsigned int)nPageBuffer & 3 ) ? 0 : 1;
+
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================	
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	//=========================================================================
+	// Write Data as 528Bytes
+	//=========================================================================
+
+	/* Adapt type of address */
+	if ( bAlignAddr )
+	{
+		pPageDW		= (unsigned int*)nPageBuffer;
+		pSpareDW	= (unsigned int*)nSpareBuffer;
+	}	
+	else
+	{
+		pPageB		= (unsigned char*)nPageBuffer;
+		pSpareB		= (unsigned char*)nSpareBuffer;
+	}	
+
+	//----------------------------------------------
+	//	Write Data as 512Bytes repeatly
+	//----------------------------------------------		
+	for ( j = 0; j < nWritePPSize; ++j )
+	{
+		/* Get Data Buffer */
+		pDataBuffer = ( bAlignAddr ) ? (unsigned char*)pPageDW : (unsigned char*)pPageB;
+
+		//####################################################
+		//#	Write 512 Page Data
+		//####################################################
+		//----------------------------------------------
+		//	MCU ACCESS
+		//----------------------------------------------
+		#if defined( NAND_IO_USE_MCU_ACCESS )
+
+		/* Write 512 Data Area */	
+		BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
+		pNFC->NFC_DSIZE	= 512;
+		pNFC->NFC_IREQ = 0x77;	// pNFC->NFC_IREQ_FLAG1;
+		pNFC->NFC_PSTART = 0;
+		
+		i = 128;
+		do {
+			while (!( pNFC->NFC_CTRL & HwNFC_CTRL_FS_RDY ));
+			
+			if ( bAlignAddr )
+			{
+				pNFC->NFC_LDATA = *pPageDW;++pPageDW;
+			}	
+			else
+			{
+				uDWordByte.BYTE[0] = *pPageB;++pPageB;
+				uDWordByte.BYTE[1] = *pPageB;++pPageB;
+				uDWordByte.BYTE[2] = *pPageB;++pPageB;
+				uDWordByte.BYTE[3] = *pPageB;++pPageB;
+				pNFC->NFC_LDATA	= uDWordByte.DWORD;					
+			}
+		}while(--i);
+
+		while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+		
+		//----------------------------------------------
+		//	DMA ACCESS
+		//----------------------------------------------
+		#elif defined( NAND_IO_USE_DMA_ACCESS )
+		/* Disable DMA Ahead */
+		//IO_DMA_SetCTRL( IO_DMA_CH2, 0 );
+		//IO_INT_HwICLR = IO_INT_HwDMA_CH2;
+
+		/* Prepare data */
+		//if (ISZERO( pDataBuffer, 3 )) {
+		//	#if defined(_WINCE_)
+		//		memcpy( (void*)IO_NFC_BUFFER0_BASE, pDataBuffer, 512 );
+		//	#elif defined(_LINUX_)
+		//	    #ifndef KERNEL_DRIVER
+		//	    memcpy( (void*)IO_NFC_BUFFER0_BASE, pDataBuffer, 512 );
+		//	    #else
+		//	    memcpy( virtadr, pDataBuffer, 512 );
+		//	    #endif
+		//	#else
+		//	fmemcpy16( (void*)IO_NFC_BUFFER0_BASE, pDataBuffer, 512 );
+		//	#endif
+		//} else {
+		//	#if defined(_WINCE_)
+		//		memcpy( (void*)IO_NFC_BUFFER0_BASE, pDataBuffer, 512 );
+		//	#elif defined(_LINUX_)
+		//	    #ifndef KERNEL_DRIVER
+		//	    memcpy( (void*)IO_NFC_BUFFER0_BASE, pDataBuffer, 512 );
+		//	    #else
+		//	    memcpy( virtadr, pDataBuffer, 512 );
+		//	    #endif
+		//	#else
+		//	memcpy( (void*)IO_NFC_BUFFER0_BASE, pDataBuffer, 512 );
+		//	#endif
+		//}
+			
+		#if defined(_LINUX_) || defined(_WINCE_)
+		NAND_IO_SetupDMA( (void*)pDataBuffer, 4, 0,
+						  (void*)&NAND_IO_HwLDATA_PA, 0, 0,
+						  NAND_IO_DMA_WRITE, 512 );
+		#else
+		NAND_IO_SetupDMA( (void*)pDataBufferE, 4, 0,
+						  (void*)&pNFC->NFC_LDATA, 0, 0,
+						  NAND_IO_DMA_WRITE, 512 );
+		#endif
+
+		if ( bAlignAddr ) 
+			pPageDW += 128;
+		else
+			pPageB += 512;
+
+		#endif
+		//####################################################
+		//####################################################
+		if ( nDevInfo->LBAInfo.DataTransferCheck == ENABLE )
+		{
+			/* Write 16Bytes spare data */
+			i = 4;
+			do {
+				if ( bAlignAddr )
+				{
+					pNFC->NFC_WDATA = *pSpareDW;++pSpareDW;
+				}	
+				else
+				{
+					uDWordByte.BYTE[0]	= *pSpareB;++pSpareB;
+					uDWordByte.BYTE[1]	= *pSpareB;++pSpareB;
+					uDWordByte.BYTE[2]	= *pSpareB;++pSpareB;
+					uDWordByte.BYTE[3]	= *pSpareB;++pSpareB;
+					pNFC->NFC_WDATA = uDWordByte.DWORD;
+				}
+			}while(--i);
+
+			/* Adapt type of address */
+			if ( bAlignAddr )
+				pSpareDW	= (unsigned int*)nSpareBuffer;
+			else
+				pSpareB		= (unsigned char*)nSpareBuffer;			
+		}
+	}
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+	return res;
+}
+
+/**************************************************************************
+*  FUNCTION NAME : 
+*  
+*      static __inline NAND_IO_ERROR NAND_IO_LBA_WriteDummyData( NAND_IO_DEVINFO *nDevInfo, U16 nWritePPSize );
+*  
+*  DESCRIPTION : You can add file description here.
+*  
+*  INPUT:
+*			nDevInfo	= 
+*			nWritePPSize	= 
+*  
+*  OUTPUT:	NAND_IO_ERROR - Return Type
+*  			= 
+*  
+**************************************************************************/
+static __inline NAND_IO_ERROR NAND_IO_LBA_WriteDummyData( NAND_IO_DEVINFO *nDevInfo, U16 nWritePPSize )
+{
+	unsigned int		i, j;
+	unsigned char		nTempBuffer[512];
+	NAND_IO_ERROR		res;
+	
+	if ( nWritePPSize > nDevInfo->LBAInfo.SectorCount )
+		return ERR_NAND_IO_WRONG_PARAMETER;
+
+	//=========================================================================
+	// Initial Setting
+	//=========================================================================
+	res = (NAND_IO_ERROR)SUCCESS;
+
+	//=========================================================================
+	// DATA BUS WIDTH Setting
+	//=========================================================================	
+	if ( nDevInfo->Feature.MediaType & A_DATA_WITDH_16BIT )
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_16BIT );
+	else
+		NAND_IO_SetDataWidth( NAND_IO_DATA_WITDH_8BIT );
+
+	/* Prepare data */
+	#if defined(_WINCE_)
+		memset( nTempBuffer, 0xFF, 512 );
+	#elif defined(_LINUX_)
+	    #ifndef KERNEL_DRIVER
+	    memset( nTempBuffer, 0xFF, 512 );
+	    #else
+	    memset( nTempBuffer, 0xFF, 512 );
+	    #endif
+	#else
+	memset( nTempBuffer, 0xFF, 512 );
+	#endif
+	
+	//----------------------------------------------
+	//	Write Data as 512Bytes repeatly
+	//----------------------------------------------		
+	for ( j = 0; j < nWritePPSize; ++j )
+	{
+		//####################################################
+		//#	Write 512 Page Data
+		//####################################################
+		//----------------------------------------------
+		//	MCU ACCESS
+		//----------------------------------------------
+		#if defined( NAND_IO_USE_MCU_ACCESS )
+
+		/* Write 512 Data Area */	
+		BITCSET( pNFC->NFC_CTRL, HwNFC_CTRL_BSIZE_8, HwNFC_CTRL_BSIZE_1 );	// 1R/W Burst Size
+		pNFC->NFC_DSIZE	= 512;
+		pNFC->NFC_IREQ = 0x77;	// pNFC->NFC_IREQ_FLAG1;
+		pNFC->NFC_PSTART = 0;
+		
+		i = 128;
+		do {
+			while (!( pNFC->NFC_CTRL & HwNFC_CTRL_FS_RDY ));
+			pNFC->NFC_LDATA = 0xFFFFFFFF;
+		}while(--i);
+
+		while (ISZERO( pNFC->NFC_IREQ, HwNFC_IREQ_FLAG1 ));
+		
+		//----------------------------------------------
+		//	DMA ACCESS
+		//----------------------------------------------
+		#elif defined( NAND_IO_USE_DMA_ACCESS )
+		/* Disable DMA Ahead */
+		//IO_DMA_SetCTRL( IO_DMA_CH2, 0 );
+		//IO_INT_HwICLR = IO_INT_HwDMA_CH2;
+
+		#if defined(_LINUX_) || defined(_WINCE_)
+		NAND_IO_SetupDMA( (void*)nTempBuffer, 4, 0,
+						  (void*)&NAND_IO_HwLDATA_PA, 0, 0,
+						  NAND_IO_DMA_WRITE, 512 );
+		#else
+		NAND_IO_SetupDMA( (void*)nTempBuffer, 4, 0,
+						  (void*)&pNFC->NFC_LDATA, 0, 0,
+						  NAND_IO_DMA_WRITE, 512 );
+		#endif
+
+		#endif
+		//####################################################
+		//####################################################
+		if ( nDevInfo->LBAInfo.DataTransferCheck == ENABLE )
+		{
+			/* Write 16Bytes spare data */
+			i = 4;
+			do {
+				pNFC->NFC_WDATA = 0xFFFFFFFF;
+			}while(--i);
+		}
+	}
+
+	//=========================================================================
+	// Return
+	//=========================================================================
+	return res;
+}
+#endif	// NAND_LBA_INCLUDE
+
+#endif	// WITHOUT_FILESYSTEM
+
+/* end of file */
+
diff --git a/drivers/video/tccfb.c b/drivers/video/tccfb.c
index f755b01..2ef97b3 100644
--- a/drivers/video/tccfb.c
+++ b/drivers/video/tccfb.c
@@ -198,7 +198,7 @@ static u_int  fb_reseved_mem_size [CONFIG_FB_TCC_DEVS_MAX] = {TCC_FB0_SIZE,
 PDDICONFIG	pDDICfg;
 PLCDC		pLCDC0;
 PLCDC		pLCDC1;
-PGPIO		pGPIO;
+static PGPIO		pGPIO;
 
 PM2MSCALER	pM2MSCALER[2];
 
-- 
1.6.3.3

