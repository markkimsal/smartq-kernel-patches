From b2ee9d605f396da624a7787492889a05a1c231f6 Mon Sep 17 00:00:00 2001
From: gqwang <gqwang@hhcn.com>
Date: Fri, 7 Aug 2009 15:26:13 +0800
Subject: [PATCH] add marvell8686 offcial driver

Fix sd8668 hotplug problem

Mer: WPA fix

Reduce block size for better stability
---
 drivers/net/wireless/Kconfig                       |   21 +
 drivers/net/wireless/Makefile                      |    2 +
 drivers/net/wireless/marvell8686/Makefile          |   15 +
 drivers/net/wireless/marvell8686/README            | 1587 ++++
 drivers/net/wireless/marvell8686/host.h            |  349 +
 drivers/net/wireless/marvell8686/hostcmd.h         | 1052 +++
 drivers/net/wireless/marvell8686/if_sdio.c         | 1379 ++++
 drivers/net/wireless/marvell8686/if_sdio.h         |   97 +
 drivers/net/wireless/marvell8686/include.h         |   42 +
 drivers/net/wireless/marvell8686/os_defs.h         |   42 +
 drivers/net/wireless/marvell8686/os_headers.h      |   69 +
 drivers/net/wireless/marvell8686/os_macros.h       |  165 +
 drivers/net/wireless/marvell8686/os_timers.h       |   83 +
 drivers/net/wireless/marvell8686/release_version.h |    5 +
 drivers/net/wireless/marvell8686/sbi.h             |  111 +
 drivers/net/wireless/marvell8686/sdio.h            |  112 +
 drivers/net/wireless/marvell8686/wlan_11d.c        |  893 +++
 drivers/net/wireless/marvell8686/wlan_11d.h        |  110 +
 drivers/net/wireless/marvell8686/wlan_cmd.c        | 2501 ++++++
 drivers/net/wireless/marvell8686/wlan_cmdresp.c    | 1595 ++++
 drivers/net/wireless/marvell8686/wlan_debug.c      |  281 +
 drivers/net/wireless/marvell8686/wlan_decl.h       |  109 +
 drivers/net/wireless/marvell8686/wlan_defs.h       |  623 ++
 drivers/net/wireless/marvell8686/wlan_dev.h        |  470 ++
 drivers/net/wireless/marvell8686/wlan_fops.c       |  217 +
 drivers/net/wireless/marvell8686/wlan_fw.c         |  532 ++
 drivers/net/wireless/marvell8686/wlan_join.c       | 2031 +++++
 drivers/net/wireless/marvell8686/wlan_join.h       |   84 +
 drivers/net/wireless/marvell8686/wlan_main.c       | 1362 ++++
 drivers/net/wireless/marvell8686/wlan_proc.c       |  213 +
 drivers/net/wireless/marvell8686/wlan_rx.c         |  367 +
 drivers/net/wireless/marvell8686/wlan_scan.c       | 3226 ++++++++
 drivers/net/wireless/marvell8686/wlan_scan.h       |  284 +
 drivers/net/wireless/marvell8686/wlan_thread.h     |   58 +
 drivers/net/wireless/marvell8686/wlan_tx.c         |  286 +
 drivers/net/wireless/marvell8686/wlan_types.h      | 1050 +++
 drivers/net/wireless/marvell8686/wlan_version.h    |   18 +
 drivers/net/wireless/marvell8686/wlan_wext.c       | 8047 ++++++++++++++++++++
 drivers/net/wireless/marvell8686/wlan_wext.h       |  406 +
 drivers/net/wireless/marvell8686/wlan_wmm.c        | 1666 ++++
 drivers/net/wireless/marvell8686/wlan_wmm.h        |  111 +
 41 files changed, 31671 insertions(+), 0 deletions(-)
 create mode 100644 drivers/net/wireless/marvell8686/Makefile
 create mode 100644 drivers/net/wireless/marvell8686/README
 create mode 100644 drivers/net/wireless/marvell8686/host.h
 create mode 100644 drivers/net/wireless/marvell8686/hostcmd.h
 create mode 100644 drivers/net/wireless/marvell8686/if_sdio.c
 create mode 100644 drivers/net/wireless/marvell8686/if_sdio.h
 create mode 100644 drivers/net/wireless/marvell8686/include.h
 create mode 100644 drivers/net/wireless/marvell8686/os_defs.h
 create mode 100644 drivers/net/wireless/marvell8686/os_headers.h
 create mode 100644 drivers/net/wireless/marvell8686/os_macros.h
 create mode 100644 drivers/net/wireless/marvell8686/os_timers.h
 create mode 100644 drivers/net/wireless/marvell8686/release_version.h
 create mode 100644 drivers/net/wireless/marvell8686/sbi.h
 create mode 100644 drivers/net/wireless/marvell8686/sdio.h
 create mode 100644 drivers/net/wireless/marvell8686/wlan_11d.c
 create mode 100644 drivers/net/wireless/marvell8686/wlan_11d.h
 create mode 100644 drivers/net/wireless/marvell8686/wlan_cmd.c
 create mode 100644 drivers/net/wireless/marvell8686/wlan_cmdresp.c
 create mode 100644 drivers/net/wireless/marvell8686/wlan_debug.c
 create mode 100644 drivers/net/wireless/marvell8686/wlan_decl.h
 create mode 100644 drivers/net/wireless/marvell8686/wlan_defs.h
 create mode 100644 drivers/net/wireless/marvell8686/wlan_dev.h
 create mode 100644 drivers/net/wireless/marvell8686/wlan_fops.c
 create mode 100644 drivers/net/wireless/marvell8686/wlan_fw.c
 create mode 100644 drivers/net/wireless/marvell8686/wlan_join.c
 create mode 100644 drivers/net/wireless/marvell8686/wlan_join.h
 create mode 100644 drivers/net/wireless/marvell8686/wlan_main.c
 create mode 100644 drivers/net/wireless/marvell8686/wlan_proc.c
 create mode 100644 drivers/net/wireless/marvell8686/wlan_rx.c
 create mode 100644 drivers/net/wireless/marvell8686/wlan_scan.c
 create mode 100644 drivers/net/wireless/marvell8686/wlan_scan.h
 create mode 100644 drivers/net/wireless/marvell8686/wlan_thread.h
 create mode 100644 drivers/net/wireless/marvell8686/wlan_tx.c
 create mode 100644 drivers/net/wireless/marvell8686/wlan_types.h
 create mode 100644 drivers/net/wireless/marvell8686/wlan_version.h
 create mode 100644 drivers/net/wireless/marvell8686/wlan_wext.c
 create mode 100644 drivers/net/wireless/marvell8686/wlan_wext.h
 create mode 100644 drivers/net/wireless/marvell8686/wlan_wmm.c
 create mode 100644 drivers/net/wireless/marvell8686/wlan_wmm.h

Index: linux-2.6.29/drivers/net/wireless/Kconfig
===================================================================
--- linux-2.6.29.orig/drivers/net/wireless/Kconfig	2010-04-05 22:13:54.000000000 -0400
+++ linux-2.6.29/drivers/net/wireless/Kconfig	2010-04-05 23:04:01.000000000 -0400
@@ -170,6 +170,27 @@
 	---help---
 	  A driver for Marvell Libertas 8388 USB devices using thinfirm.
 
+config MARVELL_8686_SDIO
+	tristate "Official driver for Marvell SDIO 8686"
+	depends on WLAN_80211 && MMC
+	select WIRELESS_EXT
+	select IEEE80211
+	select FW_LOADER
+	---help---
+	  Official driver for Marvell 8686 devices.
+
+config MARVELL_8686_PROC_FS
+	bool "Enable proc-fs support for official marvell 8686 module."
+	depends on MARVELL_8686_SDIO
+	---help---
+	  Proc-fs support.
+
+config MARVELL_8686_DEBUG
+	bool "Enable full debugging output in the official marvell 8686 module."
+	depends on MARVELL_8686_SDIO
+	---help---
+	  Debugging support.
+
 config AIRO
 	tristate "Cisco/Aironet 34X/35X/4500/4800 ISA and PCI cards"
 	depends on ISA_DMA_API && WLAN_80211 && (PCI || BROKEN)
Index: linux-2.6.29/drivers/net/wireless/Makefile
===================================================================
--- linux-2.6.29.orig/drivers/net/wireless/Makefile	2010-04-05 22:13:54.000000000 -0400
+++ linux-2.6.29/drivers/net/wireless/Makefile	2010-04-05 23:04:47.000000000 -0400
@@ -44,6 +44,8 @@
 
 obj-$(CONFIG_LIBERTAS_THINFIRM)	+= libertas_tf/
 
+obj-$(CONFIG_MARVELL_8686_SDIO) += marvell8686/
+
 obj-$(CONFIG_ADM8211)	+= adm8211.o
 
 obj-$(CONFIG_IWLWIFI)	+= iwlwifi/
Index: linux-2.6.29/drivers/net/wireless/marvell8686/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/Makefile	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,15 @@
+ifeq ($(CONFIG_MARVELL_8686_PROC_FS),y)
+	sd8686-objs += wlan_proc.o
+endif
+
+ifeq ($(CONFIG_MARVELL_8686_DEBUG),y)
+	sd8686-objs += wlan_debug.o
+endif
+
+sd8686-objs += wlan_main.o wlan_fw.o \
+		wlan_wext.o wlan_rx.o wlan_tx.o \
+		wlan_cmd.o wlan_cmdresp.o wlan_scan.o \
+		wlan_join.o wlan_wmm.o wlan_11d.o wlan_fops.o \
+		if_sdio.o
+obj-$(CONFIG_MARVELL_8686_SDIO) += sd8686.o
+
Index: linux-2.6.29/drivers/net/wireless/marvell8686/README
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/README	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,1587 @@
+===============================================================================
+			U S E R  M A N U A L
+
+1) FOR DRIVER BUILD
+
+	Goto source code directory src_xxxx. 
+		make [clean] build	
+	The driver and utility binaries can be found in ../bin_xxxx directory.
+
+2) FOR DRIVER INSTALL
+
+	a) Copy helper_sd.bin and sd8xxx.bin to /lib/firmware/mrvl/ directory,
+	   create the directory if it doesn't exist. 
+	b) insmod sdio.o (or sdio.ko) [clkrate=5|10|20] [intmode=0|1] [gpiopin=n]
+		The default SDIO clock frequency is 20 MHz. It can be changed to 10 MHz or 5 MHz.
+		intmode -- 0 for SDIO (default)
+		intmode -- 1 for GPIO, gpiopin for GPIO pin# has to be specified in this mode.
+	c) insmod sd8xxx.o (or sd8xxx.ko) helper_name=/lib/firmware/mrvl/helper_sd.bin \
+			fw_name=/lib/firmware/mrvl/sd8xxx.bin 
+
+	To install SD8xxx Driver with user-specified helper file /lib/firmware/mrvl/helper_sd.bin and 
+	MFG firmware file /lib/firmware/mrvl/sd8xxxmfg.bin, using the following command:
+		insmod sdio.o (or sdio.ko)
+		insmod sd8xxx.o (or sd8xxx.ko) mfgmode=1 helper_name=/lib/firmware/mrvl/helper_sd.bin \
+			fw_name=/lib/firmware/mrvl/sd8xxxmfg.bin
+
+3) FOR DRIVER PROC & DEBUG
+
+	The following info are provided in /proc/net/wlan/info,
+
+	driver_name = "wlan"
+	driver_version = <chip id, firmware version and driver version>
+	InterfaceName = "ethX"
+	Mode = "Ad-hoc" | "Managed" | "Auto" | "Unknown"
+	State = "Disconnected" | "Connected"
+	MACAddress = <6-byte adapter MAC address>
+	MCCount = <multicast address count>
+	ESSID = <current SSID>
+	Channel = <current channel>
+	region_code = <current region code>
+	MCAddr[n] = <multicast address>
+	num_tx_bytes = <number of bytes sent to device>
+	num_rx_bytes = <number of bytes received from device and sent to kernel>
+	num_tx_pkts = <number of packets sent to device>
+	num_rx_pkts = <number of packets received from device and sent to kernel>
+	num_tx_pkts_dropped = <number of tx packets dropped by driver>
+	num_rx_pkts_dropped = <number of rx packets dropped by driver>
+	num_tx_pkts_err = <number of tx packets failed to send to device>
+	num_rx_pkts_err = <number of rx packets failed to receive from device>
+	carrier "on" | "off"
+	tx queue "stopped" | "started"
+	CurCmd "NULL" | <current command id and action>
+
+	The following debug info are provided in /proc/net/wlan/debug,
+
+	IntCounter = <interrupt count, cleared when interrupt handled>
+	ConnectStatus = <0/1, disconnected/connected>
+	wmmQStp = <0/1, WMM queue started/stopped>
+	wmmPkts = <number of tx packets in WMM queues>
+	wmmAcVo = <number of packets sent to device from WMM AcVo queue>
+	wmmAcVi = <number of packets sent to device from WMM AcVi queue>
+	wmmAcBE = <number of packets sent to device from WMM AcBE queue>
+	wmmAcBK = <number of packets sent to device from WMM AcBK queue>
+	PSMode = <0/1, CAM mode/PS mode>
+	PSState = <0/1/2/3, full power state/awake state/pre-sleep state/sleep state>
+	IsDeepSleep = <0/1, not deep sleep state/deep sleep state>
+	IsAutoDeepSleepEnabled = <0/1, not auto deep sleep mode/auto deep sleep mode>
+	WakeupDevReq = <0/1, wakeup device not required/required>
+	WakeupTries = <wakeup device count, cleared when device awake>
+	HS_Configured = <0/1, host sleep not configured/configured>
+	HS_Activated = <0/1, extended host sleep not activated/activated>
+	num_tx_timeout = <number of tx timeout>
+	num_cmd_timeout = <number of timeout commands>
+	TimeoutCmdId = <command id of the last timeout command>
+	TimeoutCmdAct = <command action of the last timeout command>
+	LastCmdId = <command id of the last several commands sent to device>
+	LastCmdAct = <command action of the last several commands sent to device>
+	LastCmdIndex = <0 based last command index>
+	LastCmdRespId = <command id of the last several command responses received from device>
+	LastCmdRespIndex = <0 based last command response index>
+	LastEvent = <event id of the last several events received from device>
+	LastEventIndex = <0 based last event index>
+	num_cmd_h2c_fail = <number of commands failed to send to device>
+	num_cmd_sleep_cfm_fail = <number of sleep confirm failed to send to device>
+	num_tx_h2c_fail = <number of data packets failed to send to device>
+	num_evt_deauth = <number of deauthenticated events received from device>
+	num_evt_disassoc = <number of disassociated events received from device>
+	num_evt_link_lost = <number of link lost events received from device>
+	num_cmd_deauth = <number of deauthenticate commands sent to device>
+	num_cmd_assoc_ok = <number of associate commands with success return>
+	num_cmd_assoc_fail = <number of associate commands with failure return>
+	dnld_sent = <0/1/2, send resources available/sending data to device/sending command to device>
+
+	Use dmesg or cat /var/log/debug to check driver debug messages.
+
+	Update /proc/sys/kernel/printk to change message log levels.
+	For example,
+	echo 6 > /proc/sys/kernel/printk    (messages with a higher priority than 6 
+	                                     will be printed to the console)
+	echo 15 > /proc/sys/kernel/printk   (all messages will be printed to console)
+
+4) FOR IWPRIV COMMAND
+
+NAME
+	This manual describes the usage of private commands used in Marvell WLAN
+	Linux Driver. All the commands available in Wlanconfig will not be available 
+	in the iwpriv.
+
+	To use parameters as hex format, a'0x' must precede it for the parameters to 
+	be parsed properly. 
+
+SYNOPSIS
+	iwpriv <ethX> <command> [sub-command] ...
+
+	iwpriv ethX version
+	iwpriv ethX verext
+	iwpriv ethX scantype [sub-command]
+	iwpriv ethX getSNR <n>
+	iwpriv ethX getNF <n>
+	iwpriv ethX getRSSI <n>
+	iwpriv ethX setrxant <n>
+	iwpriv ethX getrxant
+	iwpriv ethX settxant <n>
+	iwpriv ethX gettxant
+	iwpriv ethX authalgs <n>
+	iwpriv ethX encryptionmode <n>
+	iwpriv ethX setregioncode <n>
+	iwpriv ethX getregioncode 
+	iwpriv ethX setbcnavg <n>
+	iwpriv ethX getbcnavg
+	iwpriv ethX setdataavg <n>
+	iwpriv ethX getdataavg
+	iwpriv ethX setlisteninter <n>
+	iwpriv ethX getlisteninter
+	iwpriv ethX setmultipledtim <n>
+	iwpriv ethX getmultipledtim
+	iwpriv ethX atimwindow <n>
+	iwpriv ethX deepsleep <n>
+	iwpriv ethX autodeepsleep <n>
+	iwpriv ethX hscfg <n>
+	iwpriv ethX hssetpara <n>
+	iwpriv ethX deauth
+	iwpriv ethX adhocstop
+	iwpriv ethX radioon
+	iwpriv ethX radiooff
+	iwpriv ethX reasso-on
+	iwpriv ethX reasso-off
+	iwpriv ethX scanmode  [sub-command]
+	iwpriv ethX setwpaie <n>
+	iwpriv ethX setaeskey <n>
+	iwpriv ethX getaeskey 
+	iwpriv ethX rmaeskey
+	iwpriv ethX getcis
+	iwpriv ethX getlog
+	iwpriv ethX getadhocstatus
+	iwpriv ethX adhocgrate <n>
+
+Version 4 Command:
+	iwpriv ethX inactivityto <n>
+	iwpriv ethX sleeppd <n>
+	iwpriv ethX enable11d <n>
+	iwpriv ethX bgscan <n>
+	iwpriv ethX wmm <n>
+	iwpriv ethX tpccfg <n>
+	iwpriv ethX sdioclock <n>
+
+Version 5 Command:
+	iwpriv ethX ledgpio <n>
+	iwpriv ethX wmm_qosinfo <n>
+	iwpriv ethX scanprobes <n>
+	iwpriv ethX lolisteninter <n>
+ 	iwpriv ethX rateadapt <n> <m> <l> <k>
+	iwpriv ethX fwwakeupmethod <n>
+	iwpriv ethX txcontrol <n>
+	iwpriv ethX uapsdnullgen <n>
+	iwpriv ethX psnullinterval <n>
+	iwpriv ethX getrxinfo
+	iwpriv ethX gettxrate
+	iwpriv ethX bcninterval [n]
+	iwpriv ethX setcoalescing <n>
+	iwpriv ethX bcnmisto <n>
+	iwpriv ethX adhocawakepd <n>
+	iwpriv ethX sdiopullctrl <m> <n>
+	iwpriv ethX scantime [s] [a] [p]
+	iwpriv ethX ldocfg [n]
+	iwpriv ethX dataevtcfg [a] [b] [c] [d] [e] [f] [g] [h] [i]
+	iwpriv ethX sdiomode [n]
+	iwpriv ethX rtsctsctrl [n]
+	iwpriv ethX drvdbg [n] [m]
+	iwpriv ethX adhocgprot [n]
+	iwpriv ethX getrate 
+	iwpriv ethX associate <n>
+	iwpriv ethX getdtim
+
+DESCRIPTION
+	Those commands are used to send additional commands to the Marvell WLAN
+	card via the Linux device driver.
+
+	The ethX parameter specifies the network device that is to be used to 
+		perform this command on. it could be eth0, eth1 etc.
+
+version	
+	This is used to get the current version of the driver and the firmware.
+
+verext
+    Retrieve and display an extended version string from the firmware
+
+	Usage:
+		iwpriv ethX verext [#]
+
+     where [#] is an optional argument to retrieve a specific version string,
+        omission of the argument retrieves the 0 indexed string
+
+scantype	
+	This command is used to set the scan type to be used by the driver in 
+	the scan command. This setting will not be used while performing a scan
+	for a specific SSID, as it is always done with scan type being active. 
+	
+	where the sub-commands are: - 
+			active 	-- to set the scan type to active
+			passive -- to set the scan type to passive
+			get 	-- to get the scan type set in the driver
+
+getSNR  
+	This command gets the average and non average value of Signal to Noise 
+	Ratio of Beacon and Data.
+	
+	where value is:
+			0 	-- Beacon non-average.
+	        	1 	-- Beacon average.
+	        	2 	-- Data non-average.
+	        	3 	-- Data average.
+
+	If no value is given, all four values are returned in the order mentioned
+	above.
+
+	Note: This command is available only when STA is connected.
+
+getRSSI	
+	This command gets the average and non average value os Receive Signal 
+	Strength of Beacon and Data.
+	
+	where value is:
+			0 	-- Beacon non-average.
+	        	1 	-- Beacon average.
+	        	2 	-- Data non-average.
+	        	3 	-- Data average.
+
+	Note: This command is available only when STA is connected.
+
+getNF   
+	This command gets the average and non average value of Noise Floor of 
+	Beacon and Data.
+	
+	where value is:
+			0 	-- Beacon non-average.
+	        	1 	-- Beacon average.
+	        	2 	-- Data non-average.
+	        	3 	-- Data average.
+
+	Note: This command is available only when STA is connected.
+
+setrxant	
+	This command is used to set the mode for Rx antenna. 
+	
+	The options that can be sent are:- 
+			1 	-- Antenna 1. 
+			2 	-- Antenna 2.
+			0xFFFF 	-- Diversity.
+
+	Usage:
+		iwpriv ethX setrxant 0x01: select Antenna 1.
+
+getrxant                    
+	This command is used to get the mode for Rx antenna.
+
+settxant	
+	This command is used to set the mode for Tx antenna.
+		The options that can be sent are:- 
+			1 	-- Antenna 1. 
+			2 	-- Antenna 2.
+			0xFFFF 	-- Diversity.
+	Usage:
+		iwpriv ethX settxant 0x01: select Antenna 1.
+
+gettxant                    
+	This command is used to get the mode for Tx antenna.
+
+authalgs	
+	This command is used by the WPA supplicant to set the authentication 
+	algorithms in the station.
+
+encryptionmode
+	This command is used by the WPA supplicant to set the encryption algorithm.
+		
+	where values can be:-
+			0 	-- NONE
+			1 	-- WEP40
+			2 	-- TKIP
+			3 	-- CCMP
+			4 	-- WEP104
+
+setregioncode           
+	This command is used to set the region code in the station.
+	where value is 'region code' for various regions like
+	USA FCC, Canada IC, France, Europe ETSI, Japan ...
+
+	Usage:
+		iwpriv ethX setregioncode 0x10: set region code to USA (0x10).
+
+getregioncode           
+	This command is used to get the region code information set in the 
+	station. 
+
+setbcnavg
+	Set the weighting factor for calculating beacon average RSSI and SNR.
+	where value can be:
+			0 	-- default beacon averaging factor (8)
+			1-8 	-- beacon averaging factor
+	Usage:
+		iwpriv ethX setbcnavg 0
+		iwpriv ethX setbcnavg 8
+
+getbcnavg
+	Get the weighting factor for calculating beacon average RSSI and SNR.
+	Usage:
+		iwpriv ethX getbcnavg
+
+setdataavg
+	Set the weighting factor for calculating data average RSSI and SNR.
+	where value can be:
+			0 	-- default data averaging factor (8)
+			1-8 	-- data averaging factor
+	Usage:
+		iwpriv ethX setdataavg 0
+		iwpriv ethX setdataavg 8
+
+getdataavg
+	Get the weighting factor for calculating data average RSSI and SNR.
+	Usage:
+		iwpriv ethX getdataavg
+
+setlisteninter             
+	This command is used to set the listen interval in the 
+	station.
+	
+	where the value ranges between 1 - 255
+
+getlisteninter            
+	This command is used to get the listen interval value set in the 
+	station.
+
+setmultipledtim         
+	This command is used to set the multiple dtim value in the 
+	station.
+		where the value is 1,2,3,4,5,0xfffe
+		65534 (0xfffe) means that the dtim will be ignored in firmware,
+		listen interval or local listen interval will be used.
+
+getmultipledtim        
+	This command is used to get the multiple dtim value set in the station.
+
+atimwindow         
+	This command is used to set atim value in the station when an argument is given, 
+        return the atim value set by the user and the current atim value if adapter is in connected state. 
+        The valid atimwindow is between 0 - 50.
+
+	Usage:
+		iwpriv ethX atimwindow 0  (set atimwindow to 0)
+		
+		not connected:
+		iwpriv ethX atimwindow    (get atimwindow value set by user)
+		
+		connected:
+		iwpriv ethX atimwindow     (get atimwindow set by user previously
+                                                         and current atimwindow)
+
+deauth                      
+	This command is used to send the de-authentication to the AP with which 
+	the station is associated. This command is valid only when 
+	station is in Infrastructure mode.
+
+	Note: This command is available only when STA is connected.
+
+reasso-on                  
+	This command is used to enable re-association function in dirver.
+
+reasso-off                  
+	This command is used to disable re-association function in driver
+
+adhocstop                 
+	This command is used to stop beacon transmission from the station and 
+	go into idle state in ad-hoc mode.
+	
+	Note: This command is available only when STA is connected.
+
+radioon                     
+	This command is used to turn on the RF antenna.
+
+radiooff                    
+	This command is sued to turn off the RF antenna.   
+
+scanmode                 
+	This command is used to set the station to scan for either IBSS 
+	networks or BSS networks or both BSS and IBSS networks. This 
+	command can be used with sub commands,
+
+	where the value for 
+			bss 	-- Scan All the BSS networks.
+			ibss 	-- Scan All the IBSS networks.
+			any 	-- Scan both BSS and IBSS networks.
+			
+deepsleep                    
+	This command is used to configure the station in deepsleep mode.
+
+	where the option is:
+			1 	-- Enable deepsleep mode
+			0 	-- Disable deepsleep mode
+			2 	-- Display deepsleep setting 
+	Usage:
+	iwpriv ethX deepsleep 1
+			Enable deepsleep mode
+	iwpriv ethX deepsleep 0
+			Disable deepsleep mode
+	iwpriv ethX deepsleep 2
+			Display deepsleep setting
+
+autodeepsleep                    
+	This command is used to configure the station in auto deepsleep mode.
+
+	where the option is:
+			1 	-- Enable auto deepsleep mode
+			0 	-- Disable auto deepsleep mode
+	Usage:
+	iwpriv ethX autodeepsleep
+			Read the current auto deepsleep setting
+	iwpriv ethX autodeepsleep 1
+			Enable auto deepsleep mode
+	iwpriv ethX autodeepsleep 0
+			Disable auto deepsleep mode
+
+hscfg	
+	This command is used to configure the host sleep parameters.
+
+		iwpriv ethX hscfg Condition [GPIO# [Gap]]
+
+	Note:
+
+	1) This command takes one (Condition) or two (Condition and GPIO#) or three (Condition, GPIO# and gap)
+	parameters.
+
+		where Condition is:
+			bit 0 = 1 	-- broadcast data
+			bit 1 = 1 	-- unicast data
+			bit 2 = 1 	-- mac event
+			bit 3 = 1 	-- multicast packet
+
+		where GPIO is the pin number of GPIO used to wakeup the host. It could be any valid
+		GPIO pin# (e.g. 0-7) or 0xff (Interface, e.g. SDIO will be used instead).
+		
+		where Gap is the gap in milli seconds between wakeup signal and wakeup event
+		or 0xff for special setting.
+
+	2) the Host Sleep mode will be cancelled if condition is set to -1.
+	
+	3) Usage:
+		iwpriv eth1 hscfg -1			# cancel host sleep mode
+
+		iwpriv eth1 hscfg 3			# broadcast and unicast data
+							# use GPIO and GAP set previously
+	
+		iwpriv eth1 hscfg 2 0x3			# unicast data
+							# use GPIO 3
+							# use GAP set previously
+
+		iwpriv eth1 hscfg 2 1 0xa0		# unicast data
+							# use GPIO 1
+							# gap: 160 ms
+
+		iwpriv eth1 hscfg 2 0xff		# unicast data
+							# use Interface (e.g. SDIO)
+							# use GAP set previously
+
+                iwpriv eth1 hscfg 0x2 0x3 0xff		# unicast data
+							# use GPIO 3
+							# special host sleep mode
+
+		iwpriv eth1 hscfg 0x2 0xff 0xff		# unicast data
+							# use Interface (e.g. SDIO)
+							# special host sleep mode
+
+hssetpara
+	This command is used to set host sleep parameters.
+
+		iwpriv ethX hssetpara Condition [GPIO# [Gap]]
+
+	Note:
+	1) The usages of parameters are the same as "hscfg" command.
+	2) The parameters will be saved in the driver and be usded when host suspends.
+
+setwpaie                      
+	This command is used by WPA supplicant to send the WPA-IE to the driver. 
+
+setaeskey
+	This command is used to set the AES key, when the station is in Ad-hoc
+	mode.
+
+	where value can be any 16 byte value.
+
+	Usage:
+		iwpriv ethX setaeskey 12345678901234567890123456789012
+
+getaeskey
+	This command is used to get the AES key, when the station is in Ad-hoc
+	mode.
+
+rmaeskey
+	This command is used to remove the Ad-Hoc AES key that is previously set.
+	It will disable ad-hoc AES as well.
+
+getcis
+	This command is used to read the Card Info Structure Table.
+	
+getlog
+	This command is used to get the 802.11 statistics available in the 
+		station.
+	
+	Note: This command is available only when STA is connected.
+
+getadhocstatus
+	This command is used to get the ad-hoc Network Status.
+
+	The various status codes are:
+		AdhocStarted
+		AdhocJoined
+		AdhocIdle
+		InfraMode
+		AutoUnknownMode
+
+	Note: This command is available only when STA is connected.
+
+adhocgrate
+	This command is used to enable(1) g_rate, Disable(0) g_rate 
+	and request(2) the status which g_rate is disabled/enabled,
+	for Ad-hoc creator.
+
+	where value is:
+		0	-- Disable
+		1	-- Enable
+		2	-- Get
+
+ledgpio
+	This command is used to set/get LED settings.
+
+	iwpriv ethX ledgpio <LEDs>
+		will set the corresponding LED for the GPIO Line.
+
+	iwpriv ethX ledgpio
+		will get the current LEDs settings.
+
+	Usage:
+		iwpriv eth1 ledgpio 1 0 2 1 3 16
+			LED 1 -> GPIO 0
+			LED 2 -> GPIO 1
+			LED 3 -> disable
+
+		iwpriv eth1 ledgpio 
+			shows LED information in the format as mentioned above.
+
+	Note: LED 0 is invalid
+	      Maximum Number of LEDs are 3.
+	
+inactivityto
+	This command is used by the host to set/get the inactivity timeout value, 
+	which specifies when WLAN device is put to sleep.
+	
+	Usage:
+		iwpriv ethX inactivityto [<timeout>]
+
+	where the parameter are:
+		timeout: timeout value in milliseconds.
+
+	Example:
+		iwpriv eth1 inactivityto
+			"get the timeout value"
+
+		iwpriv eth1 inactivityto X 
+			"set timeout value to X ms"
+
+sleeppd
+	This command is used to configure the sleep period of the WLAN device.
+
+	Usage:
+		iwpriv ethX sleeppd [<sleep period>]
+
+	where the parameter are:
+		Period: sleep period in milliseconds. Range 10~60.
+
+	Example:
+		iwpriv eth1 sleeppd 10 
+			"set period as 10 ms"
+		iwpriv eth1 sleeppd
+			"get the sleep period configuration"
+
+enable11d
+	This command is used to control 11d
+	where value is:
+		1	-- Enable
+		0	-- Disable
+		2	-- Get
+
+wmm
+	This command is used to control WMM
+
+	where value is:
+		0	-- Disable
+		1	-- Enable
+		2	-- Get
+
+	
+bgscan
+	Enables or disables the Background scan.
+
+	The configuration for bg scan must be set using wlanconfig
+
+	Usage:
+		wlanconfig ethX bgscanconfig bg_scan_config.conf
+		iwpriv ethX bgscan 0 (disable)
+		iwpriv ethX bgscan 1 (enable)
+		iwpriv ethX bgscan 2 (display enable or disable)
+
+tpccfg
+	Enables or disables automatic transmit power control.
+
+	The first parameter turns this feature on (1) or off (0).  When turning 
+	on, the user must also supply four more parameters in the following 
+	order:
+		-UseSNR (Use SNR (in addition to PER) for TPC algorithm),
+		-P0 (P0 power level for TPC),
+		-P1 (P1 power level for TPC),
+		-P2 (P2 power level for TPC).
+
+	Usage:
+		iwpriv ethX tpccfg: Get current configuration
+		iwpriv ethX tpccfg 0: disable auto TPC
+		iwpriv ethX tpccfg 0x01 0x00 0x05 0x0a 0x0d: enable auto TPC; do not use SNR;
+							     P0=0x05; P1=0x0a; P2=0x0d;
+		iwpriv ethX tpccfg 0x01 0x01 0x05 0x0a 0x0d: enable auto TPC; use SNR;
+							     P0=0x05; P1=0x0a; P2=0x0d.
+
+sdioclock
+	Turn On(1) or Off(0) the SDIO clock.
+
+	Usage:
+		iwpriv ethX sdioclock 1 (on)
+		iwpriv ethX sdioclock 0 (off)
+
+wmm_qosinfo
+	This command sets WMM IE QOS info when an argument is given, and gets current WMM
+	IE QOS info when no argument is given.
+
+	Usage:
+		iwpriv ethX wmm_qosinfo 0x0f (set WMM IE QOS info to 0x0f)
+		iwpriv ethX wmm_qosinfo      (get WMM IE QOS info)
+
+scanprobes
+	This command sets number of probe requests per channel.
+
+	Usage:
+		iwpriv ethX scanprobes 3 (set scan probes to 3)
+		iwpriv ethX scanprobes   (get scan probes)
+
+lolisteninter
+	This command sets the value of listen interval.
+
+	Usage:
+	iwpriv ethX lolisteninter 234 (set the lolisteninter to 234)
+	iwpriv ethX lolisteninter     (get the lolisteninter value)
+
+rateadapt
+	This command sets the data rates bitmap.
+	Where <n>
+ 		0: no HW rate drop
+		1: HW table rate drop
+		2: HW single rate drop
+	      <m>
+		 data rate bitmap
+			Bit	Data rate
+			0	1 Mbps
+			1	2 Mbps
+			2	5.5 Mbps
+			3	11 Mbps
+			4	Reserved
+			5	6 Mbps
+			6	9 Mbps
+			7	12 Mbps
+			8	18 Mbps
+			9	24 Mbps
+			10	36 Mbps
+			11	48 Mbps
+			12	54 Mbps
+			12-15	Reserved
+		<l> Threshold, Number of same rate retries before switch to Final rate.
+		    Used only if HW single rate drop is selected. Typical values are from 3 to 6.
+
+		<k> Final Rate, This value is used only if HW single rate drop is selected.
+			value	Data rate
+			0	1 Mbps
+			1	2 Mbps
+			2	5.5 Mbps
+			3	11 Mbps
+			4	Reserved
+			5	6 Mbps
+			6	9 Mbps
+			7	12 Mbps
+			8	18 Mbps
+			9	24 Mbps
+			10	36 Mbps
+			11	48 Mbps
+			12	54 Mbps
+			13-15	Reserved
+	Usage:
+	iwpriv ethX rateadapt
+			read the currect data rate setting
+	iwpriv ethX rateadapt 1 0x07
+			enable hardware auto data rate adapt and 
+			data rates are 1Mbps, 2Mbsp and 5.5Mbps
+	iwpriv ethX rateadapt 2 0x0f 6 2
+			use HW single rate drop, data rates are 1Mbps, 2Mbsp and 5.5Mbps, 11Mbps
+			Threshold is 6, Final Rate is 5.5 Mbps
+
+fwwakeupmethod
+	This command is used to set the firmware wakeup method.
+
+	where value <n> is:
+		0	-- Leave the current method to wakeup firmware unchanged
+		1	-- Firmware wakeup through the interface command interrupt
+			-- (default setting for SDIO/GSPI)
+		2	-- Firmware wakeup through the GPIO pin
+			-- (default setting for CF)
+
+	Usage:
+	iwpriv ethX fwwakeupmethod
+			Read the current firmware wakeup method setting
+	iwpriv ethX fwwakeupmethod 0
+			Leave the current method to wakeup firmware unchanged
+	iwpriv ethX fwwakeupmethod 1
+			Firmware wakeup through the interface command interrupt
+	iwpriv ethX fwwakeupmethod 2
+			Firmware wakeup through the GPIO pin
+
+txcontrol [DefaultFlags (if no UP setting)] [UserPriority] [UserPriorityFlags]
+    This command is used to set/get the TX rate, WMM ack policy, and 
+       retry limit for all packets, or selectively the packets with a specific
+       user priority.
+
+    The DefaultFlags setting is ignored for any command with 2 or more 
+       arguments.
+
+    The value of the u32 txcontrol flags returned and input for 
+       DefaultFlags or UserPriorityFlags specific settings is given by the
+       following bitmap:
+
+    bit[4:0], if bit[4] == 1:
+      bit[3:0]        -- 0  1  2    3   4   5  6  7   8   9   10  11  12  13-16
+      Data Rate(Mbps) -- 1  2  5.5  11  Rsv 6  9  12  18  24  36  48  54  Rsv
+
+    bit[12:8] 
+      if bit[12] == 1, bit[11:8] specifies the Tx retry limit.
+
+    bit[14:13] specifies per packet ack policy:
+      if bit[14] == 1, bit[13] == 1 specifies No Ack Policy
+
+    All unused and reserved bits should be set to zero for the entire 
+      u32 field.
+
+    Usage:
+      Number of arguments given:
+
+      0: Return the default setting for the txcontrol flags
+         > iwpriv eth1 txcontrol
+
+      1: Set the default value for the txcontrol flags
+         > iwpriv eth1 txcontrol 0x6013  - No ACK, 11Mbps
+         > iwpriv eth1 txcontrol 0x151A  - 5 retries, 36Mbps
+
+      2: Return a specific User Priority setting.  If the UP setting is zero,
+         the default value will be used and returned:
+         > iwpriv eth1 txcontrol 0 7  - Return UP 7 txcontrol value (UP7 = VO)
+
+      3: Set a User Priority specific value for the txcontrol flags.  A value
+         of zero will revert to the default setting:
+         > iwpriv eth1 txcontrol 0 5 0x6013 - (UP5 = VI), No ACK 11Mbps.
+
+uapsdnullgen
+	This command is used to enable(1) UAPSD null package generation, 
+	Disable(0) UAPSD null package generation, and request(2) the status 
+	which null package generation is disabled/enabled,
+	for Ad-hoc creator.
+
+	where value is:
+		0	-- Disable
+		1	-- Enable
+		2	-- Get
+
+psnullinterval
+	This command is used to set/request NULL package interval for Power Save
+	under infrastructure mode.
+
+	where value is:
+		-1	-- Disable
+		n>0	-- Set interval as n (seconds)
+
+getrxinfo
+	This command gets non average value of Signal to Noise Ratio of Data and rate index.
+
+	The following table shows RateIndex and Rate
+
+		     RateIndex	Data rate
+			0	1 Mbps
+			1	2 Mbps
+			2	5.5 Mbps
+			3	11 Mbps
+			4	Reserved
+			5	6 Mbps
+			6	9 Mbps
+			7	12 Mbps
+			8	18 Mbps
+			9	24 Mbps
+			10	36 Mbps
+			11	48 Mbps
+			12	54 Mbps
+			13-15	Reserved
+
+gettxrate	 
+	This command gets current Tx rate index of the first packet associated with Rate Adaptation.
+
+	The following table shows RateIndex and Rate
+
+		     RateIndex	Data rate
+			0	1 Mbps
+			1	2 Mbps
+			2	5.5 Mbps
+			3	11 Mbps
+			4	Reserved
+			5	6 Mbps
+			6	9 Mbps
+			7	12 Mbps
+			8	18 Mbps
+			9	24 Mbps
+			10	36 Mbps
+			11	48 Mbps
+			12	54 Mbps
+			13-15	Reserved
+
+bcninterval 
+	This command is used to set beacon interval in adhoc mode when an argument is given, 
+	return the value set by the user and the current adhoc beacon interval if adapter is in connected state. 
+        The valid beacon interval is between 20 - 1000, default beacon interval is 100.
+
+	Usage:
+		iwpriv ethX bcninterval 100  (set adhoc beacon interval to 100)
+		
+		not connected:
+		iwpriv ethX bcninterval      (get adhoc beacon interval set by user)
+		
+		connected:
+		iwpriv ethX bcninterval      (get adhoc beacon interval set by user previously
+                                              and current beacon interval)
+                 
+setcoalescing
+	This command is used to disable/enable IBSS coalescing function, and get IBSS coalescing status.
+
+	where value is:
+		0	-- Disable IBSS coalescing function
+		1	-- Enable IBSS coalescing function
+		2	-- Get current IBSS coalescing status
+
+bcnmisto 
+	This command is used to set/get beacon miss timeout for Power Save
+	under infrastructure mode.
+
+	where value is:
+		0xffff -- Disabled
+		0 -- no change
+		1--50  (miliseconds)
+
+adhocawakepd 
+	This command is used to set/get adhoc awake period for Power Save Mode.
+
+	where value is:
+		0xff -- firmware will go to sleep after send out beacon
+		0--no change 
+		1--31 (beacon interval) 
+
+sdiopullctrl
+	This command is used to set/get seting of pulling up and pulling down of SDIO lines, 
+        The PullUp is the delay before pulling SDIO lines up. The PullDown is the 
+        delay before pull SDIO lines down. the unit is us for both PullUp and PullDown.
+     
+        where <m> PullUp
+              0--no delay is needed
+              0xffff--no pulling up is needed
+
+	      <n> PullDown
+	      0--no delay is needed
+              0xffff--no pulling up is needed	
+
+	Usage:
+	iwpriv ethX sdiopullctrl
+			Read the currect firmware SDIO PullUp and PullDown settings	     	
+        iwpriv ethX sdiopullctrl 5  5
+			Set SDIO PullUp/PullDown to 5 us 
+	iwpriv ethX sdiopullctrl 0xffff 0xffff
+			Disable SDIO PullUp and PullDown
+
+scantime
+	This command is used to set/get scan time per channel in milliseconds.
+	The current setting will be returned every time.
+
+	Usage:
+		iwpriv ethX scantime [s] [a] [p]
+	
+	where the parameters are,
+		[s]: specific SSID/BSSID scan time, default 100 ms, max 500 ms
+		[a]: active scan time, default 100 ms, max 500 ms
+		[p]: passive scan time, default 100 ms, max 2000 ms
+		No change if the parameter is 0 or the parameter is not provided.
+
+	For example:
+		iwpriv ethX scantime 30         (set specific scan time to 30 ms)
+		iwpriv ethX scantime 0 100      (set active scan time to 100 ms)
+		iwpriv ethX scantime 30 80 200  (set specific scan time to 30 ms,
+		                                 set active scan time to 80 ms,
+		                                 set passive scan time to 200 ms)
+
+ldocfg
+	This command is used to set/get internal/external core power voltage source.
+	By default firmware uses internal LDO for 1.2V core power supply.
+	The current setting will be returned if no parameter provided.
+
+	Usage:
+		iwpriv ethX ldocfg [n]
+	
+	where the parameter is,
+		0	-- internal
+		1	-- external
+
+dataevtcfg 
+	This command is used to set/get the subscription of low RSSI, low SNR, high RSSI and 
+	high SNR events in data packet. 
+
+	Where value <a> is:
+	 	    Events bitmap
+			Bit	
+			0	RSSI_LOW 	RSSI_LOW event is generated when avg data RSSI is below threshold
+			1	SNR_LOW  	SNR_LOW event is generated when avg data SNR is below threshold
+			2	RSSI_HIGH	RSSI_HIGH event is generated when avg data RSSI go above threshold
+			3	SNR_HIGH 	SNR_HIGH event is generated when avg data SNR go above threshold
+
+	Where value <b> is:				
+			RSSI_LOW threshold (Absolute value, the actual value should be negative)
+	Where value <c> is:
+			RSSI_LOW reporting frequency. if set to 0, event will only report once. 
+			if set to 1, event will be reported every time it occur. 
+			if set to N, event will be reported only when the condition happens N consecutive times.
+
+	Where value <d> is:				
+			SNR_LOW threshold
+	Where value <e> is:
+			SNR_LOW reporting frequency. if set to 0, event will only report once. 
+			if set to 1, event will be reported every time it occur. 
+			if set to N, event will be reported only when the condition happens N consecutive times.
+
+	Where value <f> is:				
+			RSSI_HIGH threshold (Absolute value, the actual value should be negative)
+	Where value <g> is:
+			RSSI_HIGH reporting frequency. if set to 0, event will only report once. 
+			if set to 1, event will be reported every time it occur. 
+			if set to N, event will be reported only when the condition happens N consecutive times.
+
+	Where value <h> is:				
+			SNR_HIGH threshold
+	Where value <i> is:
+			SNR_HIGH reporting frequency. if set to 0, event will only report once. 
+			if set to 1, event will be reported every time it occur. 
+			if set to N, event will be reported only when the condition happens N consecutive times.
+
+	Usage:
+		iwpriv ethX dataevtcfg		(get current data subscribe event settings)
+		iwpriv ethX dataevtcfg 15 70 1 56 0 40 5 86 0
+		                      		(set current data subscribe event, 
+		                      		 when avg data RSSI below -70, such as -80,
+		                      		 RSSI_LOW event will be generated every time;
+		                      		 when avg data RSSI above -40 happens 5 consecutive times, 
+						 such as -30,-32,-34,-29,-33, RSSI_HIGH event will be generated 1 times; 
+		                      		 when avg data SNR below 56 or above 86, 
+		                      		 SNR_LOW or SNR_HIGHT event will be generated once)
+
+sdiomode
+	This command is used to set/get sdio mode. 
+	The setting will take effect when next command 53 is issued.
+
+	where the parameter <n> is,
+		1	-- set sdio to 1 bit mode
+		4	-- set sdio to 4 bit mode
+	
+	Usage:
+		iwpriv ethX sdiomode            (get current sdio mode)
+		iwpriv ethX sdiomode 1		(set to 1 bit mode)
+		iwpriv ethX sdiomode 4		(set to 4 bit mode)
+
+rtsctsctrl 
+	This command is used to set/get the RTS/CTS or CTS To SELF for g rate protection to the firmware.
+       	where the parameter <n> is,
+		1	-- set RTS/CTS for g rate protection to the firmware.
+		0	-- set CTS To SELF for g rate protection to the firmware.
+	
+	Usage:
+		iwpriv ethX rtsctsctrl          (gets the RTS/CTS or CTS To SELF)
+		iwpriv ethX rtsctsctrl 1	(set RTS/CTS for g rate protection to the firmware.)
+		iwpriv ethX rtsctsctrl 0	(set CTS To SELF for g rate protection to the firmware.)  
+
+drvdbg
+	This command is used to set/get the bit masks of driver debug message control.
+
+	Usage:
+		iwpriv ethX drvdbg [n] [m]
+
+	Where the parameter <n> is the generic debug message control bit mask.
+	The following types of driver debug messages can be dynamically enabled or 
+	disabled by setting or clearing the corresponding bits, 
+		bit 0:  MSG  		PRINTM(MSG,...)
+		bit 1:  FATAL		PRINTM(FATAL,...)
+		bit 2:  ERROR		PRINTM(ERROR,...)
+		bit 3:  DATA 		PRINTM(DATA,...)
+		bit 4:  CMND 		PRINTM(CMND,...)
+		bit 5:  EVENT		PRINTM(EVENT,...)
+		bit 6:  INTR 		PRINTM(INTR,...)
+		...
+		bit 16: DAT_D		PRINTM(DAT_D,...), DBG_HEXDUMP(DAT_D,...)
+		bit 17: CMD_D		PRINTM(CMD_D,...), DBG_HEXDUMP(CMD_D,...)
+		bit 18: FW_D		PRINTM(FW_D,...)
+		...
+		bit 28: ENTRY		PRINTM(ENTRY,...), ENTER(), LEAVE()
+		bit 29: WARN 		PRINTM(WARN,...)
+		bit 30: INFO 		PRINTM(INFO,...)
+
+	Where the parameter <m> is the extended interface module debug message control 
+	bit mask. The following types of debug messages can be controlled.
+
+		bit 0:  IF_D 		PRINTM(IF_D,...),  DBG_HEXDUMP(IF_D,...)
+
+	If CONFIG_DEBUG=2, all kinds of debug messages can be configured. 
+	By default all debug messages are enabled except for EVENT and IF_D.
+
+	If CONFIG_DEBUG=1, all kinds of debug messages can be configured except 
+	for ENTRY, WARN and INFO. By default MSG and FATAL are enabled.
+
+	Some special debug messages,
+		'*'		// WLAN driver ISR is called (bit 6 INTR enabled)
+		'|'		// PS awake event is received (bit 5 EVENT enabled)
+		'_'		// PS sleep event is received (bit 5 EVENT enabled)
+		'+'		// PS sleep confirm is sent (bit 5 EVENT enabled)
+
+	For example:
+		iwpriv ethX drvdbg          (get the current driver debug masks)
+		iwpriv ethX drvdbg 0 0      (disable all the debug messages)
+		iwpriv ethX drvdbg 7        (enable MSG, FATAL and ERROR messages,
+		                             no change for if debug control)
+		iwpriv ethX drvdbg 3 1      (enable MSG and FATAL messages,
+		                             enable IF_D message)
+		iwpriv ethX drvdbg -1 -1    (enable all the debug messages)
+
+adhocgprot 
+	This command is used to set/get 802.11g ad-hoc protection state.
+
+	where value is:
+		0	-- Disable
+		1	-- Enable
+		2	-- Get
+	Usage:
+		iwpriv ethX adhocgprot 0        (disable 802.11g ad-hoc g protection)
+		iwpriv ethX adhocgprot 1        (enable 802.11g ad-hoc g protection)
+		iwpriv ethX adhocgprot 2        (get 802.11g ad-hoc g protection state)
+
+getrate 
+	This command is used to get the supported rates. Returned rates are in 0.5M unit.
+
+associate <scan table index>
+    Associate to a specific BSS entry in the scan table.  The enumeration
+       of the entries in the scan table is determined by the 
+       getscantable API or from the iwlist scan results.  A re-scan is not
+       performed before the association attempt is made.
+
+getdtim
+	This command is used to get the current DTIM value.
+	Note: This command is available only when STA is connected.
+
+
+===============================================================================
+
+		U S E R  M A N U A L  F O R  W L A N _ C O N F I G 
+
+NAME
+wlanconfig - configure the additional parameters available for the Marvell 
+		WLAN Linux Driver.
+
+SYNOPSIS
+wlanconfig -v
+wlanconfig <ethX> <command> [parameters] ...
+
+wlanconfig ethX version
+wlanconfig ethX <rdmac|rdbbp|rdrf> <offset>
+wlanconfig ethX <wrmac|wrbbp|wrrf> <offset> <n>
+wlanconfig ethX sdcmd52r  <FN no.>  <address>
+wlanconfig ethX sdcmd52w  <FN no.>  <address> <data>
+wlanconfig ethX caldataext <filename>
+wlanconfig ethX rdeeprom <offset> <length>
+wlanconfig ethX sleepparams <config values>
+wlanconfig ethX bca-ts <config values>
+wlanconfig ethX extscan <ssid>
+wlanconfig ethX getscanlist
+
+Version 4 Command:
+wlanconfig ethX bgscanconfig <filename>
+
+Version 5 Command:
+wlanconfig ethX hostcmd <hostcmd.conf> <subevent_get>
+wlanconfig ethX hostcmd <hostcmd.conf> <subevent_set>
+
+Version 6 Command:
+wlanconfig ethX setuserscan [ARGS]
+wlanconfig ethX getscantable
+wlanconfig ethX getassocrsp
+
+Version 8
+wlanconfig ethX addts <filename.conf> <section# of tspec> <timeout in ms>
+wlanconfig ethX delts <filename.conf> <section# of tspec>
+wlanconfig ethX qconfig set msdu <lifetime in TUs> [Queue Id: 0-3]
+wlanconfig ethX qconfig get [Queue Id: 0-3]
+wlanconfig ethX qconfig def [Queue Id: 0-3]
+wlanconfig ethX qstats on  [Queue Id: 0-3]
+wlanconfig ethX qstats off [Queue Id: 0-3]
+wlanconfig ethX qstats get [Queue Id: 0-3]
+wlanconfig ethX hostcmd <hostcmd.conf> <pa_cfg_ext_get>
+wlanconfig ethX hostcmd <hostcmd.conf> <pa_cfg_ext_set>
+wlanconfig ethX hostcmd <hostcmd.conf> <arp_filter>
+wlanconfig ethX hostcmd <hostcmd.conf> <auto_tx_get>
+wlanconfig ethX hostcmd <hostcmd.conf> <NatKeepAlive>
+wlanconfig ethX hostcmd <hostcmd.conf> <auto_tx_unreg>
+wlanconfig ethX hostcmd <hostcmd.conf> <ledctrl_get>
+wlanconfig ethX hstest
+wlanconfig ethX getcfptable [region]
+
+Version 9
+wlanconfig ethX gettsf
+wlanconfig ethX arpfilter <arpfilter.conf>
+wlanconfig ethX txpktstats
+
+DESCRIPTION
+
+those commands are used in Marvell specic applicaion called wlanconfig.
+
+===========
+-v
+	This command is used to display the version of wlanconfig utility.
+	Usage:	
+		wlanconfig -v
+ 
+rdmac 
+rdbbp
+rdrf	
+	These commands are used to read the MAC, BBP and RF registers from the 
+	card.  These commands take one parameter that specifies the offset 
+	location that is to be read.  This parameter can be specified either in 
+	decimal or in hexadecimal (by preceding the number with a "0x").
+		
+	Usage:	
+		wlanconfig ethX rdmac 0xa123
+		wlanconfig ethX rdbbp 0x0123
+		wlanconfig ethX rdrf 0x0123
+
+wrmac 
+wrbbp
+wrrf	
+	These commands are used to write the MAC, BBP and RF registers in the 
+	card.  These commands take two parameters that specify the offset 
+	location and the value that is to be written. This parameters can be 
+	specified either in decimal or in hexadecimal (by preceding the number 
+	with a "0x").
+	
+	Usage:
+		wlanconfig ethX wrmac 0xa123 0xaa
+		wlanconfig ethX wrbbp 0x0123 0xaa
+		wlanconfig ethX wrrf 0x0123 0xaa
+
+sdcmd52r  
+	This command is used to read a controller register in 
+	Secure Digital I/O Interfaces.
+	
+	wlanconfig eth1 sdcmd52r <function number> <register address> 
+
+	Usage:
+		wlanconfig eth1 sdcmd52r 0x00 0x07
+
+sdcmd52w
+	This command is used to write to a controller register in 
+	Secure Digital I/O Interfaces. 
+	
+	wlanconfig eth1 sdcmd52w <function number> <register address> <value>
+
+	Usage:
+		wlanconfig eth1 sdcmd52w 0x00 0x02 0x0a
+
+caldataext
+	In order to overcome the situation without EEPROM in the WLAN module, 
+	we send the extension calibration command to modify the existing 
+	hardware-spec command. This command takes one parameter that specifies 
+	the file name of the configuration file.
+
+	Usage:
+	wlanconfig eth1 caldataext <cal_data_ext_set_<version>.conf>
+		cal_data_ext_set_<version>.conf is a configuration file to the 
+		wlanconfig to set the calibration values. The 3 existing 
+		versions are v5, vA and v7. 
+		Example:
+		  wlanconfig eth1 caldataext cal_data_ext_set_v5.conf
+		Edit this file for changing calibration values.			
+
+rdeeprom
+	To read the EEPROM contents of the card.
+	
+	Usage:
+	wlanconfig ethX rdeeprom 0x00 0x10
+	
+sleepparams       
+	This command is used to set the sleepclock configurations
+	
+	Usage:
+		wlanconfig ethX sleepparams get: reads the current sleepclock configuration
+	
+		wlanconfig ethX sleepparams set p1 p2 p3 p4 p5 p6: writes the sleepclock configuration.
+			
+		where:
+			p1 is Sleep clock error in ppm (0-65535)
+			p2 is Wakeup offset in usec (0-65535)
+			p3 is Clock stabilization time in usec (0-65535)
+			p4 is Control periodic calibration (0-2)
+			p5 is Control the use of external sleep clock (0-2)
+			p6 is reserved for debug (0-65535)
+
+bca-ts
+	This command is used to set/get the BCA timeshare parameters.
+ 
+	This command only works after BCA been enabled. 
+	
+	Usage:
+		wlanconfig ethX bca-ts <Traffic Type> <TimeShareInterval> <BTTime>
+
+		where:
+			Traffic Type 0 - Wlan and bluetooth are low priority.
+				     1 - Wlan and bluetooth are high priority.
+ 	
+			TimeShareInterval value is not multiple of 10 then floor value 
+			is taken and the valid range is < 20 ... 60,000 > in milliseconds.
+
+			BTTime value is  not multiple of 10 then floor value is
+			taken and the valid range is < 0 ... TimeShareInterval value >
+			in milliseconds.
+
+	Example:
+		wlanconfig ethX bca-ts get 1  
+				get the BCA timeshare settings when wlan and bluetooth are set to high priority.  
+
+		wlanconfig ethX bca-ts set 1 30 20
+				set wlan and bluetooth to high priority, wlan TimeShareInterval to 30ms, BTTime to 20ms.
+				
+
+bgscanconfig
+	This will configure the various parameters for background scan.
+
+	wlanconfig ethX bgscanconfig bg_scan_config.conf
+	
+	bg_scan_config.conf is the configuration file to wlanconfig
+	
+	Edit this file for changing bg scan values.
+
+hostcmd <hostcmd.conf> <subevent_get>
+hostcmd <hostcmd.conf> <subevent_set>
+	This command is used to set the configurations for 
+		event descriptor interface command.
+	hostcmd.conf is a generic configuration file containing multiple configuration enties
+		for subscrive event API
+	subsvent_get: get subscribed event parameters
+	subsvent_set: set subscribed event parameters
+
+	Usage:
+		wlanconfig ethX hostcmd hostcmd.conf subevent_get
+		wlanconfig ethX hostcmd hostcmd.conf subevent_set
+
+extscan
+	This command is used to do a specific scan.
+	
+	Usage: wlanconfig ethX extscan <SSID>
+
+	Example:
+		wlanconfig ethX extscan LINKSYS-AP
+
+	To see the results of use getscanlist command.
+
+getscanlist
+	This command is used to get the scan results.
+
+	Usage: wlanconfig ethX getscanlist
+		
+	Example:
+		wlanconfig ethX getscanlist
+
+setuserscan
+    Initiate a customized scan and retrieve the results
+
+    Usage:
+       wlanconfig ethX setuserscan [ARGS]
+
+         where [ARGS]: 
+
+      chan=[chan#][band][mode] where band is [a,b,g] and mode is 
+                               blank for active or 'p' for passive
+      bssid=xx:xx:xx:xx:xx:xx  specify a BSSID filter for the scan
+      ssid="[SSID]"            specify a SSID filter for the scan
+      wc="[WILDCARD SSID]"     specify a UNIX pattern matching filter (using *
+                               and ?) for SSIDs found in a broadcast probe 
+      keep=[0 or 1]            keep the previous scan results (1), discard (0)
+      dur=[scan time]          time to scan for each channel in milliseconds
+      probes=[#]               number of probe requests to send on each chan
+                               for each broadcast probe required and each SSID
+                               specific probe required
+      type=[1,2,3]             BSS type: 1 (Infra), 2(Adhoc), 3(Any)
+ 
+    Any combination of the above arguments can be supplied on the command line.
+      If the chan token is absent, a full channel scan will be completed by 
+      the driver.  If the dur or probes tokens are absent, the driver default
+      setting will be used.  The bssid and ssid fields, if blank, 
+      will produce an unfiltered scan. The type field will default to 3 (Any)
+      and the keep field will default to 0 (Discard).
+
+    Examples:
+    1) Perform an active scan on channels 1, 6, and 11 in the 'g' band:
+            setuserscan chan=1g,6g,11g
+
+    2) Perform a passive scan on channel 11 for 20 ms:
+            setuserscan chan=11gp dur=20
+
+    3) Perform an active scan on channels 1, 6, and 11; and a passive scan on
+       channel 36 in the 'a' band:
+            setuserscan chan=1g,6g,11g,36ap
+
+    4) Perform an active scan on channel 6 and 36 for a specific SSID:
+            setuserscan chan=6g,36a ssid="TestAP"
+
+    5) Scan all available channels (B/G, A bands) for a specific BSSID, keep
+       the current scan table intact, update existing or append new scan data:
+            setuserscan bssid=00:50:43:20:12:82 keep=1
+
+    6) Scan channel 6, for all infrastructure networks, sending two probe 
+       requests.  Keep the previous scan table intact. Update any duplicate
+       BSSID/SSID matches with the new scan data:
+            setuserscan chan=6g type=1 probes=2 keep=1
+
+    7) Scan channel 1 and 6, for all networks matching the Mrvl*AP
+       or AP*Mrvl? patterns and for MrvlTst SSID.  Generate 3 broadcast
+       probes for the patterns and 3 SSID specific probes for MrvlTst on
+       both channel 1 and channel 6.
+            chan=1g,6g probes=3 wc="Mrvl*AP" wc="AP*Mrvl?" ssid="MrvlTst"
+
+    All entries in the scan table (not just the new scan data when keep=1) 
+    will be displayed upon completion by use of the getscantable ioctl.
+
+getscantable
+    Display the current contents of the driver scan table
+
+    Usage:
+       wlanconfig ethX getscantable
+       wlanconfig ethX getscantable [#]
+       wlanconfig ethX getscantable tsf
+       wlanconfig ethX getscantable help
+
+    1) Without argument, the entire scantable is displayed.
+    2) Specifying a # will display detailed information about a specific scan
+       table entry.  '0' displays driver cached information regarding the 
+       current association (if any).
+    3) The tsf argument will display the entire scan table with the recorded
+       TSF timestamp for the entry.
+    4) The help argument will display the legend for the capability field
+
+getassocrsp
+    Display the contents of the driver association response buffer.  The 
+       driver buffer is cleared after the response is returned to prevent
+       state response buffer returns.
+
+    Usage:
+       wlanconfig ethX getassocrsp
+
+setmrvltlv
+    Setup a test Marvell TLV for the driver to insert in the next 
+       association command to the firmware.  
+
+    wlanconfig will provision a test TLV that can be verified in the assoc.
+       response to the AP.  Used to test the IOCTL functionality.
+
+    Usage:
+       wlanconfig ethX setmrvltlv
+
+addts
+    Send an ADDTS command to the associated AP.
+
+    Process a given conf file for a specific TSPEC data block.  Send the
+      TSPEC along with any other IEs to the driver/firmware for transmission
+      in an ADDTS request to the associated AP.  
+ 
+    Return the execution status of the command as well as the ADDTS response
+      from the AP if any.
+   
+    Usage:
+       wlanconfig ethX addts <filename.conf> <section# of tspec> <timeout(ms)>
+
+delts
+    Send a DELTS command to the associated AP.
+
+    Process a given conf file for a specific TSPEC data block.  Send the
+      TSPEC along with any other IEs to the driver/firmware for transmission
+      in a DELTS request to the associated AP.  
+ 
+    Return the execution status of the command.  There is no response to a
+      DELTS from the AP.
+   
+    Usage:
+       wlanconfig ethX delts <filename.conf> <section# of tspec>
+
+qconfig
+    Send a WMM AC Queue configuration command to get/set/default params
+ 
+    Configure or get the parameters of a WMM AC queue. The command takes
+      an optional Queue Id as a last parameter.  Without the queue id, all
+      queues will be acted upon.
+ 
+    Usage:  
+       wlanconfig ethX qconfig set msdu <lifetime in TUs> [Queue Id: 0-3]
+       wlanconfig ethX qconfig get [Queue Id: 0-3]
+       wlanconfig ethX qconfig def [Queue Id: 0-3]
+
+qstats
+    Turn on/off or retrieve and clear the queue statistics for an AC
+
+    Turn the queue statistics collection on/off for a given AC or retrieve the
+      current accumulated stats and clear them from the firmware.  The command
+      takes an optional Queue Id as a last parameter.  Without the queue id,
+      all queues will be acted upon.
+ 
+    Usage:
+       wlanconfig ethX qstats on  [Queue Id: 0-3]
+       wlanconfig ethX qstats off [Queue Id: 0-3]
+       wlanconfig ethX qstats get [Queue Id: 0-3]
+
+hostcmd <hostcmd.conf> <pa_cfg_ext_get>
+hostcmd <hostcmd.conf> <pa_cfg_ext_set>
+    This configures the power adaptation paramemters
+
+    Usage:
+	wlanconfig ethX hostcmd hostcmd.conf pa_cfg_ext_get
+	wlanconfig ethX hostcmd hostcmd.conf pa_cfg_ext_set
+	
+	hostcmd.conf is a generic configuration file containing multiple configuration enties
+		for power adapation
+	pa_cfg_ext_get: get pa_cfg_ext parameters
+	pa_cfg_ext_set: set pa_cfg_ext parameters
+	
+	The following table shows the bitmap of the rates (bit 0 is the least significant bit):
+
+		        Bit	Data rate
+			0	1 Mbps
+			1	2 Mbps
+			2	5.5 Mbps
+			3	11 Mbps
+			4	Reserved
+			5	6 Mbps
+			6	9 Mbps
+			7	12 Mbps
+			8	18 Mbps
+			9	24 Mbps
+			10	36 Mbps
+			11	48 Mbps
+			12	54 Mbps
+			13-15	Reserved
+
+	Up to 5 power level groups are supported.
+
+	The default power adaptation groups:
+
+		Power Level	Rate Bitmap (Mbps)
+		13 dbm		0x1800 (54, 48)
+		15 dbm		0x07e0 (36, 24, 18, 12, 9, 6)
+		18 dbm		0x000f (11, 5.5, 2, 1)
+
+	Edit the hostcmd.conf file to change the settings
+
+hostcmd <hostcmd.conf> <arp_filter>
+	This is an extended host_sleep_cfg command to configure the ARP filtering parameters.
+
+	Usage:
+		wlanconfig ethX hostcmd hostcmd.conf arp_filter
+
+	Edit the arp_filter section in hostcmd.conf file to change the settings
+
+hostcmd <hostcmd.conf> <auto_tx_get>
+hostcmd <hostcmd.conf> <NatKeepAlive>
+hostcmd <hostcmd.conf> <auto_tx_unreg>
+    This configures the Frame Auto Transmission paramemters
+
+    Usage:
+	wlanconfig ethX hostcmd hostcmd.conf auto_tx_get
+	wlanconfig ethX hostcmd hostcmd.conf NatKeepAlive
+	wlanconfig ethX hostcmd hostcmd.conf auto_tx_unreg
+	
+	hostcmd.conf is a generic configuration file containing multiple configuration enties
+		for Frame Auto Transmission
+	auto_tx_get: get auto_tx parameters
+	NatKeepAlive: register to firmware for sending NAT Keep Alive packet
+	auto_tx_unreg: unregister to firmware auto_tx
+	
+	Edit the auto_tx section in hostcmd.conf file to change the settings
+
+hostcmd <hostcmd.conf> <ledctrl_get>
+	This command is used to set/get LED control.
+
+	Usage:
+		wlanconfig ethX hostcmd hostcmd.conf ledctrl_get
+		wlanconfig ethX hostcmd hostcmd.conf ledctrl_set
+
+	hostcmd.conf is a generic configuration file containing multiple configuration enties
+		for LED Ctrl
+	led_ctrl_get: get auto_tx parameters
+	led_ctrl_set: set auto_tx parameters
+	
+	Edit the ledctrl section in hostcmd.conf file to change the settings
+	
+hstest
+    This command runs in the background to handle GPIO/SDIO interrupt events
+    in HOST SLEEP mode.
+
+    Usage:
+	wlanconfig ethX hstest &
+
+getcfptable
+	This command is used to get Channel-Freq-MaxTxPower table based on the region code.
+	If no parameter provided, the CFP table for current region code will be returned.
+
+	Usage:
+		wlanconfig ethX getcfptable [region]
+
+gettsf
+    Display the current MAC TSF value.
+
+arpfilter <arpfilter.conf>
+	This command is used to configure the ARP filtering parameters.
+
+	Usage:
+		wlanconfig ethX arpfilter arpfilter.conf
+
+	Edit arpfilter.conf file to change the settings
+
+txpktstats
+    Retrieve and clear transmit packet statistics collected by the firmware:
+
+    The API displays the following statistics for each rate:
+       - Number of packets initially queued using the rate
+       - Number of total attempts for the packets queued using this initial
+         rate.  This includes attempts at other rates in case of hardware or
+         single rate drop modes.
+       - Number of retry exhaustion failures for packets queued using this
+         initial rate.
+       - Number of MSDU lifetime expiry failures for packets queued using 
+         this initial rate.
+       - Number of packets successfully completed at this rate
+
+==============================================================================
Index: linux-2.6.29/drivers/net/wireless/marvell8686/host.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/host.h	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,349 @@
+/** @file host.h
+ * 
+ * @brief This file contains definitions of WLAN commands.
+ *  
+ *  Copyright  Marvell International Ltd. and/or its affiliates, 2003-2007
+ */
+/********************************************************
+Change log:
+    10/11/05: Add Doxygen format comments
+    01/11/06: Remove assoc response codes; full IEEE assoc resp now returned
+    04/06/06: Add TSPEC, queue metrics, and MSDU expiry support
+    04/10/06: Add power_adapt_cfg_ext command
+    04/18/06: Remove old Subscrive Event and add new Subscribe Event
+              implementation through generic hostcmd API
+    05/03/06: Add auto_tx hostcmd
+    05/04/06: Add IBSS coalescing related new hostcmd and event
+    08/28/06: Add LED_CTRL hostcmd
+********************************************************/
+
+#ifndef _HOST_H_
+#define _HOST_H_
+
+/** PUBLIC DEFINITIONS */
+#define DEFAULT_AD_HOC_CHANNEL       6
+#define DEFAULT_AD_HOC_CHANNEL_A    36
+/** The first valid channel for use */
+#define FIRST_VALID_CHANNEL	0xff
+
+/** IEEE 802.11 OIDs */
+#define OID_802_11_INFRASTRUCTURE_MODE        0x00008001
+#define OID_802_11_FRAGMENTATION_THRESHOLD    0x00008002
+#define OID_802_11_RTS_THRESHOLD              0x00008003
+#define OID_802_11_ADD_WEP                    0x00008004
+#define OID_802_11_REMOVE_WEP                 0x00008005
+#define OID_802_11_TX_RETRYCOUNT              0x00008006
+#define OID_802_11D_ENABLE                    0x00008007
+#define OID_802_11_DTIM                       0x00008009
+
+#define HostCmd_OPTION_WAITFORRSP             0x0002
+
+/** Host Command ID */
+#define HostCmd_CMD_GET_HW_SPEC               0x0003
+#define HostCmd_CMD_802_11_RESET              0x0005
+#define HostCmd_CMD_802_11_SCAN               0x0006
+#define HostCmd_CMD_802_11_GET_LOG            0x000b
+#define HostCmd_CMD_MAC_MULTICAST_ADR         0x0010
+#define HostCmd_CMD_802_11_EEPROM_ACCESS      0x0059
+#define HostCmd_CMD_802_11_ASSOCIATE          0x0012
+#define HostCmd_CMD_802_11_SET_WEP            0x0013
+#define HostCmd_CMD_802_11_SNMP_MIB           0x0016
+#define HostCmd_CMD_MAC_REG_ACCESS            0x0019
+#define HostCmd_CMD_BBP_REG_ACCESS            0x001a
+#define HostCmd_CMD_RF_REG_ACCESS             0x001b
+#define HostCmd_CMD_802_11_RADIO_CONTROL      0x001c
+#define HostCmd_CMD_802_11_RF_CHANNEL         0x001d
+#define HostCmd_CMD_802_11_RF_TX_POWER        0x001e
+#define HostCmd_CMD_802_11_RSSI               0x001f
+#define HostCmd_CMD_802_11_RF_ANTENNA         0x0020
+
+#define HostCmd_CMD_802_11_PS_MODE	      0x0021
+
+#define HostCmd_CMD_802_11_DEAUTHENTICATE     0x0024
+#define HostCmd_CMD_MAC_CONTROL               0x0028
+#define HostCmd_CMD_802_11_AD_HOC_START       0x002b
+#define HostCmd_CMD_802_11_AD_HOC_JOIN        0x002c
+
+#define HostCmd_CMD_802_11_KEY_MATERIAL       0x005e
+
+#define HostCmd_CMD_802_11_DEEP_SLEEP         0x003e
+
+#define HostCmd_CMD_802_11_AD_HOC_STOP        0x0040
+
+#define HostCmd_CMD_802_11_HOST_SLEEP_CFG     0x0043
+#define HostCmd_CMD_802_11_WAKEUP_CONFIRM     0x0044
+#define HostCmd_CMD_802_11_HOST_SLEEP_ACTIVATE	0x0045
+
+#define HostCmd_CMD_802_11_MAC_ADDRESS        0x004D
+#define HostCmd_CMD_802_11_EEPROM_ACCESS      0x0059
+
+#define HostCmd_CMD_802_11_BAND_CONFIG        0x0058
+
+#define HostCmd_CMD_802_11D_DOMAIN_INFO       0x005b
+
+#define HostCmd_CMD_802_11_SLEEP_PARAMS          0x0066
+
+#define HostCmd_CMD_802_11_INACTIVITY_TIMEOUT    0x0067
+
+#define HostCmd_CMD_802_11_SLEEP_PERIOD          0x0068
+#define HostCmd_CMD_802_11_BCA_CONFIG_TIMESHARE  0x0069
+
+#define HostCmd_CMD_802_11_BG_SCAN_CONFIG        0x006b
+#define HostCmd_CMD_802_11_BG_SCAN_QUERY         0x006c
+
+#define HostCmd_CMD_802_11_CAL_DATA_EXT          0x006d
+
+#define HostCmd_CMD_WMM_ADDTS_REQ                0x006E
+#define HostCmd_CMD_WMM_DELTS_REQ                0x006F
+#define HostCmd_CMD_WMM_QUEUE_CONFIG             0x0070
+#define HostCmd_CMD_WMM_GET_STATUS               0x0071
+
+#define HostCmd_CMD_802_11_TPC_CFG               0x0072
+
+#define HostCmd_CMD_802_11_FW_WAKE_METHOD        0x0074
+
+#define HostCmd_CMD_802_11_LED_CONTROL           0x004e
+
+#define HostCmd_CMD_802_11_SUBSCRIBE_EVENT       0x0075
+
+#define HostCmd_CMD_802_11_RATE_ADAPT_RATESET    0x0076
+
+#define HostCmd_CMD_802_11_TX_RATE_QUERY	0x007f
+
+#define HostCmd_CMD_802_11_POWER_ADAPT_CFG_EXT	0x007e
+
+#define HostCmd_CMD_GET_TSF                      0x0080
+
+#define HostCmd_CMD_WMM_QUEUE_STATS              0x0081
+
+#define HostCmd_CMD_802_11_AUTO_TX		0x0082
+#define HostCmd_CMD_802_11_IBSS_COALESCING_STATUS 0x0083
+
+#define HostCmd_CMD_MEM_ACCESS			0x0086
+
+#define HostCmd_CMD_SDIO_GPIO_INT_CONFIG	(0x0088)
+
+#ifdef MFG_CMD_SUPPORT
+#define HostCmd_CMD_MFG_COMMAND               0x0089
+#define HostCmd_RET_MFG_COMMAND               0x8089
+#endif
+
+#define HostCmd_CMD_TX_PKT_STATS              0x008d
+
+#define HostCmd_CMD_SDIO_PULL_CTRL		      0x0093
+
+#define HostCmd_CMD_802_11_LDO_CONFIG         0x0096
+
+#define HostCmd_CMD_VERSION_EXT               0x0097
+
+/* For the IEEE Power Save */
+#define HostCmd_SubCmd_Enter_PS               0x0030
+#define HostCmd_SubCmd_Exit_PS                0x0031
+#define HostCmd_SubCmd_Sleep_Confirmed        0x0034
+#define HostCmd_SubCmd_Full_PowerDown         0x0035
+#define HostCmd_SubCmd_Full_PowerUp           0x0036
+
+/* Command RET code, MSB is set to 1 */
+#define HostCmd_RET_HW_SPEC_INFO              0x8003
+#define HostCmd_RET_802_11_RESET              0x8005
+#define HostCmd_RET_802_11_SCAN               0x8006
+#define HostCmd_RET_802_11_GET_LOG            0x800b
+#define HostCmd_RET_MAC_CONTROL               0x8028
+#define HostCmd_RET_MAC_MULTICAST_ADR         0x8010
+#define HostCmd_RET_802_11_DEAUTHENTICATE     0x8024
+#define HostCmd_RET_802_11_ASSOCIATE          0x8012
+#define HostCmd_RET_802_11_SET_WEP            0x8013
+#define HostCmd_RET_802_3_STAT                0x8015
+#define HostCmd_RET_802_11_SNMP_MIB           0x8016
+#define HostCmd_RET_MAC_REG_ACCESS            0x8019
+#define HostCmd_RET_BBP_REG_ACCESS            0x801a
+#define HostCmd_RET_RF_REG_ACCESS             0x801b
+#define HostCmd_RET_802_11_RADIO_CONTROL      0x801c
+#define HostCmd_RET_802_11_RF_CHANNEL         0x801d
+#define HostCmd_RET_802_11_RSSI               0x801f
+#define HostCmd_RET_802_11_RF_TX_POWER        0x801e
+#define HostCmd_RET_802_11_RF_ANTENNA         0x8020
+#define HostCmd_RET_802_11_PS_MODE            0x8021
+
+#define HostCmd_RET_802_11_AD_HOC_START       0x802B
+#define HostCmd_RET_802_11_AD_HOC_JOIN        0x802C
+
+#define HostCmd_RET_802_11_KEY_MATERIAL       0x805e
+
+#define HostCmd_ACT_SET                       0x0001
+#define HostCmd_ACT_GET                       0x0000
+
+#define HostCmd_RET_802_11_AD_HOC_STOP        0x8040
+
+#define HostCmd_RET_802_11_HOST_SLEEP_CFG     0x8043
+#define HostCmd_RET_802_11_WAKEUP_CONFIRM     0x8044
+#define HostCmd_RET_802_11_HOST_SLEEP_ACTIVATE	0x8045
+
+#define HostCmd_RET_802_11_MAC_ADDRESS        0x804D
+#define HostCmd_RET_802_11_EEPROM_ACCESS      0x8059
+
+#define HostCmd_RET_802_11_BAND_CONFIG        0x8058
+
+#define HostCmd_RET_802_11_SLEEP_PARAMS          0x8066
+
+#define HostCmd_RET_802_11_INACTIVITY_TIMEOUT    0x8067
+
+#define HostCmd_RET_802_11_SLEEP_PERIOD          0x8068
+#define HostCmd_RET_802_11_BCA_CONFIG_TIMESHARE  0x8069
+
+#define HostCmd_RET_802_11D_DOMAIN_INFO          0x805B
+
+#define HostCmd_RET_802_11_BG_SCAN_CONFIG    0x806b
+#define HostCmd_RET_802_11_BG_SCAN_QUERY     0x806c
+
+#define HostCmd_RET_802_11_CAL_DATA_EXT      0x806d
+
+#define HostCmd_RET_WMM_ADDTS_REQ            0x806E
+#define HostCmd_RET_WMM_DELTS_REQ            0x806F
+#define HostCmd_RET_WMM_QUEUE_CONFIG         0x8070
+#define HostCmd_RET_WMM_GET_STATUS           0x8071
+
+#define HostCmd_RET_802_11_TPC_CFG           0x8072
+
+#define HostCmd_RET_802_11_LED_CONTROL       0x804e
+
+#define HostCmd_RET_802_11_FW_WAKE_METHOD    0x8074
+
+#define HostCmd_RET_802_11_SUBSCRIBE_EVENT   0x8075
+
+#define HostCmd_RET_802_11_RATE_ADAPT_RATESET	0x8076
+
+#define HostCmd_RTE_802_11_TX_RATE_QUERY 	0x807f
+
+#define HostCmd_RET_GET_TSF             	0x8080
+
+#define HostCmd_RET_WMM_QUEUE_STATS     	0x8081
+
+#define HostCmd_RET_802_11_POWER_ADAPT_CFG_EXT	0x807e
+
+#define HostCmd_RET_802_11_AUTO_TX		0x8082
+
+#define HostCmd_RET_802_11_IBSS_COALESCING_STATUS	0x8083
+
+#define HostCmd_RET_MEM_ACCESS		      0x8086
+
+#define	HostCmd_RET_SDIO_GPIO_INT_CONFIG		(0x8088)
+
+#define HostCmd_RET_TX_PKT_STATS              0x808d
+
+#define HostCmd_RET_SDIO_PULL_CTRL		0x8093
+
+#define HostCmd_RET_802_11_LDO_CONFIG         0x8096
+
+#define HostCmd_RET_VERSION_EXT               0x8097
+
+/** General Result Code*/
+/* OK */
+#define HostCmd_RESULT_OK                    0x0000
+/* Genenral error */
+#define HostCmd_RESULT_ERROR                 0x0001
+/* Command is not valid */
+#define HostCmd_RESULT_NOT_SUPPORT           0x0002
+/* Command is pending */
+#define HostCmd_RESULT_PENDING               0x0003
+/* System is busy (command ignored) */
+#define HostCmd_RESULT_BUSY                  0x0004
+/* Data buffer is not big enough */
+#define HostCmd_RESULT_PARTIAL_DATA          0x0005
+
+/* Definition of action or option for each command */
+
+/* Define general purpose action */
+#define HostCmd_ACT_GEN_READ                    0x0000
+#define HostCmd_ACT_GEN_WRITE                   0x0001
+#define HostCmd_ACT_GEN_GET                     0x0000
+#define HostCmd_ACT_GEN_SET                     0x0001
+#define HostCmd_ACT_GEN_REMOVE                  0x0002
+#define HostCmd_ACT_GEN_OFF                     0x0000
+#define HostCmd_ACT_GEN_ON                      0x0001
+
+/* Define action or option for HostCmd_CMD_802_11_SET_WEP */
+#define HostCmd_ACT_ADD                         0x0002
+#define HostCmd_ACT_REMOVE                      0x0004
+
+#define HostCmd_TYPE_WEP_40_BIT                 0x0001
+#define HostCmd_TYPE_WEP_104_BIT                0x0002
+
+#define HostCmd_WEP_KEY_INDEX_MASK              0x3fff
+
+/* Define action or option for HostCmd_CMD_802_11_SCAN */
+#define HostCmd_BSS_TYPE_BSS                    0x0001
+#define HostCmd_BSS_TYPE_IBSS                   0x0002
+#define HostCmd_BSS_TYPE_ANY                    0x0003
+
+/* Define action or option for HostCmd_CMD_802_11_SCAN */
+#define HostCmd_SCAN_TYPE_ACTIVE                0x0000
+#define HostCmd_SCAN_TYPE_PASSIVE               0x0001
+
+/* Radio type definitions for the channel TLV */
+#define HostCmd_SCAN_RADIO_TYPE_BG		0
+#define HostCmd_SCAN_RADIO_TYPE_A		1
+
+/* Define action or option for HostCmd_CMD_MAC_CONTROL */
+#define HostCmd_ACT_MAC_RX_ON                   0x0001
+#define HostCmd_ACT_MAC_TX_ON                   0x0002
+#define HostCmd_ACT_MAC_LOOPBACK_ON             0x0004
+#define HostCmd_ACT_MAC_WEP_ENABLE              0x0008
+#define HostCmd_ACT_MAC_ETHERNETII_ENABLE       0x0010
+#define HostCmd_ACT_MAC_PROMISCUOUS_ENABLE      0x0080
+#define HostCmd_ACT_MAC_ALL_MULTICAST_ENABLE    0x0100
+#define HostCmd_ACT_MAC_RTS_CTS_ENABLE			0x0200
+#define HostCmd_ACT_MAC_STRICT_PROTECTION_ENABLE  0x0400
+#define HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON	  0x2000
+
+/* Define action or option or constant for HostCmd_CMD_MAC_MULTICAST_ADR */
+#define HostCmd_SIZE_MAC_ADR                    6
+#define HostCmd_MAX_MCAST_ADRS                  32
+
+#define RADIO_ON                                0x01
+#define RADIO_OFF                               0x00
+
+/* Define action or option for CMD_802_11_RF_CHANNEL */
+#define HostCmd_OPT_802_11_RF_CHANNEL_GET       0x00
+#define HostCmd_OPT_802_11_RF_CHANNEL_SET       0x01
+
+#define HostCmd_ACT_SET_RX                      0x0001
+#define HostCmd_ACT_SET_TX                      0x0002
+#define HostCmd_ACT_SET_BOTH                    0x0003
+#define HostCmd_ACT_GET_RX                      0x0004
+#define HostCmd_ACT_GET_TX                      0x0008
+#define HostCmd_ACT_GET_BOTH                    0x000c
+
+/** Card Event definition */
+#define MACREG_INT_CODE_DUMMY_HOST_WAKEUP_SIGNAL       0x00000001
+#define MACREG_INT_CODE_LINK_LOST_WITH_SCAN     0x00000002
+#define MACREG_INT_CODE_LINK_LOST       	0x00000003
+#define MACREG_INT_CODE_LINK_SENSED             0x00000004
+#define MACREG_INT_CODE_MIB_CHANGED             0x00000006
+#define MACREG_INT_CODE_INIT_DONE               0x00000007
+#define MACREG_INT_CODE_DEAUTHENTICATED         0x00000008
+#define MACREG_INT_CODE_DISASSOCIATED           0x00000009
+#define MACREG_INT_CODE_PS_AWAKE                0x0000000a
+#define MACREG_INT_CODE_PS_SLEEP                0x0000000b
+#define MACREG_INT_CODE_MIC_ERR_MULTICAST       0x0000000d
+#define MACREG_INT_CODE_MIC_ERR_UNICAST         0x0000000e
+#define MACREG_INT_CODE_WM_AWAKE                0x0000000f
+#define MACREG_INT_CODE_DEEP_SLEEP_AWAKE        0x00000010
+#define MACREG_INT_CODE_ADHOC_BCN_LOST          0x00000011
+#define MACREG_INT_CODE_HOST_SLEEP_AWAKE        0x00000012
+#define MACREG_INT_CODE_WMM_STATUS_CHANGE	0x00000017
+#define MACREG_INT_CODE_BG_SCAN_REPORT		0x00000018
+#define MACREG_INT_CODE_RSSI_LOW		0x00000019
+#define MACREG_INT_CODE_SNR_LOW			0x0000001a
+#define MACREG_INT_CODE_MAX_FAIL		0x0000001b
+#define MACREG_INT_CODE_RSSI_HIGH		0x0000001c
+#define MACREG_INT_CODE_SNR_HIGH		0x0000001d
+#define MACREG_INT_CODE_IBSS_COALESCED		0x0000001e
+#define MACREG_INT_CODE_PRE_BEACON_LOST		0x00000031
+
+/* Define bitmap conditions for HOST_SLEEP_CFG */
+#define HOST_SLEEP_CFG_CANCEL			0xffffffff
+#define HOST_SLEEP_CFG_WAKEUP_THRU_INTERFACE	0xff
+#define HOST_SLEEP_CFG_GAP_FF			0xff
+
+#endif /* _HOST_H_ */
Index: linux-2.6.29/drivers/net/wireless/marvell8686/hostcmd.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/hostcmd.h	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,1052 @@
+/** @file hostcmd.h
+ * 
+ * @brief This file contains the function prototypes, data structure 
+ * and defines for all the host/station commands
+ *  
+ *  Copyright  Marvell International Ltd. and/or its affiliates, 2003-2007
+ */
+/********************************************************
+Change log:
+	10/11/05: Add Doxygen format comments
+	01/11/06: Update association struct to reflect IEEE passthrough response
+	          Conditionalize new scan/join structures
+	04/10/06: Add hostcmd generic API and power_adapt_cfg_ext command
+	04/18/06: Remove old Subscrive Event and add new Subscribe Event
+	          implementation through generic hostcmd API
+	05/03/06: Add auto_tx hostcmd
+	05/04/06: Add IBSS coalescing related new hostcmd
+	08/28/06: Add LED_CTRL hostcmd
+	08/29/06: Add ledgpio private command
+********************************************************/
+
+#ifndef __HOSTCMD__H
+#define __HOSTCMD__H
+
+/*  802.11-related definitions */
+
+/** TxPD descriptor */
+typedef struct _TxPD
+{
+    /** Current Tx packet status */
+    u32 TxStatus;
+    /** Tx Control */
+    u32 TxControl;
+    u32 TxPacketLocation;
+    /** Tx packet length */
+    u16 TxPacketLength;
+        /**Destination MAC address */
+    u8 TxDestAddr[MRVDRV_ETH_ADDR_LEN];
+    /** Pkt Priority */
+    u8 Priority;
+    /** Trasnit Pkt Flags*/
+    u8 Flags;
+    /** Amount of time the packet has been queued in the driver (units = 2ms)*/
+    u8 PktDelay_2ms;
+    /** Reserved */
+    u8 Reserved1;
+
+} __ATTRIB_PACK__ TxPD, *PTxPD;
+
+/** RxPD Descriptor */
+typedef struct _RxPD
+{
+        /** Current Rx packet status */
+    u16 RxStatus;
+
+        /** SNR */
+    u8 SNR;
+
+        /** Tx Control */
+    u8 RxControl;
+
+        /** Pkt Length */
+    u16 PktLen;
+
+        /** Noise Floor */
+    u8 NF;
+
+        /** Rx Packet Rate */
+    u8 RxRate;
+
+        /** Pkt offset */
+    u32 PktOffset;
+    u8 RxPacketType;
+    u8 Reserved_1[3];
+        /** Pkt Priority */
+    u8 Priority;
+    u8 Reserved[3];
+
+} __ATTRIB_PACK__ RxPD, *PRxPD;
+
+#if defined(__KERNEL__)
+
+/** CmdCtrlNode */
+typedef struct _CmdCtrlNode
+{
+    /* CMD link list */
+    struct list_head list;
+
+    u32 Status;
+
+    /* CMD ID */
+    WLAN_OID cmd_oid;
+
+    /*CMD wait option: wait for finish or no wait */
+    u16 wait_option;
+
+    /* command parameter */
+    void *pdata_buf;
+
+    /*command data */
+    u8 *BufVirtualAddr;
+
+    u16 CmdFlags;
+
+    /* wait queue */
+    u16 CmdWaitQWoken;
+    wait_queue_head_t cmdwait_q __ATTRIB_ALIGN__;
+} __ATTRIB_PACK__ CmdCtrlNode, *PCmdCtrlNode;
+
+#endif
+
+/** MRVL_WEP_KEY */
+typedef struct _MRVL_WEP_KEY
+{
+    u32 Length;
+    u32 KeyIndex;
+    u32 KeyLength;
+    u8 KeyMaterial[MRVL_KEY_BUFFER_SIZE_IN_BYTE];
+} __ATTRIB_PACK__ MRVL_WEP_KEY, *PMRVL_WEP_KEY;
+
+typedef ULONGLONG WLAN_802_11_KEY_RSC;
+
+/** WLAN_802_11_KEY */
+typedef struct _WLAN_802_11_KEY
+{
+    u32 Length;
+    u32 KeyIndex;
+    u32 KeyLength;
+    WLAN_802_11_MAC_ADDRESS BSSID;
+    WLAN_802_11_KEY_RSC KeyRSC;
+    u8 KeyMaterial[MRVL_MAX_KEY_WPA_KEY_LENGTH];
+} __ATTRIB_PACK__ WLAN_802_11_KEY;
+
+/** MRVL_WPA_KEY */
+typedef struct _MRVL_WPA_KEY
+{
+    u32 KeyIndex;
+    u32 KeyLength;
+    u32 KeyRSC;
+    u8 KeyMaterial[MRVL_MAX_KEY_WPA_KEY_LENGTH];
+} MRVL_WPA_KEY, *PMRVL_WPA_KEY;
+
+/** MRVL_WLAN_WPA_KEY */
+typedef struct _MRVL_WLAN_WPA_KEY
+{
+    u8 EncryptionKey[16];
+    u8 MICKey1[8];
+    u8 MICKey2[8];
+} MRVL_WLAN_WPA_KEY, *PMRVL_WLAN_WPA_KEY;
+
+/* Received Signal Strength Indication  in dBm*/
+typedef LONG WLAN_802_11_RSSI;
+
+/** WLAN_802_11_WEP */
+typedef struct _WLAN_802_11_WEP
+{
+    /* Length of this structure */
+    u32 Length;
+
+    /* 0 is the per-client key, 1-N are the global keys */
+    u32 KeyIndex;
+
+    /* length of key in bytes */
+    u32 KeyLength;
+
+    /* variable length depending on above field */
+    u8 KeyMaterial[1];
+} __ATTRIB_PACK__ WLAN_802_11_WEP;
+
+/** WLAN_802_11_SSID */
+typedef struct _WLAN_802_11_SSID
+{
+    /* SSID Length */
+    u32 SsidLength;
+
+    /* SSID information field */
+    u8 Ssid[WLAN_MAX_SSID_LENGTH];
+} __ATTRIB_PACK__ WLAN_802_11_SSID;
+
+typedef u32 WLAN_802_11_FRAGMENTATION_THRESHOLD;
+typedef u32 WLAN_802_11_RTS_THRESHOLD;
+typedef u32 WLAN_802_11_ANTENNA;
+
+/** wlan_offset_value */
+typedef struct _wlan_offset_value
+{
+    u32 offset;
+    u32 value;
+} wlan_offset_value;
+
+/** WLAN_802_11_FIXED_IEs */
+typedef struct _WLAN_802_11_FIXED_IEs
+{
+    u8 Timestamp[8];
+    u16 BeaconInterval;
+    u16 Capabilities;
+} WLAN_802_11_FIXED_IEs;
+
+/** WLAN_802_11_VARIABLE_IEs */
+typedef struct _WLAN_802_11_VARIABLE_IEs
+{
+    u8 ElementID;
+    u8 Length;
+    u8 data[1];
+} WLAN_802_11_VARIABLE_IEs;
+
+/** WLAN_802_11_AI_RESFI */
+typedef struct _WLAN_802_11_AI_RESFI
+{
+    u16 Capabilities;
+    u16 StatusCode;
+    u16 AssociationId;
+} WLAN_802_11_AI_RESFI;
+
+/** WLAN_802_11_AI_REQFI */
+typedef struct _WLAN_802_11_AI_REQFI
+{
+    u16 Capabilities;
+    u16 ListenInterval;
+    WLAN_802_11_MAC_ADDRESS CurrentAPAddress;
+} WLAN_802_11_AI_REQFI;
+
+/* Define general data structure */
+/** HostCmd_DS_GEN */
+typedef struct _HostCmd_DS_GEN
+{
+    u16 Command;
+    u16 Size;
+    u16 SeqNum;
+    u16 Result;
+} __ATTRIB_PACK__ HostCmd_DS_GEN, HostCmd_DS_802_11_DEEP_SLEEP;
+
+#define S_DS_GEN    sizeof(HostCmd_DS_GEN)
+/*
+ * Define data structure for HostCmd_CMD_GET_HW_SPEC
+ * This structure defines the response for the GET_HW_SPEC command
+ */
+/** HostCmd_DS_GET_HW_SPEC */
+typedef struct _HostCmd_DS_GET_HW_SPEC
+{
+    /* HW Interface version number */
+    u16 HWIfVersion;
+
+    /* HW version number */
+    u16 Version;
+
+    /* Max number of TxPD FW can handle */
+    u16 NumOfTxPD;
+
+    /* Max no of Multicast address  */
+    u16 NumOfMCastAdr;
+
+    /* MAC address */
+    u8 PermanentAddr[6];
+
+    /* Region Code */
+    u16 RegionCode;
+
+    /* Number of antenna used */
+    u16 NumberOfAntenna;
+
+    /* FW release number, example 0x1234=1.2.3.4 */
+    u32 FWReleaseNumber;
+
+    u32 Reserved_1;
+
+    u32 Reserved_2;
+
+    u32 Reserved_3;
+
+    /*FW/HW Capability */
+    u32 fwCapInfo;
+} __ATTRIB_PACK__ HostCmd_DS_GET_HW_SPEC;
+
+typedef struct _HostCmd_DS_802_11_SUBSCRIBE_EVENT
+{
+    u16 Action;
+    u16 Events;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_SUBSCRIBE_EVENT;
+
+/* 
+ * This scan handle Country Information IE(802.11d compliant) 
+ * Define data structure for HostCmd_CMD_802_11_SCAN 
+ */
+/** HostCmd_DS_802_11_SCAN */
+typedef struct _HostCmd_DS_802_11_SCAN
+{
+    u8 BSSType;
+    u8 BSSID[ETH_ALEN];
+    u8 TlvBuffer[1];
+    /* MrvlIEtypes_SsIdParamSet_t   SsIdParamSet; 
+     * MrvlIEtypes_ChanListParamSet_t       ChanListParamSet;
+     * MrvlIEtypes_RatesParamSet_t  OpRateSet; 
+     * */
+} __ATTRIB_PACK__ HostCmd_DS_802_11_SCAN;
+
+typedef struct _HostCmd_DS_802_11_SCAN_RSP
+{
+    u16 BSSDescriptSize;
+    u8 NumberOfSets;
+    u8 BssDescAndTlvBuffer[1];
+
+} __ATTRIB_PACK__ HostCmd_DS_802_11_SCAN_RSP;
+
+/** HostCmd_CMD_802_11_GET_LOG */
+typedef struct _HostCmd_DS_802_11_GET_LOG
+{
+    u32 mcasttxframe;
+    u32 failed;
+    u32 retry;
+    u32 multiretry;
+    u32 framedup;
+    u32 rtssuccess;
+    u32 rtsfailure;
+    u32 ackfailure;
+    u32 rxfrag;
+    u32 mcastrxframe;
+    u32 fcserror;
+    u32 txframe;
+    u32 reserved;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_GET_LOG;
+
+/**  HostCmd_CMD_MAC_CONTROL */
+typedef struct _HostCmd_DS_MAC_CONTROL
+{
+    u16 Action;
+    u16 Reserved;
+} __ATTRIB_PACK__ HostCmd_DS_MAC_CONTROL;
+
+/**  HostCmd_CMD_MAC_MULTICAST_ADR */
+typedef struct _HostCmd_DS_MAC_MULTICAST_ADR
+{
+    u16 Action;
+    u16 NumOfAdrs;
+    u8 MACList[MRVDRV_ETH_ADDR_LEN * MRVDRV_MAX_MULTICAST_LIST_SIZE];
+} __ATTRIB_PACK__ HostCmd_DS_MAC_MULTICAST_ADR;
+
+/**  HostCmd_CMD_802_11_DEAUTHENTICATE */
+typedef struct _HostCmd_DS_802_11_DEAUTHENTICATE
+{
+    u8 MacAddr[6];
+    u16 ReasonCode;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_DEAUTHENTICATE;
+
+/** HostCmd_DS_802_11_ASSOCIATE */
+typedef struct _HostCmd_DS_802_11_ASSOCIATE
+{
+    u8 PeerStaAddr[6];
+    IEEEtypes_CapInfo_t CapInfo;
+    u16 ListenInterval;
+    u8 Reserved1[3];
+
+    /*
+     *  MrvlIEtypes_SsIdParamSet_t  SsIdParamSet;
+     *  MrvlIEtypes_PhyParamSet_t   PhyParamSet;
+     *  MrvlIEtypes_SsParamSet_t    SsParamSet;
+     *  MrvlIEtypes_RatesParamSet_t RatesParamSet;
+     */
+} __ATTRIB_PACK__ HostCmd_DS_802_11_ASSOCIATE;
+
+/** HostCmd_RET_802_11_ASSOCIATE */
+typedef struct
+{
+    IEEEtypes_AssocRsp_t assocRsp;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_ASSOCIATE_RSP;
+
+/**  HostCmd_RET_802_11_AD_HOC_JOIN */
+typedef struct _HostCmd_DS_802_11_AD_HOC_RESULT
+{
+    u8 PAD[3];
+    u8 BSSID[MRVDRV_ETH_ADDR_LEN];
+} __ATTRIB_PACK__ HostCmd_DS_802_11_AD_HOC_RESULT;
+
+/**  HostCmd_CMD_802_11_SET_WEP */
+typedef struct _HostCmd_DS_802_11_SET_WEP
+{
+    /* ACT_ADD, ACT_REMOVE or ACT_ENABLE  */
+    u16 Action;
+
+    /* Key Index selected for Tx */
+    u16 KeyIndex;
+
+    /* 40, 128bit or TXWEP */
+    u8 WEPTypeForKey1;
+
+    u8 WEPTypeForKey2;
+    u8 WEPTypeForKey3;
+    u8 WEPTypeForKey4;
+    u8 WEP1[16];
+    u8 WEP2[16];
+    u8 WEP3[16];
+    u8 WEP4[16];
+} __ATTRIB_PACK__ HostCmd_DS_802_11_SET_WEP;
+
+/** HostCmd_DS_802_11_AD_HOC_STOP */
+typedef struct _HostCmd_DS_802_11_AD_HOC_STOP
+{
+
+} __ATTRIB_PACK__ HostCmd_DS_802_11_AD_HOC_STOP;
+
+/**  HostCmd_CMD_802_11_SNMP_MIB */
+typedef struct _HostCmd_DS_802_11_SNMP_MIB
+{
+    u16 QueryType;
+    u16 OID;
+    u16 BufSize;
+    u8 Value[128];
+} __ATTRIB_PACK__ HostCmd_DS_802_11_SNMP_MIB;
+
+/** HostCmd_CMD_MAC_REG_ACCESS */
+typedef struct _HostCmd_DS_MAC_REG_ACCESS
+{
+    u16 Action;
+    u16 Offset;
+    u32 Value;
+} __ATTRIB_PACK__ HostCmd_DS_MAC_REG_ACCESS;
+
+/** HostCmd_CMD_BBP_REG_ACCESS */
+typedef struct _HostCmd_DS_BBP_REG_ACCESS
+{
+    u16 Action;
+    u16 Offset;
+    u8 Value;
+    u8 Reserved[3];
+} __ATTRIB_PACK__ HostCmd_DS_BBP_REG_ACCESS;
+
+/**  HostCmd_CMD_RF_REG_ACCESS */
+typedef struct _HostCmd_DS_RF_REG_ACCESS
+{
+    u16 Action;
+    u16 Offset;
+    u8 Value;
+    u8 Reserved[3];
+} __ATTRIB_PACK__ HostCmd_DS_RF_REG_ACCESS;
+
+/** HostCmd_CMD_802_11_RADIO_CONTROL */
+typedef struct _HostCmd_DS_802_11_RADIO_CONTROL
+{
+    u16 Action;
+    u16 Control;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_RADIO_CONTROL;
+
+/* HostCmd_DS_802_11_SLEEP_PARAMS */
+typedef struct _HostCmd_DS_802_11_SLEEP_PARAMS
+{
+    /* ACT_GET/ACT_SET */
+    u16 Action;
+
+    /* Sleep clock error in ppm */
+    u16 Error;
+
+    /* Wakeup offset in usec */
+    u16 Offset;
+
+    /* Clock stabilization time in usec */
+    u16 StableTime;
+
+    /* Control periodic calibration */
+    u8 CalControl;
+
+    /* Control the use of external sleep clock */
+    u8 ExternalSleepClk;
+
+    /* Reserved field, should be set to zero */
+    u16 Reserved;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_SLEEP_PARAMS;
+
+/* HostCmd_DS_802_11_SLEEP_PERIOD */
+typedef struct _HostCmd_DS_802_11_SLEEP_PERIOD
+{
+    /* ACT_GET/ACT_SET */
+    u16 Action;
+
+    /* Sleep Period in msec */
+    u16 Period;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_SLEEP_PERIOD;
+
+/* HostCmd_DS_802_11_BCA_TIMESHARE */
+typedef struct _HostCmd_DS_802_11_BCA_TIMESHARE
+{
+    /* ACT_GET/ACT_SET */
+    u16 Action;
+
+    /* Type: WLAN, BT */
+    u16 TrafficType;
+
+    /* 20msec - 60000msec */
+    u32 TimeShareInterval;
+
+    /* PTA arbiter time in msec */
+    u32 BTTime;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_BCA_TIMESHARE;
+
+/* HostCmd_DS_802_11_INACTIVITY_TIMEOUT */
+typedef struct _HostCmd_DS_802_11_INACTIVITY_TIMEOUT
+{
+    /* ACT_GET/ACT_SET */
+    u16 Action;
+
+    /* Inactivity timeout in msec */
+    u16 Timeout;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_INACTIVITY_TIMEOUT;
+
+/** HostCmd_CMD_802_11_RF_CHANNEL */
+typedef struct _HostCmd_DS_802_11_RF_CHANNEL
+{
+    u16 Action;
+    u16 CurrentChannel;
+    u16 RFType;
+    u16 Reserved;
+    u8 ChannelList[32];
+} __ATTRIB_PACK__ HostCmd_DS_802_11_RF_CHANNEL;
+
+/**  HostCmd_CMD_802_11_RSSI */
+typedef struct _HostCmd_DS_802_11_RSSI
+{
+    /* weighting factor */
+    u16 N;
+
+    u16 Reserved_0;
+    u16 Reserved_1;
+    u16 Reserved_2;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_RSSI;
+
+/** HostCmd_DS_802_11_RSSI_RSP */
+typedef struct _HostCmd_DS_802_11_RSSI_RSP
+{
+    u16 SNR;
+    u16 NoiseFloor;
+    u16 AvgSNR;
+    u16 AvgNoiseFloor;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_RSSI_RSP;
+
+/** HostCmd_DS_802_11_MAC_ADDRESS */
+typedef struct _HostCmd_DS_802_11_MAC_ADDRESS
+{
+    u16 Action;
+    u8 MacAdd[ETH_ALEN];
+} __ATTRIB_PACK__ HostCmd_DS_802_11_MAC_ADDRESS;
+
+/** HostCmd_CMD_802_11_RF_TX_POWER */
+typedef struct _HostCmd_DS_802_11_RF_TX_POWER
+{
+    u16 Action;
+    u16 CurrentLevel;
+    u8 MaxPower;
+    u8 MinPower;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_RF_TX_POWER;
+
+/** HostCmd_CMD_802_11_RF_ANTENNA */
+typedef struct _HostCmd_DS_802_11_RF_ANTENNA
+{
+    u16 Action;
+
+    /*  Number of antennas or 0xffff(diversity) */
+    u16 AntennaMode;
+
+} __ATTRIB_PACK__ HostCmd_DS_802_11_RF_ANTENNA;
+
+/** HostCmd_CMD_802_11_PS_MODE */
+typedef struct _HostCmd_DS_802_11_PS_MODE
+{
+    u16 Action;
+    u16 NullPktInterval;
+    u16 MultipleDtim;
+    u16 BCNMissTimeOut;
+    u16 LocalListenInterval;
+    u16 AdhocAwakePeriod;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_PS_MODE;
+
+/** PS_CMD_ConfirmSleep */
+typedef struct _PS_CMD_ConfirmSleep
+{
+    u16 Command;
+    u16 Size;
+    u16 SeqNum;
+    u16 Result;
+
+    u16 Action;
+    u16 Reserved1;
+    u16 MultipleDtim;
+    u16 Reserved;
+    u16 LocalListenInterval;
+} __ATTRIB_PACK__ PS_CMD_ConfirmSleep, *PPS_CMD_ConfirmSleep;
+
+/** HostCmd_CMD_802_11_FW_WAKE_METHOD */
+typedef struct _HostCmd_DS_802_11_FW_WAKEUP_METHOD
+{
+    u16 Action;
+    u16 Method;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_FW_WAKEUP_METHOD;
+
+/** HostCmd_DS_802_11_RATE_ADAPT_RATESET */
+typedef struct _HostCmd_DS_802_11_RATE_ADAPT_RATESET
+{
+    u16 Action;
+    u16 HWRateDropMode;
+    u16 Bitmap;
+    u16 Threshold;
+    u16 FinalRate;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_RATE_ADAPT_RATESET;
+
+/** HostCmd_DS_802_11_AD_HOC_START*/
+typedef struct _HostCmd_DS_802_11_AD_HOC_START
+{
+    u8 SSID[MRVDRV_MAX_SSID_LENGTH];
+    u8 BSSType;
+    u16 BeaconPeriod;
+    u8 DTIMPeriod;
+    IEEEtypes_SsParamSet_t SsParamSet;
+    IEEEtypes_PhyParamSet_t PhyParamSet;
+    u16 Reserved1;
+    IEEEtypes_CapInfo_t Cap;
+    u8 DataRate[HOSTCMD_SUPPORTED_RATES];
+} __ATTRIB_PACK__ HostCmd_DS_802_11_AD_HOC_START;
+
+/** AdHoc_BssDesc_t */
+typedef struct _AdHoc_BssDesc_t
+{
+    u8 BSSID[6];
+    u8 SSID[32];
+    u8 BSSType;
+    u16 BeaconPeriod;
+    u8 DTIMPeriod;
+    u8 TimeStamp[8];
+    u8 LocalTime[8];
+    IEEEtypes_PhyParamSet_t PhyParamSet;
+    IEEEtypes_SsParamSet_t SsParamSet;
+    IEEEtypes_CapInfo_t Cap;
+    u8 DataRates[HOSTCMD_SUPPORTED_RATES];
+
+    /* DO NOT ADD ANY FIELDS TO THIS STRUCTURE.      It is used below in the
+     *      Adhoc join command and will cause a binary layout mismatch with 
+     *      the firmware 
+     */
+} __ATTRIB_PACK__ AdHoc_BssDesc_t;
+
+/** HostCmd_DS_802_11_AD_HOC_JOIN */
+typedef struct _HostCmd_DS_802_11_AD_HOC_JOIN
+{
+    AdHoc_BssDesc_t BssDescriptor;
+    u16 Reserved1;
+    u16 Reserved2;
+
+} __ATTRIB_PACK__ HostCmd_DS_802_11_AD_HOC_JOIN;
+
+typedef union _KeyInfo_WEP_t
+{
+    u8 Reserved;
+
+    /* bits 1-4: Specifies the index of key */
+    u8 WepKeyIndex;
+
+    /* bit 0: Specifies that this key is 
+     * to be used as the default for TX data packets 
+     * */
+    u8 isWepDefaultKey;
+} __ATTRIB_PACK__ KeyInfo_WEP_t;
+
+typedef union _KeyInfo_TKIP_t
+{
+    u8 Reserved;
+
+    /* bit 2: Specifies that this key is 
+     * enabled and valid to use */
+    u8 isKeyEnabled;
+
+    /* bit 1: Specifies that this key is
+     * to be used as the unicast key */
+    u8 isUnicastKey;
+
+    /* bit 0: Specifies that this key is 
+     * to be used as the multicast key */
+    u8 isMulticastKey;
+} __ATTRIB_PACK__ KeyInfo_TKIP_t;
+
+typedef union _KeyInfo_AES_t
+{
+    u8 Reserved;
+
+    /* bit 2: Specifies that this key is
+     * enabled and valid to use */
+    u8 isKeyEnabled;
+
+    /* bit 1: Specifies that this key is
+     * to be used as the unicast key */
+    u8 isUnicastKey;
+
+    /* bit 0: Specifies that this key is 
+     * to be used as the multicast key */
+    u8 isMulticastKey;
+} __ATTRIB_PACK__ KeyInfo_AES_t;
+
+/** KeyMaterial_TKIP_t */
+typedef struct _KeyMaterial_TKIP_t
+{
+    /* TKIP encryption/decryption key */
+    u8 TkipKey[16];
+
+    /* TKIP TX MIC Key */
+    u8 TkipTxMicKey[16];
+
+    /* TKIP RX MIC Key */
+    u8 TkipRxMicKey[16];
+} __ATTRIB_PACK__ KeyMaterial_TKIP_t, *PKeyMaterial_TKIP_t;
+
+/** KeyMaterial_AES_t */
+typedef struct _KeyMaterial_AES_t
+{
+    /* AES encryption/decryption key */
+    u8 AesKey[16];
+} __ATTRIB_PACK__ KeyMaterial_AES_t, *PKeyMaterial_AES_t;
+
+/** MrvlIEtype_KeyParamSet_t */
+typedef struct _MrvlIEtype_KeyParamSet_t
+{
+    /* Type ID */
+    u16 Type;
+
+    /* Length of Payload */
+    u16 Length;
+
+    /* Type of Key: WEP=0, TKIP=1, AES=2 */
+    u16 KeyTypeId;
+
+    /* Key Control Info specific to a KeyTypeId */
+    u16 KeyInfo;
+
+    /* Length of key */
+    u16 KeyLen;
+
+    /* Key material of size KeyLen */
+    u8 Key[32];
+} __ATTRIB_PACK__ MrvlIEtype_KeyParamSet_t, *PMrvlIEtype_KeyParamSet_t;
+
+/** HostCmd_DS_802_11_KEY_MATERIAL */
+typedef struct _HostCmd_DS_802_11_KEY_MATERIAL
+{
+    u16 Action;
+
+    MrvlIEtype_KeyParamSet_t KeyParamSet;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_KEY_MATERIAL;
+
+/** HostCmd_DS_802_11_HOST_SLEEP_CFG */
+typedef struct _HostCmd_DS_HOST_802_11_HOST_SLEEP_CFG
+{
+    /* bit0=1: non-unicast data
+     * bit1=1: unicast data
+     * bit2=1: mac events
+     * bit3=1: magic packet 
+     */
+    u32 conditions;
+
+    u8 gpio;
+
+    /* in milliseconds */
+    u8 gap;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_HOST_SLEEP_CFG;
+
+#define CAL_DATA_HEADER_LEN	6       /* sizeof(HostCmd_DS_802_11_CAL_DATA_EXT)-sizeof(CalData) */
+
+/** HostCmd_DS_802_11_CAL_DATA_EXT */
+typedef struct _HostCmd_DS_802_11_CAL_DATA_EXT
+{
+    u16 Action;
+    u16 Revision;
+    u16 CalDataLen;
+    u8 CalData[1];
+} __ATTRIB_PACK__ HostCmd_DS_802_11_CAL_DATA_EXT;
+
+/** HostCmd_DS_802_11_EEPROM_ACCESS */
+typedef struct _HostCmd_DS_802_11_EEPROM_ACCESS
+{
+    u16 Action;
+
+    /* multiple 4 */
+    u16 Offset;
+    u16 ByteCount;
+    u8 Value;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_EEPROM_ACCESS;
+
+/** HostCmd_DS_802_11_BG_SCAN_CONFIG */
+typedef struct _HostCmd_DS_802_11_BG_SCAN_CONFIG
+{
+    /** Action */
+    u16 Action;
+
+    /** 
+     *  Enable/Disable
+     *  0 - Disable
+     *  1 - Enable 
+     */
+    u8 Enable;
+
+    /**
+     *  bssType
+     *  1 - Infrastructure
+     *  2 - IBSS
+     *  3 - any 
+     */
+    u8 BssType;
+
+    /** 
+     * ChannelsPerScan 
+     *   Number of channels to scan during a single scanning opportunity
+     */
+    u8 ChannelsPerScan;
+
+    u8 Reserved1[3];
+
+    /** ScanInterval */
+    u32 ScanInterval;
+
+    /**
+     * StoreCondition
+     * - SSID Match
+     * - SSID Match & Exceed SNR Threshold 
+     */
+    u32 StoreCondition;
+
+    /** 
+     * ReportConditions
+     * - SSID Match
+     * - SSID Match & Exceed SNR Threshold
+     */
+    u32 ReportConditions;
+
+    u16 Reserved2;
+
+    /*  Attach TLV based parameters as needed:
+     *
+     *  MrvlIEtypes_SsIdParamSet_t          Set specific SSID filter
+     *  MrvlIEtypes_ChanListParamSet_t      Set the channels & channel params
+     *  MrvlIEtypes_NumProbes_t             Number of probes per SSID/broadcast
+     *  MrvlIEtypes_WildCardSsIdParamSet_t  Wildcard SSID matching patterns
+     *  MrvlIEtypes_SnrThreshold_t          SNR Threshold for match/report  
+     */
+
+} __ATTRIB_PACK__ HostCmd_DS_802_11_BG_SCAN_CONFIG;
+
+/** HostCmd_DS_802_11_BG_SCAN_QUERY */
+typedef struct _HostCmd_DS_802_11_BG_SCAN_QUERY
+{
+    u8 Flush;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_BG_SCAN_QUERY;
+
+/** HostCmd_DS_802_11_BG_SCAN_QUERY_RSP */
+typedef struct _HostCmd_DS_802_11_BG_SCAN_QUERY_RSP
+{
+    u32 ReportCondition;
+    HostCmd_DS_802_11_SCAN_RSP scanresp;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_BG_SCAN_QUERY_RSP;
+
+/** HostCmd_DS_802_11_TPC_CFG */
+typedef struct _HostCmd_DS_802_11_TPC_CFG
+{
+    u16 Action;
+    u8 Enable;
+    s8 P0;
+    s8 P1;
+    s8 P2;
+    u8 UseSNR;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_TPC_CFG;
+
+/** HostCmd_DS_802_11_LED_CTRL */
+typedef struct _HostCmd_DS_802_11_LED_CTRL
+{
+    u16 Action;                 /* 0 = ACT_GET; 1 = ACT_SET; */
+    u16 LedNums;                /* Numbers of LEDs supported */
+    MrvlIEtypes_LedGpio_t LedGpio;
+    MrvlIEtypes_LedBehavior_t LedBehavior[1];
+} __ATTRIB_PACK__ HostCmd_DS_802_11_LED_CTRL;
+
+/** HostCmd_DS_802_11_POWER_ADAPT_CFG_EXT */
+typedef struct _HostCmd_DS_802_11_POWER_ADAPT_CFG_EXT
+{
+        /** Action */
+    u16 Action;                 /* 0 = ACT_GET; 1 = ACT_SET; */
+    u16 EnablePA;               /* 0 = disable; 1 = enable; */
+    MrvlIEtypes_PowerAdapt_Group_t PowerAdaptGroup;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_POWER_ADAPT_CFG_EXT;
+
+typedef struct _HostCmd_DS_SDIO_INT_CONFIG
+{
+    u16 Action;                 /* 0: get; 1: set */
+    u16 Gpio_pin;
+    u16 Gpio_int_edge;          /*1: failing edge; 0: rasing edge */
+    u16 Gpio_pulse_width;       /* in usec units */
+} __ATTRIB_PACK__ HostCmd_DS_SDIO_INT_CONFIG;
+
+typedef struct _HostCmd_DS_SDIO_PULL_CTRL
+{
+    u16 Action;                 /* 0: get; 1: set */
+    u16 PullUp;                 /* the delay of pulling up in us */
+    u16 PullDown;               /* the delay of pulling down in us */
+} __ATTRIB_PACK__ HostCmd_DS_SDIO_PULL_CTRL;
+typedef struct _HostCmd_DS_802_11_IBSS_Status
+{
+    u16 Action;
+    u16 Enable;
+    u8 BSSID[ETH_ALEN];
+    u16 BeaconInterval;
+    u16 ATIMWindow;
+    u16 UseGRateProtection;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_IBSS_Status;
+
+typedef struct _HostCmd_TX_RATE_QUERY
+{
+    u16 TxRate;
+} __ATTRIB_PACK__ HostCmd_TX_RATE_QUERY;
+
+/** HostCmd_DS_802_11_AUTO_TX */
+typedef struct _HostCmd_DS_802_11_AUTO_TX
+{
+        /** Action */
+    u16 Action;                 /* 0 = ACT_GET; 1 = ACT_SET; */
+    MrvlIEtypes_AutoTx_t AutoTx;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_AUTO_TX;
+
+/** HostCmd_MEM_ACCESS */
+typedef struct _HostCmd_DS_MEM_ACCESS
+{
+        /** Action */
+    u16 Action;                 /* 0 = ACT_GET; 1 = ACT_SET; */
+    u16 Reserved;
+    u32 Addr;
+    u32 Value;
+} __ATTRIB_PACK__ HostCmd_DS_MEM_ACCESS;
+
+typedef struct
+{
+    u64 TsfValue;
+} __ATTRIB_PACK__ HostCmd_DS_GET_TSF;
+
+#define	LDO_INTERNAL	0
+#define LDO_EXTERNAL	1
+
+typedef struct _HostCmd_DS_802_11_LDO_CONFIG
+{
+    u16 Action;                 /* 0 = ACT_GET; 1 = ACT_SET; */
+    u16 PMSource;               /* 0 = LDO_INTERNAL; 1 = LDO_EXTERNAL */
+} __ATTRIB_PACK__ HostCmd_DS_802_11_LDO_CONFIG;
+
+typedef struct _HostCmd_DS_VERSION_EXT
+{
+    u8 versionStrSel;
+    char versionStr[128];
+} __ATTRIB_PACK__ HostCmd_DS_VERSION_EXT;
+
+/** Define data structure for HostCmd_CMD_802_11D_DOMAIN_INFO */
+typedef struct _HostCmd_DS_802_11D_DOMAIN_INFO
+{
+    u16 Action;
+    MrvlIEtypes_DomainParamSet_t Domain;
+} __ATTRIB_PACK__ HostCmd_DS_802_11D_DOMAIN_INFO;
+
+/** Define data structure for HostCmd_RET_802_11D_DOMAIN_INFO */
+typedef struct _HostCmd_DS_802_11D_DOMAIN_INFO_RSP
+{
+    u16 Action;
+    MrvlIEtypes_DomainParamSet_t Domain;
+} __ATTRIB_PACK__ HostCmd_DS_802_11D_DOMAIN_INFO_RSP;
+
+typedef struct
+{
+    u32 PktInitCnt;
+    u32 PktSuccessCnt;
+    u32 TxAttempts;
+    u32 RetryFailure;
+    u32 ExpiryFailure;
+} __ATTRIB_PACK__ HostCmd_DS_TX_PKT_STAT_Entry;
+
+typedef struct
+{
+    HostCmd_DS_TX_PKT_STAT_Entry StatEntry[HOSTCMD_SUPPORTED_RATES];
+} __ATTRIB_PACK__ HostCmd_DS_TX_PKT_STATS;
+
+/** _HostCmd_DS_COMMAND*/
+struct _HostCmd_DS_COMMAND
+{
+
+    /** Command Header */
+    u16 Command;
+    u16 Size;
+    u16 SeqNum;
+    u16 Result;
+
+    /** Command Body */
+    union
+    {
+        HostCmd_DS_GET_HW_SPEC hwspec;
+        HostCmd_DS_802_11_PS_MODE psmode;
+        HostCmd_DS_802_11_SCAN scan;
+        HostCmd_DS_802_11_SCAN_RSP scanresp;
+        HostCmd_DS_MAC_CONTROL macctrl;
+        HostCmd_DS_802_11_ASSOCIATE associate;
+        HostCmd_DS_802_11_ASSOCIATE_RSP associatersp;
+        HostCmd_DS_802_11_DEAUTHENTICATE deauth;
+        HostCmd_DS_802_11_SET_WEP wep;
+        HostCmd_DS_802_11_AD_HOC_START ads;
+        HostCmd_DS_802_11_AD_HOC_RESULT result;
+        HostCmd_DS_802_11_GET_LOG glog;
+        HostCmd_DS_802_11_SNMP_MIB smib;
+        HostCmd_DS_802_11_RF_TX_POWER txp;
+        HostCmd_DS_802_11_RF_ANTENNA rant;
+        HostCmd_DS_802_11_RATE_ADAPT_RATESET rateset;
+        HostCmd_DS_MAC_MULTICAST_ADR madr;
+        HostCmd_DS_802_11_AD_HOC_JOIN adj;
+        HostCmd_DS_802_11_RADIO_CONTROL radio;
+        HostCmd_DS_802_11_RF_CHANNEL rfchannel;
+        HostCmd_DS_802_11_RSSI rssi;
+        HostCmd_DS_802_11_RSSI_RSP rssirsp;
+        HostCmd_DS_802_11_AD_HOC_STOP adhoc_stop;
+        HostCmd_DS_802_11_MAC_ADDRESS macadd;
+        HostCmd_DS_802_11_KEY_MATERIAL keymaterial;
+        HostCmd_DS_MAC_REG_ACCESS macreg;
+        HostCmd_DS_BBP_REG_ACCESS bbpreg;
+        HostCmd_DS_RF_REG_ACCESS rfreg;
+        HostCmd_DS_802_11_CAL_DATA_EXT caldataext;
+        HostCmd_DS_802_11_HOST_SLEEP_CFG hostsleepcfg;
+        HostCmd_DS_802_11_EEPROM_ACCESS rdeeprom;
+
+        HostCmd_DS_802_11D_DOMAIN_INFO domaininfo;
+        HostCmd_DS_802_11D_DOMAIN_INFO_RSP domaininforesp;
+        HostCmd_DS_802_11_BG_SCAN_CONFIG bgscancfg;
+        HostCmd_DS_802_11_BG_SCAN_QUERY bgscanquery;
+        HostCmd_DS_802_11_BG_SCAN_QUERY_RSP bgscanqueryresp;
+        HostCmd_DS_WMM_GET_STATUS getWmmStatus;
+        HostCmd_DS_WMM_ADDTS_REQ addTsReq;
+        HostCmd_DS_WMM_DELTS_REQ delTsReq;
+        HostCmd_DS_WMM_QUEUE_CONFIG queueConfig;
+        HostCmd_DS_WMM_QUEUE_STATS queueStats;
+        HostCmd_DS_TX_PKT_STATS txPktStats;
+        HostCmd_DS_802_11_SLEEP_PARAMS sleep_params;
+        HostCmd_DS_802_11_BCA_TIMESHARE bca_timeshare;
+        HostCmd_DS_802_11_INACTIVITY_TIMEOUT inactivity_timeout;
+        HostCmd_DS_802_11_SLEEP_PERIOD ps_sleeppd;
+        HostCmd_DS_802_11_TPC_CFG tpccfg;
+        HostCmd_DS_802_11_LED_CTRL ledgpio;
+        HostCmd_DS_802_11_FW_WAKEUP_METHOD fwwakeupmethod;
+
+        HostCmd_TX_RATE_QUERY txrate;
+        HostCmd_DS_GET_TSF gettsf;
+        HostCmd_DS_802_11_IBSS_Status ibssCoalescing;
+        HostCmd_DS_SDIO_INT_CONFIG sdio_int;
+        HostCmd_DS_SDIO_PULL_CTRL sdiopullctl;
+        HostCmd_DS_802_11_LDO_CONFIG ldocfg;
+        HostCmd_DS_VERSION_EXT verext;
+    } params;
+} __ATTRIB_PACK__;
+
+#endif
Index: linux-2.6.29/drivers/net/wireless/marvell8686/if_sdio.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/if_sdio.c	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,1379 @@
+/** @file if_sdio.c
+ *  @brief This file contains SDIO IF (interface) module
+ *  related functions.
+ *
+ *  Copyright  Marvell International Ltd. and/or its affiliates, 2003-2007
+ */
+/****************************************************
+Change log:
+	10/14/05: add Doxygen format comments 
+	01/05/06: add kernel 2.6.x support
+	01/23/06: add fw downlaod
+	06/06/06: add macro SD_BLOCK_SIZE_FW_DL for firmware download
+		  add macro ALLOC_BUF_SIZE for cmd resp/Rx data skb buffer allocation
+****************************************************/
+#include <linux/mmc/card.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/sdio_ids.h>
+
+#include	"if_sdio.h"
+
+//#undef PRINTM
+//#define PRINTM(INFO, msg...) printk(msg)
+
+/* define SD block size for firmware download */
+#define SD_BLOCK_SIZE_FW_DL	32
+
+/* define SD block size for data Tx/Rx */
+#define SD_BLOCK_SIZE		128     /* To minimize the overhead of ethernet frame
+                                           with 1514 bytes, 320 bytes block size is used */
+
+#define ALLOC_BUF_SIZE		(((MAX(MRVDRV_ETH_RX_PACKET_BUFFER_SIZE, \
+					MRVDRV_SIZE_OF_CMD_BUFFER) + SDIO_HEADER_LEN \
+					+ SD_BLOCK_SIZE - 1) / SD_BLOCK_SIZE) * SD_BLOCK_SIZE)
+
+/* Max retry number of CMD53 write */
+#define MAX_WRITE_IOMEM_RETRY	2
+
+/********************************************************
+		Local Variables
+********************************************************/
+
+/********************************************************
+		Global Variables
+********************************************************/
+
+struct if_sdio_card {
+	struct sdio_func        *func;
+	wlan_private            *priv;
+	int                     model;
+
+	u8 int_cause;
+
+	u8 chiprev;
+	u8 async_int_mode;
+	u8 block_size_512;
+	card_capability info;
+};
+
+extern wlan_private *wlanpriv;
+const char *helper_name;
+const char *fw_name;
+/********************************************************
+		Local Functions
+********************************************************/
+
+/** 
+ *  @brief This function adds the card
+ *  
+ *  @param card    A pointer to the card
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+sbi_add_card(void *card, struct device *dmdev)
+{
+	struct if_sdio_card *sdio_card = (struct if_sdio_card*)card;
+	sdio_card->priv = wlan_add_card(card, dmdev);
+	if (sdio_card->priv)
+		return WLAN_STATUS_SUCCESS;
+	else
+		return WLAN_STATUS_FAILURE;
+}
+
+/** 
+ *  @brief This function removes the card
+ *  
+ *  @param card    A pointer to the card
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+sbi_remove_card(void *card)
+{
+	return wlan_remove_card(card);
+}
+
+/** 
+ *  @brief This function reads scratch registers
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param dat	   A pointer to keep returned data
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+mv_sdio_read_scratch(wlan_private * priv, u16 * dat)
+{
+	int ret = WLAN_STATUS_SUCCESS;
+	u8 scr0;
+	u8 scr1;
+	struct if_sdio_card* card = (struct if_sdio_card*)priv->wlan_dev.card;
+	
+	scr0 = sdio_readb(card->func, CARD_OCR_0_REG, &ret);
+	if (ret)
+		return WLAN_STATUS_FAILURE;
+
+	scr1 = sdio_readb(card->func, CARD_OCR_1_REG, &ret);
+	PRINTM(INFO, "CARD_OCR_0_REG = 0x%x, CARD_OCR_1_REG = 0x%x\n", scr0,
+	       scr1);
+	if (ret)
+		return WLAN_STATUS_FAILURE;
+
+	*dat = (((u16) scr1) << 8) | scr0;
+
+	return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function polls the card status register.
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @param bits    	the bit mask
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+mv_sdio_poll_card_status(wlan_private * priv, u8 bits)
+{
+	int tries;
+	int rval;
+	u8 cs;
+	struct if_sdio_card* card = (struct if_sdio_card*)priv->wlan_dev.card;
+	
+	for (tries = 0; tries < MAX_POLL_TRIES; tries++) {
+		cs = sdio_readb(card->func, CARD_STATUS_REG, &rval);
+		if (rval == 0 && (cs & bits) == bits) {
+			return WLAN_STATUS_SUCCESS;
+		}
+
+		mdelay(1);
+	}
+
+	PRINTM(WARN, "mv_sdio_poll_card_status: FAILED!:%d\n", rval);
+	return WLAN_STATUS_FAILURE;
+}
+
+/** 
+ *  @brief This function programs the firmware image.
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @param firmware 	A pointer to the buffer of firmware image
+ *  @param firmwarelen 	the length of firmware image
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+sbi_prog_firmware_image(wlan_private * priv,
+			const u8 * firmware, int firmwarelen)
+{
+	int ret = WLAN_STATUS_SUCCESS;
+	u16 firmwarestat;
+	u8 *fwbuf = priv->adapter->TmpTxBuf;
+	int fwblknow;
+	u32 tx_len;
+	struct if_sdio_card* card = (struct if_sdio_card*)priv->wlan_dev.card;
+#ifdef FW_DOWNLOAD_SPEED
+	u32 tv1, tv2;
+#endif
+
+	ENTER();
+
+	sdio_claim_host(card->func);
+	ret = sdio_set_block_size(card->func, SD_BLOCK_SIZE_FW_DL);
+	if (ret) {
+		ret = WLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	if ((ret = mv_sdio_read_scratch(priv, &firmwarestat)) < 0) {
+		PRINTM(INFO, "read scratch returned <0\n");
+		goto done;
+	}
+
+	if (firmwarestat == FIRMWARE_READY) {
+		PRINTM(INFO, "FW already downloaded!\n");
+		ret = WLAN_STATUS_SUCCESS;
+		goto done;
+	}
+
+	PRINTM(INFO, "Downloading helper image (%d bytes), block size %d bytes\n",
+	       firmwarelen, SD_BLOCK_SIZE_FW_DL);
+
+#ifdef FW_DOWNLOAD_SPEED
+	tv1 = get_utimeofday();
+#endif
+	/* Perform firmware data transfer */
+	tx_len =
+	(FIRMWARE_TRANSFER_NBLOCK * SD_BLOCK_SIZE_FW_DL) - SDIO_HEADER_LEN;
+	for (fwblknow = 0; fwblknow < firmwarelen; fwblknow += tx_len) {
+
+		/* The host polls for the DN_LD_CARD_RDY and CARD_IO_READY bits */
+		ret = mv_sdio_poll_card_status(priv, CARD_IO_READY | DN_LD_CARD_RDY);
+		if (ret < 0) {
+			PRINTM(FATAL, "FW download died @ %d\n", fwblknow);
+			goto done;
+		}
+
+		/* Set blocksize to transfer - checking for last block */
+		if (firmwarelen - fwblknow < tx_len)
+			tx_len = firmwarelen - fwblknow;
+
+		fwbuf[0] = ((tx_len & 0x000000ff) >> 0);	/* Little-endian */
+		fwbuf[1] = ((tx_len & 0x0000ff00) >> 8);
+		fwbuf[2] = ((tx_len & 0x00ff0000) >> 16);
+		fwbuf[3] = ((tx_len & 0xff000000) >> 24);
+
+		/* Copy payload to buffer */
+		memcpy(&fwbuf[SDIO_HEADER_LEN], &firmware[fwblknow], tx_len);
+
+		PRINTM(INFO, ".");
+
+		/* Send data */
+		ret = sdio_writesb(card->func, priv->wlan_dev.ioport,
+				    fwbuf, FIRMWARE_TRANSFER_NBLOCK * SD_BLOCK_SIZE_FW_DL);
+
+		if (ret) {
+			PRINTM(FATAL, "IO error: transferring block @ %d\n", fwblknow);
+			goto done;
+		}
+	}
+
+#ifdef FW_DOWNLOAD_SPEED
+	tv2 = get_utimeofday();
+	PRINTM(INFO, "helper: %ld.%03ld.%03ld ", tv1 / 1000000,
+	       (tv1 % 1000000) / 1000, tv1 % 1000);
+	PRINTM(INFO, " -> %ld.%03ld.%03ld ", tv2 / 1000000,
+	       (tv2 % 1000000) / 1000, tv2 % 1000);
+	tv2 -= tv1;
+	PRINTM(INFO, " == %ld.%03ld.%03ld\n", tv2 / 1000000,
+	       (tv2 % 1000000) / 1000, tv2 % 1000);
+#endif
+
+	/* Write last EOF data */
+	PRINTM(INFO, "\nTransferring EOF block\n");
+	memset(fwbuf, 0x0, SD_BLOCK_SIZE_FW_DL);
+	ret = sdio_writesb(card->func, priv->wlan_dev.ioport, fwbuf, SD_BLOCK_SIZE_FW_DL);
+
+	if (ret) {
+		PRINTM(FATAL, "IO error in writing EOF FW block\n");
+		goto done;
+	}
+
+	ret = WLAN_STATUS_SUCCESS;
+
+done:
+	sdio_set_block_size(card->func, 0);
+	sdio_release_host(card->func);
+	return ret;
+}
+
+/** 
+ *  @brief This function downloads firmware image to the card.
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @param firmware	A pointer to firmware image buffer
+ *  @param firmwarelen	the length of firmware image
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+sbi_download_wlan_fw_image(wlan_private * priv,
+			   const u8 * firmware, int firmwarelen)
+{
+	u8 base0;
+	u8 base1;
+	int ret = WLAN_STATUS_SUCCESS;
+	int offset;
+	u8 *fwbuf = priv->adapter->TmpTxBuf;
+	int timeout = 5000;
+	u16 len;
+	int txlen = 0;
+	int tx_blocks = 0;
+	int i = 0;
+	struct if_sdio_card* card = (struct if_sdio_card*)priv->wlan_dev.card;
+#ifdef FW_DOWNLOAD_SPEED
+	u32 tv1, tv2;
+#endif
+
+	ENTER();
+
+	PRINTM(INFO, "Downloading FW image (%d bytes)\n", firmwarelen);
+
+#ifdef FW_DOWNLOAD_SPEED
+	tv1 = get_utimeofday();
+#endif
+	sdio_claim_host(card->func);
+
+	ret = sdio_set_block_size(card->func, SD_BLOCK_SIZE_FW_DL);
+	if (ret) {
+		ret = WLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	/* Wait initially for the first non-zero value */
+	do {
+		base0 = sdio_readb(card->func, HOST_F1_RD_BASE_0, &ret);
+		if (ret) {
+			PRINTM(WARN, "Dev BASE0 register read failed:"
+			       " base0=0x%04X(%d)\n", base0, base0);
+			ret = WLAN_STATUS_FAILURE;
+			goto done;
+		}
+		base1 = sdio_readb(card->func, HOST_F1_RD_BASE_1, &ret);
+		if (ret) {
+			PRINTM(WARN, "Dev BASE1 register read failed:"
+			       " base1=0x%04X(%d)\n", base1, base1);
+			ret = WLAN_STATUS_FAILURE;
+			goto done;
+		}
+		len = (((u16) base1) << 8) | base0;
+		mdelay(1);
+	} while (!len && --timeout);
+
+	if (!timeout) {
+		PRINTM(MSG, "Helper downloading finished.\n");
+		PRINTM(MSG, "Timeout for FW downloading!\n");
+		ret = WLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	/* The host polls for the DN_LD_CARD_RDY and CARD_IO_READY bits */
+	ret = mv_sdio_poll_card_status(priv, CARD_IO_READY | DN_LD_CARD_RDY);
+	if (ret < 0) {
+		PRINTM(FATAL, "FW download died, helper not ready\n");
+		ret = WLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	len &= ~B_BIT_0;
+
+	/* Perform firmware data transfer */
+	for (offset = 0; offset < firmwarelen; offset += txlen) {
+		txlen = len;
+
+		/* Set blocksize to transfer - checking for last block */
+		if (firmwarelen - offset < txlen) {
+			txlen = firmwarelen - offset;
+		}
+		/* PRINTM(INFO, "fw: offset=%d, txlen = 0x%04X(%d)\n", 
+		   offset,txlen,txlen); */
+		PRINTM(INFO, ".");
+
+		tx_blocks = (txlen + SD_BLOCK_SIZE_FW_DL - 1) / SD_BLOCK_SIZE_FW_DL;
+
+		/* Copy payload to buffer */
+		memcpy(fwbuf, &firmware[offset], txlen);
+
+		/* Send data */
+		ret = sdio_writesb(card->func, priv->wlan_dev.ioport,
+				       fwbuf, tx_blocks * SD_BLOCK_SIZE_FW_DL);
+
+		if (ret) {
+			PRINTM(ERROR, "FW download, write iomem (%d) failed: %d\n", i,
+			       ret);
+			sdio_writeb(card->func, 0x04, CONFIGURATION_REG, &ret);
+			if (ret) {
+				PRINTM(ERROR, "write ioreg failed (FN1 CFG)\n");
+			}
+		}
+
+		/* The host polls for the DN_LD_CARD_RDY and CARD_IO_READY bits */
+		ret = mv_sdio_poll_card_status(priv, CARD_IO_READY | DN_LD_CARD_RDY);
+		if (ret < 0) {
+			PRINTM(FATAL, "FW download with helper died @ %d\n", offset);
+			goto done;
+		}
+
+		base0 = sdio_readb(card->func, HOST_F1_RD_BASE_0, &ret);
+		if (ret) {
+			PRINTM(WARN, "Dev BASE0 register read failed:"
+			       " base0=0x%04X(%d)\n", base0, base0);
+			ret = WLAN_STATUS_FAILURE;
+			goto done;
+		}
+		base1 = sdio_readb(card->func, HOST_F1_RD_BASE_1, &ret);
+		if (ret) {
+			PRINTM(WARN, "Dev BASE1 register read failed:"
+			       " base1=0x%04X(%d)\n", base1, base1);
+			ret = WLAN_STATUS_FAILURE;
+			goto done;
+		}
+		len = (((u16) base1) << 8) | base0;
+
+		if (!len) {
+			break;
+		}
+
+		if (len & B_BIT_0) {
+			i++;
+			if (i > MAX_WRITE_IOMEM_RETRY) {
+				PRINTM(FATAL, "FW download failure, over max retry count\n");
+				ret = WLAN_STATUS_FAILURE;
+				goto done;
+			}
+			PRINTM(ERROR, "CRC error indicated by the helper:"
+			       " len = 0x%04X, txlen = %d\n", len, txlen);
+			len &= ~B_BIT_0;
+			/* Setting this to 0 to resend from same offset */
+			txlen = 0;
+		}
+		else
+			i = 0;
+	}
+	PRINTM(INFO, "\nFW download over, size %d bytes\n", firmwarelen);
+
+	ret = WLAN_STATUS_SUCCESS;
+done:
+	sdio_set_block_size(card->func, 0);
+	sdio_release_host(card->func);
+#ifdef FW_DOWNLOAD_SPEED
+	tv2 = get_utimeofday();
+	PRINTM(INFO, "FW: %ld.%03ld.%03ld ", tv1 / 1000000,
+	       (tv1 % 1000000) / 1000, tv1 % 1000);
+	PRINTM(INFO, " -> %ld.%03ld.%03ld ", tv2 / 1000000,
+	       (tv2 % 1000000) / 1000, tv2 % 1000);
+	tv2 -= tv1;
+	PRINTM(INFO, " == %ld.%03ld.%03ld\n", tv2 / 1000000,
+	       (tv2 % 1000000) / 1000, tv2 % 1000);
+#endif
+	LEAVE();
+	return ret;
+}
+
+/** 
+ *  @brief This function reads data from the card.
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @param type	   	A pointer to keep type as data or command
+ *  @param nb		A pointer to keep the data/cmd length retured in buffer
+ *  @param payload 	A pointer to the data/cmd buffer
+ *  @param nb	   	the length of data/cmd buffer
+ *  @param npayload	the length of data/cmd buffer
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+mv_sdio_card_to_host(wlan_private * priv,
+		     u32 * type, int *nb, u8 * payload, int npayload)
+{
+	int ret = WLAN_STATUS_SUCCESS;
+	u16 buf_len = 0;
+	int buf_block_len;
+	int blksz;
+	u32 *pevent;
+	struct if_sdio_card* card = (struct if_sdio_card*)priv->wlan_dev.card;
+
+	ENTER();
+
+	if (!payload) {
+		PRINTM(WARN, "payload NULL pointer received!\n");
+		ret = WLAN_STATUS_FAILURE;
+		goto exit;
+	}
+
+	/* Read the length of data to be transferred */
+	ret = mv_sdio_read_scratch(priv, &buf_len);
+	if (ret < 0) {
+		PRINTM(ERROR, "card_to_host, read RX length failed\n");
+		ret = WLAN_STATUS_FAILURE;
+		goto exit;
+	}
+
+	if (buf_len <= SDIO_HEADER_LEN || buf_len > npayload) {
+		PRINTM(ERROR, "card_to_host, invalid packet length: %d\n", buf_len);
+		ret = WLAN_STATUS_FAILURE;
+		goto exit;
+	}
+
+	ret = mv_sdio_poll_card_status(priv, CARD_IO_READY);
+	if (ret < 0) {
+		PRINTM(FATAL, "MV card status fail\n");
+		goto exit;
+	}
+
+	/* Allocate buffer */
+	blksz = SD_BLOCK_SIZE;
+	buf_block_len = (buf_len + blksz - 1) / blksz;
+
+	ret = sdio_set_block_size(card->func, blksz);
+	if (ret) {
+		ret = WLAN_STATUS_FAILURE;
+		goto exit;
+	}
+
+	ret = sdio_readsb(card->func, payload, priv->wlan_dev.ioport, buf_block_len * blksz);
+
+	if (ret) {
+		PRINTM(ERROR, "card_to_host, read iomem failed: %d\n", ret);
+		ret = WLAN_STATUS_FAILURE;
+		goto exit;
+	}
+	*nb = buf_len;
+
+	DBG_HEXDUMP(IF_D, "SDIO Blk Rd", payload, blksz * buf_block_len);
+
+	*type = (payload[2] | (payload[3] << 8));
+	if (*type == MVSD_EVENT) {
+		pevent = (u32 *) & payload[4];
+		priv->adapter->EventCause = MVSD_EVENT | (((u16) (*pevent)) << 3);
+	}
+
+exit:
+	sdio_set_block_size(card->func, 0);
+	LEAVE();
+	return ret;
+}
+
+/** 
+ *  @brief This function enables the host interrupts mask
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param mask	   the interrupt mask
+ *  @return 	   WLAN_STATUS_SUCCESS
+ */
+static int
+enable_host_int_mask(wlan_private * priv, u8 mask)
+{
+	int ret = WLAN_STATUS_SUCCESS;
+	struct if_sdio_card* card = (struct if_sdio_card*)priv->wlan_dev.card;
+
+	sdio_claim_host(card->func);
+	/* Simply write the mask to the register */
+	sdio_writeb(card->func, mask, HOST_INT_MASK_REG, &ret);
+	sdio_release_host(card->func);
+
+	if (ret) {
+		PRINTM(WARN, "ret = %d\n", ret);
+		ret = WLAN_STATUS_FAILURE;
+	}
+
+	priv->adapter->HisRegCpy = 1;
+
+	return ret;
+}
+
+/**  @brief This function disables the host interrupts mask.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param mask	   the interrupt mask
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+disable_host_int_mask(wlan_private * priv, u8 mask)
+{
+	int ret = WLAN_STATUS_SUCCESS;
+	u8 host_int_mask;
+	struct if_sdio_card* card = (struct if_sdio_card*)priv->wlan_dev.card;
+
+	sdio_claim_host(card->func);
+	/* Read back the host_int_mask register */
+	host_int_mask = sdio_readb(card->func, HOST_INT_MASK_REG, &ret);
+	if (ret) {
+		ret = WLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	/* Update with the mask and write back to the register */
+	host_int_mask &= ~mask;
+	sdio_writeb(card->func, host_int_mask, HOST_INT_MASK_REG, &ret);
+	if (ret) {
+		PRINTM(WARN, "Unable to diable the host interrupt!\n");
+		ret = WLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+done:
+	sdio_release_host(card->func);
+	return ret;
+}
+
+/********************************************************
+		Global Functions
+********************************************************/
+
+/** 
+ *  @brief This function handles the interrupt.
+ *  
+ *  @param irq 	   The irq of device.
+ *  @param dev_id  A pointer to net_device structure
+ *  @param fp	   A pointer to pt_regs structure
+ *  @return 	   n/a
+ */
+static void sbi_interrupt(struct sdio_func *func)
+{
+	int ret = WLAN_STATUS_SUCCESS;
+	u8 sdio_ireg = 0;
+	u8 *cmdBuf;
+	wlan_private *priv;
+	wlan_dev_t *wlan_dev;
+	struct sk_buff *skb;
+	struct if_sdio_card* card = NULL;
+	ENTER();
+
+	priv = wlanpriv;
+	wlan_dev = &priv->wlan_dev;
+	card = (struct if_sdio_card*)wlan_dev->card;
+
+	sdio_ireg = sdio_readb(func, HOST_INTSTATUS_REG, &ret);
+	if (ret) {
+		PRINTM(WARN, "sdio_read_ioreg: read int status register failed\n");
+		ret = WLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	sdio_writeb(func,  (~sdio_ireg) & (DN_LD_HOST_INT_STATUS | UP_LD_HOST_INT_STATUS),
+		    HOST_INTSTATUS_REG, &ret);
+	if (ret) {
+		PRINTM(WARN, "sdio_write_ioreg: clear int status register failed\n");
+		ret = WLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	if (sdio_ireg & DN_LD_HOST_INT_STATUS) {    /* tx_done INT */
+		if (!priv->wlan_dev.dnld_sent) {	/* tx_done already received */
+			PRINTM(INFO, "warning: tx_done already received:"
+			       " dnld_sent=0x%x int status=0x%x\n",
+			       priv->wlan_dev.dnld_sent, sdio_ireg);
+		}
+		else {
+			wmm_process_fw_iface_tx_xfer_end(priv);
+			priv->wlan_dev.dnld_sent = DNLD_RES_RECEIVED;
+		}
+		OS_INT_DISABLE;
+		card->int_cause |= HIS_TxDnLdRdy;
+		wlan_interrupt(wlan_dev->netdev);
+		OS_INT_RESTORE;
+	}
+
+	if (sdio_ireg & UP_LD_HOST_INT_STATUS) {
+
+		/* 
+		 * DMA read data is by block alignment,so we need alloc extra block
+		 * to avoid wrong memory access.
+		 */
+		if (!(skb = dev_alloc_skb(ALLOC_BUF_SIZE))) {
+			PRINTM(WARN, "No free skb\n");
+			priv->stats.rx_dropped++;
+			ret = WLAN_STATUS_FAILURE;
+			goto done;
+		}
+
+		/* 
+		 * Transfer data from card
+		 * skb->tail is passed as we are calling skb_put after we
+		 * are reading the data
+		 */
+		if (mv_sdio_card_to_host(priv, &wlan_dev->upld_typ,
+					 (int *) &wlan_dev->upld_len, skb->tail,
+					 ALLOC_BUF_SIZE) < 0) {
+			u8 cr = 0;
+
+			PRINTM(ERROR, "Card to host failed: int status=0x%x\n",
+			       sdio_ireg);
+			cr = sdio_readb(func, CONFIGURATION_REG, &ret);
+			if (ret) 
+				PRINTM(ERROR, "read ioreg failed (FN1 CFG)\n");
+
+			PRINTM(INFO, "Config Reg val = %d\n", cr);
+			sdio_writeb(func, cr | 0x04, CONFIGURATION_REG, &ret);
+			if (ret)
+				PRINTM(ERROR, "write ioreg failed (FN1 CFG)\n");
+
+			PRINTM(INFO, "write success\n");
+			cr = sdio_readb(func, CONFIGURATION_REG, &ret);
+			if (ret)
+				PRINTM(ERROR, "read ioreg failed (FN1 CFG)\n");
+
+			PRINTM(INFO, "Config reg val =%x\n", cr);
+			ret = WLAN_STATUS_FAILURE;
+			kfree_skb(skb);
+			goto done;
+		}
+
+		OS_INT_DISABLE;
+		switch (wlan_dev->upld_typ) {
+		case MVSD_DAT:
+			PRINTM(DATA, "Data <= FW\n");
+			card->int_cause |= HIS_RxUpLdRdy;
+			skb_put(skb, priv->wlan_dev.upld_len);
+			skb_pull(skb, SDIO_HEADER_LEN);
+			list_add_tail((struct list_head *) skb,
+				      (struct list_head *) &priv->adapter->RxSkbQ);
+			/* skb will be freed by kernel later */
+			break;
+
+		case MVSD_CMD:
+			PRINTM(DATA, "CMD\n");
+
+			/* take care of CurCmd = NULL case */
+			if (!priv->adapter->CurCmd) {
+				cmdBuf = priv->wlan_dev.upld_buf;
+			}
+			else {
+				cmdBuf = priv->adapter->CurCmd->BufVirtualAddr;
+			}
+
+			priv->wlan_dev.upld_len -= SDIO_HEADER_LEN;
+			memcpy(cmdBuf, skb->data + SDIO_HEADER_LEN,
+			       MIN(MRVDRV_SIZE_OF_CMD_BUFFER, priv->wlan_dev.upld_len));
+			kfree_skb(skb);
+			card->int_cause |= HIS_CmdUpLdRdy;
+			break;
+
+		case MVSD_EVENT:
+			/* event cause has been saved to priv->adapter->EventCause */
+			kfree_skb(skb);
+			card->int_cause |= HIS_CardEvent;
+			break;
+
+		default:
+			PRINTM(ERROR, "SDIO unknown upld type = 0x%x\n",
+			       wlan_dev->upld_typ);
+			kfree_skb(skb);
+			break;
+		}
+		wlan_interrupt(wlan_dev->netdev);
+		OS_INT_RESTORE;
+	}
+
+	ret = WLAN_STATUS_SUCCESS;
+done:
+	LEAVE();
+	return;
+}
+
+/**
+ *  @brief This function reads the IO register.
+ *
+ *  @param priv    A pointer to wlan_private structure
+ *  @param func	   funcion number
+ *  @param reg	   register to be read
+ *  @param dat	   A pointer to variable that keeps returned value
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+sbi_read_ioreg(wlan_private * priv, u8 func, u32 reg, u8 * dat)
+{
+	int ret;
+	struct if_sdio_card* card = (struct if_sdio_card*)priv->wlan_dev.card;
+	sdio_claim_host(card->func);
+	if (func == 0)
+		*dat = sdio_f0_readb(card->func, reg, &ret);
+	else
+		*dat = sdio_readb(card->func, reg, &ret);
+	sdio_release_host(card->func);
+	return ret;
+}
+
+/**
+ *  @brief This function writes the IO register.
+ *
+ *  @param priv    A pointer to wlan_private structure
+ *  @param func	   funcion number
+ *  @param reg	   register to be written
+ *  @param dat	   the value to be written
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+sbi_write_ioreg(wlan_private * priv, u8 func, u32 reg, u8 dat)
+{
+	int ret;
+	struct if_sdio_card* card = (struct if_sdio_card*)priv->wlan_dev.card;
+	sdio_claim_host(card->func);
+	if (func == 0)
+		sdio_f0_writeb(card->func, dat, reg, &ret);
+	else
+		sdio_writeb(card->func, dat, reg, &ret);
+	sdio_release_host(card->func);
+	return ret;
+}
+
+/** 
+ *  @brief This function checks the interrupt status and handle it accordingly.
+ *
+ *  @param priv    A pointer to wlan_private structure
+ *  @param ireg    A pointer to variable that keeps returned value
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+sbi_get_int_status(wlan_private * priv, u8 * ireg)
+{
+	struct if_sdio_card* card = (struct if_sdio_card*)priv->wlan_dev.card;
+	OS_INT_DISABLE;
+	*ireg = card->int_cause;
+	card->int_cause = 0;
+	OS_INT_RESTORE;
+	return WLAN_STATUS_SUCCESS;
+
+}
+
+/**
+ *  @brief This function is a dummy function.
+ *  
+ *  @return 	   WLAN_STATUS_SUCCESS
+ */
+int
+sbi_card_to_host(wlan_private * priv, u32 type,
+		 u32 * nb, u8 * payload, u16 npayload)
+{
+	return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @return 	   WLAN_STATUS_SUCCESS
+ */
+int
+sbi_read_event_cause(wlan_private * priv)
+{
+	return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function disables the host interrupts.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+sbi_disable_host_int(wlan_private * priv)
+{
+	return disable_host_int_mask(priv, HIM_DISABLE);
+}
+
+/** 
+ *  @brief This function enables the host interrupts.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS
+ */
+int
+sbi_enable_host_int(wlan_private * priv)
+{
+	return enable_host_int_mask(priv, HIM_ENABLE);
+}
+
+/** 
+ *  @brief This function de-registers the device.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS
+ */
+int
+sbi_unregister_dev(wlan_private * priv)
+{
+	ENTER();
+
+	if (priv->wlan_dev.card != NULL) {
+		/* Release the SDIO IRQ */
+		PRINTM(WARN, "Making the sdio dev card as NULL\n");
+	}
+
+	LEAVE();
+	return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function registers the device.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+sbi_register_dev(wlan_private * priv)
+{
+	int ret = WLAN_STATUS_SUCCESS;
+	u8 reg;
+	struct if_sdio_card* card = (struct if_sdio_card*)priv->wlan_dev.card;
+
+	ENTER();
+
+	/* Initialize the private structure */
+	strncpy(priv->wlan_dev.name, "sdio0", sizeof(priv->wlan_dev.name));
+	priv->wlan_dev.ioport = 0;
+	priv->wlan_dev.upld_rcv = 0;
+	priv->wlan_dev.upld_typ = 0;
+	priv->wlan_dev.upld_len = 0;
+
+	sdio_claim_host(card->func);
+	/* Read the IO port */
+	reg = sdio_readb(card->func, IO_PORT_0_REG, &ret);
+	if (ret) 
+		goto failed;
+	else
+		priv->wlan_dev.ioport |= reg;
+
+	reg = sdio_readb(card->func, IO_PORT_1_REG, &ret);
+	if (ret) 
+		goto failed;
+	else
+		priv->wlan_dev.ioport |= (reg << 8);
+
+	reg = sdio_readb(card->func, IO_PORT_2_REG, &ret);
+	if (ret) 
+		goto failed;
+	else
+		priv->wlan_dev.ioport |= (reg << 16);
+	sdio_release_host(card->func);
+
+	PRINTM(INFO, "SDIO FUNC1 IO port: 0x%x\n", priv->wlan_dev.ioport);
+
+	/* Disable host interrupt first. */
+	if ((ret = disable_host_int_mask(priv, 0xff)) < 0) {
+		PRINTM(WARN, "Warning: unable to disable host interrupt!\n");
+	}
+
+	priv->adapter->chip_rev = card->chiprev;
+	priv->adapter->sdiomode = 4;
+
+	return WLAN_STATUS_SUCCESS;
+
+failed:
+	sdio_release_host(card->func);
+	priv->wlan_dev.card = NULL;
+
+	return WLAN_STATUS_FAILURE;
+}
+
+/** 
+ *  @brief This function sends data to the card.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param type	   data or command
+ *  @param payload A pointer to the data/cmd buffer
+ *  @param nb	   the length of data/cmd
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+sbi_host_to_card(wlan_private * priv, u8 type, u8 * payload, u16 nb)
+{
+	int ret = WLAN_STATUS_SUCCESS;
+	int buf_block_len;
+	int blksz;
+	int i = 0;
+	struct if_sdio_card* card = (struct if_sdio_card*)priv->wlan_dev.card;
+
+	ENTER();
+
+	sdio_claim_host(card->func);
+	priv->adapter->HisRegCpy = 0;
+
+	/* Allocate buffer and copy payload */
+	blksz = SD_BLOCK_SIZE;
+	buf_block_len = (nb + SDIO_HEADER_LEN + blksz - 1) / blksz;
+
+	/* This is SDIO specific header
+	 *  length: byte[1][0], 
+	 *  type: byte[3][2] (MVSD_DAT = 0, MVSD_CMD = 1, MVSD_EVENT = 3) 
+	 */
+	priv->adapter->TmpTxBuf[0] = (nb + SDIO_HEADER_LEN) & 0xff;
+	priv->adapter->TmpTxBuf[1] = ((nb + SDIO_HEADER_LEN) >> 8) & 0xff;
+	priv->adapter->TmpTxBuf[2] = type;
+	priv->adapter->TmpTxBuf[3] = 0x0;
+
+	if (payload != NULL &&
+	    (nb > 0 &&
+	     nb <= (sizeof(priv->adapter->TmpTxBuf) - SDIO_HEADER_LEN))) {
+		if (type == MVMS_CMD)
+			memcpy(&priv->adapter->TmpTxBuf[SDIO_HEADER_LEN], payload, nb);
+	}
+	else {
+		PRINTM(WARN, "sbi_host_to_card(): Error: payload=%p, nb=%d\n",
+		       payload, nb);
+	}
+
+	if (type == MVSD_DAT)
+		priv->wlan_dev.dnld_sent = DNLD_DATA_SENT;
+	else
+		priv->wlan_dev.dnld_sent = DNLD_CMD_SENT;
+
+	ret = sdio_set_block_size(card->func, blksz);
+	if (ret) {
+		ret = WLAN_STATUS_FAILURE;
+		goto exit;
+	}
+
+	do {
+		/* Transfer data to card */
+		ret = sdio_writesb(card->func, priv->wlan_dev.ioport,
+				   priv->adapter->TmpTxBuf, blksz * buf_block_len);
+		if (ret) {
+			i++;
+
+			PRINTM(ERROR, "host_to_card, write iomem (%d) failed: %d\n", i,
+			       ret);
+			sdio_writeb(card->func, 0x04, CONFIGURATION_REG, &ret);
+			if (ret) {
+				PRINTM(ERROR, "write ioreg failed (FN1 CFG)\n");
+			}
+			ret = WLAN_STATUS_FAILURE;
+			if (i > MAX_WRITE_IOMEM_RETRY) {
+				priv->wlan_dev.dnld_sent = DNLD_RES_RECEIVED;
+				goto exit;
+			}
+		}
+		else {
+			DBG_HEXDUMP(IF_D, "SDIO Blk Wr", priv->adapter->TmpTxBuf,
+				    blksz * buf_block_len);
+		}
+	} while (ret == WLAN_STATUS_FAILURE);
+
+exit:
+	sdio_set_block_size(card->func, 0);
+	sdio_release_host(card->func);
+	LEAVE();
+	return ret;
+}
+
+/** 
+ *  @brief This function reads CIS informaion.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+sbi_get_cis_info(wlan_private * priv)
+{
+	wlan_adapter *Adapter = priv->adapter;
+	u8 tupledata[255];
+	ENTER();
+
+	/* TODO using sdio tuple data */
+
+	/* Copy the CIS Table to Adapter */
+	memset(Adapter->CisInfoBuf, 0x0, sizeof(Adapter->CisInfoBuf));
+	memcpy(Adapter->CisInfoBuf, tupledata, sizeof(tupledata));
+	Adapter->CisInfoLen = sizeof(tupledata);
+
+	LEAVE();
+	return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function probes the card.
+ *  
+ *  @param card_p  A pointer to the card
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+sbi_probe_card(void *card_p)
+{
+	struct if_sdio_card* card = (struct if_sdio_card*)card_p;
+	int ret = WLAN_STATUS_SUCCESS;
+
+	if (!card) {
+		ret = -ENODEV;		//WLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	/* Check for MANFID */
+	PRINTM(INFO, "Marvell SDIO card detected!\n");
+
+	sdio_claim_host(card->func);
+	/* read Revision Register to get the hw revision number */
+	card->chiprev = sdio_readb(card->func, CARD_REVISION_REG, &ret);
+	if (ret) {
+		PRINTM(FATAL, "cannot read CARD_REVISION_REG\n");
+	}
+	else {
+		PRINTM(INFO, "revision=0x%x\n", card->chiprev);
+		switch (card->chiprev) {
+		default:
+			card->block_size_512 = TRUE;
+			card->async_int_mode = TRUE;
+			break;
+		}
+	}
+
+	ret = WLAN_STATUS_SUCCESS;
+done:
+	sdio_release_host(card->func);
+	return ret;
+}
+
+/** 
+ *  @brief This function calls sbi_download_wlan_fw_image to download
+ *  firmware image to the card.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+sbi_prog_firmware_w_helper(wlan_private * priv)
+{
+	wlan_adapter *Adapter = priv->adapter;
+	if (Adapter->fmimage != NULL) {
+		return sbi_download_wlan_fw_image(priv,
+						  Adapter->fmimage,
+						  Adapter->fmimage_len);
+	}
+	else {
+		PRINTM(MSG, "No external FW image\n");
+		return WLAN_STATUS_FAILURE;
+	}
+}
+
+/** 
+ *  @brief This function programs helper image.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+sbi_prog_helper(wlan_private * priv)
+{
+	wlan_adapter *Adapter = priv->adapter;
+	if (Adapter->helper != NULL) {
+		return sbi_prog_firmware_image(priv,
+					       Adapter->helper, Adapter->helper_len);
+	}
+	else {
+		PRINTM(MSG, "No external helper image\n");
+		return WLAN_STATUS_FAILURE;
+	}
+}
+
+/** 
+ *  @brief This function checks if the firmware is ready to accept
+ *  command or not.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+sbi_verify_fw_download(wlan_private * priv)
+{
+	int ret = WLAN_STATUS_SUCCESS;
+	u16 firmwarestat;
+	int tries;
+	struct if_sdio_card* card = (struct if_sdio_card*)priv->wlan_dev.card;
+
+	sdio_claim_host(card->func);
+	/* Wait for firmware initialization event */
+	for (tries = 0; tries < MAX_FIRMWARE_POLL_TRIES; tries++) {
+		if ((ret = mv_sdio_read_scratch(priv, &firmwarestat)) < 0)
+			continue;
+
+		if (firmwarestat == FIRMWARE_READY) {
+			ret = WLAN_STATUS_SUCCESS;
+			break;
+		}
+		else {
+			mdelay(10);
+			ret = WLAN_STATUS_FAILURE;
+		}
+	}
+
+	if (ret < 0) {
+		PRINTM(MSG, "Timeout waiting for FW to become active\n");
+		goto done;
+	}
+
+	ret = WLAN_STATUS_SUCCESS;
+done:
+	sdio_release_host(card->func);
+	return ret;
+}
+
+/** 
+ *  @brief This function set bus clock on/off
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param option    TRUE--on , FALSE--off
+ *  @return 	   WLAN_STATUS_SUCCESS
+ */
+int
+sbi_set_bus_clock(wlan_private * priv, u8 option)
+{
+/*	if (option == TRUE)
+		start_bus_clock(((mmc_card_t) ((priv->wlan_dev).card))->ctrlr);
+	else
+		stop_bus_clock_2(((mmc_card_t) ((priv->wlan_dev).card))->ctrlr); */
+	return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function makes firmware exiting from deep sleep.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+sbi_exit_deep_sleep(wlan_private * priv)
+{
+	int ret = WLAN_STATUS_SUCCESS;
+	struct if_sdio_card* card = (struct if_sdio_card*)priv->wlan_dev.card;
+
+	sbi_set_bus_clock(priv, TRUE);
+
+	sdio_claim_host(card->func);
+	sdio_writeb(card->func, HOST_POWER_UP, CONFIGURATION_REG, &ret);
+	sdio_release_host(card->func);
+
+	return ret;
+}
+
+/** 
+ *  @brief This function resets the setting of deep sleep.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+sbi_reset_deepsleep_wakeup(wlan_private * priv)
+{
+
+	int ret = WLAN_STATUS_SUCCESS;
+	struct if_sdio_card* card = (struct if_sdio_card*)priv->wlan_dev.card;
+
+	ENTER();
+
+	sdio_claim_host(card->func);
+	sdio_writeb(card->func, 0, CONFIGURATION_REG, &ret);
+	sdio_release_host(card->func);
+
+	LEAVE();
+
+	return ret;
+}
+
+static const struct sdio_device_id if_sdio_ids[] = {
+	{ SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_LIBERTAS)},
+	{ /* end: all zeroes */},
+};
+
+MODULE_DEVICE_TABLE(sdio, if_sdio_ids);
+struct if_sdio_model
+{
+	int model;
+	const char *helper;
+	const char *firmware;
+};
+
+static struct if_sdio_model if_sdio_models[] = {
+	{
+		/* 8686 */
+		.model = 0x0B,
+		.helper = "/lib/firmware/sd8686_helper.bin",
+		.firmware = "/lib/firmware/sd8686.bin",
+	},
+};
+
+static int if_sdio_probe(struct sdio_func *func,
+			 const struct sdio_device_id *id)
+{
+	struct if_sdio_card *card;
+	int ret, i;
+	unsigned int model;
+
+	card = kzalloc(sizeof(struct if_sdio_card), GFP_KERNEL);
+	
+	for (i = 0;i < func->card->num_info;i++) {
+		if (sscanf(func->card->info[i],
+			   "802.11 SDIO ID: %x", &model) == 1)
+			break;
+		if (sscanf(func->card->info[i],
+			   "ID: %x", &model) == 1)
+			break;
+		if (!strcmp(func->card->info[i], "IBIS Wireless SDIO Card")) {
+			model = 4;
+			break;
+		}
+	}
+
+	if (i == func->card->num_info) {
+		printk("unable to identify card model\n");
+		return -ENODEV;
+	}
+	
+	card->func = func;
+	card->model = model;
+
+	for (i = 0;i < ARRAY_SIZE(if_sdio_models);i++) {
+		if (card->model == if_sdio_models[i].model)
+			break;
+	}
+
+	if (i == ARRAY_SIZE(if_sdio_models)) {
+		printk("unknown card model 0x%x\n", card->model);
+		ret = -ENODEV;
+		goto free;
+	}
+
+	helper_name = if_sdio_models[i].helper;
+	fw_name = if_sdio_models[i].firmware;
+
+	sdio_claim_host(func);
+
+	ret = sdio_enable_func(func);
+	if (ret)
+		goto release;
+
+	sdio_writeb(func, 0x00, HOST_INT_MASK_REG, &ret);
+	if (ret) {
+		PRINTM(WARN, "Unable to diable the host interrupt!\n");
+		goto reclaim;
+	}
+
+	ret = sdio_claim_irq(func, sbi_interrupt);
+	if (ret)
+		goto disable;
+
+	sdio_release_host(func);
+
+	sdio_set_drvdata(func, card);
+
+	ret = sbi_add_card(card, &func->dev);
+	if (ret)
+		goto reclaim;
+
+out:
+	return ret;
+
+reclaim:
+	sdio_claim_host(func);
+	sdio_release_irq(func);
+disable:
+	sdio_disable_func(func);
+release:
+	sdio_release_host(func);
+free:
+	kfree(card);
+	goto out;
+}
+
+static void if_sdio_remove(struct sdio_func *func)
+{
+	struct if_sdio_card *card = sdio_get_drvdata(func);
+	sbi_remove_card(card);
+	sdio_claim_host(func);
+	sdio_release_irq(func);
+	sdio_disable_func(func);
+	sdio_release_host(func);
+	kfree(card);
+	return;
+}
+
+static struct sdio_driver if_sdio_driver = {
+	.name           = "sd8686_sdio",
+	.id_table       = if_sdio_ids,
+	.probe          = if_sdio_probe,
+	.remove         = if_sdio_remove,
+};
+
+static int if_sdio_init_module(void)
+{
+	int ret = 0;
+
+	printk(KERN_INFO "8686 sdio: sd 8686 driver\n");
+	printk(KERN_INFO "8686 sdio: Copyright HHCN 2009\n");
+
+	ret = sdio_register_driver(&if_sdio_driver);
+
+	return ret;
+}
+
+static void if_sdio_exit_module(void)
+{
+	sdio_unregister_driver(&if_sdio_driver);
+}
+
+module_init(if_sdio_init_module);
+module_exit(if_sdio_exit_module);
+
+MODULE_DESCRIPTION("Marvell SD8686 SDIO WLAN Driver");
+MODULE_AUTHOR("You Sheng");
+MODULE_LICENSE("GPL");
Index: linux-2.6.29/drivers/net/wireless/marvell8686/if_sdio.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/if_sdio.h	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,97 @@
+/** @file if_sdio.h
+ *  @brief This file contains SDIO IF (interface) module
+ *  related macros, enum, and structure.
+ *
+ *  Copyright  Marvell International Ltd. and/or its affiliates, 2003-2006
+ */
+/****************************************************
+Change log:
+	10/12/05: add Doxygen format comments 
+****************************************************/
+
+#ifndef	_IF_SDIO_H_
+#define	_IF_SDIO_H_
+
+#include	"include.h"
+#include	"sdio.h"
+
+#define SD_BUS_WIDTH_1			0x00
+#define SD_BUS_WIDTH_4			0x02
+#define SD_BUS_WIDTH_MASK		0x03
+#define ASYNC_INT_MODE			0x20
+
+/* Host Control Registers */
+#define IO_PORT_0_REG			0x00
+#define IO_PORT_1_REG			0x01
+#define IO_PORT_2_REG			0x02
+#define CONFIGURATION_REG		0x03
+#define HOST_WO_CMD53_FINISH_HOST	(0x1U << 2)
+#define HOST_POWER_UP			(0x1U << 1)
+#define HOST_POWER_DOWN			(0x1U << 0)
+#define HOST_INT_MASK_REG		0x04
+#define UP_LD_HOST_INT_MASK		(0x1U)
+#define DN_LD_HOST_INT_MASK		(0x2U)
+#define HOST_INTSTATUS_REG		0x05
+#define UP_LD_HOST_INT_STATUS		(0x1U)
+#define DN_LD_HOST_INT_STATUS		(0x2U)
+#define HOST_INT_RSR_REG		0x06
+#define UP_LD_HOST_INT_RSR		(0x1U)
+#define HOST_INT_STATUS_REG		0x07
+#define UP_LD_CRC_ERR			(0x1U << 2)
+#define UP_LD_RESTART              	(0x1U << 1)
+#define DN_LD_RESTART              	(0x1U << 0)
+
+/* Card Control Registers */
+#define SQ_READ_BASE_ADDRESS_A0_REG  	0x10
+#define SQ_READ_BASE_ADDRESS_A1_REG  	0x11
+#define SQ_READ_BASE_ADDRESS_A2_REG  	0x12
+#define SQ_READ_BASE_ADDRESS_A3_REG  	0x13
+#define SQ_READ_BASE_ADDRESS_B0_REG  	0x14
+#define SQ_READ_BASE_ADDRESS_B1_REG  	0x15
+#define SQ_READ_BASE_ADDRESS_B2_REG  	0x16
+#define SQ_READ_BASE_ADDRESS_B3_REG  	0x17
+#define CARD_STATUS_REG              	0x20
+#define CARD_IO_READY              	(0x1U << 3)
+#define CIS_CARD_RDY                 	(0x1U << 2)
+#define UP_LD_CARD_RDY               	(0x1U << 1)
+#define DN_LD_CARD_RDY               	(0x1U << 0)
+#define HOST_INTERRUPT_MASK_REG      	0x24
+#define HOST_POWER_INT_MASK          	(0x1U << 3)
+#define ABORT_CARD_INT_MASK          	(0x1U << 2)
+#define UP_LD_CARD_INT_MASK          	(0x1U << 1)
+#define DN_LD_CARD_INT_MASK          	(0x1U << 0)
+#define CARD_INTERRUPT_STATUS_REG    	0x28
+#define POWER_UP_INT                 	(0x1U << 4)
+#define POWER_DOWN_INT               	(0x1U << 3)
+#define CARD_INTERRUPT_RSR_REG       	0x2c
+#define POWER_UP_RSR                 	(0x1U << 4)
+#define POWER_DOWN_RSR               	(0x1U << 3)
+#define DEBUG_0_REG                  	0x30
+#define SD_TESTBUS0                  	(0x1U)
+#define DEBUG_1_REG                  	0x31
+#define SD_TESTBUS1                  	(0x1U)
+#define DEBUG_2_REG                  	0x32
+#define SD_TESTBUS2                  	(0x1U)
+#define DEBUG_3_REG                  	0x33
+#define SD_TESTBUS3                  	(0x1U)
+#define CARD_OCR_0_REG               	0x34
+#define CARD_OCR_1_REG               	0x35
+#define CARD_OCR_3_REG               	0x36
+#define CARD_CONFIG_REG              	0x38
+#define CARD_REVISION_REG            	0x3c
+#define CMD53_FINISH_GBUS            	(0x1U << 1)
+#define SD_NEG_EDGE                  	(0x1U << 0)
+
+/* Special registers in function 0 of the SDxx card */
+#define	SCRATCH_0_REG			0x80fe
+#define	SCRATCH_1_REG			0x80ff
+
+#define HOST_F1_RD_BASE_0		0x0010
+#define HOST_F1_RD_BASE_1		0x0011
+#define HOST_F1_CARD_RDY		0x0020
+
+/********************************************************
+		Global Functions
+********************************************************/
+
+#endif /* _IF_SDIO_H */
Index: linux-2.6.29/drivers/net/wireless/marvell8686/include.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/include.h	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,42 @@
+/** @file include.h
+ * 
+ * @brief This file contains all the necessary include file.
+ *  
+ *  Copyright  Marvell International Ltd. and/or its affiliates, 2003-2007
+ */
+/********************************************************
+Change log:
+	10/11/05: Add Doxygen format comments
+	01/11/06: Conditional include file removal/addition
+	01/30/06: Add kernel 2.6 support
+	
+********************************************************/
+
+#ifndef _INCLUDE_H_
+#define _INCLUDE_H_
+
+#include    "os_headers.h"
+#include    "wlan_types.h"
+#include    "wlan_defs.h"
+#include    "wlan_thread.h"
+
+#include    "wlan_wmm.h"
+#include    "wlan_11d.h"
+
+#include    "os_timers.h"
+
+#include    "host.h"
+#include    "hostcmd.h"
+
+#include    "wlan_scan.h"
+#include    "wlan_join.h"
+
+#include    "wlan_dev.h"
+#include    "os_macros.h"
+#include    "sbi.h"
+
+#include    "sdio.h"
+
+#include    "wlan_wext.h"
+#include    "wlan_decl.h"
+#endif /* _INCLUDE_H_ */
Index: linux-2.6.29/drivers/net/wireless/marvell8686/os_defs.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/os_defs.h	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,42 @@
+/*
+ * Copyright  Marvell International Ltd. and/or its affiliates, 2003-2006
+ */
+
+#ifndef _OS_HEADER1_
+#define _OS_HEADER1_
+
+typedef char CHAR;
+typedef char *PCHAR;
+typedef u8 *PUCHAR;
+typedef u16 *PUSHORT;
+typedef long *PLONG;
+typedef PLONG LONG_PTR;
+typedef u32 *ULONG_PTR;
+typedef u32 *Pu32;
+typedef unsigned int UINT;
+typedef UINT *PUINT;
+typedef void VOID;
+typedef VOID *PVOID;
+typedef int WLAN_STATUS;
+typedef u8 BOOLEAN;
+typedef BOOLEAN *PBOOLEAN;
+typedef PVOID PDRIVER_OBJECT;
+typedef PUCHAR PUNICODE_STRING;
+typedef long long LONGLONG;
+typedef LONGLONG *PLONGLONG;
+typedef unsigned long long *PULONGLONG;
+typedef PUCHAR ANSI_STRING;
+typedef ANSI_STRING *PANSI_STRING;
+typedef unsigned short WCHAR;
+typedef WCHAR *PWCHAR;
+typedef WCHAR *LPWCH, *PWCH;
+typedef WCHAR *NWPSTR;
+typedef WCHAR *LPWSTR, *PWSTR;
+typedef struct semaphore SEMAPHORE;
+
+#ifdef __KERNEL__
+typedef irqreturn_t IRQ_RET_TYPE;
+#define IRQ_RET		return IRQ_HANDLED
+#endif /* __KERNEL__ */
+
+#endif /* _OS_HEADER1 */
Index: linux-2.6.29/drivers/net/wireless/marvell8686/os_headers.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/os_headers.h	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,69 @@
+/*
+ * Copyright  Marvell International Ltd. and/or its affiliates, 2003-2006
+ */
+
+#ifndef _OS_HEADERS_H
+#define _OS_HEADERS_H
+
+#ifndef __ATTRIB_ALIGN__
+#define __ATTRIB_ALIGN__ __attribute__((aligned(4)))
+#endif
+
+#ifndef __ATTRIB_PACK__
+#define __ATTRIB_PACK__ __attribute__ ((packed))
+#endif
+
+/* Linux header files */
+#include        <linux/kernel.h>
+#include        <linux/module.h>
+#include        <linux/init.h>
+#include        <linux/version.h>
+#include        <linux/param.h>
+#include        <linux/delay.h>
+#include        <linux/slab.h>
+#include        <linux/mm.h>
+#include        <linux/types.h>
+#include        <linux/sched.h>
+#include        <linux/timer.h>
+#include        <linux/types.h>
+#include        <linux/ioport.h>
+#include        <linux/pci.h>
+#include        <linux/ctype.h>
+#include        <linux/proc_fs.h>
+#include	<linux/ptrace.h>
+#include	<linux/string.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+#include	<linux/config.h>
+#endif
+
+#include	<linux/ioport.h>
+
+/* New Code to synchronize between IEEE Power save and PM*/
+#ifdef ENABLE_PM
+#include <linux/pm.h>
+#endif
+
+/* ASM files */
+#include        <linux/semaphore.h>
+#include        <asm/byteorder.h>
+#include        <asm/irq.h>
+#include        <asm/uaccess.h>
+#include        <asm/io.h>
+#include	<asm/system.h>
+
+/* Net header files */
+#include        <linux/wireless.h>
+#include        <linux/netdevice.h>
+#include        <linux/net.h>
+#include        <linux/ip.h>
+#include        <linux/skbuff.h>
+#include        <linux/if_arp.h>
+#include        <linux/if_ether.h>
+#include        <linux/etherdevice.h>
+#include        <net/arp.h>
+#include        <linux/rtnetlink.h>
+
+/* Wireless header */
+#include        <net/iw_handler.h>
+#endif
Index: linux-2.6.29/drivers/net/wireless/marvell8686/os_macros.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/os_macros.h	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,165 @@
+/*
+ * Copyright  Marvell International Ltd. and/or its affiliates, 2003-2006
+ */
+#ifndef	_OS_MACROS_H
+#define _OS_MACROS_H
+
+#define os_time_get()	jiffies
+
+extern spinlock_t driver_lock;
+extern unsigned long driver_flags;
+#define OS_INT_DISABLE	spin_lock_irqsave(&driver_lock, driver_flags)
+#define	OS_INT_RESTORE	spin_unlock_irqrestore(&driver_lock, driver_flags); \
+			driver_lock = SPIN_LOCK_UNLOCKED
+
+#define UpdateTransStart(dev) { \
+	dev->trans_start = jiffies; \
+}
+
+#define OS_SET_THREAD_STATE(x)		set_current_state(x)
+
+#define MODULE_GET	if(try_module_get(THIS_MODULE)==0) return WLAN_STATUS_FAILURE;
+#define MODULE_PUT	module_put(THIS_MODULE)
+
+#define OS_INIT_SEMAPHORE(x)    	init_MUTEX(x)
+#define OS_ACQ_SEMAPHORE_BLOCK(x)	down_interruptible(x)
+#define OS_ACQ_SEMAPHORE_NOBLOCK(x)	down_trylock(x)
+#define OS_REL_SEMAPHORE(x) 		up(x)
+
+/* Definitions below are needed for other OS like threadx */
+#define	TX_DISABLE
+#define TX_RESTORE
+#define	ConfigureThreadPriority()
+#define OS_INTERRUPT_SAVE_AREA
+#define OS_FREE_LOCK(x)
+#define TX_EVENT_FLAGS_SET(x, y, z)
+
+#define os_wait_interruptible_timeout(waitq, cond, timeout) \
+	wait_event_interruptible_timeout(waitq, cond, timeout)
+
+static inline void
+os_sched_timeout(u32 millisec)
+{
+    set_current_state(TASK_INTERRUPTIBLE);
+
+    schedule_timeout((millisec * HZ) / 1000);
+}
+
+static inline void
+os_schedule(u32 millisec)
+{
+    schedule_timeout((millisec * HZ) / 1000);
+}
+
+static inline int
+CopyMulticastAddrs(wlan_adapter * Adapter, struct net_device *dev)
+{
+    int i = 0;
+    struct dev_mc_list *mcptr = dev->mc_list;
+
+    for (i = 0; i < dev->mc_count; i++) {
+        memcpy(&Adapter->MulticastList[i], mcptr->dmi_addr, ETH_ALEN);
+        mcptr = mcptr->next;
+    }
+
+    return i;
+}
+
+static inline u32
+get_utimeofday(void)
+{
+    struct timeval t;
+    u32 ut;
+
+    do_gettimeofday(&t);
+    ut = (u32) t.tv_sec * 1000000 + ((u32) t.tv_usec);
+    return ut;
+}
+
+static inline int
+os_upload_rx_packet(wlan_private * priv, struct sk_buff *skb)
+{
+
+#define IPFIELD_ALIGN_OFFSET	2
+
+    skb->dev = priv->wlan_dev.netdev;
+    skb->protocol = eth_type_trans(skb, priv->wlan_dev.netdev);
+    skb->ip_summed = CHECKSUM_UNNECESSARY;
+
+    netif_rx(skb);
+
+    return 0;
+}
+
+static inline void
+os_free_tx_packet(wlan_private * priv)
+{
+    ulong flags;
+
+    if (priv->adapter->CurrentTxSkb) {
+        kfree_skb(priv->adapter->CurrentTxSkb);
+        spin_lock_irqsave(&priv->adapter->CurrentTxLock, flags);
+        priv->adapter->CurrentTxSkb = NULL;
+        spin_unlock_irqrestore(&priv->adapter->CurrentTxLock, flags);
+    }
+}
+
+/*
+ *  netif carrier_on/off and start(wake)/stop_queue handling
+ *
+ *           carrier_on      carrier_off     start_queue     stop_queue
+ * open           x(connect)      x(disconnect)   x
+ * close                          x                               x
+ * assoc          x                               x
+ * deauth                         x                               x
+ * adhoc-start
+ * adhoc-join
+ * adhoc-link     x                               x
+ * adhoc-bcnlost                  x                               x
+ * scan-begin                     x                               x
+ * scan-end       x                               x
+ * ds-enter                       x                               x
+ * ds-exit        x                               x
+ * xmit                                                           x
+ * xmit-done                                      x
+ * tx-timeout
+ */
+static inline void
+os_carrier_on(wlan_private * priv)
+{
+    if (!netif_carrier_ok(priv->wlan_dev.netdev) &&
+        (priv->adapter->MediaConnectStatus == WlanMediaStateConnected) &&
+        ((priv->adapter->InfrastructureMode != Wlan802_11IBSS) ||
+         (priv->adapter->AdhocLinkSensed))) {
+        netif_carrier_on(priv->wlan_dev.netdev);
+    }
+}
+
+static inline void
+os_carrier_off(wlan_private * priv)
+{
+    if (netif_carrier_ok(priv->wlan_dev.netdev)) {
+        netif_carrier_off(priv->wlan_dev.netdev);
+    }
+}
+
+static inline void
+os_start_queue(wlan_private * priv)
+{
+    if (netif_queue_stopped(priv->wlan_dev.netdev) &&
+        (priv->adapter->MediaConnectStatus == WlanMediaStateConnected) &&
+        ((priv->adapter->InfrastructureMode != Wlan802_11IBSS) ||
+         (priv->adapter->AdhocLinkSensed))) {
+        netif_wake_queue(priv->wlan_dev.netdev);
+    }
+}
+
+static inline void
+os_stop_queue(wlan_private * priv)
+{
+    if (!netif_queue_stopped(priv->wlan_dev.netdev)) {
+        netif_stop_queue(priv->wlan_dev.netdev);
+    }
+}
+
+#endif /* _OS_MACROS_H */
Index: linux-2.6.29/drivers/net/wireless/marvell8686/os_timers.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/os_timers.h	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,83 @@
+/*
+ * Copyright  Marvell International Ltd. and/or its affiliates, 2003-2006
+ */
+
+#ifndef	_OS_TIMERS_H
+#define _OS_TIMERS_H
+
+typedef struct __WLAN_DRV_TIMER
+{
+    struct timer_list tl;
+    void (*timer_function) (void *context);
+    void *function_context;
+    UINT time_period;
+    BOOLEAN timer_is_periodic;
+    BOOLEAN timer_is_canceled;
+} __ATTRIB_PACK__ WLAN_DRV_TIMER, *PWLAN_DRV_TIMER;
+
+static inline void
+TimerHandler(unsigned long fcontext)
+{
+    PWLAN_DRV_TIMER timer = (PWLAN_DRV_TIMER) fcontext;
+
+    timer->timer_function(timer->function_context);
+
+    if (timer->timer_is_periodic == TRUE) {
+        mod_timer(&timer->tl, jiffies + ((timer->time_period * HZ) / 1000));
+    }
+}
+
+static inline void
+InitializeTimer(PWLAN_DRV_TIMER timer,
+                void (*TimerFunction) (void *context), void *FunctionContext)
+{
+    // first, setup the timer to trigger the WlanTimerHandler proxy
+    init_timer(&timer->tl);
+    timer->tl.function = TimerHandler;
+    timer->tl.data = (u32) timer;
+
+    // then tell the proxy which function to call and what to pass it       
+    timer->timer_function = TimerFunction;
+    timer->function_context = FunctionContext;
+    timer->timer_is_canceled = FALSE;
+}
+
+static inline void
+SetTimer(PWLAN_DRV_TIMER timer, UINT MillisecondPeriod)
+{
+    timer->time_period = MillisecondPeriod;
+    timer->timer_is_periodic = FALSE;
+    timer->tl.expires = jiffies + (MillisecondPeriod * HZ) / 1000;
+    add_timer(&timer->tl);
+    timer->timer_is_canceled = FALSE;
+}
+
+static inline void
+ModTimer(PWLAN_DRV_TIMER timer, UINT MillisecondPeriod)
+{
+    timer->time_period = MillisecondPeriod;
+    timer->timer_is_periodic = FALSE;
+    mod_timer(&timer->tl, jiffies + (MillisecondPeriod * HZ) / 1000);
+    timer->timer_is_canceled = FALSE;
+}
+
+static inline void
+SetPeriodicTimer(PWLAN_DRV_TIMER timer, UINT MillisecondPeriod)
+{
+    timer->time_period = MillisecondPeriod;
+    timer->timer_is_periodic = TRUE;
+    timer->tl.expires = jiffies + (MillisecondPeriod * HZ) / 1000;
+    add_timer(&timer->tl);
+    timer->timer_is_canceled = FALSE;
+}
+
+#define	FreeTimer(x)	do {} while (0)
+
+static inline void
+CancelTimer(WLAN_DRV_TIMER * timer)
+{
+    del_timer(&timer->tl);
+    timer->timer_is_canceled = TRUE;
+}
+
+#endif /* _OS_TIMERS_H */
Index: linux-2.6.29/drivers/net/wireless/marvell8686/release_version.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/release_version.h	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,5 @@
+/**
+  * Copyright  Marvell International Ltd. and/or its affiliates, 2003-2006
+  */
+
+#define DRIVER_RELEASE_VERSION		"26409.p60"
Index: linux-2.6.29/drivers/net/wireless/marvell8686/sbi.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/sbi.h	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,111 @@
+/** @file sbi.h
+ * 
+ * @brief This file contains IF layer definitions.
+ *  
+ *  Copyright  Marvell International Ltd. and/or its affiliates, 2003-2006
+ */
+/********************************************************
+Change log:
+	10/11/05: Add Doxygen format comments
+	01/05/06: Add kernel 2.6.x support	
+	
+********************************************************/
+
+#ifndef	_SBI_H_
+#define	_SBI_H_
+
+/**Bit Definition*/
+#define B_BIT_0		0x01
+#define B_BIT_1		0x02
+#define B_BIT_2		0x04
+#define B_BIT_3		0x08
+#define B_BIT_4		0x10
+#define B_BIT_5		0x20
+#define B_BIT_6		0x40
+#define B_BIT_7		0x80
+#define B_BIT_8		0x100
+#define B_BIT_9		0X200
+#define B_BIT_10	0x400
+
+/** INT Status Bit Definition*/
+#define HIS_RxUpLdRdy			B_BIT_0
+#define HIS_TxDnLdRdy			B_BIT_1
+#define HIS_CmdDnLdRdy			B_BIT_2
+#define HIS_CardEvent			B_BIT_3
+#define HIS_CmdUpLdRdy			B_BIT_4
+#define HIS_WrFifoOvrflow		B_BIT_5
+#define HIS_RdFifoUndrflow		B_BIT_6
+#define HIS_WlanReady			B_BIT_7
+
+#define	HIM_DISABLE			0xff
+#define HIM_ENABLE			0x03
+
+#define FIRMWARE_READY			0xfedc
+#ifndef DEV_NAME_LEN
+#define DEV_NAME_LEN			32
+#endif
+#define MAXKEYLEN			13
+
+/* The number of times to try when polling for status bits */
+#define MAX_POLL_TRIES			1000
+
+/* The number of times to try when waiting for downloaded firmware to 
+     become active. (polling the scratch register). */
+
+#define MAX_FIRMWARE_POLL_TRIES		1000
+
+#define FIRMWARE_TRANSFER_NBLOCK	1
+#define SBI_EVENT_CAUSE_SHIFT		3
+
+typedef enum _mv_sd_type
+{
+    MVSD_DAT = 0,
+    MVSD_CMD = 1,
+    MVSD_EVENT = 3
+} mv_sd_type;
+
+/** Function Prototype Declaration */
+typedef wlan_private *(*wlan_notifier_fn_add) (void *dev_id);
+typedef int (*wlan_notifier_fn_remove) (void *dev_id);
+
+typedef IRQ_RET_TYPE(*isr_notifier_fn_t) (s32 irq, void *dev_id,
+                                          struct pt_regs * reg);
+typedef IRQ_RET_TYPE(*handler_fn_t) (s32 irq, void *dev_id, struct pt_regs *);
+
+/* Probe and Check if the card is present*/
+int sbi_probe_card(void *card);
+int *sbi_register(wlan_notifier_fn_add, wlan_notifier_fn_remove, void *);
+int sbi_register_dev(wlan_private * priv);
+int sbi_unregister_dev(wlan_private *);
+int sbi_disable_host_int(wlan_private * priv);
+int sbi_get_int_status(wlan_private * priv, u8 *);
+void sbi_unregister(void);
+int sbi_prog_firmware(wlan_private *);
+int sbi_verify_fw_download(wlan_private *);
+
+int sbi_prog_helper(wlan_private *);
+int sbi_prog_firmware_w_helper(wlan_private *);
+
+int sbi_read_event_cause(wlan_private *);
+int sbi_host_to_card(wlan_private * priv, u8 type, u8 * payload, u16 nb);
+int sbi_card_to_host(wlan_private * priv, u32 type, u32 * nb, u8 * payload,
+                     u16 npayload);
+int sbi_enable_host_int(wlan_private *);
+
+int sbi_exit_deep_sleep(wlan_private *);
+int sbi_reset_deepsleep_wakeup(wlan_private *);
+#ifdef ENABLE_PM
+int sbi_suspend(wlan_private *);
+int sbi_resume(wlan_private *);
+#endif
+
+int sbi_read_ioreg(wlan_private * priv, u8 func, u32 reg, u8 * dat);
+int sbi_write_ioreg(wlan_private * priv, u8 func, u32 reg, u8 dat);
+int sbi_set_bus_clock(wlan_private * priv, u8 option);
+
+int sbi_get_cis_info(wlan_private * priv);
+
+int wlan_remove_card(void *card);
+wlan_private* wlan_add_card(void *card, struct device *dmdev);
+
+#endif /* _SBI_H */
Index: linux-2.6.29/drivers/net/wireless/marvell8686/sdio.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/sdio.h	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,112 @@
+/*File sdio.h
+ * This file contains the structure definations for the low level driver
+ * And the error response related code
+ *
+ *  Copyright  Marvell International Ltd. and/or its affiliates, 2003-2006
+ */
+
+#ifndef __SDIO_H__
+#define __SDIO_H__
+
+#include	<linux/spinlock.h>      /* For read write semaphores */
+#include	<linux/semaphore.h>
+#include	<linux/completion.h>
+#include	<asm/dma.h>
+#ifdef CONFIG_MARVELL_8686_PROC_FS
+	#include 	<linux/proc_fs.h>
+#endif
+
+#include 	"os_defs.h"
+
+#ifdef	DEBUG_SDIO_LEVEL2
+#ifndef DEBUG_LEVEL1
+#define	DEBUG_LEVEL1
+#endif
+#define	_ENTER() printk(KERN_DEBUG "Enter: %s, %s linux %i\n", __FUNCTION__, \
+			__FILE__, __LINE__)
+#define	_LEAVE() printk(KERN_DEBUG "Leave: %s, %s linux %i\n", __FUNCTION__, \
+			__FILE__, __LINE__)
+#else
+#define _ENTER()
+#define _LEAVE()
+#endif
+
+#ifdef	DEBUG_SDIO_LEVEL1
+#define	_DBGMSG(x...)		printk(KERN_DEBUG x)
+#define	_WARNING(x...)		printk(KERN_DEBUG x)
+#else
+#define	_DBGMSG(x...)
+#define	_WARNING(x...)
+#endif
+
+#ifdef DEBUG_SDIO_LEVEL0
+#define	_PRINTK(x...)		printk(x)
+#define	_ERROR(x...)		printk(KERN_ERR x)
+#else
+#define	_PRINTK(x...)
+#define	_ERROR(x...)
+#endif
+
+typedef struct _card_capability
+{
+	u8 num_of_io_funcs;	    /* Number of i/o functions */
+	u8 memory_yes;		    /* Memory present ? */
+	u16 rca;		    /* Relative Card Address */
+	u32 ocr;		    /* Operation Condition register */
+	u16 fnblksz[8];
+	u32 cisptr[8];
+} card_capability;
+
+typedef struct _dummy_tmpl
+{
+	int irq_line;
+} dummy_tmpl;
+
+typedef struct _sdio_host *mmc_controller_t;
+
+typedef enum _sdio_fsm
+{
+	SDIO_FSM_IDLE = 1,
+	SDIO_FSM_CLK_OFF,
+	SDIO_FSM_END_CMD,
+	SDIO_FSM_BUFFER_IN_TRANSIT,
+	SDIO_FSM_END_BUFFER,
+	SDIO_FSM_END_IO,
+	SDIO_FSM_END_PRG,
+	SDIO_FSM_ERROR
+} sdio_fsm_state;
+
+typedef struct _sdio_host
+{
+	char name[16];
+	int bus_width;
+} __attribute__ ((aligned)) sdio_ctrller;
+
+typedef struct _sdio_operations
+{
+	char name[16];
+} sdio_operations;
+
+typedef struct _iorw_extended_t
+{
+	u8 rw_flag;	     /** If 0 command is READ; else if 1 command is WRITE */
+	u8 func_num;
+	u8 blkmode;
+	u8 op_code;
+	u32 reg_addr;
+	u32 byte_cnt;
+	u32 blk_size;
+	u8 *buf;
+} iorw_extended_t;
+
+#define BUS_INTERFACE_CONTROL_REG 	0x07
+#define CARD_CAPABILITY_REG		0x08
+#define COMMON_CIS_POINTER_0_REG	0x09
+#define COMMON_CIS_POINTER_1_REG	0x0a
+#define COMMON_CIS_POINTER_2_REG	0x0b
+#define BUS_SUSPEND_REG			0x0c
+#define FUNCTION_SELECT_REG		0x0d
+#define EXEC_FLAGS_REG			0x0e
+#define READY_FLAGS_REG			0x0f
+
+#endif /* __SDIO__H */
Index: linux-2.6.29/drivers/net/wireless/marvell8686/wlan_11d.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/wlan_11d.c	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,893 @@
+/** @file wlan_11d.c
+  * @brief This file contains functions for 802.11D.
+  * 
+  *  Copyright  Marvell International Ltd. and/or its affiliates, 2003-2006
+  */
+/********************************************************
+Change log:
+	10/04/05: Add Doxygen format comments
+	
+********************************************************/
+#include	"include.h"
+
+/********************************************************
+		Local Variables
+********************************************************/
+#define TX_PWR_DEFAULT	10
+
+static region_code_mapping_t region_code_mapping[] = {
+    {"US ", 0x10},              /* US FCC      */
+    {"CA ", 0x20},              /* IC Canada   */
+    {"SG ", 0x10},              /* Singapore   */
+    {"EU ", 0x30},              /* ETSI        */
+    {"AU ", 0x30},              /* Australia   */
+    {"KR ", 0x30},              /* Republic Of Korea */
+    {"FR ", 0x32},              /* France      */
+    {"JP ", 0x40},              /* Japan       */
+    {"JP ", 0x41},              /* Japan       */
+};
+
+/********************************************************
+		Global Variables
+********************************************************/
+/* Following 2 structure defines the supported channels */
+CHANNEL_FREQ_POWER channel_freq_power_UN_BG[] = {
+    {1, 2412, TX_PWR_DEFAULT},
+    {2, 2417, TX_PWR_DEFAULT},
+    {3, 2422, TX_PWR_DEFAULT},
+    {4, 2427, TX_PWR_DEFAULT},
+    {5, 2432, TX_PWR_DEFAULT},
+    {6, 2437, TX_PWR_DEFAULT},
+    {7, 2442, TX_PWR_DEFAULT},
+    {8, 2447, TX_PWR_DEFAULT},
+    {9, 2452, TX_PWR_DEFAULT},
+    {10, 2457, TX_PWR_DEFAULT},
+    {11, 2462, TX_PWR_DEFAULT},
+    {12, 2467, TX_PWR_DEFAULT},
+    {13, 2472, TX_PWR_DEFAULT},
+    {14, 2484, TX_PWR_DEFAULT}
+};
+
+CHANNEL_FREQ_POWER channel_freq_power_UN_AJ[] = {
+    {8, 5040, TX_PWR_DEFAULT},
+    {12, 5060, TX_PWR_DEFAULT},
+    {16, 5080, TX_PWR_DEFAULT},
+    {34, 5170, TX_PWR_DEFAULT},
+    {38, 5190, TX_PWR_DEFAULT},
+    {42, 5210, TX_PWR_DEFAULT},
+    {46, 5230, TX_PWR_DEFAULT},
+    {36, 5180, TX_PWR_DEFAULT},
+    {40, 5200, TX_PWR_DEFAULT},
+    {44, 5220, TX_PWR_DEFAULT},
+    {48, 5240, TX_PWR_DEFAULT},
+    {52, 5260, TX_PWR_DEFAULT},
+    {56, 5280, TX_PWR_DEFAULT},
+    {60, 5300, TX_PWR_DEFAULT},
+    {64, 5320, TX_PWR_DEFAULT},
+    {100, 5500, TX_PWR_DEFAULT},
+    {104, 5520, TX_PWR_DEFAULT},
+    {108, 5540, TX_PWR_DEFAULT},
+    {112, 5560, TX_PWR_DEFAULT},
+    {116, 5580, TX_PWR_DEFAULT},
+    {120, 5600, TX_PWR_DEFAULT},
+    {124, 5620, TX_PWR_DEFAULT},
+    {128, 5640, TX_PWR_DEFAULT},
+    {132, 5660, TX_PWR_DEFAULT},
+    {136, 5680, TX_PWR_DEFAULT},
+    {140, 5700, TX_PWR_DEFAULT},
+    {149, 5745, TX_PWR_DEFAULT},
+    {153, 5765, TX_PWR_DEFAULT},
+    {157, 5785, TX_PWR_DEFAULT},
+    {161, 5805, TX_PWR_DEFAULT},
+    {165, 5825, TX_PWR_DEFAULT},
+/*	{240, 4920, TX_PWR_DEFAULT}, 
+	{244, 4940, TX_PWR_DEFAULT}, 
+	{248, 4960, TX_PWR_DEFAULT}, 
+	{252, 4980, TX_PWR_DEFAULT}, 
+channels for 11J JP 10M channel gap */
+};
+
+extern CHANNEL_FREQ_POWER *wlan_get_region_cfp_table(u8 region,
+                                                     u8 band, int *cfp_no);
+
+/********************************************************
+		Local Functions
+********************************************************/
+/** 
+ *  @brief This function convert Region string to code integer
+ *  @param region     region string
+ *  @return 	      region id
+*/
+static u8
+wlan_region_2_code(s8 * region)
+{
+    u8 i;
+    u8 size = sizeof(region_code_mapping) / sizeof(region_code_mapping_t);
+
+    for (i = 0; i < COUNTRY_CODE_LEN && region[i]; i++)
+        region[i] = toupper(region[i]);
+
+    for (i = 0; i < size; i++) {
+        if (!memcmp(region, region_code_mapping[i].region, COUNTRY_CODE_LEN))
+            return (region_code_mapping[i].code);
+    }
+
+    /* default is US */
+    return (region_code_mapping[0].code);
+}
+
+/** 
+ *  @brief This function converts interger code to region string
+ *  @param code       region code
+ *  @return 	      region string
+*/
+static u8 *
+wlan_code_2_region(u8 code)
+{
+    u8 i;
+    u8 size = sizeof(region_code_mapping) / sizeof(region_code_mapping_t);
+    for (i = 0; i < size; i++) {
+        if (region_code_mapping[i].code == code)
+            return (region_code_mapping[i].region);
+    }
+    /* default is US */
+    return (region_code_mapping[0].region);
+}
+
+/** 
+ *  @brief This function finds the NoOfChan-th chan after the firstChan
+ *  @param band       band
+ *  @param firstChan  first channel number
+ *  @param NoOfChan   number of channels
+ *  @return 	      the NoOfChan-th chan number
+*/
+static BOOLEAN
+wlan_get_chan_11d(u8 band, u8 firstChan, u8 NoOfChan, u8 * chan)
+/*find the NoOfChan-th chan after the firstChan*/
+{
+    u8 i;
+    CHANNEL_FREQ_POWER *cfp;
+    u8 cfp_no;
+
+    ENTER();
+
+    {
+        cfp = channel_freq_power_UN_BG;
+        cfp_no = sizeof(channel_freq_power_UN_BG) /
+            sizeof(CHANNEL_FREQ_POWER);
+    }
+
+    for (i = 0; i < cfp_no; i++) {
+        if ((cfp + i)->Channel == firstChan) {
+            PRINTM(INFO, "firstChan found\n");
+            break;
+        }
+    }
+
+    if (i < cfp_no) {
+        /*if beyond the boundary */
+        if (i + NoOfChan < cfp_no) {
+            *chan = (cfp + i + NoOfChan)->Channel;
+            return TRUE;
+        }
+    }
+
+    LEAVE();
+    return FALSE;
+}
+
+/** 
+ *  @brief This function Checks if chan txpwr is learned from AP/IBSS
+ *  @param chan                 chan number
+ *  @param parsed_region_chan   pointer to parsed_region_chan_11d_t     
+ *  @return 	                TRUE; FALSE
+*/
+BOOLEAN
+wlan_channel_known_11d(u8 chan, parsed_region_chan_11d_t * parsed_region_chan)
+{
+    chan_power_11d_t *chanPwr = parsed_region_chan->chanPwr;
+    u8 NoOfChan = parsed_region_chan->NoOfChan;
+    u8 i = 0;
+
+    ENTER();
+    HEXDUMP("11D:parsed_region_chan:", (char *) chanPwr,
+            sizeof(chan_power_11d_t) * NoOfChan);
+
+    for (i = 0; i < NoOfChan; i++) {
+        if (chan == chanPwr[i].chan) {
+            PRINTM(INFO, "11D: Found Chan:%d\n", chan);
+            LEAVE();
+            return TRUE;
+        }
+    }
+
+    PRINTM(INFO, "11D: Not Find Chan:%d\n", chan);
+    LEAVE();
+    return FALSE;
+}
+
+/********************************************************
+		Global Functions
+********************************************************/
+
+/** 
+ *  @brief This function Converts chan to frequency
+ *  @param chan                 channel number
+ *  @param band                 band
+ *  @return 	                channel frequency
+*/
+u32
+chan_2_freq(u8 chan, u8 band)
+{
+    CHANNEL_FREQ_POWER *cf;
+    u16 cnt;
+    u16 i;
+    u32 freq = 0;
+
+    ENTER();
+
+    {
+        cf = channel_freq_power_UN_BG;
+        cnt = sizeof(channel_freq_power_UN_BG) / sizeof(CHANNEL_FREQ_POWER);
+    }
+
+    for (i = 0; i < cnt; i++) {
+        if (chan == cf[i].Channel)
+            freq = cf[i].Freq;
+    }
+
+    LEAVE();
+    return freq;
+}
+
+/** 
+ *  @brief This function generates domaininfo from parsed_region_chan
+ *  @param parsed_region_chan   pointer to parsed_region_chan_11d_t
+ *  @param domaininfo           pointer to wlan_802_11d_domain_reg_t
+ *  @return 	                WLAN_STATUS_SUCCESS
+*/
+int
+wlan_generate_domain_info_11d(parsed_region_chan_11d_t * parsed_region_chan,
+                              wlan_802_11d_domain_reg_t * domaininfo)
+{
+    u8 NoOfSubband = 0;
+
+    u8 NoOfChan = parsed_region_chan->NoOfChan;
+    u8 NoOfParsedChan = 0;
+
+    u8 firstChan = 0, nextChan = 0, maxPwr = 0;
+
+    u8 i, flag = 0;
+
+    ENTER();
+
+    memcpy(domaininfo->CountryCode, parsed_region_chan->CountryCode,
+           COUNTRY_CODE_LEN);
+
+    PRINTM(INFO, "11D:NoOfChan=%d\n", NoOfChan);
+    HEXDUMP("11D:parsed_region_chan:", (char *) parsed_region_chan,
+            sizeof(parsed_region_chan_11d_t));
+
+    for (i = 0; i < NoOfChan; i++) {
+        if (!flag) {
+            flag = 1;
+            nextChan = firstChan = parsed_region_chan->chanPwr[i].chan;
+            maxPwr = parsed_region_chan->chanPwr[i].pwr;
+            NoOfParsedChan = 1;
+            continue;
+        }
+
+        if (parsed_region_chan->chanPwr[i].chan == nextChan + 1 &&
+            parsed_region_chan->chanPwr[i].pwr == maxPwr) {
+            nextChan++;
+            NoOfParsedChan++;
+        } else {
+            domaininfo->Subband[NoOfSubband].FirstChan = firstChan;
+            domaininfo->Subband[NoOfSubband].NoOfChan = NoOfParsedChan;
+            domaininfo->Subband[NoOfSubband].MaxTxPwr = maxPwr;
+            NoOfSubband++;
+            NoOfParsedChan = 1;
+            nextChan = firstChan = parsed_region_chan->chanPwr[i].chan;
+            maxPwr = parsed_region_chan->chanPwr[i].pwr;
+        }
+    }
+
+    if (flag) {
+        domaininfo->Subband[NoOfSubband].FirstChan = firstChan;
+        domaininfo->Subband[NoOfSubband].NoOfChan = NoOfParsedChan;
+        domaininfo->Subband[NoOfSubband].MaxTxPwr = maxPwr;
+        NoOfSubband++;
+    }
+    domaininfo->NoOfSubband = NoOfSubband;
+
+    PRINTM(INFO, "NoOfSubband=%x\n", domaininfo->NoOfSubband);
+    HEXDUMP("11D:domaininfo:", (char *) domaininfo,
+            COUNTRY_CODE_LEN + 1 +
+            sizeof(IEEEtypes_SubbandSet_t) * NoOfSubband);
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function generates parsed_region_chan from Domain Info learned from AP/IBSS
+ *  @param region_chan          pointer to REGION_CHANNEL
+ *  @param *parsed_region_chan  pointer to parsed_region_chan_11d_t
+ *  @return 	                N/A
+*/
+void
+wlan_generate_parsed_region_chan_11d(REGION_CHANNEL * region_chan,
+                                     parsed_region_chan_11d_t *
+                                     parsed_region_chan)
+{
+    u8 i;
+    CHANNEL_FREQ_POWER *cfp;
+
+    ENTER();
+
+    if (region_chan == NULL) {
+        PRINTM(INFO, "11D: region_chan is NULL\n");
+        return;
+    }
+
+    cfp = region_chan->CFP;
+    if (cfp == NULL) {
+        PRINTM(INFO, "11D: cfp equal NULL \n");
+        return;
+    }
+
+    parsed_region_chan->band = region_chan->Band;
+    parsed_region_chan->region = region_chan->Region;
+    memcpy(parsed_region_chan->CountryCode,
+           wlan_code_2_region(region_chan->Region), COUNTRY_CODE_LEN);
+
+    PRINTM(INFO, "11D: region[0x%x] band[%d]\n", parsed_region_chan->region,
+           parsed_region_chan->band);
+
+    for (i = 0; i < region_chan->NrCFP; i++, cfp++) {
+        parsed_region_chan->chanPwr[i].chan = cfp->Channel;
+        parsed_region_chan->chanPwr[i].pwr = cfp->MaxTxPower;
+        PRINTM(INFO, "11D: Chan[%d] Pwr[%d]\n",
+               parsed_region_chan->chanPwr[i].chan,
+               parsed_region_chan->chanPwr[i].pwr);
+    }
+    parsed_region_chan->NoOfChan = region_chan->NrCFP;
+
+    PRINTM(INFO, "11D: NoOfChan[%d]\n", parsed_region_chan->NoOfChan);
+
+    LEAVE();
+    return;
+}
+
+/** 
+ *  @brief generate parsed_region_chan from Domain Info learned from AP/IBSS
+ *  @param region               region ID
+ *  @param band                 band
+ *  @param chan                 chan
+ *  @return 	                TRUE;FALSE
+*/
+BOOLEAN
+wlan_region_chan_supported_11d(u8 region, u8 band, u8 chan)
+{
+    CHANNEL_FREQ_POWER *cfp;
+    int cfp_no;
+    u8 idx;
+
+    ENTER();
+
+    if ((cfp = wlan_get_region_cfp_table(region, band, &cfp_no)) == NULL) {
+        return FALSE;
+    }
+
+    for (idx = 0; idx < cfp_no; idx++) {
+        if (chan == (cfp + idx)->Channel) {
+            /* If Mrvl Chip Supported? */
+            if ((cfp + idx)->Unsupported) {
+                return FALSE;
+            } else {
+                return TRUE;
+            }
+        }
+    }
+
+    /*chan is not in the region table */
+    LEAVE();
+    return FALSE;
+}
+
+/** 
+ *  @brief This function checks if chan txpwr is learned from AP/IBSS
+ *  @param chan                 chan number
+ *  @param parsed_region_chan   pointer to parsed_region_chan_11d_t     
+ *  @return 	                WLAN_STATUS_SUCCESS       
+*/
+int
+wlan_parse_domain_info_11d(IEEEtypes_CountryInfoFullSet_t * CountryInfo,
+                           u8 band,
+                           parsed_region_chan_11d_t * parsed_region_chan)
+{
+    u8 NoOfSubband, NoOfChan;
+    u8 lastChan, firstChan, curChan;
+    u8 region;
+
+    u8 idx = 0;                 /*chan index in parsed_region_chan */
+
+    u8 j, i;
+
+    ENTER();
+
+    /*Validation Rules:
+       1. Valid Region Code
+       2. First Chan increment
+       3. Channel range no overlap
+       4. Channel is valid?
+       5. Channel is supported by Region?
+       6. Others
+     */
+
+    HEXDUMP("CountryInfo:", (s8 *) CountryInfo, 30);
+
+    if ((*(CountryInfo->CountryCode)) == 0 ||
+        (CountryInfo->Len <= COUNTRY_CODE_LEN)) {
+        /* No region Info or Wrong region info: treat as No 11D info */
+        LEAVE();
+        return WLAN_STATUS_FAILURE;
+    }
+
+    /*Step1: check region_code */
+    parsed_region_chan->region = region =
+        wlan_region_2_code((s8 *) CountryInfo->CountryCode);
+
+    PRINTM(INFO, "regioncode=%x\n", (u8) parsed_region_chan->region);
+    HEXDUMP("CountryCode:", (char *) CountryInfo->CountryCode,
+            COUNTRY_CODE_LEN);
+
+    parsed_region_chan->band = band;
+
+    memcpy(parsed_region_chan->CountryCode, CountryInfo->CountryCode,
+           COUNTRY_CODE_LEN);
+
+    NoOfSubband = (CountryInfo->Len - COUNTRY_CODE_LEN) /
+        sizeof(IEEEtypes_SubbandSet_t);
+
+    for (j = 0, lastChan = 0; j < NoOfSubband; j++) {
+
+        if (CountryInfo->Subband[j].FirstChan <= lastChan) {
+            /*Step2&3. Check First Chan Num increment and no overlap */
+            PRINTM(INFO, "11D: Chan[%d>%d] Overlap\n",
+                   CountryInfo->Subband[j].FirstChan, lastChan);
+            continue;
+        }
+
+        firstChan = CountryInfo->Subband[j].FirstChan;
+        NoOfChan = CountryInfo->Subband[j].NoOfChan;
+
+        for (i = 0; idx < MAX_NO_OF_CHAN && i < NoOfChan; i++) {
+            /*step4: channel is supported? */
+
+            if (wlan_get_chan_11d(band, firstChan, i, &curChan)
+                == FALSE) {
+                /* Chan is not found in UN table */
+                PRINTM(INFO, "chan is not supported: %d \n", i);
+                break;
+            }
+
+            lastChan = curChan;
+
+            /*step5: We don't need to Check if curChan is supported by mrvl in region */
+            parsed_region_chan->chanPwr[idx].chan = curChan;
+            parsed_region_chan->chanPwr[idx].pwr =
+                CountryInfo->Subband[j].MaxTxPwr;
+            idx++;
+        }
+
+        /*Step6: Add other checking if any */
+
+    }
+
+    parsed_region_chan->NoOfChan = idx;
+
+    PRINTM(INFO, "NoOfChan=%x\n", parsed_region_chan->NoOfChan);
+    HEXDUMP("11D:parsed_region_chan:", (s8 *) parsed_region_chan,
+            2 + COUNTRY_CODE_LEN + sizeof(parsed_region_chan_11d_t) * idx);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function calculates the scan type for channels
+ *  @param chan                 chan number
+ *  @param parsed_region_chan   pointer to parsed_region_chan_11d_t     
+ *  @return 	                PASSIVE if chan is unknown; ACTIVE if chan is known
+*/
+u8
+wlan_get_scan_type_11d(u8 chan, parsed_region_chan_11d_t * parsed_region_chan)
+{
+    u8 scan_type = HostCmd_SCAN_TYPE_PASSIVE;
+
+    ENTER();
+
+    if (wlan_channel_known_11d(chan, parsed_region_chan)) {
+        PRINTM(INFO, "11D: Found and do Active Scan\n");
+        scan_type = HostCmd_SCAN_TYPE_ACTIVE;
+    } else {
+        PRINTM(INFO, "11D: Not Find and do Passive Scan\n");
+    }
+
+    LEAVE();
+    return scan_type;
+
+}
+
+/** 
+ *  @brief This function gets if 11D is enabled
+ *  @param priv       pointer to wlan_private
+ *  @return 	      ENABLE_11D;DISABLE_11D
+*/
+state_11d_t
+wlan_get_state_11d(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    wlan_802_11d_state_t *state = &Adapter->State11D;
+    return (state->Enable11D);
+}
+
+/** 
+ *  @brief initialize internal variable for 11D
+ *  @param priv       pointer to wlan_private
+ *  @return 	      N/A
+*/
+void
+wlan_init_11d(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    wlan_802_11d_state_t *state = &Adapter->State11D;
+
+    state->Enable11D = DISABLE_11D;
+
+    memset(&(priv->adapter->parsed_region_chan), 0,
+           sizeof(parsed_region_chan_11d_t));
+
+    return;
+}
+
+/** 
+ *  @brief This function enable/disable 11D
+ *  @param priv       pointer to wlan_private
+ *  @param flag       enable/disable flag
+ *  @return 	      WLAN_STATUS_SUCCESS; WLAN_STATUS_FAILURE
+*/
+int
+wlan_enable_11d(wlan_private * priv, state_11d_t flag)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    wlan_802_11d_state_t *state = &Adapter->State11D;
+    int ret;
+    state_11d_t enable = flag;
+
+    ENTER();
+
+    state->Enable11D = flag;
+
+    /* send cmd to FW to enable/disable 11D fucntion in FW */
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_SNMP_MIB,
+                                HostCmd_ACT_SET,
+                                HostCmd_OPTION_WAITFORRSP,
+                                OID_802_11D_ENABLE, &enable);
+    if (ret) {
+        PRINTM(INFO, "11D: Fail to enable 11D \n");
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function sets DOMAIN INFO to FW
+ *  @param priv       pointer to wlan_private
+ *  @return 	      WLAN_STATUS_SUCCESS; WLAN_STATUS_FAILURE
+*/
+int
+wlan_set_domain_info_11d(wlan_private * priv)
+{
+    int ret;
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11D_DOMAIN_INFO,
+                                HostCmd_ACT_GEN_SET,
+                                HostCmd_OPTION_WAITFORRSP, 0, NULL);
+    if (ret) {
+        PRINTM(INFO, "11D: Fail to dnld domain Info\n");
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function setups scan channels
+ *  @param priv       pointer to wlan_private
+ *  @param band       band
+ *  @return 	      WLAN_STATUS_SUCCESS
+*/
+int
+wlan_set_universaltable(wlan_private * priv, u8 band)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    u16 size = sizeof(CHANNEL_FREQ_POWER);
+    u16 i = 0;
+
+    ENTER();
+
+    memset(Adapter->universal_channel, 0, sizeof(Adapter->universal_channel));
+
+    {
+        Adapter->universal_channel[i].NrCFP =
+            sizeof(channel_freq_power_UN_BG) / size;
+        PRINTM(INFO, "11D: BG-band NrCFP=%d\n",
+               Adapter->universal_channel[i].NrCFP);
+
+        Adapter->universal_channel[i].CFP = channel_freq_power_UN_BG;
+        Adapter->universal_channel[i].Valid = TRUE;
+        Adapter->universal_channel[i].Region = UNIVERSAL_REGION_CODE;
+        Adapter->universal_channel[i].Band = band;
+        i++;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function implements command CMD_802_11D_DOMAIN_INFO
+ *  @param priv       pointer to wlan_private
+ *  @param cmd        pointer to cmd buffer
+ *  @param cmdno      cmd ID
+ *  @param CmdOption  cmd action 
+ *  @return 	      WLAN_STATUS_SUCCESS
+*/
+int
+wlan_cmd_802_11d_domain_info(wlan_private * priv,
+                             HostCmd_DS_COMMAND * cmd, u16 cmdno,
+                             u16 CmdOption)
+{
+    HostCmd_DS_802_11D_DOMAIN_INFO *pDomainInfo = &cmd->params.domaininfo;
+    MrvlIEtypes_DomainParamSet_t *domain = &pDomainInfo->Domain;
+    wlan_adapter *Adapter = priv->adapter;
+    u8 NoOfSubband = Adapter->DomainReg.NoOfSubband;
+
+    ENTER();
+
+    PRINTM(INFO, "NoOfSubband=%x\n", NoOfSubband);
+
+    cmd->Command = wlan_cpu_to_le16(cmdno);
+    pDomainInfo->Action = wlan_cpu_to_le16(CmdOption);
+    if (CmdOption == HostCmd_ACT_GET) {
+        cmd->Size = wlan_cpu_to_le16(sizeof(pDomainInfo->Action) + S_DS_GEN);
+        HEXDUMP("11D: 802_11D_DOMAIN_INFO:", (u8 *) cmd, (int) (cmd->Size));
+        LEAVE();
+        return WLAN_STATUS_SUCCESS;
+    }
+
+    domain->Header.Type = wlan_cpu_to_le16(TLV_TYPE_DOMAIN);
+    memcpy(domain->CountryCode, Adapter->DomainReg.CountryCode,
+           sizeof(domain->CountryCode));
+
+    domain->Header.Len =
+        wlan_cpu_to_le16(NoOfSubband * sizeof(IEEEtypes_SubbandSet_t) +
+                         sizeof(domain->CountryCode));
+
+    if (NoOfSubband) {
+        memcpy(domain->Subband, Adapter->DomainReg.Subband,
+               NoOfSubband * sizeof(IEEEtypes_SubbandSet_t));
+
+        cmd->Size = wlan_cpu_to_le16(sizeof(pDomainInfo->Action) +
+                                     domain->Header.Len +
+                                     sizeof(MrvlIEtypesHeader_t) + S_DS_GEN);
+    } else {
+        cmd->Size = wlan_cpu_to_le16(sizeof(pDomainInfo->Action) + S_DS_GEN);
+    }
+
+    HEXDUMP("11D:802_11D_DOMAIN_INFO:", (u8 *) cmd, (int) (cmd->Size));
+
+    LEAVE();
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function implements private cmd: enable/disable 11D
+ *  @param priv    pointer to wlan_private
+ *  @param wrq     pointer to user data 
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_cmd_enable_11d(wlan_private * priv, struct iwreq *wrq)
+{
+    int data = 0;
+    int *val;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    data = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+
+    PRINTM(INFO, "Enable 11D: %s\n",
+           (data == CMD_ENABLED) ? "Enable" : "Disable");
+    switch (data) {
+    case CMD_ENABLED:
+        wlan_enable_11d(priv, ENABLE_11D);
+        break;
+    case CMD_DISABLED:
+        wlan_enable_11d(priv, DISABLE_11D);
+        break;
+    default:
+        break;
+    }
+
+    data =
+        (Adapter->State11D.Enable11D ==
+         ENABLE_11D) ? CMD_ENABLED : CMD_DISABLED;
+    val = (int *) wrq->u.name;
+    *val = data;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function parses countryinfo from AP and download country info to FW
+ *  @param priv    pointer to wlan_private
+ *  @param resp    pointer to command response buffer
+ *  @return 	   WLAN_STATUS_SUCCESS; WLAN_STATUS_FAILURE
+ */
+int
+wlan_ret_802_11d_domain_info(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11D_DOMAIN_INFO_RSP
+        * domaininfo = &resp->params.domaininforesp;
+    MrvlIEtypes_DomainParamSet_t * domain = &domaininfo->Domain;
+    u16 Action = wlan_le16_to_cpu(domaininfo->Action);
+    s16 ret = WLAN_STATUS_SUCCESS;
+    u8 NoOfSubband = 0;
+
+    ENTER();
+
+    HEXDUMP("11D DOMAIN Info Rsp Data:", (u8 *) resp, resp->Size);
+
+    NoOfSubband =
+        (wlan_le16_to_cpu(domain->Header.Len) -
+         3) / sizeof(IEEEtypes_SubbandSet_t);
+    /* countrycode 3 bytes */
+
+    PRINTM(INFO, "11D Domain Info Resp: NoOfSubband=%d\n", NoOfSubband);
+
+    if (NoOfSubband > MRVDRV_MAX_SUBBAND_802_11D) {
+        PRINTM(INFO, "Invalid Numrer of Subband returned!!\n");
+        return WLAN_STATUS_FAILURE;
+    }
+
+    switch (Action) {
+    case HostCmd_ACT_SET:      /*Proc Set Action */
+        break;
+
+    case HostCmd_ACT_GET:
+        break;
+    default:
+        PRINTM(INFO, "Invalid Action:%d\n", domaininfo->Action);
+        ret = WLAN_STATUS_FAILURE;
+        break;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function parses countryinfo from AP and download country info to FW
+ *  @param priv    pointer to wlan_private
+ *  @return 	   WLAN_STATUS_SUCCESS; WLAN_STATUS_FAILURE
+ */
+int
+wlan_parse_dnld_countryinfo_11d(wlan_private * priv)
+{
+    int ret;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        /* Skip new 11d download when roaming */
+        return WLAN_STATUS_SUCCESS;
+    }
+
+    if (wlan_get_state_11d(priv) == ENABLE_11D) {
+
+        memset(&Adapter->parsed_region_chan, 0,
+               sizeof(parsed_region_chan_11d_t));
+
+        ret =
+            wlan_parse_domain_info_11d(&Adapter->pAttemptedBSSDesc->
+                                       CountryInfo, 0,
+                                       &Adapter->parsed_region_chan);
+
+        if (ret == WLAN_STATUS_FAILURE) {
+            PRINTM(INFO, "11D: No region info in the AP BssDesc..\n");
+            LEAVE();
+            return WLAN_STATUS_SUCCESS;
+        }
+
+        memset(&Adapter->DomainReg, 0, sizeof(wlan_802_11d_domain_reg_t));
+        wlan_generate_domain_info_11d(&Adapter->parsed_region_chan,
+                                      &Adapter->DomainReg);
+
+        ret = wlan_set_domain_info_11d(priv);
+
+        if (ret) {
+            PRINTM(INFO, "11D: Err set domainInfo to FW\n");
+            LEAVE();
+            return ret;
+        }
+    }
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function generates 11D info from user specified regioncode and download to FW
+ *  @param priv    pointer to wlan_private
+ *  @return 	   WLAN_STATUS_SUCCESS; WLAN_STATUS_FAILURE
+ */
+int
+wlan_create_dnld_countryinfo_11d(wlan_private * priv, u8 band)
+{
+    int ret;
+    wlan_adapter *Adapter = priv->adapter;
+    REGION_CHANNEL *region_chan;
+    u8 j;
+
+    ENTER();
+    PRINTM(INFO, "11D:Band[%d]\n", band);
+
+    /* update parsed_region_chan_11; dnld domaininf to FW */
+
+    for (j = 0; j < sizeof(Adapter->region_channel) /
+         sizeof(Adapter->region_channel[0]); j++) {
+        region_chan = &Adapter->region_channel[j];
+
+        PRINTM(INFO, "11D:[%d] region_chan->Band[%d]\n", j,
+               region_chan->Band);
+
+        if (!region_chan || !region_chan->Valid || !region_chan->CFP)
+            continue;
+        if (region_chan->Band != band)
+            continue;
+        break;
+    }
+
+    if (j >= sizeof(Adapter->region_channel) /
+        sizeof(Adapter->region_channel[0])) {
+        PRINTM(INFO, "11D:region_chan not found. Band[%d]\n", band);
+        LEAVE();
+        return WLAN_STATUS_FAILURE;
+    }
+
+    memset(&Adapter->parsed_region_chan, 0, sizeof(parsed_region_chan_11d_t));
+    wlan_generate_parsed_region_chan_11d(region_chan,
+                                         &Adapter->parsed_region_chan);
+
+    memset(&Adapter->DomainReg, 0, sizeof(wlan_802_11d_domain_reg_t));
+    wlan_generate_domain_info_11d(&Adapter->parsed_region_chan,
+                                  &Adapter->DomainReg);
+
+    ret = wlan_set_domain_info_11d(priv);
+
+    if (ret) {
+        PRINTM(INFO, "11D: Err set domainInfo to FW\n");
+        LEAVE();
+        return ret;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
Index: linux-2.6.29/drivers/net/wireless/marvell8686/wlan_11d.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/wlan_11d.h	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,110 @@
+/** @file wlan_11d.h
+ *  @brief This header file contains data structures and 
+ *  function declarations of 802.11d   
+ *
+ *  Copyright  Marvell International Ltd. and/or its affiliates, 2003-2006
+ */
+/*************************************************************
+Change log:
+	09/26/05: add Doxygen format comments 
+ ************************************************************/
+
+#ifndef _WLAN_11D_
+#define _WLAN_11D_
+
+#define MAX_CHAN_NUM				255
+
+#define UNIVERSAL_REGION_CODE			0xff
+
+/** (Beaconsize(256)-5(IEId,len,contrystr(3))/3(FirstChan,NoOfChan,MaxPwr) 
+ */
+#define MAX_NO_OF_CHAN 				40
+
+typedef struct _REGION_CHANNEL *PREGION_CHANNEL;
+
+typedef enum
+{
+    DISABLE_11D = 0,
+    ENABLE_11D = 1,
+} state_11d_t;
+
+/** domain regulatory information */
+typedef struct _wlan_802_11d_domain_reg
+{
+        /** country Code*/
+    u8 CountryCode[COUNTRY_CODE_LEN];
+        /** No. of subband*/
+    u8 NoOfSubband;
+    IEEEtypes_SubbandSet_t Subband[MRVDRV_MAX_SUBBAND_802_11D];
+} wlan_802_11d_domain_reg_t;
+
+typedef struct _chan_power_11d
+{
+    u8 chan;
+    u8 pwr;
+} __ATTRIB_PACK__ chan_power_11d_t;
+
+typedef struct _parsed_region_chan_11d
+{
+    u8 band;
+    u8 region;
+    s8 CountryCode[COUNTRY_CODE_LEN];
+    chan_power_11d_t chanPwr[MAX_NO_OF_CHAN];
+    u8 NoOfChan;
+} __ATTRIB_PACK__ parsed_region_chan_11d_t;
+
+/** Data for state machine */
+typedef struct _wlan_802_11d_state
+{
+        /** True for Enabling  11D*/
+    BOOLEAN Enable11D;
+} wlan_802_11d_state_t;
+
+typedef struct _region_code_mapping
+{
+    s8 region[COUNTRY_CODE_LEN];
+    u8 code;
+} region_code_mapping_t;
+
+/* function prototypes*/
+int wlan_generate_domain_info_11d(parsed_region_chan_11d_t *
+                                  parsed_region_chan,
+                                  wlan_802_11d_domain_reg_t * domaininfo);
+
+int wlan_parse_domain_info_11d(IEEEtypes_CountryInfoFullSet_t * CountryInfo,
+                               u8 band,
+                               parsed_region_chan_11d_t * parsed_region_chan);
+
+u8 wlan_get_scan_type_11d(u8 chan,
+                          parsed_region_chan_11d_t * parsed_region_chan);
+
+u32 chan_2_freq(u8 chan, u8 band);
+
+int wlan_set_domain_info_11d(wlan_private * priv);
+
+state_11d_t wlan_get_state_11d(wlan_private * priv);
+
+void wlan_init_11d(wlan_private * priv);
+
+int wlan_enable_11d(wlan_private * priv, state_11d_t flag);
+
+int wlan_set_universaltable(wlan_private * priv, u8 band);
+
+void wlan_generate_parsed_region_chan_11d(PREGION_CHANNEL region_chan,
+                                          parsed_region_chan_11d_t *
+                                          parsed_region_chan);
+
+int wlan_cmd_802_11d_domain_info(wlan_private * priv,
+                                 HostCmd_DS_COMMAND * cmd, u16 cmdno,
+                                 u16 CmdOption);
+
+int wlan_cmd_enable_11d(wlan_private * priv, struct iwreq *wrq);
+
+int wlan_ret_802_11d_domain_info(wlan_private * priv,
+                                 HostCmd_DS_COMMAND * resp);
+
+int wlan_parse_dnld_countryinfo_11d(wlan_private * priv);
+
+int wlan_create_dnld_countryinfo_11d(wlan_private * priv, u8 band);
+
+#endif /* _WLAN_11D_ */
Index: linux-2.6.29/drivers/net/wireless/marvell8686/wlan_cmd.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/wlan_cmd.c	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,2501 @@
+/** @file wlan_cmd.c
+  *  
+  * @brief This file contains the handling of command.
+  * it prepares command and sends it to firmware when
+  * it is ready.
+  * 
+  *  Copyright  Marvell International Ltd. and/or its affiliates, 2003-2007
+  * 
+  */
+/********************************************************
+Change log:
+    10/04/05: Add Doxygen format comments
+    01/05/06: Add kernel 2.6.x support  
+    01/11/06: Conditionalize new scan/join structures
+    01/31/06: Add support to selectively enabe the FW Scan channel filter
+    02/16/06: Clear scan in progress flag when scan command failed and dropped
+    04/06/06: Add TSPEC, queue metrics, and MSDU expiry support
+    04/18/06: Remove old Subscrive Event and add new Subscribe Event
+              implementation through generic hostcmd API
+    05/04/06: Add IBSS coalescing related new hostcmd handling	      
+    08/29/06: Add ledgpio private command
+********************************************************/
+
+#include	"include.h"
+
+/********************************************************
+		Local Variables
+********************************************************/
+
+static u16 Commands_Allowed_In_PS[] = {
+    HostCmd_CMD_802_11_RSSI,
+    HostCmd_CMD_802_11_HOST_SLEEP_CFG,
+    HostCmd_CMD_802_11_WAKEUP_CONFIRM,
+};
+
+/********************************************************
+		Global Variables
+********************************************************/
+
+/********************************************************
+		Local Functions
+********************************************************/
+
+/** 
+ *  @brief This function checks if the commans is allowed
+ *  in PS mode not.
+ *  
+ *  @param Command the command ID
+ *  @return 	   TRUE or FALSE
+ */
+static BOOLEAN
+Is_Command_Allowed_In_PS(u16 Command)
+{
+    int count = sizeof(Commands_Allowed_In_PS)
+        / sizeof(Commands_Allowed_In_PS[0]);
+    int i;
+
+    for (i = 0; i < count; i++) {
+        if (Command == wlan_cpu_to_le16(Commands_Allowed_In_PS[i]))
+            return TRUE;
+    }
+
+    return FALSE;
+}
+
+/** 
+ *  @brief This function prepares command of get_hw_spec.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param cmd	   A pointer to HostCmd_DS_COMMAND structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_hw_spec(wlan_private * priv, HostCmd_DS_COMMAND * cmd)
+{
+    HostCmd_DS_GET_HW_SPEC *hwspec = &cmd->params.hwspec;
+
+    ENTER();
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_GET_HW_SPEC);
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_GET_HW_SPEC) + S_DS_GEN);
+    memcpy(hwspec->PermanentAddr, priv->adapter->CurrentAddr, ETH_ALEN);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of ps_mode.
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action 	the action: GET or SET
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_ps_mode(wlan_private * priv,
+                        HostCmd_DS_COMMAND * cmd, u16 cmd_action)
+{
+    HostCmd_DS_802_11_PS_MODE *psm = &cmd->params.psmode;
+    u16 Action = cmd_action;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_PS_MODE);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_PS_MODE) + S_DS_GEN);
+    psm->Action = wlan_cpu_to_le16(cmd_action);
+    psm->MultipleDtim = 0;
+    switch (Action) {
+    case HostCmd_SubCmd_Enter_PS:
+        PRINTM(INFO, "PS Command:" "SubCode- Enter PS\n");
+        PRINTM(INFO, "LocalListenInterval = %d\n",
+               Adapter->LocalListenInterval);
+
+        psm->LocalListenInterval =
+            wlan_cpu_to_le16(Adapter->LocalListenInterval);
+        psm->NullPktInterval = wlan_cpu_to_le16(Adapter->NullPktInterval);
+        psm->MultipleDtim = wlan_cpu_to_le16(priv->adapter->MultipleDtim);
+        psm->BCNMissTimeOut = wlan_cpu_to_le16(priv->adapter->BCNMissTimeOut);
+        if (priv->adapter->InfrastructureMode == Wlan802_11IBSS)
+            psm->AdhocAwakePeriod =
+                wlan_cpu_to_le16(priv->adapter->AdhocAwakePeriod);
+        break;
+
+    case HostCmd_SubCmd_Exit_PS:
+        PRINTM(INFO, "PS Command:" "SubCode- Exit PS\n");
+        break;
+
+    case HostCmd_SubCmd_Sleep_Confirmed:
+        PRINTM(INFO, "PS Command: SubCode- sleep confirm\n");
+        break;
+
+    default:
+        break;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of fw_wakeup_method.
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action 	the action: GET or SET
+ *  @param pdata_buf 	A pointer to data buffer
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_fw_wakeup_method(wlan_private * priv,
+                                 HostCmd_DS_COMMAND * cmd,
+                                 int cmd_action, void *pdata_buf)
+{
+    HostCmd_DS_802_11_FW_WAKEUP_METHOD *fwwm = &cmd->params.fwwakeupmethod;
+    u16 action = (u16) cmd_action;
+    u16 method = *((u16 *) pdata_buf);
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_FW_WAKE_METHOD);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_FW_WAKEUP_METHOD) +
+                         S_DS_GEN);
+    fwwm->Action = wlan_cpu_to_le16(action);
+    switch (action) {
+    case HostCmd_ACT_SET:
+        fwwm->Method = wlan_cpu_to_le16(method);
+        break;
+    case HostCmd_ACT_GET:
+    default:
+        fwwm->Method = 0;
+        break;
+    }
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function sends the HS_Activated event to the application
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_host_sleep_activated_event(wlan_private * priv)
+{
+    ENTER();
+
+    priv->adapter->HS_Activated = TRUE;
+    os_carrier_off(priv);
+    os_stop_queue(priv);
+    wmm_stop_queue(priv);
+
+#if WIRELESS_EXT > 14
+    send_iwevcustom_event(priv, CUS_EVT_HS_ACTIVATED);
+#endif /* WIRELESS_EXT */
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function sends the HS_DeActivated event to the application
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_host_sleep_deactivated_event(wlan_private * priv)
+{
+    ENTER();
+
+    priv->adapter->HS_Activated = FALSE;
+
+#if WIRELESS_EXT > 14
+    send_iwevcustom_event(priv, CUS_EVT_HS_DEACTIVATED);
+#endif /* WIRELESS_EXT */
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function sends the HS_GPIO_INT event to the application
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail 
+ */
+int
+wlan_host_sleep_gpio_int_event(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (Adapter->bHostSleepConfigured) {
+#if WIRELESS_EXT > 14
+        send_iwevcustom_event(priv, CUS_EVT_HS_GPIO_INT);
+#endif /* WIRELESS_EXT */
+    } else {
+        PRINTM(INFO, "hs_gpio_int: HS not configured !!!\n");
+    }
+
+    LEAVE();
+
+    return ret;
+}
+
+/** 
+ *  @brief This function prepares command of host_sleep_cfg.
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param pdata_buf 	A pointer to HostCmd_DS_802_11_HOST_SLEEP_CFG structure
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_host_sleep_cfg(wlan_private * priv,
+                               HostCmd_DS_COMMAND * cmd,
+                               HostCmd_DS_802_11_HOST_SLEEP_CFG * pdata_buf)
+{
+    HostCmd_DS_802_11_HOST_SLEEP_CFG *phwuc = &cmd->params.hostsleepcfg;
+
+    ENTER();
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_HOST_SLEEP_CFG);
+    if ((pdata_buf->conditions != HOST_SLEEP_CFG_CANCEL)
+        && ((priv->adapter->ArpFilterSize > 0)
+            && (priv->adapter->ArpFilterSize <= ARP_FILTER_MAX_BUF_SIZE))) {
+        PRINTM(INFO, "Attach %d bytes ArpFilter to HSCfg cmd\n",
+               priv->adapter->ArpFilterSize);
+        memcpy(((u8 *) phwuc) + sizeof(HostCmd_DS_802_11_HOST_SLEEP_CFG),
+               priv->adapter->ArpFilter, priv->adapter->ArpFilterSize);
+        cmd->Size =
+            wlan_cpu_to_le16(priv->adapter->ArpFilterSize +
+                             sizeof(HostCmd_DS_802_11_HOST_SLEEP_CFG) +
+                             S_DS_GEN);
+    } else
+        cmd->Size =
+            wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_HOST_SLEEP_CFG) +
+                             S_DS_GEN);
+    phwuc->conditions = wlan_cpu_to_le32(pdata_buf->conditions);
+    phwuc->gpio = pdata_buf->gpio;
+    phwuc->gap = pdata_buf->gap;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of inactivity_timeout.
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   Action: GET SET
+ *  @param pdata_buf 	A pointer to data buffer
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_inactivity_timeout(wlan_private * priv,
+                                   HostCmd_DS_COMMAND * cmd,
+                                   u16 cmd_action, void *pdata_buf)
+{
+    u16 *timeout = (u16 *) pdata_buf;
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_INACTIVITY_TIMEOUT);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_INACTIVITY_TIMEOUT) +
+                         S_DS_GEN);
+
+    cmd->params.inactivity_timeout.Action = wlan_cpu_to_le16(cmd_action);
+
+    if (cmd_action)
+        cmd->params.inactivity_timeout.Timeout = wlan_cpu_to_le16(*timeout);
+    else
+        cmd->params.inactivity_timeout.Timeout = 0;
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of sleep_period.
+ *  
+ *  @param priv    		A pointer to wlan_private structure
+ *  @param cmd	   		A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action 		the action: GET or SET
+ *  @param pdata_buf		A pointer to data buffer
+ *  @return 	   		WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_sleep_period(wlan_private * priv,
+                             HostCmd_DS_COMMAND * cmd,
+                             u16 cmd_action, void *pdata_buf)
+{
+    HostCmd_DS_802_11_SLEEP_PERIOD *pSleepPeriod = &cmd->params.ps_sleeppd;
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_SLEEP_PERIOD);
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_SLEEP_PERIOD) +
+                                 S_DS_GEN);
+    memmove(pSleepPeriod, pdata_buf, sizeof(HostCmd_DS_802_11_SLEEP_PERIOD));
+    pSleepPeriod->Action = wlan_cpu_to_le16(pSleepPeriod->Action);
+    pSleepPeriod->Period = wlan_cpu_to_le16(pSleepPeriod->Period);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of sleep_params.
+ *  
+ *  @param priv    		A pointer to wlan_private structure
+ *  @param cmd	   		A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action 		the action: GET or SET
+ *  @return 	   		WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_sleep_params(wlan_private * priv,
+                             HostCmd_DS_COMMAND * cmd, u16 cmd_action)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_SLEEP_PARAMS *sp = &cmd->params.sleep_params;
+
+    ENTER();
+
+    cmd->Size = wlan_cpu_to_le16((sizeof(HostCmd_DS_802_11_SLEEP_PARAMS)) +
+                                 S_DS_GEN);
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_SLEEP_PARAMS);
+
+    if (cmd_action == HostCmd_ACT_GEN_GET) {
+        memset(&Adapter->sp, 0, sizeof(SleepParams));
+        memset(sp, 0, sizeof(HostCmd_DS_802_11_SLEEP_PARAMS));
+        sp->Action = wlan_cpu_to_le16(cmd_action);
+    } else if (cmd_action == HostCmd_ACT_GEN_SET) {
+        sp->Action = wlan_cpu_to_le16(cmd_action);
+        sp->Error = wlan_cpu_to_le16(Adapter->sp.sp_error);
+        sp->Offset = wlan_cpu_to_le16(Adapter->sp.sp_offset);
+        sp->StableTime = wlan_cpu_to_le16(Adapter->sp.sp_stabletime);
+        sp->CalControl = (u8) Adapter->sp.sp_calcontrol;
+        sp->ExternalSleepClk = (u8) Adapter->sp.sp_extsleepclk;
+        sp->Reserved = wlan_cpu_to_le16(Adapter->sp.sp_reserved);
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+#define WEP_40_BIT_LEN	5
+#define WEP_104_BIT_LEN	13
+
+/** 
+ *  @brief This function prepares command of set_wep.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_oid   OID: ADD_WEP KEY or REMOVE_WEP KEY
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_set_wep(wlan_private * priv,
+                        HostCmd_DS_COMMAND * cmd, u32 cmd_oid)
+{
+    HostCmd_DS_802_11_SET_WEP *wep = &cmd->params.wep;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (cmd_oid == OID_802_11_ADD_WEP) {
+        cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_SET_WEP);
+        cmd->Size =
+            wlan_cpu_to_le16((sizeof(HostCmd_DS_802_11_SET_WEP)) + S_DS_GEN);
+        wep->Action = wlan_cpu_to_le16(HostCmd_ACT_ADD);
+
+        /* default tx key index */
+        wep->KeyIndex = wlan_cpu_to_le16(Adapter->CurrentWepKeyIndex &
+                                         HostCmd_WEP_KEY_INDEX_MASK);
+
+        PRINTM(INFO, "Tx Key Index: %u\n", wep->KeyIndex);
+
+        switch (Adapter->WepKey[0].KeyLength) {
+        case WEP_40_BIT_LEN:
+            wep->WEPTypeForKey1 = HostCmd_TYPE_WEP_40_BIT;
+            memmove(wep->WEP1, Adapter->WepKey[0].KeyMaterial,
+                    Adapter->WepKey[0].KeyLength);
+            break;
+        case WEP_104_BIT_LEN:
+            wep->WEPTypeForKey1 = HostCmd_TYPE_WEP_104_BIT;
+            memmove(wep->WEP1, Adapter->WepKey[0].KeyMaterial,
+                    Adapter->WepKey[0].KeyLength);
+            break;
+        case 0:
+            break;
+        default:
+            PRINTM(INFO, "Key1 Length = %d is incorrect\n",
+                   Adapter->WepKey[0].KeyLength);
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+
+        switch (Adapter->WepKey[1].KeyLength) {
+        case WEP_40_BIT_LEN:
+            wep->WEPTypeForKey2 = HostCmd_TYPE_WEP_40_BIT;
+            memmove(wep->WEP2, Adapter->WepKey[1].KeyMaterial,
+                    Adapter->WepKey[1].KeyLength);
+            break;
+        case WEP_104_BIT_LEN:
+            wep->WEPTypeForKey2 = HostCmd_TYPE_WEP_104_BIT;
+            memmove(wep->WEP2, Adapter->WepKey[1].KeyMaterial,
+                    Adapter->WepKey[1].KeyLength);
+            break;
+        case 0:
+            break;
+        default:
+            PRINTM(INFO, "Key2 Length = %d is incorrect\n",
+                   Adapter->WepKey[1].KeyLength);
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+
+        switch (Adapter->WepKey[2].KeyLength) {
+        case WEP_40_BIT_LEN:
+            wep->WEPTypeForKey3 = HostCmd_TYPE_WEP_40_BIT;
+            memmove(wep->WEP3, Adapter->WepKey[2].KeyMaterial,
+                    Adapter->WepKey[2].KeyLength);
+            break;
+        case WEP_104_BIT_LEN:
+            wep->WEPTypeForKey3 = HostCmd_TYPE_WEP_104_BIT;
+            memmove(wep->WEP3, Adapter->WepKey[2].KeyMaterial,
+                    Adapter->WepKey[2].KeyLength);
+            break;
+        case 0:
+            break;
+        default:
+            PRINTM(INFO, "Key3 Length = %d is incorrect\n",
+                   Adapter->WepKey[2].KeyLength);
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+
+        switch (Adapter->WepKey[3].KeyLength) {
+        case WEP_40_BIT_LEN:
+            wep->WEPTypeForKey4 = HostCmd_TYPE_WEP_40_BIT;
+            memmove(wep->WEP4, Adapter->WepKey[3].KeyMaterial,
+                    Adapter->WepKey[3].KeyLength);
+            break;
+        case WEP_104_BIT_LEN:
+            wep->WEPTypeForKey4 = HostCmd_TYPE_WEP_104_BIT;
+            memmove(wep->WEP4, Adapter->WepKey[3].KeyMaterial,
+                    Adapter->WepKey[3].KeyLength);
+            break;
+        case 0:
+            break;
+        default:
+            PRINTM(INFO, "Key4 Length = %d is incorrect\n",
+                   Adapter->WepKey[3].KeyLength);
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+    } else if (cmd_oid == OID_802_11_REMOVE_WEP) {
+        cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_SET_WEP);
+        cmd->Size =
+            wlan_cpu_to_le16((sizeof(HostCmd_DS_802_11_SET_WEP)) + S_DS_GEN);
+        wep->Action = wlan_cpu_to_le16(HostCmd_ACT_REMOVE);
+
+        /* default tx key index */
+        wep->KeyIndex = wlan_cpu_to_le16((u16) (Adapter->CurrentWepKeyIndex &
+                                                (u32)
+                                                HostCmd_WEP_KEY_INDEX_MASK));
+    }
+
+    ret = WLAN_STATUS_SUCCESS;
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function prepares command of key_material.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action 	the action: GET or SET
+ *  @param cmd_oid	OID: ENABLE or DISABLE
+ *  @param pdata_buf    A pointer to data buffer
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_key_material(wlan_private * priv,
+                             HostCmd_DS_COMMAND * cmd,
+                             u16 cmd_action,
+                             WLAN_OID cmd_oid, void *pdata_buf)
+{
+    HostCmd_DS_802_11_KEY_MATERIAL *pKeyMaterial = &cmd->params.keymaterial;
+    WLAN_802_11_KEY *pKey = (WLAN_802_11_KEY *) pdata_buf;
+    u16 KeyParamSet_len;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_KEY_MATERIAL);
+    pKeyMaterial->Action = wlan_cpu_to_le16(cmd_action);
+
+    if (cmd_action == HostCmd_ACT_GET) {
+        cmd->Size = wlan_cpu_to_le16(2 + S_DS_GEN);
+        ret = WLAN_STATUS_SUCCESS;
+        goto done;
+    }
+
+    memset(&pKeyMaterial->KeyParamSet, 0, sizeof(MrvlIEtype_KeyParamSet_t));
+
+    if (pKey->KeyLength == WPA_AES_KEY_LEN) {
+        PRINTM(INFO, "WPA_AES\n");
+        pKeyMaterial->KeyParamSet.KeyTypeId =
+            wlan_cpu_to_le16(KEY_TYPE_ID_AES);
+
+        if (cmd_oid == (WLAN_OID) KEY_INFO_ENABLED)
+            pKeyMaterial->KeyParamSet.KeyInfo =
+                wlan_cpu_to_le16(KEY_INFO_AES_ENABLED);
+        else
+            pKeyMaterial->KeyParamSet.KeyInfo =
+                !(wlan_cpu_to_le16(KEY_INFO_AES_ENABLED));
+
+        if (pKey->KeyIndex & 0x40000000)        //AES pairwise key: unicast
+            pKeyMaterial->KeyParamSet.KeyInfo |=
+                wlan_cpu_to_le16(KEY_INFO_AES_UNICAST);
+        else                    //AES group key: multicast
+            pKeyMaterial->KeyParamSet.KeyInfo |=
+                wlan_cpu_to_le16(KEY_INFO_AES_MCAST);
+    } else if (pKey->KeyLength == WPA_TKIP_KEY_LEN) {
+        PRINTM(INFO, "WPA_TKIP\n");
+        pKeyMaterial->KeyParamSet.KeyTypeId =
+            wlan_cpu_to_le16(KEY_TYPE_ID_TKIP);
+        pKeyMaterial->KeyParamSet.KeyInfo =
+            wlan_cpu_to_le16(KEY_INFO_TKIP_ENABLED);
+
+        if (pKey->KeyIndex & 0x40000000)        //TKIP pairwise key: unicast
+            pKeyMaterial->KeyParamSet.KeyInfo |=
+                wlan_cpu_to_le16(KEY_INFO_TKIP_UNICAST);
+        else                    //TKIP group key: multicast
+            pKeyMaterial->KeyParamSet.KeyInfo |=
+                wlan_cpu_to_le16(KEY_INFO_TKIP_MCAST);
+    }
+
+    if (pKeyMaterial->KeyParamSet.KeyTypeId) {
+        pKeyMaterial->KeyParamSet.Type =
+            wlan_cpu_to_le16(TLV_TYPE_KEY_MATERIAL);
+        pKeyMaterial->KeyParamSet.KeyLen = wlan_cpu_to_le16(pKey->KeyLength);
+        memcpy(pKeyMaterial->KeyParamSet.Key,
+               pKey->KeyMaterial, pKey->KeyLength);
+        pKeyMaterial->KeyParamSet.Length =
+            wlan_cpu_to_le16(pKey->KeyLength + 6);
+
+#define TYPE_LEN_FIELDS_LEN 4
+        KeyParamSet_len = (pKey->KeyLength + 6) + TYPE_LEN_FIELDS_LEN;
+#define ACTION_FIELD_LEN 2
+        cmd->Size =
+            wlan_cpu_to_le16(KeyParamSet_len + ACTION_FIELD_LEN + S_DS_GEN);
+    }
+
+    ret = WLAN_STATUS_SUCCESS;
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function prepares command of get_log.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_get_log(wlan_private * priv, HostCmd_DS_COMMAND * cmd)
+{
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_GET_LOG);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_GET_LOG) + S_DS_GEN);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of snmp_mib.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @param cmd_oid   	the OID of SNMP MIB
+ *  @param pdata_buf	the pointer to data buffer
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_snmp_mib(wlan_private * priv,
+                         HostCmd_DS_COMMAND * cmd,
+                         int cmd_action, int cmd_oid, void *pdata_buf)
+{
+    HostCmd_DS_802_11_SNMP_MIB *pSNMPMIB = &cmd->params.smib;
+    wlan_adapter *Adapter = priv->adapter;
+    u8 ucTemp;
+
+    ENTER();
+
+    PRINTM(INFO, "SNMP_CMD: cmd_oid = 0x%x\n", cmd_oid);
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_SNMP_MIB);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_SNMP_MIB) + S_DS_GEN);
+
+    switch (cmd_oid) {
+    case OID_802_11_INFRASTRUCTURE_MODE:
+        pSNMPMIB->QueryType = wlan_cpu_to_le16(HostCmd_ACT_GEN_SET);
+        pSNMPMIB->OID = wlan_cpu_to_le16((u16) DesiredBssType_i);
+        pSNMPMIB->BufSize = wlan_cpu_to_le16(sizeof(u8));
+        if (Adapter->InfrastructureMode == Wlan802_11Infrastructure)
+            ucTemp = SNMP_MIB_VALUE_INFRA;
+        else
+            ucTemp = SNMP_MIB_VALUE_ADHOC;
+
+        memmove(pSNMPMIB->Value, &ucTemp, sizeof(u8));
+
+        break;
+
+    case OID_802_11D_ENABLE:
+        {
+            u32 ulTemp;
+
+            pSNMPMIB->OID = wlan_cpu_to_le16((u16) Dot11D_i);
+
+            if (cmd_action == HostCmd_ACT_SET) {
+                pSNMPMIB->QueryType = wlan_cpu_to_le16(HostCmd_ACT_GEN_SET);
+                pSNMPMIB->BufSize = wlan_cpu_to_le16(sizeof(u16));
+                ulTemp = *(u32 *) pdata_buf;
+                *((PUSHORT) (pSNMPMIB->Value)) =
+                    wlan_cpu_to_le16((u16) ulTemp);
+            }
+            break;
+        }
+
+    case OID_802_11_FRAGMENTATION_THRESHOLD:
+        {
+            WLAN_802_11_FRAGMENTATION_THRESHOLD ulTemp;
+
+            pSNMPMIB->OID = wlan_cpu_to_le16((u16) FragThresh_i);
+
+            if (cmd_action == HostCmd_ACT_GET) {
+                pSNMPMIB->QueryType = wlan_cpu_to_le16(HostCmd_ACT_GEN_GET);
+            } else if (cmd_action == HostCmd_ACT_SET) {
+                pSNMPMIB->QueryType = wlan_cpu_to_le16(HostCmd_ACT_GEN_SET);
+                pSNMPMIB->BufSize = wlan_cpu_to_le16(sizeof(u16));
+                ulTemp = *((WLAN_802_11_FRAGMENTATION_THRESHOLD *)
+                           pdata_buf);
+                *((PUSHORT) (pSNMPMIB->Value)) =
+                    wlan_cpu_to_le16((u16) ulTemp);
+
+            }
+
+            break;
+        }
+
+    case OID_802_11_RTS_THRESHOLD:
+        {
+
+            WLAN_802_11_RTS_THRESHOLD ulTemp;
+            pSNMPMIB->OID = wlan_cpu_to_le16((u16) RtsThresh_i);
+
+            if (cmd_action == HostCmd_ACT_GET) {
+                pSNMPMIB->QueryType = wlan_cpu_to_le16(HostCmd_ACT_GEN_GET);
+            } else if (cmd_action == HostCmd_ACT_SET) {
+                pSNMPMIB->QueryType = wlan_cpu_to_le16(HostCmd_ACT_GEN_SET);
+                pSNMPMIB->BufSize = wlan_cpu_to_le16(sizeof(u16));
+                ulTemp = *((WLAN_802_11_RTS_THRESHOLD *)
+                           pdata_buf);
+                *(PUSHORT) (pSNMPMIB->Value) = wlan_cpu_to_le16((u16) ulTemp);
+            }
+            break;
+        }
+    case OID_802_11_TX_RETRYCOUNT:
+        pSNMPMIB->OID = wlan_cpu_to_le16((u16) ShortRetryLim_i);
+
+        if (cmd_action == HostCmd_ACT_GET) {
+            pSNMPMIB->QueryType = wlan_cpu_to_le16(HostCmd_ACT_GEN_GET);
+        } else if (cmd_action == HostCmd_ACT_SET) {
+            pSNMPMIB->QueryType = wlan_cpu_to_le16(HostCmd_ACT_GEN_SET);
+            pSNMPMIB->BufSize = wlan_cpu_to_le16(sizeof(u16));
+            *((PUSHORT) (pSNMPMIB->Value)) =
+                wlan_cpu_to_le16((u16) Adapter->TxRetryCount);
+        }
+        break;
+
+    case OID_802_11_DTIM:
+        pSNMPMIB->OID = wlan_cpu_to_le16((u16) DtimPeriod_i);
+
+        if (cmd_action == HostCmd_ACT_GET) {
+            pSNMPMIB->QueryType = wlan_cpu_to_le16(HostCmd_ACT_GEN_GET);
+        }
+        break;
+
+    default:
+        break;
+    }
+
+    PRINTM(INFO,
+           "SNMP_CMD: Command=0x%x, Size=0x%x, SeqNum=0x%x, Result=0x%x\n",
+           cmd->Command, cmd->Size, cmd->SeqNum, cmd->Result);
+
+    PRINTM(INFO,
+           "SNMP_CMD: Action=0x%x, OID=0x%x, OIDSize=0x%x, Value=0x%x\n",
+           pSNMPMIB->QueryType, pSNMPMIB->OID, pSNMPMIB->BufSize,
+           *(u16 *) pSNMPMIB->Value);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of radio_control.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_radio_control(wlan_private * priv,
+                              HostCmd_DS_COMMAND * cmd, int cmd_action)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_RADIO_CONTROL *pRadioControl = &cmd->params.radio;
+
+    ENTER();
+
+    cmd->Size = wlan_cpu_to_le16((sizeof(HostCmd_DS_802_11_RADIO_CONTROL))
+                                 + S_DS_GEN);
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_RADIO_CONTROL);
+
+    pRadioControl->Action = wlan_cpu_to_le16(cmd_action);
+    pRadioControl->Control = wlan_cpu_to_le16(Adapter->RadioOn);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of bca_timeshare.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @param user_bca_ts	A pointer to HostCmd_DS_802_11_BCA_TIMESHARE structure
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_bca_timeshare(wlan_private * priv,
+                              HostCmd_DS_COMMAND * cmd,
+                              u16 cmd_action,
+                              HostCmd_DS_802_11_BCA_TIMESHARE * user_bca_ts)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_BCA_TIMESHARE *bca_ts = &cmd->params.bca_timeshare;
+
+    ENTER();
+
+    cmd->Size = wlan_cpu_to_le16((sizeof(HostCmd_DS_802_11_BCA_TIMESHARE)) +
+                                 S_DS_GEN);
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_BCA_CONFIG_TIMESHARE);
+
+    if (cmd_action == HostCmd_ACT_GEN_GET) {
+        memset(&Adapter->bca_ts, 0, sizeof(bca_ts));
+        memset(bca_ts, 0, sizeof(HostCmd_DS_802_11_BCA_TIMESHARE));
+        bca_ts->Action = wlan_cpu_to_le16(cmd_action);
+        bca_ts->TrafficType = wlan_cpu_to_le16(user_bca_ts->TrafficType);
+    } else if (cmd_action == HostCmd_ACT_GEN_SET) {
+        bca_ts->Action = wlan_cpu_to_le16(cmd_action);
+        bca_ts->TrafficType = wlan_cpu_to_le16(user_bca_ts->TrafficType);
+        bca_ts->TimeShareInterval =
+            wlan_cpu_to_le32(user_bca_ts->TimeShareInterval);
+        bca_ts->BTTime = wlan_cpu_to_le32(user_bca_ts->BTTime);
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of rf_tx_power.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @param pdata_buf	A pointer to data buffer
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_rf_tx_power(wlan_private * priv,
+                            HostCmd_DS_COMMAND * cmd,
+                            u16 cmd_action, void *pdata_buf)
+{
+
+    HostCmd_DS_802_11_RF_TX_POWER *pRTP = &cmd->params.txp;
+
+    ENTER();
+
+    cmd->Size =
+        wlan_cpu_to_le16((sizeof(HostCmd_DS_802_11_RF_TX_POWER)) + S_DS_GEN);
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_RF_TX_POWER);
+    pRTP->Action = cmd_action;
+
+    PRINTM(INFO, "RF_TX_POWER_CMD: Size:%d Cmd:0x%x Act:%d\n", cmd->Size,
+           cmd->Command, pRTP->Action);
+
+    switch (cmd_action) {
+    case HostCmd_ACT_GEN_GET:
+        pRTP->Action = wlan_cpu_to_le16(HostCmd_ACT_GEN_GET);
+        pRTP->CurrentLevel = 0;
+        break;
+
+    case HostCmd_ACT_GEN_SET:
+        pRTP->Action = wlan_cpu_to_le16(HostCmd_ACT_GEN_SET);
+        pRTP->CurrentLevel = wlan_cpu_to_le16(*((u16 *) pdata_buf));
+        break;
+    }
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of rf_antenna.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @param pdata_buf	A pointer to data buffer
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_rf_antenna(wlan_private * priv,
+                           HostCmd_DS_COMMAND * cmd,
+                           u16 cmd_action, void *pdata_buf)
+{
+    HostCmd_DS_802_11_RF_ANTENNA *rant = &cmd->params.rant;
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_RF_ANTENNA);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_RF_ANTENNA) + S_DS_GEN);
+
+    rant->Action = wlan_cpu_to_le16(cmd_action);
+    if ((cmd_action == HostCmd_ACT_SET_RX) ||
+        (cmd_action == HostCmd_ACT_SET_TX)) {
+        rant->AntennaMode =
+            wlan_cpu_to_le16((u16) (*(WLAN_802_11_ANTENNA *) pdata_buf));
+    }
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of rate_adapt_rateset.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_rate_adapt_rateset(wlan_private * priv,
+                                   HostCmd_DS_COMMAND * cmd, u16 cmd_action)
+{
+    HostCmd_DS_802_11_RATE_ADAPT_RATESET * rateadapt = &cmd->params.rateset;
+    wlan_adapter *Adapter = priv->adapter;
+
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_RATE_ADAPT_RATESET) +
+                         S_DS_GEN);
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_RATE_ADAPT_RATESET);
+
+    ENTER();
+
+    rateadapt->Action = wlan_cpu_to_le16(cmd_action);
+    rateadapt->HWRateDropMode = wlan_cpu_to_le16(Adapter->HWRateDropMode);
+    rateadapt->Threshold = wlan_cpu_to_le16(Adapter->Threshold);
+    rateadapt->FinalRate = wlan_cpu_to_le16(Adapter->FinalRate);
+    rateadapt->Bitmap = wlan_cpu_to_le16(Adapter->RateBitmap);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of mac_multicast_adr.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_mac_multicast_adr(wlan_private * priv,
+                           HostCmd_DS_COMMAND * cmd, u16 cmd_action)
+{
+    HostCmd_DS_MAC_MULTICAST_ADR *pMCastAdr = &cmd->params.madr;
+    wlan_adapter *Adapter = priv->adapter;
+
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_MAC_MULTICAST_ADR) + S_DS_GEN);
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_MAC_MULTICAST_ADR);
+
+    pMCastAdr->Action = wlan_cpu_to_le16(cmd_action);
+    pMCastAdr->NumOfAdrs =
+        wlan_cpu_to_le16((u16) Adapter->NumOfMulticastMACAddr);
+    memcpy(pMCastAdr->MACList, Adapter->MulticastList,
+           Adapter->NumOfMulticastMACAddr * ETH_ALEN);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of rf_channel.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @param pdata_buf	A pointer to data buffer
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_rf_channel(wlan_private * priv,
+                           HostCmd_DS_COMMAND * cmd,
+                           int option, void *pdata_buf)
+{
+    HostCmd_DS_802_11_RF_CHANNEL *rfchan = &cmd->params.rfchannel;
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_RF_CHANNEL);
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_RF_CHANNEL)
+                                 + S_DS_GEN);
+
+    if (option == HostCmd_OPT_802_11_RF_CHANNEL_SET) {
+        rfchan->CurrentChannel = wlan_cpu_to_le16(*((u16 *) pdata_buf));
+    }
+
+    rfchan->Action = wlan_cpu_to_le16(option);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of rssi.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_rssi(wlan_private * priv, HostCmd_DS_COMMAND * cmd)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_RSSI);
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_RSSI) + S_DS_GEN);
+    cmd->params.rssi.N = wlan_cpu_to_le16(Adapter->bcn_avg_factor);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of reg_access.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @param pdata_buf	A pointer to data buffer
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_reg_access(wlan_private * priv,
+                    HostCmd_DS_COMMAND * CmdPtr,
+                    u8 cmd_action, void *pdata_buf)
+{
+    wlan_offset_value *offval;
+
+    ENTER();
+
+    offval = (wlan_offset_value *) pdata_buf;
+
+    switch (CmdPtr->Command) {
+    case HostCmd_CMD_MAC_REG_ACCESS:
+        {
+            HostCmd_DS_MAC_REG_ACCESS *macreg;
+
+            CmdPtr->Size =
+                wlan_cpu_to_le16(sizeof(HostCmd_DS_MAC_REG_ACCESS) +
+                                 S_DS_GEN);
+            macreg = (HostCmd_DS_MAC_REG_ACCESS *) & CmdPtr->params.macreg;
+
+            macreg->Action = wlan_cpu_to_le16(cmd_action);
+            macreg->Offset = wlan_cpu_to_le16((u16) offval->offset);
+            macreg->Value = wlan_cpu_to_le32(offval->value);
+
+            break;
+        }
+
+    case HostCmd_CMD_BBP_REG_ACCESS:
+        {
+            HostCmd_DS_BBP_REG_ACCESS *bbpreg;
+
+            CmdPtr->Size =
+                wlan_cpu_to_le16(sizeof(HostCmd_DS_BBP_REG_ACCESS) +
+                                 S_DS_GEN);
+            bbpreg = (HostCmd_DS_BBP_REG_ACCESS *) & CmdPtr->params.bbpreg;
+
+            bbpreg->Action = wlan_cpu_to_le16(cmd_action);
+            bbpreg->Offset = wlan_cpu_to_le16((u16) offval->offset);
+            bbpreg->Value = (u8) offval->value;
+
+            break;
+        }
+
+    case HostCmd_CMD_RF_REG_ACCESS:
+        {
+            HostCmd_DS_RF_REG_ACCESS *rfreg;
+
+            CmdPtr->Size =
+                wlan_cpu_to_le16(sizeof(HostCmd_DS_RF_REG_ACCESS) + S_DS_GEN);
+            rfreg = (HostCmd_DS_RF_REG_ACCESS *) & CmdPtr->params.rfreg;
+
+            rfreg->Action = wlan_cpu_to_le16(cmd_action);
+            rfreg->Offset = wlan_cpu_to_le16((u16) offval->offset);
+            rfreg->Value = (u8) offval->value;
+
+            break;
+        }
+
+    default:
+        break;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of mac_address.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_mac_address(wlan_private * priv,
+                            HostCmd_DS_COMMAND * cmd, u16 cmd_action)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_MAC_ADDRESS);
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_MAC_ADDRESS) +
+                                 S_DS_GEN);
+    cmd->Result = 0;
+
+    cmd->params.macadd.Action = wlan_cpu_to_le16(cmd_action);
+
+    if (cmd_action == HostCmd_ACT_SET) {
+        memcpy(cmd->params.macadd.MacAdd, Adapter->CurrentAddr, ETH_ALEN);
+        HEXDUMP("SET_CMD: MAC ADDRESS-", Adapter->CurrentAddr, 6);
+    }
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of cal_data_ext.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param pdata_buf	A pointer to data buffer
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_cal_data_ext(wlan_private * priv,
+                             HostCmd_DS_COMMAND * cmd, void *pdata_buf)
+{
+    HostCmd_DS_802_11_CAL_DATA_EXT *PCalDataext = pdata_buf;
+
+    HostCmd_DS_802_11_CAL_DATA_EXT *pCmdCalData =
+        (HostCmd_DS_802_11_CAL_DATA_EXT *) & cmd->params.caldataext;
+
+    ENTER();
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_CAL_DATA_EXT);
+
+    PRINTM(INFO, "CalDataLen = %d(d)\n", PCalDataext->CalDataLen);
+
+    if (PCalDataext->CalDataLen >
+        MAX_SETGET_CONF_CMD_LEN - CAL_DATA_HEADER_LEN) {
+        PRINTM(MSG, "CAL_DATA_EXT: Cal data lenght too large!\n");
+        return WLAN_STATUS_FAILURE;
+    }
+
+    memcpy(pCmdCalData, PCalDataext,
+           PCalDataext->CalDataLen + CAL_DATA_HEADER_LEN);
+
+    pCmdCalData->Action = wlan_cpu_to_le16(pCmdCalData->Action);
+    pCmdCalData->Revision = wlan_cpu_to_le16(pCmdCalData->Revision);
+    pCmdCalData->CalDataLen = wlan_cpu_to_le16(pCmdCalData->CalDataLen);
+
+    cmd->Size = wlan_cpu_to_le16(PCalDataext->CalDataLen +
+                                 CAL_DATA_HEADER_LEN + S_DS_GEN);
+
+    PRINTM(INFO, "CAL_DATA_EXT: cmd->Size = %d(d)\n", cmd->Size);
+
+    cmd->Result = 0;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of eeprom_access.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @param pdata_buf	A pointer to data buffer
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_eeprom_access(wlan_private * priv,
+                              HostCmd_DS_COMMAND * cmd,
+                              int cmd_action, void *pdata_buf)
+{
+    wlan_ioctl_regrdwr *ea = pdata_buf;
+
+    ENTER();
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_EEPROM_ACCESS);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_EEPROM_ACCESS) + S_DS_GEN);
+    cmd->Result = 0;
+
+    cmd->params.rdeeprom.Action = wlan_cpu_to_le16(ea->Action);
+    cmd->params.rdeeprom.Offset = wlan_cpu_to_le16(ea->Offset);
+    cmd->params.rdeeprom.ByteCount = wlan_cpu_to_le16(ea->NOB);
+    cmd->params.rdeeprom.Value = 0;
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+static int
+wlan_cmd_802_11_IBSS_Coalesced_Status(wlan_private * priv,
+                                      HostCmd_DS_COMMAND * cmd,
+                                      int cmd_action, void *pdata_buf)
+{
+    HostCmd_DS_802_11_IBSS_Status *pIBSSReq = &(cmd->params.ibssCoalescing);
+    u16 *enable = pdata_buf;
+
+    PRINTM(INFO, "HostCmd_CMD_802_11_BSSID_QUERY request");
+
+    cmd->Command =
+        wlan_cpu_to_le16(HostCmd_CMD_802_11_IBSS_COALESCING_STATUS);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_IBSS_Status) + S_DS_GEN);
+    cmd->Result = 0;
+    pIBSSReq->Action = wlan_cpu_to_le16(cmd_action);
+
+    switch (cmd_action) {
+    case HostCmd_ACT_SET:
+        pIBSSReq->Enable = wlan_cpu_to_le16(*enable);
+        break;
+
+        /* In other case.. Noting to do */
+    case HostCmd_ACT_GET:
+    default:
+        break;
+    }
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function queues the command to cmd list.
+ *  
+ *  @param Adapter	A pointer to wlan_adapter structure
+ *  @param CmdNode   	A pointer to CmdCtrlNode structure
+ *  @param addtail	specify if the cmd needs to be queued in the header or tail
+ *  @return 	   	n/a
+ */
+void
+QueueCmd(wlan_adapter * Adapter, CmdCtrlNode * CmdNode, BOOLEAN addtail)
+{
+    ulong flags;
+    HostCmd_DS_COMMAND *CmdPtr;
+    u16 command;
+
+    ENTER();
+
+    if (!CmdNode) {
+        PRINTM(WARN, "QUEUE_CMD: CmdNode is NULL\n");
+        goto done;
+    }
+
+    CmdPtr = (HostCmd_DS_COMMAND *) CmdNode->BufVirtualAddr;
+    if (!CmdPtr) {
+        PRINTM(WARN, "QUEUE_CMD: CmdPtr is NULL\n");
+        goto done;
+    }
+
+    command = wlan_le16_to_cpu(CmdPtr->Command);
+
+    /* Exit_PS command needs to be queued in the header always. */
+    if (command == HostCmd_CMD_802_11_PS_MODE) {
+        HostCmd_DS_802_11_PS_MODE *psm = &CmdPtr->params.psmode;
+        if (wlan_le16_to_cpu(psm->Action) == HostCmd_SubCmd_Exit_PS) {
+            if (Adapter->PSState != PS_STATE_FULL_POWER)
+                addtail = FALSE;
+        }
+    }
+
+    if ((command == HostCmd_CMD_802_11_WAKEUP_CONFIRM)
+        || (command == HostCmd_CMD_802_11_HOST_SLEEP_ACTIVATE)
+        || (command == HostCmd_CMD_802_11_HOST_SLEEP_CFG)
+        ) {
+        addtail = FALSE;
+    }
+
+    spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+
+    if (addtail)
+        list_add_tail((struct list_head *) CmdNode, &Adapter->CmdPendingQ);
+    else
+        list_add((struct list_head *) CmdNode, &Adapter->CmdPendingQ);
+
+    spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+
+    PRINTM(INFO, "QUEUE_CMD: cmd=0x%x is queued\n", command);
+
+  done:
+    LEAVE();
+    return;
+}
+
+#ifdef MFG_CMD_SUPPORT
+/** 
+ *  @brief This function sends general command to firmware.
+ *  
+ *  @param priv     	A pointer to wlan_private structure
+ *  @param cmd      	A pointer to HostCmd_DS_COMMAND structure
+ *  @param pdata_buf	A pointer to data buffer
+ *  @return         	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_mfg_cmd(wlan_private * priv,
+                 HostCmd_DS_COMMAND * cmd, void *pdata_buf)
+{
+    HostCmd_DS_GEN *pCmdPtr;
+
+    ENTER();
+
+    pCmdPtr = (HostCmd_DS_GEN *) pdata_buf;
+
+    /* copy the MFG command to command buffer */
+    memcpy((void *) cmd, pdata_buf, pCmdPtr->Size);
+
+    PRINTM(INFO, "MFG command size = %d\n", pCmdPtr->Size);
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_MFG_COMMAND);
+    cmd->Size = wlan_cpu_to_le16(cmd->Size);
+    cmd->Result = 0;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+#endif
+
+/** 
+ *  @brief This function downloads the command to firmware.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param CmdNode   	A pointer to CmdCtrlNode structure
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+DownloadCommandToStation(wlan_private * priv, CmdCtrlNode * CmdNode)
+{
+    ulong flags;
+    HostCmd_DS_COMMAND *CmdPtr;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    u16 CmdSize;
+    u16 Command;
+
+    OS_INTERRUPT_SAVE_AREA;
+
+    ENTER();
+
+    if (!Adapter || !CmdNode) {
+        PRINTM(ERROR, "DNLD_CMD: Adapter = %#x, CmdNode = %#x\n",
+               (int) Adapter, (int) CmdNode);
+        if (CmdNode)
+            CleanupAndInsertCmd(priv, CmdNode);
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    CmdPtr = (HostCmd_DS_COMMAND *) CmdNode->BufVirtualAddr;
+
+    if (!CmdPtr || !CmdPtr->Size) {
+        PRINTM(ERROR, "DNLD_CMD: CmdPtr is Null or Cmd Size is Zero, "
+               "Not sending\n");
+        CleanupAndInsertCmd(priv, CmdNode);
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    /* Set command sequence number */
+    Adapter->SeqNum++;
+    CmdPtr->SeqNum = wlan_cpu_to_le16(Adapter->SeqNum);
+
+    spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+    Adapter->CurCmd = CmdNode;
+    spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+
+    Command = wlan_le16_to_cpu(CmdPtr->Command);
+    CmdSize = wlan_le16_to_cpu(CmdPtr->Size);
+
+    CmdNode->CmdWaitQWoken = FALSE;
+
+    ret = sbi_host_to_card(priv, MVMS_CMD, (u8 *) CmdPtr, CmdSize);
+
+    /* clear TxDone interrupt bit */
+    OS_INT_DISABLE;
+    Adapter->HisRegCpy &= ~HIS_TxDnLdRdy;
+    OS_INT_RESTORE;
+
+    if (ret != 0) {
+        PRINTM(ERROR, "DNLD_CMD: Host to Card Failed\n");
+        /* set error code that will be transferred back to PrepareAndSendCommand() */
+        Adapter->CurCmdRetCode = WLAN_STATUS_FAILURE;
+        CleanupAndInsertCmd(priv, Adapter->CurCmd);
+        spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+        Adapter->CurCmd = NULL;
+        spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+        Adapter->dbg.num_cmd_host_to_card_failure++;
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    /* Save the last command id and action to debug log */
+    Adapter->dbg.LastCmdIndex = (Adapter->dbg.LastCmdIndex + 1) % DBG_CMD_NUM;
+    Adapter->dbg.LastCmdId[Adapter->dbg.LastCmdIndex] = Command;
+    Adapter->dbg.LastCmdAct[Adapter->dbg.LastCmdIndex] =
+        wlan_le16_to_cpu(*(u16 *) ((u8 *) CmdPtr + S_DS_GEN));
+
+    PRINTM(CMND, "DNLD_CMD: 0x%x, act 0x%x, len %d, seqno %d @ %lu\n",
+           Command, wlan_le16_to_cpu(*(u16 *) ((u8 *) CmdPtr + S_DS_GEN)),
+           CmdSize, wlan_le16_to_cpu(CmdPtr->SeqNum), os_time_get());
+    DBG_HEXDUMP(CMD_D, "DNLD_CMD", CmdNode->BufVirtualAddr, CmdSize);
+
+    /* Setup the timer after transmit command */
+    if (Command == HostCmd_CMD_802_11_SCAN
+        || Command == HostCmd_CMD_802_11_DEAUTHENTICATE
+        || Command == HostCmd_CMD_802_11_ASSOCIATE
+        || Command == HostCmd_CMD_WMM_ADDTS_REQ) {
+        ModTimer(&Adapter->MrvDrvCommandTimer, MRVDRV_TIMER_10S);
+    } else {
+        ModTimer(&Adapter->MrvDrvCommandTimer, MRVDRV_TIMER_5S);
+    }
+
+    Adapter->CommandTimerIsSet = TRUE;
+
+    if (Command == HostCmd_CMD_802_11_DEEP_SLEEP) {
+        if (Adapter->IntCounter || Adapter->CurrentTxSkb)
+            PRINTM(INFO, "DNLD_CMD: DS- IntCnt=%d CurTxSkb=%s\n",
+                   Adapter->IntCounter, (Adapter->CurrentTxSkb) ? "Y" : "N");
+
+        if (Adapter->IntCounter) {
+            OS_INT_DISABLE;
+            Adapter->IntCounterSaved = Adapter->IntCounter;
+            Adapter->IntCounter = 0;
+            OS_INT_RESTORE;
+        }
+        if (Adapter->CurrentTxSkb) {
+            kfree_skb(Adapter->CurrentTxSkb);
+            OS_INT_DISABLE;
+            Adapter->CurrentTxSkb = NULL;
+            OS_INT_RESTORE;
+            priv->stats.tx_dropped++;
+        }
+        /* 1. change the PS state to DEEP_SLEEP
+         * 2. since there is no response for this command, so 
+         *    delete the command timer and free the Node. */
+
+        Adapter->IsDeepSleep = TRUE;
+
+        CleanupAndInsertCmd(priv, CmdNode);
+        spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+        Adapter->CurCmd = NULL;
+        spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+
+        if (Adapter->CommandTimerIsSet) {
+            CancelTimer(&Adapter->MrvDrvCommandTimer);
+            Adapter->CommandTimerIsSet = FALSE;
+        }
+
+        if (!Adapter->IsAutoDeepSleepEnabled
+            || (Adapter->bHostSleepConfigured &&
+                (Adapter->HSCfg.gpio != HOST_SLEEP_CFG_WAKEUP_THRU_INTERFACE))
+            )
+            /* stop clock to save more power */
+            sbi_set_bus_clock(priv, FALSE);
+
+        if (Adapter->IsAutoDeepSleepEnabled) {
+            Adapter->bWakeupDevRequired = TRUE;
+            /* For auto deep sleep mode, after entering deep sleep state, 
+             * dnld_sent flag should be cleared so that the commands in 
+             * pending queue can be handled by main thread. */
+            priv->wlan_dev.dnld_sent = DNLD_RES_RECEIVED;
+        }
+
+        if (Adapter->bHostSleepConfigured) {
+            Adapter->bWakeupDevRequired = TRUE;
+            wlan_host_sleep_activated_event(priv);
+        }
+
+    }
+
+    ret = WLAN_STATUS_SUCCESS;
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function prepares command of mac_control.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd		A pointer to HostCmd_DS_COMMAND structure
+ *  @return 		WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_mac_control(wlan_private * priv,
+                     HostCmd_DS_COMMAND * cmd, void *InfoBuf)
+{
+    HostCmd_DS_MAC_CONTROL *mac = &cmd->params.macctrl;
+    u16 Action = *((u16 *) InfoBuf);
+
+    ENTER();
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_MAC_CONTROL);
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_MAC_CONTROL) + S_DS_GEN);
+    mac->Action = wlan_cpu_to_le16(Action);
+
+    PRINTM(INFO, "wlan_cmd_mac_control(): Action=0x%X Size=%d\n",
+           mac->Action, cmd->Size);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/********************************************************
+		Global Functions
+********************************************************/
+
+/** 
+ *  @brief This function inserts command node to CmdFreeQ
+ *  after cleans it.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param pTempCmd	A pointer to CmdCtrlNode structure
+ *  @return 		n/a
+ */
+void
+CleanupAndInsertCmd(wlan_private * priv, CmdCtrlNode * pTempCmd)
+{
+    ulong flags;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (!pTempCmd)
+        goto done;
+
+    spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+    CleanUpCmdCtrlNode(pTempCmd);
+    list_add_tail((struct list_head *) pTempCmd, &Adapter->CmdFreeQ);
+    spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+
+  done:
+    LEAVE();
+}
+
+/** 
+ *  @brief This function prepare the command before send to firmware.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd_no	command number
+ *  @param cmd_action	command action: GET or SET
+ *  @param wait_option	wait option: wait response or not
+ *  @param cmd_oid	cmd oid: treated as sub command
+ *  @param pdata_buf	A pointer to informaion buffer
+ *  @return 		WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+PrepareAndSendCommand(wlan_private * priv,
+                      u16 cmd_no,
+                      u16 cmd_action,
+                      u16 wait_option, WLAN_OID cmd_oid, void *pdata_buf)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+    CmdCtrlNode *CmdNode;
+    HostCmd_DS_COMMAND *CmdPtr;
+
+    ENTER();
+
+    if (!Adapter) {
+        PRINTM(ERROR, "PREP_CMD: Adapter is Null\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    if (Adapter->SurpriseRemoved) {
+        PRINTM(ERROR, "PREP_CMD: Card is Removed\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    CmdNode = GetFreeCmdCtrlNode(priv);
+
+    if (CmdNode == NULL) {
+        PRINTM(MSG, "PREP_CMD: No free CmdNode\n");
+
+        /* Wake up main thread to execute next command */
+        wake_up_interruptible(&priv->MainThread.waitQ);
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    SetCmdCtrlNode(priv, CmdNode, cmd_oid, wait_option, pdata_buf);
+
+    CmdPtr = (HostCmd_DS_COMMAND *) CmdNode->BufVirtualAddr;
+
+    if (!CmdPtr) {
+        PRINTM(MSG, "PREP_CMD: BufVirtualAddr of CmdNode is NULL\n");
+        CleanupAndInsertCmd(priv, CmdNode);
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    CmdPtr->Command = cmd_no;
+    CmdPtr->Result = 0;
+
+    TX_EVENT_FLAGS_SET(&CmdNode->cmdwait_q, 0, TX_AND);
+    switch (cmd_no) {
+    case HostCmd_CMD_GET_HW_SPEC:
+        ret = wlan_cmd_hw_spec(priv, CmdPtr);
+        break;
+    case HostCmd_CMD_802_11_PS_MODE:
+        ret = wlan_cmd_802_11_ps_mode(priv, CmdPtr, cmd_action);
+        break;
+
+    case HostCmd_CMD_802_11_SCAN:
+        ret = wlan_cmd_802_11_scan(priv, CmdPtr, pdata_buf);
+        break;
+
+    case HostCmd_CMD_MAC_CONTROL:
+        ret = wlan_cmd_mac_control(priv, CmdPtr, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_ASSOCIATE:
+        ret = wlan_cmd_802_11_associate(priv, CmdPtr, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_DEAUTHENTICATE:
+        ret = wlan_cmd_802_11_deauthenticate(priv, CmdPtr);
+        break;
+
+    case HostCmd_CMD_802_11_SET_WEP:
+        ret = wlan_cmd_802_11_set_wep(priv, CmdPtr, cmd_oid);
+        break;
+
+    case HostCmd_CMD_802_11_AD_HOC_START:
+        ret = wlan_cmd_802_11_ad_hoc_start(priv, CmdPtr, pdata_buf);
+        break;
+    case HostCmd_CMD_802_11_RESET:
+        CmdPtr->Command = wlan_cpu_to_le16(cmd_no);
+        CmdPtr->Size = wlan_cpu_to_le16(S_DS_GEN);
+        break;
+
+    case HostCmd_CMD_802_11_GET_LOG:
+        ret = wlan_cmd_802_11_get_log(priv, CmdPtr);
+        break;
+
+    case HostCmd_CMD_802_11_SNMP_MIB:
+        ret = wlan_cmd_802_11_snmp_mib(priv, CmdPtr,
+                                       cmd_action, cmd_oid, pdata_buf);
+        break;
+
+    case HostCmd_CMD_MAC_REG_ACCESS:
+    case HostCmd_CMD_BBP_REG_ACCESS:
+    case HostCmd_CMD_RF_REG_ACCESS:
+        ret = wlan_cmd_reg_access(priv, CmdPtr, cmd_action, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_RF_CHANNEL:
+        ret = wlan_cmd_802_11_rf_channel(priv, CmdPtr, cmd_action, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_RF_TX_POWER:
+        ret = wlan_cmd_802_11_rf_tx_power(priv, CmdPtr,
+                                          cmd_action, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_RADIO_CONTROL:
+        ret = wlan_cmd_802_11_radio_control(priv, CmdPtr, cmd_action);
+        break;
+
+    case HostCmd_CMD_802_11_RF_ANTENNA:
+        ret = wlan_cmd_802_11_rf_antenna(priv, CmdPtr, cmd_action, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_RATE_ADAPT_RATESET:
+        ret = wlan_cmd_802_11_rate_adapt_rateset(priv, CmdPtr, cmd_action);
+        break;
+
+    case HostCmd_CMD_MAC_MULTICAST_ADR:
+        ret = wlan_cmd_mac_multicast_adr(priv, CmdPtr, cmd_action);
+        break;
+
+    case HostCmd_CMD_802_11_AD_HOC_JOIN:
+        ret = wlan_cmd_802_11_ad_hoc_join(priv, CmdPtr, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_RSSI:
+        ret = wlan_cmd_802_11_rssi(priv, CmdPtr);
+        break;
+
+    case HostCmd_CMD_802_11_AD_HOC_STOP:
+        ret = wlan_cmd_802_11_ad_hoc_stop(priv, CmdPtr);
+        break;
+    case HostCmd_CMD_802_11_KEY_MATERIAL:
+        ret = wlan_cmd_802_11_key_material(priv, CmdPtr,
+                                           cmd_action, cmd_oid, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_MAC_ADDRESS:
+        ret = wlan_cmd_802_11_mac_address(priv, CmdPtr, cmd_action);
+        break;
+    case HostCmd_CMD_802_11_CAL_DATA_EXT:
+        ret = wlan_cmd_802_11_cal_data_ext(priv, CmdPtr, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_DEEP_SLEEP:
+        CmdPtr->Command = wlan_cpu_to_le16(cmd_no);
+        CmdPtr->Size = wlan_cpu_to_le16((u16)
+                                        (sizeof
+                                         (HostCmd_DS_802_11_DEEP_SLEEP)));
+        break;
+
+    case HostCmd_CMD_802_11_HOST_SLEEP_CFG:
+        ret = wlan_cmd_802_11_host_sleep_cfg(priv, CmdPtr, pdata_buf);
+        break;
+    case HostCmd_CMD_802_11_WAKEUP_CONFIRM:
+    case HostCmd_CMD_802_11_HOST_SLEEP_ACTIVATE:
+        CmdPtr->Command = wlan_cpu_to_le16(cmd_no);
+        CmdPtr->Size = wlan_cpu_to_le16(S_DS_GEN);
+        break;
+
+    case HostCmd_CMD_802_11_EEPROM_ACCESS:
+        ret = wlan_cmd_802_11_eeprom_access(priv, CmdPtr,
+                                            cmd_action, pdata_buf);
+        break;
+
+#ifdef MFG_CMD_SUPPORT
+    case HostCmd_CMD_MFG_COMMAND:
+        ret = wlan_cmd_mfg_cmd(priv, CmdPtr, pdata_buf);
+        break;
+#endif
+
+    case HostCmd_CMD_802_11D_DOMAIN_INFO:
+        ret = wlan_cmd_802_11d_domain_info(priv, CmdPtr, cmd_no, cmd_action);
+        break;
+
+    case HostCmd_CMD_802_11_SLEEP_PARAMS:
+        ret = wlan_cmd_802_11_sleep_params(priv, CmdPtr, cmd_action);
+        break;
+    case HostCmd_CMD_802_11_BCA_CONFIG_TIMESHARE:
+        ret = wlan_cmd_802_11_bca_timeshare(priv, CmdPtr,
+                                            cmd_action, pdata_buf);
+        break;
+    case HostCmd_CMD_802_11_INACTIVITY_TIMEOUT:
+        ret = wlan_cmd_802_11_inactivity_timeout(priv, CmdPtr,
+                                                 cmd_action, pdata_buf);
+        break;
+    case HostCmd_CMD_802_11_BG_SCAN_CONFIG:
+        ret = wlan_cmd_802_11_bg_scan_config(priv, CmdPtr,
+                                             cmd_action, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_BG_SCAN_QUERY:
+        ret = wlan_cmd_802_11_bg_scan_query(priv, CmdPtr);
+        break;
+
+    case HostCmd_CMD_802_11_FW_WAKE_METHOD:
+        ret = wlan_cmd_802_11_fw_wakeup_method(priv, CmdPtr,
+                                               cmd_action, pdata_buf);
+        break;
+
+    case HostCmd_CMD_WMM_GET_STATUS:
+        ret = wlan_cmd_wmm_get_status(priv, CmdPtr, pdata_buf);
+        break;
+
+    case HostCmd_CMD_WMM_ADDTS_REQ:
+        ret = wlan_cmd_wmm_addts_req(priv, CmdPtr, pdata_buf);
+        break;
+    case HostCmd_CMD_WMM_DELTS_REQ:
+        ret = wlan_cmd_wmm_delts_req(priv, CmdPtr, pdata_buf);
+        break;
+    case HostCmd_CMD_WMM_QUEUE_CONFIG:
+        ret = wlan_cmd_wmm_queue_config(priv, CmdPtr, pdata_buf);
+        break;
+    case HostCmd_CMD_WMM_QUEUE_STATS:
+        ret = wlan_cmd_wmm_queue_stats(priv, CmdPtr, pdata_buf);
+        break;
+    case HostCmd_CMD_TX_PKT_STATS:
+        CmdPtr->Command = wlan_cpu_to_le16(HostCmd_CMD_TX_PKT_STATS);
+        CmdPtr->Size = wlan_cpu_to_le16(S_DS_GEN);
+        ret = WLAN_STATUS_SUCCESS;
+        break;
+    case HostCmd_CMD_802_11_TPC_CFG:
+        CmdPtr->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_TPC_CFG);
+        CmdPtr->Size =
+            wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_TPC_CFG) + S_DS_GEN);
+
+        memmove(&CmdPtr->params.tpccfg,
+                pdata_buf, sizeof(HostCmd_DS_802_11_TPC_CFG));
+        CmdPtr->params.tpccfg.Action =
+            wlan_cpu_to_le16(CmdPtr->params.tpccfg.Action);
+
+        ret = WLAN_STATUS_SUCCESS;
+        break;
+    case HostCmd_CMD_802_11_LED_CONTROL:
+        {
+            HostCmd_DS_802_11_LED_CTRL *pLedCtrl = &CmdPtr->params.ledgpio;
+            MrvlIEtypes_LedGpio_t *gpio = &pLedCtrl->LedGpio;
+            MrvlIEtypes_LedBehavior_t *pLedBehavior = pLedCtrl->LedBehavior;
+
+            memmove(&CmdPtr->params.ledgpio,
+                    pdata_buf, sizeof(HostCmd_DS_802_11_LED_CTRL));
+
+            CmdPtr->Command =
+                wlan_cpu_to_le16(HostCmd_CMD_802_11_LED_CONTROL);
+
+#define ACTION_NUMLED_TLVTYPE_LEN_FIELDS_LEN 8
+            CmdPtr->Size = wlan_cpu_to_le16(gpio->Header.Len + S_DS_GEN
+                                            +
+                                            ACTION_NUMLED_TLVTYPE_LEN_FIELDS_LEN);
+
+            pLedCtrl->Action = wlan_cpu_to_le16(pLedCtrl->Action);
+            pLedCtrl->LedNums = wlan_cpu_to_le16(pLedCtrl->LedNums);
+
+            gpio->Header.Type = wlan_cpu_to_le16(gpio->Header.Type);
+            gpio->Header.Len = wlan_cpu_to_le16(gpio->Header.Len);
+
+            pLedBehavior->Header.Type =
+                wlan_cpu_to_le16(pLedBehavior->Header.Type);
+            pLedBehavior->Header.Len =
+                wlan_cpu_to_le16(pLedBehavior->Header.Len);
+
+            ret = WLAN_STATUS_SUCCESS;
+            break;
+        }
+    case HostCmd_CMD_802_11_SLEEP_PERIOD:
+        ret = wlan_cmd_802_11_sleep_period(priv, CmdPtr,
+                                           cmd_action, pdata_buf);
+        break;
+    case HostCmd_CMD_GET_TSF:
+        CmdPtr->Command = wlan_cpu_to_le16(HostCmd_CMD_GET_TSF);
+        CmdPtr->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_GET_TSF)
+                                        + S_DS_GEN);
+        ret = WLAN_STATUS_SUCCESS;
+        break;
+    case HostCmd_CMD_802_11_TX_RATE_QUERY:
+        CmdPtr->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_TX_RATE_QUERY);
+        CmdPtr->Size =
+            wlan_cpu_to_le16(sizeof(HostCmd_TX_RATE_QUERY) + S_DS_GEN);
+        Adapter->TxRate = 0;
+        ret = WLAN_STATUS_SUCCESS;
+        break;
+    case HostCmd_CMD_802_11_IBSS_COALESCING_STATUS:
+        ret =
+            wlan_cmd_802_11_IBSS_Coalesced_Status(priv, CmdPtr, cmd_action,
+                                                  pdata_buf);
+        break;
+
+    case HostCmd_CMD_SDIO_GPIO_INT_CONFIG:
+        {
+            HostCmd_DS_SDIO_INT_CONFIG *pSdioIntConf =
+                &CmdPtr->params.sdio_int;
+
+            CmdPtr->Command =
+                wlan_cpu_to_le16(HostCmd_CMD_SDIO_GPIO_INT_CONFIG);
+            CmdPtr->Size =
+                wlan_cpu_to_le16(sizeof(HostCmd_DS_SDIO_INT_CONFIG) +
+                                 S_DS_GEN);
+
+            memcpy(pSdioIntConf, pdata_buf,
+                   sizeof(HostCmd_DS_SDIO_INT_CONFIG));
+            pSdioIntConf->Action = wlan_cpu_to_le16(pSdioIntConf->Action);
+            pSdioIntConf->Gpio_pin = wlan_cpu_to_le16(pSdioIntConf->Gpio_pin);
+            pSdioIntConf->Gpio_int_edge =
+                wlan_cpu_to_le16(pSdioIntConf->Gpio_int_edge);
+            pSdioIntConf->Gpio_pulse_width =
+                wlan_cpu_to_le16(pSdioIntConf->Gpio_pulse_width);
+
+            ret = WLAN_STATUS_SUCCESS;
+            break;
+        }
+
+    case HostCmd_CMD_SDIO_PULL_CTRL:
+        {
+            HostCmd_DS_SDIO_PULL_CTRL *pSdiopullctl =
+                &CmdPtr->params.sdiopullctl;
+
+            CmdPtr->Command = wlan_cpu_to_le16(HostCmd_CMD_SDIO_PULL_CTRL);
+            CmdPtr->Size =
+                wlan_cpu_to_le16(sizeof(HostCmd_DS_SDIO_PULL_CTRL) +
+                                 S_DS_GEN);
+
+            memcpy(pSdiopullctl, pdata_buf,
+                   sizeof(HostCmd_DS_SDIO_PULL_CTRL));
+            pSdiopullctl->Action = wlan_cpu_to_le16(pSdiopullctl->Action);
+            pSdiopullctl->PullUp = wlan_cpu_to_le16(pSdiopullctl->PullUp);
+            pSdiopullctl->PullDown = wlan_cpu_to_le16(pSdiopullctl->PullDown);
+
+            ret = WLAN_STATUS_SUCCESS;
+            break;
+        }
+
+    case HostCmd_CMD_802_11_LDO_CONFIG:
+        CmdPtr->Command = wlan_cpu_to_le16(cmd_no);
+        CmdPtr->Size =
+            wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_LDO_CONFIG) + S_DS_GEN);
+        memcpy(&CmdPtr->params.ldocfg, pdata_buf,
+               sizeof(HostCmd_DS_802_11_LDO_CONFIG));
+        CmdPtr->params.ldocfg.Action =
+            wlan_cpu_to_le16(CmdPtr->params.ldocfg.Action);
+        CmdPtr->params.ldocfg.PMSource =
+            wlan_cpu_to_le16(CmdPtr->params.ldocfg.PMSource);
+        break;
+
+    case HostCmd_CMD_VERSION_EXT:
+        CmdPtr->Command = wlan_cpu_to_le16(cmd_no);
+        memcpy(&CmdPtr->params, pdata_buf, sizeof(HostCmd_DS_VERSION_EXT));
+        CmdPtr->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_VERSION_EXT)
+                                        + S_DS_GEN);
+        break;
+
+    default:
+        PRINTM(INFO, "PREP_CMD: unknown command- %#x\n", cmd_no);
+        ret = WLAN_STATUS_FAILURE;
+        break;
+    }
+
+    /* return error, since the command preparation failed */
+    if (ret != WLAN_STATUS_SUCCESS) {
+        PRINTM(ERROR, "PREP_CMD: Command 0x%x preparation failed\n", cmd_no);
+        CleanupAndInsertCmd(priv, CmdNode);
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    PRINTM(CMND, "PREP_CMD: 0x%x\n", cmd_no);
+
+    CmdNode->CmdWaitQWoken = FALSE;
+    QueueCmd(Adapter, CmdNode, TRUE);
+    wake_up_interruptible(&priv->MainThread.waitQ);
+
+    if (wait_option & HostCmd_OPTION_WAITFORRSP) {
+        PRINTM(INFO, "PREP_CMD: Wait for CMD response...\n");
+        wait_event_interruptible(CmdNode->cmdwait_q, CmdNode->CmdWaitQWoken);
+        if (Adapter->CurCmdRetCode) {
+            PRINTM(INFO, "PREP_CMD: Command failed with return code=%d\n",
+                   Adapter->CurCmdRetCode);
+            Adapter->CurCmdRetCode = 0;
+            ret = WLAN_STATUS_FAILURE;
+        }
+    }
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function allocates the command buffer and link
+ *  it to command free queue.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @return 		WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+AllocateCmdBuffer(wlan_private * priv)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    u32 ulBufSize;
+    u32 i;
+    CmdCtrlNode *TempCmdArray;
+    u8 *pTempVirtualAddr;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    /* Allocate and initialize CmdCtrlNode */
+    ulBufSize = sizeof(CmdCtrlNode) * MRVDRV_NUM_OF_CMD_BUFFER;
+
+    if (!(TempCmdArray = kmalloc(ulBufSize, GFP_KERNEL))) {
+        PRINTM(INFO, "ALLOC_CMD_BUF: Failed to allocate TempCmdArray\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    Adapter->CmdArray = TempCmdArray;
+    memset(Adapter->CmdArray, 0, ulBufSize);
+
+    /* Allocate and initialize command buffers */
+    ulBufSize = MRVDRV_SIZE_OF_CMD_BUFFER;
+    for (i = 0; i < MRVDRV_NUM_OF_CMD_BUFFER; i++) {
+        if (!(pTempVirtualAddr = kmalloc(ulBufSize, GFP_KERNEL))) {
+            PRINTM(INFO, "ALLOC_CMD_BUF: pTempVirtualAddr: out of memory\n");
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+
+        memset(pTempVirtualAddr, 0, ulBufSize);
+
+        /* Update command buffer virtual */
+        TempCmdArray[i].BufVirtualAddr = pTempVirtualAddr;
+    }
+
+    for (i = 0; i < MRVDRV_NUM_OF_CMD_BUFFER; i++) {
+        init_waitqueue_head(&TempCmdArray[i].cmdwait_q);
+        CleanupAndInsertCmd(priv, &TempCmdArray[i]);
+    }
+
+    ret = WLAN_STATUS_SUCCESS;
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function frees the command buffer.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @return 		WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+FreeCmdBuffer(wlan_private * priv)
+{
+    u32 ulBufSize;
+    UINT i;
+    CmdCtrlNode *TempCmdArray;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    /* need to check if cmd array is allocated or not */
+    if (Adapter->CmdArray == NULL) {
+        PRINTM(INFO, "FREE_CMD_BUF: CmdArray is Null\n");
+        goto done;
+    }
+
+    TempCmdArray = Adapter->CmdArray;
+
+    /* Release shared memory buffers */
+    ulBufSize = MRVDRV_SIZE_OF_CMD_BUFFER;
+    for (i = 0; i < MRVDRV_NUM_OF_CMD_BUFFER; i++) {
+        if (TempCmdArray[i].BufVirtualAddr) {
+            PRINTM(INFO, "Free all the array\n");
+            kfree(TempCmdArray[i].BufVirtualAddr);
+            TempCmdArray[i].BufVirtualAddr = NULL;
+        }
+    }
+
+    /* Release CmdCtrlNode */
+    if (Adapter->CmdArray) {
+        PRINTM(INFO, "Free CmdArray\n");
+        kfree(Adapter->CmdArray);
+        Adapter->CmdArray = NULL;
+    }
+
+  done:
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function gets a free command node if available in
+ *  command free queue.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @return CmdCtrlNode A pointer to CmdCtrlNode structure or NULL
+ */
+CmdCtrlNode *
+GetFreeCmdCtrlNode(wlan_private * priv)
+{
+    CmdCtrlNode *TempNode;
+    wlan_adapter *Adapter = priv->adapter;
+    ulong flags;
+
+    ENTER();
+
+    if (!Adapter)
+        return NULL;
+
+    spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+
+    if (!list_empty(&Adapter->CmdFreeQ)) {
+        TempNode = (CmdCtrlNode *) Adapter->CmdFreeQ.next;
+        list_del((struct list_head *) TempNode);
+    } else {
+        PRINTM(WARN, "GET_CMD_NODE: CmdCtrlNode is not available\n");
+        TempNode = NULL;
+    }
+
+    spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+
+    if (TempNode) {
+        CleanUpCmdCtrlNode(TempNode);
+    }
+
+    LEAVE();
+    return TempNode;
+}
+
+/** 
+ *  @brief This function cleans command node.
+ *  
+ *  @param pTempNode	A pointer to CmdCtrlNode structure
+ *  @return 		n/a
+ */
+void
+CleanUpCmdCtrlNode(CmdCtrlNode * pTempNode)
+{
+    ENTER();
+
+    if (!pTempNode)
+        return;
+    pTempNode->CmdWaitQWoken = TRUE;
+
+    if (pTempNode->wait_option & HostCmd_OPTION_WAITFORRSP) {
+        wake_up_interruptible(&pTempNode->cmdwait_q);
+    }
+    pTempNode->Status = 0;
+    pTempNode->cmd_oid = (WLAN_OID) 0;
+    pTempNode->wait_option = 0;
+    pTempNode->CmdFlags = 0;
+    pTempNode->pdata_buf = NULL;
+
+    if (pTempNode->BufVirtualAddr != NULL)
+        memset(pTempNode->BufVirtualAddr, 0, MRVDRV_SIZE_OF_CMD_BUFFER);
+
+    LEAVE();
+    return;
+}
+
+/** 
+ *  @brief This function initializes the command node.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param pTempNode	A pointer to CmdCtrlNode structure
+ *  @param cmd_oid	cmd oid: treated as sub command
+ *  @param wait_option	wait option: wait response or not
+ *  @param pdata_buf	A pointer to informaion buffer
+ *  @return 		WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+void
+SetCmdCtrlNode(wlan_private * priv,
+               CmdCtrlNode * pTempNode,
+               WLAN_OID cmd_oid, u16 wait_option, void *pdata_buf)
+{
+    ENTER();
+
+    if (!pTempNode)
+        return;
+
+    pTempNode->cmd_oid = cmd_oid;
+    pTempNode->wait_option = wait_option;
+    pTempNode->pdata_buf = pdata_buf;
+
+    LEAVE();
+}
+
+/** 
+ *  @brief This function executes next command in command
+ *  pending queue. It will put fimware back to PS mode
+ *  if applicable.
+ *  
+ *  @param priv     A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+ExecuteNextCommand(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    CmdCtrlNode *CmdNode = NULL;
+    HostCmd_DS_COMMAND *CmdPtr;
+    ulong flags;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (!Adapter) {
+        PRINTM(MSG, "EXEC_NEXT_CMD: Adapter is NULL\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+
+    if (Adapter->CurCmd) {
+        PRINTM(MSG, "EXEC_NEXT_CMD: there is command in processing!\n");
+        spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    if (!list_empty(&Adapter->CmdPendingQ)) {
+        CmdNode = (CmdCtrlNode *)
+            Adapter->CmdPendingQ.next;
+    }
+
+    spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+
+    if (CmdNode) {
+        CmdPtr = (HostCmd_DS_COMMAND *) CmdNode->BufVirtualAddr;
+
+        if (Is_Command_Allowed_In_PS(CmdPtr->Command)) {
+            if ((Adapter->PSState == PS_STATE_SLEEP)
+                || (Adapter->PSState == PS_STATE_PRE_SLEEP)
+                ) {
+                PRINTM(INFO,
+                       "EXEC_NEXT_CMD: Cannot send cmd 0x%x in PSState %d\n",
+                       CmdPtr->Command, Adapter->PSState);
+                ret = WLAN_STATUS_FAILURE;
+                goto done;
+            }
+            PRINTM(INFO, "EXEC_NEXT_CMD: OK to send command "
+                   "0x%x in PSState %d\n", CmdPtr->Command, Adapter->PSState);
+        } else if (Adapter->PSState != PS_STATE_FULL_POWER) {
+            /*
+             * 1. Non-PS command: 
+             * Queue it. set NeedToWakeup to TRUE if current state 
+             * is SLEEP, otherwise call PSWakeup to send Exit_PS.
+             * 2. PS command but not Exit_PS: 
+             * Ignore it.
+             * 3. PS command Exit_PS:
+             * Set NeedToWakeup to TRUE if current state is SLEEP, 
+             * otherwise send this command down to firmware
+             * immediately.
+             */
+            if (CmdPtr->Command !=
+                wlan_cpu_to_le16(HostCmd_CMD_802_11_PS_MODE)) {
+                /*  Prepare to send Exit PS,
+                 *  this non PS command will be sent later */
+                if ((Adapter->PSState == PS_STATE_SLEEP)
+                    || (Adapter->PSState == PS_STATE_PRE_SLEEP)
+                    ) {
+                    /* w/ new scheme, it will not reach here.
+                       since it is blocked in main_thread. */
+                    Adapter->NeedToWakeup = TRUE;
+                } else
+                    PSWakeup(priv, 0);
+
+                ret = WLAN_STATUS_SUCCESS;
+                goto done;
+            } else {
+                /*
+                 * PS command. Ignore it if it is not Exit_PS. 
+                 * otherwise send it down immediately.
+                 */
+                HostCmd_DS_802_11_PS_MODE *psm = &CmdPtr->params.psmode;
+
+                PRINTM(INFO, "EXEC_NEXT_CMD: PS cmd- Action=0x%x\n",
+                       psm->Action);
+                if (psm->Action != wlan_cpu_to_le16(HostCmd_SubCmd_Exit_PS)) {
+                    PRINTM(INFO, "EXEC_NEXT_CMD: Ignore Enter PS cmd\n");
+                    list_del((struct list_head *) CmdNode);
+                    CleanupAndInsertCmd(priv, CmdNode);
+
+                    ret = WLAN_STATUS_SUCCESS;
+                    goto done;
+                }
+
+                if ((Adapter->PSState == PS_STATE_SLEEP)
+                    || (Adapter->PSState == PS_STATE_PRE_SLEEP)
+                    ) {
+                    PRINTM(INFO,
+                           "EXEC_NEXT_CMD: Ignore ExitPS cmd in sleep\n");
+                    list_del((struct list_head *) CmdNode);
+                    CleanupAndInsertCmd(priv, CmdNode);
+                    Adapter->NeedToWakeup = TRUE;
+
+                    ret = WLAN_STATUS_SUCCESS;
+                    goto done;
+                }
+
+                PRINTM(INFO, "EXEC_NEXT_CMD: Sending Exit_PS down...\n");
+            }
+        }
+        list_del((struct list_head *) CmdNode);
+        DownloadCommandToStation(priv, CmdNode);
+    } else {
+        if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+            /*
+             * check if in power save mode, if yes, put the device back
+             * to PS mode
+             */
+            if ((Adapter->PSMode != Wlan802_11PowerModeCAM) &&
+                (Adapter->PSState == PS_STATE_FULL_POWER)) {
+                if (Adapter->SecInfo.WPAEnabled
+                    || Adapter->SecInfo.WPA2Enabled) {
+                    if (Adapter->IsGTK_SET) {
+                        PRINTM(INFO, "EXEC_NEXT_CMD: WPA enabled and GTK_SET"
+                               " go back to PS_SLEEP");
+                        PSSleep(priv, 0);
+                    }
+                } else {
+                    if ((Adapter->InfrastructureMode != Wlan802_11IBSS)
+                        || Adapter->CurBssParams.BSSDescriptor.ATIMWindow) {
+                        PRINTM(INFO, "EXEC_NEXT_CMD: Command PendQ is empty,"
+                               " go back to PS_SLEEP");
+                        PSSleep(priv, 0);
+                    }
+                }
+            }
+        } else {
+            /*
+             * check if in auto deep sleep mode, if yes, put the device back
+             * to DS mode
+             */
+            if (Adapter->IsAutoDeepSleepEnabled && !Adapter->IntCounter) {
+                PRINTM(INFO, "Entering Auto Deep Sleep mode...\n");
+                ret = PrepareAndSendCommand(priv,
+                                            HostCmd_CMD_802_11_DEEP_SLEEP, 0,
+                                            0, 0, NULL);
+            }
+        }
+        /* The hs_activate command is sent when Host Sleep is configured
+           and de-activated in full power mode. */
+        if (Adapter->bHostSleepConfigured && !Adapter->HS_Activated
+            && ((Adapter->MediaConnectStatus == WlanMediaStateConnected)
+                || (!Adapter->IsAutoDeepSleepEnabled))
+            && (((Adapter->PSMode == Wlan802_11PowerModeCAM)
+                 && (Adapter->PSState == PS_STATE_FULL_POWER))
+                || ((Adapter->InfrastructureMode == Wlan802_11IBSS)
+                    && !Adapter->CurBssParams.BSSDescriptor.ATIMWindow)
+            )) {
+            ret = PrepareAndSendCommand(priv,
+                                        HostCmd_CMD_802_11_HOST_SLEEP_ACTIVATE,
+                                        0, 0, 0, NULL);
+        }
+    }
+
+    ret = WLAN_STATUS_SUCCESS;
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function handles the timeout of command sending.
+ *  It will re-send the same command again.
+ *  
+ *  @param FunctionContext    A pointer to FunctionContext
+ *  @return 	   n/a
+ */
+void
+MrvDrvCommandTimerFunction(void *FunctionContext)
+{
+    wlan_private *priv = (wlan_private *) FunctionContext;
+    wlan_adapter *Adapter = priv->adapter;
+    CmdCtrlNode *pTempNode;
+    HostCmd_DS_COMMAND *CmdPtr;
+
+    ENTER();
+
+    PRINTM(CMND, "Command timeout.\n");
+
+    Adapter->CommandTimerIsSet = FALSE;
+
+    if (!Adapter->num_cmd_timeout)
+        Adapter->dbg.num_cmd_timeout++;
+
+    pTempNode = Adapter->CurCmd;
+
+    if (pTempNode == NULL) {
+        PRINTM(INFO, "CurCmd Empty\n");
+        goto exit;
+    }
+
+    CmdPtr = (HostCmd_DS_COMMAND *) pTempNode->BufVirtualAddr;
+    if (CmdPtr == NULL) {
+        goto exit;
+    }
+
+    if (CmdPtr->Size) {
+        Adapter->dbg.TimeoutCmdId = wlan_cpu_to_le16(CmdPtr->Command);
+        Adapter->dbg.TimeoutCmdAct =
+            wlan_cpu_to_le16(*(u16 *) ((u8 *) CmdPtr + S_DS_GEN));
+        PRINTM(CMND, "Timeout cmd = 0x%x, act = 0x%x\n",
+               Adapter->dbg.TimeoutCmdId, Adapter->dbg.TimeoutCmdAct);
+    }
+#define MAX_CMD_TIMEOUT_COUNT	3
+    Adapter->num_cmd_timeout++;
+    if (Adapter->num_cmd_timeout > MAX_CMD_TIMEOUT_COUNT) {
+        PRINTM(FATAL, "num_cmd_timeout=%d\n", Adapter->num_cmd_timeout);
+        goto exit;
+    }
+
+    /* Restart the timer to trace command response again */
+    ModTimer(&Adapter->MrvDrvCommandTimer, MRVDRV_TIMER_1S);
+    Adapter->CommandTimerIsSet = TRUE;
+
+    /* Wake up main thread to read int status register */
+    Adapter->IntCounter++;
+    wake_up_interruptible(&priv->MainThread.waitQ);
+
+  exit:
+    LEAVE();
+    return;
+}
+
+/** 
+ *  @brief This function sends sleep confirm command to firmware.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param cmdptr  A pointer to the command
+ *  @param size	   the size of command
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+SendConfirmSleep(wlan_private * priv, u8 * CmdPtr, u16 size)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    static u32 i = 0;
+
+    ENTER();
+
+    HEXDUMP("SLEEP_CFM", CmdPtr, size);
+
+    ret = sbi_host_to_card(priv, MVMS_CMD, CmdPtr, size);
+    priv->wlan_dev.dnld_sent = DNLD_RES_RECEIVED;
+
+    if (ret) {
+        PRINTM(MSG, "SLEEP_CFM: sbi_host_to_card() failed\n");
+        Adapter->dbg.num_cmd_sleep_cfm_host_to_card_failure++;
+    } else {
+        Adapter->PSState = PS_STATE_SLEEP;
+
+        if (Adapter->bHostSleepConfigured &&
+            (Adapter->sleep_period.period == 0)) {
+            Adapter->bWakeupDevRequired = TRUE;
+
+            wlan_host_sleep_activated_event(priv);
+        }
+#define NUM_SC_PER_LINE		16
+        if (++i % NUM_SC_PER_LINE == 0) {
+            PRINTM(EVENT, "+\n");
+        } else {
+            PRINTM(EVENT, "+");
+        }
+
+        /* check if interrupt is received after sleep confirm */
+        if (Adapter->IntCounter) {
+            PRINTM(INFO, "SLEEP_CFM: After sent, IntCnt=%d\n",
+                   Adapter->IntCounter);
+            Adapter->PSState = PS_STATE_AWAKE;
+
+        }
+
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function sends Enter_PS command to firmware.
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @param wait_option	wait response or not
+ *  @return 	   	n/a 
+ */
+void
+PSSleep(wlan_private * priv, int wait_option)
+{
+
+    ENTER();
+
+    PrepareAndSendCommand(priv, HostCmd_CMD_802_11_PS_MODE,
+                          HostCmd_SubCmd_Enter_PS, wait_option, 0, NULL);
+
+    LEAVE();
+    return;
+}
+
+/** 
+ *  @brief This function sends Eixt_PS command to firmware.
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @param wait_option	wait response or not
+ *  @return 	   	n/a 
+ */
+void
+PSWakeup(wlan_private * priv, int wait_option)
+{
+    WLAN_802_11_POWER_MODE LocalPSMode;
+
+    ENTER();
+
+    LocalPSMode = Wlan802_11PowerModeCAM;
+
+    PrepareAndSendCommand(priv, HostCmd_CMD_802_11_PS_MODE,
+                          HostCmd_SubCmd_Exit_PS,
+                          wait_option, 0, &LocalPSMode);
+
+    LEAVE();
+    return;
+}
+
+/** 
+ *  @brief This function checks condition and prepares to
+ *  send sleep confirm command to firmware if ok.
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @param PSMode  	Power Saving mode
+ *  @return 	   	n/a 
+ */
+void
+PSConfirmSleep(wlan_private * priv, u16 PSMode)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (!priv->wlan_dev.dnld_sent && !Adapter->CurCmd && !Adapter->IntCounter) {
+        SendConfirmSleep(priv, (u8 *) & Adapter->PSConfirmSleep,
+                         sizeof(PS_CMD_ConfirmSleep));
+
+        os_start_queue(priv);
+    } else {
+        PRINTM(INFO, "Delay Sleep Confirm (%s%s%s)\n",
+               (priv->wlan_dev.dnld_sent) ? "D" : "",
+               (Adapter->CurCmd) ? "C" : "",
+               (Adapter->IntCounter) ? "I" : "");
+    }
+
+    LEAVE();
+}
Index: linux-2.6.29/drivers/net/wireless/marvell8686/wlan_cmdresp.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/wlan_cmdresp.c	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,1595 @@
+/** @file wlan_cmdresp.c
+  * @brief This file contains the handling of command
+  * responses as well as events generated by firmware.
+  * 
+  *  Copyright  Marvell International Ltd. and/or its affiliates, 2003-2007
+  */
+/********************************************************
+Change log:
+	10/10/05: Add Doxygen format comments
+	11/11/05: Add support for WMM Status change event
+	12/13/05: Add Proprietary periodic sleep support
+	12/23/05: Fix bug in adhoc start where the current index was
+	          not properly being assigned before it was used.
+	01/05/06: Add kernel 2.6.x support	
+	01/11/06: Conditionalize new scan/join structures.
+	          Update assoc response handling; entire IEEE response returned
+	04/06/06: Add TSPEC, queue metrics, and MSDU expiry support
+	04/10/06: Add hostcmd generic API
+	04/18/06: Remove old Subscrive Event and add new Subscribe Event
+	          implementation through generic hostcmd API
+	05/04/06: Add IBSS coalescing related new hostcmd response handling
+	05/08/06: Remove PermanentAddr from Adapter
+	06/08/06: Remove function HandleMICFailureEvent()
+	08/29/06: Add ledgpio private command
+********************************************************/
+
+#include	"include.h"
+
+/********************************************************
+		Local Variables
+********************************************************/
+
+/********************************************************
+		Global Variables
+********************************************************/
+
+/********************************************************
+		Local Functions
+********************************************************/
+
+/** 
+ *  @brief This function handles disconnect event. it
+ *  reports disconnect to upper layer, clean tx/rx packets,
+ *  reset link state etc.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   n/a
+ */
+void
+MacEventDisconnected(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    union iwreq_data wrqu;
+
+    ENTER();
+
+    if (Adapter->MediaConnectStatus != WlanMediaStateConnected)
+        return;
+
+    PRINTM(INFO, "Handles disconnect event.\n");
+
+    /* Free Tx and Rx packets, report disconnect to upper layer */
+    wlan_clean_txrx(priv);
+
+    memset(wrqu.ap_addr.sa_data, 0x00, ETH_ALEN);
+    wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+
+    wireless_send_event(priv->wlan_dev.netdev, SIOCGIWAP, &wrqu, NULL);
+
+    /* reset SNR/NF/RSSI values */
+    memset(Adapter->SNR, 0x00, sizeof(Adapter->SNR));
+    memset(Adapter->NF, 0x00, sizeof(Adapter->NF));
+    memset(Adapter->RSSI, 0x00, sizeof(Adapter->RSSI));
+    memset(Adapter->rawSNR, 0x00, sizeof(Adapter->rawSNR));
+    memset(Adapter->rawNF, 0x00, sizeof(Adapter->rawNF));
+    Adapter->nextSNRNF = 0;
+    Adapter->numSNRNF = 0;
+    Adapter->RxPDRate = 0;
+    PRINTM(INFO, "Current SSID=%s, Ssid Length=%u\n",
+           Adapter->CurBssParams.BSSDescriptor.Ssid.Ssid,
+           Adapter->CurBssParams.BSSDescriptor.Ssid.SsidLength);
+    PRINTM(INFO, "Previous SSID=%s, Ssid Length=%u\n",
+           Adapter->PreviousSSID.Ssid, Adapter->PreviousSSID.SsidLength);
+
+    Adapter->SecInfo.WPAEnabled = FALSE;
+    Adapter->SecInfo.WPA2Enabled = FALSE;
+    Adapter->Wpa_ie_len = 0;
+    Adapter->SecInfo.EncryptionMode = CIPHER_NONE;
+
+    Adapter->MediaConnectStatus = WlanMediaStateDisconnected;
+
+    Adapter->AdhocLinkSensed = FALSE;
+
+    /* 
+     * memorize the previous SSID and BSSID
+     * it could be used for re-assoc
+     */
+    memcpy(&Adapter->PreviousSSID,
+           &Adapter->CurBssParams.BSSDescriptor.Ssid,
+           sizeof(WLAN_802_11_SSID));
+    memcpy(Adapter->PreviousBSSID,
+           Adapter->CurBssParams.BSSDescriptor.MacAddress, ETH_ALEN);
+
+    /* need to erase the current SSID and BSSID info */
+    memset(&Adapter->CurBssParams, 0x00, sizeof(Adapter->CurBssParams));
+
+    if (Adapter->PSState != PS_STATE_FULL_POWER) {
+        /* make firmware to exit PS mode */
+        PRINTM(INFO, "Disconnected, so exit PS mode.\n");
+        PSWakeup(priv, 0);
+    }
+
+    LEAVE();
+}
+
+/** 
+ *  @brief This function handles link lost, deauth and
+ *  disassoc events.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   n/a
+ */
+static void
+HandleDisconnectEvent(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        MacEventDisconnected(priv);
+#ifdef REASSOCIATION
+        if (Adapter->Reassoc_on == TRUE) {
+            PRINTM(INFO, "RE-ASSOC: trigger the timer\n");
+            Adapter->ReassocTimerIsSet = TRUE;
+            ModTimer(&Adapter->MrvDrvTimer, 0);
+        }
+#endif /* REASSOCIATION */
+    }
+}
+
+/** 
+ *  @brief This function handles the command response of reg_access
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param type	   the type of reg access (MAC, BBP or RF)
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_reg_access(wlan_private * priv, u16 type, HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    wlan_offset_value *pOffsetValue =
+        (wlan_offset_value *) Adapter->CurCmd->pdata_buf;
+
+    ENTER();
+
+    switch (type) {
+    case HostCmd_RET_MAC_REG_ACCESS:
+        {
+            HostCmd_DS_MAC_REG_ACCESS *reg;
+
+            reg = (HostCmd_DS_MAC_REG_ACCESS *) & resp->params.macreg;
+
+            pOffsetValue->offset = wlan_le16_to_cpu(reg->Offset);
+            pOffsetValue->value = wlan_le32_to_cpu(reg->Value);
+            break;
+        }
+
+    case HostCmd_RET_BBP_REG_ACCESS:
+        {
+            HostCmd_DS_BBP_REG_ACCESS *reg;
+            reg = (HostCmd_DS_BBP_REG_ACCESS *) & resp->params.bbpreg;
+
+            pOffsetValue->offset = wlan_le16_to_cpu(reg->Offset);
+            pOffsetValue->value = (u8) reg->Value;
+            break;
+        }
+
+    case HostCmd_RET_RF_REG_ACCESS:
+        {
+            HostCmd_DS_RF_REG_ACCESS *reg;
+            reg = (HostCmd_DS_RF_REG_ACCESS *) & resp->params.rfreg;
+
+            pOffsetValue->offset = wlan_le16_to_cpu(reg->Offset);
+            pOffsetValue->value = (u8) reg->Value;
+            break;
+        }
+
+    default:
+        LEAVE();
+        return WLAN_STATUS_FAILURE;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of get_hw_spec
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_get_hw_spec(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    u32 i;
+    HostCmd_DS_GET_HW_SPEC *hwspec = &resp->params.hwspec;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    Adapter->fwCapInfo = wlan_le32_to_cpu(hwspec->fwCapInfo);
+
+    Adapter->FWReleaseNumber = wlan_le32_to_cpu(hwspec->FWReleaseNumber);
+
+    PRINTM(INFO, "GET_HW_SPEC: FWReleaseVersion- 0x%X\n",
+           Adapter->FWReleaseNumber);
+    PRINTM(INFO, "GET_HW_SPEC: Permanent addr- %2x:%2x:%2x:%2x:%2x:%2x\n",
+           hwspec->PermanentAddr[0], hwspec->PermanentAddr[1],
+           hwspec->PermanentAddr[2], hwspec->PermanentAddr[3],
+           hwspec->PermanentAddr[4], hwspec->PermanentAddr[5]);
+    PRINTM(INFO, "GET_HW_SPEC: HWIfVersion=0x%X  Version=0x%X\n",
+           wlan_le16_to_cpu(hwspec->HWIfVersion),
+           wlan_le16_to_cpu(hwspec->Version));
+
+    Adapter->RegionCode = wlan_le16_to_cpu(hwspec->RegionCode);
+
+    for (i = 0; i < MRVDRV_MAX_REGION_CODE; i++) {
+        /* use the region code to search for the index */
+        if (Adapter->RegionCode == RegionCodeToIndex[i]) {
+            break;
+        }
+    }
+
+    /* if it's unidentified region code, use the default (USA) */
+    if (i >= MRVDRV_MAX_REGION_CODE) {
+        Adapter->RegionCode = 0x10;
+        PRINTM(WARN, "unidentified region code, use the default (USA)\n");
+    }
+
+    /* HACK IT MAKE RegionCode always equals 0x30 */
+    Adapter->RegionCode = 0x30;
+
+    if (Adapter->CurrentAddr[0] == 0xff) {
+        memmove(Adapter->CurrentAddr, hwspec->PermanentAddr, ETH_ALEN);
+    }
+    /* HACK PermanentAddr[0] Equals 0xFF */
+    if (Adapter->CurrentAddr[0] == 0xff) {
+        Adapter->CurrentAddr[0] = 0x00;
+        Adapter->CurrentAddr[1] = 0x1a;
+        Adapter->CurrentAddr[2] = 0x6b;
+    }
+    memcpy(priv->wlan_dev.netdev->dev_addr, Adapter->CurrentAddr, ETH_ALEN);
+
+    if (wlan_set_regiontable(priv, Adapter->RegionCode, 0)) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    if (wlan_set_universaltable(priv, 0)) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function handles the command response of host_sleep_cfg
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_host_sleep_cfg(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_HOST_SLEEP_CFG *hscfg = &resp->params.hostsleepcfg;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (hscfg->conditions != HOST_SLEEP_CFG_CANCEL) {
+        Adapter->bHostSleepConfigured = TRUE;
+    } else {
+        Adapter->bHostSleepConfigured = FALSE;
+        if (Adapter->PSState == PS_STATE_FULL_POWER && Adapter->HS_Activated) {
+            wlan_host_sleep_deactivated_event(priv);
+        }
+        os_start_queue(priv);
+        os_carrier_on(priv);
+        wmm_start_queue(priv);
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function handles the command response of fw_wakeup_method
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_fw_wakeup_method(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_FW_WAKEUP_METHOD *fwwm = &resp->params.fwwakeupmethod;
+    u16 action;
+
+    ENTER();
+
+    action = wlan_le16_to_cpu(fwwm->Action);
+
+    switch (action) {
+    case HostCmd_ACT_GET:
+    case HostCmd_ACT_SET:
+        Adapter->fwWakeupMethod = wlan_le16_to_cpu(fwwm->Method);
+        break;
+    default:
+        break;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of sleep_params
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_sleep_params(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_SLEEP_PARAMS *sp = &resp->params.sleep_params;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    PRINTM(INFO, "error=%x offset=%x stabletime=%x calcontrol=%x\n"
+           " extsleepclk=%x\n", sp->Error, sp->Offset,
+           sp->StableTime, sp->CalControl, sp->ExternalSleepClk);
+    Adapter->sp.sp_error = wlan_le16_to_cpu(sp->Error);
+    Adapter->sp.sp_offset = wlan_le16_to_cpu(sp->Offset);
+    Adapter->sp.sp_stabletime = wlan_le16_to_cpu(sp->StableTime);
+    Adapter->sp.sp_calcontrol = wlan_le16_to_cpu(sp->CalControl);
+    Adapter->sp.sp_extsleepclk = wlan_le16_to_cpu(sp->ExternalSleepClk);
+    Adapter->sp.sp_reserved = wlan_le16_to_cpu(sp->Reserved);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of sleep_params
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_sleep_period(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_SLEEP_PERIOD *sp_period = &resp->params.ps_sleeppd;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    Adapter->sleep_period.period = wlan_le16_to_cpu(sp_period->Period);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of bca_timeshare
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_bca_timeshare(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_BCA_TIMESHARE *bca_ts = &resp->params.bca_timeshare;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    PRINTM(MSG, "TrafficType=%x TimeShareInterva=%x BTTime=%x\n",
+           bca_ts->TrafficType, bca_ts->TimeShareInterval, bca_ts->BTTime);
+
+    Adapter->bca_ts.TrafficType = wlan_le16_to_cpu(bca_ts->TrafficType);
+    Adapter->bca_ts.TimeShareInterval =
+        wlan_le32_to_cpu(bca_ts->TimeShareInterval);
+    Adapter->bca_ts.BTTime = wlan_le32_to_cpu(bca_ts->BTTime);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of mac_control
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_mac_control(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of set_wep
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_set_wep(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of reset
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_reset(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    ENTER();
+    PRINTM(INFO, "HWAC - Reset command successful\n");
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of snmp_mib
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_snmp_mib(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_SNMP_MIB *smib = &resp->params.smib;
+    u16 OID = wlan_le16_to_cpu(smib->OID);
+    u16 QueryType = wlan_le16_to_cpu(smib->QueryType);
+
+    ENTER();
+
+    PRINTM(INFO, "SNMP_RESP: value of the OID = %x, QueryType=%x\n", OID,
+           QueryType);
+    PRINTM(INFO, "SNMP_RESP: Buf size  = %x\n",
+           wlan_le16_to_cpu(smib->BufSize));
+
+    if (QueryType == HostCmd_ACT_GEN_GET) {
+        switch (OID) {
+        case FragThresh_i:
+            priv->adapter->FragThsd =
+                wlan_le16_to_cpu(*((PUSHORT) (smib->Value)));
+            PRINTM(INFO, "SNMP_RESP: FragThsd =%u\n",
+                   priv->adapter->FragThsd);
+            break;
+        case RtsThresh_i:
+            priv->adapter->RTSThsd =
+                wlan_le16_to_cpu(*((PUSHORT) (smib->Value)));
+            PRINTM(INFO, "SNMP_RESP: RTSThsd =%u\n", priv->adapter->RTSThsd);
+            break;
+        case ShortRetryLim_i:
+            priv->adapter->TxRetryCount =
+                wlan_le16_to_cpu(*((PUSHORT) (smib->Value)));
+            PRINTM(INFO, "SNMP_RESP: TxRetryCount =%u\n",
+                   priv->adapter->RTSThsd);
+            break;
+        case DtimPeriod_i:
+            priv->adapter->Dtim =
+                wlan_le16_to_cpu(*((PUSHORT) (smib->Value)));
+            PRINTM(INFO, "SNMP_RESP: DtimPeriod =%u\n", priv->adapter->Dtim);
+            break;
+        default:
+            break;
+        }
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of radio_control
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_radio_control(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    ENTER();
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of key_material
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_key_material(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_KEY_MATERIAL *pKey = &resp->params.keymaterial;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (wlan_le16_to_cpu(pKey->Action) == HostCmd_ACT_SET) {
+        if ((wlan_le16_to_cpu(pKey->KeyParamSet.KeyInfo) &
+             KEY_INFO_TKIP_MCAST)
+            || (wlan_le16_to_cpu(pKey->KeyParamSet.KeyInfo) &
+                KEY_INFO_AES_MCAST)) {
+            PRINTM(INFO, "Key: GTK is set\n");
+            Adapter->IsGTK_SET = TRUE;
+        }
+    }
+
+    memcpy(Adapter->aeskey.KeyParamSet.Key, pKey->KeyParamSet.Key,
+           sizeof(pKey->KeyParamSet.Key));
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of mac_address
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_mac_address(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_MAC_ADDRESS *MacAdd = &resp->params.macadd;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    memcpy(Adapter->CurrentAddr, MacAdd->MacAdd, ETH_ALEN);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of rf_tx_power
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_rf_tx_power(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_RF_TX_POWER *rtp = &resp->params.txp;
+    wlan_adapter *Adapter = priv->adapter;
+    u16 Action = wlan_le16_to_cpu(rtp->Action);
+
+    ENTER();
+
+    Adapter->TxPowerLevel = wlan_le16_to_cpu(rtp->CurrentLevel);
+
+    if (Action == HostCmd_ACT_GET) {
+        Adapter->MaxTxPowerLevel = rtp->MaxPower;
+        Adapter->MinTxPowerLevel = rtp->MinPower;
+    }
+
+    PRINTM(INFO, "Current TxPower Level = %d,Max Power=%d, Min Power=%d\n",
+           Adapter->TxPowerLevel, Adapter->MaxTxPowerLevel,
+           Adapter->MinTxPowerLevel);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of rf_antenna
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_rf_antenna(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_RF_ANTENNA *pAntenna = &resp->params.rant;
+    wlan_adapter *Adapter = priv->adapter;
+    u16 Action = wlan_le16_to_cpu(pAntenna->Action);
+
+    if (Action == HostCmd_ACT_GET_RX)
+        Adapter->RxAntennaMode = wlan_le16_to_cpu(pAntenna->AntennaMode);
+
+    if (Action == HostCmd_ACT_GET_TX)
+        Adapter->TxAntennaMode = wlan_le16_to_cpu(pAntenna->AntennaMode);
+
+    PRINTM(INFO, "RF_ANT_RESP: Action = 0x%x, Mode = 0x%04x\n",
+           Action, wlan_le16_to_cpu(pAntenna->AntennaMode));
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of multicast_address
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_mac_multicast_adr(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of rate_adapt_rateset
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_rate_adapt_rateset(wlan_private * priv,
+                                   HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_RATE_ADAPT_RATESET *rates = &resp->params.rateset;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (wlan_le16_to_cpu(rates->Action) == HostCmd_ACT_GET) {
+        Adapter->HWRateDropMode = wlan_le16_to_cpu(rates->HWRateDropMode);
+        Adapter->Threshold = wlan_le16_to_cpu(rates->Threshold);
+        Adapter->FinalRate = wlan_le16_to_cpu(rates->FinalRate);
+        Adapter->RateBitmap = wlan_le16_to_cpu(rates->Bitmap);
+    }
+
+    LEAVE();
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of rf_channel
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_rf_channel(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_RF_CHANNEL *rfchannel = &resp->params.rfchannel;
+    wlan_adapter *Adapter = priv->adapter;
+    u16 Action = wlan_le16_to_cpu(rfchannel->Action);
+    u16 newChannel = wlan_le16_to_cpu(rfchannel->CurrentChannel);
+
+    ENTER();
+
+    if (Action == HostCmd_OPT_802_11_RF_CHANNEL_GET
+        && Adapter->CurBssParams.BSSDescriptor.Channel != newChannel) {
+        PRINTM(INFO, "Channel Switch: %d to %d\n",
+               Adapter->CurBssParams.BSSDescriptor.Channel, newChannel);
+
+        /* Update the channel again */
+        Adapter->CurBssParams.BSSDescriptor.Channel = newChannel;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of rssi
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_rssi(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_RSSI_RSP *rssirsp = &resp->params.rssirsp;
+    wlan_adapter *Adapter = priv->adapter;
+
+    /* store the non average value */
+    Adapter->SNR[TYPE_BEACON][TYPE_NOAVG] = wlan_le16_to_cpu(rssirsp->SNR);
+    Adapter->NF[TYPE_BEACON][TYPE_NOAVG] =
+        wlan_le16_to_cpu(rssirsp->NoiseFloor);
+
+    Adapter->SNR[TYPE_BEACON][TYPE_AVG] = wlan_le16_to_cpu(rssirsp->AvgSNR);
+    Adapter->NF[TYPE_BEACON][TYPE_AVG] =
+        wlan_le16_to_cpu(rssirsp->AvgNoiseFloor);
+
+    Adapter->RSSI[TYPE_BEACON][TYPE_NOAVG] =
+        CAL_RSSI(Adapter->SNR[TYPE_BEACON][TYPE_NOAVG],
+                 Adapter->NF[TYPE_BEACON][TYPE_NOAVG]);
+
+    Adapter->RSSI[TYPE_BEACON][TYPE_AVG] =
+        CAL_RSSI(Adapter->SNR[TYPE_BEACON][TYPE_AVG] / AVG_SCALE,
+                 Adapter->NF[TYPE_BEACON][TYPE_AVG] / AVG_SCALE);
+
+    PRINTM(INFO, "Beacon RSSI value = 0x%x\n",
+           Adapter->RSSI[TYPE_BEACON][TYPE_AVG]);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+#ifdef MFG_CMD_SUPPORT
+/** 
+ *  @brief This function handles the command response of mfg_cmd
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_mfg_cmd(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    PRINTM(INFO, "MFG command response size = %d\n", resp->Size);
+
+    resp->Size = MIN(resp->Size, MRVDRV_SIZE_OF_CMD_BUFFER);
+    memcpy(Adapter->CurCmd->pdata_buf, (void *) resp, resp->Size);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+#endif /* MFG_CMD_SUPPORT */
+
+/** 
+ *  @brief This function handles the command response of cal_data_ext.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param resp		A pointer to HostCmd_DS_COMMAND
+ *  @return    		WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_cal_data_ext(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_CAL_DATA_EXT *pCalDataExt = &resp->params.caldataext;
+
+    ENTER();
+
+    if (wlan_le16_to_cpu(pCalDataExt->Action) == HostCmd_ACT_GEN_GET) {
+        pCalDataExt->Action = wlan_le16_to_cpu(pCalDataExt->Action);
+        pCalDataExt->Revision = wlan_le16_to_cpu(pCalDataExt->Revision);
+        pCalDataExt->CalDataLen = wlan_le16_to_cpu(pCalDataExt->CalDataLen);
+
+        memmove(Adapter->CurCmd->pdata_buf,
+                pCalDataExt, pCalDataExt->CalDataLen + CAL_DATA_HEADER_LEN);
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of eeprom_access
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_ret_802_11_eeprom_access(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    wlan_ioctl_regrdwr *pBuf =
+        (wlan_ioctl_regrdwr *) Adapter->CurCmd->pdata_buf;
+
+    PRINTM(INFO, "eeprom read len=%x\n",
+           wlan_le16_to_cpu(resp->params.rdeeprom.ByteCount));
+    if (pBuf->NOB < wlan_le16_to_cpu(resp->params.rdeeprom.ByteCount)) {
+        pBuf->NOB = 0;
+        PRINTM(INFO, "eeprom read return length is too big\n");
+        return WLAN_STATUS_FAILURE;
+    }
+    pBuf->NOB = wlan_le16_to_cpu(resp->params.rdeeprom.ByteCount);
+    if (pBuf->NOB > 0) {
+        memcpy(&pBuf->Value, (u8 *) & resp->params.rdeeprom.Value, pBuf->NOB);
+        HEXDUMP("EEPROM", (char *) &pBuf->Value, pBuf->NOB);
+    }
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of get_log
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_get_log(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_GET_LOG *LogMessage =
+        (HostCmd_DS_802_11_GET_LOG *) & resp->params.glog;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    /* TODO Convert it to Big Endian before copy */
+    memcpy(&Adapter->LogMsg, LogMessage, sizeof(HostCmd_DS_802_11_GET_LOG));
+    endian_convert_GET_LOG(Adapter->LogMsg);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+static void
+wlan_ret_802_11_IBSS_Coalesced_Status(wlan_private * priv,
+                                      HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_IBSS_Status *IBSSStatusRsp;
+    wlan_adapter *Adapter;
+    union iwreq_data wrqu;
+    u8 nullMac[6] = { 0, 0, 0, 0, 0, 0 };
+
+    Adapter = priv->adapter;
+    IBSSStatusRsp = &(resp->params.ibssCoalescing);
+
+    if (Adapter->CurCmd->pdata_buf)
+        *(int *) Adapter->CurCmd->pdata_buf = IBSSStatusRsp->Enable;
+
+    if (wlan_le16_to_cpu(IBSSStatusRsp->Action) == HostCmd_ACT_SET) {
+        return;
+    }
+
+    PRINTM(INFO, "New BSSID %x:%x:%x:%x:%x:%x\n",
+           IBSSStatusRsp->BSSID[0],
+           IBSSStatusRsp->BSSID[1],
+           IBSSStatusRsp->BSSID[2],
+           IBSSStatusRsp->BSSID[3],
+           IBSSStatusRsp->BSSID[4], IBSSStatusRsp->BSSID[5]);
+
+    /* if rsp has NULL BSSID, Just return.. No Action */
+    if (!memcmp(IBSSStatusRsp->BSSID, nullMac, MRVDRV_ETH_ADDR_LEN)) {
+        PRINTM(MSG, "New BSSID is NULL\n");
+        return;
+    }
+
+    /* if BSSID is diff, Send evnet to Linux */
+    if (memcmp(Adapter->CurBssParams.BSSDescriptor.MacAddress,
+               IBSSStatusRsp->BSSID, ETH_ALEN)) {
+        memcpy((void *) Adapter->CurBssParams.BSSDescriptor.MacAddress,
+               (void *) IBSSStatusRsp->BSSID, MRVDRV_ETH_ADDR_LEN);
+
+        /* Beacon Interval and ATIM window */
+        Adapter->CurBssParams.BSSDescriptor.BeaconPeriod
+            = IBSSStatusRsp->BeaconInterval;
+        Adapter->CurBssParams.BSSDescriptor.ATIMWindow
+            = IBSSStatusRsp->ATIMWindow;
+        //ERP Information
+        Adapter->CurBssParams.BSSDescriptor.ERPFlags =
+            (u8) IBSSStatusRsp->UseGRateProtection;
+
+        memset(&wrqu, 0, sizeof(wrqu));
+        memcpy(wrqu.ap_addr.sa_data,
+               Adapter->CurBssParams.BSSDescriptor.MacAddress, ETH_ALEN);
+        wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+
+        wireless_send_event(priv->wlan_dev.netdev, SIOCGIWAP, &wrqu, NULL);
+
+    }
+}
+
+/********************************************************
+		Global Functions
+********************************************************/
+
+/** 
+ *  @brief This function stop tx/rx queue and free skb
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+void
+wlan_clean_txrx(wlan_private * priv)
+{
+    os_stop_queue(priv);
+    os_carrier_off(priv);
+
+    wmm_stop_queue(priv);
+    wmm_cleanup_queues(priv);
+
+    /* Free Tx and Rx packets */
+    os_free_tx_packet(priv);
+    wlan_send_rxskbQ(priv);
+}
+
+/** 
+ *  @brief This function handles the command response
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_process_rx_command(wlan_private * priv)
+{
+    u16 RespCmd;
+    HostCmd_DS_COMMAND *resp;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    ulong flags;
+    u16 Result;
+
+    ENTER();
+
+    /* Now we got response from FW, cancel the command timer */
+    if (Adapter->CommandTimerIsSet) {
+        CancelTimer(&Adapter->MrvDrvCommandTimer);
+        Adapter->CommandTimerIsSet = FALSE;
+    }
+
+    if (!Adapter->CurCmd) {
+        resp = (HostCmd_DS_COMMAND *) priv->wlan_dev.upld_buf;
+        resp->Command = wlan_le16_to_cpu(resp->Command);
+        PRINTM(ERROR, "CMD_RESP: NULL CurCmd, 0x%x\n", resp->Command);
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+    Adapter->num_cmd_timeout = 0;
+
+    DBG_HEXDUMP(CMD_D, "CMD_RESP", Adapter->CurCmd->BufVirtualAddr,
+                priv->wlan_dev.upld_len);
+
+    resp = (HostCmd_DS_COMMAND *) (Adapter->CurCmd->BufVirtualAddr);
+
+    resp->Command = wlan_le16_to_cpu(resp->Command);
+    resp->Size = wlan_le16_to_cpu(resp->Size);
+    resp->SeqNum = wlan_le16_to_cpu(resp->SeqNum);
+    resp->Result = wlan_le16_to_cpu(resp->Result);
+
+    RespCmd = resp->Command;
+    Result = resp->Result;
+
+    /* Save the last command response to debug log */
+    Adapter->dbg.LastCmdRespIndex =
+        (Adapter->dbg.LastCmdRespIndex + 1) % DBG_CMD_NUM;
+    Adapter->dbg.LastCmdRespId[Adapter->dbg.LastCmdRespIndex] = RespCmd;
+
+    PRINTM(CMND, "CMD_RESP: 0x%x, result %d, len %d, seqno %d @ %lu\n",
+           RespCmd, Result, resp->Size, resp->SeqNum, os_time_get());
+
+    if (!(RespCmd & 0x8000)) {
+        PRINTM(ERROR, "CMD_RESP: Invalid response to command!");
+        Adapter->CurCmdRetCode = WLAN_STATUS_FAILURE;
+        CleanupAndInsertCmd(priv, Adapter->CurCmd);
+        spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+        Adapter->CurCmd = NULL;
+        spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    /* Store the response code to CurCmdRetCode. */
+    Adapter->CurCmdRetCode = resp->Result;
+
+    if (RespCmd == HostCmd_RET_802_11_PS_MODE) {
+        HostCmd_DS_802_11_PS_MODE *psmode;
+
+        psmode = &resp->params.psmode;
+        PRINTM(INFO, "CMD_RESP: PS_MODE cmd reply result=%#x action=0x%X\n",
+               resp->Result, psmode->Action);
+        psmode->Action = wlan_cpu_to_le16(psmode->Action);
+
+        if (Result) {
+            PRINTM(ERROR, "CMD_RESP: PS command failed- %#x \n",
+                   resp->Result);
+            if (Adapter->InfrastructureMode == Wlan802_11IBSS) {
+                /* 
+                 * We should not re-try enter-ps command in 
+                 * ad-hoc mode. It takes place in 
+                 * ExecuteNextCommand().
+                 */
+                if (psmode->Action == HostCmd_SubCmd_Enter_PS)
+                    Adapter->PSMode = Wlan802_11PowerModeCAM;
+            }
+        } else if (psmode->Action == HostCmd_SubCmd_Enter_PS) {
+            Adapter->NeedToWakeup = FALSE;
+            Adapter->PSState = PS_STATE_AWAKE;
+
+            if (Adapter->MediaConnectStatus != WlanMediaStateConnected) {
+                /*
+                 * When Deauth Event received before Enter_PS command
+                 * response, We need to wake up the firmware.
+                 */
+                PRINTM(INFO,
+                       "CMD_RESP: Disconnected, Going to invoke PSWakeup\n");
+                PSWakeup(priv, 0);
+            }
+        } else if (psmode->Action == HostCmd_SubCmd_Exit_PS) {
+            Adapter->NeedToWakeup = FALSE;
+            Adapter->PSState = PS_STATE_FULL_POWER;
+
+        } else {
+            PRINTM(INFO, "CMD_RESP: PS- Action=0x%X\n", psmode->Action);
+        }
+
+        CleanupAndInsertCmd(priv, Adapter->CurCmd);
+        spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+        Adapter->CurCmd = NULL;
+        spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+
+        ret = WLAN_STATUS_SUCCESS;
+        goto done;
+    }
+
+    if (Adapter->CurCmd->CmdFlags & CMD_F_HOSTCMD) {
+        /* Copy the response back to response buffer */
+        memcpy(Adapter->CurCmd->pdata_buf, resp, resp->Size);
+
+        Adapter->CurCmd->CmdFlags &= ~CMD_F_HOSTCMD;
+
+        if ((Result == HostCmd_RESULT_OK)
+            && (RespCmd == HostCmd_RET_802_11_HOST_SLEEP_CFG)) {
+            ret = wlan_ret_host_sleep_cfg(priv, resp);
+        }
+    } else {
+        /* If the command is not successful, cleanup and return failure */
+        if ((Result != HostCmd_RESULT_OK || !(RespCmd & 0x8000))) {
+            PRINTM(ERROR, "CMD_RESP: cmd %#x error, result=%#x\n",
+                   resp->Command, resp->Result);
+            /*
+             * Handling errors here
+             */
+            switch (RespCmd) {
+            case HostCmd_RET_HW_SPEC_INFO:
+                PRINTM(INFO, "CMD_RESP: HW spec command Failed\n");
+                break;
+
+            }
+
+            CleanupAndInsertCmd(priv, Adapter->CurCmd);
+            spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+            Adapter->CurCmd = NULL;
+            spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+
+            return WLAN_STATUS_FAILURE;
+        }
+
+        switch (RespCmd) {
+        case HostCmd_RET_MAC_REG_ACCESS:
+        case HostCmd_RET_BBP_REG_ACCESS:
+        case HostCmd_RET_RF_REG_ACCESS:
+            ret = wlan_ret_reg_access(priv, RespCmd, resp);
+
+            break;
+
+        case HostCmd_RET_HW_SPEC_INFO:
+            ret = wlan_ret_get_hw_spec(priv, resp);
+            break;
+
+        case HostCmd_RET_802_11_BG_SCAN_QUERY:
+            {
+                union iwreq_data wrqu;
+
+                ret = wlan_ret_802_11_scan(priv, resp);
+                memset(&wrqu, 0, sizeof(union iwreq_data));
+                wireless_send_event(priv->wlan_dev.netdev, SIOCGIWSCAN, &wrqu,
+                                    NULL);
+                PRINTM(INFO, "CMD_RESP: BG_SCAN result is ready!\n");
+                break;
+            }
+        case HostCmd_RET_802_11_SCAN:
+            ret = wlan_ret_802_11_scan(priv, resp);
+            break;
+
+        case HostCmd_RET_MAC_CONTROL:
+            ret = wlan_ret_mac_control(priv, resp);
+            break;
+
+        case HostCmd_RET_802_11_GET_LOG:
+            ret = wlan_ret_get_log(priv, resp);
+            break;
+
+        case HostCmd_RET_802_11_ASSOCIATE:
+            ret = wlan_ret_802_11_associate(priv, resp);
+            break;
+
+        case HostCmd_RET_802_11_DEAUTHENTICATE:
+            ret = wlan_ret_802_11_disassociate(priv, resp);
+            break;
+
+        case HostCmd_RET_802_11_SET_WEP:
+            ret = wlan_ret_802_11_set_wep(priv, resp);
+            break;
+
+        case HostCmd_RET_802_11_AD_HOC_START:
+        case HostCmd_RET_802_11_AD_HOC_JOIN:
+            ret = wlan_ret_802_11_ad_hoc(priv, resp);
+            break;
+
+        case HostCmd_RET_802_11_RESET:
+            ret = wlan_ret_802_11_reset(priv, resp);
+            break;
+
+        case HostCmd_RET_802_11_SNMP_MIB:
+            ret = wlan_ret_802_11_snmp_mib(priv, resp);
+            break;
+
+        case HostCmd_RET_802_11_RF_TX_POWER:
+            ret = wlan_ret_802_11_rf_tx_power(priv, resp);
+            break;
+
+        case HostCmd_RET_802_11_RADIO_CONTROL:
+            ret = wlan_ret_802_11_radio_control(priv, resp);
+            break;
+
+        case HostCmd_RET_802_11_HOST_SLEEP_CFG:
+            ret = wlan_ret_host_sleep_cfg(priv, resp);
+            break;
+        case HostCmd_RET_802_11_WAKEUP_CONFIRM:
+            wlan_host_sleep_deactivated_event(priv);
+            break;
+        case HostCmd_RET_802_11_HOST_SLEEP_ACTIVATE:
+            if (Adapter->bHostSleepConfigured
+                && Adapter->HSCfg.gap == HOST_SLEEP_CFG_GAP_FF)
+                Adapter->bWakeupDevRequired = TRUE;
+            wlan_host_sleep_activated_event(priv);
+            break;
+
+        case HostCmd_RET_802_11_RF_ANTENNA:
+            ret = wlan_ret_802_11_rf_antenna(priv, resp);
+            break;
+
+        case HostCmd_RET_MAC_MULTICAST_ADR:
+            ret = wlan_ret_mac_multicast_adr(priv, resp);
+            break;
+
+        case HostCmd_RET_802_11_RATE_ADAPT_RATESET:
+            ret = wlan_ret_802_11_rate_adapt_rateset(priv, resp);
+            break;
+        case HostCmd_RET_802_11_RF_CHANNEL:
+            ret = wlan_ret_802_11_rf_channel(priv, resp);
+            break;
+
+        case HostCmd_RET_802_11_RSSI:
+            ret = wlan_ret_802_11_rssi(priv, resp);
+            break;
+
+        case HostCmd_RET_802_11_MAC_ADDRESS:
+            ret = wlan_ret_802_11_mac_address(priv, resp);
+            break;
+
+#ifdef MFG_CMD_SUPPORT
+        case HostCmd_RET_MFG_COMMAND:
+            ret = wlan_ret_mfg_cmd(priv, resp);
+            break;
+#endif
+        case HostCmd_RET_802_11_AD_HOC_STOP:
+            ret = wlan_ret_802_11_ad_hoc_stop(priv, resp);
+            break;
+
+        case HostCmd_RET_802_11_CAL_DATA_EXT:
+            ret = wlan_ret_802_11_cal_data_ext(priv, resp);
+            break;
+
+        case HostCmd_RET_802_11_KEY_MATERIAL:
+            ret = wlan_ret_802_11_key_material(priv, resp);
+            break;
+
+        case HostCmd_RET_802_11_EEPROM_ACCESS:
+            ret = wlan_ret_802_11_eeprom_access(priv, resp);
+            break;
+
+        case HostCmd_RET_802_11D_DOMAIN_INFO:
+            ret = wlan_ret_802_11d_domain_info(priv, resp);
+            break;
+
+        case HostCmd_RET_802_11_SLEEP_PARAMS:
+            ret = wlan_ret_802_11_sleep_params(priv, resp);
+            break;
+        case HostCmd_RET_802_11_BCA_CONFIG_TIMESHARE:
+            ret = wlan_ret_802_11_bca_timeshare(priv, resp);
+            break;
+        case HostCmd_RET_802_11_INACTIVITY_TIMEOUT:
+            *((u16 *) Adapter->CurCmd->pdata_buf) =
+                wlan_le16_to_cpu(resp->params.inactivity_timeout.Timeout);
+            break;
+        case HostCmd_RET_802_11_BG_SCAN_CONFIG:
+            break;
+
+        case HostCmd_RET_802_11_FW_WAKE_METHOD:
+            ret = wlan_ret_fw_wakeup_method(priv, resp);
+            break;
+
+        case HostCmd_RET_802_11_SLEEP_PERIOD:
+            ret = wlan_ret_802_11_sleep_period(priv, resp);
+            break;
+        case HostCmd_RET_WMM_GET_STATUS:
+            ret = wlan_cmdresp_wmm_get_status(priv, resp);
+            break;
+        case HostCmd_RET_WMM_ADDTS_REQ:
+            ret = wlan_cmdresp_wmm_addts_req(priv, resp);
+            break;
+        case HostCmd_RET_WMM_DELTS_REQ:
+            ret = wlan_cmdresp_wmm_delts_req(priv, resp);
+            break;
+        case HostCmd_RET_WMM_QUEUE_CONFIG:
+            ret = wlan_cmdresp_wmm_queue_config(priv, resp);
+            break;
+        case HostCmd_RET_WMM_QUEUE_STATS:
+            ret = wlan_cmdresp_wmm_queue_stats(priv, resp);
+            break;
+        case HostCmd_RET_TX_PKT_STATS:
+            memcpy(Adapter->CurCmd->pdata_buf,
+                   &resp->params.txPktStats, sizeof(HostCmd_DS_TX_PKT_STATS));
+            ret = WLAN_STATUS_SUCCESS;
+            break;
+        case HostCmd_RET_802_11_TPC_CFG:
+            memmove(Adapter->CurCmd->pdata_buf,
+                    &resp->params.tpccfg, sizeof(HostCmd_DS_802_11_TPC_CFG));
+            break;
+        case HostCmd_RET_802_11_LED_CONTROL:
+            {
+                HostCmd_DS_802_11_LED_CTRL *pLedCtrl = &resp->params.ledgpio;
+                MrvlIEtypes_LedGpio_t *pGpio = &pLedCtrl->LedGpio;
+                MrvlIEtypes_LedBehavior_t *pBehavior = pLedCtrl->LedBehavior;
+
+                pLedCtrl->Action = wlan_le16_to_cpu(pLedCtrl->Action);
+                pLedCtrl->LedNums = wlan_le16_to_cpu(pLedCtrl->LedNums);
+                pGpio->Header.Type = wlan_le16_to_cpu(pGpio->Header.Type);
+                pGpio->Header.Len = wlan_le16_to_cpu(pGpio->Header.Len);
+                pBehavior->Header.Type =
+                    wlan_le16_to_cpu(pBehavior->Header.Type);
+                pBehavior->Header.Len =
+                    wlan_le16_to_cpu(pBehavior->Header.Len);
+                memmove(Adapter->CurCmd->pdata_buf, &resp->params.ledgpio,
+                        sizeof(HostCmd_DS_802_11_LED_CTRL));
+                break;
+            }
+
+        case HostCmd_RET_GET_TSF:
+            resp->params.gettsf.TsfValue =
+                wlan_le64_to_cpu(resp->params.gettsf.TsfValue);
+            memcpy(priv->adapter->CurCmd->pdata_buf,
+                   &resp->params.gettsf.TsfValue, sizeof(u64));
+            break;
+        case HostCmd_RTE_802_11_TX_RATE_QUERY:
+            priv->adapter->TxRate =
+                wlan_le16_to_cpu(resp->params.txrate.TxRate);
+            break;
+        case HostCmd_RET_802_11_IBSS_COALESCING_STATUS:
+            wlan_ret_802_11_IBSS_Coalesced_Status(priv, resp);
+            break;
+
+        case HostCmd_RET_SDIO_GPIO_INT_CONFIG:
+            memmove(Adapter->CurCmd->pdata_buf,
+                    &resp->params.sdio_int,
+                    sizeof(HostCmd_DS_SDIO_INT_CONFIG));
+            break;
+
+        case HostCmd_RET_SDIO_PULL_CTRL:
+            memmove(Adapter->CurCmd->pdata_buf,
+                    &resp->params.sdiopullctl,
+                    sizeof(HostCmd_DS_SDIO_PULL_CTRL));
+            break;
+
+        case HostCmd_RET_802_11_LDO_CONFIG:
+            resp->params.ldocfg.Action =
+                wlan_le16_to_cpu(resp->params.ldocfg.Action);
+            resp->params.ldocfg.PMSource =
+                wlan_le16_to_cpu(resp->params.ldocfg.PMSource);
+            memmove(Adapter->CurCmd->pdata_buf, &resp->params.ldocfg,
+                    sizeof(HostCmd_DS_802_11_LDO_CONFIG));
+            break;
+
+        case HostCmd_RET_VERSION_EXT:
+            memcpy(Adapter->CurCmd->pdata_buf,
+                   &resp->params.verext, sizeof(HostCmd_DS_VERSION_EXT));
+            break;
+
+        default:
+            PRINTM(INFO, "CMD_RESP: Unknown command response %#x\n",
+                   resp->Command);
+            break;
+        }
+    }
+
+    if (Adapter->CurCmd) {
+        /* Clean up and Put current command back to CmdFreeQ */
+        CleanupAndInsertCmd(priv, Adapter->CurCmd);
+        spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+        Adapter->CurCmd = NULL;
+        spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+    }
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+#if WIRELESS_EXT >= 18
+/** 
+ *  @brief This function sends mic error event to application.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @para event    MIC ERROR EVENT. 
+ *  @return 	   n/a
+ */
+void
+send_mic_error_event(wlan_private * priv, u32 event)
+{
+    union iwreq_data iwrq;
+    struct iw_michaelmicfailure mic;
+
+    ENTER();
+
+    memset(&iwrq, 0, sizeof(iwrq));
+    memset(&mic, 0, sizeof(mic));
+    if (event == MACREG_INT_CODE_MIC_ERR_UNICAST) {
+        mic.flags = IW_MICFAILURE_PAIRWISE;
+    } else {
+        mic.flags = IW_MICFAILURE_GROUP;
+    }
+
+    iwrq.data.pointer = &mic;
+    iwrq.data.length = sizeof(mic);
+
+    wireless_send_event(priv->wlan_dev.netdev, IWEVMICHAELMICFAILURE, &iwrq,
+                        (u8 *) & mic);
+
+    LEAVE();
+    return;
+}
+#endif
+
+/** 
+ *  @brief This function handles events generated by firmware
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_process_event(wlan_private * priv)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+    u32 eventcause = Adapter->EventCause >> SBI_EVENT_CAUSE_SHIFT;
+
+    ENTER();
+
+    /* Save the last event to debug log */
+    Adapter->dbg.LastEventIndex =
+        (Adapter->dbg.LastEventIndex + 1) % DBG_CMD_NUM;
+    Adapter->dbg.LastEvent[Adapter->dbg.LastEventIndex] = eventcause;
+
+    if (eventcause != MACREG_INT_CODE_PS_SLEEP &&
+        eventcause != MACREG_INT_CODE_PS_AWAKE)
+        PRINTM(EVENT, "EVENT: 0x%x @ %lu\n", eventcause, os_time_get());
+
+    switch (eventcause) {
+    case MACREG_INT_CODE_DUMMY_HOST_WAKEUP_SIGNAL:
+        PRINTM(INFO, "EVENT: DUMMY_HOST_WAKEUP_SIGNAL\n");
+        if (!priv->adapter->HS_Activated) {
+            PRINTM(WARN, "DUMMY_HOST_WAKEUP_SIGNAL (HS_Deactivated)\n");
+        } else {
+            wlan_host_sleep_gpio_int_event(priv);
+        }
+        break;
+    case MACREG_INT_CODE_LINK_SENSED:
+        PRINTM(INFO, "EVENT: LINK_SENSED\n");
+        Adapter->AdhocLinkSensed = TRUE;
+        os_carrier_on(priv);
+        os_start_queue(priv);
+        wmm_start_queue(priv);
+        send_iwevcustom_event(priv, CUS_EVT_ADHOC_LINK_SENSED);
+        break;
+
+    case MACREG_INT_CODE_DEAUTHENTICATED:
+        PRINTM(INFO, "EVENT: Deauthenticated\n");
+        Adapter->dbg.num_event_deauth++;
+        HandleDisconnectEvent(priv);
+        break;
+
+    case MACREG_INT_CODE_DISASSOCIATED:
+        PRINTM(INFO, "EVENT: Disassociated\n");
+        Adapter->dbg.num_event_disassoc++;
+        HandleDisconnectEvent(priv);
+        break;
+
+    case MACREG_INT_CODE_LINK_LOST:
+        PRINTM(INFO, "EVENT: Link lost\n");
+        Adapter->dbg.num_event_link_lost++;
+        HandleDisconnectEvent(priv);
+        break;
+
+    case MACREG_INT_CODE_PS_SLEEP:
+        PRINTM(INFO, "EVENT: SLEEP\n");
+        PRINTM(EVENT, "_");
+
+        /* handle unexpected PS SLEEP event */
+        if (Adapter->PSState == PS_STATE_FULL_POWER) {
+            PRINTM(INFO, "EVENT: In FULL POWER mode - ignore PS SLEEP\n");
+            break;
+        }
+        Adapter->PSState = PS_STATE_PRE_SLEEP;
+        PSConfirmSleep(priv, (u16) Adapter->PSMode);
+        break;
+
+    case MACREG_INT_CODE_PS_AWAKE:
+        PRINTM(INFO, "EVENT: AWAKE \n");
+        PRINTM(EVENT, "|");
+
+        /* handle unexpected PS AWAKE event */
+        if (Adapter->PSState == PS_STATE_FULL_POWER) {
+            PRINTM(INFO, "EVENT: In FULL POWER mode - ignore PS AWAKE\n");
+            break;
+        }
+
+        Adapter->TxLockFlag = FALSE;
+        if (TRUE == CheckLastPacketIndication(priv)) {
+            if (!priv->wlan_dev.dnld_sent && Adapter->gen_null_pkg) {
+                SendNullPacket(priv, MRVDRV_TxPD_POWER_MGMT_NULL_PACKET |
+                               MRVDRV_TxPD_POWER_MGMT_LAST_PACKET);
+                Adapter->TxLockFlag = TRUE;
+            }
+        }
+
+        Adapter->PSState = PS_STATE_AWAKE;
+
+        if (Adapter->NeedToWakeup == TRUE) {
+            /*
+             * wait for the command processing to finish
+             * before resuming sending 
+             * Adapter->NeedToWakeup will be set to FALSE 
+             * in PSWakup()
+             */
+            PRINTM(INFO, "Waking up...\n");
+            PSWakeup(priv, 0);
+        }
+        break;
+
+    case MACREG_INT_CODE_DEEP_SLEEP_AWAKE:
+        sbi_reset_deepsleep_wakeup(priv);
+        PRINTM(INFO, "EVENT: DS_AWAKE\n");
+        if (priv->adapter->IsDeepSleep == TRUE) {
+            Adapter->IsDeepSleep = FALSE;
+            Adapter->bWakeupDevRequired = FALSE;
+            Adapter->WakeupTries = 0;
+
+            /* 
+             * For auto DS + BGS case, some delay is needed to 
+             * avoid going back to DS before getting BGS result
+             */
+            if (Adapter->IsAutoDeepSleepEnabled &&
+                Adapter->bgScanConfig->Enable)
+                os_sched_timeout(10);
+            priv->wlan_dev.dnld_sent = DNLD_RES_RECEIVED;
+            priv->adapter->HisRegCpy |= HIS_TxDnLdRdy;
+        }
+        send_iwevcustom_event(priv, CUS_EVT_DEEP_SLEEP_AWAKE);
+        wake_up_interruptible(&Adapter->ds_awake_q);
+        break;
+
+    case MACREG_INT_CODE_HOST_SLEEP_AWAKE:
+        PRINTM(INFO, "EVENT: HS_AWAKE\n");
+        Adapter->bWakeupDevRequired = FALSE;
+
+        Adapter->WakeupTries = 0;
+
+        sbi_reset_deepsleep_wakeup(priv);
+
+        /*
+         * in BG SCAN mode w/ deep sleep, WAKE UP event
+         * will be sent first, Deep Sleep Awake will
+         * be sent later. 
+         */
+        if (priv->adapter->IsDeepSleep == TRUE) {
+            priv->adapter->IsDeepSleep = FALSE;
+            priv->wlan_dev.dnld_sent = DNLD_RES_RECEIVED;
+            priv->adapter->HisRegCpy |= HIS_TxDnLdRdy;
+        }
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_802_11_WAKEUP_CONFIRM,
+                                    0, 0, 0, NULL);
+        break;
+
+    case MACREG_INT_CODE_MIC_ERR_UNICAST:
+        PRINTM(INFO, "EVENT: UNICAST MIC ERROR\n");
+#if WIRELESS_EXT >= 18
+        send_mic_error_event(priv, MACREG_INT_CODE_MIC_ERR_UNICAST);
+#else
+        send_iwevcustom_event(priv, CUS_EVT_MLME_MIC_ERR_UNI);
+#endif
+        break;
+
+    case MACREG_INT_CODE_MIC_ERR_MULTICAST:
+        PRINTM(INFO, "EVENT: MULTICAST MIC ERROR\n");
+#if WIRELESS_EXT >= 18
+        send_mic_error_event(priv, MACREG_INT_CODE_MIC_ERR_MULTICAST);
+#else
+        send_iwevcustom_event(priv, CUS_EVT_MLME_MIC_ERR_MUL);
+#endif
+        break;
+    case MACREG_INT_CODE_MIB_CHANGED:
+    case MACREG_INT_CODE_INIT_DONE:
+        break;
+
+    case MACREG_INT_CODE_ADHOC_BCN_LOST:
+        PRINTM(INFO, "EVENT: ADHOC_BCN_LOST\n");
+        Adapter->AdhocLinkSensed = FALSE;
+        wlan_clean_txrx(priv);
+        send_iwevcustom_event(priv, CUS_EVT_ADHOC_BCN_LOST);
+        break;
+
+    case MACREG_INT_CODE_BG_SCAN_REPORT:
+        PRINTM(INFO, "EVENT: BGS_REPORT\n");
+        Adapter->bgScanConfig->Enable = FALSE;
+        ret = sendBgScanQueryCmd(priv);
+        break;
+    case MACREG_INT_CODE_WMM_STATUS_CHANGE:
+        PRINTM(INFO, "EVENT: WMM status changed\n");
+        ret = sendWMMStatusChangeCmd(priv);
+        break;
+
+    case MACREG_INT_CODE_RSSI_LOW:
+        PRINTM(INFO, "EVENT: RSSI_LOW\n");
+        send_iwevcustom_event(priv, CUS_EVT_BEACON_RSSI_LOW);
+        break;
+    case MACREG_INT_CODE_SNR_LOW:
+        PRINTM(INFO, "EVENT: SNR_LOW\n");
+        send_iwevcustom_event(priv, CUS_EVT_BEACON_SNR_LOW);
+        break;
+    case MACREG_INT_CODE_MAX_FAIL:
+        PRINTM(INFO, "EVENT: MAX_FAIL\n");
+        send_iwevcustom_event(priv, CUS_EVT_MAX_FAIL);
+        break;
+    case MACREG_INT_CODE_RSSI_HIGH:
+        PRINTM(INFO, "EVENT: RSSI_HIGH\n");
+        send_iwevcustom_event(priv, CUS_EVT_BEACON_RSSI_HIGH);
+        break;
+    case MACREG_INT_CODE_SNR_HIGH:
+        PRINTM(INFO, "EVENT: SNR_HIGH\n");
+        send_iwevcustom_event(priv, CUS_EVT_BEACON_SNR_HIGH);
+        break;
+    case MACREG_INT_CODE_PRE_BEACON_LOST:
+        PRINTM(INFO, "EVENT: Pre-Beacon Lost\n");
+        send_iwevcustom_event(priv, CUS_EVT_PRE_BEACON_LOST);
+        break;
+    case MACREG_INT_CODE_IBSS_COALESCED:
+        PRINTM(INFO, "EVENT: IBSS_COALESCED\n");
+        ret = sendADHOCBSSIDQuery(priv);
+        break;
+    default:
+        PRINTM(INFO, "EVENT: unknown event id: %#x\n", eventcause);
+        break;
+    }
+
+    Adapter->EventCause = 0;
+    LEAVE();
+    return ret;
+}
Index: linux-2.6.29/drivers/net/wireless/marvell8686/wlan_debug.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/wlan_debug.c	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,281 @@
+/** @file wlan_debug.c
+  * @brief This file contains functions for debug proc file.
+  * 
+  *  Copyright  Marvell International Ltd. and/or its affiliates, 2003-2007
+  */
+/********************************************************
+Change log:
+	10/04/05: Add Doxygen format comments
+	01/05/06: Add kernel 2.6.x support	
+	
+********************************************************/
+
+#include  "include.h"
+
+#ifdef CONFIG_MARVELL_8686_PROC_FS
+/********************************************************
+		Local Variables
+********************************************************/
+
+#define item_size(n) (sizeof ((wlan_adapter *)0)->n)
+#define item_addr(n) ((u32) &((wlan_adapter *)0)->n)
+
+#define item_dbg_size(n) (sizeof (((wlan_adapter *)0)->dbg.n))
+#define item_dbg_addr(n) ((u32) &(((wlan_adapter *)0)->dbg.n))
+
+#define item1_size(n) (sizeof ((wlan_dev_t *)0)->n)
+#define item1_addr(n) ((u32) &((wlan_dev_t *)0)->n)
+
+struct debug_data
+{
+    char name[32];
+    u32 size;
+    u32 addr;
+    u32 offset;
+};
+
+/* To debug any member of wlan_adapter or wlan_dev_t, simply add one line here.
+ */
+#define ITEMS_FROM_WLAN_DEV		1
+
+static struct debug_data items[] = {
+    {"IntCounter", item_size(IntCounter), 0, item_addr(IntCounter)},
+    {"ConnectStatus", item_size(MediaConnectStatus), 0,
+     item_addr(MediaConnectStatus)},
+    {"wmmQStp", item_size(wmm.queueStopped), 0, item_addr(wmm.queueStopped)},
+    {"wmmPkts", item_size(wmm.packetsQueued), 0,
+     item_addr(wmm.packetsQueued)},
+    {"wmmAcVo", item_size(wmm.packetsOut[WMM_AC_VO]), 0,
+     item_addr(wmm.packetsOut[WMM_AC_VO])},
+    {"wmmAcVi", item_size(wmm.packetsOut[WMM_AC_VI]), 0,
+     item_addr(wmm.packetsOut[WMM_AC_VI])},
+    {"wmmAcBE", item_size(wmm.packetsOut[WMM_AC_BE]), 0,
+     item_addr(wmm.packetsOut[WMM_AC_BE])},
+    {"wmmAcBK", item_size(wmm.packetsOut[WMM_AC_BK]), 0,
+     item_addr(wmm.packetsOut[WMM_AC_BK])},
+    {"PSMode", item_size(PSMode), 0, item_addr(PSMode)},
+    {"PSState", item_size(PSState), 0, item_addr(PSState)},
+    {"IsDeepSleep", item_size(IsDeepSleep), 0, item_addr(IsDeepSleep)},
+    {"IsAutoDeepSleepEnabled", item_size(IsAutoDeepSleepEnabled), 0,
+     item_addr(IsAutoDeepSleepEnabled)},
+    {"WakeupDevReq", item_size(bWakeupDevRequired), 0,
+     item_addr(bWakeupDevRequired)},
+    {"WakeupTries", item_size(WakeupTries), 0, item_addr(WakeupTries)},
+    {"HS_Configured", item_size(bHostSleepConfigured), 0,
+     item_addr(bHostSleepConfigured)},
+    {"HS_Activated", item_size(HS_Activated), 0, item_addr(HS_Activated)},
+    {"num_tx_timeout", item_dbg_size(num_tx_timeout), 0,
+     item_dbg_addr(num_tx_timeout)},
+    {"num_cmd_timeout", item_dbg_size(num_cmd_timeout), 0,
+     item_dbg_addr(num_cmd_timeout)},
+    {"TimeoutCmdId", item_dbg_size(TimeoutCmdId), 0,
+     item_dbg_addr(TimeoutCmdId)},
+    {"TimeoutCmdAct", item_dbg_size(TimeoutCmdAct), 0,
+     item_dbg_addr(TimeoutCmdAct)},
+    {"LastCmdId", item_dbg_size(LastCmdId), 0, item_dbg_addr(LastCmdId)},
+    {"LastCmdAct", item_dbg_size(LastCmdAct), 0, item_dbg_addr(LastCmdAct)},
+    {"LastCmdIndex", item_dbg_size(LastCmdIndex), 0,
+     item_dbg_addr(LastCmdIndex)},
+    {"LastCmdRespId", item_dbg_size(LastCmdRespId), 0,
+     item_dbg_addr(LastCmdRespId)},
+    {"LastCmdRespIndex", item_dbg_size(LastCmdRespIndex), 0,
+     item_dbg_addr(LastCmdRespIndex)},
+    {"LastEvent", item_dbg_size(LastEvent), 0, item_dbg_addr(LastEvent)},
+    {"LastEventIndex", item_dbg_size(LastEventIndex), 0,
+     item_dbg_addr(LastEventIndex)},
+    {"num_cmd_h2c_fail", item_dbg_size(num_cmd_host_to_card_failure), 0,
+     item_dbg_addr(num_cmd_host_to_card_failure)},
+    {"num_cmd_sleep_cfm_fail",
+     item_dbg_size(num_cmd_sleep_cfm_host_to_card_failure), 0,
+     item_dbg_addr(num_cmd_sleep_cfm_host_to_card_failure)},
+    {"num_tx_h2c_fail", item_dbg_size(num_tx_host_to_card_failure), 0,
+     item_dbg_addr(num_tx_host_to_card_failure)},
+    {"num_evt_deauth", item_dbg_size(num_event_deauth), 0,
+     item_dbg_addr(num_event_deauth)},
+    {"num_evt_disassoc", item_dbg_size(num_event_disassoc), 0,
+     item_dbg_addr(num_event_disassoc)},
+    {"num_evt_link_lost", item_dbg_size(num_event_link_lost), 0,
+     item_dbg_addr(num_event_link_lost)},
+    {"num_cmd_deauth", item_dbg_size(num_cmd_deauth), 0,
+     item_dbg_addr(num_cmd_deauth)},
+    {"num_cmd_assoc_ok", item_dbg_size(num_cmd_assoc_success), 0,
+     item_dbg_addr(num_cmd_assoc_success)},
+    {"num_cmd_assoc_fail", item_dbg_size(num_cmd_assoc_failure), 0,
+     item_dbg_addr(num_cmd_assoc_failure)},
+
+    {"dnld_sent", item1_size(dnld_sent), 0, item1_addr(dnld_sent)},
+};
+
+static int num_of_items = sizeof(items) / sizeof(items[0]);
+
+/********************************************************
+		Global Variables
+********************************************************/
+
+/********************************************************
+		Local Functions
+********************************************************/
+/** 
+ *  @brief proc read function
+ *
+ *  @param page	   pointer to buffer
+ *  @param s       read data starting position
+ *  @param off     offset
+ *  @param cnt     counter 
+ *  @param eof     end of file flag
+ *  @param data    data to output
+ *  @return 	   number of output data
+ */
+static int
+wlan_debug_read(char *page, char **s, off_t off, int cnt, int *eof,
+                void *data)
+{
+    int val = 0;
+    char *p = page;
+    int i;
+
+    struct debug_data *d = (struct debug_data *) data;
+
+    MODULE_GET;
+
+    for (i = 0; i < num_of_items; i++) {
+        if (d[i].size == 1)
+            val = *((u8 *) d[i].addr);
+        else if (d[i].size == 2)
+            val = *((u16 *) d[i].addr);
+        else if (d[i].size == 4)
+            val = *((u32 *) d[i].addr);
+        else {
+            int j;
+            p += sprintf(p, "%s=", d[i].name);
+            for (j = 0; j < d[i].size; j += 2) {
+                val = *(u16 *) (d[i].addr + j);
+                p += sprintf(p, "0x%x ", val);
+            }
+            p += sprintf(p, "\n");
+            continue;
+        }
+
+        if (strstr(d[i].name, "Id"))
+            p += sprintf(p, "%s=0x%x\n", d[i].name, val);
+        else
+            p += sprintf(p, "%s=%d\n", d[i].name, val);
+    }
+    MODULE_PUT;
+    return p - page;
+}
+
+/** 
+ *  @brief proc write function
+ *
+ *  @param f	   file pointer
+ *  @param buf     pointer to data buffer
+ *  @param cnt     data number to write
+ *  @param data    data to write
+ *  @return 	   number of data
+ */
+static int
+wlan_debug_write(struct file *f, const char *buf, unsigned long cnt,
+                 void *data)
+{
+    int r, i;
+    char *pdata;
+    char *p;
+    char *p0;
+    char *p1;
+    char *p2;
+    struct debug_data *d = (struct debug_data *) data;
+
+    MODULE_GET;
+
+    pdata = (char *) kmalloc(cnt, GFP_KERNEL);
+    if (pdata == NULL) {
+        MODULE_PUT;
+        return 0;
+    }
+
+    if (copy_from_user(pdata, buf, cnt)) {
+        PRINTM(INFO, "Copy from user failed\n");
+        kfree(pdata);
+        MODULE_PUT;
+        return 0;
+    }
+
+    p0 = pdata;
+    for (i = 0; i < num_of_items; i++) {
+        do {
+            p = strstr(p0, d[i].name);
+            if (p == NULL)
+                break;
+            p1 = strchr(p, '\n');
+            if (p1 == NULL)
+                break;
+            p0 = p1++;
+            p2 = strchr(p, '=');
+            if (!p2)
+                break;
+            p2++;
+            r = string_to_number(p2);
+            if (d[i].size == 1)
+                *((u8 *) d[i].addr) = (u8) r;
+            else if (d[i].size == 2)
+                *((u16 *) d[i].addr) = (u16) r;
+            else if (d[i].size == 4)
+                *((u32 *) d[i].addr) = (u32) r;
+            break;
+        } while (TRUE);
+    }
+    kfree(pdata);
+    MODULE_PUT;
+    return cnt;
+}
+
+/********************************************************
+		Global Functions
+********************************************************/
+/** 
+ *  @brief create debug proc file
+ *
+ *  @param priv	   pointer wlan_private
+ *  @param dev     pointer net_device
+ *  @return 	   N/A
+ */
+void
+wlan_debug_entry(wlan_private * priv, struct net_device *dev)
+{
+    int i;
+    struct proc_dir_entry *r;
+
+    if (priv->proc_entry == NULL)
+        return;
+
+    for (i = 0; i < (num_of_items - ITEMS_FROM_WLAN_DEV); i++) {
+        items[i].addr = items[i].offset + (u32) priv->adapter;
+    }
+    for (i = num_of_items - ITEMS_FROM_WLAN_DEV; i < num_of_items; i++) {
+        items[i].addr = items[i].offset + (u32) & priv->wlan_dev;
+    }
+    r = create_proc_entry("debug", 0644, priv->proc_entry);
+    if (r == NULL)
+        return;
+
+    r->data = &items[0];
+    r->read_proc = wlan_debug_read;
+    r->write_proc = wlan_debug_write;
+    r->owner = THIS_MODULE;
+
+}
+
+/** 
+ *  @brief remove proc file
+ *
+ *  @param priv	   pointer wlan_private
+ *  @return 	   N/A
+ */
+void
+wlan_debug_remove(wlan_private * priv)
+{
+    remove_proc_entry("debug", priv->proc_entry);
+}
+
+#endif
Index: linux-2.6.29/drivers/net/wireless/marvell8686/wlan_decl.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/wlan_decl.h	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,109 @@
+/** @file wlan_decl.h
+ *  @brief This file contains declaration referring to
+ *  functions defined in other source files
+ *
+ *  Copyright  Marvell International Ltd. and/or its affiliates, 2003-2007
+ */
+/******************************************************
+Change log:
+	09/29/05: add Doxygen format comments
+	01/05/06: Add kernel 2.6.x support	
+	01/11/06: Conditionalize new scan/join structures.
+	          Move wlan_wext statics to their source file.
+******************************************************/
+
+#ifndef _WLAN_DECL_H_
+#define _WLAN_DECL_H_
+
+/** Function Prototype Declaration */
+int wlan_init_fw(wlan_private * priv);
+int wlan_tx_packet(wlan_private * priv, struct sk_buff *skb);
+void wlan_free_adapter(wlan_private * priv);
+
+int SendNullPacket(wlan_private * priv, u8 flags);
+BOOLEAN CheckLastPacketIndication(wlan_private * priv);
+
+void Wep_encrypt(wlan_private * priv, u8 * Buf, u32 Len);
+int FreeCmdBuffer(wlan_private * priv);
+void CleanUpCmdCtrlNode(CmdCtrlNode * pTempNode);
+CmdCtrlNode *GetFreeCmdCtrlNode(wlan_private * priv);
+
+void SetCmdCtrlNode(wlan_private * priv,
+                    CmdCtrlNode * pTempNode,
+                    WLAN_OID cmd_oid, u16 wait_option, void *pdata_buf);
+
+BOOLEAN Is_Command_Allowed(wlan_private * priv);
+
+int PrepareAndSendCommand(wlan_private * priv,
+                          u16 cmd_no,
+                          u16 cmd_action,
+                          u16 wait_option, WLAN_OID cmd_oid, void *pdata_buf);
+
+void QueueCmd(wlan_adapter * Adapter, CmdCtrlNode * CmdNode, BOOLEAN addtail);
+
+int SetDeepSleep(wlan_private * priv, BOOLEAN bDeepSleep);
+int AllocateCmdBuffer(wlan_private * priv);
+int ExecuteNextCommand(wlan_private * priv);
+int wlan_process_event(wlan_private * priv);
+void wlan_interrupt(struct net_device *);
+u32 index_to_data_rate(u8 index);
+u8 data_rate_to_index(u32 rate);
+void HexDump(char *prompt, u8 * data, int len);
+void get_version(wlan_adapter * adapter, char *version, int maxlen);
+void wlan_read_write_rfreg(wlan_private * priv);
+
+#ifdef CONFIG_MARVELL_8686_PROC_FS
+/** The proc fs interface */
+void wlan_proc_entry(wlan_private * priv, struct net_device *dev);
+void wlan_proc_remove(wlan_private * priv);
+int string_to_number(char *s);
+#ifdef CONFIG_MARVELL_8686_DEBUG
+void wlan_debug_entry(wlan_private * priv, struct net_device *dev);
+void wlan_debug_remove(wlan_private * priv);
+#endif
+#endif
+int wlan_process_rx_command(wlan_private * priv);
+void wlan_process_tx(wlan_private * priv);
+void CleanupAndInsertCmd(wlan_private * priv, CmdCtrlNode * pTempCmd);
+void MrvDrvCommandTimerFunction(void *FunctionContext);
+
+#ifdef REASSOCIATION
+void MrvDrvReassocTimerFunction(void *FunctionContext);
+#endif /* REASSOCIATION */
+
+int wlan_set_essid(struct net_device *dev, struct iw_request_info *info,
+                   struct iw_point *dwrq, char *extra);
+int wlan_set_regiontable(wlan_private * priv, u8 region, u8 band);
+
+void wlan_clean_txrx(wlan_private * priv);
+
+int wlan_host_sleep_activated_event(wlan_private * priv);
+int wlan_host_sleep_deactivated_event(wlan_private * priv);
+int wlan_host_sleep_gpio_int_event(wlan_private * priv);
+int wlan_deep_sleep_ioctl(wlan_private * priv, struct ifreq *rq);
+
+int ProcessRxedPacket(wlan_private * priv, struct sk_buff *);
+
+void PSSleep(wlan_private * priv, int wait_option);
+void PSConfirmSleep(wlan_private * priv, u16 PSMode);
+void PSWakeup(wlan_private * priv, int wait_option);
+
+void wlan_send_rxskbQ(wlan_private * priv);
+
+extern CHANNEL_FREQ_POWER *find_cfp_by_band_and_channel(wlan_adapter *
+                                                        adapter, u8 band,
+                                                        u16 channel);
+extern CHANNEL_FREQ_POWER *get_cfp_by_band_and_channel(u8 band, u16 channel,
+                                                       REGION_CHANNEL *
+                                                       region_channnel);
+
+extern void MacEventDisconnected(wlan_private * priv);
+
+#if WIRELESS_EXT > 14
+void send_iwevcustom_event(wlan_private * priv, s8 * str);
+#endif
+
+int fw_read(const char *name, u8 ** addr, u32 * len);
+void fw_buffer_free(u8 * addr);
+
+#endif /* _WLAN_DECL_H_ */
Index: linux-2.6.29/drivers/net/wireless/marvell8686/wlan_defs.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/wlan_defs.h	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,623 @@
+/** @file wlan_defs.h
+ *  @brief This header file contains global constant/enum definitions,
+ *  global variable declaration.
+ *
+ *  Copyright  Marvell International Ltd. and/or its affiliates, 2003-2007
+ */
+/*************************************************************
+Change log:
+	10/11/05: add Doxygen format comments 
+	01/11/06: Add NELEMENTS, BAND_XX defines
+	04/10/06: Add hostcmd generic API and power_adapt_cfg_ext command
+************************************************************/
+
+#ifndef _WLAN_DEFS_H_
+#define _WLAN_DEFS_H_
+
+#include	"os_defs.h"
+
+/** Double-Word(32Bit) Bit definition */
+#define DW_BIT_0	0x00000001
+#define DW_BIT_1	0x00000002
+#define DW_BIT_2	0x00000004
+#define DW_BIT_3	0x00000008
+#define DW_BIT_4	0x00000010
+#define DW_BIT_5	0x00000020
+#define DW_BIT_6	0x00000040
+#define DW_BIT_7	0x00000080
+#define DW_BIT_8	0x00000100
+#define DW_BIT_9	0x00000200
+#define DW_BIT_10	0x00000400
+#define DW_BIT_11       0x00000800
+#define DW_BIT_12       0x00001000
+#define DW_BIT_13       0x00002000
+#define DW_BIT_14       0x00004000
+#define DW_BIT_15       0x00008000
+#define DW_BIT_16       0x00010000
+#define DW_BIT_17       0x00020000
+#define DW_BIT_18       0x00040000
+#define DW_BIT_19       0x00080000
+#define DW_BIT_20       0x00100000
+#define DW_BIT_21       0x00200000
+#define DW_BIT_22       0x00400000
+#define DW_BIT_23       0x00800000
+#define DW_BIT_24       0x01000000
+#define DW_BIT_25       0x02000000
+#define DW_BIT_26       0x04000000
+#define DW_BIT_27       0x08000000
+#define DW_BIT_28       0x10000000
+#define DW_BIT_29       0x20000000
+#define DW_BIT_30	0x40000000
+#define DW_BIT_31	0x80000000
+
+/** Word (16bit) Bit Definition*/
+#define W_BIT_0		0x0001
+#define W_BIT_1		0x0002
+#define W_BIT_2		0x0004
+#define W_BIT_3		0x0008
+#define W_BIT_4		0x0010
+#define W_BIT_5		0x0020
+#define W_BIT_6		0x0040
+#define W_BIT_7		0x0080
+#define W_BIT_8		0x0100
+#define W_BIT_9		0x0200
+#define W_BIT_10	0x0400
+#define W_BIT_11	0x0800
+#define W_BIT_12	0x1000
+#define W_BIT_13	0x2000
+#define W_BIT_14	0x4000
+#define W_BIT_15	0x8000
+
+/** Byte (8Bit) Bit definition*/
+#define B_BIT_0		0x01
+#define B_BIT_1		0x02
+#define B_BIT_2		0x04
+#define B_BIT_3		0x08
+#define B_BIT_4		0x10
+#define B_BIT_5		0x20
+#define B_BIT_6		0x40
+#define B_BIT_7		0x80
+
+/** Debug Macro definition*/
+#ifdef	DEBUG_LEVEL1
+
+extern u32 drvdbg;
+extern u32 ifdbg;
+
+/* Debug message control bit definition for drvdbg */
+#define	DBG_MSG		DW_BIT_0
+#define DBG_FATAL	DW_BIT_1
+#define DBG_ERROR	DW_BIT_2
+#define DBG_DATA	DW_BIT_3
+#define DBG_CMND	DW_BIT_4
+#define DBG_EVENT	DW_BIT_5
+#define DBG_INTR	DW_BIT_6
+
+#define DBG_DAT_D	DW_BIT_16
+#define DBG_CMD_D	DW_BIT_17
+#define DBG_FW_D	DW_BIT_18
+
+#define DBG_ENTRY	DW_BIT_28
+#define DBG_WARN	DW_BIT_29
+#define DBG_INFO	DW_BIT_30
+
+/* Debug message control bit definition for ifdbg */
+#define DBG_IF_D	DW_BIT_0
+
+#ifdef	DEBUG_LEVEL2
+#define	PRINTM_INFO(msg...)  {if (drvdbg & DBG_INFO) printk(KERN_DEBUG msg);}
+#define	PRINTM_WARN(msg...)  {if (drvdbg & DBG_WARN) printk(KERN_DEBUG msg);}
+#define	PRINTM_ENTRY(msg...) {if (drvdbg & DBG_ENTRY) printk(KERN_DEBUG msg);}
+#else
+#define	PRINTM_INFO(msg...)  do {} while (0)
+#define	PRINTM_WARN(msg...)  do {} while (0)
+#define	PRINTM_ENTRY(msg...) do {} while (0)
+#endif /* DEBUG_LEVEL2 */
+
+#define	PRINTM_FW_D(msg...)  {if (drvdbg & DBG_FW_D) printk(KERN_DEBUG msg);}
+#define	PRINTM_CMD_D(msg...) {if (drvdbg & DBG_CMD_D) printk(KERN_DEBUG msg);}
+#define	PRINTM_DAT_D(msg...) {if (drvdbg & DBG_DAT_D) printk(KERN_DEBUG msg);}
+
+#define	PRINTM_INTR(msg...)  {if (drvdbg & DBG_INTR) printk(KERN_DEBUG msg);}
+#define	PRINTM_EVENT(msg...) {if (drvdbg & DBG_EVENT) printk(msg);}
+#define	PRINTM_CMND(msg...)  {if (drvdbg & DBG_CMND) printk(KERN_DEBUG msg);}
+#define	PRINTM_DATA(msg...)  {if (drvdbg & DBG_DATA) printk(KERN_DEBUG msg);}
+#define	PRINTM_ERROR(msg...) {if (drvdbg & DBG_ERROR) printk(KERN_DEBUG msg);}
+#define	PRINTM_FATAL(msg...) {if (drvdbg & DBG_FATAL) printk(KERN_DEBUG msg);}
+#define	PRINTM_MSG(msg...)   {if (drvdbg & DBG_MSG) printk(KERN_ALERT msg);}
+
+#define	PRINTM_IF_D(msg...)  {if (ifdbg & DBG_IF_D) printk(KERN_DEBUG msg);}
+
+#define	PRINTM(level,msg...) PRINTM_##level(msg)
+
+#else
+
+#define	PRINTM(level,msg...) do {} while (0)
+
+#endif /* DEBUG_LEVEL1 */
+
+#define ASSERT(cond)						\
+do {								\
+	if (!(cond))						\
+		PRINTM(INFO, "ASSERT: %s, %s:%i\n",		\
+		       __FUNCTION__, __FILE__, __LINE__);	\
+} while(0)
+
+#define	ENTER()			PRINTM(ENTRY, "Enter: %s, %s:%i\n", __FUNCTION__, \
+							__FILE__, __LINE__)
+#define	LEAVE()			PRINTM(ENTRY, "Leave: %s, %s:%i\n", __FUNCTION__, \
+							__FILE__, __LINE__)
+
+#if defined(DEBUG_LEVEL1) && defined(__KERNEL__)
+#define DBG_DUMP_BUF_LEN 	64
+#define MAX_DUMP_PER_LINE	16
+#define MAX_DATA_DUMP_LEN	48
+
+static inline void
+hexdump(char *prompt, u8 * buf, int len)
+{
+    int i;
+    char dbgdumpbuf[DBG_DUMP_BUF_LEN];
+    char *ptr = dbgdumpbuf;
+
+    printk(KERN_DEBUG "%s:\n", prompt);
+    for (i = 1; i <= len; i++) {
+        ptr += sprintf(ptr, "%02x ", *buf);
+        buf++;
+        if (i % MAX_DUMP_PER_LINE == 0) {
+            *ptr = 0;
+            printk(KERN_DEBUG "%s\n", dbgdumpbuf);
+            ptr = dbgdumpbuf;
+        }
+    }
+    if (len % MAX_DUMP_PER_LINE) {
+        *ptr = 0;
+        printk(KERN_DEBUG "%s\n", dbgdumpbuf);
+    }
+}
+
+#define DBG_HEXDUMP_CMD_D(x,y,z)    {if (drvdbg & DBG_CMD_D) hexdump(x,y,z);}
+#define DBG_HEXDUMP_DAT_D(x,y,z)    {if (drvdbg & DBG_DAT_D) hexdump(x,y,z);}
+#define DBG_HEXDUMP_IF_D(x,y,z)     {if (ifdbg & DBG_IF_D) hexdump(x,y,z);}
+#define DBG_HEXDUMP_FW_D(x,y,z)     {if (drvdbg & DBG_FW_D) hexdump(x,y,z);}
+
+#define	DBG_HEXDUMP(level,x,y,z)    DBG_HEXDUMP_##level(x,y,z)
+
+#else
+#define DBG_HEXDUMP(level,x,y,z)    do {} while (0)
+#endif
+
+#if defined(DEBUG_LEVEL2) && defined(__KERNEL__)
+#define HEXDUMP(x,y,z)              {if (drvdbg & DBG_INFO) hexdump(x,y,z);}
+#else
+#define HEXDUMP(x,y,z)              do {} while (0)
+#endif
+
+#ifndef	TRUE
+#define TRUE			1
+#endif
+#ifndef	FALSE
+#define	FALSE			0
+#endif
+
+#ifndef MIN
+#define MIN(a,b)		((a) < (b) ? (a) : (b))
+#endif
+
+#ifndef MAX
+#define MAX(a,b)		((a) > (b) ? (a) : (b))
+#endif
+
+#ifndef NELEMENTS
+#define NELEMENTS(x) (sizeof(x)/sizeof(x[0]))
+#endif
+
+/** Buffer Constants */
+
+/*	The size of SQ memory PPA, DPA are 8 DWORDs, that keep the physical
+*	addresses of TxPD buffers. Station has only 8 TxPD available, Whereas
+*	driver has more local TxPDs. Each TxPD on the host memory is associated 
+*	with a Tx control node. The driver maintains 8 RxPD descriptors for 
+*	station firmware to store Rx packet information.
+*
+*	Current version of MAC has a 32x6 multicast address buffer.
+*
+*	802.11b can have up to  14 channels, the driver keeps the
+*	BSSID(MAC address) of each APs or Ad hoc stations it has sensed.
+*/
+
+#define MRVDRV_SIZE_OF_PPA		0x00000008
+#define MRVDRV_SIZE_OF_DPA		0x00000008
+#define MRVDRV_NUM_OF_TxPD		0x00000020
+#define MRVDRV_NUM_OF_CMD_BUFFER        10
+#define MRVDRV_SIZE_OF_CMD_BUFFER       (2 * 1024)
+#define MRVDRV_MAX_BSSID_LIST		64
+#define MRVDRV_TIMER_10S		10000
+#define MRVDRV_TIMER_5S			5000
+#define MRVDRV_TIMER_1S			1000
+#define MRVDRV_SNAP_HEADER_LEN          8
+#define MRVDRV_ETH_HEADER_SIZE          14
+
+#define ARP_FILTER_MAX_BUF_SIZE		68
+
+#define	WLAN_UPLD_SIZE			2312
+#define DEV_NAME_LEN			32
+
+#ifndef	ETH_ALEN
+#define ETH_ALEN			6
+#endif
+
+/** Misc constants */
+/* This section defines 802.11 specific contants */
+#define SDIO_HEADER_LEN		4
+
+#define MRVDRV_MAX_REGION_CODE			6
+#define MRVDRV_IGNORE_MULTIPLE_DTIM		0xfffe
+#define MRVDRV_MIN_MULTIPLE_DTIM		1
+#define MRVDRV_MAX_MULTIPLE_DTIM		5
+#define MRVDRV_DEFAULT_MULTIPLE_DTIM		1
+
+#define MRVDRV_DEFAULT_LISTEN_INTERVAL		10
+#define MRVDRV_DEFAULT_LOCAL_LISTEN_INTERVAL		0
+
+#define	MRVDRV_CHANNELS_PER_ACTIVE_SCAN		14
+#define MRVDRV_MIN_BEACON_INTERVAL		20
+#define MRVDRV_MAX_BEACON_INTERVAL		1000
+#define MRVDRV_BEACON_INTERVAL			100
+
+#define MRVDRV_DEFAULT_WATCHDOG_TIMEOUT (5 * HZ)
+#define MRVDRV_SCAN_WATCHDOG_TIMEOUT    (10 * HZ)
+#define MRVDRV_DEEP_SLEEP_EXIT_TIMEOUT  (10 * HZ)
+
+/** TxPD Status */
+
+/*	Station firmware use TxPD status field to report final Tx transmit
+*	result, Bit masks are used to present combined situations.
+*/
+
+#define MRVDRV_TxPD_POWER_MGMT_NULL_PACKET 0x01
+#define MRVDRV_TxPD_POWER_MGMT_LAST_PACKET 0x08
+
+/** Tx control node status */
+
+#define MRVDRV_TX_CTRL_NODE_STATUS_IDLE      0x0000
+
+/* Link spped */
+#define MRVDRV_LINK_SPEED_1mbps          10000  /* in unit of 100bps */
+#define MRVDRV_LINK_SPEED_11mbps         110000
+
+/** RSSI-related defines */
+/*	RSSI constants are used to implement 802.11 RSSI threshold 
+*	indication. if the Rx packet signal got too weak for 5 consecutive
+*	times, miniport driver (driver) will report this event to wrapper
+*/
+
+#define MRVDRV_NF_DEFAULT_SCAN_VALUE		(-96)
+
+/** RTS/FRAG related defines */
+#define MRVDRV_RTS_MIN_VALUE		0
+#define MRVDRV_RTS_MAX_VALUE		2347
+#define MRVDRV_FRAG_MIN_VALUE		256
+#define MRVDRV_FRAG_MAX_VALUE		2346
+
+/* Fixed IE size is 8 bytes time stamp + 2 bytes beacon interval +
+ * 2 bytes cap */
+#define MRVL_FIXED_IE_SIZE      12
+
+/* This is for firmware specific length */
+#define EXTRA_LEN	36
+#define MRVDRV_MAXIMUM_ETH_PACKET_SIZE	1514
+
+#define MRVDRV_ETH_TX_PACKET_BUFFER_SIZE \
+	(MRVDRV_MAXIMUM_ETH_PACKET_SIZE + sizeof(TxPD) + EXTRA_LEN)
+
+#define MRVDRV_ETH_RX_PACKET_BUFFER_SIZE \
+	(MRVDRV_MAXIMUM_ETH_PACKET_SIZE + sizeof(RxPD) \
+	 + MRVDRV_SNAP_HEADER_LEN + EXTRA_LEN)
+
+#define	CMD_F_HOSTCMD		(1 << 0)
+
+/* to resolve CISCO AP extension */
+#define MRVDRV_SCAN_LIST_VAR_IE_SPACE  	256
+#define FW_IS_WPA_ENABLED(_adapter) \
+		(_adapter->fwCapInfo & FW_CAPINFO_WPA)
+
+#define FW_CAPINFO_WPA  	(1 << 0)
+#define WLAN_802_11_AI_REQFI_CAPABILITIES 	1
+#define WLAN_802_11_AI_REQFI_LISTENINTERVAL 	2
+#define WLAN_802_11_AI_REQFI_CURRENTAPADDRESS 	4
+
+#define WLAN_802_11_AI_RESFI_CAPABILITIES 	1
+#define WLAN_802_11_AI_RESFI_STATUSCODE 	2
+#define WLAN_802_11_AI_RESFI_ASSOCIATIONID 	4
+
+#define MRVL_NUM_WEP_KEY		4
+
+/** WPA Key LENGTH*/
+/* Support 4 keys per key set */
+#define MRVL_NUM_WPA_KEY_PER_SET        4
+#define MRVL_MAX_WPA_KEY_LENGTH 	32
+
+#define WPA_AES_KEY_LEN 		16
+#define WPA_TKIP_KEY_LEN 		32
+
+/* A few details needed for WEP (Wireless Equivalent Privacy) */
+/* 104 bits */
+#define MAX_WEP_KEY_SIZE	13
+/*40 bits RC4 - WEP*/
+#define MIN_WEP_KEY_SIZE	5
+
+#define RF_ANTENNA_1		0x1
+#define RF_ANTENNA_2		0x2
+#define RF_ANTENNA_AUTO		0xFFFF
+
+#define KEY_INFO_ENABLED	0x01
+
+#define SNR_BEACON		0
+#define SNR_RXPD		1
+#define NF_BEACON		2
+#define NF_RXPD			3
+
+/** MACRO DEFINITIONS */
+#define CAL_NF(NF)			((s32)(-(s32)(NF)))
+#define CAL_RSSI(SNR, NF) 		((s32)((s32)(SNR) + CAL_NF(NF)))
+#define SCAN_RSSI(RSSI)			(0x100 - ((u8)(RSSI)))
+
+#define DEFAULT_BCN_AVG_FACTOR		8
+#define DEFAULT_DATA_AVG_FACTOR		8
+#define MIN_BCN_AVG_FACTOR		1
+#define MAX_BCN_AVG_FACTOR		8
+#define MIN_DATA_AVG_FACTOR		1
+#define MAX_DATA_AVG_FACTOR		8
+#define AVG_SCALE			100
+#define CAL_AVG_SNR_NF(AVG, SNRNF, N)         \
+                        (((AVG) == 0) ? ((u16)(SNRNF) * AVG_SCALE) : \
+                        ((((int)(AVG) * (N -1)) + ((u16)(SNRNF) * \
+                        AVG_SCALE))  / N))
+
+#define WLAN_STATUS_SUCCESS			(0)
+#define WLAN_STATUS_FAILURE			(-1)
+#define WLAN_STATUS_NOT_ACCEPTED                (-2)
+
+#define	MAX_LEDS			3
+#define	LED_DISABLED			16
+#define	LED_BLINKING			2
+
+/* S_SWAP : To swap 2 u8 */
+#define S_SWAP(a,b) 	do { \
+				u8  t = SArr[a]; \
+				SArr[a] = SArr[b]; SArr[b] = t; \
+			} while(0)
+
+/* SWAP: swap u8 */
+#define SWAP_U8(a,b)	{u8 t; t=a; a=b; b=t;}
+
+/* SWAP: swap u8 */
+#define SWAP_U16(a,b)	{u16 t; t=a; a=b; b=t;}
+
+#define wlan_le16_to_cpu(x) x
+#define wlan_le32_to_cpu(x) x
+#define wlan_le64_to_cpu(x) x
+#define wlan_cpu_to_le16(x) x
+#define wlan_cpu_to_le32(x) x
+#define wlan_cpu_to_le64(x) x
+
+#define endian_convert_TxPD(x)
+#define endian_convert_RxPD(x)
+#define endian_convert_GET_LOG(x)
+
+/** Global Varibale Declaration */
+typedef struct _wlan_private wlan_private;
+typedef struct _wlan_adapter wlan_adapter;
+typedef struct _HostCmd_DS_COMMAND HostCmd_DS_COMMAND;
+
+extern u32 DSFreqList[15];
+extern const char driver_version[];
+extern u32 DSFreqList[];
+extern u16 RegionCodeToIndex[MRVDRV_MAX_REGION_CODE];
+
+extern u8 WlanDataRates[WLAN_SUPPORTED_RATES];
+
+extern u8 SupportedRates[G_SUPPORTED_RATES];
+
+extern u8 AdhocRates_G[G_SUPPORTED_RATES];
+
+extern u8 AdhocRates_B[4];
+extern wlan_private *wlanpriv;
+
+#ifdef MFG_CMD_SUPPORT
+#define SIOCCFMFG SIOCDEVPRIVATE
+#endif /* MFG_CMD_SUPPORT */
+
+#define INTMODE_SDIO	0
+#define INTMODE_GPIO	1
+extern int intmode;
+extern int gpiopin;
+
+/** ENUM definition*/
+/** SNRNF_TYPE */
+typedef enum _SNRNF_TYPE
+{
+    TYPE_BEACON = 0,
+    TYPE_RXPD,
+    MAX_TYPE_B
+} SNRNF_TYPE;
+
+/** SNRNF_DATA*/
+typedef enum _SNRNF_DATA
+{
+    TYPE_NOAVG = 0,
+    TYPE_AVG,
+    MAX_TYPE_AVG
+} SNRNF_DATA;
+
+/** WLAN_802_11_AUTH_ALG*/
+typedef enum _WLAN_802_11_AUTH_ALG
+{
+    AUTH_ALG_OPEN_SYSTEM = 1,
+    AUTH_ALG_SHARED_KEY = 2,
+    AUTH_ALG_NETWORK_EAP = 8,
+} WLAN_802_11_AUTH_ALG;
+
+/** WLAN_802_11_ENCRYPTION_MODE */
+typedef enum _WLAN_802_11_ENCRYPTION_MODE
+{
+    CIPHER_NONE,
+    CIPHER_WEP40,
+    CIPHER_TKIP,
+    CIPHER_CCMP,
+    CIPHER_WEP104,
+} WLAN_802_11_ENCRYPTION_MODE;
+
+/** WLAN_802_11_POWER_MODE */
+typedef enum _WLAN_802_11_POWER_MODE
+{
+    Wlan802_11PowerModeCAM,
+    Wlan802_11PowerModeMAX_PSP,
+    Wlan802_11PowerModeFast_PSP,
+
+    /*not a real mode, defined as an upper bound */
+    Wlan802_11PowerModeMax
+} WLAN_802_11_POWER_MODE;
+
+/** PS_STATE */
+typedef enum _PS_STATE
+{
+    PS_STATE_FULL_POWER,
+    PS_STATE_AWAKE,
+    PS_STATE_PRE_SLEEP,
+    PS_STATE_SLEEP
+} PS_STATE;
+
+/** DNLD_STATE */
+typedef enum _DNLD_STATE
+{
+    DNLD_RES_RECEIVED,
+    DNLD_DATA_SENT,
+    DNLD_CMD_SENT
+} DNLD_STATE;
+
+/** WLAN_MEDIA_STATE */
+typedef enum _WLAN_MEDIA_STATE
+{
+    WlanMediaStateDisconnected,
+    WlanMediaStateConnected
+} WLAN_MEDIA_STATE;
+
+/** WLAN_802_11_PRIVACY_FILTER */
+typedef enum _WLAN_802_11_PRIVACY_FILTER
+{
+    Wlan802_11PrivFilterAcceptAll,
+    Wlan802_11PrivFilter8021xWEP
+} WLAN_802_11_PRIVACY_FILTER;
+
+/** mv_ms_type */
+typedef enum _mv_ms_type
+{
+    MVMS_DAT = 0,
+    MVMS_CMD = 1,
+    /* 2: reserved */
+    MVMS_EVENT = 3
+} mv_ms_type;
+
+/* Hardware status codes */
+typedef enum _WLAN_HARDWARE_STATUS
+{
+    WlanHardwareStatusReady,
+    WlanHardwareStatusInitializing,
+    WlanHardwareStatusReset,
+    WlanHardwareStatusClosing,
+    WlanHardwareStatusNotReady
+} WLAN_HARDWARE_STATUS;
+
+/** WLAN_802_11_AUTHENTICATION_MODE */
+typedef enum _WLAN_802_11_AUTHENTICATION_MODE
+{
+    Wlan802_11AuthModeOpen = 0x00,
+    Wlan802_11AuthModeShared = 0x01,
+    Wlan802_11AuthModeNetworkEAP = 0x80,
+} WLAN_802_11_AUTHENTICATION_MODE;
+
+/** WLAN_802_11_WEP_STATUS */
+typedef enum _WLAN_802_11_WEP_STATUS
+{
+    Wlan802_11WEPEnabled,
+    Wlan802_11WEPDisabled,
+    Wlan802_11WEPKeyAbsent,
+    Wlan802_11WEPNotSupported
+} WLAN_802_11_WEP_STATUS;
+
+/** SNMP_MIB_INDEX_e */
+typedef enum _SNMP_MIB_INDEX_e
+{
+    DesiredBssType_i = 0,
+    OpRateSet_i,
+    BcnPeriod_i,
+    DtimPeriod_i,
+    AssocRspTimeOut_i,
+    RtsThresh_i,
+    ShortRetryLim_i,
+    LongRetryLim_i,
+    FragThresh_i,
+    Dot11D_i,
+    Dot11H_i,
+    ManufId_i,
+    ProdId_i,
+    ManufOui_i,
+    ManufName_i,
+    ManufProdName_i,
+    ManufProdVer_i
+} SNMP_MIB_INDEX_e;
+
+/** KEY_TYPE_ID */
+typedef enum _KEY_TYPE_ID
+{
+    KEY_TYPE_ID_WEP = 0,
+    KEY_TYPE_ID_TKIP,
+    KEY_TYPE_ID_AES
+} KEY_TYPE_ID;
+
+/** KEY_INFO_WEP*/
+typedef enum _KEY_INFO_WEP
+{
+    KEY_INFO_WEP_DEFAULT_KEY = 0x01
+} KEY_INFO_WEP;
+
+/** KEY_INFO_TKIP */
+typedef enum _KEY_INFO_TKIP
+{
+    KEY_INFO_TKIP_MCAST = 0x01,
+    KEY_INFO_TKIP_UNICAST = 0x02,
+    KEY_INFO_TKIP_ENABLED = 0x04
+} KEY_INFO_TKIP;
+
+/** KEY_INFO_AES*/
+typedef enum _KEY_INFO_AES
+{
+    KEY_INFO_AES_MCAST = 0x01,
+    KEY_INFO_AES_UNICAST = 0x02,
+    KEY_INFO_AES_ENABLED = 0x04
+} KEY_INFO_AES;
+
+/** SNMP_MIB_VALUE_e */
+typedef enum _SNMP_MIB_VALUE_e
+{
+    SNMP_MIB_VALUE_INFRA = 1,
+    SNMP_MIB_VALUE_ADHOC
+} SNMP_MIB_VALUE_e;
+
+/** HWRateDropMode */
+typedef enum _HWRateDropMode
+{
+    NO_HW_RATE_DROP,
+    HW_TABLE_RATE_DROP,
+    HW_SINGLE_RATE_DROP
+} HWRateDropMode;
+
+#ifdef __KERNEL__
+extern struct iw_handler_def wlan_handler_def;
+struct iw_statistics *wlan_get_wireless_stats(struct net_device *dev);
+int wlan_do_ioctl(struct net_device *dev, struct ifreq *req, int i);
+#endif
+
+#endif /* _WLAN_DEFS_H_ */
Index: linux-2.6.29/drivers/net/wireless/marvell8686/wlan_dev.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/wlan_dev.h	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,470 @@
+/** @file wlan_dev.h
+ *  @brief This file contains definitions and data structures specific
+ *          to Marvell 802.11 NIC. It contains the Device Information
+ *          structure wlan_adapter.  
+ *
+ *  Copyright  Marvell International Ltd. and/or its affiliates, 2003-2007
+ */
+/*************************************************************
+Change log:
+	09/26/05: add Doxygen format comments 
+	01/11/06: Conditionalize new scan/join structures.
+	04/18/06: Remove old Subscrive Event and add new Subscribe Event
+		  implementation through generic hostcmd API
+	05/08/06: Remove PermanentAddr from Adapter
+
+ ************************************************************/
+
+#ifndef _WLAN_DEV_H_
+#define _WLAN_DEV_H_
+
+#define	MAX_BSSID_PER_CHANNEL		16
+
+/* For the extended Scan */
+#define MAX_EXTENDED_SCAN_BSSID_LIST    MAX_BSSID_PER_CHANNEL * \
+						MRVDRV_MAX_CHANNEL_SIZE + 1
+
+typedef struct _PER_CHANNEL_BSSID_LIST_DATA
+{
+    u8 ucStart;
+    u8 ucNumEntry;
+} PER_CHANNEL_BSSID_LIST_DATA, *PPER_CHANNEL_BSSID_LIST_DATA;
+
+typedef struct _MRV_BSSID_IE_LIST
+{
+    WLAN_802_11_FIXED_IEs FixedIE;
+    u8 VariableIE[MRVDRV_SCAN_LIST_VAR_IE_SPACE];
+} MRV_BSSID_IE_LIST, *PMRV_BSSID_IE_LIST;
+
+#define	MAX_REGION_CHANNEL_NUM	2
+
+/** Chan-Freq-TxPower mapping table*/
+typedef struct _CHANNEL_FREQ_POWER
+{
+        /** Channel Number		*/
+    u16 Channel;
+        /** Frequency of this Channel	*/
+    u32 Freq;
+        /** Max allowed Tx power level	*/
+    u16 MaxTxPower;
+        /** TRUE:channel unsupported;  FLASE:supported*/
+    BOOLEAN Unsupported;
+} CHANNEL_FREQ_POWER;
+
+/** region-band mapping table*/
+typedef struct _REGION_CHANNEL
+{
+        /** TRUE if this entry is valid		     */
+    BOOLEAN Valid;
+        /** Region code for US, Japan ...	     */
+    u8 Region;
+        /** Band B/G/A, used for BAND_CONFIG cmd	     */
+    u8 Band;
+        /** Actual No. of elements in the array below */
+    u8 NrCFP;
+        /** chan-freq-txpower mapping table*/
+    CHANNEL_FREQ_POWER *CFP;
+} REGION_CHANNEL;
+
+typedef struct _wlan_802_11_security_t
+{
+    BOOLEAN WPAEnabled;
+    BOOLEAN WPA2Enabled;
+    WLAN_802_11_WEP_STATUS WEPStatus;
+    WLAN_802_11_AUTHENTICATION_MODE AuthenticationMode;
+    WLAN_802_11_ENCRYPTION_MODE EncryptionMode;
+} wlan_802_11_security_t;
+
+/** Current Basic Service Set State Structure */
+typedef struct
+{
+    BSSDescriptor_t BSSDescriptor;
+
+        /** band */
+    u8 band;
+
+        /** number of rates supported */
+    int NumOfRates;
+
+        /** supported rates*/
+    u8 DataRates[WLAN_SUPPORTED_RATES];
+
+        /** wmm enable? */
+    u8 wmm_enabled;
+
+        /** uapsd enable?*/
+    u8 wmm_uapsd_enabled;
+} CurrentBSSParams_t;
+
+/** sleep_params */
+typedef struct SleepParams
+{
+    u16 sp_error;
+    u16 sp_offset;
+    u16 sp_stabletime;
+    u8 sp_calcontrol;
+    u8 sp_extsleepclk;
+    u16 sp_reserved;
+} SleepParams;
+
+/** sleep_period */
+typedef struct SleepPeriod
+{
+    u16 period;
+    u16 reserved;
+} SleepPeriod;
+
+#define DBG_CMD_NUM	5
+
+/** info for debug purpose */
+typedef struct _wlan_dbg
+{
+    u32 num_cmd_host_to_card_failure;
+    u32 num_cmd_sleep_cfm_host_to_card_failure;
+    u32 num_tx_host_to_card_failure;
+    u32 num_event_deauth;
+    u32 num_event_disassoc;
+    u32 num_event_link_lost;
+    u32 num_cmd_deauth;
+    u32 num_cmd_assoc_success;
+    u32 num_cmd_assoc_failure;
+    u32 num_tx_timeout;
+    u32 num_cmd_timeout;
+    u16 TimeoutCmdId;
+    u16 TimeoutCmdAct;
+    u16 LastCmdId[DBG_CMD_NUM];
+    u16 LastCmdAct[DBG_CMD_NUM];
+    u16 LastCmdIndex;
+    u16 LastCmdRespId[DBG_CMD_NUM];
+    u16 LastCmdRespIndex;
+    u16 LastEvent[DBG_CMD_NUM];
+    u16 LastEventIndex;
+} wlan_dbg;
+
+/** Data structure for the Marvell WLAN device */
+typedef struct _wlan_dev
+{
+        /** device name */
+    char name[DEV_NAME_LEN];
+        /** card pointer */
+    void *card;
+        /** IO port */
+    u32 ioport;
+        /** Upload received */
+    u32 upld_rcv;
+        /** Upload type */
+    u32 upld_typ;
+        /** Upload length */
+    u32 upld_len;
+        /** netdev pointer */
+    struct net_device *netdev;
+    struct device *hotplug_device;
+
+    /* Upload buffer */
+    u8 upld_buf[WLAN_UPLD_SIZE];
+    /* Download sent: 
+       bit0 1/0=data_sent/data_tx_done, 
+       bit1 1/0=cmd_sent/cmd_tx_done, 
+       all other bits reserved 0 */
+    u8 dnld_sent;
+} wlan_dev_t, *pwlan_dev_t;
+
+/* Data structure for WPS information */
+typedef struct
+{
+    IEEEtypes_VendorSpecific_t wpsIe;
+    BOOLEAN SessionEnable;
+} wps_t;
+
+/** Private structure for the MV device */
+struct _wlan_private
+{
+    int open;
+
+    wlan_adapter *adapter;
+    wlan_dev_t wlan_dev;
+
+    struct net_device_stats stats;
+
+    struct iw_statistics wstats;
+#ifdef CONFIG_MARVELL_8686_PROC_FS
+    struct proc_dir_entry *proc_entry;
+    struct proc_dir_entry *proc_dev;
+#endif
+
+        /** thread to service interrupts */
+    wlan_thread MainThread;
+
+#ifdef REASSOCIATION
+        /** thread to service mac events */
+    wlan_thread ReassocThread;
+#endif                          /* REASSOCIATION */
+};
+
+/** Wlan Adapter data structure*/
+struct _wlan_adapter
+{
+    u8 TmpTxBuf[WLAN_UPLD_SIZE] __ATTRIB_ALIGN__;
+        /** STATUS variables */
+    WLAN_HARDWARE_STATUS HardwareStatus;
+    u32 FWReleaseNumber;
+    u32 fwCapInfo;
+    u8 chip_rev;
+
+        /** Command-related variables */
+    u16 SeqNum;
+    CmdCtrlNode *CmdArray;
+        /** Current Command */
+    CmdCtrlNode *CurCmd;
+    int CurCmdRetCode;
+
+        /** Command Queues */
+        /** Free command buffers */
+    struct list_head CmdFreeQ;
+        /** Pending command buffers */
+    struct list_head CmdPendingQ;
+
+        /** Variables brought in from private structure */
+    int irq;
+
+        /** Async and Sync Event variables */
+    u32 IntCounter;
+    u32 IntCounterSaved;        /* save int for DS/PS */
+    u32 EventCause;
+    u8 nodeName[16];            /* nickname */
+
+        /** spin locks */
+    spinlock_t QueueSpinLock __ATTRIB_ALIGN__;
+
+        /** Timers */
+    WLAN_DRV_TIMER MrvDrvCommandTimer __ATTRIB_ALIGN__;
+    BOOLEAN CommandTimerIsSet;
+
+#ifdef REASSOCIATION
+        /**Reassociation timer*/
+    BOOLEAN ReassocTimerIsSet;
+    WLAN_DRV_TIMER MrvDrvTimer __ATTRIB_ALIGN__;
+#endif                          /* REASSOCIATION */
+
+        /** Event Queues */
+    wait_queue_head_t ds_awake_q __ATTRIB_ALIGN__;
+
+    u8 HisRegCpy;
+
+    /** bg scan related variable */
+    HostCmd_DS_802_11_BG_SCAN_CONFIG *bgScanConfig;
+    u32 bgScanConfigSize;
+
+    /** WMM related variable*/
+    WMM_DESC wmm;
+
+        /** current ssid/bssid related parameters*/
+    CurrentBSSParams_t CurBssParams;
+
+    WLAN_802_11_NETWORK_INFRASTRUCTURE InfrastructureMode;
+
+    BSSDescriptor_t *pAttemptedBSSDesc;
+
+    WLAN_802_11_SSID AttemptedSSIDBeforeScan;
+    WLAN_802_11_SSID PreviousSSID;
+    u8 PreviousBSSID[MRVDRV_ETH_ADDR_LEN];
+
+    BSSDescriptor_t *ScanTable;
+    u32 NumInScanTable;
+
+    u8 ScanType;
+    u32 ScanMode;
+    u16 SpecificScanTime;
+    u16 ActiveScanTime;
+    u16 PassiveScanTime;
+
+    u16 BeaconPeriod;
+    u8 AdhocCreate;
+    BOOLEAN AdhocLinkSensed;
+
+#ifdef REASSOCIATION
+        /** Reassociation on and off */
+    BOOLEAN Reassoc_on;
+    SEMAPHORE ReassocSem;
+#endif                          /* REASSOCIATION */
+
+    BOOLEAN ATIMEnabled;
+
+        /** MAC address information */
+    u8 CurrentAddr[MRVDRV_ETH_ADDR_LEN];
+    u8 MulticastList[MRVDRV_MAX_MULTICAST_LIST_SIZE]
+        [MRVDRV_ETH_ADDR_LEN];
+    u32 NumOfMulticastMACAddr;
+
+    u16 HWRateDropMode;
+    u16 RateBitmap;
+    u16 Threshold;
+    u16 FinalRate;
+        /** control G Rates */
+    BOOLEAN adhoc_grate_enabled;
+
+    WLAN_802_11_ANTENNA TxAntenna;
+    WLAN_802_11_ANTENNA RxAntenna;
+
+    u8 AdhocChannel;
+    WLAN_802_11_FRAGMENTATION_THRESHOLD FragThsd;
+    WLAN_802_11_RTS_THRESHOLD RTSThsd;
+
+    u32 DataRate;
+    BOOLEAN Is_DataRate_Auto;
+
+        /** number of association attempts for the current SSID cmd */
+    u16 ListenInterval;
+    u16 TxRetryCount;
+
+    u16 Dtim;
+
+        /** Tx-related variables (for single packet tx) */
+    struct sk_buff *CurrentTxSkb;
+    struct sk_buff RxSkbQ;
+    BOOLEAN TxLockFlag;
+    u16 gen_null_pkg;
+    spinlock_t CurrentTxLock __ATTRIB_ALIGN__;
+
+        /** NIC Operation characteristics */
+    u16 CurrentPacketFilter;
+    u32 MediaConnectStatus;
+    u16 RegionCode;
+    u16 TxPowerLevel;
+    u8 MaxTxPowerLevel;
+    u8 MinTxPowerLevel;
+
+        /** POWER MANAGEMENT AND PnP SUPPORT */
+    BOOLEAN SurpriseRemoved;
+    u16 AtimWindow;
+
+    u16 PSMode;                 /* Wlan802_11PowerModeCAM=disable
+                                   Wlan802_11PowerModeMAX_PSP=enable */
+    u16 MultipleDtim;
+    u16 BCNMissTimeOut;
+    u32 PSState;
+    BOOLEAN NeedToWakeup;
+
+    PS_CMD_ConfirmSleep PSConfirmSleep;
+    u16 LocalListenInterval;
+    u16 NullPktInterval;
+    u16 AdhocAwakePeriod;
+    u16 fwWakeupMethod;
+    BOOLEAN IsDeepSleep;
+    BOOLEAN IsAutoDeepSleepEnabled;
+    BOOLEAN bWakeupDevRequired;
+    u32 WakeupTries;
+    BOOLEAN bHostSleepConfigured;
+    HostCmd_DS_802_11_HOST_SLEEP_CFG HSCfg;
+        /** ARP filter related variable */
+    u8 ArpFilter[ARP_FILTER_MAX_BUF_SIZE];
+    u32 ArpFilterSize;
+    BOOLEAN HS_Activated;
+
+        /** Encryption parameter */
+    wlan_802_11_security_t SecInfo;
+
+    MRVL_WEP_KEY WepKey[MRVL_NUM_WEP_KEY];
+    u16 CurrentWepKeyIndex;
+
+    /** Buffer for TLVs passed from the application to be inserted into the
+     *    association request to firmware 
+     */
+    u8 mrvlAssocTlvBuffer[MRVDRV_ASSOC_TLV_BUF_SIZE];
+
+    /** Length of the data stored in mrvlAssocTlvBuffer*/
+    u8 mrvlAssocTlvBufferLen;
+
+    /** Buffer to store the association response for application retrieval */
+    u8 assocRspBuffer[MRVDRV_ASSOC_RSP_BUF_SIZE];
+
+    /** Length of the data stored in assocRspBuffer */
+    int assocRspSize;
+
+    /** Generice IEEE IEs passed from the application to be inserted into the
+     *    association request to firmware 
+     */
+    u8 genIeBuffer[MRVDRV_GENIE_BUF_SIZE];
+
+    /** Length of the data stored in genIeBuffer */
+    u8 genIeBufferLen;
+
+    BOOLEAN IsGTK_SET;
+
+        /** Encryption Key*/
+    u8 Wpa_ie[256];
+    u8 Wpa_ie_len;
+
+    HostCmd_DS_802_11_KEY_MATERIAL aeskey;
+
+    /* Advanced Encryption Standard */
+    BOOLEAN AdhocAESEnabled;
+    wait_queue_head_t cmd_EncKey __ATTRIB_ALIGN__;
+
+    u16 RxAntennaMode;
+    u16 TxAntennaMode;
+
+        /** Requested Signal Strength*/
+    u16 bcn_avg_factor;
+    u16 data_avg_factor;
+    u16 SNR[MAX_TYPE_B][MAX_TYPE_AVG];
+    u16 NF[MAX_TYPE_B][MAX_TYPE_AVG];
+    u8 RSSI[MAX_TYPE_B][MAX_TYPE_AVG];
+    u8 rawSNR[DEFAULT_DATA_AVG_FACTOR];
+    u8 rawNF[DEFAULT_DATA_AVG_FACTOR];
+    u16 nextSNRNF;
+    u16 numSNRNF;
+    u32 RxPDAge;
+    u16 RxPDRate;
+
+    BOOLEAN RadioOn;
+
+        /** Blue Tooth Co-existence Arbitration */
+    HostCmd_DS_802_11_BCA_TIMESHARE bca_ts;
+
+        /** sleep_params */
+    SleepParams sp;
+
+        /** sleep_period (Enhanced Power Save) */
+    SleepPeriod sleep_period;
+
+#define	MAX_REGION_CHANNEL_NUM	2
+        /** Region Channel data */
+    REGION_CHANNEL region_channel[MAX_REGION_CHANNEL_NUM];
+
+    REGION_CHANNEL universal_channel[MAX_REGION_CHANNEL_NUM];
+
+        /** 11D and Domain Regulatory Data */
+    wlan_802_11d_domain_reg_t DomainReg;
+    parsed_region_chan_11d_t parsed_region_chan;
+
+        /** FSM variable for 11d support */
+    wlan_802_11d_state_t State11D;
+    u8 beaconBuffer[MAX_SCAN_BEACON_BUFFER];
+    u8 *pBeaconBufEnd;
+
+        /**	MISCELLANEOUS */
+    /* Card Information Structure */
+    u8 CisInfoBuf[512];
+    u16 CisInfoLen;
+
+    HostCmd_DS_802_11_GET_LOG LogMsg;
+    u16 ScanProbes;
+
+    u32 PktTxCtrl;
+
+    u8 *helper;
+    u32 helper_len;
+    u8 *fmimage;
+    u32 fmimage_len;
+    u16 TxRate;
+
+    wps_t wps;
+
+    wlan_dbg dbg;
+    wlan_subscribe_event subevent;
+    u8 sdiomode;
+    u32 num_cmd_timeout;
+};
+
+#endif /* _WLAN_DEV_H_ */
Index: linux-2.6.29/drivers/net/wireless/marvell8686/wlan_fops.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/wlan_fops.c	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,217 @@
+/** @file wlan_fops.c
+  * @brief This file contains the file read functions
+  * 
+  *  Copyright  Marvell International Ltd. and/or its affiliates, 2003-2006
+  */
+/********************************************************
+Change log:
+	01/06/06: Add Doxygen format comments
+
+********************************************************/
+
+#include	"include.h"
+
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <asm/fcntl.h>
+#include <linux/vmalloc.h>
+
+/********************************************************
+		Local Variables
+********************************************************/
+
+/********************************************************
+		Global Variables
+********************************************************/
+
+/********************************************************
+		Local Functions
+********************************************************/
+
+/** 
+ *  @brief This function opens/create a file in kernel mode.
+ *  
+ *  @param filename	Name of the file to be opened
+ *  @param flags		File flags 
+ *  @param mode		File permissions
+ *  @return 		file pointer if successful or NULL if failed.
+ */
+static struct file *
+wlan_fopen(const char *filename, unsigned int flags, int mode)
+{
+    int orgfsuid, orgfsgid;
+    struct file *file_ret;
+
+    /* Save uid and gid used for filesystem access.  */
+
+    orgfsuid = current->fsuid;
+    orgfsgid = current->fsgid;
+
+    /* Set user and group to 0 (root) */
+    current->fsuid = 0;
+    current->fsgid = 0;
+
+    /* Open the file in kernel mode */
+    file_ret = filp_open(filename, flags, mode);
+
+    /* Restore the uid and gid */
+    current->fsuid = orgfsuid;
+    current->fsgid = orgfsgid;
+
+    /* Check if the file was opened successfully
+       and return the file pointer of it was.  */
+    return ((IS_ERR(file_ret)) ? NULL : file_ret);
+}
+
+/** 
+ *  @brief This function closes a file in kernel mode.
+ *  
+ *  @param file_ptr     File pointer 
+ *  @return 		WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_fclose(struct file *file_ptr)
+{
+    int orgfsuid, orgfsgid;
+    int file_ret;
+
+    if ((NULL == file_ptr) || (IS_ERR(file_ptr)))
+        return -ENOENT;
+
+    /* Save uid and gid used for filesystem access.  */
+    orgfsuid = current->fsuid;
+    orgfsgid = current->fsgid;
+
+    /* Set user and group to 0 (root) */
+    current->fsuid = 0;
+    current->fsgid = 0;
+
+    /* Close the file in kernel mode (user_id = 0) */
+    file_ret = filp_close(file_ptr, 0);
+
+    /* Restore the uid and gid */
+    current->fsuid = orgfsuid;
+    current->fsgid = orgfsgid;
+
+    return (file_ret);
+}
+
+/** 
+ *  @brief This function reads data from files in kernel mode.
+ *  
+ *  @param file_ptr     File pointer
+ *  @param buf		Buffers to read data into
+ *  @param len		Length of buffer
+ *  @return 		number of characters read	
+ */
+static int
+wlan_fread(struct file *file_ptr, char *buf, int len)
+{
+    int orgfsuid, orgfsgid;
+    int file_ret;
+    mm_segment_t orgfs;
+
+    /* Check if the file pointer is valid */
+    if ((NULL == file_ptr) || (IS_ERR(file_ptr)))
+        return -ENOENT;
+
+    /* Check for a valid file read function */
+    if (file_ptr->f_op->read == NULL)
+        return -ENOSYS;
+
+    /* Check for access permissions */
+    if (((file_ptr->f_flags & O_ACCMODE) & (O_RDONLY | O_RDWR)) == 0)
+        return -EACCES;
+
+    /* Check if there is a valid length */
+    if (0 >= len)
+        return -EINVAL;
+
+    /* Save uid and gid used for filesystem access.  */
+    orgfsuid = current->fsuid;
+    orgfsgid = current->fsgid;
+
+    /* Set user and group to 0 (root) */
+    current->fsuid = 0;
+    current->fsgid = 0;
+
+    /* Save FS register and set FS register to kernel
+       space, needed for read and write to accept
+       buffer in kernel space.  */
+    orgfs = get_fs();
+
+    /* Set the FS register to KERNEL mode.  */
+    set_fs(KERNEL_DS);
+
+    /* Read the actual data from the file */
+    file_ret = file_ptr->f_op->read(file_ptr, buf, len, &file_ptr->f_pos);
+
+    /* Restore the FS register */
+    set_fs(orgfs);
+
+    /* Restore the uid and gid */
+    current->fsuid = orgfsuid;
+    current->fsgid = orgfsgid;
+
+    return (file_ret);
+}
+
+/********************************************************
+		Global Functions
+********************************************************/
+
+/** 
+ *  @brief This function free FW/Helper buffer.
+ *  
+ *  @param addr		Pointer to buffer storing FW/Helper
+ *  @return 		None	
+ */
+void
+fw_buffer_free(u8 * addr)
+{
+    vfree(addr);
+}
+
+/** 
+ *  @brief This function reads FW/Helper.
+ *  
+ *  @param name		File name
+ *  @param addr		Pointer to buffer storing FW/Helper
+ *  @param len     	Pointer to length of FW/Helper
+ *  @return 		WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+fw_read(const char *name, u8 ** addr, u32 * len)
+{
+    struct file *fp;
+    int ret;
+    u8 *ptr;
+
+    fp = wlan_fopen(name, O_RDWR, 0);
+
+    if (fp == NULL) {
+        PRINTM(MSG, "Could not open file:%s\n", name);
+        return WLAN_STATUS_FAILURE;
+    }
+
+    /*calculate file length */
+    *len = fp->f_dentry->d_inode->i_size - fp->f_pos;
+
+    ptr = (u8 *) vmalloc(*len + 1023);
+    if (ptr == NULL) {
+        PRINTM(MSG, "vmalloc failure\n");
+        return WLAN_STATUS_FAILURE;
+    }
+    if (wlan_fread(fp, ptr, *len) > 0) {
+        *addr = ptr;
+        ret = WLAN_STATUS_SUCCESS;
+    } else {
+        fw_buffer_free(ptr);
+        *addr = NULL;
+        PRINTM(MSG, "fail to read the file %s \n", name);
+        ret = WLAN_STATUS_FAILURE;
+    }
+
+    wlan_fclose(fp);
+    return ret;
+}
Index: linux-2.6.29/drivers/net/wireless/marvell8686/wlan_fw.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/wlan_fw.c	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,532 @@
+/** @file wlan_fw.c
+  * @brief This file contains the initialization for FW
+  * and HW 
+  * 
+  *  Copyright  Marvell International Ltd. and/or its affiliates, 2003-2007
+  */
+/********************************************************
+Change log:
+	09/28/05: Add Doxygen format comments
+	01/05/06: Add kernel 2.6.x support	
+	01/11/06: Conditionalize new scan/join functions.
+	          Cleanup association response handler initialization.
+	01/06/05: Add FW file read
+	05/08/06: Remove the 2nd GET_HW_SPEC command and TempAddr/PermanentAddr
+	06/30/06: replaced MODULE_PARM(name, type) with module_param(name, type, perm)
+
+********************************************************/
+
+#include	"include.h"
+#include <linux/vmalloc.h>
+
+/********************************************************
+		Local Variables
+********************************************************/
+
+extern const char *helper_name;
+extern const char *fw_name;
+
+#if 0
+module_param(helper_name, charp, 0);
+module_param(fw_name, charp, 0);
+#endif
+
+#ifdef MFG_CMD_SUPPORT
+int mfgmode = 0;
+module_param(mfgmode, int, 0);
+#endif
+
+/********************************************************
+		Global Variables
+********************************************************/
+
+/********************************************************
+		Local Functions
+********************************************************/
+
+/** 
+ *  @brief This function downloads firmware image, gets
+ *  HW spec from firmware and set basic parameters to
+ *  firmware.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_setup_station_hw(wlan_private * priv)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *adapter = priv->adapter;
+    u8 *ptr = NULL;
+    u32 len = 0;
+
+    //HostCmd_DS_SDIO_INT_CONFIG sdio_int_cfg;
+
+    ENTER();
+
+    sbi_disable_host_int(priv);
+
+#if 0
+    if ((intmode == INTMODE_GPIO) && (gpiopin == 0)) {
+        PRINTM(MSG, "Invalid gpio pin#\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+#endif
+
+    adapter->fmimage = NULL;
+    adapter->fmimage_len = 0;
+    adapter->helper = NULL;
+    adapter->helper_len = 0;
+
+    if (helper_name != NULL) {
+        if (fw_read(helper_name, &ptr, &len) != WLAN_STATUS_FAILURE) {
+            adapter->helper = ptr;
+            adapter->helper_len = len;
+            PRINTM(INFO, "helper read success, len=%x\n", len);
+        } else {
+            PRINTM(MSG, "helper %s read fail.\n", helper_name);
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+    }
+
+    if (fw_name != NULL) {
+        if (fw_read(fw_name, &ptr, &len) != WLAN_STATUS_FAILURE) {
+            adapter->fmimage = ptr;
+            adapter->fmimage_len = len;
+            PRINTM(INFO, "fw read success, len=%x\n", len);
+        } else {
+            PRINTM(MSG, "fw %s read fail.\n", fw_name);
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+    }
+
+    /* Download the helper */
+    ret = sbi_prog_helper(priv);
+
+    if (ret) {
+        PRINTM(INFO, "Bootloader in invalid state!\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+    /* Download the main firmware via the helper firmware */
+    if (sbi_prog_firmware_w_helper(priv)) {
+        PRINTM(INFO, "Wlan FW download failed!\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    /* check if the fimware is downloaded successfully or not */
+    if (sbi_verify_fw_download(priv)) {
+        PRINTM(INFO, "FW failed to be active in time!\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+#define RF_REG_OFFSET 0x07
+#define RF_REG_VALUE  0xc8
+
+    sbi_enable_host_int(priv);
+
+#define INT_RASING_EDGE		0
+#define INT_FALLING_EDGE	1
+
+#define DELAY_1_US		1
+#if 0
+    if (intmode == INTMODE_GPIO) {
+        /* This command should be issued first */
+        sdio_int_cfg.Action = HostCmd_ACT_GEN_SET;
+        sdio_int_cfg.Gpio_pin = gpiopin;
+        sdio_int_cfg.Gpio_int_edge = INT_FALLING_EDGE;
+        sdio_int_cfg.Gpio_pulse_width = DELAY_1_US;
+        ret = PrepareAndSendCommand(priv, HostCmd_CMD_SDIO_GPIO_INT_CONFIG,
+                                    0, HostCmd_OPTION_WAITFORRSP,
+                                    0, &sdio_int_cfg);
+    }
+#endif
+#ifdef MFG_CMD_SUPPORT
+    if (mfgmode == 0) {
+#endif
+
+        /*
+         * Read MAC address from HW
+         */
+        memset(adapter->CurrentAddr, 0xff, MRVDRV_ETH_ADDR_LEN);
+
+        ret = PrepareAndSendCommand(priv, HostCmd_CMD_GET_HW_SPEC,
+                                    0, HostCmd_OPTION_WAITFORRSP, 0, NULL);
+
+        if (ret) {
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_MAC_CONTROL,
+                                    0, HostCmd_OPTION_WAITFORRSP, 0,
+                                    &adapter->CurrentPacketFilter);
+
+        if (ret) {
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_802_11_FW_WAKE_METHOD,
+                                    HostCmd_ACT_GET,
+                                    HostCmd_OPTION_WAITFORRSP, 0,
+                                    &priv->adapter->fwWakeupMethod);
+
+        if (ret) {
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+#ifdef MFG_CMD_SUPPORT
+    }
+#endif
+
+#ifdef MFG_CMD_SUPPORT
+    if (mfgmode == 0) {
+#endif
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_802_11_RATE_ADAPT_RATESET,
+                                    HostCmd_ACT_GEN_GET,
+                                    HostCmd_OPTION_WAITFORRSP, 0, NULL);
+        if (ret) {
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+        priv->adapter->DataRate = 0;
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_802_11_RF_TX_POWER,
+                                    HostCmd_ACT_GEN_GET,
+                                    HostCmd_OPTION_WAITFORRSP, 0, NULL);
+
+        if (ret) {
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+#ifdef MFG_CMD_SUPPORT
+    }
+#endif
+
+    ret = WLAN_STATUS_SUCCESS;
+  done:
+    if (adapter->helper != NULL) {
+        fw_buffer_free(adapter->helper);
+    }
+    if (adapter->fmimage != NULL) {
+        fw_buffer_free(adapter->fmimage);
+    }
+
+    LEAVE();
+
+    return (ret);
+}
+
+/** 
+ *  @brief This function initializes timers.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   n/a
+ */
+static void
+init_sync_objects(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    InitializeTimer(&Adapter->MrvDrvCommandTimer,
+                    MrvDrvCommandTimerFunction, priv);
+    Adapter->CommandTimerIsSet = FALSE;
+
+#ifdef REASSOCIATION
+    /* Initialize the timer for the reassociation */
+    InitializeTimer(&Adapter->MrvDrvTimer, MrvDrvReassocTimerFunction, priv);
+    Adapter->ReassocTimerIsSet = FALSE;
+#endif /* REASSOCIATION */
+
+    return;
+}
+
+/** 
+ *  @brief This function allocates buffer for the member of adapter
+ *  structure like command buffer and BSSID list.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_allocate_adapter(wlan_private * priv)
+{
+    u32 ulBufSize;
+    wlan_adapter *Adapter = priv->adapter;
+
+    BSSDescriptor_t *pTempScanTable;
+
+    /* Allocate buffer to store the BSSID list */
+    ulBufSize = sizeof(BSSDescriptor_t) * MRVDRV_MAX_BSSID_LIST;
+    if (!(pTempScanTable = kmalloc(ulBufSize, GFP_KERNEL))) {
+        return WLAN_STATUS_FAILURE;
+    }
+
+    Adapter->ScanTable = pTempScanTable;
+    memset(Adapter->ScanTable, 0, ulBufSize);
+
+    if (!(Adapter->bgScanConfig =
+          kmalloc(sizeof(HostCmd_DS_802_11_BG_SCAN_CONFIG), GFP_KERNEL))) {
+        return WLAN_STATUS_FAILURE;
+    }
+    Adapter->bgScanConfigSize = sizeof(HostCmd_DS_802_11_BG_SCAN_CONFIG);
+    memset(Adapter->bgScanConfig, 0, Adapter->bgScanConfigSize);
+
+    spin_lock_init(&Adapter->QueueSpinLock);
+
+    /* Allocate the command buffers */
+    if (AllocateCmdBuffer(priv) != WLAN_STATUS_SUCCESS) {
+        return WLAN_STATUS_FAILURE;
+    }
+
+    memset(&Adapter->PSConfirmSleep, 0, sizeof(PS_CMD_ConfirmSleep));
+    Adapter->PSConfirmSleep.SeqNum = wlan_cpu_to_le16(++Adapter->SeqNum);
+    Adapter->PSConfirmSleep.Command =
+        wlan_cpu_to_le16(HostCmd_CMD_802_11_PS_MODE);
+    Adapter->PSConfirmSleep.Size =
+        wlan_cpu_to_le16(sizeof(PS_CMD_ConfirmSleep));
+    Adapter->PSConfirmSleep.Result = 0;
+    Adapter->PSConfirmSleep.Action =
+        wlan_cpu_to_le16(HostCmd_SubCmd_Sleep_Confirmed);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function initializes the adapter structure
+ *  and set default value to the member of adapter.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   n/a
+ */
+static void
+wlan_init_adapter(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int i;
+
+    Adapter->ScanProbes = 0;
+
+    Adapter->bcn_avg_factor = DEFAULT_BCN_AVG_FACTOR;
+    Adapter->data_avg_factor = DEFAULT_DATA_AVG_FACTOR;
+
+    /* ATIM params */
+    Adapter->AtimWindow = 0;
+    Adapter->ATIMEnabled = FALSE;
+
+    Adapter->MediaConnectStatus = WlanMediaStateDisconnected;
+
+    memset(Adapter->CurrentAddr, 0xff, MRVDRV_ETH_ADDR_LEN);
+
+    /* Status variables */
+    Adapter->HardwareStatus = WlanHardwareStatusInitializing;
+
+    /* scan type */
+    Adapter->ScanType = HostCmd_SCAN_TYPE_ACTIVE;
+
+    /* scan mode */
+    Adapter->ScanMode = HostCmd_BSS_TYPE_ANY;
+
+    /* scan time */
+    Adapter->SpecificScanTime = MRVDRV_SPECIFIC_SCAN_CHAN_TIME;
+    Adapter->ActiveScanTime = MRVDRV_ACTIVE_SCAN_CHAN_TIME;
+    Adapter->PassiveScanTime = MRVDRV_PASSIVE_SCAN_CHAN_TIME;
+
+    /* 802.11 specific */
+    Adapter->SecInfo.WEPStatus = Wlan802_11WEPDisabled;
+    for (i = 0; i < sizeof(Adapter->WepKey) / sizeof(Adapter->WepKey[0]); i++)
+        memset(&Adapter->WepKey[i], 0, sizeof(MRVL_WEP_KEY));
+    Adapter->CurrentWepKeyIndex = 0;
+    Adapter->SecInfo.AuthenticationMode = Wlan802_11AuthModeOpen;
+    Adapter->SecInfo.EncryptionMode = CIPHER_NONE;
+    Adapter->AdhocAESEnabled = FALSE;
+    Adapter->InfrastructureMode = Wlan802_11Infrastructure;
+
+    Adapter->NumInScanTable = 0;
+    Adapter->pAttemptedBSSDesc = NULL;
+#ifdef REASSOCIATION
+    OS_INIT_SEMAPHORE(&Adapter->ReassocSem);
+#endif
+    Adapter->pBeaconBufEnd = Adapter->beaconBuffer;
+
+    Adapter->HisRegCpy |= HIS_TxDnLdRdy;
+
+    memset(&Adapter->CurBssParams, 0, sizeof(Adapter->CurBssParams));
+
+    /* PnP and power profile */
+    Adapter->SurpriseRemoved = FALSE;
+
+    Adapter->CurrentPacketFilter =
+        HostCmd_ACT_MAC_RTS_CTS_ENABLE |
+        HostCmd_ACT_MAC_RX_ON | HostCmd_ACT_MAC_TX_ON;
+
+    Adapter->RadioOn = RADIO_ON;
+#ifdef REASSOCIATION
+#if (WIRELESS_EXT >= 18)
+    Adapter->Reassoc_on = FALSE;
+#else
+    Adapter->Reassoc_on = TRUE;
+#endif
+#endif /* REASSOCIATION */
+    Adapter->TxAntenna = RF_ANTENNA_2;
+    Adapter->RxAntenna = RF_ANTENNA_AUTO;
+
+    Adapter->HWRateDropMode = HW_TABLE_RATE_DROP;
+    Adapter->Is_DataRate_Auto = TRUE;
+    Adapter->BeaconPeriod = MRVDRV_BEACON_INTERVAL;
+
+    Adapter->AdhocChannel = DEFAULT_AD_HOC_CHANNEL;
+
+    Adapter->PSMode = Wlan802_11PowerModeCAM;
+    Adapter->MultipleDtim = MRVDRV_DEFAULT_MULTIPLE_DTIM;
+
+    Adapter->ListenInterval = MRVDRV_DEFAULT_LISTEN_INTERVAL;
+
+    Adapter->PSState = PS_STATE_FULL_POWER;
+
+    Adapter->NeedToWakeup = FALSE;
+    Adapter->LocalListenInterval = 0;   /* default value in firmware will be used */
+    Adapter->fwWakeupMethod = WAKEUP_FW_UNCHANGED;
+
+    Adapter->IsDeepSleep = FALSE;
+    Adapter->IsAutoDeepSleepEnabled = FALSE;
+
+    Adapter->bWakeupDevRequired = FALSE;
+
+    Adapter->WakeupTries = 0;
+    Adapter->bHostSleepConfigured = FALSE;
+
+    Adapter->HSCfg.conditions = HOST_SLEEP_CFG_CANCEL;
+    Adapter->HSCfg.gpio = 0;
+    Adapter->HSCfg.gap = 0;
+
+    Adapter->DataRate = 0;      // Initially indicate the rate as auto 
+
+    Adapter->adhoc_grate_enabled = FALSE;
+
+    Adapter->IntCounter = Adapter->IntCounterSaved = 0;
+
+    INIT_LIST_HEAD((struct list_head *) &Adapter->RxSkbQ);
+
+    Adapter->gen_null_pkg = TRUE;       /*Enable NULL Pkg generation */
+
+    init_waitqueue_head(&Adapter->cmd_EncKey);
+
+    spin_lock_init(&Adapter->CurrentTxLock);
+
+    Adapter->CurrentTxSkb = NULL;
+    Adapter->PktTxCtrl = 0;
+
+    return;
+}
+
+/********************************************************
+		Global Functions
+********************************************************/
+
+/** 
+ *  @brief This function initializes firmware
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_init_fw(wlan_private * priv)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    /* Allocate adapter structure */
+    if ((ret = wlan_allocate_adapter(priv)) != WLAN_STATUS_SUCCESS) {
+        goto done;
+    }
+
+    /* init adapter structure */
+    wlan_init_adapter(priv);
+
+    /* init timer etc. */
+    init_sync_objects(priv);
+
+    /* download fimrware etc. */
+    if ((ret = wlan_setup_station_hw(priv)) != WLAN_STATUS_SUCCESS) {
+        Adapter->HardwareStatus = WlanHardwareStatusNotReady;
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+    /* init 802.11d */
+    wlan_init_11d(priv);
+
+    Adapter->HardwareStatus = WlanHardwareStatusReady;
+    ret = WLAN_STATUS_SUCCESS;
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function frees the structure of adapter
+ *    
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   n/a
+ */
+void
+wlan_free_adapter(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (!Adapter) {
+        PRINTM(INFO, "Why double free adapter?:)\n");
+        return;
+    }
+
+    PRINTM(INFO, "Free Command buffer\n");
+    FreeCmdBuffer(priv);
+
+    PRINTM(INFO, "Free CommandTimer\n");
+    if (Adapter->CommandTimerIsSet) {
+        CancelTimer(&Adapter->MrvDrvCommandTimer);
+        Adapter->CommandTimerIsSet = FALSE;
+    }
+    FreeTimer(&Adapter->MrvDrvCommandTimer);
+#ifdef REASSOCIATION
+    PRINTM(INFO, "Free MrvDrvTimer\n");
+    if (Adapter->ReassocTimerIsSet) {
+        CancelTimer(&Adapter->MrvDrvTimer);
+        Adapter->ReassocTimerIsSet = FALSE;
+    }
+    FreeTimer(&Adapter->MrvDrvTimer);
+#endif /* REASSOCIATION */
+
+    if (Adapter->bgScanConfig) {
+        kfree(Adapter->bgScanConfig);
+        Adapter->bgScanConfig = NULL;
+    }
+
+    OS_FREE_LOCK(&Adapter->CurrentTxLock);
+    OS_FREE_LOCK(&Adapter->QueueSpinLock);
+
+    PRINTM(INFO, "Free ScanTable\n");
+    if (Adapter->ScanTable) {
+        kfree(Adapter->ScanTable);
+        Adapter->ScanTable = NULL;
+    }
+
+    PRINTM(INFO, "Free Adapter\n");
+
+    /* Free the adapter object itself */
+    kfree(Adapter);
+    priv->adapter = NULL;
+    LEAVE();
+}
Index: linux-2.6.29/drivers/net/wireless/marvell8686/wlan_join.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/wlan_join.c	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,2031 @@
+/** @file wlan_join.c
+ *
+ *  @brief Functions implementing wlan infrastructure and adhoc join routines
+ *
+ *  IOCTL handlers as well as command preperation and response routines
+ *   for sending adhoc start, adhoc join, and association commands
+ *   to the firmware.
+ *
+ *  Copyright  Marvell International Ltd. and/or its affiliates, 2003-2006
+ *
+ *  @sa wlan_join.h
+ */
+/*************************************************************
+Change Log:
+    01/11/06: Initial revision. Match new scan code, relocate related functions
+    01/19/06: Fix failure to save adhoc ssid as current after adhoc start
+    03/16/06: Add a semaphore to protect reassociation thread
+
+************************************************************/
+
+#include    "include.h"
+
+/**
+ *  @brief This function finds out the common rates between rate1 and rate2.
+ *
+ * It will fill common rates in rate1 as output if found.
+ *
+ * NOTE: Setting the MSB of the basic rates need to be taken
+ *   care, either before or after calling this function
+ *
+ *  @param Adapter     A pointer to wlan_adapter structure
+ *  @param rate1       the buffer which keeps input and output
+ *  @param rate1_size  the size of rate1 buffer
+ *  @param rate2       the buffer which keeps rate2
+ *  @param rate2_size  the size of rate2 buffer.
+ *
+ *  @return            WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+get_common_rates(wlan_adapter * Adapter, u8 * rate1,
+                 int rate1_size, u8 * rate2, int rate2_size)
+{
+    u8 *ptr = rate1;
+    int ret = WLAN_STATUS_SUCCESS;
+    u8 *tmp = NULL;
+    int i, j;
+
+    if (!(tmp = kmalloc(rate1_size, GFP_KERNEL))) {
+        PRINTM(WARN, "Allocate buffer for common rates failed\n");
+        return -ENOMEM;
+    }
+
+    memcpy(tmp, rate1, rate1_size);
+    memset(rate1, 0, rate1_size);
+
+    for (i = 0; rate2[i] && i < rate2_size; i++) {
+        for (j = 0; tmp[j] && j < rate1_size; j++) {
+            /* Check common rate, excluding the bit for basic rate */
+            if ((rate2[i] & 0x7F) == (tmp[j] & 0x7F)) {
+                *rate1++ = tmp[j];
+                break;
+            }
+        }
+    }
+
+    HEXDUMP("rate1 (AP) Rates", tmp, rate1_size);
+    HEXDUMP("rate2 (Card) Rates", rate2, rate2_size);
+    HEXDUMP("Common Rates", ptr, rate1 - ptr);
+    PRINTM(INFO, "Tx DataRate is set to 0x%X\n", Adapter->DataRate);
+
+    if (!Adapter->Is_DataRate_Auto) {
+        while (*ptr) {
+            if ((*ptr & 0x7f) == Adapter->DataRate) {
+                ret = WLAN_STATUS_SUCCESS;
+                goto done;
+            }
+            ptr++;
+        }
+        PRINTM(MSG, "Previously set fixed data rate %#x isn't "
+               "compatible with the network.\n", Adapter->DataRate);
+
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    ret = WLAN_STATUS_SUCCESS;
+  done:
+    kfree(tmp);
+    return ret;
+}
+
+/**
+ *  @brief Create the intersection of the rates supported by a target BSS and
+ *         our Adapter settings for use in an assoc/join command.
+ *
+ *  @param Adapter       A pointer to wlan_adapter structure
+ *  @param pBSSDesc      BSS Descriptor whose rates are used in the setup
+ *  @param pOutRates     Output: Octet array of rates common between the BSS
+ *                       and the Adapter supported rates settings
+ *  @param pOutRatesSize Output: Number of rates/octets set in pOutRates
+ *
+ *  @return              WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ *
+ */
+static int
+setup_rates_from_bssdesc(wlan_adapter * Adapter,
+                         BSSDescriptor_t * pBSSDesc,
+                         u8 * pOutRates, int *pOutRatesSize)
+{
+    u8 *card_rates;
+    int card_rates_size;
+
+    ENTER();
+
+    memcpy(pOutRates, pBSSDesc->SupportedRates, WLAN_SUPPORTED_RATES);
+
+    card_rates = SupportedRates;
+    card_rates_size = sizeof(SupportedRates);
+
+    if (get_common_rates(Adapter, pOutRates, WLAN_SUPPORTED_RATES,
+                         card_rates, card_rates_size)) {
+        *pOutRatesSize = 0;
+        PRINTM(INFO, "get_common_rates failed\n");
+        LEAVE();
+        return WLAN_STATUS_FAILURE;
+    }
+
+    *pOutRatesSize = MIN(strlen(pOutRates), WLAN_SUPPORTED_RATES);
+
+    LEAVE();
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Retrieve the association response
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param wrq          A pointer to iwreq structure
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_get_assoc_rsp_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int copySize;
+
+    /*
+     * Set the amount to copy back to the application as the minimum of the
+     *   available assoc resp data or the buffer provided by the application
+     */
+    copySize = MIN(Adapter->assocRspSize, wrq->u.data.length);
+
+    /* Copy the (re)association response back to the application */
+    if (copy_to_user(wrq->u.data.pointer, Adapter->assocRspBuffer, copySize)) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return -EFAULT;
+    }
+
+    /* Returned copy length */
+    wrq->u.data.length = copySize;
+
+    /* Reset assoc buffer */
+    Adapter->assocRspSize = 0;
+
+    /* No error on return */
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Set an opaque block of Marvell TLVs for insertion into the
+ *         association command
+ *
+ *  Pass an opaque block of data, expected to be Marvell TLVs, to the driver
+ *    for eventual passthrough to the firmware in an associate/join
+ *    (and potentially start) command.
+ *
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param wrq          A pointer to iwreq structure
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_set_mrvl_tlv_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    /* If the passed length is zero, reset the buffer */
+    if (wrq->u.data.length == 0) {
+        Adapter->mrvlAssocTlvBufferLen = 0;
+    } else {
+        /*
+         * Verify that the passed length is not larger than the available
+         *   space remaining in the buffer
+         */
+        if (wrq->u.data.length < (sizeof(Adapter->mrvlAssocTlvBuffer)
+                                  - Adapter->mrvlAssocTlvBufferLen)) {
+            /* Append the passed data to the end of the mrvlAssocTlvBuffer */
+            if (copy_from_user(Adapter->mrvlAssocTlvBuffer
+                               + Adapter->mrvlAssocTlvBufferLen,
+                               wrq->u.data.pointer, wrq->u.data.length)) {
+                PRINTM(INFO, "Copy from user failed\n");
+                return -EFAULT;
+            }
+
+            /* Increment the stored buffer length by the size passed */
+            Adapter->mrvlAssocTlvBufferLen += wrq->u.data.length;
+        } else {
+            /* Passed data does not fit in the remaining buffer space */
+            ret = WLAN_STATUS_FAILURE;
+        }
+    }
+
+    /* Return WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE */
+    return ret;
+}
+
+/**
+ *  @brief Stop Adhoc Network
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_do_adhocstop_ioctl(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (Adapter->InfrastructureMode == Wlan802_11IBSS &&
+        Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+
+        ret = StopAdhocNetwork(priv);
+
+    } else {
+        LEAVE();
+        return -ENOTSUPP;
+    }
+
+    LEAVE();
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Set essid
+ *
+ *  @param dev          A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param dwrq         A pointer to iw_point structure
+ *  @param extra        A pointer to extra data buf
+ *  @return             WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+int
+wlan_set_essid(struct net_device *dev, struct iw_request_info *info,
+               struct iw_point *dwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    WLAN_802_11_SSID reqSSID;
+    int i;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    /* Clear any past association response stored for application retrieval */
+    Adapter->assocRspSize = 0;
+
+#ifdef REASSOCIATION
+    // cancel re-association timer if there's one
+    if (Adapter->ReassocTimerIsSet == TRUE) {
+        CancelTimer(&Adapter->MrvDrvTimer);
+        Adapter->ReassocTimerIsSet = FALSE;
+    }
+
+    if (OS_ACQ_SEMAPHORE_BLOCK(&Adapter->ReassocSem)) {
+        PRINTM(ERROR, "Acquire semaphore error, wlan_set_essid\n");
+        return -EBUSY;
+    }
+#endif /* REASSOCIATION */
+
+    /* Check the size of the string */
+    if (dwrq->length > IW_ESSID_MAX_SIZE + 1) {
+        ret = -E2BIG;
+        goto setessid_ret;
+    }
+
+    memset(&reqSSID, 0, sizeof(WLAN_802_11_SSID));
+
+    /*
+     * Check if we asked for `any' or 'particular'
+     */
+    if (!dwrq->flags) {
+        if (FindBestNetworkSsid(priv, &reqSSID)) {
+            PRINTM(INFO, "Could not find best network\n");
+            ret = WLAN_STATUS_SUCCESS;
+            goto setessid_ret;
+        }
+    } else {
+        /* Set the SSID */
+#if WIRELESS_EXT > 20
+        reqSSID.SsidLength = dwrq->length;
+#else
+        reqSSID.SsidLength = dwrq->length - 1;
+#endif
+        memcpy(reqSSID.Ssid, extra,
+               MIN(reqSSID.SsidLength, reqSSID.SsidLength));
+
+    }
+
+    PRINTM(INFO, "Requested new SSID = %s\n",
+           (reqSSID.SsidLength > 0) ? (char *) reqSSID.Ssid : "NULL");
+    if (!reqSSID.SsidLength || reqSSID.Ssid[0] < 0x20) {
+        PRINTM(INFO, "Invalid SSID - aborting set_essid\n");
+        ret = -EINVAL;
+        goto setessid_ret;
+    }
+
+    if (Adapter->InfrastructureMode == Wlan802_11Infrastructure) {
+        /* infrastructure mode */
+        PRINTM(INFO, "SSID requested = %s\n", reqSSID.Ssid);
+
+        if ((dwrq->flags & IW_ENCODE_INDEX) > 1) {
+            i = (dwrq->flags & IW_ENCODE_INDEX) - 1;    /* convert to 0 based */
+
+            PRINTM(INFO, "Request SSID by index = %d\n", i);
+
+            if (i > Adapter->NumInScanTable) {
+                /* Failed to find in table since index is > current max. */
+                i = -EINVAL;
+            }
+        } else {
+            SendSpecificSSIDScan(priv, &reqSSID);
+            i = FindSSIDInList(Adapter,
+                               &reqSSID, NULL, Wlan802_11Infrastructure);
+        }
+
+        if (i >= 0) {
+            PRINTM(INFO, "SSID found in scan list ... associating...\n");
+
+            ret = wlan_associate(priv, &Adapter->ScanTable[i]);
+
+            if (ret) {
+                goto setessid_ret;
+            }
+        } else {                /* i >= 0 */
+            ret = i;            /* return -ENETUNREACH, passed from FindSSIDInList */
+            goto setessid_ret;
+        }
+    } else {
+        /* ad hoc mode */
+        /* If the requested SSID matches current SSID return */
+        if (!SSIDcmp(&Adapter->CurBssParams.BSSDescriptor.Ssid, &reqSSID)) {
+            ret = WLAN_STATUS_SUCCESS;
+            goto setessid_ret;
+        }
+
+        if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+            /*
+             * Exit Adhoc mode
+             */
+            PRINTM(INFO, "Sending Adhoc Stop\n");
+            ret = StopAdhocNetwork(priv);
+
+            if (ret) {
+                goto setessid_ret;
+            }
+        }
+        Adapter->AdhocLinkSensed = FALSE;
+
+        if ((dwrq->flags & IW_ENCODE_INDEX) > 1) {
+            i = (dwrq->flags & IW_ENCODE_INDEX) - 1;    /* 0 based */
+            if (i > Adapter->NumInScanTable) {
+                /* Failed to find in table since index is > current max. */
+                i = -EINVAL;
+            }
+        } else {
+            /* Scan for the network */
+            SendSpecificSSIDScan(priv, &reqSSID);
+
+            /* Search for the requested SSID in the scan table */
+            i = FindSSIDInList(Adapter, &reqSSID, NULL, Wlan802_11IBSS);
+        }
+
+        if (i >= 0) {
+            PRINTM(INFO, "SSID found at %d in List, so join\n", i);
+            JoinAdhocNetwork(priv, &Adapter->ScanTable[i]);
+        } else {
+            /* else send START command */
+            PRINTM(INFO, "SSID not found in list, "
+                   "so creating adhoc with ssid = %s\n", reqSSID.Ssid);
+
+            StartAdhocNetwork(priv, &reqSSID);
+        }                       /* end of else (START command) */
+    }                           /* end of else (Ad hoc mode) */
+
+    /*
+     * The MediaConnectStatus change can be removed later when
+     *   the ret code is being properly returned.
+     */
+    /* Check to see if we successfully connected */
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        ret = WLAN_STATUS_SUCCESS;
+    } else {
+        ret = -ENETDOWN;
+    }
+
+  setessid_ret:
+#ifdef REASSOCIATION
+    OS_REL_SEMAPHORE(&Adapter->ReassocSem);
+#endif
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Connect to the AP or Ad-hoc Network with specific bssid
+ *
+ * NOTE: Scan should be issued by application before this function is called
+ *
+ *  @param dev          A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param awrq         A pointer to iw_param structure
+ *  @param extra        A pointer to extra data buf
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_set_wap(struct net_device *dev, struct iw_request_info *info,
+             struct sockaddr *awrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    const u8 bcast[ETH_ALEN] = { 255, 255, 255, 255, 255, 255 };
+    u8 reqBSSID[ETH_ALEN];
+    int i;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    /* Clear any past association response stored for application retrieval */
+    Adapter->assocRspSize = 0;
+
+    if (awrq->sa_family != ARPHRD_ETHER)
+        return -EINVAL;
+
+    PRINTM(INFO, "ASSOC: WAP: sa_data: %02x:%02x:%02x:%02x:%02x:%02x\n",
+           (u8) awrq->sa_data[0], (u8) awrq->sa_data[1],
+           (u8) awrq->sa_data[2], (u8) awrq->sa_data[3],
+           (u8) awrq->sa_data[4], (u8) awrq->sa_data[5]);
+#ifdef REASSOCIATION
+    // cancel re-association timer if there's one
+    if (Adapter->ReassocTimerIsSet == TRUE) {
+        CancelTimer(&Adapter->MrvDrvTimer);
+        Adapter->ReassocTimerIsSet = FALSE;
+    }
+#endif /* REASSOCIATION */
+
+    if (!memcmp(bcast, awrq->sa_data, ETH_ALEN)) {
+        i = FindBestSSIDInList(Adapter);
+    } else {
+        if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+            if (memcmp
+                (awrq->sa_data,
+                 Adapter->CurBssParams.BSSDescriptor.MacAddress,
+                 ETH_ALEN) == 0)
+                return WLAN_STATUS_SUCCESS;
+        }
+        memcpy(reqBSSID, awrq->sa_data, ETH_ALEN);
+
+        PRINTM(INFO, "ASSOC: WAP: Bssid = %02x:%02x:%02x:%02x:%02x:%02x\n",
+               reqBSSID[0], reqBSSID[1], reqBSSID[2],
+               reqBSSID[3], reqBSSID[4], reqBSSID[5]);
+
+        /* Search for index position in list for requested MAC */
+        i = FindBSSIDInList(Adapter, reqBSSID, Adapter->InfrastructureMode);
+    }
+
+    if (i < 0) {
+        PRINTM(INFO, "ASSOC: WAP: MAC address not found in BSSID List\n");
+        return -ENETUNREACH;
+    }
+
+    if (Adapter->InfrastructureMode == Wlan802_11Infrastructure) {
+
+        ret = wlan_associate(priv, &Adapter->ScanTable[i]);
+
+        if (ret) {
+            LEAVE();
+            return ret;
+        }
+    } else {
+        if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+            /* Exit Adhoc mode */
+            ret = StopAdhocNetwork(priv);
+
+            if (ret) {
+                LEAVE();
+                return ret;
+            }
+        }
+        Adapter->AdhocLinkSensed = FALSE;
+
+        JoinAdhocNetwork(priv, &Adapter->ScanTable[i]);
+    }
+
+    /* Check to see if we successfully connected */
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        ret = WLAN_STATUS_SUCCESS;
+    } else {
+        ret = -ENETDOWN;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Associated to a specific BSS discovered in a scan
+ *
+ *  @param priv      A pointer to wlan_private structure
+ *  @param pBSSDesc  Pointer to the BSS descriptor to associate with.
+ *
+ *  @return          WLAN_STATUS_SUCCESS-success, otherwise fail
+ */
+int
+wlan_associate(wlan_private * priv, BSSDescriptor_t * pBSSDesc)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int enableData = TRUE;
+    union iwreq_data wrqu;
+    int ret;
+    IEEEtypes_AssocRsp_t *pAssocRsp;
+    u8 currentBSSID[MRVDRV_ETH_ADDR_LEN];
+    int reassocAttempt = FALSE;
+
+    ENTER();
+
+    /* Return error if the Adapter or table entry is not marked as infra */
+    if ((Adapter->InfrastructureMode != Wlan802_11Infrastructure)
+        || (pBSSDesc->InfrastructureMode != Wlan802_11Infrastructure)) {
+        LEAVE();
+        return -EINVAL;
+    }
+
+    memcpy(&currentBSSID,
+           &Adapter->CurBssParams.BSSDescriptor.MacAddress,
+           sizeof(currentBSSID));
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        reassocAttempt = TRUE;
+        PRINTM(INFO, "Attempting reassociation, stopping wmm queues\n");
+        wmm_stop_queue(priv);
+    }
+
+    /* Clear any past association response stored for application retrieval */
+    Adapter->assocRspSize = 0;
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_ASSOCIATE,
+                                0, HostCmd_OPTION_WAITFORRSP, 0, pBSSDesc);
+
+    if (Adapter->wmm.enabled) {
+        /* Don't re-enable carrier until we get the WMM_GET_STATUS event */
+        enableData = FALSE;
+    } else {
+        /* Since WMM is not enabled, setup the queues with the defaults */
+        wmm_setup_queues(priv);
+    }
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+
+        if (reassocAttempt
+            && (memcmp(&currentBSSID,
+                       &Adapter->CurBssParams.BSSDescriptor.MacAddress,
+                       sizeof(currentBSSID)) == 0)) {
+
+            /* Reassociation attempt failed, still associated to old AP,
+             **   no need to wait for WMM notification to restart data
+             */
+            enableData = TRUE;
+        }
+        if (enableData) {
+            PRINTM(INFO, "Post association, re-enabling data flow\n");
+            wmm_start_queue(priv);
+            os_carrier_on(priv);
+            os_start_queue(priv);
+        }
+    } else {
+        PRINTM(INFO, "Post association, stopping data flow\n");
+        os_carrier_off(priv);
+        os_stop_queue(priv);
+    }
+
+    memcpy(wrqu.ap_addr.sa_data,
+           &Adapter->CurBssParams.BSSDescriptor.MacAddress, ETH_ALEN);
+    wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+    wireless_send_event(priv->wlan_dev.netdev, SIOCGIWAP, &wrqu, NULL);
+
+    pAssocRsp = (IEEEtypes_AssocRsp_t *) Adapter->assocRspBuffer;
+
+    if (ret || pAssocRsp->StatusCode) {
+        ret = -ENETUNREACH;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Associated to a specific indexed entry in the ScanTable
+ *
+ *  @param priv      A pointer to wlan_private structure
+ *  @param tableIdx  Index into the ScanTable to associate to, index parameter
+ *                   base value is 1.  No scanning is done before the 
+ *                   association attempt.
+ *
+ *  @return          WLAN_STATUS_SUCCESS-success, otherwise fail
+ */
+int
+wlan_associate_to_table_idx(wlan_private * priv, int tableIdx)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret;
+
+    ENTER();
+
+#ifdef REASSOCIATION
+    if (OS_ACQ_SEMAPHORE_BLOCK(&Adapter->ReassocSem)) {
+        PRINTM(ERROR, "Acquire semaphore error\n");
+        return -EBUSY;
+    }
+#endif
+
+    PRINTM(INFO, "ASSOC: iwpriv: Index = %d, NumInScanTable = %d\n",
+           tableIdx, Adapter->NumInScanTable);
+
+    /* Check index in table, subtract 1 if within range and call association
+     *   sub-function.  ScanTable[] is 0 based, parameter is 1 based to
+     *   conform with IW_ENCODE_INDEX flag parameter passing in iwconfig/iwlist
+     */
+    if (tableIdx && (tableIdx <= Adapter->NumInScanTable)) {
+        ret = wlan_associate(priv, &Adapter->ScanTable[tableIdx - 1]);
+    } else {
+        ret = -EINVAL;
+    }
+
+#ifdef REASSOCIATION
+    OS_REL_SEMAPHORE(&Adapter->ReassocSem);
+#endif
+    LEAVE();
+
+    return ret;
+}
+
+/**
+ *  @brief Start an Adhoc Network
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param AdhocSSID    The ssid of the Adhoc Network
+ *  @return             WLAN_STATUS_SUCCESS--success, WLAN_STATUS_FAILURE--fail
+ */
+int
+StartAdhocNetwork(wlan_private * priv, WLAN_802_11_SSID * AdhocSSID)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    Adapter->AdhocCreate = TRUE;
+
+    PRINTM(INFO, "Adhoc Channel = %d\n", Adapter->AdhocChannel);
+    PRINTM(INFO, "CurBssParams.channel = %d\n",
+           Adapter->CurBssParams.BSSDescriptor.Channel);
+    PRINTM(INFO, "CurBssParams.band = %d\n", Adapter->CurBssParams.band);
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_AD_HOC_START,
+                                0, HostCmd_OPTION_WAITFORRSP, 0, AdhocSSID);
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Join an adhoc network found in a previous scan
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param pBSSDesc     Pointer to a BSS descriptor found in a previous scan
+ *                      to attempt to join
+ *
+ *  @return             WLAN_STATUS_SUCCESS--success, WLAN_STATUS_FAILURE--fail
+ */
+int
+JoinAdhocNetwork(wlan_private * priv, BSSDescriptor_t * pBSSDesc)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    PRINTM(INFO, "JoinAdhocNetwork: CurBss.ssid =%s\n",
+           Adapter->CurBssParams.BSSDescriptor.Ssid.Ssid);
+    PRINTM(INFO, "JoinAdhocNetwork: CurBss.ssid_len =%u\n",
+           Adapter->CurBssParams.BSSDescriptor.Ssid.SsidLength);
+    PRINTM(INFO, "JoinAdhocNetwork: ssid =%s\n", pBSSDesc->Ssid.Ssid);
+    PRINTM(INFO, "JoinAdhocNetwork: ssid len =%u\n",
+           pBSSDesc->Ssid.SsidLength);
+
+    /* check if the requested SSID is already joined */
+    if (Adapter->CurBssParams.BSSDescriptor.Ssid.SsidLength
+        && !SSIDcmp(&pBSSDesc->Ssid,
+                    &Adapter->CurBssParams.BSSDescriptor.Ssid)
+        && (Adapter->CurBssParams.BSSDescriptor.InfrastructureMode ==
+            Wlan802_11IBSS)) {
+
+        PRINTM(INFO,
+               "ADHOC_J_CMD: New ad-hoc SSID is the same as current, "
+               "not attempting to re-join");
+
+        return WLAN_STATUS_FAILURE;
+    }
+
+    PRINTM(INFO, "CurBssParams.channel = %d\n",
+           Adapter->CurBssParams.BSSDescriptor.Channel);
+    PRINTM(INFO, "CurBssParams.band = %c\n", Adapter->CurBssParams.band);
+
+    Adapter->AdhocCreate = FALSE;
+
+    // store the SSID info temporarily
+    memset(&Adapter->AttemptedSSIDBeforeScan, 0, sizeof(WLAN_802_11_SSID));
+    memcpy(&Adapter->AttemptedSSIDBeforeScan,
+           &pBSSDesc->Ssid, sizeof(WLAN_802_11_SSID));
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_AD_HOC_JOIN,
+                                0, HostCmd_OPTION_WAITFORRSP, 0, pBSSDesc);
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Stop the Adhoc Network
+ *
+ *  @param priv      A pointer to wlan_private structure
+ *  @return          WLAN_STATUS_SUCCESS--success, WLAN_STATUS_FAILURE--fail
+ */
+int
+StopAdhocNetwork(wlan_private * priv)
+{
+    return PrepareAndSendCommand(priv, HostCmd_CMD_802_11_AD_HOC_STOP,
+                                 0, HostCmd_OPTION_WAITFORRSP, 0, NULL);
+}
+
+/**
+ *  @brief Send Deauthentication Request
+ *
+ *  @param priv      A pointer to wlan_private structure
+ *  @return          WLAN_STATUS_SUCCESS--success, WLAN_STATUS_FAILURE--fail
+ */
+int
+SendDeauthentication(wlan_private * priv)
+{
+    return PrepareAndSendCommand(priv, HostCmd_CMD_802_11_DEAUTHENTICATE,
+                                 0, HostCmd_OPTION_WAITFORRSP, 0, NULL);
+}
+
+/**
+ *  @brief Set Idle Off
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlanidle_off(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    const u8 zeroMac[] = { 0, 0, 0, 0, 0, 0 };
+    int i;
+
+    ENTER();
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateDisconnected) {
+        if (Adapter->InfrastructureMode == Wlan802_11Infrastructure) {
+            if (memcmp(Adapter->PreviousBSSID, zeroMac, sizeof(zeroMac)) != 0) {
+
+                PRINTM(INFO, "Previous SSID = %s\n",
+                       Adapter->PreviousSSID.Ssid);
+                PRINTM(INFO, "Previous BSSID = "
+                       "%02x:%02x:%02x:%02x:%02x:%02x:\n",
+                       Adapter->PreviousBSSID[0], Adapter->PreviousBSSID[1],
+                       Adapter->PreviousBSSID[2], Adapter->PreviousBSSID[3],
+                       Adapter->PreviousBSSID[4], Adapter->PreviousBSSID[5]);
+
+                i = FindSSIDInList(Adapter,
+                                   &Adapter->PreviousSSID,
+                                   Adapter->PreviousBSSID,
+                                   Adapter->InfrastructureMode);
+
+                if (i < 0) {
+                    SendSpecificBSSIDScan(priv, Adapter->PreviousBSSID);
+                    i = FindSSIDInList(Adapter,
+                                       &Adapter->PreviousSSID,
+                                       Adapter->PreviousBSSID,
+                                       Adapter->InfrastructureMode);
+                }
+
+                if (i < 0) {
+                    /* If the BSSID could not be found, try just the SSID */
+                    i = FindSSIDInList(Adapter,
+                                       &Adapter->PreviousSSID,
+                                       NULL, Adapter->InfrastructureMode);
+                }
+
+                if (i < 0) {
+                    SendSpecificSSIDScan(priv, &Adapter->PreviousSSID);
+                    i = FindSSIDInList(Adapter,
+                                       &Adapter->PreviousSSID,
+                                       NULL, Adapter->InfrastructureMode);
+                }
+
+                if (i >= 0) {
+                    ret = wlan_associate(priv, &Adapter->ScanTable[i]);
+                }
+            }
+        } else if (Adapter->InfrastructureMode == Wlan802_11IBSS) {
+            ret = PrepareAndSendCommand(priv,
+                                        HostCmd_CMD_802_11_AD_HOC_START,
+                                        0, HostCmd_OPTION_WAITFORRSP,
+                                        0, &Adapter->PreviousSSID);
+        }
+    }
+    /* else it is connected */
+
+    PRINTM(INFO, "\nwlanidle is off");
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Set Idle On
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlanidle_on(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        if (Adapter->InfrastructureMode == Wlan802_11Infrastructure) {
+            PRINTM(INFO, "Previous SSID = %s\n", Adapter->PreviousSSID.Ssid);
+            memcpy(&Adapter->PreviousSSID,
+                   &Adapter->CurBssParams.BSSDescriptor.Ssid,
+                   sizeof(WLAN_802_11_SSID));
+            SendDeauthentication(priv);
+
+        } else if (Adapter->InfrastructureMode == Wlan802_11IBSS) {
+            ret = StopAdhocNetwork(priv);
+        }
+
+    }
+#ifdef REASSOCIATION
+    if (Adapter->ReassocTimerIsSet == TRUE) {
+        CancelTimer(&Adapter->MrvDrvTimer);
+        Adapter->ReassocTimerIsSet = FALSE;
+    }
+#endif /* REASSOCIATION */
+
+    PRINTM(INFO, "\nwlanidle is on");
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Append a generic IE as a passthrough TLV to a TLV buffer.
+ *
+ *  This function is called from the network join command prep. routine. 
+ *    If the IE buffer has been setup by the application, this routine appends
+ *    the buffer as a passthrough TLV type to the request.
+ *
+ *  @param priv     A pointer to wlan_private structure
+ *  @param ppBuffer pointer to command buffer pointer
+ *
+ *  @return         bytes added to the buffer
+ */
+static int
+wlan_cmd_append_generic_ie(wlan_private * priv, u8 ** ppBuffer)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int retLen = 0;
+    MrvlIEtypesHeader_t ieHeader;
+
+    /* Null Checks */
+    if (ppBuffer == 0)
+        return 0;
+    if (*ppBuffer == 0)
+        return 0;
+
+    /*
+     * If there is a generic ie buffer setup, append it to the return
+     *   parameter buffer pointer.
+     */
+    if (Adapter->genIeBufferLen) {
+        PRINTM(INFO, "append generic %d to %p\n", Adapter->genIeBufferLen,
+               *ppBuffer);
+
+        /* Wrap the generic IE buffer with a passthrough TLV type */
+        ieHeader.Type = wlan_cpu_to_le16(TLV_TYPE_PASSTHROUGH);
+        ieHeader.Len = wlan_cpu_to_le16(Adapter->genIeBufferLen);
+        memcpy(*ppBuffer, &ieHeader, sizeof(ieHeader));
+
+        /* Increment the return size and the return buffer pointer param */
+        *ppBuffer += sizeof(ieHeader);
+        retLen += sizeof(ieHeader);
+
+        /* Copy the generic IE buffer to the output buffer, advance pointer */
+        memcpy(*ppBuffer, Adapter->genIeBuffer, Adapter->genIeBufferLen);
+
+        /* Increment the return size and the return buffer pointer param */
+        *ppBuffer += Adapter->genIeBufferLen;
+        retLen += Adapter->genIeBufferLen;
+
+        /* Reset the generic IE buffer */
+        Adapter->genIeBufferLen = 0;
+    }
+
+    /* return the length appended to the buffer */
+    return retLen;
+}
+
+/**
+ *  @brief Append any application provided Marvell TLVs to a TLV buffer.
+ *
+ *  This function is called from the network join command prep. routine. 
+ *    If the Marvell TLV buffer has been setup by the application, this routine
+ *    appends the buffer to the request.
+ *
+ *  @param priv     A pointer to wlan_private structure
+ *  @param ppBuffer pointer to command buffer pointer
+ *
+ *  @return         bytes added to the buffer
+ */
+static int
+wlan_cmd_append_marvell_tlv(wlan_private * priv, u8 ** ppBuffer)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int retLen = 0;
+
+    /* Null Checks */
+    if (ppBuffer == 0)
+        return 0;
+    if (*ppBuffer == 0)
+        return 0;
+
+    /*
+     * If there is a Marvell TLV buffer setup, append it to the return
+     *   parameter buffer pointer.
+     */
+    if (Adapter->mrvlAssocTlvBufferLen) {
+        PRINTM(INFO, "append tlv %d to %p\n",
+               Adapter->mrvlAssocTlvBufferLen, *ppBuffer);
+
+        /* Copy the TLV buffer to the output buffer, advance pointer */
+        memcpy(*ppBuffer,
+               Adapter->mrvlAssocTlvBuffer, Adapter->mrvlAssocTlvBufferLen);
+
+        /* Increment the return size and the return buffer pointer param */
+        *ppBuffer += Adapter->mrvlAssocTlvBufferLen;
+        retLen += Adapter->mrvlAssocTlvBufferLen;
+
+        /* Reset the Marvell TLV buffer */
+        Adapter->mrvlAssocTlvBufferLen = 0;
+    }
+
+    /* return the length appended to the buffer */
+    return retLen;
+}
+
+/**
+ *  @brief Append TSF tracking info from the scan table for the target AP
+ *
+ *  This function is called from the network join command prep. routine. 
+ *    The TSF table TSF sent to the firmware contians two TSF values:
+ *      - the TSF of the target AP from its previous beacon/probe response
+ *      - the TSF timestamp of our local MAC at the time we observed the
+ *        beacon/probe response.
+ *
+ *    The firmware uses the timestamp values to set an initial TSF value
+ *      in the MAC for the new association after a reassociation attempt.
+ *
+ *  @param priv     A pointer to wlan_private structure
+ *  @param ppBuffer A pointer to command buffer pointer
+ *  @param pBSSDesc A pointer to the BSS Descriptor from the scan table of
+ *                  the AP we are trying to join
+ *
+ *  @return         bytes added to the buffer
+ */
+static int
+wlan_cmd_append_tsf_tlv(wlan_private * priv, u8 ** ppBuffer,
+                        BSSDescriptor_t * pBSSDesc)
+{
+    MrvlIEtypes_TsfTimestamp_t tsfTlv;
+    u64 tsfVal;
+
+    /* Null Checks */
+    if (ppBuffer == 0)
+        return 0;
+    if (*ppBuffer == 0)
+        return 0;
+
+    memset(&tsfTlv, 0x00, sizeof(MrvlIEtypes_TsfTimestamp_t));
+
+    tsfTlv.Header.Type = wlan_cpu_to_le16(TLV_TYPE_TSFTIMESTAMP);
+    tsfTlv.Header.Len = wlan_cpu_to_le16(2 * sizeof(tsfVal));
+
+    memcpy(*ppBuffer, &tsfTlv, sizeof(tsfTlv.Header));
+    *ppBuffer += sizeof(tsfTlv.Header);
+
+    /* TSF timestamp from the firmware TSF when the bcn/prb rsp was received */
+    tsfVal = wlan_cpu_to_le64(pBSSDesc->networkTSF);
+    memcpy(*ppBuffer, &tsfVal, sizeof(tsfVal));
+    *ppBuffer += sizeof(tsfVal);
+
+    memcpy(&tsfVal, pBSSDesc->TimeStamp, sizeof(tsfVal));
+
+    PRINTM(INFO, "ASSOC: TSF offset calc: %016llx - %016llx\n",
+           tsfVal, pBSSDesc->networkTSF);
+
+    tsfVal = wlan_cpu_to_le64(tsfVal);
+    memcpy(*ppBuffer, &tsfVal, sizeof(tsfVal));
+    *ppBuffer += sizeof(tsfVal);
+
+    return (sizeof(tsfTlv.Header) + (2 * sizeof(tsfVal)));
+}
+
+/**
+ *  @brief This function prepares command of deauthenticate.
+ *
+ *  @param priv     A pointer to wlan_private structure
+ *  @param cmd      A pointer to HostCmd_DS_COMMAND structure
+ *  @return         WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_cmd_802_11_deauthenticate(wlan_private * priv, HostCmd_DS_COMMAND * cmd)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_DEAUTHENTICATE *dauth = &cmd->params.deauth;
+
+    ENTER();
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_DEAUTHENTICATE);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_DEAUTHENTICATE) + S_DS_GEN);
+
+    /* set AP MAC address */
+    memcpy(dauth->MacAddr,
+           &Adapter->CurBssParams.BSSDescriptor.MacAddress, ETH_ALEN);
+
+    /* Reason code 3 = Station is leaving */
+#define REASON_CODE_STA_LEAVING 3
+    dauth->ReasonCode = wlan_cpu_to_le16(REASON_CODE_STA_LEAVING);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function prepares command of association.
+ *
+ *  @param priv      A pointer to wlan_private structure
+ *  @param cmd       A pointer to HostCmd_DS_COMMAND structure
+ *  @param pdata_buf Void cast of BSSDescriptor_t from the scan table to assoc
+ *  @return          WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_cmd_802_11_associate(wlan_private * priv,
+                          HostCmd_DS_COMMAND * cmd, void *pdata_buf)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_ASSOCIATE *pAsso = &cmd->params.associate;
+    int ret = WLAN_STATUS_SUCCESS;
+    BSSDescriptor_t *pBSSDesc;
+    WLAN_802_11_RATES rates;
+    int ratesSize;
+    u8 *pos;
+    u16 TmpCap;
+    MrvlIEtypes_SsIdParamSet_t *pSsidTlv;
+    MrvlIEtypes_PhyParamSet_t *pPhyTlv;
+    MrvlIEtypes_SsParamSet_t *pSsTlv;
+    MrvlIEtypes_RatesParamSet_t *pRatesTlv;
+    MrvlIEtypes_AuthType_t *pAuthTlv;
+    MrvlIEtypes_RsnParamSet_t *pRsnTlv;
+
+    ENTER();
+
+    pBSSDesc = (BSSDescriptor_t *) pdata_buf;
+    pos = (u8 *) pAsso;
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_ASSOCIATE);
+
+    /* Save so we know which BSS Desc to use in the response handler */
+    Adapter->pAttemptedBSSDesc = pBSSDesc;
+
+    memcpy(pAsso->PeerStaAddr,
+           pBSSDesc->MacAddress, sizeof(pAsso->PeerStaAddr));
+    pos += sizeof(pAsso->PeerStaAddr);
+
+    /* set the listen interval */
+    pAsso->ListenInterval = wlan_cpu_to_le16(Adapter->ListenInterval);
+
+    pos += sizeof(pAsso->CapInfo);
+    pos += sizeof(pAsso->ListenInterval);
+    pos += sizeof(pAsso->Reserved1);
+
+    pSsidTlv = (MrvlIEtypes_SsIdParamSet_t *) pos;
+    pSsidTlv->Header.Type = wlan_cpu_to_le16(TLV_TYPE_SSID);
+    pSsidTlv->Header.Len = pBSSDesc->Ssid.SsidLength;
+    memcpy(pSsidTlv->SsId, pBSSDesc->Ssid.Ssid, pSsidTlv->Header.Len);
+    pos += sizeof(pSsidTlv->Header) + pSsidTlv->Header.Len;
+    pSsidTlv->Header.Len = wlan_cpu_to_le16(pSsidTlv->Header.Len);
+
+    pPhyTlv = (MrvlIEtypes_PhyParamSet_t *) pos;
+    pPhyTlv->Header.Type = wlan_cpu_to_le16(TLV_TYPE_PHY_DS);
+    pPhyTlv->Header.Len = sizeof(pPhyTlv->fh_ds.DsParamSet);
+    memcpy(&pPhyTlv->fh_ds.DsParamSet,
+           &pBSSDesc->PhyParamSet.DsParamSet.CurrentChan,
+           sizeof(pPhyTlv->fh_ds.DsParamSet));
+    pos += sizeof(pPhyTlv->Header) + pPhyTlv->Header.Len;
+    pPhyTlv->Header.Len = wlan_cpu_to_le16(pPhyTlv->Header.Len);
+
+    pSsTlv = (MrvlIEtypes_SsParamSet_t *) pos;
+    pSsTlv->Header.Type = wlan_cpu_to_le16(TLV_TYPE_CF);
+    pSsTlv->Header.Len = sizeof(pSsTlv->cf_ibss.CfParamSet);
+    pos += sizeof(pSsTlv->Header) + pSsTlv->Header.Len;
+    pSsTlv->Header.Len = wlan_cpu_to_le16(pSsTlv->Header.Len);
+
+    /* Get the common rates supported between the driver and the BSS Desc */
+    if (setup_rates_from_bssdesc(Adapter, pBSSDesc, rates, &ratesSize)) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    /* Setup the Rates TLV in the association command */
+    pRatesTlv = (MrvlIEtypes_RatesParamSet_t *) pos;
+    pRatesTlv->Header.Type = wlan_cpu_to_le16(TLV_TYPE_RATES);
+    pRatesTlv->Header.Len = wlan_cpu_to_le16(ratesSize);
+    memcpy(pRatesTlv->Rates, rates, ratesSize);
+    pos += sizeof(pRatesTlv->Header) + ratesSize;
+    PRINTM(INFO, "ASSOC_CMD: Rates size = %d\n", ratesSize);
+
+    /* Add the Authentication type to be used for Auth frames if needed */
+    pAuthTlv = (MrvlIEtypes_AuthType_t *) pos;
+    pAuthTlv->Header.Type = wlan_cpu_to_le16(TLV_TYPE_AUTH_TYPE);
+    pAuthTlv->Header.Len = sizeof(pAuthTlv->AuthType);
+    pAuthTlv->AuthType = Adapter->SecInfo.AuthenticationMode;
+    pos += sizeof(pAuthTlv->Header) + pAuthTlv->Header.Len;
+    pAuthTlv->Header.Len = wlan_cpu_to_le16(pAuthTlv->Header.Len);
+
+    if (!Adapter->wps.SessionEnable) {
+        if (Adapter->SecInfo.WPAEnabled || Adapter->SecInfo.WPA2Enabled) {
+            pRsnTlv = (MrvlIEtypes_RsnParamSet_t *) pos;
+            pRsnTlv->Header.Type = (u16) Adapter->Wpa_ie[0];    /* WPA_IE or WPA2_IE */
+            pRsnTlv->Header.Type = pRsnTlv->Header.Type & 0x00FF;
+            pRsnTlv->Header.Type = wlan_cpu_to_le16(pRsnTlv->Header.Type);
+            pRsnTlv->Header.Len = (u16) Adapter->Wpa_ie[1];
+            pRsnTlv->Header.Len = pRsnTlv->Header.Len & 0x00FF;
+            if (pRsnTlv->Header.Len <= (sizeof(Adapter->Wpa_ie) - 2)) {
+                memcpy(pRsnTlv->RsnIE, &Adapter->Wpa_ie[2],
+                       pRsnTlv->Header.Len);
+            } else {
+                ret = WLAN_STATUS_FAILURE;
+                goto done;
+            }
+
+            HEXDUMP("ASSOC_CMD: RSN IE", (u8 *) pRsnTlv,
+                    sizeof(pRsnTlv->Header) + pRsnTlv->Header.Len);
+            pos += sizeof(pRsnTlv->Header) + pRsnTlv->Header.Len;
+            pRsnTlv->Header.Len = wlan_cpu_to_le16(pRsnTlv->Header.Len);
+        }
+    }
+
+    wlan_wmm_process_association_req(priv, &pos, &pBSSDesc->wmmIE);
+
+    wlan_cmd_append_generic_ie(priv, &pos);
+
+    wlan_cmd_append_marvell_tlv(priv, &pos);
+
+    wlan_cmd_append_tsf_tlv(priv, &pos, pBSSDesc);
+
+    if (wlan_create_dnld_countryinfo_11d(priv, 0)) {
+        PRINTM(INFO, "Dnld_countryinfo_11d failed\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+    if (wlan_parse_dnld_countryinfo_11d(priv)) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    cmd->Size = wlan_cpu_to_le16((u16) (pos - (u8 *) pAsso) + S_DS_GEN);
+
+    /* set the Capability info at last */
+    memcpy(&TmpCap, &pBSSDesc->Cap, sizeof(pAsso->CapInfo));
+    TmpCap &= CAPINFO_MASK;
+    PRINTM(INFO, "ASSOC_CMD: TmpCap=%4X CAPINFO_MASK=%4X\n",
+           TmpCap, CAPINFO_MASK);
+    TmpCap = wlan_cpu_to_le16(TmpCap);
+    memcpy(&pAsso->CapInfo, &TmpCap, sizeof(pAsso->CapInfo));
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function prepares command of ad_hoc_start.
+ *
+ *  @param priv     A pointer to wlan_private structure
+ *  @param cmd      A pointer to HostCmd_DS_COMMAND structure
+ *  @param pssid    A pointer to WLAN_802_11_SSID structure
+ *  @return         WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_cmd_802_11_ad_hoc_start(wlan_private * priv,
+                             HostCmd_DS_COMMAND * cmd, void *pssid)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_AD_HOC_START *adhs = &cmd->params.ads;
+    int ret = WLAN_STATUS_SUCCESS;
+    int cmdAppendSize = 0;
+    int i;
+    u16 TmpCap;
+    BSSDescriptor_t *pBSSDesc;
+
+    ENTER();
+
+    if (!Adapter) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_START);
+
+    pBSSDesc = &Adapter->CurBssParams.BSSDescriptor;
+    Adapter->pAttemptedBSSDesc = pBSSDesc;
+
+    /*
+     * Fill in the parameters for 2 data structures:
+     *   1. HostCmd_DS_802_11_AD_HOC_START Command
+     *   2. pBSSDesc
+     *
+     * Driver will fill up SSID, BSSType,IBSS param, Physical Param,
+     *   probe delay, and Cap info.
+     *
+     * Firmware will fill up beacon period, Basic rates
+     *   and operational rates.
+     */
+
+    memset(adhs->SSID, 0, MRVDRV_MAX_SSID_LENGTH);
+
+    memcpy(adhs->SSID, ((WLAN_802_11_SSID *) pssid)->Ssid,
+           ((WLAN_802_11_SSID *) pssid)->SsidLength);
+
+    PRINTM(INFO, "ADHOC_S_CMD: SSID = %s\n", adhs->SSID);
+
+    memset(pBSSDesc->Ssid.Ssid, 0, MRVDRV_MAX_SSID_LENGTH);
+    memcpy(pBSSDesc->Ssid.Ssid,
+           ((WLAN_802_11_SSID *) pssid)->Ssid,
+           ((WLAN_802_11_SSID *) pssid)->SsidLength);
+
+    pBSSDesc->Ssid.SsidLength = ((WLAN_802_11_SSID *) pssid)->SsidLength;
+
+    /* set the BSS type */
+    adhs->BSSType = HostCmd_BSS_TYPE_IBSS;
+    pBSSDesc->InfrastructureMode = Wlan802_11IBSS;
+    adhs->BeaconPeriod = wlan_cpu_to_le16(Adapter->BeaconPeriod);
+    pBSSDesc->BeaconPeriod = Adapter->BeaconPeriod;
+
+    /* set Physical param set */
+#define DS_PARA_IE_ID   3
+#define DS_PARA_IE_LEN  1
+
+    adhs->PhyParamSet.DsParamSet.ElementId = DS_PARA_IE_ID;
+    adhs->PhyParamSet.DsParamSet.Len = DS_PARA_IE_LEN;
+
+    if (!get_cfp_by_band_and_channel
+        (0, (u16) Adapter->AdhocChannel, Adapter->region_channel)) {
+        CHANNEL_FREQ_POWER *cfp;
+        cfp =
+            get_cfp_by_band_and_channel(0, FIRST_VALID_CHANNEL,
+                                        Adapter->region_channel);
+        if (cfp)
+            Adapter->AdhocChannel = cfp->Channel;
+    }
+
+    ASSERT(Adapter->AdhocChannel);
+
+    PRINTM(INFO, "ADHOC_S_CMD: Creating ADHOC on Channel %d\n",
+           Adapter->AdhocChannel);
+
+    Adapter->CurBssParams.BSSDescriptor.Channel = Adapter->AdhocChannel;
+
+    pBSSDesc->Channel = Adapter->AdhocChannel;
+    adhs->PhyParamSet.DsParamSet.CurrentChan = Adapter->AdhocChannel;
+
+    memcpy(&pBSSDesc->PhyParamSet,
+           &adhs->PhyParamSet, sizeof(IEEEtypes_PhyParamSet_t));
+
+    pBSSDesc->NetworkTypeInUse = Wlan802_11DS;
+
+    /* set IBSS param set */
+#define IBSS_PARA_IE_ID   6
+#define IBSS_PARA_IE_LEN  2
+
+    adhs->SsParamSet.IbssParamSet.ElementId = IBSS_PARA_IE_ID;
+    adhs->SsParamSet.IbssParamSet.Len = IBSS_PARA_IE_LEN;
+    adhs->SsParamSet.IbssParamSet.AtimWindow
+        = wlan_cpu_to_le16(Adapter->AtimWindow);
+    pBSSDesc->ATIMWindow = Adapter->AtimWindow;
+    memcpy(&pBSSDesc->SsParamSet,
+           &adhs->SsParamSet, sizeof(IEEEtypes_SsParamSet_t));
+
+    /* set Capability info */
+    adhs->Cap.Ess = 0;
+    adhs->Cap.Ibss = 1;
+    pBSSDesc->Cap.Ibss = 1;
+
+    /* set up privacy in pBSSDesc */
+    if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPEnabled
+        || Adapter->AdhocAESEnabled) {
+
+#define AD_HOC_CAP_PRIVACY_ON 1
+        PRINTM(INFO, "ADHOC_S_CMD: WEPStatus set, Privacy to WEP\n");
+        pBSSDesc->Privacy = Wlan802_11PrivFilter8021xWEP;
+        adhs->Cap.Privacy = AD_HOC_CAP_PRIVACY_ON;
+    } else {
+        PRINTM(INFO, "ADHOC_S_CMD: WEPStatus NOT set, Setting "
+               "Privacy to ACCEPT ALL\n");
+        pBSSDesc->Privacy = Wlan802_11PrivFilterAcceptAll;
+    }
+
+    memset(adhs->DataRate, 0, sizeof(adhs->DataRate));
+
+    if (Adapter->adhoc_grate_enabled == TRUE) {
+        memcpy(adhs->DataRate, AdhocRates_G,
+               MIN(sizeof(adhs->DataRate), sizeof(AdhocRates_G)));
+        if (Adapter->
+            CurrentPacketFilter & HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON) {
+            ret =
+                PrepareAndSendCommand(priv, HostCmd_CMD_MAC_CONTROL, 0,
+                                      HostCmd_OPTION_WAITFORRSP, 0,
+                                      &Adapter->CurrentPacketFilter);
+            if (ret) {
+                PRINTM(INFO, "ADHOC_S_CMD: G Protection config failed\n");
+                ret = WLAN_STATUS_FAILURE;
+                goto done;
+            }
+        }
+    } else {
+        memcpy(adhs->DataRate, AdhocRates_B,
+               MIN(sizeof(adhs->DataRate), sizeof(AdhocRates_B)));
+    }
+
+    /* Find the last non zero */
+    for (i = 0; i < sizeof(adhs->DataRate) && adhs->DataRate[i]; i++);
+
+    Adapter->CurBssParams.NumOfRates = i;
+
+    /* Copy the ad-hoc creating rates into Current BSS state structure */
+    memcpy(&Adapter->CurBssParams.DataRates,
+           &adhs->DataRate, Adapter->CurBssParams.NumOfRates);
+
+    PRINTM(INFO, "ADHOC_S_CMD: Rates=%02x %02x %02x %02x \n",
+           adhs->DataRate[0], adhs->DataRate[1],
+           adhs->DataRate[2], adhs->DataRate[3]);
+
+    PRINTM(INFO, "ADHOC_S_CMD: AD HOC Start command is ready\n");
+
+    if (wlan_create_dnld_countryinfo_11d(priv, Adapter->CurBssParams.band)) {
+        PRINTM(INFO, "ADHOC_S_CMD: dnld_countryinfo_11d failed\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_AD_HOC_START)
+                                 + S_DS_GEN + cmdAppendSize);
+
+    memcpy(&TmpCap, &adhs->Cap, sizeof(u16));
+    TmpCap = wlan_cpu_to_le16(TmpCap);
+    memcpy(&adhs->Cap, &TmpCap, sizeof(u16));
+
+    ret = WLAN_STATUS_SUCCESS;
+  done:
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function prepares command of ad_hoc_stop.
+ *
+ *  @param priv     A pointer to wlan_private structure
+ *  @param cmd      A pointer to HostCmd_DS_COMMAND structure
+ *  @return         WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_cmd_802_11_ad_hoc_stop(wlan_private * priv, HostCmd_DS_COMMAND * cmd)
+{
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_STOP);
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_AD_HOC_STOP)
+                                 + S_DS_GEN);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function prepares command of ad_hoc_join.
+ *
+ *  @param priv      A pointer to wlan_private structure
+ *  @param cmd       A pointer to HostCmd_DS_COMMAND structure
+ *  @param pdata_buf Void cast of BSSDescriptor_t from the scan table to join
+ *
+ *  @return          WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_cmd_802_11_ad_hoc_join(wlan_private * priv,
+                            HostCmd_DS_COMMAND * cmd, void *pdata_buf)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_AD_HOC_JOIN *pAdHocJoin = &cmd->params.adj;
+    BSSDescriptor_t *pBSSDesc = (BSSDescriptor_t *) pdata_buf;
+    int cmdAppendSize = 0;
+    int ret = WLAN_STATUS_SUCCESS;
+    WLAN_802_11_RATES rates;
+    int ratesSize;
+    u16 TmpCap;
+    u16 CurrentPacketFilter;
+
+    ENTER();
+
+#define USE_G_PROTECTION	0x02
+    if (pBSSDesc->ERPFlags & USE_G_PROTECTION) {
+        CurrentPacketFilter =
+            Adapter->
+            CurrentPacketFilter | HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON;
+        ret =
+            PrepareAndSendCommand(priv, HostCmd_CMD_MAC_CONTROL, 0,
+                                  HostCmd_OPTION_WAITFORRSP, 0,
+                                  &CurrentPacketFilter);
+        if (ret) {
+            PRINTM(INFO, "ADHOC_S_CMD: G Protection config failed\n");
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+    }
+    Adapter->pAttemptedBSSDesc = pBSSDesc;
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_JOIN);
+
+    pAdHocJoin->BssDescriptor.BSSType = HostCmd_BSS_TYPE_IBSS;
+
+    pAdHocJoin->BssDescriptor.BeaconPeriod
+        = wlan_cpu_to_le16(pBSSDesc->BeaconPeriod);
+
+    memcpy(&pAdHocJoin->BssDescriptor.BSSID,
+           &pBSSDesc->MacAddress, MRVDRV_ETH_ADDR_LEN);
+
+    memcpy(&pAdHocJoin->BssDescriptor.SSID,
+           &pBSSDesc->Ssid.Ssid, pBSSDesc->Ssid.SsidLength);
+
+    memcpy(&pAdHocJoin->BssDescriptor.PhyParamSet,
+           &pBSSDesc->PhyParamSet, sizeof(IEEEtypes_PhyParamSet_t));
+
+    memcpy(&pAdHocJoin->BssDescriptor.SsParamSet,
+           &pBSSDesc->SsParamSet, sizeof(IEEEtypes_SsParamSet_t));
+
+    memcpy(&TmpCap, &pBSSDesc->Cap, sizeof(IEEEtypes_CapInfo_t));
+
+    TmpCap &= CAPINFO_MASK;
+
+    PRINTM(INFO, "ADHOC_J_CMD: TmpCap=%4X CAPINFO_MASK=%4X\n",
+           TmpCap, CAPINFO_MASK);
+    memcpy(&pAdHocJoin->BssDescriptor.Cap, &TmpCap,
+           sizeof(IEEEtypes_CapInfo_t));
+
+    /* information on BSSID descriptor passed to FW */
+    PRINTM(INFO,
+           "ADHOC_J_CMD: BSSID = %02x-%02x-%02x-%02x-%02x-%02x, SSID = %s\n",
+           pAdHocJoin->BssDescriptor.BSSID[0],
+           pAdHocJoin->BssDescriptor.BSSID[1],
+           pAdHocJoin->BssDescriptor.BSSID[2],
+           pAdHocJoin->BssDescriptor.BSSID[3],
+           pAdHocJoin->BssDescriptor.BSSID[4],
+           pAdHocJoin->BssDescriptor.BSSID[5],
+           pAdHocJoin->BssDescriptor.SSID);
+
+    /* Get the common rates supported between the driver and the BSS Desc */
+    if (setup_rates_from_bssdesc(Adapter, pBSSDesc, rates, &ratesSize)) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    /* Copy Data Rates from the Rates recorded in scan response */
+    memset(pAdHocJoin->BssDescriptor.DataRates, 0,
+           sizeof(pAdHocJoin->BssDescriptor.DataRates));
+    memcpy(pAdHocJoin->BssDescriptor.DataRates, rates, ratesSize);
+
+    /* Copy the adhoc join rates into Current BSS state structure */
+    Adapter->CurBssParams.NumOfRates = ratesSize;
+    memcpy(&Adapter->CurBssParams.DataRates, rates, ratesSize);
+
+    /* Copy the channel information */
+    Adapter->CurBssParams.BSSDescriptor.Channel = pBSSDesc->Channel;
+
+    if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPEnabled
+        || Adapter->AdhocAESEnabled) {
+        pAdHocJoin->BssDescriptor.Cap.Privacy = AD_HOC_CAP_PRIVACY_ON;
+    }
+
+    if (Adapter->PSMode == Wlan802_11PowerModeMAX_PSP) {
+        /* wake up first */
+        WLAN_802_11_POWER_MODE LocalPSMode;
+
+        LocalPSMode = Wlan802_11PowerModeCAM;
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_802_11_PS_MODE,
+                                    HostCmd_ACT_GEN_SET, 0, 0, &LocalPSMode);
+
+        if (ret) {
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+    }
+
+    if (wlan_create_dnld_countryinfo_11d(priv, 0)) {
+        PRINTM(INFO, "Dnld_countryinfo_11d failed\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    if (wlan_parse_dnld_countryinfo_11d(priv)) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_AD_HOC_JOIN)
+                                 + S_DS_GEN + cmdAppendSize);
+
+    memcpy(&TmpCap, &pAdHocJoin->BssDescriptor.Cap,
+           sizeof(IEEEtypes_CapInfo_t));
+    TmpCap = wlan_cpu_to_le16(TmpCap);
+
+    memcpy(&pAdHocJoin->BssDescriptor.Cap,
+           &TmpCap, sizeof(IEEEtypes_CapInfo_t));
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Association firmware command response handler
+ *
+ *   The response buffer for the association command has the following
+ *      memory layout.
+ *
+ *   For cases where an association response was not received (indicated
+ *      by the CapInfo and AId field):
+ *
+ *     .------------------------------------------------------------.
+ *     |  Header(4 * sizeof(u16)):  Standard command response hdr   |
+ *     .------------------------------------------------------------.
+ *     |  CapInfo/Error Return(u16):                                |
+ *     |           0xFFFF(-1): Internal error                       |
+ *     |           0xFFFE(-2): Authentication unhandled message     |
+ *     |           0xFFFD(-3): Authentication refused               |
+ *     |           0xFFFC(-4): Timeout waiting for AP response      |
+ *     .------------------------------------------------------------.
+ *     |  StatusCode(u16):                                          |
+ *     |        If CapInfo is -1:                                   |
+ *     |           An internal firmware failure prevented the       |
+ *     |           command from being processed.  The StatusCode    |
+ *     |           will be set to 1.                                |
+ *     |                                                            |
+ *     |        If CapInfo is -2:                                   |
+ *     |           An authentication frame was received but was     |
+ *     |           not handled by the firmware.  IEEE Status        |
+ *     |           code for the failure is returned.                |
+ *     |                                                            |
+ *     |        If CapInfo is -3:                                   |
+ *     |           An authentication frame was received and the     |
+ *     |           StatusCode is the IEEE Status reported in the    |
+ *     |           response.                                        |
+ *     |                                                            |
+ *     |        If CapInfo is -4:                                   |
+ *     |           (1) Association response timeout                 |
+ *     |           (2) Authentication response timeout              |
+ *     .------------------------------------------------------------.
+ *     |  AId(u16): 0xFFFF                                          |
+ *     .------------------------------------------------------------.
+ *
+ *
+ *   For cases where an association response was received, the IEEE 
+ *     standard association response frame is returned:
+ *
+ *     .------------------------------------------------------------.
+ *     |  Header(4 * sizeof(u16)):  Standard command response hdr   |
+ *     .------------------------------------------------------------.
+ *     |  CapInfo(u16): IEEE Capability                             |
+ *     .------------------------------------------------------------.
+ *     |  StatusCode(u16): IEEE Status Code                         |
+ *     .------------------------------------------------------------.
+ *     |  AId(u16): IEEE Association ID                             |
+ *     .------------------------------------------------------------.
+ *     |  IEEE IEs(variable): Any received IEs comprising the       |
+ *     |                      remaining portion of a received       |
+ *     |                      association response frame.           |
+ *     .------------------------------------------------------------.
+ *
+ *  For simplistic handling, the StatusCode field can be used to determine
+ *    an association success (0) or failure (non-zero).
+ *
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp    A pointer to HostCmd_DS_COMMAND
+ *  @return        WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_ret_802_11_associate(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    IEEEtypes_AssocRsp_t *pAssocRsp;
+    BSSDescriptor_t *pBSSDesc;
+    WLAN_802_11_RATES rates;
+    int ratesSize;
+
+    ENTER();
+
+    pAssocRsp = (IEEEtypes_AssocRsp_t *) & resp->params;
+
+    HEXDUMP("ASSOC_RESP:", (void *) &resp->params,
+            wlan_le16_to_cpu(resp->Size) - S_DS_GEN);
+
+    Adapter->assocRspSize = MIN(wlan_le16_to_cpu(resp->Size) - S_DS_GEN,
+                                sizeof(Adapter->assocRspBuffer));
+
+    memcpy(Adapter->assocRspBuffer, &resp->params, Adapter->assocRspSize);
+
+    if (pAssocRsp->StatusCode) {
+        priv->adapter->dbg.num_cmd_assoc_failure++;
+
+        PRINTM(CMND, "ASSOC_RESP: Association Failed, "
+               "status code = %d, error = %d\n",
+               pAssocRsp->StatusCode, *(short *) &pAssocRsp->Capability);
+        ret = WLAN_STATUS_FAILURE;
+
+        goto done;
+    }
+
+    /* Send a Media Connected event, according to the Spec */
+    Adapter->MediaConnectStatus = WlanMediaStateConnected;
+
+    /* Set the attempted BSSID Index to current */
+    pBSSDesc = Adapter->pAttemptedBSSDesc;
+
+    PRINTM(INFO, "ASSOC_RESP: %s\n", pBSSDesc->Ssid.Ssid);
+
+    /* Make a copy of current BSSID descriptor */
+    memcpy(&Adapter->CurBssParams.BSSDescriptor,
+           pBSSDesc, sizeof(BSSDescriptor_t));
+
+    /* update CurBssParams */
+    Adapter->CurBssParams.BSSDescriptor.Channel
+        = pBSSDesc->PhyParamSet.DsParamSet.CurrentChan;
+
+    if (setup_rates_from_bssdesc(Adapter, pBSSDesc, rates, &ratesSize)) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    /* Copy the infra. association rates into Current BSS state structure */
+    Adapter->CurBssParams.NumOfRates = ratesSize;
+    memcpy(&Adapter->CurBssParams.DataRates, rates, ratesSize);
+
+    /* Adjust the timestamps in the scan table to be relative to the newly
+     *   associated AP's TSF
+     */
+    wlan_scan_update_tsf_timestamps(priv, pBSSDesc);
+
+    if (pBSSDesc->wmmIE.VendHdr.ElementId == WMM_IE) {
+        Adapter->CurBssParams.wmm_enabled = TRUE;
+    } else {
+        Adapter->CurBssParams.wmm_enabled = FALSE;
+    }
+
+    if (Adapter->wmm.required && Adapter->CurBssParams.wmm_enabled) {
+        Adapter->wmm.enabled = TRUE;
+    } else {
+        Adapter->wmm.enabled = FALSE;
+    }
+
+    Adapter->CurBssParams.wmm_uapsd_enabled = FALSE;
+
+    if (Adapter->wmm.enabled == TRUE) {
+        Adapter->CurBssParams.wmm_uapsd_enabled
+            = pBSSDesc->wmmIE.QoSInfo.QosUAPSD;
+    }
+
+    PRINTM(INFO, "ASSOC_RESP: CurrentPacketFilter is %x\n",
+           Adapter->CurrentPacketFilter);
+
+    if (Adapter->SecInfo.WPAEnabled || Adapter->SecInfo.WPA2Enabled)
+        Adapter->IsGTK_SET = FALSE;
+
+    Adapter->SNR[TYPE_RXPD][TYPE_AVG] = 0;
+    Adapter->NF[TYPE_RXPD][TYPE_AVG] = 0;
+
+    memset(Adapter->rawSNR, 0x00, sizeof(Adapter->rawSNR));
+    memset(Adapter->rawNF, 0x00, sizeof(Adapter->rawNF));
+    Adapter->nextSNRNF = 0;
+    Adapter->numSNRNF = 0;
+
+    priv->adapter->dbg.num_cmd_assoc_success++;
+
+    PRINTM(INFO, "ASSOC_RESP: Associated \n");
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function handles the command response of disassociate
+ *
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp    A pointer to HostCmd_DS_COMMAND
+ *  @return        WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_ret_802_11_disassociate(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    ENTER();
+
+    priv->adapter->dbg.num_cmd_deauth++;
+    MacEventDisconnected(priv);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function handles the command response of ad_hoc_start and
+ *  ad_hoc_join
+ *
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp    A pointer to HostCmd_DS_COMMAND
+ *  @return        WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_ret_802_11_ad_hoc(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    u16 Command = resp->Command;
+    u16 Result = resp->Result;
+    HostCmd_DS_802_11_AD_HOC_RESULT *pAdHocResult;
+    union iwreq_data wrqu;
+    BSSDescriptor_t *pBSSDesc;
+
+    ENTER();
+
+    pAdHocResult = &resp->params.result;
+
+    pBSSDesc = Adapter->pAttemptedBSSDesc;
+
+    /*
+     * Join result code 0 --> SUCCESS
+     */
+    if (Result) {
+        PRINTM(INFO, "ADHOC_RESP Failed\n");
+        if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+            MacEventDisconnected(priv);
+        }
+
+        memset(&Adapter->CurBssParams.BSSDescriptor,
+               0x00, sizeof(Adapter->CurBssParams.BSSDescriptor));
+
+        LEAVE();
+        return WLAN_STATUS_FAILURE;
+    }
+
+    /* Send a Media Connected event, according to the Spec */
+    Adapter->MediaConnectStatus = WlanMediaStateConnected;
+
+    if (Command == HostCmd_RET_802_11_AD_HOC_START) {
+        PRINTM(INFO, "ADHOC_S_RESP  %s\n", pBSSDesc->Ssid.Ssid);
+
+        /* Update the created network descriptor with the new BSSID */
+        memcpy(pBSSDesc->MacAddress,
+               pAdHocResult->BSSID, MRVDRV_ETH_ADDR_LEN);
+    } else {
+        /*
+         * Now the join cmd should be successful
+         * If BSSID has changed use SSID to compare instead of BSSID
+         */
+        PRINTM(INFO, "ADHOC_J_RESP  %s\n", pBSSDesc->Ssid.Ssid);
+
+        /* Make a copy of current BSSID descriptor, only needed for join since
+         *   the current descriptor is already being used for adhoc start
+         */
+        memcpy(&Adapter->CurBssParams.BSSDescriptor,
+               pBSSDesc, sizeof(BSSDescriptor_t));
+    }
+
+    memset(&wrqu, 0, sizeof(wrqu));
+    memcpy(wrqu.ap_addr.sa_data,
+           &Adapter->CurBssParams.BSSDescriptor.MacAddress, ETH_ALEN);
+    wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+    wireless_send_event(priv->wlan_dev.netdev, SIOCGIWAP, &wrqu, NULL);
+
+    PRINTM(INFO, "ADHOC_RESP: Channel = %d\n", Adapter->AdhocChannel);
+    PRINTM(INFO, "ADHOC_RESP: BSSID = %02x:%02x:%02x:%02x:%02x:%02x\n",
+           Adapter->CurBssParams.BSSDescriptor.MacAddress[0],
+           Adapter->CurBssParams.BSSDescriptor.MacAddress[1],
+           Adapter->CurBssParams.BSSDescriptor.MacAddress[2],
+           Adapter->CurBssParams.BSSDescriptor.MacAddress[3],
+           Adapter->CurBssParams.BSSDescriptor.MacAddress[4],
+           Adapter->CurBssParams.BSSDescriptor.MacAddress[5]);
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function handles the command response of ad_hoc_stop
+ *
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp    A pointer to HostCmd_DS_COMMAND
+ *  @return        WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_ret_802_11_ad_hoc_stop(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    ENTER();
+
+    MacEventDisconnected(priv);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+#ifdef REASSOCIATION
+/**
+ *  @brief This function handles re-association. it is triggered
+ *  by re-assoc timer.
+ *
+ *  @param data    A pointer to wlan_thread structure
+ *  @return        WLAN_STATUS_SUCCESS
+ */
+int
+wlan_reassociation_thread(void *data)
+{
+    wlan_thread *thread = data;
+    wlan_private *priv = thread->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    wait_queue_t wait;
+    int i;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    OS_INTERRUPT_SAVE_AREA;
+
+    ENTER();
+
+    wlan_activate_thread(thread);
+    init_waitqueue_entry(&wait, current);
+
+    current->flags |= PF_NOFREEZE;
+
+    for (;;) {
+        add_wait_queue(&thread->waitQ, &wait);
+        OS_SET_THREAD_STATE(TASK_INTERRUPTIBLE);
+
+        PRINTM(INFO, "Reassoc: Thread sleeping...\n");
+
+        schedule();
+
+        OS_SET_THREAD_STATE(TASK_RUNNING);
+        remove_wait_queue(&thread->waitQ, &wait);
+
+        if (Adapter->SurpriseRemoved) {
+            break;
+        }
+
+        if (kthread_should_stop()) {
+            break;
+        }
+
+        PRINTM(INFO, "Reassoc: Thread waking up...\n");
+
+        if (Adapter->InfrastructureMode != Wlan802_11Infrastructure ||
+            Adapter->HardwareStatus != WlanHardwareStatusReady) {
+            PRINTM(MSG, "Reassoc: mode or hardware status is not correct\n");
+            continue;
+        }
+
+        /* The semaphore is used to avoid reassociation thread and 
+           wlan_set_scan/wlan_set_essid interrupting each other.
+           Reassociation should be disabled completely by application if 
+           wlan_set_user_scan_ioctl/wlan_set_wap is used.
+         */
+        if (OS_ACQ_SEMAPHORE_BLOCK(&Adapter->ReassocSem)) {
+            PRINTM(ERROR, "Acquire semaphore error, reassociation thread\n");
+            goto settimer;
+        }
+
+        if (Adapter->MediaConnectStatus != WlanMediaStateDisconnected) {
+            OS_REL_SEMAPHORE(&Adapter->ReassocSem);
+            PRINTM(MSG, "Reassoc: Adapter->MediaConnectStatus is wrong\n");
+            continue;
+        }
+
+        PRINTM(INFO, "Reassoc: Required ESSID: %s\n",
+               Adapter->PreviousSSID.Ssid);
+
+        PRINTM(INFO, "Reassoc: Performing Active Scan @ %lu\n",
+               os_time_get());
+        SendSpecificSSIDScan(priv, &Adapter->PreviousSSID);
+
+        i = FindSSIDInList(Adapter,
+                           &Adapter->PreviousSSID,
+                           Adapter->PreviousBSSID,
+                           Adapter->InfrastructureMode);
+
+        if (i < 0) {
+            /* If the SSID could not be found, try just the SSID */
+            i = FindSSIDInList(Adapter,
+                               &Adapter->PreviousSSID,
+                               NULL, Adapter->InfrastructureMode);
+        }
+
+        if (i >= 0) {
+            if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPEnabled) {
+                ret = PrepareAndSendCommand(priv,
+                                            HostCmd_CMD_802_11_SET_WEP,
+                                            0, HostCmd_OPTION_WAITFORRSP,
+                                            OID_802_11_ADD_WEP, NULL);
+                if (ret)
+                    PRINTM(INFO, "Ressoc: Fail to set WEP KEY\n");
+            }
+            wlan_associate(priv, &Adapter->ScanTable[i]);
+        }
+
+        OS_REL_SEMAPHORE(&Adapter->ReassocSem);
+
+      settimer:
+        if (Adapter->MediaConnectStatus == WlanMediaStateDisconnected) {
+            PRINTM(INFO, "Reassoc: No AP found or assoc failed."
+                   "Restarting re-assoc Timer @ %lu\n", os_time_get());
+
+            Adapter->ReassocTimerIsSet = TRUE;
+            ModTimer(&Adapter->MrvDrvTimer, MRVDRV_TIMER_10S);
+        }
+    }
+
+    wlan_deactivate_thread(thread);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function triggers re-association by waking up
+ *  re-assoc thread.
+ *  
+ *  @param FunctionContext    A pointer to FunctionContext
+ *  @return 	   n/a
+ */
+void
+MrvDrvReassocTimerFunction(void *FunctionContext)
+{
+    wlan_private *priv = (wlan_private *) FunctionContext;
+    wlan_adapter *Adapter = priv->adapter;
+    OS_INTERRUPT_SAVE_AREA;
+
+    ENTER();
+
+    PRINTM(INFO, "MrvDrvReassocTimer fired.\n");
+    Adapter->ReassocTimerIsSet = FALSE;
+    if (Adapter->PSState != PS_STATE_FULL_POWER) {
+        /* wait until Exit_PS command returns */
+        Adapter->ReassocTimerIsSet = TRUE;
+        ModTimer(&Adapter->MrvDrvTimer, MRVDRV_TIMER_1S);
+        PRINTM(INFO, "MrvDrvTimerFunction(PSState=%d) waiting"
+               "for Exit_PS done\n", Adapter->PSState);
+        LEAVE();
+        return;
+    }
+
+    PRINTM(INFO, "Waking Up the Reassoc Thread\n");
+
+    wake_up_interruptible(&priv->ReassocThread.waitQ);
+
+    LEAVE();
+    return;
+}
+#endif /* REASSOCIATION */
+
+int
+sendADHOCBSSIDQuery(wlan_private * priv)
+{
+    return PrepareAndSendCommand(priv,
+                                 HostCmd_CMD_802_11_IBSS_COALESCING_STATUS,
+                                 HostCmd_ACT_GET, 0, 0, NULL);
+}
Index: linux-2.6.29/drivers/net/wireless/marvell8686/wlan_join.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/wlan_join.h	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,84 @@
+/** @file wlan_join.h
+ *
+ *  @brief Interface for the wlan infrastructure and adhoc join routines
+ *
+ *  Driver interface functions and type declarations for the join module
+ *    implemented in wlan_join.c.  Process all start/join requests for
+ *    both adhoc and infrastructure networks
+ *
+ *  Copyright  Marvell International Ltd. and/or its affiliates, 2003-2006
+ *
+ *  @sa wlan_join.c
+ */
+/*************************************************************
+Change Log:
+    01/11/06: Initial revision. Match new scan code, relocate related functions
+
+************************************************************/
+
+#ifndef _WLAN_JOIN_H
+#define _WLAN_JOIN_H
+
+//! Size of buffer allocated to store the association response from firmware
+#define MRVDRV_ASSOC_RSP_BUF_SIZE  500
+
+//! Size of buffer allocated to store IEs passed to firmware in the assoc req
+#define MRVDRV_GENIE_BUF_SIZE      256
+
+//! Size of buffer allocated to store TLVs passed to firmware in the assoc req
+#define MRVDRV_ASSOC_TLV_BUF_SIZE  256
+
+extern int wlan_cmd_802_11_authenticate(wlan_private * priv,
+                                        HostCmd_DS_COMMAND * cmd,
+                                        void *pdata_buf);
+extern int wlan_cmd_802_11_ad_hoc_join(wlan_private * priv,
+                                       HostCmd_DS_COMMAND * cmd,
+                                       void *pdata_buf);
+extern int wlan_cmd_802_11_ad_hoc_stop(wlan_private * priv,
+                                       HostCmd_DS_COMMAND * cmd);
+extern int wlan_cmd_802_11_ad_hoc_start(wlan_private * priv,
+                                        HostCmd_DS_COMMAND * cmd,
+                                        void *pssid);
+extern int wlan_cmd_802_11_deauthenticate(wlan_private * priv,
+                                          HostCmd_DS_COMMAND * cmd);
+extern int wlan_cmd_802_11_associate(wlan_private * priv,
+                                     HostCmd_DS_COMMAND * cmd,
+                                     void *pdata_buf);
+extern int wlan_ret_802_11_authenticate(wlan_private * priv,
+                                        HostCmd_DS_COMMAND * resp);
+extern int wlan_ret_802_11_ad_hoc(wlan_private * priv,
+                                  HostCmd_DS_COMMAND * resp);
+extern int wlan_ret_802_11_ad_hoc_stop(wlan_private * priv,
+                                       HostCmd_DS_COMMAND * resp);
+extern int wlan_ret_802_11_disassociate(wlan_private * priv,
+                                        HostCmd_DS_COMMAND * resp);
+extern int wlan_ret_802_11_associate(wlan_private * priv,
+                                     HostCmd_DS_COMMAND * resp);
+
+extern int wlan_associate(wlan_private * priv, BSSDescriptor_t * pBSSDesc);
+extern int wlan_associate_to_table_idx(wlan_private * priv, int tableIdx);
+
+extern int wlanidle_on(wlan_private * priv);
+extern int wlanidle_off(wlan_private * priv);
+
+extern int wlan_do_adhocstop_ioctl(wlan_private * priv);
+extern int wlan_reassociation_thread(void *data);
+
+extern int StartAdhocNetwork(wlan_private * priv,
+                             WLAN_802_11_SSID * AdhocSSID);
+extern int JoinAdhocNetwork(wlan_private * priv, BSSDescriptor_t * pBSSDesc);
+extern int StopAdhocNetwork(wlan_private * priv);
+extern int SendDeauthentication(wlan_private * priv);
+
+extern int wlan_do_adhocstop_ioctl(wlan_private * priv);
+extern int wlan_get_assoc_rsp_ioctl(wlan_private * priv, struct iwreq *wrq);
+extern int wlan_set_mrvl_tlv_ioctl(wlan_private * priv, struct iwreq *wrq);
+
+#ifdef __KERNEL__
+extern int wlan_set_wap(struct net_device *dev, struct iw_request_info *info,
+                        struct sockaddr *awrq, char *extra);
+#endif
+
+extern int sendADHOCBSSIDQuery(wlan_private * priv);
+
+#endif
Index: linux-2.6.29/drivers/net/wireless/marvell8686/wlan_main.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/wlan_main.c	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,1362 @@
+/** @file wlan_main.c
+  *  
+  * @brief This file contains the major functions in WLAN
+  * driver. It includes init, exit, open, close and main
+  * thread etc..
+  * 
+  */
+/**
+  * @mainpage M-WLAN Linux Driver
+  *
+  * @section overview_sec Overview
+  *
+  * The M-WLAN is a Linux reference driver for Marvell
+  * 802.11 (a/b/g) WLAN chipset.
+  * 
+  * @section copyright_sec Copyright
+  *
+  * Copyright  Marvell International Ltd. and/or its affiliates, 2003-2007
+  *
+  */
+/********************************************************
+Change log:
+    09/30/05: Add Doxygen format comments
+    12/09/05: Add TX_QUEUE support  
+    01/05/06: Add kernel 2.6.x support  
+    01/11/06: Conditionalize new scan/join functions.
+    01/12/06: Add TxLockFlag for UAPSD power save mode 
+              and Proprietary Periodic sleep support
+********************************************************/
+
+#include    "include.h"
+
+/********************************************************
+        Local Variables
+********************************************************/
+
+#ifdef ENABLE_PM
+#define WLAN_PM_DRV_NAME "wlan_pm_drv"
+
+static int wlan_pm_suspend(struct device *pmdev, u32 state, u32 level);
+static int wlan_pm_resume(struct device *pmdev, u32 level);
+static void wlan_pm_release(struct device *pmdev);
+
+/*!
+ * This structure contains pointers to the power management callback functions.
+ */
+static struct device_driver wlan_pm_driver = {
+    .name = WLAN_PM_DRV_NAME,
+    .bus = &platform_bus_type,
+    .suspend = wlan_pm_suspend,
+    .resume = wlan_pm_resume,
+};
+
+/*! Device Definition for WLAN */
+static struct platform_device wlan_pm_platform_device = {
+    .name = WLAN_PM_DRV_NAME,
+    .id = 0,
+    .dev.release = wlan_pm_release,
+};
+#endif
+
+spinlock_t driver_lock = SPIN_LOCK_UNLOCKED;
+ulong driver_flags;
+
+#define WLAN_TX_PWR_DEFAULT     20      /*100mW */
+#define WLAN_TX_PWR_US_DEFAULT      20  /*100mW */
+#define WLAN_TX_PWR_JP_DEFAULT      16  /*50mW */
+#define WLAN_TX_PWR_FR_100MW        20  /*100mW */
+#define WLAN_TX_PWR_FR_10MW     10      /*10mW */
+#define WLAN_TX_PWR_EMEA_DEFAULT    20  /*100mW */
+
+/* Format { Channel, Frequency (MHz), MaxTxPower } */
+/* Band: 'B/G', Region: USA FCC/Canada IC */
+static CHANNEL_FREQ_POWER channel_freq_power_US_BG[] = {
+    {1, 2412, WLAN_TX_PWR_US_DEFAULT},
+    {2, 2417, WLAN_TX_PWR_US_DEFAULT},
+    {3, 2422, WLAN_TX_PWR_US_DEFAULT},
+    {4, 2427, WLAN_TX_PWR_US_DEFAULT},
+    {5, 2432, WLAN_TX_PWR_US_DEFAULT},
+    {6, 2437, WLAN_TX_PWR_US_DEFAULT},
+    {7, 2442, WLAN_TX_PWR_US_DEFAULT},
+    {8, 2447, WLAN_TX_PWR_US_DEFAULT},
+    {9, 2452, WLAN_TX_PWR_US_DEFAULT},
+    {10, 2457, WLAN_TX_PWR_US_DEFAULT},
+    {11, 2462, WLAN_TX_PWR_US_DEFAULT}
+};
+
+/* Band: 'B/G', Region: Europe ETSI */
+static CHANNEL_FREQ_POWER channel_freq_power_EU_BG[] = {
+    {1, 2412, WLAN_TX_PWR_EMEA_DEFAULT},
+    {2, 2417, WLAN_TX_PWR_EMEA_DEFAULT},
+    {3, 2422, WLAN_TX_PWR_EMEA_DEFAULT},
+    {4, 2427, WLAN_TX_PWR_EMEA_DEFAULT},
+    {5, 2432, WLAN_TX_PWR_EMEA_DEFAULT},
+    {6, 2437, WLAN_TX_PWR_EMEA_DEFAULT},
+    {7, 2442, WLAN_TX_PWR_EMEA_DEFAULT},
+    {8, 2447, WLAN_TX_PWR_EMEA_DEFAULT},
+    {9, 2452, WLAN_TX_PWR_EMEA_DEFAULT},
+    {10, 2457, WLAN_TX_PWR_EMEA_DEFAULT},
+    {11, 2462, WLAN_TX_PWR_EMEA_DEFAULT},
+    {12, 2467, WLAN_TX_PWR_EMEA_DEFAULT},
+    {13, 2472, WLAN_TX_PWR_EMEA_DEFAULT}
+};
+
+/* Band: 'B/G', Region: France */
+static CHANNEL_FREQ_POWER channel_freq_power_FR_BG[] = {
+    {1, 2412, WLAN_TX_PWR_FR_100MW},
+    {2, 2417, WLAN_TX_PWR_FR_100MW},
+    {3, 2422, WLAN_TX_PWR_FR_100MW},
+    {4, 2427, WLAN_TX_PWR_FR_100MW},
+    {5, 2432, WLAN_TX_PWR_FR_100MW},
+    {6, 2437, WLAN_TX_PWR_FR_100MW},
+    {7, 2442, WLAN_TX_PWR_FR_100MW},
+    {8, 2447, WLAN_TX_PWR_FR_100MW},
+    {9, 2452, WLAN_TX_PWR_FR_100MW},
+    {10, 2457, WLAN_TX_PWR_FR_10MW},
+    {11, 2462, WLAN_TX_PWR_FR_10MW},
+    {12, 2467, WLAN_TX_PWR_FR_10MW},
+    {13, 2472, WLAN_TX_PWR_FR_10MW}
+};
+
+/* Band: 'B/G', Region: Japan */
+static CHANNEL_FREQ_POWER channel_freq_power_JPN41_BG[] = {
+    {1, 2412, WLAN_TX_PWR_JP_DEFAULT},
+    {2, 2417, WLAN_TX_PWR_JP_DEFAULT},
+    {3, 2422, WLAN_TX_PWR_JP_DEFAULT},
+    {4, 2427, WLAN_TX_PWR_JP_DEFAULT},
+    {5, 2432, WLAN_TX_PWR_JP_DEFAULT},
+    {6, 2437, WLAN_TX_PWR_JP_DEFAULT},
+    {7, 2442, WLAN_TX_PWR_JP_DEFAULT},
+    {8, 2447, WLAN_TX_PWR_JP_DEFAULT},
+    {9, 2452, WLAN_TX_PWR_JP_DEFAULT},
+    {10, 2457, WLAN_TX_PWR_JP_DEFAULT},
+    {11, 2462, WLAN_TX_PWR_JP_DEFAULT},
+    {12, 2467, WLAN_TX_PWR_JP_DEFAULT},
+    {13, 2472, WLAN_TX_PWR_JP_DEFAULT}
+};
+
+/* Band: 'B/G', Region: Japan */
+static CHANNEL_FREQ_POWER channel_freq_power_JPN40_BG[] = {
+    {14, 2484, WLAN_TX_PWR_JP_DEFAULT}
+};
+
+/********************************************************
+        Global Variables
+********************************************************/
+
+/**
+ * the structure for channel, frequency and power
+ */
+typedef struct _region_cfp_table
+{
+    u8 region;
+    CHANNEL_FREQ_POWER *cfp_BG;
+    int cfp_no_BG;
+} region_cfp_table_t;
+
+/**
+ * the structure for the mapping between region and CFP
+ */
+region_cfp_table_t region_cfp_table[] = {
+    {0x10,                      /*US FCC */
+     channel_freq_power_US_BG,
+     sizeof(channel_freq_power_US_BG) / sizeof(CHANNEL_FREQ_POWER),
+     }
+    ,
+    {0x20,                      /*CANADA IC */
+     channel_freq_power_US_BG,
+     sizeof(channel_freq_power_US_BG) / sizeof(CHANNEL_FREQ_POWER),
+     }
+    ,
+    {0x30, /*EU*/ channel_freq_power_EU_BG,
+     sizeof(channel_freq_power_EU_BG) / sizeof(CHANNEL_FREQ_POWER),
+     }
+    ,
+    {0x32, /*FRANCE*/ channel_freq_power_FR_BG,
+     sizeof(channel_freq_power_FR_BG) / sizeof(CHANNEL_FREQ_POWER),
+     }
+    ,
+    {0x40, /*JAPAN*/ channel_freq_power_JPN40_BG,
+     sizeof(channel_freq_power_JPN40_BG) / sizeof(CHANNEL_FREQ_POWER),
+     }
+    ,
+    {0x41, /*JAPAN*/ channel_freq_power_JPN41_BG,
+     sizeof(channel_freq_power_JPN41_BG) / sizeof(CHANNEL_FREQ_POWER),
+     }
+    ,
+/*Add new region here */
+};
+
+/**
+ * the rates supported by the card
+ */
+u8 WlanDataRates[WLAN_SUPPORTED_RATES] =
+    { 0x02, 0x04, 0x0B, 0x16, 0x00, 0x0C, 0x12,
+    0x18, 0x24, 0x30, 0x48, 0x60, 0x6C, 0x00
+};
+
+/**
+ * the rates supported
+ */
+u8 SupportedRates[G_SUPPORTED_RATES] =
+    { 0x82, 0x84, 0x8b, 0x96, 0x0c, 0x12, 0x18, 0x24, 0x30, 0x48,
+    0x60, 0x6c, 0
+};
+
+/**
+ * the rates supported for ad-hoc G mode
+ */
+u8 AdhocRates_G[G_SUPPORTED_RATES] =
+    { 0x82, 0x84, 0x8b, 0x96, 0x0c, 0x12, 0x18, 0x24, 0x30, 0x48, 0x60, 0x6c,
+0 };
+
+/**
+ * the rates supported for ad-hoc B mode
+ */
+u8 AdhocRates_B[4] = { 0x82, 0x84, 0x8b, 0x96 };
+
+/**
+ * the global variable of a pointer to wlan_private
+ * structure variable
+ */
+wlan_private *wlanpriv = NULL;
+
+u32 DSFreqList[15] = {
+    0, 2412000, 2417000, 2422000, 2427000, 2432000, 2437000, 2442000,
+    2447000, 2452000, 2457000, 2462000, 2467000, 2472000, 2484000
+};
+
+/**
+ * the table to keep region code
+ */
+u16 RegionCodeToIndex[MRVDRV_MAX_REGION_CODE] =
+    { 0x10, 0x20, 0x30, 0x32, 0x40, 0x41 };
+
+/********************************************************
+        Local Functions
+********************************************************/
+
+/** 
+ *  @brief This function opens the network device
+ *  
+ *  @param dev     A pointer to net_device structure
+ *  @return        WLAN_STATUS_SUCCESS
+ */
+static int
+wlan_open(struct net_device *dev)
+{
+    wlan_private *priv = (wlan_private *) dev->priv;
+    wlan_adapter *adapter = priv->adapter;
+
+    ENTER();
+
+    MODULE_GET;
+
+    priv->open = TRUE;
+
+    if ((adapter->MediaConnectStatus == WlanMediaStateConnected)
+        && (adapter->InfrastructureMode != Wlan802_11IBSS
+            || adapter->AdhocLinkSensed == TRUE))
+        os_carrier_on(priv);
+    else
+        os_carrier_off(priv);
+
+    os_start_queue(priv);
+    wmm_start_queue(priv);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function closes the network device
+ *  
+ *  @param dev     A pointer to net_device structure
+ *  @return        WLAN_STATUS_SUCCESS
+ */
+static int
+wlan_close(struct net_device *dev)
+{
+    wlan_private *priv = dev->priv;
+
+    ENTER();
+
+    if (priv->adapter)
+        wlan_clean_txrx(priv);
+
+    MODULE_PUT;
+
+    priv->open = FALSE;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+#ifdef ENABLE_PM
+/**
+ * @brief
+ *     This function is called to put the SDHC in a low power state. Refer to the
+ *     document driver-model/driver.txt in the kernel source tree for more
+ *     information.
+ *
+ * @param   dev   the device structure used to give information on which SDHC
+ *                to suspend
+ * @param   state the power state the device is entering
+ * @param   level the stage in device suspension process that we want the
+ *                device to be put in
+ *
+ * @return  0 : go to sleep mode
+ *          -1 : do not accept to go to sleep mode.
+ */
+static int
+wlan_pm_suspend(struct device *pmdev, u32 state, u32 level)
+{
+    wlan_private *priv = wlanpriv;
+    wlan_adapter *Adapter = priv->adapter;
+    struct net_device *dev = priv->wlan_dev.netdev;
+
+    switch (level) {
+
+    case SUSPEND_DISABLE:
+        PRINTM(INFO, "WIFI_PM_SUSPEND_CALLBACK: enter SUSPEND_DISABLE.\n");
+
+        /* in associated mode : check that chipset is in IEEE PS and well configured to wake up the host if needed */
+        if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+            if ((Adapter->PSState != PS_STATE_SLEEP)
+                || (!Adapter->bWakeupDevRequired)
+                || (Adapter->WakeupTries != 0)) {
+                PRINTM(INFO, "WIFI_PM_SUSPEND_CALLBACK: can't enter sleep mode because \
+		        PSstate=%d, bWakeupDevRequired=%d, wakeupTries=%d\n",
+                       Adapter->PSState, Adapter->bWakeupDevRequired, Adapter->WakeupTries);
+                return WLAN_STATUS_FAILURE;
+            }
+
+            else {
+
+                /*
+                 * Detach the network interface
+                 * if the network is running
+                 */
+                if (netif_running(dev)) {
+                    netif_device_detach(dev);
+                    PRINTM(INFO, "netif_device_detach().\n");
+                }
+                /* Stop bus clock */
+                sbi_set_bus_clock(priv, FALSE);
+            }
+        }
+
+        /* in non associated mode  : check that chipset is in Deepsleep mode */
+        else {
+            if (Adapter->IsDeepSleep == FALSE) {
+                PRINTM(INFO,
+                       "WIFI_PM_SUSPEND_CALLBACK: No allowed to enter sleep while in FW in full power.\n");
+                return WLAN_STATUS_FAILURE;
+            }
+            /*
+             * Detach the network interface 
+             * if the network is running
+             */
+            if (netif_running(dev)) {
+                netif_device_detach(dev);
+            }
+        }
+        break;
+
+    case SUSPEND_SAVE_STATE:
+
+        PRINTM(INFO, "WIFI_PM_SUSPEND_CALLBACK: enter SUSPEND_SAVE_STATE.\n");
+        /* Save bus state to restore it when waking up */
+        sbi_suspend(priv);
+
+        break;
+
+    case SUSPEND_POWER_DOWN:
+
+        PRINTM(INFO, "WIFI_PM_SUSPEND_CALLBACK: enter SUSPEND_POWER_DOWN.\n");
+        /* nothing to do */
+        break;
+
+    default:
+
+        break;
+
+    }
+
+    return WLAN_STATUS_SUCCESS;
+
+}
+
+/**
+ * @brief
+ *     This function is called to bring the SDHC back from a low power state. Refer
+ *     to the document driver-model/driver.txt in the kernel source tree for more
+ *     information.
+ *
+ * @param   dev   the device structure used to give information on which SDHC
+ *                to resume
+ * @param   level the stage in device resumption process that we want the
+ *                device to be put in
+ *
+ * @return  The function always returns 0.
+ */
+static int
+wlan_pm_resume(struct device *pmdev, u32 level)
+{
+    wlan_private *priv = wlanpriv;
+    wlan_adapter *Adapter = priv->adapter;
+    struct net_device *dev = priv->wlan_dev.netdev;
+
+    switch (level) {
+
+    case RESUME_POWER_ON:
+
+        PRINTM(INFO, "WIFI_PM_RESUME_CALLBACK: enter RESUME_POWER_ON.\n");
+        /* nothing to do */
+        break;
+
+    case RESUME_RESTORE_STATE:
+
+        PRINTM(INFO,
+               "WIFI_PM_RESUME_CALLBACK: enter RESUME_RESTORE_STATE.\n");
+        /* Restore bus state */
+        sbi_resume(priv);
+        break;
+
+    case RESUME_ENABLE:
+
+        PRINTM(INFO, "WIFI_PM_RESUME_CALLBACK: enter RESUME_ENABLE.\n");
+
+        /* in associated mode */
+        if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+
+            if (Adapter->bWakeupDevRequired == FALSE) {
+                /* could never happen */
+                PRINTM(MSG, "WIFI_PM_RESUME_CALLBACK: serious error.\n");
+            } else {
+                /*
+                 * Start bus clock
+                 */
+                sbi_set_bus_clock(priv, TRUE);
+                /*
+                 * Attach the network interface
+                 * if the network is running
+                 */
+                if (netif_running(dev)) {
+                    netif_device_attach(dev);
+                    PRINTM(INFO, "WIFI_PM : after netif_device_attach().\n");
+                }
+                PRINTM(INFO,
+                       "WIFI_PM : After netif attach, in associated mode.\n");
+            }
+        }
+
+        /* in non associated mode */
+        else {
+            if (netif_running(dev)) {
+                netif_device_attach(dev);
+            }
+
+            PRINTM(INFO,
+                   "WIFI_PM : after netif attach, in NON associated mode.\n");
+        }
+        break;
+
+    default:
+        break;
+
+    }
+    return WLAN_STATUS_SUCCESS;
+
+}
+
+/**
+ * @brief
+ *     Dummy function to be compliant with Linux Power Management framework.
+ *
+ * @param   pmdev   the device structure used to give information on which SDHC
+ *                  to use
+ *
+ * @return  None.
+ */
+static void
+wlan_pm_release(struct device *pmdev)
+{
+    PRINTM(INFO, "WIFI_PM_DRIVER : Into pm_device release function\n");
+    return;
+}
+
+#endif /* ENABLE_PM */
+
+/** 
+ *  @brief This function handles packet transmission
+ *  
+ *  @param skb     A pointer to sk_buff structure
+ *  @param dev     A pointer to net_device structure
+ *  @return        WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+    int ret;
+    wlan_private *priv = dev->priv;
+
+    ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    PRINTM(DATA, "Data <= kernel\n");
+
+    if (wlan_tx_packet(priv, skb)) {
+        /* Transmit failed */
+        ret = WLAN_STATUS_FAILURE;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function handles the timeout of packet
+ *  transmission
+ *  
+ *  @param dev     A pointer to net_device structure
+ *  @return        n/a
+ */
+static void
+wlan_tx_timeout(struct net_device *dev)
+{
+    wlan_private *priv = (wlan_private *) dev->priv;
+
+    ENTER();
+
+    PRINTM(DATA, "Tx timeout\n");
+    UpdateTransStart(dev);
+
+    priv->adapter->dbg.num_tx_timeout++;
+
+    priv->adapter->IntCounter++;
+    wake_up_interruptible(&priv->MainThread.waitQ);
+
+    LEAVE();
+}
+
+/** 
+ *  @brief This function returns the network statistics
+ *  
+ *  @param dev     A pointer to wlan_private structure
+ *  @return        A pointer to net_device_stats structure
+ */
+static struct net_device_stats *
+wlan_get_stats(struct net_device *dev)
+{
+    wlan_private *priv = (wlan_private *) dev->priv;
+
+    return &priv->stats;
+}
+
+/** 
+ *  @brief This function sets the MAC address to firmware.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param pRxPD   A pointer to RxPD structure of received packet
+ *  @return        WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_set_mac_address(struct net_device *dev, void *addr)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = (wlan_private *) dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    struct sockaddr *pHwAddr = (struct sockaddr *) addr;
+
+    ENTER();
+
+    memset(Adapter->CurrentAddr, 0, MRVDRV_ETH_ADDR_LEN);
+
+    /* dev->dev_addr is 8 bytes */
+    HEXDUMP("dev->dev_addr:", dev->dev_addr, ETH_ALEN);
+
+    HEXDUMP("addr:", pHwAddr->sa_data, ETH_ALEN);
+    memcpy(Adapter->CurrentAddr, pHwAddr->sa_data, ETH_ALEN);
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_MAC_ADDRESS,
+                                HostCmd_ACT_SET,
+                                HostCmd_OPTION_WAITFORRSP, 0, NULL);
+
+    if (ret) {
+        PRINTM(INFO, "set mac address failed.\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    HEXDUMP("Adapter->MacAddr:", Adapter->CurrentAddr, ETH_ALEN);
+    memcpy(dev->dev_addr, Adapter->CurrentAddr, ETH_ALEN);
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function sets multicast addresses to firmware
+ *  
+ *  @param dev     A pointer to net_device structure
+ *  @return        n/a
+ */
+static void
+wlan_set_multicast_list(struct net_device *dev)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int OldPacketFilter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    OldPacketFilter = Adapter->CurrentPacketFilter;
+
+    if (dev->flags & IFF_PROMISC) {
+        PRINTM(INFO, "Enable Promiscuous mode\n");
+        Adapter->CurrentPacketFilter |= HostCmd_ACT_MAC_PROMISCUOUS_ENABLE;
+        Adapter->CurrentPacketFilter &= ~HostCmd_ACT_MAC_ALL_MULTICAST_ENABLE;
+    } else {
+        /* Multicast */
+        Adapter->CurrentPacketFilter &= ~HostCmd_ACT_MAC_PROMISCUOUS_ENABLE;
+
+        if (dev->flags & IFF_ALLMULTI || dev->mc_count >
+            MRVDRV_MAX_MULTICAST_LIST_SIZE) {
+            PRINTM(INFO, "Enabling All Multicast!\n");
+            Adapter->CurrentPacketFilter |=
+                HostCmd_ACT_MAC_ALL_MULTICAST_ENABLE;
+        } else {
+            Adapter->CurrentPacketFilter &=
+                ~HostCmd_ACT_MAC_ALL_MULTICAST_ENABLE;
+
+            if (!dev->mc_count) {
+                PRINTM(INFO, "No multicast addresses - "
+                       "disabling multicast!\n");
+
+            } else {
+                int i;
+
+                Adapter->NumOfMulticastMACAddr =
+                    CopyMulticastAddrs(Adapter, dev);
+
+                PRINTM(INFO, "Multicast addresses: %d\n", dev->mc_count);
+
+                for (i = 0; i < dev->mc_count; i++) {
+                    PRINTM(INFO, "Multicast address %d:"
+                           "%x %x %x %x %x %x\n", i,
+                           Adapter->MulticastList[i][0],
+                           Adapter->MulticastList[i][1],
+                           Adapter->MulticastList[i][2],
+                           Adapter->MulticastList[i][3],
+                           Adapter->MulticastList[i][4],
+                           Adapter->MulticastList[i][5]);
+                }
+                /* set multicast addresses to firmware */
+                ret =
+                    PrepareAndSendCommand(priv, HostCmd_CMD_MAC_MULTICAST_ADR,
+                                          HostCmd_ACT_GEN_SET, 0, 0, NULL);
+            }
+        }
+    }
+
+    if (Adapter->CurrentPacketFilter != OldPacketFilter) {
+        if (ret == WLAN_STATUS_SUCCESS)
+            PrepareAndSendCommand(priv,
+                                  HostCmd_CMD_MAC_CONTROL,
+                                  0, 0, 0, &Adapter->CurrentPacketFilter);
+    }
+
+    LEAVE();
+}
+
+/** 
+ *  @brief This function pops rx_skb from the rx queue.
+ *  
+ *  @param RxSkbQ  A pointer to rx_skb queue
+ *  @return        A pointer to skb
+ */
+static struct sk_buff *
+wlan_pop_rx_skb(struct sk_buff *RxSkbQ)
+{
+    struct sk_buff *skb_data = NULL;
+
+    if (!list_empty((struct list_head *) RxSkbQ)) {
+        skb_data = RxSkbQ->next;
+        list_del((struct list_head *) RxSkbQ->next);
+    }
+
+    return skb_data;
+}
+
+/** 
+ *  @brief This function hanldes the major job in WLAN driver.
+ *  it handles the event generated by firmware, rx data received
+ *  from firmware and tx data sent from kernel.
+ *  
+ *  @param data    A pointer to wlan_thread structure
+ *  @return        WLAN_STATUS_SUCCESS
+ */
+static int
+wlan_service_main_thread(void *data)
+{
+    wlan_thread *thread = data;
+    wlan_private *priv = thread->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    wait_queue_t wait;
+    u8 ireg = 0;
+    u8 runCmd = 1;
+
+    OS_INTERRUPT_SAVE_AREA;
+
+    ENTER();
+
+    wlan_activate_thread(thread);
+
+    init_waitqueue_entry(&wait, current);
+
+    current->flags |= PF_NOFREEZE;
+
+    wmm_init(priv);
+
+    for (;;) {
+        add_wait_queue(&thread->waitQ, &wait);
+        OS_SET_THREAD_STATE(TASK_INTERRUPTIBLE);
+
+        runCmd = 1;
+        TX_DISABLE;
+
+        if ((Adapter->WakeupTries) ||
+            (Adapter->PSState == PS_STATE_SLEEP
+             && !Adapter->bWakeupDevRequired) ||
+            (!Adapter->IntCounter &&
+             Adapter->PSState == PS_STATE_PRE_SLEEP) ||
+            (!Adapter->IntCounter
+             && (priv->wlan_dev.dnld_sent || Adapter->TxLockFlag
+                 || wmm_lists_empty(priv) || wmm_is_queue_stopped(priv))
+             && (priv->wlan_dev.dnld_sent || !Adapter->CurrentTxSkb)
+             && (priv->wlan_dev.dnld_sent || Adapter->CurCmd ||
+                 list_empty(&Adapter->CmdPendingQ))
+            )
+            ) {
+            PRINTM(INFO, "main-thread sleeping... "
+                   "HS_Act=%s WakeupReq=%s Conn=%s PS_Mode=%d PS_State=%d\n",
+                   (Adapter->HS_Activated) ? "Y" : "N",
+                   (Adapter->bWakeupDevRequired) ? "Y" : "N",
+                   (Adapter->MediaConnectStatus) ? "Y" : "N",
+                   Adapter->PSMode, Adapter->PSState);
+
+#ifdef _MAINSTONE
+            MST_LEDDAT1 = get_utimeofday();
+#endif
+            TX_RESTORE;
+            schedule();
+            PRINTM(INFO, "main-thread waking up: IntCnt=%d "
+                   "CurCmd=%s CmdPending=%s\n"
+                   "                       Connect=%s "
+                   "CurTxSkb=%s dnld_sent=%d\n",
+                   Adapter->IntCounter,
+                   (Adapter->CurCmd) ? "Y" : "N",
+                   list_empty(&Adapter->CmdPendingQ) ? "N" : "Y",
+                   (Adapter->MediaConnectStatus) ? "Y" : "N",
+                   (Adapter->CurrentTxSkb) ? "Y" : "N",
+                   priv->wlan_dev.dnld_sent);
+        } else {
+            TX_RESTORE;
+        }
+
+        OS_SET_THREAD_STATE(TASK_RUNNING);
+        remove_wait_queue(&thread->waitQ, &wait);
+
+        if (kthread_should_stop() || Adapter->SurpriseRemoved) {
+            PRINTM(INFO, "main-thread: break from main thread: "
+                   "SurpriseRemoved=0x%x\n", Adapter->SurpriseRemoved);
+            break;
+        }
+
+        if (Adapter->IntCounter) {
+            OS_INT_DISABLE;
+            Adapter->IntCounter = 0;
+            OS_INT_RESTORE;
+
+            if (sbi_get_int_status(priv, &ireg)) {
+                PRINTM(ERROR,
+                       "main-thread: reading HOST_INT_STATUS_REG failed\n");
+                continue;
+            }
+            OS_INT_DISABLE;
+            Adapter->HisRegCpy |= ireg;
+            OS_INT_RESTORE;
+            PRINTM(INTR, "INT: status = 0x%x\n", Adapter->HisRegCpy);
+        } else if (Adapter->bWakeupDevRequired
+                   && (Adapter->HS_Activated || (Adapter->IsDeepSleep)
+                   )
+            ) {
+            Adapter->WakeupTries++;
+            PRINTM(CMND,
+                   "Wakeup device... WakeupReq=%s Conn=%s PS_Mode=%d PS_State=%d\n",
+                   (Adapter->bWakeupDevRequired) ? "Y" : "N",
+                   (priv->adapter->MediaConnectStatus) ? "Y" : "N",
+                   priv->adapter->PSMode, priv->adapter->PSState);
+
+            /* Wake up device */
+            if (sbi_exit_deep_sleep(priv))
+                PRINTM(MSG, "main-thread: wakeup dev failed\n");
+            continue;
+        }
+
+        /* Command response? */
+        if (Adapter->HisRegCpy & HIS_CmdUpLdRdy) {
+            OS_INT_DISABLE;
+            Adapter->HisRegCpy &= ~HIS_CmdUpLdRdy;
+            OS_INT_RESTORE;
+
+            wlan_process_rx_command(priv);
+        }
+
+        /* Any received data? */
+        if (Adapter->HisRegCpy & HIS_RxUpLdRdy) {
+            OS_INT_DISABLE;
+            Adapter->HisRegCpy &= ~HIS_RxUpLdRdy;
+            OS_INT_RESTORE;
+
+            wlan_send_rxskbQ(priv);
+            runCmd = 0;
+        }
+
+        /* Any Card Event */
+        if (Adapter->HisRegCpy & HIS_CardEvent) {
+            OS_INT_DISABLE;
+            Adapter->HisRegCpy &= ~HIS_CardEvent;
+            OS_INT_RESTORE;
+
+            if (sbi_read_event_cause(priv)) {
+                PRINTM(ERROR, "main-thread: sbi_read_event_cause failed.\n");
+                continue;
+            }
+            wlan_process_event(priv);
+        }
+
+        /* Check if we need to confirm Sleep Request received previously */
+        if (Adapter->PSState == PS_STATE_PRE_SLEEP) {
+            if (!priv->wlan_dev.dnld_sent && !Adapter->CurCmd) {
+                ASSERT(Adapter->MediaConnectStatus ==
+                       WlanMediaStateConnected);
+                PSConfirmSleep(priv, (u16) Adapter->PSMode);
+            }
+        }
+
+        /* The PS state is changed during processing of 
+         * Sleep Request event above 
+         */
+        if ((Adapter->PSState == PS_STATE_SLEEP)
+            || (Adapter->PSState == PS_STATE_PRE_SLEEP)) {
+            continue;
+        }
+
+        if (Adapter->IsDeepSleep)
+            continue;
+
+        /* The HS_Activated flag is changed during processing of 
+           HS_Activate command resp */
+        /* We cannot send command or data if HS_Activated and 
+           WakeupDevRequired are TRUE */
+        if (Adapter->HS_Activated && Adapter->bWakeupDevRequired) {
+            PRINTM(INFO, "main-thread: cannot send command or data, "
+                   "HS_Activated=%d\n", Adapter->HS_Activated);
+            continue;
+        }
+
+        /* Execute the next command */
+        if (!priv->wlan_dev.dnld_sent && !Adapter->CurCmd && runCmd == 1) {
+            ExecuteNextCommand(priv);
+        }
+
+        if (!priv->wlan_dev.dnld_sent
+            && !wmm_lists_empty(priv) && !wmm_is_queue_stopped(priv)) {
+            if ((Adapter->PSState == PS_STATE_FULL_POWER)
+                || (Adapter->sleep_period.period == 0)
+                || (Adapter->TxLockFlag == FALSE)) {
+                wmm_process_tx(priv);
+            }
+        }
+
+    }
+
+    wlan_deactivate_thread(thread);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ * @brief This function adds the card. it will probe the
+ * card, allocate the wlan_priv and initialize the device. 
+ *  
+ *  @param card    A pointer to card
+ *  @return        A pointer to wlan_private structure
+ */
+wlan_private *
+wlan_add_card(void *card, struct device *dmdev)
+{
+    struct net_device *dev = NULL;
+    wlan_private *priv = NULL;
+
+    ENTER();
+
+    /* probe the card */
+    if (sbi_probe_card(card) < 0) {
+        PRINTM(MSG, "NO card found!\n");
+        return NULL;
+    }
+
+    /* Allocate an Ethernet device and register it */
+    if (!(dev = alloc_etherdev(sizeof(wlan_private)))) {
+        PRINTM(MSG, "Init ethernet device failed!\n");
+        return NULL;
+    }
+
+    priv = dev->priv;
+
+    /* allocate buffer for wlan_adapter */
+    if (!(priv->adapter = kmalloc(sizeof(wlan_adapter), GFP_KERNEL))) {
+        PRINTM(MSG, "Allocate buffer for wlan_adapter failed!\n");
+        goto err_kmalloc;
+    }
+
+    /* init wlan_adapter */
+    memset(priv->adapter, 0, sizeof(wlan_adapter));
+
+    priv->wlan_dev.netdev = dev;
+    priv->wlan_dev.card = card;
+    priv->wlan_dev.hotplug_device = dmdev;
+    wlanpriv = priv;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+    SET_MODULE_OWNER(dev);
+#endif
+
+    /* Setup the OS Interface to our functions */
+    dev->open = wlan_open;
+    dev->hard_start_xmit = wlan_hard_start_xmit;
+    dev->stop = wlan_close;
+    dev->do_ioctl = wlan_do_ioctl;
+    dev->set_mac_address = wlan_set_mac_address;
+
+    dev->tx_timeout = wlan_tx_timeout;
+    dev->get_stats = wlan_get_stats;
+    dev->watchdog_timeo = MRVDRV_DEFAULT_WATCHDOG_TIMEOUT;
+
+#ifdef  WIRELESS_EXT
+#if     WIRELESS_EXT > 17 
+    wlan_handler_def.get_wireless_stats = wlan_get_wireless_stats;
+#else
+    dev->get_wireless_stats = wlan_get_wireless_stats;
+#endif
+    dev->wireless_handlers = (struct iw_handler_def *) &wlan_handler_def;
+#endif
+#define NETIF_F_DYNALLOC 16
+    dev->features |= NETIF_F_DYNALLOC;
+    dev->flags |= IFF_BROADCAST | IFF_MULTICAST;
+    dev->set_multicast_list = wlan_set_multicast_list;
+
+    SET_NETDEV_DEV(dev, dmdev);
+
+    init_waitqueue_head(&priv->adapter->ds_awake_q);
+
+#ifdef ENABLE_PM
+    /* register Driver to Linux Power Management system. */
+    if (!driver_register(&wlan_pm_driver)) {
+        /* Register one device to Linux Power Management system. */
+        if (platform_device_register(&wlan_pm_platform_device)) {
+            PRINTM(MSG,
+                   "WiFi driver, wlan_main : error when registering device to Linux Power Managment.\n");
+            driver_unregister(&wlan_pm_driver);
+        } else {
+            PRINTM(INFO,
+                   "WiFi device and driver registered to Linux Power Managment.\n");
+        }
+    } else {
+        PRINTM(MSG,
+               "WiFi driver, wlan_main : error when registering driver to Linux Power Managment.\n");
+    }
+
+#endif
+
+    INIT_LIST_HEAD(&priv->adapter->CmdFreeQ);
+    INIT_LIST_HEAD(&priv->adapter->CmdPendingQ);
+
+    PRINTM(INFO, "Starting kthread...\n");
+    priv->MainThread.priv = priv;
+    wlan_create_thread(wlan_service_main_thread,
+                       &priv->MainThread, "wlan_main_service");
+
+    ConfigureThreadPriority();
+
+#ifdef REASSOCIATION
+    priv->ReassocThread.priv = priv;
+    wlan_create_thread(wlan_reassociation_thread,
+                       &priv->ReassocThread, "wlan_reassoc_service");
+#endif /* REASSOCIATION */
+
+    /*
+     * Register the device. Fillup the private data structure with
+     * relevant information from the card and request for the required
+     * IRQ. 
+     */
+
+    if (sbi_register_dev(priv) < 0) {
+        PRINTM(FATAL, "Failed to register wlan device!\n");
+        goto err_registerdev;
+    }
+
+    PRINTM(WARN, "%s: Marvell Wlan 802.11 Adapter "
+           "revision 0x%02X at IRQ %i\n", dev->name,
+           priv->adapter->chip_rev, dev->irq);
+
+#ifdef CONFIG_MARVELL_8686_PROC_FS
+    wlan_proc_entry(priv, dev);
+#ifdef CONFIG_MARVELL_8686_DEBUG
+    wlan_debug_entry(priv, dev);
+#endif
+#endif
+
+    /* Get the CIS Table */
+    sbi_get_cis_info(priv);
+
+    /* init FW and HW */
+    if (wlan_init_fw(priv)) {
+        PRINTM(FATAL, "Firmware Init Failed\n");
+        goto err_init_fw;
+    }
+
+    if (register_netdev(dev)) {
+        printk(KERN_ERR "Cannot register network device!\n");
+        goto err_netdev;
+    }
+
+    LEAVE();
+    return priv;
+
+err_netdev:
+    unregister_netdev(dev);
+
+err_init_fw:
+    sbi_unregister_dev(priv);
+
+#ifdef CONFIG_MARVELL_8686_PROC_FS
+#ifdef CONFIG_MARVELL_8686_DEBUG
+    wlan_debug_remove(priv);
+#endif
+    wlan_proc_remove(priv);
+#endif
+
+err_registerdev:
+    /* Stop the thread servicing the interrupts */
+    wake_up_interruptible(&priv->MainThread.waitQ);
+    wlan_terminate_thread(&priv->MainThread);
+
+#ifdef REASSOCIATION
+    wake_up_interruptible(&priv->ReassocThread.waitQ);
+    wlan_terminate_thread(&priv->ReassocThread);
+#endif /* REASSOCIATION */
+
+err_kmalloc:
+    free_netdev(dev);
+    wlan_free_adapter(priv);
+    wlanpriv = NULL;
+
+    LEAVE();
+    return NULL;
+}
+
+/** 
+ *  @brief This function removes the card.
+ *  
+ *  @param priv    A pointer to card
+ *  @return        WLAN_STATUS_SUCCESS
+ */
+int
+wlan_remove_card(void *card)
+{
+    wlan_private *priv = wlanpriv;
+    wlan_adapter *Adapter;
+    struct net_device *dev;
+    union iwreq_data wrqu;
+
+    ENTER();
+
+    if (!priv) {
+        LEAVE();
+        return WLAN_STATUS_SUCCESS;
+    }
+
+    Adapter = priv->adapter;
+
+    if (!Adapter) {
+        LEAVE();
+        return WLAN_STATUS_SUCCESS;
+    }
+
+    dev = priv->wlan_dev.netdev;
+
+    wake_up_interruptible(&Adapter->ds_awake_q);
+
+    if (Adapter->CurCmd) {
+        PRINTM(INFO, "Wake up current cmdwait_q\n");
+        wake_up_interruptible(&Adapter->CurCmd->cmdwait_q);
+    }
+
+    Adapter->CurCmd = NULL;
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        wlan_clean_txrx(priv);
+        Adapter->MediaConnectStatus = WlanMediaStateDisconnected;
+    }
+    Adapter->IsAutoDeepSleepEnabled = FALSE;
+    if (Adapter->IsDeepSleep == TRUE) {
+        sbi_exit_deep_sleep(priv);
+        if (Adapter->IsDeepSleep == TRUE) {
+            if (os_wait_interruptible_timeout(Adapter->ds_awake_q,
+                                              !Adapter->IsDeepSleep,
+                                              MRVDRV_DEEP_SLEEP_EXIT_TIMEOUT)
+                == 0) {
+                PRINTM(MSG, "ds_awake_q: timer expired\n");
+            }
+        }
+    }
+
+    if (Adapter->PSMode == Wlan802_11PowerModeMAX_PSP) {
+        Adapter->PSMode = Wlan802_11PowerModeCAM;
+        PSWakeup(priv, HostCmd_OPTION_WAITFORRSP);
+    }
+
+    memset(wrqu.ap_addr.sa_data, 0xaa, ETH_ALEN);
+    wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+    wireless_send_event(priv->wlan_dev.netdev, SIOCGIWAP, &wrqu, NULL);
+
+    /* Disable interrupts on the card as we cannot handle them after RESET */
+    sbi_disable_host_int(priv);
+
+    PrepareAndSendCommand(priv, HostCmd_CMD_802_11_RESET, 0, 0, 0, NULL);
+
+    os_sched_timeout(500);
+
+#ifdef ENABLE_PM
+    /* unregister driver and device from Linux Power Management system. */
+    platform_device_unregister(&wlan_pm_platform_device);
+    driver_unregister(&wlan_pm_driver);
+#endif
+
+    Adapter->SurpriseRemoved = TRUE;
+
+    /* Stop the thread servicing the interrupts */
+    wake_up_interruptible(&priv->MainThread.waitQ);
+
+#ifdef REASSOCIATION
+    wake_up_interruptible(&priv->ReassocThread.waitQ);
+#endif /* REASSOCIATION */
+
+#ifdef CONFIG_MARVELL_8686_PROC_FS
+#ifdef CONFIG_MARVELL_8686_DEBUG
+    wlan_debug_remove(priv);
+#endif
+    wlan_proc_remove(priv);
+#endif
+
+    PRINTM(INFO, "unregester dev\n");
+    sbi_unregister_dev(priv);
+
+    /* Last reference is our one */
+    PRINTM(INFO, "refcnt = %d\n", atomic_read(&dev->refcnt));
+
+    PRINTM(INFO, "netdev_finish_unregister: %s%s.\n", dev->name,
+           (dev->features & NETIF_F_DYNALLOC) ? "" : ", old style");
+
+    unregister_netdev(dev);
+
+    PRINTM(INFO, "Unregister finish\n");
+
+    priv->wlan_dev.netdev = NULL;
+    PRINTM(INFO, "Free Adapter\n");
+    wlan_free_adapter(priv);
+    free_netdev(dev);
+    wlanpriv = NULL;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/********************************************************
+        Global Functions
+********************************************************/
+
+/**
+ * @brief This function sends the rx packets to the os from the skb queue
+ *
+ * @param priv  A pointer to wlan_private structure
+ * @return  n/a
+ */
+void
+wlan_send_rxskbQ(wlan_private * priv)
+{
+    struct sk_buff *skb;
+
+    ENTER();
+    if (priv->adapter) {
+        while ((skb = wlan_pop_rx_skb(&priv->adapter->RxSkbQ))) {
+            if (ProcessRxedPacket(priv, skb) == -ENOMEM)
+                break;
+        }
+    }
+    LEAVE();
+}
+
+/** 
+ *  @brief This function finds the CFP in 
+ *  region_cfp_table based on region and band parameter.
+ *  
+ *  @param region  The region code
+ *  @param band    The band
+ *  @param cfp_no  A pointer to CFP number
+ *  @return        A pointer to CFP
+ */
+CHANNEL_FREQ_POWER *
+wlan_get_region_cfp_table(u8 region, u8 band, int *cfp_no)
+{
+    int i;
+
+    ENTER();
+
+    for (i = 0; i < sizeof(region_cfp_table) / sizeof(region_cfp_table_t);
+         i++) {
+        PRINTM(INFO, "region_cfp_table[i].region=%d\n",
+               region_cfp_table[i].region);
+        if (region_cfp_table[i].region == region) {
+            {
+                *cfp_no = region_cfp_table[i].cfp_no_BG;
+                LEAVE();
+                return region_cfp_table[i].cfp_BG;
+            }
+        }
+    }
+
+    LEAVE();
+    return NULL;
+}
+
+/** 
+ *  @brief This function sets region table. 
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param region  The region code
+ *  @param band    The band
+ *  @return        WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_set_regiontable(wlan_private * priv, u8 region, u8 band)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int i = 0;
+
+    CHANNEL_FREQ_POWER *cfp;
+    int cfp_no;
+
+    ENTER();
+
+    memset(Adapter->region_channel, 0, sizeof(Adapter->region_channel));
+
+    {
+        cfp = wlan_get_region_cfp_table(region, band, &cfp_no);
+        if (cfp != NULL) {
+            Adapter->region_channel[i].NrCFP = cfp_no;
+            Adapter->region_channel[i].CFP = cfp;
+        } else {
+            PRINTM(INFO, "wrong region code %#x in Band B-G\n", region);
+            return WLAN_STATUS_FAILURE;
+        }
+        Adapter->region_channel[i].Valid = TRUE;
+        Adapter->region_channel[i].Region = region;
+        Adapter->region_channel[i].Band = band;
+        i++;
+    }
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the interrupt. it will change PS
+ *  state if applicable. it will wake up main_thread to handle
+ *  the interrupt event as well.
+ *  
+ *  @param dev     A pointer to net_device structure
+ *  @return        n/a
+ */
+void
+wlan_interrupt(struct net_device *dev)
+{
+    wlan_private *priv = dev->priv;
+
+    priv->adapter->IntCounter++;
+
+    PRINTM(INTR, "*\n");
+
+    priv->adapter->WakeupTries = 0;
+
+    if (priv->adapter->PSState == PS_STATE_SLEEP) {
+        priv->adapter->PSState = PS_STATE_AWAKE;
+    }
+
+    wake_up_interruptible(&priv->MainThread.waitQ);
+}
+
+#if 0
+/** 
+ *  @brief This function initializes module.
+ *  
+ *  @param     n/a    A pointer to wlan_private structure
+ *  @return        WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_init_module(void)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (sbi_register(wlan_add_card, wlan_remove_card, NULL) == NULL) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function cleans module
+ *  
+ *  @param priv    n/a
+ *  @return        n/a
+ */
+void
+wlan_cleanup_module(void)
+{
+    ENTER();
+
+    sbi_unregister();
+
+    LEAVE();
+}
+
+module_init(wlan_init_module);
+module_exit(wlan_cleanup_module);
+#endif
+
+MODULE_DESCRIPTION("M-WLAN Driver");
+MODULE_AUTHOR("Marvell International Ltd.");
Index: linux-2.6.29/drivers/net/wireless/marvell8686/wlan_proc.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/wlan_proc.c	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,213 @@
+/** @file wlan_proc.c
+  * @brief This file contains functions for proc fin proc file.
+  * 
+  *  Copyright  Marvell International Ltd. and/or its affiliates, 2003-2006
+  */
+/********************************************************
+Change log:
+	10/04/05: Add Doxygen format comments
+	01/05/06: Add kernel 2.6.x support	
+	
+********************************************************/
+#include 	"include.h"
+
+#ifdef CONFIG_MARVELL_8686_PROC_FS
+/********************************************************
+		Local Variables
+********************************************************/
+
+static char *szModes[] = {
+    "Ad-hoc",
+    "Managed",
+    "Auto",
+    "Unknown"
+};
+
+/********************************************************
+		Global Variables
+********************************************************/
+
+/********************************************************
+		Local Functions
+********************************************************/
+
+/** 
+ *  @brief proc read function
+ *
+ *  @param page	   pointer to buffer
+ *  @param start   read data starting position
+ *  @param offset  offset
+ *  @param count   counter 
+ *  @param eof     end of file flag
+ *  @param data    data to output
+ *  @return 	   number of output data
+ */
+static int
+wlan_proc_read(char *page, char **start, off_t offset,
+               int count, int *eof, void *data)
+{
+    int i;
+    char *p = page;
+    struct net_device *netdev = data;
+    struct dev_mc_list *mcptr = netdev->mc_list;
+    char fmt[64];
+    wlan_private *priv = netdev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    ulong flags;
+
+    if (offset != 0) {
+        *eof = 1;
+        goto exit;
+    }
+
+    get_version(Adapter, fmt, sizeof(fmt) - 1);
+
+    p += sprintf(p, "driver_name = " "\"wlan\"\n");
+    p += sprintf(p, "driver_version = %s", fmt);
+    p += sprintf(p, "\nInterfaceName=\"%s\"\n", netdev->name);
+    p += sprintf(p, "Mode=\"%s\"\n", szModes[Adapter->InfrastructureMode]);
+    p += sprintf(p, "State=\"%s\"\n",
+                 ((Adapter->MediaConnectStatus ==
+                   WlanMediaStateDisconnected) ? "Disconnected" :
+                  "Connected"));
+    p += sprintf(p, "MACAddress=\"%02x:%02x:%02x:%02x:%02x:%02x\"\n",
+                 netdev->dev_addr[0], netdev->dev_addr[1],
+                 netdev->dev_addr[2], netdev->dev_addr[3],
+                 netdev->dev_addr[4], netdev->dev_addr[5]);
+
+    p += sprintf(p, "MCCount=\"%d\"\n", netdev->mc_count);
+    p += sprintf(p, "ESSID=\"%s\"\n",
+                 (u8 *) Adapter->CurBssParams.BSSDescriptor.Ssid.Ssid);
+    p += sprintf(p, "Channel=\"%d\"\n",
+                 Adapter->CurBssParams.BSSDescriptor.Channel);
+    p += sprintf(p, "region_code = \"%02x\"\n", (u32) Adapter->RegionCode);
+
+    /*
+     * Put out the multicast list 
+     */
+    for (i = 0; i < netdev->mc_count; i++) {
+        p += sprintf(p,
+                     "MCAddr[%d]=\"%02x:%02x:%02x:%02x:%02x:%02x\"\n",
+                     i,
+                     mcptr->dmi_addr[0], mcptr->dmi_addr[1],
+                     mcptr->dmi_addr[2], mcptr->dmi_addr[3],
+                     mcptr->dmi_addr[4], mcptr->dmi_addr[5]);
+
+        mcptr = mcptr->next;
+    }
+    p += sprintf(p, "num_tx_bytes = %lu\n", priv->stats.tx_bytes);
+    p += sprintf(p, "num_rx_bytes = %lu\n", priv->stats.rx_bytes);
+    p += sprintf(p, "num_tx_pkts = %lu\n", priv->stats.tx_packets);
+    p += sprintf(p, "num_rx_pkts = %lu\n", priv->stats.rx_packets);
+    p += sprintf(p, "num_tx_pkts_dropped = %lu\n", priv->stats.tx_dropped);
+    p += sprintf(p, "num_rx_pkts_dropped = %lu\n", priv->stats.rx_dropped);
+    p += sprintf(p, "num_tx_pkts_err = %lu\n", priv->stats.tx_errors);
+    p += sprintf(p, "num_rx_pkts_err = %lu\n", priv->stats.rx_errors);
+    p += sprintf(p, "carrier %s\n",
+                 ((netif_carrier_ok(priv->wlan_dev.netdev)) ? "on" : "off"));
+    p += sprintf(p, "tx queue %s\n",
+                 ((netif_queue_stopped(priv->wlan_dev.netdev)) ? "stopped" :
+                  "started"));
+
+    spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+    if (Adapter->CurCmd) {
+        HostCmd_DS_COMMAND *CmdPtr =
+            (HostCmd_DS_COMMAND *) Adapter->CurCmd->BufVirtualAddr;
+        p += sprintf(p, "CurCmd ID = 0x%x, 0x%x\n",
+                     wlan_cpu_to_le16(CmdPtr->Command),
+                     wlan_cpu_to_le16(*(u16 *) ((u8 *) CmdPtr + S_DS_GEN)));
+    } else {
+        p += sprintf(p, "CurCmd NULL\n");
+    }
+    spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+
+  exit:
+    return (p - page);
+}
+
+/********************************************************
+		Global Functions
+********************************************************/
+
+/** 
+ *  @brief create wlan proc file
+ *
+ *  @param priv	   pointer wlan_private
+ *  @param dev     pointer net_device
+ *  @return 	   N/A
+ */
+void
+wlan_proc_entry(wlan_private * priv, struct net_device *dev)
+{
+
+    PRINTM(INFO, "Creating Proc Interface\n");
+
+    if (!priv->proc_entry) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+        priv->proc_entry = proc_mkdir("wlan", init_net.proc_net);
+#else
+        priv->proc_entry = proc_mkdir("wlan", proc_net);
+#endif
+        
+
+        if (priv->proc_entry) {
+            priv->proc_dev = create_proc_read_entry
+                ("info", 0, priv->proc_entry, wlan_proc_read, dev);
+        }
+    }
+}
+
+/** 
+ *  @brief remove proc file
+ *
+ *  @param priv	   pointer wlan_private
+ *  @return 	   N/A
+ */
+void
+wlan_proc_remove(wlan_private * priv)
+{
+
+    if (priv->proc_entry) {
+        remove_proc_entry("info", priv->proc_entry);
+    }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+    remove_proc_entry("wlan", init_net.proc_net);
+#else
+    remove_proc_entry("wlan", proc_net);
+#endif
+
+}
+
+/** 
+ *  @brief convert string to number
+ *
+ *  @param s   	   pointer to numbered string
+ *  @return 	   converted number from string s
+ */
+int
+string_to_number(char *s)
+{
+    int r = 0;
+    int base = 0;
+
+    if ((strncmp(s, "0x", 2) == 0) || (strncmp(s, "0X", 2) == 0))
+        base = 16;
+    else
+        base = 10;
+    if (base == 16)
+        s += 2;
+    for (s = s; *s != 0; s++) {
+        if ((*s >= 48) && (*s <= 57))
+            r = (r * base) + (*s - 48);
+        else if ((*s >= 65) && (*s <= 70))
+            r = (r * base) + (*s - 55);
+        else if ((*s >= 97) && (*s <= 102))
+            r = (r * base) + (*s - 87);
+        else
+            break;
+    }
+
+    return r;
+}
+
+#endif
Index: linux-2.6.29/drivers/net/wireless/marvell8686/wlan_rx.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/wlan_rx.c	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,367 @@
+/** @file wlan_rx.c
+  * @brief This file contains the handling of RX in wlan
+  * driver.
+  * 
+  *  Copyright  Marvell International Ltd. and/or its affiliates, 2003-2006
+  */
+/********************************************************
+Change log:
+	09/28/05: Add Doxygen format comments
+	12/09/05: ADD Sliding window SNR/NF Average Calculation support
+	
+********************************************************/
+
+#include	"include.h"
+
+/********************************************************
+		Local Variables
+********************************************************/
+
+typedef struct
+{
+    u8 dest_addr[6];
+    u8 src_addr[6];
+    u16 h803_len;
+
+} __ATTRIB_PACK__ Eth803Hdr_t;
+
+typedef struct
+{
+    u8 llc_dsap;
+    u8 llc_ssap;
+    u8 llc_ctrl;
+    u8 snap_oui[3];
+    u16 snap_type;
+
+} __ATTRIB_PACK__ Rfc1042Hdr_t;
+
+typedef struct
+{
+    Eth803Hdr_t eth803_hdr;
+    Rfc1042Hdr_t rfc1042_hdr;
+
+} __ATTRIB_PACK__ RxPacketHdr_t;
+
+typedef struct
+{
+    u8 dest_addr[6];
+    u8 src_addr[6];
+    u16 ethertype;
+
+} __ATTRIB_PACK__ EthII_Hdr_t;
+
+/********************************************************
+		Global Variables
+********************************************************/
+
+/********************************************************
+		Local Functions
+********************************************************/
+
+/** 
+ *  @brief This function computes the AvgSNR .
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   AvgSNR
+ */
+static u8
+wlan_getAvgSNR(wlan_private * priv)
+{
+    u8 i;
+    u16 temp = 0;
+    wlan_adapter *Adapter = priv->adapter;
+    if (Adapter->numSNRNF == 0)
+        return 0;
+    for (i = 0; i < Adapter->numSNRNF; i++)
+        temp += Adapter->rawSNR[i];
+    return (u8) (temp / Adapter->numSNRNF);
+
+}
+
+/** 
+ *  @brief This function computes the AvgNF
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   AvgNF
+ */
+static u8
+wlan_getAvgNF(wlan_private * priv)
+{
+    u8 i;
+    u16 temp = 0;
+    wlan_adapter *Adapter = priv->adapter;
+    if (Adapter->numSNRNF == 0)
+        return 0;
+    for (i = 0; i < Adapter->numSNRNF; i++)
+        temp += Adapter->rawNF[i];
+    return (u8) (temp / Adapter->numSNRNF);
+
+}
+
+/** 
+ *  @brief This function save the raw SNR/NF to our internel buffer
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param pRxPD   A pointer to RxPD structure of received packet
+ *  @return 	   n/a
+ */
+static void
+wlan_save_rawSNRNF(wlan_private * priv, RxPD * pRxPD)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    if (Adapter->numSNRNF < Adapter->data_avg_factor)
+        Adapter->numSNRNF++;
+    Adapter->rawSNR[Adapter->nextSNRNF] = pRxPD->SNR;
+    Adapter->rawNF[Adapter->nextSNRNF] = pRxPD->NF;
+    Adapter->nextSNRNF++;
+    if (Adapter->nextSNRNF >= Adapter->data_avg_factor)
+        Adapter->nextSNRNF = 0;
+    return;
+}
+
+#define DATA_RSSI_LOW_BIT		0x01
+#define DATA_SNR_LOW_BIT		0x02
+#define DATA_RSSI_HIGH_BIT		0x04
+#define DATA_SNR_HIGH_BIT		0x08
+/** 
+ *  @brief This function computes the RSSI in received packet.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   n/a
+ */
+static void
+wlan_check_subscribe_event(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int temp;
+    if (Adapter->subevent.EventsBitmap == 0)
+        return;
+    if ((Adapter->subevent.EventsBitmap & DATA_RSSI_LOW_BIT) ||
+        (Adapter->subevent.EventsBitmap & DATA_RSSI_HIGH_BIT)) {
+        temp =
+            -CAL_RSSI(Adapter->SNR[TYPE_RXPD][TYPE_AVG] / AVG_SCALE,
+                      Adapter->NF[TYPE_RXPD][TYPE_AVG] / AVG_SCALE);
+        if (Adapter->subevent.EventsBitmap & DATA_RSSI_LOW_BIT) {
+            if (temp > Adapter->subevent.Rssi_low.value) {
+                if (!Adapter->subevent.Rssi_low.Freq) {
+                    Adapter->subevent.EventsBitmap &= ~DATA_RSSI_LOW_BIT;
+                    send_iwevcustom_event(priv, CUS_EVT_DATA_RSSI_LOW);
+                } else {
+                    Adapter->subevent.Rssi_low_count++;
+                    if (Adapter->subevent.Rssi_low_count >=
+                        Adapter->subevent.Rssi_low.Freq) {
+                        Adapter->subevent.Rssi_low_count = 0;
+                        send_iwevcustom_event(priv, CUS_EVT_DATA_RSSI_LOW);
+                    }
+                }
+            } else
+                Adapter->subevent.Rssi_low_count = 0;
+        }
+        if (Adapter->subevent.EventsBitmap & DATA_RSSI_HIGH_BIT) {
+            if (temp < Adapter->subevent.Rssi_high.value) {
+                if (!Adapter->subevent.Rssi_high.Freq) {
+                    Adapter->subevent.EventsBitmap &= ~DATA_RSSI_HIGH_BIT;
+                    send_iwevcustom_event(priv, CUS_EVT_DATA_RSSI_HIGH);
+                } else {
+                    Adapter->subevent.Rssi_high_count++;
+                    if (Adapter->subevent.Rssi_high_count >=
+                        Adapter->subevent.Rssi_high.Freq) {
+                        Adapter->subevent.Rssi_high_count = 0;
+                        send_iwevcustom_event(priv, CUS_EVT_DATA_RSSI_HIGH);
+                    }
+                }
+            } else
+                Adapter->subevent.Rssi_high_count = 0;
+        }
+    }
+    if ((Adapter->subevent.EventsBitmap & DATA_SNR_LOW_BIT) ||
+        (Adapter->subevent.EventsBitmap & DATA_SNR_HIGH_BIT)) {
+        temp = Adapter->SNR[TYPE_RXPD][TYPE_AVG] / AVG_SCALE;
+        if (Adapter->subevent.EventsBitmap & DATA_SNR_LOW_BIT) {
+            if (temp < Adapter->subevent.Snr_low.value) {
+                if (!Adapter->subevent.Snr_low.Freq) {
+                    send_iwevcustom_event(priv, CUS_EVT_DATA_SNR_LOW);
+                    Adapter->subevent.EventsBitmap &= ~DATA_SNR_LOW_BIT;
+                } else {
+                    Adapter->subevent.Snr_low_count++;
+                    if (Adapter->subevent.Snr_low_count >=
+                        Adapter->subevent.Snr_low.Freq) {
+                        Adapter->subevent.Snr_low_count = 0;
+                        send_iwevcustom_event(priv, CUS_EVT_DATA_SNR_LOW);
+                    }
+                }
+            } else
+                Adapter->subevent.Snr_low_count = 0;
+        }
+        if (Adapter->subevent.EventsBitmap & DATA_SNR_HIGH_BIT) {
+            if (temp > Adapter->subevent.Snr_high.value) {
+                if (!Adapter->subevent.Snr_high.Freq) {
+                    Adapter->subevent.EventsBitmap &= ~DATA_SNR_HIGH_BIT;
+                    send_iwevcustom_event(priv, CUS_EVT_DATA_SNR_HIGH);
+                } else {
+                    Adapter->subevent.Snr_high_count++;
+                    if (Adapter->subevent.Snr_high_count >=
+                        Adapter->subevent.Snr_high.Freq) {
+                        Adapter->subevent.Snr_high_count = 0;
+                        send_iwevcustom_event(priv, CUS_EVT_DATA_SNR_HIGH);
+                    }
+                }
+
+            } else
+                Adapter->subevent.Snr_high_count = 0;
+        }
+    }
+    return;
+}
+
+/** 
+ *  @brief This function computes the RSSI in received packet.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param pRxPD   A pointer to RxPD structure of received packet
+ *  @return 	   n/a
+ */
+static void
+wlan_compute_rssi(wlan_private * priv, RxPD * pRxPD)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    PRINTM(INFO, "RxPD: SNR = %d, NF = %d\n", pRxPD->SNR, pRxPD->NF);
+
+    Adapter->SNR[TYPE_RXPD][TYPE_NOAVG] = pRxPD->SNR;
+    Adapter->NF[TYPE_RXPD][TYPE_NOAVG] = pRxPD->NF;
+    wlan_save_rawSNRNF(priv, pRxPD);
+
+    Adapter->RxPDAge = os_time_get();
+    Adapter->RxPDRate = pRxPD->RxRate;
+
+    Adapter->SNR[TYPE_RXPD][TYPE_AVG] = wlan_getAvgSNR(priv) * AVG_SCALE;
+    Adapter->NF[TYPE_RXPD][TYPE_AVG] = wlan_getAvgNF(priv) * AVG_SCALE;
+    PRINTM(INFO, "SNR-avg = %d, NF-avg = %d\n",
+           Adapter->SNR[TYPE_RXPD][TYPE_AVG] / AVG_SCALE,
+           Adapter->NF[TYPE_RXPD][TYPE_AVG] / AVG_SCALE);
+
+    Adapter->RSSI[TYPE_RXPD][TYPE_NOAVG] =
+        CAL_RSSI(Adapter->SNR[TYPE_RXPD][TYPE_NOAVG],
+                 Adapter->NF[TYPE_RXPD][TYPE_NOAVG]);
+
+    Adapter->RSSI[TYPE_RXPD][TYPE_AVG] =
+        CAL_RSSI(Adapter->SNR[TYPE_RXPD][TYPE_AVG] / AVG_SCALE,
+                 Adapter->NF[TYPE_RXPD][TYPE_AVG] / AVG_SCALE);
+    wlan_check_subscribe_event(priv);
+    LEAVE();
+}
+
+/********************************************************
+		Global functions
+********************************************************/
+
+/**
+ *  @brief This function processes received packet and forwards it
+ *  to kernel/upper layer
+ *  
+ *  @param priv    A pointer to wlan_private
+ *  @param skb     A pointer to skb which includes the received packet
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+ProcessRxedPacket(wlan_private * priv, struct sk_buff *skb)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+
+    RxPacketHdr_t *pRxPkt;
+    RxPD *pRxPD;
+
+    int hdrChop;
+    EthII_Hdr_t *pEthHdr;
+    u32 u32SkbLen = skb->len;
+
+    const u8 rfc1042_eth_hdr[] = { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };
+
+    ENTER();
+
+    pRxPD = (RxPD *) skb->data;
+    pRxPkt = (RxPacketHdr_t *) ((u8 *) pRxPD + pRxPD->PktOffset);
+
+    DBG_HEXDUMP(DAT_D, "Rx", skb->data, MIN(skb->len, MAX_DATA_DUMP_LEN));
+
+    endian_convert_RxPD(pRxPD);
+
+    if (skb->len < (ETH_HLEN + 8 + pRxPD->PktOffset)) {
+        PRINTM(ERROR, "RX Error: FRAME RECEIVED WITH BAD LENGTH\n");
+        priv->stats.rx_length_errors++;
+        ret = WLAN_STATUS_SUCCESS;
+        kfree_skb(skb);
+        goto done;
+    }
+
+    PRINTM(INFO, "RX Data: skb->len - pRxPD->PktOffset = %d - %d = %d\n",
+           skb->len, pRxPD->PktOffset, skb->len - pRxPD->PktOffset);
+
+    HEXDUMP("RX Data: Dest", pRxPkt->eth803_hdr.dest_addr,
+            sizeof(pRxPkt->eth803_hdr.dest_addr));
+    HEXDUMP("RX Data: Src", pRxPkt->eth803_hdr.src_addr,
+            sizeof(pRxPkt->eth803_hdr.src_addr));
+
+    if (memcmp(&pRxPkt->rfc1042_hdr,
+               rfc1042_eth_hdr, sizeof(rfc1042_eth_hdr)) == 0) {
+        /* 
+         *  Replace the 803 header and rfc1042 header (llc/snap) with an 
+         *    EthernetII header, keep the src/dst and snap_type (ethertype)
+         *
+         *  The firmware only passes up SNAP frames converting
+         *    all RX Data from 802.11 to 802.2/LLC/SNAP frames.
+         *
+         *  To create the Ethernet II, just move the src, dst address right
+         *    before the snap_type.
+         */
+        pEthHdr = (EthII_Hdr_t *)
+            ((u8 *) & pRxPkt->eth803_hdr
+             + sizeof(pRxPkt->eth803_hdr) + sizeof(pRxPkt->rfc1042_hdr)
+             - sizeof(pRxPkt->eth803_hdr.dest_addr)
+             - sizeof(pRxPkt->eth803_hdr.src_addr)
+             - sizeof(pRxPkt->rfc1042_hdr.snap_type));
+
+        memcpy(pEthHdr->src_addr, pRxPkt->eth803_hdr.src_addr,
+               sizeof(pEthHdr->src_addr));
+        memcpy(pEthHdr->dest_addr, pRxPkt->eth803_hdr.dest_addr,
+               sizeof(pEthHdr->dest_addr));
+
+        /* Chop off the RxPD + the excess memory from the 802.2/llc/snap header
+         *   that was removed 
+         */
+        hdrChop = (u8 *) pEthHdr - (u8 *) pRxPD;
+    } else {
+        HEXDUMP("RX Data: LLC/SNAP",
+                (u8 *) & pRxPkt->rfc1042_hdr, sizeof(pRxPkt->rfc1042_hdr));
+
+        /* Chop off the RxPD */
+        hdrChop = (u8 *) & pRxPkt->eth803_hdr - (u8 *) pRxPD;
+    }
+
+    /* Chop off the leading header bytes so the skb points to the start of 
+     *   either the reconstructed EthII frame or the 802.2/llc/snap frame
+     */
+    skb_pull(skb, hdrChop);
+
+    u32SkbLen = skb->len;
+    wlan_compute_rssi(priv, pRxPD);
+
+    if (os_upload_rx_packet(priv, skb)) {
+        PRINTM(ERROR, "RX Error: os_upload_rx_packet" " returns failure\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+    priv->stats.rx_bytes += u32SkbLen;
+    priv->stats.rx_packets++;
+
+    PRINTM(DATA, "Data => kernel\n");
+
+    ret = WLAN_STATUS_SUCCESS;
+  done:
+    LEAVE();
+
+    return (ret);
+}
Index: linux-2.6.29/drivers/net/wireless/marvell8686/wlan_scan.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/wlan_scan.c	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,3226 @@
+/** @file wlan_scan.c
+ *
+ *  @brief Functions implementing wlan scan IOCTL and firmware command APIs
+ *
+ *  IOCTL handlers as well as command preperation and response routines
+ *   for sending scan commands to the firmware.
+ *
+ *  Copyright  Marvell International Ltd. and/or its affiliates, 2003-2007
+ *
+ *  @sa wlan_scan.h
+ */
+/********************************************************
+Change Log:
+    01/11/06: Initial revision. New scan code, relocate related functions
+    01/19/06: Update specific scan routines to discard old results for adhoc
+    01/31/06: Add support for selectively enabling the FW Scan channel filter
+
+************************************************************/
+
+#include    "include.h"
+
+/********************************************************
+    Local Constants
+********************************************************/
+
+//! Approximate amount of data needed to pass a scan result back to iwlist
+#define MAX_SCAN_CELL_SIZE  (IW_EV_ADDR_LEN             \
+                             + MRVDRV_MAX_SSID_LENGTH   \
+                             + IW_EV_UINT_LEN           \
+                             + IW_EV_FREQ_LEN           \
+                             + IW_EV_QUAL_LEN           \
+                             + MRVDRV_MAX_SSID_LENGTH   \
+                             + IW_EV_PARAM_LEN          \
+                             + 40)      /* 40 for WPAIE */
+
+//! Memory needed to store a max sized Channel List TLV for a firmware scan
+#define CHAN_TLV_MAX_SIZE  (sizeof(MrvlIEtypesHeader_t)         \
+                            + (MRVDRV_MAX_CHANNELS_PER_SCAN     \
+                               * sizeof(ChanScanParamSet_t)))
+
+//! Memory needed to store a max number/size SSID TLV for a firmware scan
+#define SSID_TLV_MAX_SIZE  (1 * sizeof(MrvlIEtypes_SsIdParamSet_t))
+
+//! WPS TLV MAX size is MAX IE size plus 2 bytes for u16 MRVL TLV extension
+#define WPS_TLV_MAX_SIZE   (sizeof(IEEEtypes_VendorSpecific_t) + 2)
+
+//! Maximum memory needed for a wlan_scan_cmd_config with all TLVs at max
+#define MAX_SCAN_CFG_ALLOC (sizeof(wlan_scan_cmd_config)        \
+                            + sizeof(MrvlIEtypes_NumProbes_t)   \
+                            + CHAN_TLV_MAX_SIZE                 \
+                            + SSID_TLV_MAX_SIZE                 \
+                            + WPS_TLV_MAX_SIZE)
+
+//! The maximum number of channels the firmware can scan per command
+#define MRVDRV_MAX_CHANNELS_PER_SCAN   14
+
+/**
+ * @brief Number of channels to scan per firmware scan command issuance.
+ *
+ *  Number restricted to prevent hitting the limit on the amount of scan data
+ *  returned in a single firmware scan command.
+ */
+#define MRVDRV_CHANNELS_PER_SCAN_CMD   4
+
+//! Macro to enable/disable SSID checking before storing a scan table
+#ifdef DISCARD_BAD_SSID
+#define CHECK_SSID_IS_VALID(x) ssid_valid(&bssidEntry.Ssid)
+#else
+#define CHECK_SSID_IS_VALID(x) TRUE
+#endif
+
+/********************************************************
+    Local Variables and Types
+********************************************************/
+
+/**
+ * @brief Interally used to send a configured scan cmd between driver routines
+ */
+typedef union
+{
+    wlan_scan_cmd_config config;        //!< Scan configuration (variable length)
+    u8 configAllocBuf[MAX_SCAN_CFG_ALLOC];      //!< Max allocated block
+} wlan_scan_cmd_config_tlv;
+
+/**
+ *  @brief Check if a scanned network compatible with the driver settings
+ *
+ *   WEP     WPA     WPA2    ad-hoc  encrypt                      Network
+ * enabled enabled  enabled   AES     mode   Privacy  WPA  WPA2  Compatible
+ *    0       0        0       0      NONE      0      0    0   yes No security
+ *    0       1        0       0       x        1x     1    x   yes WPA
+ *    0       0        1       0       x        1x     x    1   yes WPA2
+ *    0       0        0       1      NONE      1      0    0   yes Ad-hoc AES
+ *
+ *    1       0        0       0      NONE      1      0    0   yes Static WEP
+ *    0       0        0       0     !=NONE     1      0    0   yes Dynamic WEP
+ *
+ *
+ *  @param Adapter A pointer to wlan_adapter
+ *  @param index   Index in ScanTable to check against current driver settings
+ *  @param mode    Network mode: Infrastructure or IBSS
+ *
+ *  @return        Index in ScanTable, or error code if negative
+ */
+static int
+IsNetworkCompatible(wlan_adapter * Adapter, int index, int mode)
+{
+    BSSDescriptor_t *pBSSDesc;
+
+    ENTER();
+
+    pBSSDesc = &Adapter->ScanTable[index];
+
+    /* Don't check for compatibility if roaming */
+    if ((Adapter->MediaConnectStatus == WlanMediaStateConnected)
+        && (Adapter->InfrastructureMode == Wlan802_11Infrastructure)
+        && (pBSSDesc->InfrastructureMode == Wlan802_11Infrastructure)) {
+        LEAVE();
+        return index;
+    }
+
+    if (Adapter->wps.SessionEnable == TRUE) {
+        PRINTM(INFO, "Return success directly in WPS period\n");
+        LEAVE();
+        return index;
+    }
+
+    if (pBSSDesc->InfrastructureMode == mode) {
+        if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPDisabled
+            && !Adapter->SecInfo.WPAEnabled
+            && !Adapter->SecInfo.WPA2Enabled
+            && pBSSDesc->wpaIE.VendHdr.ElementId != WPA_IE
+            && pBSSDesc->rsnIE.IeeeHdr.ElementId != RSN_IE
+            && !Adapter->AdhocAESEnabled
+            && Adapter->SecInfo.EncryptionMode == CIPHER_NONE
+            && !pBSSDesc->Privacy) {
+            /* no security */
+            LEAVE();
+            return index;
+        } else if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPEnabled
+                   && !Adapter->SecInfo.WPAEnabled
+                   && !Adapter->SecInfo.WPA2Enabled
+                   && !Adapter->AdhocAESEnabled && pBSSDesc->Privacy) {
+            /* static WEP enabled */
+            LEAVE();
+            return index;
+        } else if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPDisabled
+                   && Adapter->SecInfo.WPAEnabled
+                   && !Adapter->SecInfo.WPA2Enabled
+                   && (pBSSDesc->wpaIE.VendHdr.ElementId == WPA_IE)
+                   && !Adapter->AdhocAESEnabled
+                   /* Privacy bit may NOT be set in some APs like LinkSys WRT54G
+                      && pBSSDesc->Privacy */
+            ) {
+            /* WPA enabled */
+            PRINTM(INFO, "IsNetworkCompatible() WPA: index=%d wpa_ie=%#x "
+                   "wpa2_ie=%#x WEP=%s WPA=%s WPA2=%s EncMode=%#x "
+                   "privacy=%#x\n",
+                   index,
+                   pBSSDesc->wpaIE.VendHdr.ElementId,
+                   pBSSDesc->rsnIE.IeeeHdr.ElementId,
+                   (Adapter->SecInfo.WEPStatus ==
+                    Wlan802_11WEPEnabled) ? "e" : "d",
+                   (Adapter->SecInfo.WPAEnabled) ? "e" : "d",
+                   (Adapter->SecInfo.WPA2Enabled) ? "e" : "d",
+                   Adapter->SecInfo.EncryptionMode, pBSSDesc->Privacy);
+            LEAVE();
+            return index;
+        } else if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPDisabled
+                   && !Adapter->SecInfo.WPAEnabled
+                   && Adapter->SecInfo.WPA2Enabled
+                   && (pBSSDesc->rsnIE.IeeeHdr.ElementId == RSN_IE)
+                   && !Adapter->AdhocAESEnabled
+                   /* Privacy bit may NOT be set in some APs like LinkSys WRT54G
+                      && pBSSDesc->Privacy */
+            ) {
+            /* WPA2 enabled */
+            PRINTM(INFO, "IsNetworkCompatible() WPA2: index=%d wpa_ie=%#x "
+                   "wpa2_ie=%#x WEP=%s WPA=%s WPA2=%s EncMode=%#x "
+                   "privacy=%#x\n",
+                   index,
+                   pBSSDesc->wpaIE.VendHdr.ElementId,
+                   pBSSDesc->rsnIE.IeeeHdr.ElementId,
+                   (Adapter->SecInfo.WEPStatus ==
+                    Wlan802_11WEPEnabled) ? "e" : "d",
+                   (Adapter->SecInfo.WPAEnabled) ? "e" : "d",
+                   (Adapter->SecInfo.WPA2Enabled) ? "e" : "d",
+                   Adapter->SecInfo.EncryptionMode, pBSSDesc->Privacy);
+            LEAVE();
+            return index;
+        } else if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPDisabled
+                   && !Adapter->SecInfo.WPAEnabled
+                   && !Adapter->SecInfo.WPA2Enabled
+                   && (pBSSDesc->wpaIE.VendHdr.ElementId != WPA_IE)
+                   && (pBSSDesc->rsnIE.IeeeHdr.ElementId != RSN_IE)
+                   && Adapter->AdhocAESEnabled
+                   && Adapter->SecInfo.EncryptionMode == CIPHER_NONE
+                   && pBSSDesc->Privacy) {
+            /* Ad-hoc AES enabled */
+            LEAVE();
+            return index;
+        } else if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPDisabled
+                   && !Adapter->SecInfo.WPAEnabled
+                   && !Adapter->SecInfo.WPA2Enabled
+                   && (pBSSDesc->wpaIE.VendHdr.ElementId != WPA_IE)
+                   && (pBSSDesc->rsnIE.IeeeHdr.ElementId != RSN_IE)
+                   && !Adapter->AdhocAESEnabled
+                   && Adapter->SecInfo.EncryptionMode != CIPHER_NONE
+                   && pBSSDesc->Privacy) {
+            /* dynamic WEP enabled */
+            PRINTM(INFO, "IsNetworkCompatible() dynamic WEP: index=%d "
+                   "wpa_ie=%#x wpa2_ie=%#x EncMode=%#x privacy=%#x\n",
+                   index,
+                   pBSSDesc->wpaIE.VendHdr.ElementId,
+                   pBSSDesc->rsnIE.IeeeHdr.ElementId,
+                   Adapter->SecInfo.EncryptionMode, pBSSDesc->Privacy);
+            LEAVE();
+            return index;
+        }
+
+        /* security doesn't match */
+        PRINTM(INFO, "IsNetworkCompatible() FAILED: index=%d wpa_ie=%#x "
+               "wpa2_ie=%#x WEP=%s WPA=%s WPA2=%s EncMode=%#x privacy=%#x\n",
+               index,
+               pBSSDesc->wpaIE.VendHdr.ElementId,
+               pBSSDesc->rsnIE.IeeeHdr.ElementId,
+               (Adapter->SecInfo.WEPStatus ==
+                Wlan802_11WEPEnabled) ? "e" : "d",
+               (Adapter->SecInfo.WPAEnabled) ? "e" : "d",
+               (Adapter->SecInfo.WPA2Enabled) ? "e" : "d",
+               Adapter->SecInfo.EncryptionMode, pBSSDesc->Privacy);
+        LEAVE();
+        return -ECONNREFUSED;
+    }
+
+    /* mode doesn't match */
+    LEAVE();
+    return -ENETUNREACH;
+}
+
+/**
+ *  @brief This function validates a SSID as being able to be printed
+ *
+ *  @param pSsid   SSID structure to validate
+ *
+ *  @return        TRUE or FALSE
+ */
+static BOOLEAN
+ssid_valid(WLAN_802_11_SSID * pSsid)
+{
+    int ssidIdx;
+
+    for (ssidIdx = 0; ssidIdx < pSsid->SsidLength; ssidIdx++) {
+        if (!isprint(pSsid->Ssid[ssidIdx])) {
+            return FALSE;
+        }
+    }
+
+    return TRUE;
+}
+
+/**
+ *  @brief Post process the scan table after a new scan command has completed
+ *
+ *  Inspect each entry of the scan table and try to find an entry that
+ *    matches our current associated/joined network from the scan.  If
+ *    one is found, update the stored copy of the BSSDescriptor for our
+ *    current network.
+ *
+ *  Debug dump the current scan table contents if compiled accordingly.
+ *
+ *  @param priv   A pointer to wlan_private structure
+ *
+ *  @return       void
+ */
+static void
+wlan_scan_process_results(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int i;
+    int foundCurrent;
+
+    foundCurrent = FALSE;
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        Adapter->CurBssParams.BSSDescriptor.pBeaconBuf = NULL;
+        Adapter->CurBssParams.BSSDescriptor.beaconBufSize = 0;
+        Adapter->CurBssParams.BSSDescriptor.beaconBufSizeMax = 0;
+        i = FindSSIDInList(Adapter,
+                           &Adapter->CurBssParams.BSSDescriptor.Ssid,
+                           Adapter->CurBssParams.BSSDescriptor.MacAddress,
+                           Adapter->InfrastructureMode);
+
+        if (i >= 0) {
+            PRINTM(INFO, "Found current ssid/bssid in list @ index #%d\n", i);
+            /* Make a copy of current BSSID descriptor */
+            memcpy(&Adapter->CurBssParams.BSSDescriptor,
+                   &Adapter->ScanTable[i],
+                   sizeof(Adapter->CurBssParams.BSSDescriptor));
+        }
+    }
+
+    for (i = 0; i < Adapter->NumInScanTable; i++) {
+        PRINTM(INFO, "Scan:(%02d) %02x:%02x:%02x:%02x:%02x:%02x, "
+               "RSSI[%03d], SSID[%s]\n",
+               i,
+               Adapter->ScanTable[i].MacAddress[0],
+               Adapter->ScanTable[i].MacAddress[1],
+               Adapter->ScanTable[i].MacAddress[2],
+               Adapter->ScanTable[i].MacAddress[3],
+               Adapter->ScanTable[i].MacAddress[4],
+               Adapter->ScanTable[i].MacAddress[5],
+               (s32) Adapter->ScanTable[i].Rssi,
+               Adapter->ScanTable[i].Ssid.Ssid);
+
+    }
+}
+
+/**
+ *  @brief Create a channel list for the driver to scan based on region info
+ *
+ *  Use the driver region/band information to construct a comprehensive list
+ *    of channels to scan.  This routine is used for any scan that is not
+ *    provided a specific channel list to scan.
+ *
+ *  @param priv          A pointer to wlan_private structure
+ *  @param scanChanList  Output parameter: Resulting channel list to scan
+ *  @param filteredScan  Flag indicating whether or not a BSSID or SSID filter
+ *                       is being sent in the command to firmware.  Used to 
+ *                       increase the number of channels sent in a scan
+ *                       command and to disable the firmware channel scan
+ *                       filter.
+ *
+ *  @return              void
+ */
+static void
+wlan_scan_create_channel_list(wlan_private * priv,
+                              ChanScanParamSet_t * scanChanList,
+                              BOOLEAN filteredScan)
+{
+
+    wlan_adapter *Adapter = priv->adapter;
+    REGION_CHANNEL *scanRegion;
+    CHANNEL_FREQ_POWER *cfp;
+    int rgnIdx;
+    int chanIdx;
+    int nextChan;
+    u8 scanType;
+
+    chanIdx = 0;
+
+    /* Set the default scan type to the user specified type, will later
+     *   be changed to passive on a per channel basis if restricted by
+     *   regulatory requirements (11d or 11h)
+     */
+    scanType = Adapter->ScanType;
+
+    for (rgnIdx = 0; rgnIdx < NELEMENTS(Adapter->region_channel); rgnIdx++) {
+        if (wlan_get_state_11d(priv) == ENABLE_11D &&
+            Adapter->MediaConnectStatus != WlanMediaStateConnected) {
+            /* Scan all the supported chan for the first scan */
+            if (!Adapter->universal_channel[rgnIdx].Valid)
+                continue;
+            scanRegion = &Adapter->universal_channel[rgnIdx];
+
+            /* clear the parsed_region_chan for the first scan */
+            memset(&Adapter->parsed_region_chan, 0x00,
+                   sizeof(Adapter->parsed_region_chan));
+        } else {
+            if (!Adapter->region_channel[rgnIdx].Valid)
+                continue;
+            scanRegion = &Adapter->region_channel[rgnIdx];
+        }
+
+        for (nextChan = 0;
+             nextChan < scanRegion->NrCFP; nextChan++, chanIdx++) {
+
+            cfp = scanRegion->CFP + nextChan;
+
+            if (wlan_get_state_11d(priv) == ENABLE_11D) {
+                scanType =
+                    wlan_get_scan_type_11d(cfp->Channel,
+                                           &Adapter->parsed_region_chan);
+            }
+
+            switch (scanRegion->Band) {
+            case BAND_B:
+            case BAND_G:
+            default:
+                scanChanList[chanIdx].RadioType = HostCmd_SCAN_RADIO_TYPE_BG;
+                break;
+            }
+
+            if (scanType == HostCmd_SCAN_TYPE_PASSIVE) {
+                scanChanList[chanIdx].MaxScanTime =
+                    wlan_cpu_to_le16(Adapter->PassiveScanTime);
+                scanChanList[chanIdx].ChanScanMode.PassiveScan = TRUE;
+            } else {
+                scanChanList[chanIdx].MaxScanTime =
+                    wlan_cpu_to_le16(Adapter->ActiveScanTime);
+                scanChanList[chanIdx].ChanScanMode.PassiveScan = FALSE;
+            }
+
+            scanChanList[chanIdx].ChanNumber = cfp->Channel;
+
+            if (filteredScan) {
+                scanChanList[chanIdx].MaxScanTime =
+                    wlan_cpu_to_le16(Adapter->SpecificScanTime);
+                scanChanList[chanIdx].ChanScanMode.DisableChanFilt = TRUE;
+            }
+        }
+    }
+}
+
+static void
+wlan_add_wps_probe_request_ie(wlan_private * priv, u8 ** ppTlvOut)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    MrvlIEtypesHeader_t *tlv;
+
+    if (Adapter->wps.wpsIe.VendHdr.Len) {
+        tlv = (MrvlIEtypesHeader_t *) * ppTlvOut;
+        tlv->Type = wlan_cpu_to_le16(TLV_TYPE_WPS_ENROLLEE_PROBE_REQ_TLV);
+        tlv->Len = wlan_cpu_to_le16(Adapter->wps.wpsIe.VendHdr.Len);
+        *ppTlvOut += sizeof(MrvlIEtypesHeader_t);
+        memcpy(*ppTlvOut,
+               Adapter->wps.wpsIe.VendHdr.Oui,
+               Adapter->wps.wpsIe.VendHdr.Len);
+        *ppTlvOut += (Adapter->wps.wpsIe.VendHdr.Len
+                      + sizeof(MrvlIEtypesHeader_t));
+    }
+}
+
+/**
+ *  @brief Construct a wlan_scan_cmd_config structure to use in issue scan cmds
+ *
+ *  Application layer or other functions can invoke wlan_scan_networks
+ *    with a scan configuration supplied in a wlan_ioctl_user_scan_cfg struct.
+ *    This structure is used as the basis of one or many wlan_scan_cmd_config
+ *    commands that are sent to the command processing module and sent to
+ *    firmware.
+ *
+ *  Create a wlan_scan_cmd_config based on the following user supplied
+ *    parameters (if present):
+ *             - SSID filter
+ *             - BSSID filter
+ *             - Number of Probes to be sent
+ *             - Channel list
+ *
+ *  If the SSID or BSSID filter is not present, disable/clear the filter.
+ *  If the number of probes is not set, use the adapter default setting
+ *  Qualify the channel
+ *
+ *  @param priv             A pointer to wlan_private structure
+ *  @param pUserScanIn      NULL or pointer to scan configuration parameters
+ *  @param pScanCfgOut      Output parameter: Resulting scan configuration
+ *  @param ppChanTlvOut     Output parameter: Pointer to the start of the
+ *                          channel TLV portion of the output scan config
+ *  @param pScanChanList    Output parameter: Pointer to the resulting channel
+ *                          list to scan
+ *  @param pMaxChanPerScan  Output parameter: Number of channels to scan for
+ *                          each issuance of the firmware scan command
+ *  @param pFilteredScan    Output parameter: Flag indicating whether or not
+ *                          a BSSID or SSID filter is being sent in the
+ *                          command to firmware.  Used to increase the number
+ *                          of channels sent in a scan command and to 
+ *                          disable the firmware channel scan filter.
+ *  @param pScanCurrentOnly Output parameter: Flag indicating whether or not
+ *                          we are only scanning our current active channel
+ *
+ *  @return                 void
+ */
+static void
+wlan_scan_setup_scan_config(wlan_private * priv,
+                            const wlan_ioctl_user_scan_cfg * pUserScanIn,
+                            wlan_scan_cmd_config * pScanCfgOut,
+                            MrvlIEtypes_ChanListParamSet_t ** ppChanTlvOut,
+                            ChanScanParamSet_t * pScanChanList,
+                            int *pMaxChanPerScan,
+                            BOOLEAN * pFilteredScan,
+                            BOOLEAN * pScanCurrentOnly)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    const u8 zeroMac[ETH_ALEN] = { 0, 0, 0, 0, 0, 0 };
+    MrvlIEtypes_NumProbes_t *pNumProbesTlv;
+    u8 *pTlvPos;
+    u16 numProbes;
+    u16 ssidLen;
+    int chanIdx;
+    int scanType;
+    int scanDur;
+    int channel;
+    int radioType;
+    int ssidIdx;
+    BOOLEAN ssidFilter;
+
+    MrvlIEtypes_WildCardSsIdParamSet_t *pWildCardSsidTlv;
+
+    /* The tlvBufferLen is calculated for each scan command.  The TLVs added
+     *   in this routine will be preserved since the routine that sends
+     *   the command will append channelTLVs at *ppChanTlvOut.  The difference
+     *   between the *ppChanTlvOut and the tlvBuffer start will be used
+     *   to calculate the size of anything we add in this routine.
+     */
+    pScanCfgOut->tlvBufferLen = 0;
+
+    /* Running tlv pointer.  Assigned to ppChanTlvOut at end of function
+     *  so later routines know where channels can be added to the command buf
+     */
+    pTlvPos = pScanCfgOut->tlvBuffer;
+
+    /*
+     * Set the initial scan paramters for progressive scanning.  If a specific
+     *   BSSID or SSID is used, the number of channels in the scan command
+     *   will be increased to the absolute maximum
+     */
+    *pMaxChanPerScan = MRVDRV_MAX_CHANNELS_PER_SCAN;
+
+    /* Initialize the scan as un-filtered; the flag is later set to
+     *   TRUE below if a SSID or BSSID filter is sent in the command
+     */
+    *pFilteredScan = FALSE;
+
+    /* Initialize the scan as not being only on the current channel.  If
+     *   the channel list is customized, only contains one channel, and
+     *   is the active channel, this is set true and data flow is not halted.
+     */
+    *pScanCurrentOnly = FALSE;
+
+    if (pUserScanIn) {
+
+        /* Default the ssidFilter flag to TRUE, set false under certain 
+         *   wildcard conditions and qualified by the existence of an SSID 
+         *   list before marking the scan as filtered
+         */
+        ssidFilter = TRUE;
+
+        /* Set the bss type scan filter, use Adapter setting if unset */
+        pScanCfgOut->bssType = (pUserScanIn->bssType ? pUserScanIn->bssType :
+                                Adapter->ScanMode);
+
+        /* Set the number of probes to send, use Adapter setting if unset */
+        numProbes = (pUserScanIn->numProbes ? pUserScanIn->numProbes :
+                     Adapter->ScanProbes);
+
+        /*
+         * Set the BSSID filter to the incoming configuration,
+         *   if non-zero.  If not set, it will remain disabled (all zeros).
+         */
+        memcpy(pScanCfgOut->specificBSSID,
+               pUserScanIn->specificBSSID,
+               sizeof(pScanCfgOut->specificBSSID));
+
+        for (ssidIdx = 0; ((ssidIdx < NELEMENTS(pUserScanIn->ssidList))
+                           && (*pUserScanIn->ssidList[ssidIdx].ssid
+                               || pUserScanIn->ssidList[ssidIdx].maxLen));
+             ssidIdx++) {
+
+            ssidLen = strlen(pUserScanIn->ssidList[ssidIdx].ssid) + 1;
+
+            pWildCardSsidTlv = (MrvlIEtypes_WildCardSsIdParamSet_t *) pTlvPos;
+            pWildCardSsidTlv->Header.Type
+                = wlan_cpu_to_le16(TLV_TYPE_WILDCARDSSID);
+            pWildCardSsidTlv->Header.Len
+                = ssidLen + sizeof(pWildCardSsidTlv->MaxSsidLength);
+            pWildCardSsidTlv->MaxSsidLength
+                = pUserScanIn->ssidList[ssidIdx].maxLen;
+
+            memcpy(pWildCardSsidTlv->SsId,
+                   pUserScanIn->ssidList[ssidIdx].ssid, ssidLen);
+
+            pTlvPos += (sizeof(pWildCardSsidTlv->Header)
+                        + pWildCardSsidTlv->Header.Len);
+
+            pWildCardSsidTlv->Header.Len
+                = wlan_cpu_to_le16(pWildCardSsidTlv->Header.Len);
+
+            PRINTM(INFO, "Scan: ssidList[%d]: %s, %d\n",
+                   ssidIdx,
+                   pWildCardSsidTlv->SsId, pWildCardSsidTlv->MaxSsidLength);
+
+            /* Empty wildcard ssid with a maxlen will match many or potentially
+             *   all SSIDs (maxlen == 32), therefore do not treat the scan
+             *   as filtered.
+             */
+            if ((ssidLen == 0) && pWildCardSsidTlv->MaxSsidLength) {
+                ssidFilter = FALSE;
+            }
+        }
+
+        /*
+         *  The default number of channels sent in the command is low to
+         *    ensure the response buffer from the firmware does not truncate
+         *    scan results.  That is not an issue with an SSID or BSSID
+         *    filter applied to the scan results in the firmware.
+         */
+        if ((ssidIdx && ssidFilter)
+            || memcmp(pScanCfgOut->specificBSSID, &zeroMac, sizeof(zeroMac))) {
+            *pFilteredScan = TRUE;
+        }
+
+    } else {
+        pScanCfgOut->bssType = Adapter->ScanMode;
+        numProbes = Adapter->ScanProbes;
+    }
+
+    /* If the input config or adapter has the number of Probes set, add tlv */
+    if (numProbes) {
+
+        PRINTM(INFO, "Scan: numProbes = %d\n", numProbes);
+
+        pNumProbesTlv = (MrvlIEtypes_NumProbes_t *) pTlvPos;
+        pNumProbesTlv->Header.Type = wlan_cpu_to_le16(TLV_TYPE_NUMPROBES);
+        pNumProbesTlv->Header.Len = sizeof(pNumProbesTlv->NumProbes);
+        pNumProbesTlv->NumProbes = wlan_cpu_to_le16(numProbes);
+
+        pTlvPos += sizeof(pNumProbesTlv->Header) + pNumProbesTlv->Header.Len;
+
+        pNumProbesTlv->Header.Len =
+            wlan_cpu_to_le16(pNumProbesTlv->Header.Len);
+    }
+
+    wlan_add_wps_probe_request_ie(priv, &pTlvPos);
+
+    /*
+     * Set the output for the channel TLV to the address in the tlv buffer
+     *   past any TLVs that were added in this fuction (SSID, numProbes).
+     *   Channel TLVs will be added past this for each scan command, preserving
+     *   the TLVs that were previously added.
+     */
+    *ppChanTlvOut = (MrvlIEtypes_ChanListParamSet_t *) pTlvPos;
+
+    if (pUserScanIn && pUserScanIn->chanList[0].chanNumber) {
+
+        PRINTM(INFO, "Scan: Using supplied channel list\n");
+
+        for (chanIdx = 0;
+             chanIdx < WLAN_IOCTL_USER_SCAN_CHAN_MAX
+             && pUserScanIn->chanList[chanIdx].chanNumber; chanIdx++) {
+
+            channel = pUserScanIn->chanList[chanIdx].chanNumber;
+            (pScanChanList + chanIdx)->ChanNumber = channel;
+
+            radioType = pUserScanIn->chanList[chanIdx].radioType;
+            (pScanChanList + chanIdx)->RadioType = radioType;
+
+            scanType = pUserScanIn->chanList[chanIdx].scanType;
+
+            if (scanType == HostCmd_SCAN_TYPE_PASSIVE) {
+                (pScanChanList + chanIdx)->ChanScanMode.PassiveScan = TRUE;
+            } else {
+                (pScanChanList + chanIdx)->ChanScanMode.PassiveScan = FALSE;
+            }
+
+            if (pUserScanIn->chanList[chanIdx].scanTime) {
+                scanDur = pUserScanIn->chanList[chanIdx].scanTime;
+            } else {
+                if (scanType == HostCmd_SCAN_TYPE_PASSIVE) {
+                    scanDur = Adapter->PassiveScanTime;
+                } else if (*pFilteredScan) {
+                    scanDur = Adapter->SpecificScanTime;
+                } else {
+                    scanDur = Adapter->ActiveScanTime;
+                }
+            }
+
+            (pScanChanList + chanIdx)->MinScanTime =
+                wlan_cpu_to_le16(scanDur);
+            (pScanChanList + chanIdx)->MaxScanTime =
+                wlan_cpu_to_le16(scanDur);
+        }
+
+        /* Check if we are only scanning the current channel */
+        if ((chanIdx == 1)
+            && (pUserScanIn->chanList[0].chanNumber
+                == priv->adapter->CurBssParams.BSSDescriptor.Channel)) {
+            *pScanCurrentOnly = TRUE;
+            PRINTM(INFO, "Scan: Scanning current channel only");
+        }
+
+    } else {
+        PRINTM(INFO, "Scan: Creating full region channel list\n");
+        wlan_scan_create_channel_list(priv, pScanChanList, *pFilteredScan);
+    }
+}
+
+/**
+ *  @brief Construct and send multiple scan config commands to the firmware
+ *
+ *  Previous routines have created a wlan_scan_cmd_config with any requested
+ *   TLVs.  This function splits the channel TLV into maxChanPerScan lists
+ *   and sends the portion of the channel TLV along with the other TLVs
+ *   to the wlan_cmd routines for execution in the firmware.
+ *
+ *  @param priv            A pointer to wlan_private structure
+ *  @param maxChanPerScan  Maximum number channels to be included in each
+ *                         scan command sent to firmware
+ *  @param filteredScan    Flag indicating whether or not a BSSID or SSID
+ *                         filter is being used for the firmware command
+ *                         scan command sent to firmware
+ *  @param pScanCfgOut     Scan configuration used for this scan.
+ *  @param pChanTlvOut     Pointer in the pScanCfgOut where the channel TLV
+ *                         should start.  This is past any other TLVs that
+ *                         must be sent down in each firmware command.
+ *  @param pScanChanList   List of channels to scan in maxChanPerScan segments
+ *
+ *  @return                WLAN_STATUS_SUCCESS or error return otherwise
+ */
+static int
+wlan_scan_channel_list(wlan_private * priv,
+                       int maxChanPerScan,
+                       BOOLEAN filteredScan,
+                       wlan_scan_cmd_config * pScanCfgOut,
+                       MrvlIEtypes_ChanListParamSet_t * pChanTlvOut,
+                       ChanScanParamSet_t * pScanChanList)
+{
+    ChanScanParamSet_t *pTmpChan;
+    ChanScanParamSet_t *pStartChan;
+    u8 scanBand;
+    int doneEarly;
+    int tlvIdx;
+    int totalscantime;
+    int ret;
+
+    ENTER();
+
+    if (pScanCfgOut == 0 || pChanTlvOut == 0 || pScanChanList == 0) {
+        PRINTM(INFO, "Scan: Null detect: %p, %p, %p\n",
+               pScanCfgOut, pChanTlvOut, pScanChanList);
+        return WLAN_STATUS_FAILURE;
+    }
+
+    ret = WLAN_STATUS_SUCCESS;
+
+    pChanTlvOut->Header.Type = wlan_cpu_to_le16(TLV_TYPE_CHANLIST);
+
+    /* Set the temp channel struct pointer to the start of the desired list */
+    pTmpChan = pScanChanList;
+
+    /* Loop through the desired channel list, sending a new firmware scan
+     *   commands for each maxChanPerScan channels (or for 1,6,11 individually
+     *   if configured accordingly)
+     */
+    while (pTmpChan->ChanNumber) {
+
+        tlvIdx = 0;
+        totalscantime = 0;
+        pChanTlvOut->Header.Len = 0;
+        scanBand = pTmpChan->RadioType;
+        pStartChan = pTmpChan;
+        doneEarly = FALSE;
+
+        /* Construct the Channel TLV for the scan command.  Continue to
+         *  insert channel TLVs until:
+         *    - the tlvIdx hits the maximum configured per scan command
+         *    - the next channel to insert is 0 (end of desired channel list)
+         *    - doneEarly is set (controlling individual scanning of 1,6,11)
+         */
+        while (tlvIdx < maxChanPerScan && pTmpChan->ChanNumber && !doneEarly) {
+
+            PRINTM(INFO, "Scan: Chan(%3d), Radio(%d), Mode(%d,%d), Dur(%d)\n",
+                   pTmpChan->ChanNumber,
+                   pTmpChan->RadioType,
+                   pTmpChan->ChanScanMode.PassiveScan,
+                   pTmpChan->ChanScanMode.DisableChanFilt,
+                   pTmpChan->MaxScanTime);
+
+            /* Copy the current channel TLV to the command being prepared */
+            memcpy(pChanTlvOut->ChanScanParam + tlvIdx,
+                   pTmpChan, sizeof(pChanTlvOut->ChanScanParam));
+
+            /* Increment the TLV header length by the size appended */
+            pChanTlvOut->Header.Len += sizeof(pChanTlvOut->ChanScanParam);
+
+            /*
+             *  The tlv buffer length is set to the number of bytes of the
+             *    between the channel tlv pointer and the start of the
+             *    tlv buffer.  This compensates for any TLVs that were appended
+             *    before the channel list.
+             */
+            pScanCfgOut->tlvBufferLen = ((u8 *) pChanTlvOut
+                                         - pScanCfgOut->tlvBuffer);
+
+            /*  Add the size of the channel tlv header and the data length */
+            pScanCfgOut->tlvBufferLen += (sizeof(pChanTlvOut->Header)
+                                          + pChanTlvOut->Header.Len);
+
+            /* Increment the index to the channel tlv we are constructing */
+            tlvIdx++;
+
+            /* Count the total scan time per command */
+            totalscantime += pTmpChan->MaxScanTime;
+
+            doneEarly = FALSE;
+
+            /* Stop the loop if the *current* channel is in the 1,6,11 set
+             *   and we are not filtering on a BSSID or SSID.
+             */
+            if (!filteredScan && (pTmpChan->ChanNumber == 1
+                                  || pTmpChan->ChanNumber == 6
+                                  || pTmpChan->ChanNumber == 11)) {
+                doneEarly = TRUE;
+            }
+
+            /* Increment the tmp pointer to the next channel to be scanned */
+            pTmpChan++;
+
+            /* Stop the loop if the *next* channel is in the 1,6,11 set.
+             *  This will cause it to be the only channel scanned on the next
+             *  interation
+             */
+            if (!filteredScan && (pTmpChan->ChanNumber == 1
+                                  || pTmpChan->ChanNumber == 6
+                                  || pTmpChan->ChanNumber == 11)) {
+                doneEarly = TRUE;
+            }
+        }
+
+        /* The total scan time should be less than scan command timeout value */
+        if (totalscantime > MRVDRV_MAX_TOTAL_SCAN_TIME) {
+            PRINTM(MSG,
+                   "Total scan time %d ms is over limit (%d ms), scan skipped\n",
+                   totalscantime, MRVDRV_MAX_TOTAL_SCAN_TIME);
+            ret = WLAN_STATUS_FAILURE;
+            break;
+        }
+
+        pChanTlvOut->Header.Len = wlan_cpu_to_le16(pChanTlvOut->Header.Len);
+
+        /* Send the scan command to the firmware with the specified cfg */
+        ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_SCAN, 0,
+                                    HostCmd_OPTION_WAITFORRSP, 0,
+                                    pScanCfgOut);
+    }
+
+    LEAVE();
+
+    if (ret) {
+        return WLAN_STATUS_FAILURE;
+    }
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Internal function used to start a scan based on an input config
+ *
+ *  Use the input user scan configuration information when provided in
+ *    order to send the appropriate scan commands to firmware to populate or
+ *    update the internal driver scan table
+ *
+ *  @param priv          A pointer to wlan_private structure
+ *  @param pUserScanIn   Pointer to the input configuration for the requested
+ *                       scan.
+ *
+ *  @return              WLAN_STATUS_SUCCESS or < 0 if error
+ */
+static int
+wlan_scan_networks(wlan_private * priv,
+                   const wlan_ioctl_user_scan_cfg * pUserScanIn)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    MrvlIEtypes_ChanListParamSet_t *pChanTlvOut;
+
+    ChanScanParamSet_t scanChanList[WLAN_IOCTL_USER_SCAN_CHAN_MAX];
+    wlan_scan_cmd_config_tlv scanCfgOut;
+    BOOLEAN keepPreviousScan;
+    BOOLEAN filteredScan;
+    BOOLEAN scanCurrentChanOnly;
+    int maxChanPerScan;
+    int ret;
+    BOOLEAN bBgScan;
+
+    ENTER();
+
+    memset(scanChanList, 0x00, sizeof(scanChanList));
+    memset(&scanCfgOut, 0x00, sizeof(scanCfgOut));
+
+    keepPreviousScan = FALSE;
+
+    wlan_scan_setup_scan_config(priv,
+                                pUserScanIn,
+                                &scanCfgOut.config,
+                                &pChanTlvOut,
+                                scanChanList,
+                                &maxChanPerScan,
+                                &filteredScan, &scanCurrentChanOnly);
+
+    if (pUserScanIn) {
+        keepPreviousScan = pUserScanIn->keepPreviousScan;
+    }
+
+    if (keepPreviousScan == FALSE) {
+        memset(Adapter->ScanTable, 0x00,
+               sizeof(BSSDescriptor_t) * MRVDRV_MAX_BSSID_LIST);
+        Adapter->NumInScanTable = 0;
+        Adapter->pBeaconBufEnd = Adapter->beaconBuffer;
+    }
+
+    /* Keep the data path active if we are only scanning our current channel */
+    if (!scanCurrentChanOnly) {
+        PRINTM(INFO, "Scan: WMM Queue stop\n");
+        priv->wlan_dev.netdev->watchdog_timeo = MRVDRV_SCAN_WATCHDOG_TIMEOUT;
+        /* If WMM queues are in use, only stop the internal data queues */
+        wmm_stop_queue(priv);
+    }
+
+    bBgScan = priv->adapter->bgScanConfig->Enable;
+    if (priv->adapter->bgScanConfig->Enable == TRUE) {
+        wlan_bg_scan_enable(priv, FALSE);
+    }
+
+    ret = wlan_scan_channel_list(priv,
+                                 maxChanPerScan,
+                                 filteredScan,
+                                 &scanCfgOut.config,
+                                 pChanTlvOut, scanChanList);
+
+    /*  Process the resulting scan table:
+     *    - Remove any bad ssids
+     *    - Update our current BSS information from scan data
+     */
+    wlan_scan_process_results(priv);
+
+    if (bBgScan == TRUE) {
+        wlan_bg_scan_enable(priv, TRUE);
+    }
+
+    PRINTM(INFO, "Scan: WMM Queue start\n");
+
+    priv->wlan_dev.netdev->watchdog_timeo = MRVDRV_DEFAULT_WATCHDOG_TIMEOUT;
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        wmm_start_queue(priv);
+    }
+    os_carrier_on(priv);
+    os_start_queue(priv);
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Create a brief scan resp to relay basic BSS info to the app layer
+ *
+ *  When the beacon/probe response has not been buffered, use the saved BSS
+ *    information available to provide a minimum response for the application
+ *    ioctl retrieval routines.  Include:
+ *        - Timestamp
+ *        - Beacon Period
+ *        - Capabilities (including WMM Element if available)
+ *        - SSID
+ *
+ *  @param ppBuffer  Output parameter: Buffer used to create basic scan rsp
+ *  @param pBSSDesc  Pointer to a BSS entry in the scan table to create
+ *                   scan response from for delivery to the application layer
+ *
+ *  @return          void
+ */
+static void
+wlan_scan_create_brief_table_entry(u8 ** ppBuffer, BSSDescriptor_t * pBSSDesc)
+{
+    u8 *pTmpBuf = *ppBuffer;
+    u8 tmpSSIDHdr[2];
+    u8 ieLen;
+
+    if (copy_to_user(pTmpBuf, pBSSDesc->TimeStamp,
+                     sizeof(pBSSDesc->TimeStamp))) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return;
+    }
+    pTmpBuf += sizeof(pBSSDesc->TimeStamp);
+
+    if (copy_to_user(pTmpBuf, &pBSSDesc->BeaconPeriod,
+                     sizeof(pBSSDesc->BeaconPeriod))) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return;
+    }
+    pTmpBuf += sizeof(pBSSDesc->BeaconPeriod);
+
+    if (copy_to_user(pTmpBuf, &pBSSDesc->Cap, sizeof(pBSSDesc->Cap))) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return;
+    }
+    pTmpBuf += sizeof(pBSSDesc->Cap);
+
+    tmpSSIDHdr[0] = 0;          /* Element ID for SSID is zero */
+    tmpSSIDHdr[1] = pBSSDesc->Ssid.SsidLength;
+    if (copy_to_user(pTmpBuf, tmpSSIDHdr, sizeof(tmpSSIDHdr))) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return;
+    }
+    pTmpBuf += sizeof(tmpSSIDHdr);
+
+    if (copy_to_user(pTmpBuf, pBSSDesc->Ssid.Ssid, pBSSDesc->Ssid.SsidLength)) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return;
+    }
+    pTmpBuf += pBSSDesc->Ssid.SsidLength;
+
+    if (pBSSDesc->wmmIE.VendHdr.ElementId == WMM_IE) {
+        ieLen = sizeof(IEEEtypes_Header_t) + pBSSDesc->wmmIE.VendHdr.Len;
+        if (copy_to_user(pTmpBuf, &pBSSDesc->wmmIE, ieLen)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return;
+        }
+
+        pTmpBuf += ieLen;
+    }
+
+    if (pBSSDesc->wpaIE.VendHdr.ElementId == WPA_IE) {
+        ieLen = sizeof(IEEEtypes_Header_t) + pBSSDesc->wpaIE.VendHdr.Len;
+        if (copy_to_user(pTmpBuf, &pBSSDesc->wpaIE, ieLen)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return;
+        }
+
+        pTmpBuf += ieLen;
+    }
+
+    if (pBSSDesc->rsnIE.IeeeHdr.ElementId == RSN_IE) {
+        ieLen = sizeof(IEEEtypes_Header_t) + pBSSDesc->rsnIE.IeeeHdr.Len;
+        if (copy_to_user(pTmpBuf, &pBSSDesc->rsnIE, ieLen)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return;
+        }
+
+        pTmpBuf += ieLen;
+    }
+
+    *ppBuffer = pTmpBuf;
+}
+
+/**
+ *  @brief Inspect the scan response buffer for pointers to expected TLVs
+ *
+ *  TLVs can be included at the end of the scan response BSS information.
+ *    Parse the data in the buffer for pointers to TLVs that can potentially
+ *    be passed back in the response
+ *
+ *  @param pTlv        Pointer to the start of the TLV buffer to parse
+ *  @param tlvBufSize  Size of the TLV buffer
+ *  @param ppTsfTlv    Output parameter: Pointer to the TSF TLV if found
+ *
+ *  @return            void
+ */
+static void
+wlan_ret_802_11_scan_get_tlv_ptrs(MrvlIEtypes_Data_t * pTlv,
+                                  int tlvBufSize,
+                                  MrvlIEtypes_TsfTimestamp_t ** ppTsfTlv)
+{
+    MrvlIEtypes_Data_t *pCurrentTlv;
+    int tlvBufLeft;
+    u16 tlvType;
+    u16 tlvLen;
+
+    pCurrentTlv = pTlv;
+    tlvBufLeft = tlvBufSize;
+    *ppTsfTlv = NULL;
+
+    PRINTM(INFO, "SCAN_RESP: tlvBufSize = %d\n", tlvBufSize);
+    HEXDUMP("SCAN_RESP: TLV Buf", (u8 *) pTlv, tlvBufSize);
+
+    while (tlvBufLeft >= sizeof(MrvlIEtypesHeader_t)) {
+        tlvType = wlan_le16_to_cpu(pCurrentTlv->Header.Type);
+        tlvLen = wlan_le16_to_cpu(pCurrentTlv->Header.Len);
+
+        switch (tlvType) {
+        case TLV_TYPE_TSFTIMESTAMP:
+            PRINTM(INFO, "SCAN_RESP: TSF Timestamp TLV, len = %d\n", tlvLen);
+            *ppTsfTlv = (MrvlIEtypes_TsfTimestamp_t *) pCurrentTlv;
+            break;
+
+        default:
+            PRINTM(INFO, "SCAN_RESP: Unhandled TLV = %d\n", tlvType);
+            /* Give up, this seems corrupted */
+            return;
+        }                       /* switch */
+
+        tlvBufLeft -= (sizeof(pTlv->Header) + tlvLen);
+        pCurrentTlv = (MrvlIEtypes_Data_t *) (pCurrentTlv->Data + tlvLen);
+    }                           /* while */
+}
+
+/**
+ *  @brief Interpret a BSS scan response returned from the firmware
+ *
+ *  Parse the various fixed fields and IEs passed back for a a BSS probe
+ *   response or beacon from the scan command.  Record information as needed
+ *   in the scan table BSSDescriptor_t for that entry.
+ *
+ *  @param pBSSIDEntry  Output parameter: Pointer to the BSS Entry
+ *
+ *  @return             WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+InterpretBSSDescriptionWithIE(BSSDescriptor_t * pBSSEntry,
+                              u8 ** pBeaconInfo, int *bytesLeft)
+{
+    IEEEtypes_ElementId_e elemID;
+    IEEEtypes_FhParamSet_t *pFH;
+    IEEEtypes_DsParamSet_t *pDS;
+    IEEEtypes_CfParamSet_t *pCF;
+    IEEEtypes_IbssParamSet_t *pIbss;
+    IEEEtypes_CapInfo_t *pCap;
+    WLAN_802_11_FIXED_IEs fixedIE;
+    u8 *pCurrentPtr;
+    u8 *pRate;
+    u8 elemLen;
+    u16 totalIeLen;
+    u8 bytesToCopy;
+    u8 rateSize;
+    u16 beaconSize;
+    BOOLEAN foundDataRateIE;
+    int bytesLeftForCurrentBeacon;
+    IEEEtypes_ERPInfo_t *pERPInfo;
+
+    IEEEtypes_VendorSpecific_t *pVendorIe;
+    const u8 wpa_oui[4] = { 0x00, 0x50, 0xf2, 0x01 };
+    const u8 wmm_oui[4] = { 0x00, 0x50, 0xf2, 0x02 };
+    const u8 wps_oui[4] = { 0x00, 0x50, 0xf2, 0x04 };
+
+    IEEEtypes_CountryInfoSet_t *pcountryinfo;
+
+    ENTER();
+
+    foundDataRateIE = FALSE;
+    rateSize = 0;
+    beaconSize = 0;
+
+    if (*bytesLeft >= sizeof(beaconSize)) {
+        /* Extract & convert beacon size from the command buffer */
+        memcpy(&beaconSize, *pBeaconInfo, sizeof(beaconSize));
+        beaconSize = wlan_le16_to_cpu(beaconSize);
+        *bytesLeft -= sizeof(beaconSize);
+        *pBeaconInfo += sizeof(beaconSize);
+    }
+
+    if (beaconSize == 0 || beaconSize > *bytesLeft) {
+
+        *pBeaconInfo += *bytesLeft;
+        *bytesLeft = 0;
+
+        return WLAN_STATUS_FAILURE;
+    }
+
+    /* Initialize the current working beacon pointer for this BSS iteration */
+    pCurrentPtr = *pBeaconInfo;
+
+    /* Advance the return beacon pointer past the current beacon */
+    *pBeaconInfo += beaconSize;
+    *bytesLeft -= beaconSize;
+
+    bytesLeftForCurrentBeacon = beaconSize;
+
+    memcpy(pBSSEntry->MacAddress, pCurrentPtr, MRVDRV_ETH_ADDR_LEN);
+    PRINTM(INFO, "InterpretIE: AP MAC Addr-%02x:%02x:%02x:%02x:%02x:%02x\n",
+           pBSSEntry->MacAddress[0], pBSSEntry->MacAddress[1],
+           pBSSEntry->MacAddress[2], pBSSEntry->MacAddress[3],
+           pBSSEntry->MacAddress[4], pBSSEntry->MacAddress[5]);
+
+    pCurrentPtr += MRVDRV_ETH_ADDR_LEN;
+    bytesLeftForCurrentBeacon -= MRVDRV_ETH_ADDR_LEN;
+
+    if (bytesLeftForCurrentBeacon < 12) {
+        PRINTM(INFO, "InterpretIE: Not enough bytes left\n");
+        return WLAN_STATUS_FAILURE;
+    }
+
+    /*
+     * next 4 fields are RSSI, time stamp, beacon interval,
+     *   and capability information
+     */
+
+    /* RSSI is 1 byte long */
+    pBSSEntry->Rssi = wlan_le32_to_cpu((LONG) (*pCurrentPtr));
+    PRINTM(INFO, "InterpretIE: RSSI=%02X\n", *pCurrentPtr);
+    pCurrentPtr += 1;
+    bytesLeftForCurrentBeacon -= 1;
+
+    /*
+     *  The RSSI is not part of the beacon/probe response.  After we have
+     *    advanced pCurrentPtr past the RSSI field, save the remaining
+     *    data for use at the application layer
+     */
+    pBSSEntry->pBeaconBuf = pCurrentPtr;
+    pBSSEntry->beaconBufSize = bytesLeftForCurrentBeacon;
+
+    /* time stamp is 8 bytes long */
+    memcpy(fixedIE.Timestamp, pCurrentPtr, 8);
+    memcpy(pBSSEntry->TimeStamp, pCurrentPtr, 8);
+    pCurrentPtr += 8;
+    bytesLeftForCurrentBeacon -= 8;
+
+    /* beacon interval is 2 bytes long */
+    memcpy(&fixedIE.BeaconInterval, pCurrentPtr, 2);
+    pBSSEntry->BeaconPeriod = wlan_le16_to_cpu(fixedIE.BeaconInterval);
+    pCurrentPtr += 2;
+    bytesLeftForCurrentBeacon -= 2;
+
+    /* capability information is 2 bytes long */
+    memcpy(&fixedIE.Capabilities, pCurrentPtr, 2);
+    PRINTM(INFO, "InterpretIE: fixedIE.Capabilities=0x%X\n",
+           fixedIE.Capabilities);
+    fixedIE.Capabilities = wlan_le16_to_cpu(fixedIE.Capabilities);
+    pCap = (IEEEtypes_CapInfo_t *) & fixedIE.Capabilities;
+    memcpy(&pBSSEntry->Cap, pCap, sizeof(IEEEtypes_CapInfo_t));
+    pCurrentPtr += 2;
+    bytesLeftForCurrentBeacon -= 2;
+
+    /* rest of the current buffer are IE's */
+    PRINTM(INFO, "InterpretIE: IELength for this AP = %d\n",
+           bytesLeftForCurrentBeacon);
+
+    HEXDUMP("InterpretIE: IE info", (u8 *) pCurrentPtr,
+            bytesLeftForCurrentBeacon);
+
+    if (pCap->Privacy) {
+        PRINTM(INFO, "InterpretIE: AP WEP enabled\n");
+        pBSSEntry->Privacy = Wlan802_11PrivFilter8021xWEP;
+    } else {
+        pBSSEntry->Privacy = Wlan802_11PrivFilterAcceptAll;
+    }
+
+    if (pCap->Ibss == 1) {
+        pBSSEntry->InfrastructureMode = Wlan802_11IBSS;
+    } else {
+        pBSSEntry->InfrastructureMode = Wlan802_11Infrastructure;
+    }
+
+    /* process variable IE */
+    while (bytesLeftForCurrentBeacon >= 2) {
+        elemID = (IEEEtypes_ElementId_e) (*((u8 *) pCurrentPtr));
+        elemLen = *((u8 *) pCurrentPtr + 1);
+        totalIeLen = elemLen + sizeof(IEEEtypes_Header_t);
+
+        if (bytesLeftForCurrentBeacon < elemLen) {
+            PRINTM(INFO, "InterpretIE: Error in processing IE, "
+                   "bytes left < IE length\n");
+            bytesLeftForCurrentBeacon = 0;
+            continue;
+        }
+
+        switch (elemID) {
+
+        case SSID:
+            pBSSEntry->Ssid.SsidLength = elemLen;
+            memcpy(pBSSEntry->Ssid.Ssid, (pCurrentPtr + 2), elemLen);
+            PRINTM(INFO, "InterpretIE: Ssid: %-32s\n", pBSSEntry->Ssid.Ssid);
+            break;
+
+        case SUPPORTED_RATES:
+            memcpy(pBSSEntry->DataRates, pCurrentPtr + 2, elemLen);
+            memcpy(pBSSEntry->SupportedRates, pCurrentPtr + 2, elemLen);
+            HEXDUMP("InterpretIE: SupportedRates:",
+                    pBSSEntry->SupportedRates, elemLen);
+            rateSize = elemLen;
+            foundDataRateIE = TRUE;
+            break;
+
+        case EXTRA_IE:
+            PRINTM(INFO, "InterpretIE: EXTRA_IE Found!\n");
+            pBSSEntry->extra_ie = 1;
+            break;
+
+        case FH_PARAM_SET:
+            pFH = (IEEEtypes_FhParamSet_t *) pCurrentPtr;
+            pBSSEntry->NetworkTypeInUse = Wlan802_11FH;
+            memcpy(&pBSSEntry->PhyParamSet.FhParamSet, pFH,
+                   sizeof(IEEEtypes_FhParamSet_t));
+            pBSSEntry->PhyParamSet.FhParamSet.DwellTime
+                =
+                wlan_le16_to_cpu(pBSSEntry->PhyParamSet.FhParamSet.DwellTime);
+            break;
+
+        case DS_PARAM_SET:
+            pDS = (IEEEtypes_DsParamSet_t *) pCurrentPtr;
+
+            pBSSEntry->NetworkTypeInUse = Wlan802_11DS;
+            pBSSEntry->Channel = pDS->CurrentChan;
+
+            memcpy(&pBSSEntry->PhyParamSet.DsParamSet, pDS,
+                   sizeof(IEEEtypes_DsParamSet_t));
+            break;
+
+        case CF_PARAM_SET:
+            pCF = (IEEEtypes_CfParamSet_t *) pCurrentPtr;
+            memcpy(&pBSSEntry->SsParamSet.CfParamSet, pCF,
+                   sizeof(IEEEtypes_CfParamSet_t));
+            break;
+
+        case IBSS_PARAM_SET:
+            pIbss = (IEEEtypes_IbssParamSet_t *) pCurrentPtr;
+            pBSSEntry->ATIMWindow = wlan_le32_to_cpu(pIbss->AtimWindow);
+            memcpy(&pBSSEntry->SsParamSet.IbssParamSet, pIbss,
+                   sizeof(IEEEtypes_IbssParamSet_t));
+            break;
+
+            /* Handle Country Info IE */
+        case COUNTRY_INFO:
+            pcountryinfo = (IEEEtypes_CountryInfoSet_t *) pCurrentPtr;
+
+            if (pcountryinfo->Len < sizeof(pcountryinfo->CountryCode) ||
+                pcountryinfo->Len + 2 >
+                sizeof(IEEEtypes_CountryInfoFullSet_t)) {
+                PRINTM(INFO,
+                       "InterpretIE: 11D- Err "
+                       "CountryInfo len =%d min=%d max=%d\n",
+                       pcountryinfo->Len, sizeof(pcountryinfo->CountryCode),
+                       sizeof(IEEEtypes_CountryInfoFullSet_t));
+                LEAVE();
+                return WLAN_STATUS_FAILURE;
+            }
+
+            memcpy(&pBSSEntry->CountryInfo,
+                   pcountryinfo, pcountryinfo->Len + 2);
+            HEXDUMP("InterpretIE: 11D- CountryInfo:",
+                    (u8 *) pcountryinfo, (u32) (pcountryinfo->Len + 2));
+            break;
+        case ERP_INFO:
+            pERPInfo = (IEEEtypes_ERPInfo_t *) pCurrentPtr;
+            pBSSEntry->ERPFlags = pERPInfo->ERPFlags;
+            break;
+        case EXTENDED_SUPPORTED_RATES:
+            /*
+             * only process extended supported rate
+             * if data rate is already found.
+             * data rate IE should come before
+             * extended supported rate IE
+             */
+            if (foundDataRateIE) {
+                if ((elemLen + rateSize) > WLAN_SUPPORTED_RATES) {
+                    bytesToCopy = (WLAN_SUPPORTED_RATES - rateSize);
+                } else {
+                    bytesToCopy = elemLen;
+                }
+
+                pRate = (u8 *) pBSSEntry->DataRates;
+                pRate += rateSize;
+                memcpy(pRate, pCurrentPtr + 2, bytesToCopy);
+
+                pRate = (u8 *) pBSSEntry->SupportedRates;
+                pRate += rateSize;
+                memcpy(pRate, pCurrentPtr + 2, bytesToCopy);
+            }
+            HEXDUMP("InterpretIE: ExtSupportedRates:",
+                    pBSSEntry->SupportedRates, elemLen + rateSize);
+            break;
+
+        case VENDOR_SPECIFIC_221:
+            pVendorIe = (IEEEtypes_VendorSpecific_t *) pCurrentPtr;
+
+            if ((!memcmp
+                 (pVendorIe->VendHdr.Oui, wpa_oui,
+                  sizeof(pVendorIe->VendHdr.Oui)))
+                && (pVendorIe->VendHdr.OuiType == wpa_oui[3])) {
+                pBSSEntry->wpaIE.VendHdr.Len
+                    = (MIN(totalIeLen, sizeof(pBSSEntry->wpaIE))
+                       - sizeof(IEEEtypes_Header_t));
+
+                memcpy(&pBSSEntry->wpaIE,
+                       pCurrentPtr,
+                       (pBSSEntry->wpaIE.VendHdr.Len
+                        + sizeof(IEEEtypes_Header_t)));
+
+                HEXDUMP("InterpretIE: Resp WPA_IE",
+                        (u8 *) & pBSSEntry->wpaIE,
+                        (pBSSEntry->wpaIE.VendHdr.Len
+                         + sizeof(IEEEtypes_Header_t)));
+            } else
+                if ((!memcmp
+                     (pVendorIe->VendHdr.Oui, wmm_oui,
+                      sizeof(pVendorIe->VendHdr.Oui)))
+                    && (pVendorIe->VendHdr.OuiType == wmm_oui[3])) {
+                if (totalIeLen == sizeof(IEEEtypes_WmmParameter_t)
+                    || totalIeLen == sizeof(IEEEtypes_WmmInfo_t)) {
+
+                    /* Only accept and copy the WMM IE if it matches
+                     *  the size expected for the WMM Info IE or the
+                     *  WMM Parameter IE.
+                     */
+                    memcpy((u8 *) & pBSSEntry->wmmIE, pCurrentPtr,
+                           totalIeLen);
+                    HEXDUMP("InterpretIE: Resp WMM_IE",
+                            (u8 *) & pBSSEntry->wmmIE, totalIeLen);
+                }
+            } else
+                if ((!memcmp
+                     (pVendorIe->VendHdr.Oui, wps_oui,
+                      sizeof(pVendorIe->VendHdr.Oui)))
+                    && (pVendorIe->VendHdr.OuiType == wps_oui[3])) {
+                memcpy((u8 *) & pBSSEntry->wpsIE, pCurrentPtr, totalIeLen);
+                HEXDUMP("InterpretIE: Resp WPS_IE",
+                        (u8 *) & pBSSEntry->wpsIE, totalIeLen);
+            }
+            break;
+        case RSN_IE:
+            pBSSEntry->rsnIE.IeeeHdr.Len
+                = (MIN(totalIeLen, sizeof(pBSSEntry->rsnIE))
+                   - sizeof(IEEEtypes_Header_t));
+
+            memcpy(&pBSSEntry->rsnIE,
+                   pCurrentPtr,
+                   pBSSEntry->rsnIE.IeeeHdr.Len + sizeof(IEEEtypes_Header_t));
+
+            HEXDUMP("InterpretIE: Resp RSN_IE",
+                    (u8 *) & pBSSEntry->rsnIE,
+                    pBSSEntry->rsnIE.IeeeHdr.Len +
+                    sizeof(IEEEtypes_Header_t));
+            break;
+        }
+
+        pCurrentPtr += elemLen + 2;
+
+        /* need to account for IE ID and IE Len */
+        bytesLeftForCurrentBeacon -= (elemLen + 2);
+
+    }                           /* while (bytesLeftForCurrentBeacon > 2) */
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Compare two SSIDs
+ *
+ *  @param ssid1    A pointer to ssid to compare
+ *  @param ssid2    A pointer to ssid to compare
+ *
+ *  @return         0--ssid is same, otherwise is different
+ */
+int
+SSIDcmp(WLAN_802_11_SSID * ssid1, WLAN_802_11_SSID * ssid2)
+{
+    if (!ssid1 || !ssid2)
+        return -1;
+
+    if (ssid1->SsidLength != ssid2->SsidLength)
+        return -1;
+
+    return memcmp(ssid1->Ssid, ssid2->Ssid, ssid1->SsidLength);
+}
+
+/**
+ *  @brief This function finds a specific compatible BSSID in the scan list
+ *
+ *  @param Adapter  A pointer to wlan_adapter
+ *  @param bssid    BSSID to find in the scan list
+ *  @param mode     Network mode: Infrastructure or IBSS
+ *
+ *  @return         index in BSSID list, or error return code (< 0)
+ */
+int
+FindBSSIDInList(wlan_adapter * Adapter, u8 * bssid, int mode)
+{
+    int ret = -ENETUNREACH;
+    int i;
+
+    if (!bssid)
+        return -EFAULT;
+
+    PRINTM(INFO, "FindBSSID: Num of BSSIDs = %d\n", Adapter->NumInScanTable);
+
+    /* Look through the scan table for a compatible match. The ret return
+     *   variable will be equal to the index in the scan table (greater
+     *   than zero) if the network is compatible.  The loop will continue
+     *   past a matched bssid that is not compatible in case there is an
+     *   AP with multiple SSIDs assigned to the same BSSID
+     */
+    for (i = 0; ret < 0 && i < Adapter->NumInScanTable; i++) {
+        if (!memcmp(Adapter->ScanTable[i].MacAddress, bssid, ETH_ALEN)) {
+            switch (mode) {
+            case Wlan802_11Infrastructure:
+            case Wlan802_11IBSS:
+                ret = IsNetworkCompatible(Adapter, i, mode);
+                break;
+            default:
+                ret = i;
+                break;
+            }
+        }
+    }
+
+    if (ret >= 0) {
+        if (find_cfp_by_band_and_channel
+            (Adapter, 0, Adapter->ScanTable[ret].Channel) == NULL) {
+            ret = -ENETUNREACH;
+        }
+    }
+    return ret;
+}
+
+/**
+ *  @brief This function finds ssid in ssid list.
+ *
+ *  @param Adapter      A pointer to wlan_adapter
+ *  @param ssid         SSID to find in the list
+ *  @param bssid        BSSID to qualify the SSID selection (if provided)
+ *  @param mode         Network mode: Infrastructure or IBSS
+ *
+ *  @return         index in BSSID list
+ */
+int
+FindSSIDInList(wlan_adapter * Adapter, WLAN_802_11_SSID * ssid,
+               u8 * bssid, int mode)
+{
+    int net = -ENETUNREACH;
+    u8 bestrssi = 0;
+    int i, j;
+
+    PRINTM(INFO, "Num of Entries in Table = %d\n", Adapter->NumInScanTable);
+
+    /* Loop through the table until the maximum is reached or until a match
+     *   is found based on the bssid field comparison 
+     */
+    for (i = 0;
+         i < Adapter->NumInScanTable && (bssid == NULL || (bssid && net < 0));
+         i++) {
+
+        if (!SSIDcmp(&Adapter->ScanTable[i].Ssid, ssid) && ((bssid == NULL)
+                                                            ||
+                                                            !memcmp(Adapter->
+                                                                    ScanTable
+                                                                    [i].
+                                                                    MacAddress,
+                                                                    bssid,
+                                                                    ETH_ALEN)))
+        {
+            switch (mode) {
+            case Wlan802_11Infrastructure:
+            case Wlan802_11IBSS:
+                j = IsNetworkCompatible(Adapter, i, mode);
+
+                if (j >= 0) {
+                    if (SCAN_RSSI(Adapter->ScanTable[i].Rssi) > bestrssi) {
+                        bestrssi = SCAN_RSSI(Adapter->ScanTable[i].Rssi);
+                        net = i;
+                    }
+                } else {
+                    if (net == -ENETUNREACH) {
+                        net = j;
+                    }
+                }
+                break;
+            case Wlan802_11AutoUnknown:
+            default:
+                /* Do not check compatibility if the mode requested is 
+                 *   AutoUnknown.  Allows generic find to work without 
+                 *   verifying against the Adapter security settings
+                 */
+                if (SCAN_RSSI(Adapter->ScanTable[i].Rssi) > bestrssi) {
+                    bestrssi = SCAN_RSSI(Adapter->ScanTable[i].Rssi);
+                    net = i;
+                }
+                break;
+            }
+        }
+    }
+    if (net >= 0) {
+        if (find_cfp_by_band_and_channel
+            (Adapter, 0, Adapter->ScanTable[net].Channel) == NULL) {
+            net = -ENETUNREACH;
+        }
+    }
+    return net;
+}
+
+/**
+ *  @brief This function finds the best SSID in the Scan List
+ *
+ *  Search the scan table for the best SSID that also matches the current
+ *   adapter network preference (infrastructure or adhoc)
+ *
+ *  @param Adapter  A pointer to wlan_adapter
+ *
+ *  @return         index in BSSID list
+ */
+int
+FindBestSSIDInList(wlan_adapter * Adapter)
+{
+    int mode = Adapter->InfrastructureMode;
+    int bestnet = -ENETUNREACH;
+    u8 bestrssi = 0;
+    int i;
+
+    ENTER();
+
+    PRINTM(INFO, "Num of BSSIDs = %d\n", Adapter->NumInScanTable);
+
+    for (i = 0; i < Adapter->NumInScanTable; i++) {
+        switch (mode) {
+        case Wlan802_11Infrastructure:
+        case Wlan802_11IBSS:
+            if (IsNetworkCompatible(Adapter, i, mode) >= 0) {
+                if (SCAN_RSSI(Adapter->ScanTable[i].Rssi) > bestrssi) {
+                    bestrssi = SCAN_RSSI(Adapter->ScanTable[i].Rssi);
+                    bestnet = i;
+                }
+            }
+            break;
+        case Wlan802_11AutoUnknown:
+        default:
+            if (SCAN_RSSI(Adapter->ScanTable[i].Rssi) > bestrssi) {
+                bestrssi = SCAN_RSSI(Adapter->ScanTable[i].Rssi);
+                bestnet = i;
+            }
+            break;
+        }
+    }
+
+    LEAVE();
+    return bestnet;
+}
+
+/**
+ *  @brief Find the AP with specific ssid in the scan list
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param pSSID        A pointer to AP's ssid
+ *
+ *  @return             WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+int
+FindBestNetworkSsid(wlan_private * priv, WLAN_802_11_SSID * pSSID)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    BSSDescriptor_t *pReqBSSID;
+    int i;
+
+    ENTER();
+
+    memset(pSSID, 0, sizeof(WLAN_802_11_SSID));
+
+    wlan_scan_networks(priv, NULL);
+
+    i = FindBestSSIDInList(Adapter);
+
+    if (i >= 0) {
+
+        pReqBSSID = &Adapter->ScanTable[i];
+        memcpy(pSSID, &pReqBSSID->Ssid, sizeof(WLAN_802_11_SSID));
+
+        /* Make sure we are in the right mode */
+        if (Adapter->InfrastructureMode == Wlan802_11AutoUnknown) {
+            Adapter->InfrastructureMode = pReqBSSID->InfrastructureMode;
+
+            ret = PrepareAndSendCommand(priv,
+                                        HostCmd_CMD_802_11_SNMP_MIB,
+                                        HostCmd_ACT_SET,
+                                        HostCmd_OPTION_WAITFORRSP,
+                                        OID_802_11_INFRASTRUCTURE_MODE, NULL);
+
+            if (ret) {
+                LEAVE();
+                return ret;
+            }
+        }
+    }
+
+    if (!pSSID->SsidLength) {
+        ret = WLAN_STATUS_FAILURE;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Delete a specific indexed entry from the scan table.
+ *
+ *  Delete the scan table entry indexed by tableIdx.  Compact the remaining
+ *    entries and adjust any buffering of beacon/probe response data
+ *    if needed.
+ *
+ *  @param priv       A pointer to wlan_private structure
+ *  @param tableIdx   Scan table entry index to delete from the table
+ *
+ *  @return           void
+ *
+ *  @pre              tableIdx must be an index to a valid entry
+ */
+static void
+wlan_scan_delete_table_entry(wlan_private * priv, int tableIdx)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int delIdx;
+    uint beaconBufAdj;
+    u8 *pBeaconBuf;
+
+    /* Shift the saved beacon buffer data for the scan table back over the
+     *   entry being removed.  Update the end of buffer pointer.  Save the 
+     *   deleted buffer allocation size for pointer adjustments for entries
+     *   compacted after the deleted index.
+     */
+    beaconBufAdj = Adapter->ScanTable[tableIdx].beaconBufSizeMax;
+
+    PRINTM(INFO, "Scan: Delete Entry %d, beacon buffer removal = %d bytes\n",
+           tableIdx, beaconBufAdj);
+
+    /* Check if the table entry had storage allocated for its beacon */
+    if (beaconBufAdj) {
+        pBeaconBuf = Adapter->ScanTable[tableIdx].pBeaconBuf;
+
+        /* Remove the entry's buffer space, decrement the table end pointer
+         *   by the amount we are removing 
+         */
+        Adapter->pBeaconBufEnd -= beaconBufAdj;
+
+        PRINTM(INFO,
+               "Scan: Delete Entry %d, compact data: %p <- %p (sz = %d)\n",
+               tableIdx,
+               pBeaconBuf,
+               pBeaconBuf + beaconBufAdj,
+               Adapter->pBeaconBufEnd - pBeaconBuf);
+
+        /* Compact data storage.  Copy all data after the deleted entry's
+         *   end address (pBeaconBuf + beaconBufAdj) back to the original
+         *   start address (pBeaconBuf).
+         *
+         * Scan table entries affected by the move will have their entry
+         *   pointer adjusted below.
+         *
+         * Use memmove since the dest/src memory regions overlap.
+         */
+        memmove(pBeaconBuf,
+                pBeaconBuf + beaconBufAdj,
+                Adapter->pBeaconBufEnd - pBeaconBuf);
+    }
+
+    PRINTM(INFO, "Scan: Delete Entry %d, NumInScanTable = %d\n",
+           tableIdx, Adapter->NumInScanTable);
+
+    /* Shift all of the entries after the tableIdx back by one, compacting
+     *   the table and removing the requested entry
+     */
+    for (delIdx = tableIdx; (delIdx + 1) < Adapter->NumInScanTable; delIdx++) {
+        /* Copy the next entry over this one */
+        memcpy(Adapter->ScanTable + delIdx,
+               Adapter->ScanTable + delIdx + 1, sizeof(BSSDescriptor_t));
+
+        /* Adjust this entry's pointer to its beacon buffer based on the 
+         *   removed/compacted entry from the deleted index.  Don't decrement
+         *   if the buffer pointer is NULL (no data stored for this entry).
+         */
+        if (Adapter->ScanTable[delIdx].pBeaconBuf) {
+            Adapter->ScanTable[delIdx].pBeaconBuf -= beaconBufAdj;
+        }
+    }
+
+    /* The last entry is invalid now that it has been deleted or moved back */
+    memset(Adapter->ScanTable + Adapter->NumInScanTable - 1,
+           0x00, sizeof(BSSDescriptor_t));
+
+    Adapter->NumInScanTable--;
+}
+
+/**
+ *  @brief Delete all occurrences of a given SSID from the scan table
+ *
+ *  Iterate through the scan table and delete all entries that match a given
+ *    SSID.  Compact the remaining scan table entries.
+ *
+ *  @param priv       A pointer to wlan_private structure
+ *  @param pDelSSID   Pointer to an SSID struct to use in deleting all
+ *                    matching SSIDs from the scan table
+ *
+ *  @return           WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ *
+ */
+static int
+wlan_scan_delete_ssid_table_entry(wlan_private * priv,
+                                  WLAN_802_11_SSID * pDelSSID)
+{
+    int tableIdx;
+    int retval = WLAN_STATUS_FAILURE;
+
+    ENTER();
+
+    PRINTM(INFO, "Scan: Delete Ssid Entry: %-32s\n", pDelSSID->Ssid);
+
+    /* If the requested SSID is found in the table, delete it.  Then keep
+     *   searching the table for multiple entires for the SSID until no
+     *   more are found 
+     */
+    while ((tableIdx = FindSSIDInList(priv->adapter,
+                                      pDelSSID,
+                                      NULL, Wlan802_11AutoUnknown)) >= 0) {
+        PRINTM(INFO, "Scan: Delete Ssid Entry: Found Idx = %d\n", tableIdx);
+        retval = WLAN_STATUS_SUCCESS;
+        wlan_scan_delete_table_entry(priv, tableIdx);
+    }
+
+    LEAVE();
+
+    return retval;
+}
+
+/**
+ *  @brief Scan Network
+ *
+ *  @param dev          A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param vwrq         A pointer to iw_param structure
+ *  @param extra        A pointer to extra data buf
+ *
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_set_scan(struct net_device *dev, struct iw_request_info *info,
+              struct iw_param *vwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    union iwreq_data wrqu;
+#if WIRELESS_EXT >= 18
+    struct iw_scan_req *req;
+    struct iw_point *dwrq = (struct iw_point *) vwrq;
+    wlan_ioctl_user_scan_cfg scanCfg;
+#endif
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+#ifdef REASSOCIATION
+    if (OS_ACQ_SEMAPHORE_BLOCK(&Adapter->ReassocSem)) {
+        PRINTM(ERROR, "Acquire semaphore error, wlan_set_scan\n");
+        return -EBUSY;
+    }
+#endif
+#if WIRELESS_EXT >= 18
+    if ((dwrq->flags & IW_SCAN_THIS_ESSID) &&
+        (dwrq->length == sizeof(struct iw_scan_req))) {
+        req = (struct iw_scan_req *) extra;
+        if (req->essid_len <= WLAN_MAX_SSID_LENGTH) {
+            memset(&scanCfg, 0x00, sizeof(scanCfg));
+            memcpy(scanCfg.ssidList[0].ssid, (u8 *) req->essid,
+                   req->essid_len);
+            if (!wlan_scan_networks(priv, &scanCfg)) {
+                memset(&wrqu, 0, sizeof(union iwreq_data));
+                wireless_send_event(priv->wlan_dev.netdev, SIOCGIWSCAN, &wrqu,
+                                    NULL);
+
+            }
+        }
+    } else {
+#endif
+
+        if (!wlan_scan_networks(priv, NULL)) {
+            memset(&wrqu, 0, sizeof(union iwreq_data));
+            wireless_send_event(priv->wlan_dev.netdev, SIOCGIWSCAN, &wrqu,
+                                NULL);
+
+        }
+#if WIRELESS_EXT >= 18
+    }
+#endif
+
+#ifdef REASSOCIATION
+    OS_REL_SEMAPHORE(&Adapter->ReassocSem);
+#endif
+
+    if (Adapter->SurpriseRemoved)
+        return WLAN_STATUS_FAILURE;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Send a scan command for all available channels filtered on a spec
+ *
+ *  @param priv             A pointer to wlan_private structure
+ *  @param pRequestedSSID   A pointer to AP's ssid
+ *
+ *  @return                WLAN_STATUS_SUCCESS-success, otherwise fail
+ */
+int
+SendSpecificSSIDScan(wlan_private * priv, WLAN_802_11_SSID * pRequestedSSID)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    wlan_ioctl_user_scan_cfg scanCfg;
+
+    ENTER();
+
+    if (pRequestedSSID == NULL) {
+        return WLAN_STATUS_FAILURE;
+    }
+
+    wlan_scan_delete_ssid_table_entry(priv, pRequestedSSID);
+
+    memset(&scanCfg, 0x00, sizeof(scanCfg));
+
+    memcpy(scanCfg.ssidList[0].ssid,
+           pRequestedSSID->Ssid, pRequestedSSID->SsidLength);
+    scanCfg.keepPreviousScan = TRUE;
+
+    wlan_scan_networks(priv, &scanCfg);
+
+    if (Adapter->SurpriseRemoved)
+        return WLAN_STATUS_FAILURE;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief scan an AP with specific BSSID
+ *
+ *  @param priv      A pointer to wlan_private structure
+ *  @param bssid     A pointer to AP's bssid
+ *
+ *  @return          WLAN_STATUS_SUCCESS-success, otherwise fail
+ */
+int
+SendSpecificBSSIDScan(wlan_private * priv, u8 * bssid)
+{
+    wlan_ioctl_user_scan_cfg scanCfg;
+
+    ENTER();
+
+    if (bssid == NULL) {
+        return WLAN_STATUS_FAILURE;
+    }
+
+    memset(&scanCfg, 0x00, sizeof(scanCfg));
+    memcpy(scanCfg.specificBSSID, bssid, sizeof(scanCfg.specificBSSID));
+    scanCfg.keepPreviousScan = TRUE;
+
+    wlan_scan_networks(priv, &scanCfg);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief  Retrieve the scan table entries via wireless tools IOCTL call
+ *
+ *  @param dev          A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param dwrq         A pointer to iw_point structure
+ *  @param extra        A pointer to extra data buf
+ *
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_get_scan(struct net_device *dev, struct iw_request_info *info,
+              struct iw_point *dwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    char *current_ev = extra;
+    char *end_buf = extra + IW_SCAN_MAX_DATA;
+    CHANNEL_FREQ_POWER *cfp;
+    BSSDescriptor_t *pScanTable;
+    char *current_val;          /* For rates */
+    struct iw_event iwe;        /* Temporary buffer */
+    int i;
+    int j;
+    int rate;
+
+    u8 buf[16 + 256 * 2];
+    u8 *ptr;
+    u8 *pRawData;
+#define PERFECT_RSSI ((u8)50)
+#define WORST_RSSI   ((u8)0)
+#define RSSI_DIFF    ((u8)(PERFECT_RSSI - WORST_RSSI))
+    u8 rssi;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        PRINTM(INFO, "Current Ssid: %-32s\n",
+               Adapter->CurBssParams.BSSDescriptor.Ssid.Ssid);
+    }
+
+    PRINTM(INFO, "Scan: Get: NumInScanTable = %d\n", Adapter->NumInScanTable);
+
+#if WIRELESS_EXT > 13
+    /* The old API using SIOCGIWAPLIST had a hard limit of IW_MAX_AP.
+     * The new API using SIOCGIWSCAN is only limited by buffer size
+     * WE-14 -> WE-16 the buffer is limited to IW_SCAN_MAX_DATA bytes
+     * which is 4096.
+     */
+    for (i = 0; i < Adapter->NumInScanTable; i++) {
+        if ((current_ev + MAX_SCAN_CELL_SIZE) >= end_buf) {
+            PRINTM(INFO, "i=%d break out: current_ev=%p end_buf=%p "
+                   "MAX_SCAN_CELL_SIZE=%d\n",
+                   i, current_ev, end_buf, MAX_SCAN_CELL_SIZE);
+            break;
+        }
+
+        pScanTable = &Adapter->ScanTable[i];
+
+        PRINTM(INFO, "i=%d  Ssid: %-32s\n", i, pScanTable->Ssid.Ssid);
+
+        cfp =
+            find_cfp_by_band_and_channel(Adapter, 0,
+                                         (u16) pScanTable->Channel);
+        if (!cfp) {
+            PRINTM(INFO, "Invalid channel number %d\n", pScanTable->Channel);
+            continue;
+        }
+
+        if (ssid_valid(&Adapter->ScanTable[i].Ssid) == FALSE) {
+            continue;
+        }
+
+        /* First entry *MUST* be the AP MAC address */
+        iwe.cmd = SIOCGIWAP;
+        iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
+        memcpy(iwe.u.ap_addr.sa_data,
+               &Adapter->ScanTable[i].MacAddress, ETH_ALEN);
+
+        iwe.len = IW_EV_ADDR_LEN;
+        current_ev = iwe_stream_add_event(info, current_ev, end_buf, &iwe, iwe.len);
+
+        //Add the ESSID
+        iwe.u.data.length = Adapter->ScanTable[i].Ssid.SsidLength;
+
+        if (iwe.u.data.length > 32) {
+            iwe.u.data.length = 32;
+        }
+
+        iwe.cmd = SIOCGIWESSID;
+        iwe.u.essid.flags = (i + 1) & IW_ENCODE_INDEX;
+        iwe.len = IW_EV_POINT_LEN + iwe.u.data.length;
+        current_ev = iwe_stream_add_point(info, current_ev, end_buf, &iwe,
+                                          (s8 *) Adapter->ScanTable[i].Ssid.
+                                          Ssid);
+
+        //Add mode
+        iwe.cmd = SIOCGIWMODE;
+        iwe.u.mode = Adapter->ScanTable[i].InfrastructureMode + 1;
+        iwe.len = IW_EV_UINT_LEN;
+        current_ev = iwe_stream_add_event(info, current_ev, end_buf, &iwe, iwe.len);
+
+        //frequency
+        iwe.cmd = SIOCGIWFREQ;
+        iwe.u.freq.m = (long) cfp->Freq * 100000;
+        iwe.u.freq.e = 1;
+        iwe.len = IW_EV_FREQ_LEN;
+        current_ev = iwe_stream_add_event(info, current_ev, end_buf, &iwe, iwe.len);
+
+        /* Add quality statistics */
+        iwe.cmd = IWEVQUAL;
+        iwe.u.qual.updated = IW_QUAL_ALL_UPDATED;
+        iwe.u.qual.level = SCAN_RSSI(Adapter->ScanTable[i].Rssi);
+
+        rssi = iwe.u.qual.level - MRVDRV_NF_DEFAULT_SCAN_VALUE;
+        iwe.u.qual.qual =
+            (100 * RSSI_DIFF * RSSI_DIFF - (PERFECT_RSSI - rssi) *
+            (15 * (RSSI_DIFF) + 62 * (PERFECT_RSSI - rssi)))  /
+            (RSSI_DIFF * RSSI_DIFF);
+        if (iwe.u.qual.qual > 100)
+            iwe.u.qual.qual = 100;
+
+        if (Adapter->NF[TYPE_BEACON][TYPE_NOAVG] == 0) {
+            iwe.u.qual.noise = MRVDRV_NF_DEFAULT_SCAN_VALUE;
+        } else {
+            iwe.u.qual.noise = CAL_NF(Adapter->NF[TYPE_BEACON][TYPE_NOAVG]);
+        }
+        if ((Adapter->InfrastructureMode == Wlan802_11IBSS) &&
+            !SSIDcmp(&Adapter->CurBssParams.BSSDescriptor.Ssid,
+                     &Adapter->ScanTable[i].Ssid)
+            && Adapter->AdhocCreate) {
+            ret = PrepareAndSendCommand(priv,
+                                        HostCmd_CMD_802_11_RSSI,
+                                        0, HostCmd_OPTION_WAITFORRSP, 0,
+                                        NULL);
+
+            if (ret) {
+                LEAVE();
+                return ret;
+            }
+            iwe.u.qual.level =
+                CAL_RSSI(Adapter->SNR[TYPE_RXPD][TYPE_AVG] / AVG_SCALE,
+                         Adapter->NF[TYPE_RXPD][TYPE_AVG] / AVG_SCALE);
+        }
+
+        iwe.len = IW_EV_QUAL_LEN;
+        current_ev = iwe_stream_add_event(info, current_ev, end_buf, &iwe, iwe.len);
+
+        /* Add encryption capability */
+        iwe.cmd = SIOCGIWENCODE;
+        if (Adapter->ScanTable[i].Privacy) {
+            iwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
+        } else {
+            iwe.u.data.flags = IW_ENCODE_DISABLED;
+        }
+        iwe.u.data.length = 0;
+        iwe.len = IW_EV_POINT_LEN + iwe.u.data.length;
+        current_ev = iwe_stream_add_point(info, current_ev, end_buf, &iwe, NULL);
+
+        current_val = current_ev + IW_EV_LCP_LEN;
+
+        iwe.cmd = SIOCGIWRATE;
+
+        iwe.u.bitrate.fixed = 0;
+        iwe.u.bitrate.disabled = 0;
+        iwe.u.bitrate.value = 0;
+
+        /* Bit rate given in 500 kb/s units (+ 0x80) */
+        for (j = 0; j < sizeof(Adapter->ScanTable[i].SupportedRates); j++) {
+            if (Adapter->ScanTable[i].SupportedRates[j] == 0) {
+                break;
+            }
+            rate = (Adapter->ScanTable[i].SupportedRates[j] & 0x7F) * 500000;
+            if (rate > iwe.u.bitrate.value) {
+                iwe.u.bitrate.value = rate;
+            }
+
+            iwe.u.bitrate.value = (Adapter->ScanTable[i].SupportedRates[j]
+                                   & 0x7f) * 500000;
+            iwe.len = IW_EV_PARAM_LEN;
+            current_ev =
+                iwe_stream_add_value(info, current_ev, current_val, end_buf, &iwe,
+                                     iwe.len);
+
+        }
+        if ((Adapter->ScanTable[i].InfrastructureMode == Wlan802_11IBSS) &&
+            !SSIDcmp(&Adapter->CurBssParams.BSSDescriptor.Ssid,
+                     &Adapter->ScanTable[i].Ssid)
+            && Adapter->AdhocCreate) {
+            iwe.u.bitrate.value = 22 * 500000;
+        }
+        iwe.len = IW_EV_PARAM_LEN;
+        current_ev = iwe_stream_add_value(info, current_ev, current_val, end_buf,
+                                          &iwe, iwe.len);
+
+        /* Add new value to event */
+        current_val = current_ev + IW_EV_LCP_LEN;
+
+        if (Adapter->ScanTable[i].rsnIE.IeeeHdr.ElementId == RSN_IE) {
+            pRawData = (u8 *) & Adapter->ScanTable[i].rsnIE;
+            memset(&iwe, 0, sizeof(iwe));
+            memset(buf, 0, sizeof(buf));
+            ptr = buf;
+#if WIRELESS_EXT >= 18
+            memcpy(buf, pRawData,
+                   Adapter->ScanTable[i].rsnIE.IeeeHdr.Len + 2);
+            iwe.cmd = IWEVGENIE;
+            iwe.u.data.length = Adapter->ScanTable[i].rsnIE.IeeeHdr.Len + 2;
+#else
+            ptr += sprintf(ptr, "rsn_ie=");
+
+            for (j = 0;
+                 j < (Adapter->ScanTable[i].rsnIE.IeeeHdr.Len
+                      + sizeof(IEEEtypes_Header_t)); j++) {
+                ptr += sprintf(ptr, "%02x", *(pRawData + j));
+            }
+            iwe.u.data.length = strlen(buf);
+
+            PRINTM(INFO, "iwe.u.data.length %d\n", iwe.u.data.length);
+            PRINTM(INFO, "WPA2 BUF: %s \n", buf);
+
+            iwe.cmd = IWEVCUSTOM;
+#endif
+            iwe.len = IW_EV_POINT_LEN + iwe.u.data.length;
+            current_ev = iwe_stream_add_point(info, current_ev, end_buf, &iwe, buf);
+        }
+        if (Adapter->ScanTable[i].wpaIE.VendHdr.ElementId == WPA_IE) {
+            pRawData = (u8 *) & Adapter->ScanTable[i].wpaIE;
+            memset(&iwe, 0, sizeof(iwe));
+            memset(buf, 0, sizeof(buf));
+            ptr = buf;
+#if WIRELESS_EXT >= 18
+            memcpy(buf, pRawData,
+                   Adapter->ScanTable[i].wpaIE.VendHdr.Len + 2);
+            iwe.cmd = IWEVGENIE;
+            iwe.u.data.length = Adapter->ScanTable[i].wpaIE.VendHdr.Len + 2;
+#else
+            ptr += sprintf(ptr, "wpa_ie=");
+
+            for (j = 0;
+                 j < (Adapter->ScanTable[i].wpaIE.VendHdr.Len
+                      + sizeof(IEEEtypes_Header_t)); j++) {
+                ptr += sprintf(ptr, "%02x", *(pRawData + j));
+            }
+            iwe.u.data.length = strlen(buf);
+
+            PRINTM(INFO, "iwe.u.data.length %d\n", iwe.u.data.length);
+            PRINTM(INFO, "WPA BUF: %s \n", buf);
+
+            iwe.cmd = IWEVCUSTOM;
+#endif
+            iwe.len = IW_EV_POINT_LEN + iwe.u.data.length;
+            current_ev = iwe_stream_add_point(info, current_ev, end_buf, &iwe, buf);
+        }
+        if (Adapter->ScanTable[i].wpsIE.VendHdr.ElementId == WPS_IE) {
+            pRawData = (u8 *) & Adapter->ScanTable[i].wpsIE;
+            memset(&iwe, 0, sizeof(iwe));
+            memset(buf, 0, sizeof(buf));
+            ptr = buf;
+            ptr += sprintf(ptr, "wps_ie=");
+
+            for (j = 0;
+                 j < (Adapter->ScanTable[i].wpsIE.VendHdr.Len
+                      + sizeof(IEEEtypes_Header_t)); j++) {
+                ptr += sprintf(ptr, "%02x", *(pRawData + j));
+            }
+            iwe.u.data.length = strlen(buf);
+
+            PRINTM(INFO, "iwe.u.data.length %d\n", iwe.u.data.length);
+            PRINTM(INFO, "WPS BUF: %s \n", buf);
+
+            iwe.cmd = IWEVCUSTOM;
+            iwe.len = IW_EV_POINT_LEN + iwe.u.data.length;
+            current_ev = iwe_stream_add_point(info, current_ev, end_buf, &iwe, buf);
+        }
+
+#if WIRELESS_EXT > 14
+
+        if (Adapter->ScanTable[i].extra_ie != 0) {
+            memset(&iwe, 0, sizeof(iwe));
+            memset(buf, 0, sizeof(buf));
+            ptr = buf;
+            ptr += sprintf(ptr, "extra_ie");
+            iwe.u.data.length = strlen(buf);
+
+            PRINTM(INFO, "iwe.u.data.length %d\n", iwe.u.data.length);
+            PRINTM(INFO, "BUF: %s \n", buf);
+
+            iwe.cmd = IWEVCUSTOM;
+            iwe.len = IW_EV_POINT_LEN + iwe.u.data.length;
+            current_ev = iwe_stream_add_point(info, current_ev, end_buf, &iwe, buf);
+        }
+#endif
+
+        current_val = current_ev + IW_EV_LCP_LEN;
+
+        /*
+         * Check if we added any event
+         */
+        if ((current_val - current_ev) > IW_EV_LCP_LEN)
+            current_ev = current_val;
+    }
+
+    dwrq->length = (current_ev - extra);
+    dwrq->flags = 0;
+
+    LEAVE();
+#endif
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Create a wlan_ioctl_get_scan_table_entry for a given BSS 
+ *         Descriptor for inclusion in the ioctl response to the user space
+ *         application.
+ *
+ *
+ *  @param priv      A pointer to wlan_private structure
+ *  @param pBSSDesc  Pointer to a BSS entry in the scan table to form
+ *                   scan response from for delivery to the application layer
+ *  @param ppBuffer  Output parameter: Buffer used to output scan return struct
+ *  @param pSpaceLeft Output parameter: Number of bytes available in the 
+ *                    response buffer.
+ *
+ *  @return WLAN_STATUS_SUCCESS, or < 0 with IOCTL error code
+ */
+static int
+wlan_get_scan_table_ret_entry(wlan_private * priv,
+                              BSSDescriptor_t * pBSSDesc,
+                              u8 ** ppBuffer, int *pSpaceLeft)
+{
+    wlan_adapter *Adapter;
+    wlan_ioctl_get_scan_table_entry *pRspEntry;
+    wlan_ioctl_get_scan_table_entry tmpRspEntry;
+    int spaceNeeded;
+    u8 *pCurrent;
+    int variableSize;
+
+    const int fixedSize = (sizeof(tmpRspEntry.fixedFieldLength)
+                           + sizeof(tmpRspEntry.fixedFields)
+                           + sizeof(tmpRspEntry.bssInfoLength));
+
+    ENTER();
+
+    Adapter = priv->adapter;
+    pCurrent = *ppBuffer;
+
+    /* The variable size returned is the stored beacon size */
+    variableSize = pBSSDesc->beaconBufSize;
+
+    /* If we stored a beacon and its size was zero, set the variable
+     *  size return value to the size of the brief scan response 
+     *  wlan_scan_create_brief_table_entry creates.  Also used if 
+     *  we are not configured to store beacons in the first place
+     */
+    if (variableSize == 0) {
+        variableSize = pBSSDesc->Ssid.SsidLength + 2;
+        variableSize += (sizeof(pBSSDesc->BeaconPeriod)
+                         + sizeof(pBSSDesc->TimeStamp)
+                         + sizeof(pBSSDesc->Cap));
+        if (pBSSDesc->wmmIE.VendHdr.ElementId == WMM_IE) {
+            variableSize += (sizeof(IEEEtypes_Header_t)
+                             + pBSSDesc->wmmIE.VendHdr.Len);
+        }
+
+        if (pBSSDesc->wpaIE.VendHdr.ElementId == WPA_IE) {
+            variableSize += (sizeof(IEEEtypes_Header_t)
+                             + pBSSDesc->wpaIE.VendHdr.Len);
+        }
+
+        if (pBSSDesc->rsnIE.IeeeHdr.ElementId == RSN_IE) {
+            variableSize += (sizeof(IEEEtypes_Header_t)
+                             + pBSSDesc->rsnIE.IeeeHdr.Len);
+        }
+    }
+
+    spaceNeeded = fixedSize + variableSize;
+
+    PRINTM(INFO, "GetScanTable: need(%d), left(%d)\n",
+           spaceNeeded, *pSpaceLeft);
+
+    if (spaceNeeded >= *pSpaceLeft) {
+        *pSpaceLeft = 0;
+        LEAVE();
+        return -E2BIG;
+    }
+
+    *pSpaceLeft -= spaceNeeded;
+
+    tmpRspEntry.fixedFieldLength = sizeof(pRspEntry->fixedFields);
+
+    memcpy(tmpRspEntry.fixedFields.bssid,
+           pBSSDesc->MacAddress, sizeof(pRspEntry->fixedFields.bssid));
+
+    tmpRspEntry.fixedFields.rssi = pBSSDesc->Rssi;
+    tmpRspEntry.fixedFields.channel = pBSSDesc->Channel;
+    tmpRspEntry.fixedFields.networkTSF = pBSSDesc->networkTSF;
+    tmpRspEntry.bssInfoLength = variableSize;
+
+    /*
+     *  Copy fixed fields to user space
+     */
+    if (copy_to_user(pCurrent, &tmpRspEntry, fixedSize)) {
+        PRINTM(INFO, "Copy to user failed\n");
+        LEAVE();
+        return -EFAULT;
+    }
+
+    pCurrent += fixedSize;
+
+    if (pBSSDesc->pBeaconBuf) {
+        /*
+         *  Copy variable length elements to user space
+         */
+        if (copy_to_user(pCurrent, pBSSDesc->pBeaconBuf,
+                         pBSSDesc->beaconBufSize)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+
+        pCurrent += pBSSDesc->beaconBufSize;
+    } else {
+        wlan_scan_create_brief_table_entry(&pCurrent, pBSSDesc);
+    }
+
+    *ppBuffer = pCurrent;
+
+    LEAVE();
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Retrieve the scan response/beacon table
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param wrq          A pointer to iwreq structure
+ *
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_get_scan_table_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter;
+    BSSDescriptor_t *pBSSDesc;
+    wlan_ioctl_get_scan_table_info *pRspInfo;
+    int retcode;
+    int retlen;
+    int spaceLeft;
+    u8 *pCurrent;
+    u8 *pBufferEnd;
+    u32 scanStart;
+    u32 numScansDone;
+
+    numScansDone = 0;
+    retcode = WLAN_STATUS_SUCCESS;
+    Adapter = priv->adapter;
+
+    if (copy_from_user(&scanStart,
+                       wrq->u.data.pointer, sizeof(scanStart)) != 0) {
+        /* copy_from_user failed  */
+        PRINTM(INFO, "GetScanTable: copy from user failed\n");
+        return -EFAULT;
+    }
+
+    pRspInfo = (wlan_ioctl_get_scan_table_info *) wrq->u.data.pointer;
+    pCurrent = pRspInfo->scan_table_entry_buffer;
+    pBufferEnd = wrq->u.data.pointer + wrq->u.data.length - 1;
+    spaceLeft = pBufferEnd - pCurrent;
+    PRINTM(INFO, "GetScanTable: scanStart req = %d\n", scanStart);
+    PRINTM(INFO, "GetScanTable: length avail = %d\n", wrq->u.data.length);
+
+    if (scanStart == 0) {
+        PRINTM(INFO, "GetScanTable: get current BSS Descriptor\n");
+
+        /* Use to get current association saved descriptor */
+        pBSSDesc = &Adapter->CurBssParams.BSSDescriptor;
+
+        retcode = wlan_get_scan_table_ret_entry(priv,
+                                                pBSSDesc,
+                                                &pCurrent, &spaceLeft);
+
+        if (retcode == WLAN_STATUS_SUCCESS) {
+            numScansDone = 1;
+        }
+
+    } else {
+        scanStart--;
+
+        while (spaceLeft
+               && (scanStart + numScansDone < Adapter->NumInScanTable)
+               && (retcode == WLAN_STATUS_SUCCESS)) {
+
+            pBSSDesc = &Adapter->ScanTable[scanStart + numScansDone];
+
+            PRINTM(INFO, "GetScanTable: get current BSS Descriptor [%d]\n",
+                   scanStart + numScansDone);
+
+            retcode = wlan_get_scan_table_ret_entry(priv,
+                                                    pBSSDesc,
+                                                    &pCurrent, &spaceLeft);
+
+            if (retcode == WLAN_STATUS_SUCCESS) {
+                numScansDone++;
+            }
+        }
+    }
+
+    pRspInfo->scanNumber = numScansDone;
+    retlen = pCurrent - (u8 *) wrq->u.data.pointer;
+
+    wrq->u.data.length = retlen;
+
+    /* Return retcode (EFAULT or E2BIG) in the case where no scan results were
+     *   successfully encoded.
+     */
+
+    return (numScansDone ? WLAN_STATUS_SUCCESS : retcode);
+}
+
+/**
+ *  @brief Update the scan entry TSF timestamps to reflect a new association
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param pNewBssDesc  A pointer to the newly associated AP's scan table entry
+ *
+ *  @return             void
+ */
+void
+wlan_scan_update_tsf_timestamps(wlan_private * priv,
+                                BSSDescriptor_t * pNewBssDesc)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int tableIdx;
+    u64 newTsfBase;
+    s64 tsfDelta;
+
+    memcpy(&newTsfBase, pNewBssDesc->TimeStamp, sizeof(newTsfBase));
+
+    tsfDelta = newTsfBase - pNewBssDesc->networkTSF;
+
+    PRINTM(INFO, "TSF: Update TSF timestamps, 0x%016llx -> 0x%016llx\n",
+           pNewBssDesc->networkTSF, newTsfBase);
+
+    for (tableIdx = 0; tableIdx < Adapter->NumInScanTable; tableIdx++) {
+        Adapter->ScanTable[tableIdx].networkTSF += tsfDelta;
+    }
+}
+
+/**
+ *  @brief Private IOCTL entry to perform an app configured immediate scan
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param wrq          A pointer to iwreq structure containing the
+ *                      wlan_ioctl_user_scan_cfg requesting this scan
+ *
+ *  @return             0 if successful; IOCTL error code otherwise
+ */
+int
+wlan_set_user_scan_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_ioctl_user_scan_cfg scanReq;
+    int retcode;
+    union iwreq_data wrqu;
+
+#ifdef REASSOCIATION
+    if (OS_ACQ_SEMAPHORE_BLOCK(&priv->adapter->ReassocSem)) {
+        PRINTM(ERROR, "Acquire semaphore error, wlan_extscan_ioctl\n");
+        return -EBUSY;
+    }
+#endif
+
+    memset(&scanReq, 0x00, sizeof(scanReq));
+
+    if (copy_from_user(&scanReq,
+                       wrq->u.data.pointer,
+                       MIN(wrq->u.data.length, sizeof(scanReq))) != 0) {
+        /* copy_from_user failed  */
+        PRINTM(INFO, "SetUserScan: copy from user failed\n");
+        retcode = -EFAULT;
+
+    } else {
+
+        retcode = wlan_scan_networks(priv, &scanReq);
+
+        memset(&wrqu, 0x00, sizeof(union iwreq_data));
+        wireless_send_event(priv->wlan_dev.netdev, SIOCGIWSCAN, &wrqu, NULL);
+
+    }
+
+#ifdef REASSOCIATION
+    OS_REL_SEMAPHORE(&priv->adapter->ReassocSem);
+#endif
+
+    return retcode;
+}
+
+/**
+ *  @brief Prepare a scan command to be sent to the firmware
+ *
+ *  Use the wlan_scan_cmd_config sent to the command processing module in
+ *   the PrepareAndSendCommand to configure a HostCmd_DS_802_11_SCAN command
+ *   struct to send to firmware.
+ *
+ *  The fixed fields specifying the BSS type and BSSID filters as well as a
+ *   variable number/length of TLVs are sent in the command to firmware.
+ *
+ *  @param priv       A pointer to wlan_private structure
+ *  @param cmd        A pointer to HostCmd_DS_COMMAND structure to be sent to
+ *                    firmware with the HostCmd_DS_801_11_SCAN structure
+ *  @param pdata_buf  Void pointer cast of a wlan_scan_cmd_config struct used
+ *                    to set the fields/TLVs for the command sent to firmware
+ *
+ *  @return           WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ *
+ *  @sa wlan_scan_create_channel_list
+ */
+int
+wlan_cmd_802_11_scan(wlan_private * priv,
+                     HostCmd_DS_COMMAND * cmd, void *pdata_buf)
+{
+    HostCmd_DS_802_11_SCAN *pScan = &cmd->params.scan;
+    wlan_scan_cmd_config *pScanCfg;
+
+    ENTER();
+
+    pScanCfg = (wlan_scan_cmd_config *) pdata_buf;
+
+    /* Set fixed field variables in scan command */
+    pScan->BSSType = pScanCfg->bssType;
+    memcpy(pScan->BSSID, pScanCfg->specificBSSID, sizeof(pScan->BSSID));
+    memcpy(pScan->TlvBuffer, pScanCfg->tlvBuffer, pScanCfg->tlvBufferLen);
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_SCAN);
+
+    /* Size is equal to the sizeof(fixed portions) + the TLV len + header */
+    cmd->Size = wlan_cpu_to_le16(sizeof(pScan->BSSType)
+                                 + sizeof(pScan->BSSID)
+                                 + pScanCfg->tlvBufferLen + S_DS_GEN);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Store a beacon or probe response for a BSS returned in the scan
+ *  
+ *  Store a new scan response or an update for a previous scan response.  New
+ *    entries need to verify that they do not exceed the total amount of 
+ *    memory allocated for the table.
+
+ *  Replacement entries need to take into consideration the amount of space 
+ *    currently allocated for the beacon/probe response and adjust the entry
+ *    as needed.  
+ *
+ *  A small amount of extra pad (SCAN_BEACON_ENTRY_PAD) is generally reserved
+ *    for an entry in case it is a beacon since a probe response for the
+ *    network will by larger per the standard.  This helps to reduce the 
+ *    amount of memory copying to fit a new probe response into an entry 
+ *    already occupied by a network's previously stored beacon.
+ *
+ *  @param priv       A pointer to wlan_private structure
+ *  @param beaconIdx  Index in the scan table to store this entry; may be
+ *                    replacing an older duplicate entry for this BSS
+ *  @param numInTable Number of entries currently in the table
+ *  @param pNewBeacon Pointer to the new beacon/probe response to save
+ *
+ *  @return           void
+ */
+void
+wlan_ret_802_11_scan_store_beacon(wlan_private * priv,
+                                  int beaconIdx,
+                                  int numInTable,
+                                  BSSDescriptor_t * pNewBeacon)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    u8 *pBcnStore;
+    int newBcnSize;
+    int oldBcnSize;
+    int bcnSpace;
+    int adjIdx;
+
+    if (Adapter->ScanTable[beaconIdx].pBeaconBuf != NULL) {
+
+        newBcnSize = pNewBeacon->beaconBufSize;
+        oldBcnSize = Adapter->ScanTable[beaconIdx].beaconBufSize;
+        bcnSpace = Adapter->ScanTable[beaconIdx].beaconBufSizeMax;
+        pBcnStore = Adapter->ScanTable[beaconIdx].pBeaconBuf;
+
+        /* Set the max to be the same as current entry unless changed below */
+        pNewBeacon->beaconBufSizeMax = bcnSpace;
+
+        if (newBcnSize == oldBcnSize) {
+            /*
+             * Beacon is the same size as the previous entry.
+             *   Replace the previous contents with the scan result
+             */
+            memcpy(pBcnStore,
+                   pNewBeacon->pBeaconBuf, pNewBeacon->beaconBufSize);
+
+        } else if (newBcnSize <= bcnSpace) {
+            /*
+             * New beacon size will fit in the amount of space
+             *   we have previously allocated for it
+             */
+
+            /* Copy the new beacon buffer entry over the old one */
+            memcpy(pBcnStore, pNewBeacon->pBeaconBuf, newBcnSize);
+
+            /* If the old beacon size was less than the maximum
+             *  we had alloted for the entry, and the new entry
+             *  is even smaller, reset the max size to the old beacon
+             *  entry and compress the storage space (leaving a new
+             *  pad space of (oldBcnSize - newBcnSize).
+             */
+            if (oldBcnSize < bcnSpace && newBcnSize != bcnSpace) {
+                /*
+                 * Old Beacon size is smaller than the alloted storage size.
+                 *   Shrink the alloted storage space.
+                 */
+                PRINTM(INFO, "AppControl: Smaller Duplicate Beacon (%d), "
+                       "old = %d, new = %d, space = %d, left = %d\n",
+                       beaconIdx, oldBcnSize, newBcnSize, bcnSpace,
+                       (sizeof(Adapter->beaconBuffer) -
+                        (Adapter->pBeaconBufEnd - Adapter->beaconBuffer)));
+
+                /* memmove (since the memory overlaps) the data
+                 *  after the beacon we just stored to the end of
+                 *  the current beacon.  This cleans up any unused
+                 *  space the old larger beacon was using in the buffer
+                 */
+                memmove(pBcnStore + oldBcnSize,
+                        pBcnStore + bcnSpace,
+                        Adapter->pBeaconBufEnd - (pBcnStore + bcnSpace));
+
+                /* Decrement the end pointer by the difference between
+                 *  the old larger size and the new smaller size since
+                 *  we are using less space due to the new beacon being
+                 *  smaller
+                 */
+                Adapter->pBeaconBufEnd -= (bcnSpace - oldBcnSize);
+
+                /* Set the maximum storage size to the old beacon size */
+                pNewBeacon->beaconBufSizeMax = oldBcnSize;
+
+                /* Adjust beacon buffer pointers that are past the current */
+                for (adjIdx = 0; adjIdx < numInTable; adjIdx++) {
+                    if (Adapter->ScanTable[adjIdx].pBeaconBuf > pBcnStore) {
+                        Adapter->ScanTable[adjIdx].pBeaconBuf
+                            -= (bcnSpace - oldBcnSize);
+                    }
+                }
+            }
+        } else if (Adapter->pBeaconBufEnd + (newBcnSize - bcnSpace)
+                   < (Adapter->beaconBuffer + sizeof(Adapter->beaconBuffer))) {
+            /*
+             * Beacon is larger than space previously allocated (bcnSpace)
+             *   and there is enough space left in the beaconBuffer to store
+             *   the additional data
+             */
+            PRINTM(INFO, "AppControl: Larger Duplicate Beacon (%d), "
+                   "old = %d, new = %d, space = %d, left = %d\n",
+                   beaconIdx, oldBcnSize, newBcnSize, bcnSpace,
+                   (sizeof(Adapter->beaconBuffer) -
+                    (Adapter->pBeaconBufEnd - Adapter->beaconBuffer)));
+
+            /* memmove (since the memory overlaps) the data
+             *  after the beacon we just stored to the end of
+             *  the current beacon.  This moves the data for
+             *  the beacons after this further in memory to
+             *  make space for the new larger beacon we are
+             *  about to copy in.
+             */
+            memmove(pBcnStore + newBcnSize,
+                    pBcnStore + bcnSpace,
+                    Adapter->pBeaconBufEnd - (pBcnStore + bcnSpace));
+
+            /* Copy the new beacon buffer entry over the old one */
+            memcpy(pBcnStore, pNewBeacon->pBeaconBuf, newBcnSize);
+
+            /* Move the beacon end pointer by the amount of new
+             *  beacon data we are adding
+             */
+            Adapter->pBeaconBufEnd += (newBcnSize - bcnSpace);
+
+            /* This entry is bigger than the alloted max space
+             *  previously reserved.  Increase the max space to
+             *  be equal to the new beacon size
+             */
+            pNewBeacon->beaconBufSizeMax = newBcnSize;
+
+            /* Adjust beacon buffer pointers that are past the current */
+            for (adjIdx = 0; adjIdx < numInTable; adjIdx++) {
+                if (Adapter->ScanTable[adjIdx].pBeaconBuf > pBcnStore) {
+                    Adapter->ScanTable[adjIdx].pBeaconBuf
+                        += (newBcnSize - bcnSpace);
+                }
+            }
+        } else {
+            /*
+             * Beacon is larger than the previously allocated space, but
+             *   there is not enough free space to store the additional data
+             */
+            PRINTM(INFO,
+                   "AppControl: Failed: Larger Duplicate Beacon (%d),"
+                   " old = %d, new = %d, space = %d, left = %d\n",
+                   beaconIdx, oldBcnSize, newBcnSize, bcnSpace,
+                   (sizeof(Adapter->beaconBuffer) -
+                    (Adapter->pBeaconBufEnd - Adapter->beaconBuffer)));
+
+            /* Storage failure, keep old beacon intact */
+            pNewBeacon->beaconBufSize = oldBcnSize;
+        }
+
+        /* Point the new entry to its permanent storage space */
+        pNewBeacon->pBeaconBuf = pBcnStore;
+
+    } else {
+        /* No existing beacon data exists for this entry, check to see
+         *   if we can fit it in the remaining space
+         */
+        if (Adapter->pBeaconBufEnd + pNewBeacon->beaconBufSize +
+            SCAN_BEACON_ENTRY_PAD < (Adapter->beaconBuffer +
+                                     sizeof(Adapter->beaconBuffer))) {
+
+            /* Copy the beacon buffer data from the local entry to the
+             *   adapter dev struct buffer space used to store the raw
+             *   beacon data for each entry in the scan table
+             */
+            memcpy(Adapter->pBeaconBufEnd, pNewBeacon->pBeaconBuf,
+                   pNewBeacon->beaconBufSize);
+
+            /* Update the beacon ptr to point to the table save area */
+            pNewBeacon->pBeaconBuf = Adapter->pBeaconBufEnd;
+            pNewBeacon->beaconBufSizeMax = (pNewBeacon->beaconBufSize
+                                            + SCAN_BEACON_ENTRY_PAD);
+
+            /* Increment the end pointer by the size reserved */
+            Adapter->pBeaconBufEnd += pNewBeacon->beaconBufSizeMax;
+
+            PRINTM(INFO, "AppControl: Beacon[%02d] sz=%03d,"
+                   " used = %04d, left = %04d\n",
+                   beaconIdx,
+                   pNewBeacon->beaconBufSize,
+                   (Adapter->pBeaconBufEnd - Adapter->beaconBuffer),
+                   (sizeof(Adapter->beaconBuffer) -
+                    (Adapter->pBeaconBufEnd - Adapter->beaconBuffer)));
+        } else {
+            /*
+             * No space for new beacon
+             */
+            PRINTM(INFO, "AppControl: No space beacon (%d): "
+                   "%02x:%02x:%02x:%02x:%02x:%02x; sz=%03d, left=%03d\n",
+                   beaconIdx,
+                   pNewBeacon->MacAddress[0], pNewBeacon->MacAddress[1],
+                   pNewBeacon->MacAddress[2], pNewBeacon->MacAddress[3],
+                   pNewBeacon->MacAddress[4], pNewBeacon->MacAddress[5],
+                   pNewBeacon->beaconBufSize,
+                   (sizeof(Adapter->beaconBuffer) -
+                    (Adapter->pBeaconBufEnd - Adapter->beaconBuffer)));
+
+            /* Storage failure; clear storage records for this bcn */
+            pNewBeacon->pBeaconBuf = NULL;
+            pNewBeacon->beaconBufSize = 0;
+            pNewBeacon->beaconBufSizeMax = 0;
+        }
+    }
+}
+
+/**
+ *  @brief This function handles the command response of scan
+ *
+ *   The response buffer for the scan command has the following
+ *      memory layout:
+ *
+ *     .-----------------------------------------------------------.
+ *     |  Header (4 * sizeof(u16)):  Standard command response hdr |
+ *     .-----------------------------------------------------------.
+ *     |  BufSize (u16) : sizeof the BSS Description data          |
+ *     .-----------------------------------------------------------.
+ *     |  NumOfSet (u8) : Number of BSS Descs returned             |
+ *     .-----------------------------------------------------------.
+ *     |  BSSDescription data (variable, size given in BufSize)    |
+ *     .-----------------------------------------------------------.
+ *     |  TLV data (variable, size calculated using Header->Size,  |
+ *     |            BufSize and sizeof the fixed fields above)     |
+ *     .-----------------------------------------------------------.
+ *
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp    A pointer to HostCmd_DS_COMMAND
+ *
+ *  @return        WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_ret_802_11_scan(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_SCAN_RSP *pScan;
+    BSSDescriptor_t newBssEntry;
+    MrvlIEtypes_Data_t *pTlv;
+    MrvlIEtypes_TsfTimestamp_t *pTsfTlv;
+    u8 *pBssInfo;
+    u16 scanRespSize;
+    int bytesLeft;
+    int numInTable;
+    int bssIdx;
+    int idx;
+    int tlvBufSize;
+    u64 tsfVal;
+    BOOLEAN bgScanResp;
+
+    ENTER();
+
+    bgScanResp = (resp->Command == HostCmd_RET_802_11_BG_SCAN_QUERY);
+    if (bgScanResp) {
+        pScan = &resp->params.bgscanqueryresp.scanresp;
+    } else {
+        pScan = &resp->params.scanresp;
+    }
+
+    if (pScan->NumberOfSets > MRVDRV_MAX_BSSID_LIST) {
+        PRINTM(INFO, "SCAN_RESP: Invalid number of AP returned (%d)!!\n",
+               pScan->NumberOfSets);
+        LEAVE();
+        return WLAN_STATUS_FAILURE;
+    }
+
+    bytesLeft = wlan_le16_to_cpu(pScan->BSSDescriptSize);
+    PRINTM(INFO, "SCAN_RESP: BSSDescriptSize %d\n", bytesLeft);
+
+    scanRespSize = resp->Size;
+
+    PRINTM(CMND, "SCAN_RESP: returned %d APs before parsing\n",
+           pScan->NumberOfSets);
+
+    numInTable = Adapter->NumInScanTable;
+    pBssInfo = pScan->BssDescAndTlvBuffer;
+
+    /* The size of the TLV buffer is equal to the entire command response
+     *   size (scanRespSize) minus the fixed fields (sizeof()'s), the
+     *   BSS Descriptions (BSSDescriptSize as bytesLef) and the command
+     *   response header (S_DS_GEN)
+     */
+    tlvBufSize = scanRespSize - (bytesLeft + sizeof(pScan->BSSDescriptSize)
+                                 + sizeof(pScan->NumberOfSets)
+                                 + S_DS_GEN);
+
+    pTlv = (MrvlIEtypes_Data_t *) (pScan->BssDescAndTlvBuffer + bytesLeft);
+
+    /* Search the TLV buffer space in the scan response for any valid TLVs */
+    wlan_ret_802_11_scan_get_tlv_ptrs(pTlv, tlvBufSize, &pTsfTlv);
+
+    /*
+     *  Process each scan response returned (pScan->NumberOfSets).  Save
+     *    the information in the newBssEntry and then insert into the
+     *    driver scan table either as an update to an existing entry
+     *    or as an addition at the end of the table
+     */
+    for (idx = 0; idx < pScan->NumberOfSets && bytesLeft; idx++) {
+        /* Zero out the newBssEntry we are about to store info in */
+        memset(&newBssEntry, 0x00, sizeof(newBssEntry));
+
+        /* Process the data fields and IEs returned for this BSS */
+        if ((InterpretBSSDescriptionWithIE(&newBssEntry,
+                                           &pBssInfo,
+                                           &bytesLeft) == WLAN_STATUS_SUCCESS)
+            && CHECK_SSID_IS_VALID(&newBssEntry.Ssid)) {
+
+            PRINTM(INFO, "SCAN_RESP: BSSID = %02x:%02x:%02x:%02x:%02x:%02x\n",
+                   newBssEntry.MacAddress[0], newBssEntry.MacAddress[1],
+                   newBssEntry.MacAddress[2], newBssEntry.MacAddress[3],
+                   newBssEntry.MacAddress[4], newBssEntry.MacAddress[5]);
+
+            /*
+             * Search the scan table for the same bssid
+             */
+            for (bssIdx = 0; bssIdx < numInTable; bssIdx++) {
+                if (memcmp(newBssEntry.MacAddress,
+                           Adapter->ScanTable[bssIdx].MacAddress,
+                           sizeof(newBssEntry.MacAddress)) == 0) {
+                    /*
+                     * If the SSID matches as well, it is a duplicate of
+                     *   this entry.  Keep the bssIdx set to this
+                     *   entry so we replace the old contents in the table
+                     */
+                    if ((newBssEntry.Ssid.SsidLength ==
+                         Adapter->ScanTable[bssIdx].Ssid.SsidLength)
+                        && (memcmp(newBssEntry.Ssid.Ssid,
+                                   Adapter->ScanTable[bssIdx].Ssid.Ssid,
+                                   newBssEntry.Ssid.SsidLength) == 0)) {
+                        PRINTM(INFO, "SCAN_RESP: Duplicate of index: %d\n",
+                               bssIdx);
+                        break;
+                    }
+                }
+            }
+            /*
+             * If the bssIdx is equal to the number of entries in the table,
+             *   the new entry was not a duplicate; append it to the scan
+             *   table
+             */
+            if (bssIdx == numInTable) {
+                /* Range check the bssIdx, keep it limited to the last entry */
+                if (bssIdx == MRVDRV_MAX_BSSID_LIST) {
+                    bssIdx--;
+                } else {
+                    numInTable++;
+                }
+            }
+
+            /*
+             * Save the beacon/probe response returned for later application
+             *   retrieval.  Duplicate beacon/probe responses are updated if
+             *   possible
+             */
+            wlan_ret_802_11_scan_store_beacon(priv,
+                                              bssIdx,
+                                              numInTable, &newBssEntry);
+            /*
+             * If the TSF TLV was appended to the scan results, save
+             *   this entry's TSF value in the networkTSF field.  The
+             *   networkTSF is the firmware's TSF value at the time the
+             *   beacon or probe response was received.
+             */
+            if (pTsfTlv) {
+                memcpy(&tsfVal, &pTsfTlv->tsfTable[idx], sizeof(tsfVal));
+                tsfVal = wlan_le64_to_cpu(tsfVal);
+
+                memcpy(&newBssEntry.networkTSF,
+                       &tsfVal, sizeof(newBssEntry.networkTSF));
+            }
+
+            /* Copy the locally created newBssEntry to the scan table */
+            memcpy(&Adapter->ScanTable[bssIdx],
+                   &newBssEntry, sizeof(Adapter->ScanTable[bssIdx]));
+
+        } else {
+
+            /* Error parsing/interpreting the scan response, skipped */
+            PRINTM(INFO, "SCAN_RESP: "
+                   "InterpretBSSDescriptionWithIE returned ERROR\n");
+        }
+    }
+
+    PRINTM(CMND, "SCAN_RESP: Scanned %2d APs, %d valid, %d total\n",
+           pScan->NumberOfSets, numInTable - Adapter->NumInScanTable,
+           numInTable);
+
+    /* Update the total number of BSSIDs in the scan table */
+    Adapter->NumInScanTable = numInTable;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief scan network with specific ssid
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param req          A pointer to ifreq structure
+ *
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_extscan_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    WLAN_802_11_SSID Ext_Scan_SSID;
+    wlan_ioctl_user_scan_cfg scanCfg;
+    union iwreq_data wrqu;
+
+    ENTER();
+
+    if (copy_from_user(&Ext_Scan_SSID, req->ifr_data, sizeof(Ext_Scan_SSID))) {
+        PRINTM(INFO, "copy of SSID for ext scan from user failed \n");
+        LEAVE();
+        return -EFAULT;
+    }
+#ifdef REASSOCIATION
+    if (OS_ACQ_SEMAPHORE_BLOCK(&Adapter->ReassocSem)) {
+        PRINTM(ERROR, "Acquire semaphore error, wlan_extscan_ioctl\n");
+        return -EBUSY;
+    }
+#endif
+
+    memset(&scanCfg, 0x00, sizeof(scanCfg));
+
+    memcpy(scanCfg.ssidList[0].ssid, Ext_Scan_SSID.Ssid,
+           Ext_Scan_SSID.SsidLength);
+
+    wlan_scan_networks(priv, &scanCfg);
+
+    memset(&wrqu, 0, sizeof(union iwreq_data));
+    wireless_send_event(priv->wlan_dev.netdev, SIOCGIWSCAN, &wrqu, NULL);
+
+#ifdef REASSOCIATION
+    OS_REL_SEMAPHORE(&Adapter->ReassocSem);
+#endif
+
+    if (Adapter->SurpriseRemoved)
+        return WLAN_STATUS_FAILURE;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function sends BG_SCAN query command to firmware.
+ *
+ *  @param priv    A pointer to wlan_private structure
+ *
+ *  @return        WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+sendBgScanQueryCmd(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    /* Clear the previous scan result */
+    memset(Adapter->ScanTable, 0x00,
+           sizeof(BSSDescriptor_t) * MRVDRV_MAX_BSSID_LIST);
+    Adapter->NumInScanTable = 0;
+    Adapter->pBeaconBufEnd = Adapter->beaconBuffer;
+
+    return PrepareAndSendCommand(priv, HostCmd_CMD_802_11_BG_SCAN_QUERY,
+                                 0, 0, 0, NULL);
+}
+
+/**
+ *  @brief Enable/Disable BG Scan
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param enable       TRUE-enable, FALSE-disable
+ *
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_bg_scan_enable(wlan_private * priv, BOOLEAN enable)
+{
+    int ret;
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_BG_SCAN_CONFIG,
+                                0, HostCmd_OPTION_WAITFORRSP, 0, &enable);
+    return ret;
+}
+
+/**
+ *  @brief config BGSCAN parameter
+
+ *  @param priv         A pointer to wlan_private structure
+ *  @param req          A pointer to ifreq structure
+ *
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_do_bg_scan_config_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    u8 action;
+    u8 *buf = NULL;
+    HostCmd_DS_802_11_BG_SCAN_CONFIG *tmp;
+
+    ENTER();
+
+    action = *((u8 *) req->ifr_data + SKIP_CMDNUM + SKIP_SIZE);
+    PRINTM(INFO, "Action = %d\n", action);
+
+    switch (action) {
+    case HostCmd_ACT_GEN_GET:
+        buf = kmalloc(Adapter->bgScanConfigSize + SKIP_TYPE_SIZE, GFP_KERNEL);
+        if (!buf) {
+            PRINTM(MSG, "kmalloc no memory !!\n");
+            return -ENOMEM;
+        }
+        memcpy(buf, &Adapter->bgScanConfigSize, SKIP_SIZE);
+        memcpy(buf + SKIP_TYPE_SIZE, Adapter->bgScanConfig,
+               Adapter->bgScanConfigSize);
+
+        if (copy_to_user(req->ifr_data, buf,
+                         Adapter->bgScanConfigSize + SKIP_TYPE_SIZE)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            kfree(buf);
+            return -EFAULT;
+        }
+
+        kfree(buf);
+
+        break;
+
+    case HostCmd_ACT_GEN_SET:
+        Adapter->bgScanConfigSize = *(u16 *) (req->ifr_data + SKIP_CMDNUM);
+        PRINTM(INFO, "bgscanConfigSize = %d\n", Adapter->bgScanConfigSize);
+
+        if (!(tmp = kmalloc(Adapter->bgScanConfigSize, GFP_KERNEL))) {
+            PRINTM(MSG, "kmalloc no memory !!\n");
+            Adapter->bgScanConfigSize = 0;
+            return -ENOMEM;
+        }
+
+        HEXDUMP("treq", req->ifr_data + SKIP_CMDNUM + SKIP_SIZE,
+                Adapter->bgScanConfigSize);
+
+        if (copy_from_user(tmp, req->ifr_data + SKIP_CMDNUM + SKIP_SIZE,
+                           Adapter->bgScanConfigSize)) {
+            PRINTM(INFO, "Copy from user failed\n");
+            kfree(tmp);
+            return -EFAULT;
+        }
+
+        if (Adapter->bgScanConfig) {
+            tmp->Enable = Adapter->bgScanConfig->Enable;
+            buf = (u8 *) Adapter->bgScanConfig;
+        }
+        Adapter->bgScanConfig = tmp;
+        if (buf)
+            kfree(buf);
+
+        break;
+    }
+
+    LEAVE();
+
+    return ret;
+}
+
+/**
+ *  @brief This function prepares command of bg_scan_config.
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param cmd          A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @param pdata_buf    A pointer to data buffer
+ *
+ *  @return             WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_cmd_802_11_bg_scan_config(wlan_private * priv,
+                               HostCmd_DS_COMMAND * cmd,
+                               int cmd_action, void *pdata_buf)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_BG_SCAN_CONFIG *bgcfg = &cmd->params.bgscancfg;
+    BOOLEAN enable = *((BOOLEAN *) pdata_buf);
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_BG_SCAN_CONFIG);
+    cmd->Size =
+        wlan_cpu_to_le16((priv->adapter->bgScanConfigSize) + S_DS_GEN);
+
+    Adapter->bgScanConfig->Enable = enable;
+
+    memcpy(bgcfg, Adapter->bgScanConfig, Adapter->bgScanConfigSize);
+
+    bgcfg->Action = wlan_cpu_to_le16(bgcfg->Action);
+    bgcfg->ScanInterval = wlan_cpu_to_le32(bgcfg->ScanInterval);
+    bgcfg->StoreCondition = wlan_cpu_to_le32(bgcfg->StoreCondition);
+    bgcfg->ReportConditions = wlan_cpu_to_le32(bgcfg->ReportConditions);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function prepares command of bg_scan_query.
+ *
+ *  @param priv     A pointer to wlan_private structure
+ *  @param cmd      A pointer to HostCmd_DS_COMMAND structure
+ *
+ *  @return         WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_cmd_802_11_bg_scan_query(wlan_private * priv, HostCmd_DS_COMMAND * cmd)
+{
+    HostCmd_DS_802_11_BG_SCAN_QUERY *bgquery = &cmd->params.bgscanquery;
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_BG_SCAN_QUERY);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_BG_SCAN_QUERY) + S_DS_GEN);
+
+    bgquery->Flush = 1;
+
+    return WLAN_STATUS_SUCCESS;
+}
Index: linux-2.6.29/drivers/net/wireless/marvell8686/wlan_scan.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/wlan_scan.h	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,284 @@
+/** @file wlan_scan.h
+ *
+ *  @brief Interface for the wlan network scan routines
+ *
+ *  Driver interface functions and type declarations for the scan module
+ *    implemented in wlan_scan.c.
+ *
+ *  Copyright  Marvell International Ltd. and/or its affiliates, 2003-2006
+ *
+ *  @sa wlan_scan.c
+ */
+/*************************************************************
+Change Log:
+    01/11/06: Initial revision. New scan code, relocate related functions
+
+************************************************************/
+
+#ifndef _WLAN_SCAN_H
+#define _WLAN_SCAN_H
+
+//! Infrastructure BSS scan type in wlan_scan_cmd_config
+#define WLAN_SCAN_BSS_TYPE_BSS         1
+
+//! Adhoc BSS scan type in wlan_scan_cmd_config
+#define WLAN_SCAN_BSS_TYPE_IBSS        2
+
+//! Adhoc or Infrastructure BSS scan type in wlan_scan_cmd_config, no filter
+#define WLAN_SCAN_BSS_TYPE_ANY         3
+
+/** @brief Maximum buffer space for beacons retrieved from scan responses
+ *    4000 has successfully stored up to 40 beacons
+ *    6000 has successfully stored the max scan results (max 64)
+ */
+#define MAX_SCAN_BEACON_BUFFER         6000
+
+/**
+ * @brief Buffer pad space for newly allocated beacons/probe responses
+ *
+ * Beacons are typically 6 bytes longer than an equivalent probe response.
+ *  For each scan response stored, allocate an extra byte pad at the end to
+ *  allow easy expansion to store a beacon in the same memory a probe reponse
+ *  previously contained
+ */
+#define SCAN_BEACON_ENTRY_PAD          6
+
+//! Scan time specified in the channel TLV for each channel for passive scans
+#define MRVDRV_PASSIVE_SCAN_CHAN_TIME  100
+
+//! Scan time specified in the channel TLV for each channel for active scans
+#define MRVDRV_ACTIVE_SCAN_CHAN_TIME   100
+
+//! Scan time specified in the channel TLV for each channel for specific scans
+#define MRVDRV_SPECIFIC_SCAN_CHAN_TIME 100
+
+//! Max passive scan time for each channel in milliseconds
+#define MRVDRV_MAX_PASSIVE_SCAN_CHAN_TIME   2000
+
+//! Max active scan time for each channel in milliseconds 
+#define MRVDRV_MAX_ACTIVE_SCAN_CHAN_TIME    500
+
+/**
+ * Max total scan time in milliseconds
+ * The total scan time should be less than scan command timeout value (10s)
+ */
+#define MRVDRV_MAX_TOTAL_SCAN_TIME     (MRVDRV_TIMER_10S - MRVDRV_TIMER_1S)
+
+/**
+ * @brief Structure used internally in the wlan driver to configure a scan.
+ *
+ * Sent to the command processing module to configure the firmware
+ *   scan command prepared by wlan_cmd_802_11_scan.
+ *
+ * @sa wlan_scan_networks
+ *
+ */
+typedef struct
+{
+    /**
+     *  @brief BSS Type to be sent in the firmware command
+     *
+     *  Field can be used to restrict the types of networks returned in the
+     *    scan.  Valid settings are:
+     *
+     *   - WLAN_SCAN_BSS_TYPE_BSS  (infrastructure)
+     *   - WLAN_SCAN_BSS_TYPE_IBSS (adhoc)
+     *   - WLAN_SCAN_BSS_TYPE_ANY  (unrestricted, adhoc and infrastructure)
+     */
+    u8 bssType;
+
+    /**
+     *  @brief Specific BSSID used to filter scan results in the firmware
+     */
+    u8 specificBSSID[MRVDRV_ETH_ADDR_LEN];
+
+    /**
+     *  @brief Length of TLVs sent in command starting at tlvBuffer
+     */
+    int tlvBufferLen;
+
+    /**
+     *  @brief SSID TLV(s) and ChanList TLVs to be sent in the firmware command
+     *
+     *  @sa TLV_TYPE_CHANLIST, MrvlIEtypes_ChanListParamSet_t
+     *  @sa TLV_TYPE_SSID, MrvlIEtypes_SsIdParamSet_t
+     */
+    u8 tlvBuffer[1];            //!< SSID TLV(s) and ChanList TLVs are stored here
+} wlan_scan_cmd_config;
+
+/**
+ *  @brief Sub-structure passed in wlan_ioctl_get_scan_table_entry for each BSS
+ *
+ *  Fixed field information returned for the scan response in the IOCTL
+ *    response.
+ */
+typedef struct
+{
+    u8 bssid[6];                //!< BSSID of this network
+    u8 channel;                 //!< Channel this beacon/probe response was detected
+    u8 rssi;                    //!< RSSI for the received packet
+    u64 networkTSF;             //!< TSF value from the firmware at packet reception
+} __ATTRIB_PACK__ wlan_ioctl_get_scan_table_fixed;
+
+/**
+ *  @brief Structure passed in the wlan_ioctl_get_scan_table_info for each
+ *         BSS returned in the WLAN_GET_SCAN_RESP IOCTL
+ *
+ *  @sa wlan_get_scan_table_ioctl
+ */
+typedef struct
+{
+
+    /**
+     *  @brief Fixed field length included in the response.
+     *
+     *  Length value is included so future fixed fields can be added to the
+     *   response without breaking backwards compatibility.  Use the length
+     *   to find the offset for the bssInfoLength field, not a sizeof() calc.
+     */
+    u32 fixedFieldLength;
+
+    /**
+     *  @brief Always present, fixed length data fields for the BSS
+     */
+    wlan_ioctl_get_scan_table_fixed fixedFields;
+
+    /**
+     *  @brief Length of the BSS Information (probe resp or beacon) that
+     *         follows starting at bssInfoBuffer
+     */
+    u32 bssInfoLength;
+
+    /**
+     *  @brief Probe response or beacon scanned for the BSS.
+     *
+     *  Field layout:
+     *   - TSF              8 octets
+     *   - Beacon Interval  2 octets
+     *   - Capability Info  2 octets
+     *
+     *   - IEEE Infomation Elements; variable number & length per 802.11 spec
+     */
+    u8 bssInfoBuffer[1];
+} __ATTRIB_PACK__ wlan_ioctl_get_scan_table_entry;
+
+/**
+ *  @brief WLAN_GET_SCAN_RESP private IOCTL struct to retrieve the scan table
+ *
+ *  @sa wlan_get_scan_table_ioctl
+ */
+typedef struct
+{
+
+    /**
+     *  - Zero based scan entry to start retrieval in command request
+     *  - Number of scans entires returned in command response
+     */
+    u32 scanNumber;
+
+     /**
+      * Buffer marker for multiple wlan_ioctl_get_scan_table_entry structures.
+      *   Each struct is padded to the nearest 32 bit boundary.
+      */
+    u8 scan_table_entry_buffer[1];
+
+} __ATTRIB_PACK__ wlan_ioctl_get_scan_table_info;
+
+/**
+ *  @brief Structure used to store information for each beacon/probe response
+ */
+typedef struct
+{
+    WLAN_802_11_MAC_ADDRESS MacAddress;
+
+    WLAN_802_11_SSID Ssid;
+
+    /* WEP encryption requirement */
+    u32 Privacy;
+
+    /* receive signal strength in dBm */
+    WLAN_802_11_RSSI Rssi;
+
+    u32 Channel;
+
+    u16 BeaconPeriod;
+
+    u32 ATIMWindow;
+    u8 ERPFlags;
+
+    WLAN_802_11_NETWORK_TYPE NetworkTypeInUse;
+    WLAN_802_11_NETWORK_INFRASTRUCTURE InfrastructureMode;
+    WLAN_802_11_RATES SupportedRates;
+    IEEEtypes_WmmParameter_t wmmIE;
+
+    int extra_ie;
+
+    u8 TimeStamp[8];            //!< TSF value included in the beacon/probe response
+
+    IEEEtypes_PhyParamSet_t PhyParamSet;
+    IEEEtypes_SsParamSet_t SsParamSet;
+    IEEEtypes_CapInfo_t Cap;
+
+    u8 DataRates[WLAN_SUPPORTED_RATES];
+
+    u64 networkTSF;             //!< TSF timestamp from the current firmware TSF
+
+    IEEEtypes_CountryInfoFullSet_t CountryInfo;
+
+    IEEEtypes_VendorSpecific_t wpaIE;
+    IEEEtypes_Generic_t rsnIE;
+
+    IEEEtypes_VendorSpecific_t wpsIE;
+
+    u8 *pBeaconBuf;             //!< Pointer to the returned scan response
+    uint beaconBufSize;         //!< Length of the stored scan response
+    uint beaconBufSizeMax;      //!< Max allocated size for updated scan response
+
+} BSSDescriptor_t;
+
+extern int SSIDcmp(WLAN_802_11_SSID * ssid1, WLAN_802_11_SSID * ssid2);
+extern int FindSSIDInList(wlan_adapter * Adapter, WLAN_802_11_SSID * ssid,
+                          u8 * bssid, int mode);
+extern int FindBestSSIDInList(wlan_adapter * Adapter);
+extern int FindBSSIDInList(wlan_adapter * Adapter, u8 * bssid, int mode);
+
+extern int FindBestNetworkSsid(wlan_private * priv, WLAN_802_11_SSID * pSSID);
+
+extern int SendSpecificSSIDScan(wlan_private * priv,
+                                WLAN_802_11_SSID * pRequestedSSID);
+extern int SendSpecificBSSIDScan(wlan_private * priv, u8 * bssid);
+
+extern int wlan_get_scan_table_ioctl(wlan_private * priv, struct iwreq *wrq);
+extern int wlan_set_user_scan_ioctl(wlan_private * priv, struct iwreq *wrq);
+
+extern int wlan_associate(wlan_private * priv, BSSDescriptor_t * pBSSDesc);
+
+extern int wlan_cmd_802_11_scan(wlan_private * priv,
+                                HostCmd_DS_COMMAND * cmd, void *pdata_buf);
+
+extern void wlan_scan_update_tsf_timestamps(wlan_private * priv,
+                                            BSSDescriptor_t * pNewBssDesc);
+
+extern int wlan_ret_802_11_scan(wlan_private * priv,
+                                HostCmd_DS_COMMAND * resp);
+
+extern int wlan_extscan_ioctl(wlan_private * priv, struct ifreq *req);
+
+extern int sendBgScanQueryCmd(wlan_private * priv);
+extern int wlan_bg_scan_enable(wlan_private * priv, BOOLEAN enable);
+extern int wlan_do_bg_scan_config_ioctl(wlan_private * priv,
+                                        struct ifreq *req);
+extern int wlan_cmd_802_11_bg_scan_config(wlan_private * priv,
+                                          HostCmd_DS_COMMAND * cmd,
+                                          int cmd_action, void *pdata_buf);
+extern int wlan_cmd_802_11_bg_scan_query(wlan_private * priv,
+                                         HostCmd_DS_COMMAND * cmd);
+
+#ifdef __KERNEL__
+extern int wlan_get_scan(struct net_device *dev, struct iw_request_info *info,
+                         struct iw_point *dwrq, char *extra);
+extern int wlan_set_scan(struct net_device *dev, struct iw_request_info *info,
+                         struct iw_param *vwrq, char *extra);
+#endif
+
+#endif /* _WLAN_SCAN_H */
Index: linux-2.6.29/drivers/net/wireless/marvell8686/wlan_thread.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/wlan_thread.h	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,58 @@
+/*
+ * Copyright  Marvell International Ltd. and/or its affiliates, 2003-2006
+ */
+
+#ifndef	__WLAN_THREAD_H_
+#define	__WLAN_THREAD_H_
+
+#include	<linux/kthread.h>
+
+typedef struct
+{
+    struct task_struct *task;
+    wait_queue_head_t waitQ;
+    pid_t pid;
+    void *priv;
+} wlan_thread;
+
+static inline void
+wlan_activate_thread(wlan_thread * thr)
+{
+        /** Record the thread pid */
+    thr->pid = current->pid;
+
+        /** Initialize the wait queue */
+    init_waitqueue_head(&thr->waitQ);
+}
+
+static inline void
+wlan_deactivate_thread(wlan_thread * thr)
+{
+    ENTER();
+
+    LEAVE();
+}
+
+static inline void
+wlan_create_thread(int (*wlanfunc) (void *), wlan_thread * thr, char *name)
+{
+    thr->task = kthread_run(wlanfunc, thr, "%s", name);
+}
+
+static inline int
+wlan_terminate_thread(wlan_thread * thr)
+{
+    ENTER();
+
+    /* Check if the thread is active or not */
+    if (!thr->pid) {
+        PRINTM(INFO, "Thread does not exist\n");
+        return -1;
+    }
+    kthread_stop(thr->task);
+
+    LEAVE();
+    return 0;
+}
+
+#endif
Index: linux-2.6.29/drivers/net/wireless/marvell8686/wlan_tx.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/wlan_tx.c	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,286 @@
+/** @file wlan_tx.c
+  * @brief This file contains the handling of TX in wlan
+  * driver.
+  * 
+  *  Copyright  Marvell International Ltd. and/or its affiliates, 2003-2006
+  */
+/********************************************************
+Change log:
+	09/28/05: Add Doxygen format comments
+	12/13/05: Add Proprietary periodic sleep support
+	01/05/06: Add kernel 2.6.x support	
+	04/06/06: Add TSPEC, queue metrics, and MSDU expiry support
+********************************************************/
+
+#include	"include.h"
+
+/********************************************************
+		Local Variables
+********************************************************/
+
+/********************************************************
+		Global Variables
+********************************************************/
+
+/********************************************************
+		Local Functions
+********************************************************/
+
+/** 
+ *  @brief This function processes a single packet and sends
+ *  to IF layer
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param skb     A pointer to skb which includes TX packet
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+SendSinglePacket(wlan_private * priv, struct sk_buff *skb)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    TxPD LocalTxPD;
+    TxPD *pLocalTxPD = &LocalTxPD;
+    u8 *ptr = Adapter->TmpTxBuf;
+
+    ENTER();
+
+    if (!skb->len || (skb->len > MRVDRV_ETH_TX_PACKET_BUFFER_SIZE)) {
+        PRINTM(ERROR, "Tx Error: Bad skb length %d : %d\n",
+               skb->len, MRVDRV_ETH_TX_PACKET_BUFFER_SIZE);
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    memset(pLocalTxPD, 0, sizeof(TxPD));
+
+    pLocalTxPD->TxPacketLength = skb->len;
+
+    if (Adapter->wmm.enabled) {
+        /* 
+         * original skb->priority has been overwritten 
+         * by wmm_map_and_add_skb()
+         */
+        pLocalTxPD->Priority = (u8) skb->priority;
+
+        pLocalTxPD->PktDelay_2ms = wmm_compute_driver_packet_delay(skb);
+    }
+
+    if (pLocalTxPD->Priority < NELEMENTS(Adapter->wmm.userPriPktTxCtrl)) {
+        /* 
+         * Set the priority specific TxControl field, setting of 0 will
+         *   cause the default value to be used later in this function
+         */
+        pLocalTxPD->TxControl
+            = Adapter->wmm.userPriPktTxCtrl[pLocalTxPD->Priority];
+    }
+
+    if (Adapter->PSState != PS_STATE_FULL_POWER) {
+        if (TRUE == CheckLastPacketIndication(priv)) {
+            Adapter->TxLockFlag = TRUE;
+            pLocalTxPD->Flags = MRVDRV_TxPD_POWER_MGMT_LAST_PACKET;
+        }
+    }
+
+    /* offset of actual data */
+    pLocalTxPD->TxPacketLocation = sizeof(TxPD);
+
+    if (pLocalTxPD->TxControl == 0) {
+        /* TxCtrl set by user or default */
+        pLocalTxPD->TxControl = Adapter->PktTxCtrl;
+    }
+
+    endian_convert_TxPD(pLocalTxPD);
+
+    memcpy((u8 *) pLocalTxPD->TxDestAddr, skb->data, MRVDRV_ETH_ADDR_LEN);
+
+    ptr += SDIO_HEADER_LEN;
+    memcpy(ptr, pLocalTxPD, sizeof(TxPD));
+
+    ptr += sizeof(TxPD);
+
+    memcpy(ptr, skb->data, skb->len);
+
+    ret = sbi_host_to_card(priv, MVMS_DAT, Adapter->TmpTxBuf,
+                           skb->len + sizeof(TxPD));
+    if (ret) {
+        PRINTM(ERROR,
+               "SendSinglePacket Error: sbi_host_to_card failed: 0x%X\n",
+               ret);
+        Adapter->dbg.num_tx_host_to_card_failure++;
+        goto done;
+    }
+
+    PRINTM(DATA, "Data => FW\n");
+    DBG_HEXDUMP(DAT_D, "Tx", ptr - sizeof(TxPD),
+                MIN(skb->len + sizeof(TxPD), MAX_DATA_DUMP_LEN));
+
+    wmm_process_fw_iface_tx_xfer_start(priv);
+
+  done:
+    if (!ret) {
+        priv->stats.tx_packets++;
+        priv->stats.tx_bytes += skb->len;
+    } else {
+        priv->stats.tx_dropped++;
+        priv->stats.tx_errors++;
+    }
+
+    /* need to be freed in all cases */
+    os_free_tx_packet(priv);
+
+    LEAVE();
+    return ret;
+}
+
+/********************************************************
+		Global functions
+********************************************************/
+
+/** 
+ *  @brief This function checks the conditions and sends packet to IF
+ *  layer if everything is ok.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   n/a
+ */
+void
+wlan_process_tx(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    OS_INTERRUPT_SAVE_AREA;
+
+    if (priv->wlan_dev.dnld_sent) {
+        PRINTM(MSG, "TX Error: dnld_sent = %d, not sending\n",
+               priv->wlan_dev.dnld_sent);
+        goto done;
+    }
+
+    SendSinglePacket(priv, Adapter->CurrentTxSkb);
+    OS_INT_DISABLE;
+    priv->adapter->HisRegCpy &= ~HIS_TxDnLdRdy;
+    OS_INT_RESTORE;
+
+  done:
+    LEAVE();
+}
+
+/** 
+ *  @brief This function queues the packet received from
+ *  kernel/upper layer and wake up the main thread to handle it.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+  * @param skb     A pointer to skb which includes TX packet
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_tx_packet(wlan_private * priv, struct sk_buff *skb)
+{
+    ulong flags;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    HEXDUMP("TX Data", skb->data, MIN(skb->len, 100));
+
+    spin_lock_irqsave(&Adapter->CurrentTxLock, flags);
+
+    wmm_map_and_add_skb(priv, skb);
+    wake_up_interruptible(&priv->MainThread.waitQ);
+    spin_unlock_irqrestore(&Adapter->CurrentTxLock, flags);
+
+    LEAVE();
+
+    return ret;
+}
+
+/** 
+ *  @brief This function tells firmware to send a NULL data packet.
+ *  
+ *  @param priv     A pointer to wlan_private structure
+ *  @param flags    Trasnit Pkt Flags
+ *  @return 	    n/a
+ */
+int
+SendNullPacket(wlan_private * priv, u8 flags)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    TxPD txpd = { 0 };
+    int ret = WLAN_STATUS_SUCCESS;
+    u8 *ptr = Adapter->TmpTxBuf;
+
+    ENTER();
+
+    if (Adapter->SurpriseRemoved == TRUE) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateDisconnected) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    memset(&txpd, 0, sizeof(TxPD));
+
+    txpd.TxControl = Adapter->PktTxCtrl;
+    txpd.Flags = flags;
+    txpd.Priority = WMM_HIGHEST_PRIORITY;
+    txpd.TxPacketLocation = sizeof(TxPD);
+
+    endian_convert_TxPD(&txpd);
+
+    ptr += SDIO_HEADER_LEN;
+    memcpy(ptr, &txpd, sizeof(TxPD));
+
+    ret = sbi_host_to_card(priv, MVMS_DAT, Adapter->TmpTxBuf, sizeof(TxPD));
+
+    if (ret != 0) {
+        PRINTM(ERROR, "TX Error: SendNullPacket failed!\n");
+        Adapter->dbg.num_tx_host_to_card_failure++;
+        goto done;
+    }
+    PRINTM(DATA, "Null data => FW\n");
+    DBG_HEXDUMP(DAT_D, "Tx", ptr, sizeof(TxPD));
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function check if we need send last packet indication.
+ *  
+ *  @param priv     A pointer to wlan_private structure
+ *
+ *  @return 	   TRUE or FALSE
+ */
+BOOLEAN
+CheckLastPacketIndication(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    BOOLEAN ret = FALSE;
+    BOOLEAN prop_ps = TRUE;
+
+    ENTER();
+
+    if (Adapter->sleep_period.period == 0 || Adapter->gen_null_pkg == FALSE     /* for UPSD certification tests */
+        ) {
+        LEAVE();
+        return ret;
+    }
+
+    if (wmm_lists_empty(priv)) {
+        if (((Adapter->CurBssParams.wmm_uapsd_enabled == TRUE)
+             && (Adapter->wmm.qosinfo != 0)) || prop_ps) {
+            ret = TRUE;
+        }
+    }
+
+    LEAVE();
+    return ret;
+}
Index: linux-2.6.29/drivers/net/wireless/marvell8686/wlan_types.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/wlan_types.h	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,1050 @@
+/** @file wlan_types.h
+ *  @brief This header file contains definition for global types
+ *
+ *  Copyright  Marvell International Ltd. and/or its affiliates, 2003-2007
+ */
+/*************************************************************
+Change log:
+	10/11/05: add Doxygen format comments 
+	01/11/06: Add IEEE Association response type. Add TSF TLV information.
+	01/31/06: Add support to selectively enabe the FW Scan channel filter
+	04/10/06: Add power_adapt_cfg_ext command
+	04/18/06: Remove old Subscrive Event and add new Subscribe Event
+	          implementation through generic hostcmd API
+	05/03/06: Add auto_tx hostcmd
+	08/28/06: Add LED_CTRL hostcmd
+************************************************************/
+
+#ifndef _WLAN_TYPES_
+#define _WLAN_TYPES_
+
+#ifndef __KERNEL__
+typedef char s8;
+typedef unsigned char u8;
+
+typedef signed short s16;
+typedef unsigned short u16;
+
+typedef signed long s32;
+typedef unsigned long u32;
+
+typedef signed long long s64;
+typedef unsigned long long u64;
+
+typedef u32 dma_addr_t;
+typedef u32 dma64_addr_t;
+/* Dma addresses are 32-bits wide.  */
+#ifndef __ATTRIB_ALIGN__
+#define __ATTRIB_ALIGN__ __attribute__((aligned(4)))
+#endif
+
+#ifndef __ATTRIB_PACK__
+#define __ATTRIB_PACK__ __attribute__ ((packed))
+#endif
+#endif
+
+typedef long LONG;
+typedef unsigned long long ULONGLONG;
+typedef u32 WLAN_OID;
+
+#define MRVDRV_MAX_MULTICAST_LIST_SIZE	32
+#define MRVDRV_MAX_CHANNEL_SIZE		14
+#define MRVDRV_ETH_ADDR_LEN             6
+#define MRVDRV_MAX_SSID_LENGTH			32
+#define MRVDRV_MAX_BSS_DESCRIPTS		16
+/** WEP list macros & data structures */
+#define MRVL_KEY_BUFFER_SIZE_IN_BYTE  16
+#define MRVL_MAX_KEY_WPA_KEY_LENGTH     32
+
+#define HOSTCMD_SUPPORTED_RATES G_SUPPORTED_RATES
+
+#define	BAND_B			(0x01)
+#define	BAND_G			(0x02)
+#define ALL_802_11_BANDS	(BAND_B | BAND_G)
+
+#define B_SUPPORTED_RATES		8
+#define G_SUPPORTED_RATES		14
+
+#define	WLAN_SUPPORTED_RATES		14
+#define WLAN_MAX_SSID_LENGTH		32
+
+#define	MAX_POWER_ADAPT_GROUP		5
+
+#define MRVDRV_MAX_SSID_LIST_LENGTH     10
+
+typedef u8 WLAN_802_11_RATES[WLAN_SUPPORTED_RATES];
+typedef u8 WLAN_802_11_MAC_ADDRESS[ETH_ALEN];
+
+/** WLAN_802_11_NETWORK_TYPE */
+typedef enum _WLAN_802_11_NETWORK_TYPE
+{
+    Wlan802_11FH,
+    Wlan802_11DS,
+    /*defined as upper bound */
+    Wlan802_11NetworkTypeMax
+} WLAN_802_11_NETWORK_TYPE, *PWLAN_802_11_NETWORK_TYPE;
+
+/** WLAN_802_11_NETWORK_INFRASTRUCTURE */
+typedef enum _WLAN_802_11_NETWORK_INFRASTRUCTURE
+{
+    Wlan802_11IBSS,
+    Wlan802_11Infrastructure,
+    Wlan802_11AutoUnknown,
+    /*defined as upper bound */
+    Wlan802_11InfrastructureMax
+} WLAN_802_11_NETWORK_INFRASTRUCTURE, *PWLAN_802_11_NETWORK_INFRASTRUCTURE;
+
+#define IEEE_MAX_IE_SIZE  256
+
+/** IEEE Type definitions  */
+typedef enum _IEEEtypes_ElementId_e
+{
+    SSID = 0,
+    SUPPORTED_RATES = 1,
+    FH_PARAM_SET = 2,
+    DS_PARAM_SET = 3,
+    CF_PARAM_SET = 4,
+
+    IBSS_PARAM_SET = 6,
+
+    COUNTRY_INFO = 7,
+
+    ERP_INFO = 42,
+    EXTENDED_SUPPORTED_RATES = 50,
+
+    VENDOR_SPECIFIC_221 = 221,
+    WMM_IE = VENDOR_SPECIFIC_221,
+
+    WPS_IE = VENDOR_SPECIFIC_221,
+
+    WPA_IE = VENDOR_SPECIFIC_221,
+    RSN_IE = 48,
+
+    EXTRA_IE = 133,
+} __ATTRIB_PACK__ IEEEtypes_ElementId_e;
+
+#define CAPINFO_MASK    (~( W_BIT_15 | W_BIT_14 |               \
+                            W_BIT_12 | W_BIT_11 | W_BIT_9) )
+
+typedef struct _IEEEtypes_CapInfo_t
+{
+    u8 Ess:1;
+    u8 Ibss:1;
+    u8 CfPollable:1;
+    u8 CfPollRqst:1;
+    u8 Privacy:1;
+    u8 ShortPreamble:1;
+    u8 Pbcc:1;
+    u8 ChanAgility:1;
+    u8 SpectrumMgmt:1;
+    u8 Rsrvd3:1;
+    u8 ShortSlotTime:1;
+    u8 Apsd:1;
+    u8 Rsvrd2:1;
+    u8 DSSSOFDM:1;
+    u8 Rsrvd1:2;
+} __ATTRIB_PACK__ IEEEtypes_CapInfo_t;
+
+typedef struct
+{
+    u8 ElementId;
+    u8 Len;
+} __ATTRIB_PACK__ IEEEtypes_Header_t;
+
+/** IEEEtypes_CfParamSet_t */
+typedef struct _IEEEtypes_CfParamSet_t
+{
+    u8 ElementId;
+    u8 Len;
+    u8 CfpCnt;
+    u8 CfpPeriod;
+    u16 CfpMaxDuration;
+    u16 CfpDurationRemaining;
+} __ATTRIB_PACK__ IEEEtypes_CfParamSet_t;
+
+typedef struct IEEEtypes_IbssParamSet_t
+{
+    u8 ElementId;
+    u8 Len;
+    u16 AtimWindow;
+} __ATTRIB_PACK__ IEEEtypes_IbssParamSet_t;
+
+/** IEEEtypes_SsParamSet_t */
+typedef union _IEEEtypes_SsParamSet_t
+{
+    IEEEtypes_CfParamSet_t CfParamSet;
+    IEEEtypes_IbssParamSet_t IbssParamSet;
+} __ATTRIB_PACK__ IEEEtypes_SsParamSet_t;
+
+/** IEEEtypes_FhParamSet_t */
+typedef struct _IEEEtypes_FhParamSet_t
+{
+    u8 ElementId;
+    u8 Len;
+    u16 DwellTime;
+    u8 HopSet;
+    u8 HopPattern;
+    u8 HopIndex;
+} __ATTRIB_PACK__ IEEEtypes_FhParamSet_t;
+
+typedef struct _IEEEtypes_DsParamSet_t
+{
+    u8 ElementId;
+    u8 Len;
+    u8 CurrentChan;
+} __ATTRIB_PACK__ IEEEtypes_DsParamSet_t;
+
+/** IEEEtypes_DsParamSet_t */
+typedef union IEEEtypes_PhyParamSet_t
+{
+    IEEEtypes_FhParamSet_t FhParamSet;
+    IEEEtypes_DsParamSet_t DsParamSet;
+} __ATTRIB_PACK__ IEEEtypes_PhyParamSet_t;
+
+typedef struct _IEEEtypes_ERPInfo_t
+{
+    u8 ElementId;
+    u8 Len;
+    u8 ERPFlags;
+} __ATTRIB_PACK__ IEEEtypes_ERPInfo_t;
+
+typedef u16 IEEEtypes_AId_t;
+typedef u16 IEEEtypes_StatusCode_t;
+
+typedef struct
+{
+    IEEEtypes_CapInfo_t Capability;
+    IEEEtypes_StatusCode_t StatusCode;
+    IEEEtypes_AId_t AId;
+    u8 IEBuffer[1];
+} __ATTRIB_PACK__ IEEEtypes_AssocRsp_t;
+
+typedef struct
+{
+    u8 ElementId;
+    u8 Len;
+    u8 Oui[3];
+    u8 OuiType;
+    u8 OuiSubtype;
+    u8 Version;
+} __ATTRIB_PACK__ IEEEtypes_VendorHeader_t;
+
+typedef struct
+{
+    IEEEtypes_VendorHeader_t VendHdr;
+
+    /* IE Max - size of previous fields */
+    u8 Data[IEEE_MAX_IE_SIZE - sizeof(IEEEtypes_VendorHeader_t)];
+
+}
+__ATTRIB_PACK__ IEEEtypes_VendorSpecific_t;
+
+typedef struct
+{
+    IEEEtypes_Header_t IeeeHdr;
+
+    /* IE Max - size of previous fields */
+    u8 Data[IEEE_MAX_IE_SIZE - sizeof(IEEEtypes_Header_t)];
+
+}
+__ATTRIB_PACK__ IEEEtypes_Generic_t;
+
+/** TLV  type ID definition */
+#define PROPRIETARY_TLV_BASE_ID		0x0100
+
+/* Terminating TLV Type */
+#define MRVL_TERMINATE_TLV_ID		0xffff
+
+#define TLV_TYPE_SSID				0x0000
+#define TLV_TYPE_RATES				0x0001
+#define TLV_TYPE_PHY_FH				0x0002
+#define TLV_TYPE_PHY_DS				0x0003
+#define TLV_TYPE_CF				    0x0004
+#define TLV_TYPE_IBSS				0x0006
+
+#define TLV_TYPE_DOMAIN				0x0007
+
+#define TLV_TYPE_POWER_CAPABILITY   0x0021
+
+#define TLV_TYPE_KEY_MATERIAL       (PROPRIETARY_TLV_BASE_ID + 0)
+#define TLV_TYPE_CHANLIST           (PROPRIETARY_TLV_BASE_ID + 1)
+#define TLV_TYPE_NUMPROBES          (PROPRIETARY_TLV_BASE_ID + 2)
+#define TLV_TYPE_RSSI_LOW           (PROPRIETARY_TLV_BASE_ID + 4)
+#define TLV_TYPE_SNR_LOW            (PROPRIETARY_TLV_BASE_ID + 5)
+#define TLV_TYPE_FAILCOUNT          (PROPRIETARY_TLV_BASE_ID + 6)
+#define TLV_TYPE_BCNMISS            (PROPRIETARY_TLV_BASE_ID + 7)
+#define TLV_TYPE_LED_GPIO           (PROPRIETARY_TLV_BASE_ID + 8)
+#define TLV_TYPE_LEDBEHAVIOR        (PROPRIETARY_TLV_BASE_ID + 9)
+#define TLV_TYPE_PASSTHROUGH        (PROPRIETARY_TLV_BASE_ID + 10)
+#define TLV_TYPE_POWER_TBL_2_4GHZ   (PROPRIETARY_TLV_BASE_ID + 12)
+#define TLV_TYPE_POWER_TBL_5GHZ     (PROPRIETARY_TLV_BASE_ID + 13)
+#define TLV_TYPE_WMMQSTATUS         (PROPRIETARY_TLV_BASE_ID + 16)
+#define TLV_TYPE_WILDCARDSSID       (PROPRIETARY_TLV_BASE_ID + 18)
+#define TLV_TYPE_TSFTIMESTAMP       (PROPRIETARY_TLV_BASE_ID + 19)
+#define TLV_TYPE_POWERADAPTCFGEXT   (PROPRIETARY_TLV_BASE_ID + 20)
+#define TLV_TYPE_RSSI_HIGH          (PROPRIETARY_TLV_BASE_ID + 22)
+#define TLV_TYPE_SNR_HIGH           (PROPRIETARY_TLV_BASE_ID + 23)
+#define TLV_TYPE_AUTO_TX            (PROPRIETARY_TLV_BASE_ID + 24)
+#define TLV_TYPE_WPS_ENROLLEE_PROBE_REQ_TLV    (PROPRIETARY_TLV_BASE_ID + 27)
+#define TLV_TYPE_STARTBGSCANLATER   (PROPRIETARY_TLV_BASE_ID + 30)
+#define TLV_TYPE_AUTH_TYPE          (PROPRIETARY_TLV_BASE_ID + 31)
+#define TLV_TYPE_PRE_BEACON_LOST    (PROPRIETARY_TLV_BASE_ID + 73)
+
+/** TLV related data structures*/
+/** MrvlIEtypesHeader_t */
+typedef struct _MrvlIEtypesHeader
+{
+    u16 Type;
+    u16 Len;
+} __ATTRIB_PACK__ MrvlIEtypesHeader_t;
+
+/** MrvlIEtypes_Data_t */
+typedef struct _MrvlIEtypes_Data_t
+{
+    MrvlIEtypesHeader_t Header;
+    u8 Data[1];
+} __ATTRIB_PACK__ MrvlIEtypes_Data_t;
+
+/** MrvlIEtypes_RatesParamSet_t */
+typedef struct _MrvlIEtypes_RatesParamSet_t
+{
+    MrvlIEtypesHeader_t Header;
+    u8 Rates[1];
+} __ATTRIB_PACK__ MrvlIEtypes_RatesParamSet_t;
+
+/** MrvlIEtypes_SsIdParamSet_t */
+typedef struct _MrvlIEtypes_SsIdParamSet_t
+{
+    MrvlIEtypesHeader_t Header;
+    u8 SsId[1];
+} __ATTRIB_PACK__ MrvlIEtypes_SsIdParamSet_t;
+
+/** MrvlIEtypes_WildCardSsIdParamSet_t */
+typedef struct _MrvlIEtypes_WildCardSsIdParamSet_t
+{
+    MrvlIEtypesHeader_t Header;
+    u8 MaxSsidLength;
+    u8 SsId[1];
+} __ATTRIB_PACK__ MrvlIEtypes_WildCardSsIdParamSet_t;
+
+/** ChanScanMode_t */
+typedef struct
+{
+    u8 PassiveScan:1;
+    u8 DisableChanFilt:1;
+    u8 Reserved_2_7:6;
+} __ATTRIB_PACK__ ChanScanMode_t;
+
+/** ChanScanParamSet_t */
+typedef struct _ChanScanParamSet_t
+{
+    u8 RadioType;
+    u8 ChanNumber;
+    ChanScanMode_t ChanScanMode;
+    u16 MinScanTime;
+    u16 MaxScanTime;
+} __ATTRIB_PACK__ ChanScanParamSet_t;
+
+/** MrvlIEtypes_ChanListParamSet_t */
+typedef struct _MrvlIEtypes_ChanListParamSet_t
+{
+    MrvlIEtypesHeader_t Header;
+    ChanScanParamSet_t ChanScanParam[1];
+} __ATTRIB_PACK__ MrvlIEtypes_ChanListParamSet_t;
+
+/** CfParamSet_t */
+typedef struct _CfParamSet_t
+{
+    u8 CfpCnt;
+    u8 CfpPeriod;
+    u16 CfpMaxDuration;
+    u16 CfpDurationRemaining;
+} __ATTRIB_PACK__ CfParamSet_t;
+
+/** IbssParamSet_t */
+typedef struct _IbssParamSet_t
+{
+    u16 AtimWindow;
+} __ATTRIB_PACK__ IbssParamSet_t;
+
+/** MrvlIEtypes_SsParamSet_t */
+typedef struct _MrvlIEtypes_SsParamSet_t
+{
+    MrvlIEtypesHeader_t Header;
+    union
+    {
+        CfParamSet_t CfParamSet[1];
+        IbssParamSet_t IbssParamSet[1];
+    } cf_ibss;
+} __ATTRIB_PACK__ MrvlIEtypes_SsParamSet_t;
+
+/** FhParamSet_t */
+typedef struct _FhParamSet_t
+{
+    u16 DwellTime;
+    u8 HopSet;
+    u8 HopPattern;
+    u8 HopIndex;
+} __ATTRIB_PACK__ FhParamSet_t;
+
+/** DsParamSet_t */
+typedef struct _DsParamSet_t
+{
+    u8 CurrentChan;
+} __ATTRIB_PACK__ DsParamSet_t;
+
+/** MrvlIEtypes_PhyParamSet_t */
+typedef struct _MrvlIEtypes_PhyParamSet_t
+{
+    MrvlIEtypesHeader_t Header;
+    union
+    {
+        FhParamSet_t FhParamSet[1];
+        DsParamSet_t DsParamSet[1];
+    } fh_ds;
+} __ATTRIB_PACK__ MrvlIEtypes_PhyParamSet_t;
+
+/** MrvlIEtypes_RsnParamSet_t */
+typedef struct _MrvlIEtypes_RsnParamSet_t
+{
+    MrvlIEtypesHeader_t Header;
+    u8 RsnIE[1];
+} __ATTRIB_PACK__ MrvlIEtypes_RsnParamSet_t;
+
+/** MrvlIEtypes_WmmParamSet_t */
+typedef struct _MrvlIEtypes_WmmParamSet_t
+{
+    MrvlIEtypesHeader_t Header;
+    u8 WmmIE[1];
+} __ATTRIB_PACK__ MrvlIEtypes_WmmParamSet_t;
+
+typedef struct
+{
+    MrvlIEtypesHeader_t Header;
+    u8 QueueIndex;
+    u8 Disabled;
+    u8 Reserved1;
+    u8 Reserved2;
+    u8 FlowRequired;
+    u8 FlowCreated;
+    u32 Reserved3;
+} __ATTRIB_PACK__ MrvlIEtypes_WmmQueueStatus_t;
+
+/** Table of TSF values returned in the scan result */
+typedef struct
+{
+    MrvlIEtypesHeader_t Header;
+    u64 tsfTable[1];
+} __ATTRIB_PACK__ MrvlIEtypes_TsfTimestamp_t;
+
+/**  Local Power Capability */
+typedef struct _MrvlIEtypes_PowerCapability_t
+{
+    MrvlIEtypesHeader_t Header;
+    s8 MinPower;
+    s8 MaxPower;
+} __ATTRIB_PACK__ MrvlIEtypes_PowerCapability_t;
+
+/** MrvlIEtypes_RssiParamSet_t */
+typedef struct _MrvlIEtypes_RssiThreshold_t
+{
+    MrvlIEtypesHeader_t Header;
+    u8 RSSIValue;
+    u8 RSSIFreq;
+} __ATTRIB_PACK__ MrvlIEtypes_RssiThreshold_t;
+
+/** MrvlIEtypes_SnrThreshold_t */
+typedef struct _MrvlIEtypes_SnrThreshold_t
+{
+    MrvlIEtypesHeader_t Header;
+    u8 SNRValue;
+    u8 SNRFreq;
+} __ATTRIB_PACK__ MrvlIEtypes_SnrThreshold_t;
+
+/** MrvlIEtypes_PreBeaconLost_t */
+typedef struct _MrvlIEtypes_PreBeaconLost_t
+{
+    MrvlIEtypesHeader_t Header;
+    u8 PreBeaconLost;
+    u8 Reserved;
+} __ATTRIB_PACK__ MrvlIEtypes_PreBeaconLost_t;
+
+/** MrvlIEtypes_FailureCount_t */
+typedef struct _MrvlIEtypes_FailureCount_t
+{
+    MrvlIEtypesHeader_t Header;
+    u8 FailValue;
+    u8 FailFreq;
+} __ATTRIB_PACK__ MrvlIEtypes_FailureCount_t;
+
+/** MrvlIEtypes_BeaconsMissed_t */
+typedef struct _MrvlIEtypes_BeaconsMissed_t
+{
+    MrvlIEtypesHeader_t Header;
+    u8 BeaconMissed;
+    u8 Reserved;
+} __ATTRIB_PACK__ MrvlIEtypes_BeaconsMissed_t;
+
+/** MrvlIEtypes_NumProbes_t */
+typedef struct _MrvlIEtypes_NumProbes_t
+{
+    MrvlIEtypesHeader_t Header;
+    u16 NumProbes;
+} __ATTRIB_PACK__ MrvlIEtypes_NumProbes_t;
+
+/** MrvlIEtypes_StartBGScanLater_t */
+typedef struct _MrvlIEtypes_StartBGScanLater_t
+{
+    MrvlIEtypesHeader_t Header;
+    u16 StartLater;
+} __ATTRIB_PACK__ MrvlIEtypes_StartBGScanLater_t;
+
+typedef struct _LedGpio_t
+{
+    u8 LedNum;                  /* LED # mapped to GPIO pin # below */
+    u8 GpioNum;                 /* GPIO pin # used to control LED # above */
+} __ATTRIB_PACK__ LedGpio_t;
+
+/** MrvlIEtypes_LedGpio_t */
+typedef struct _MrvlIEtypes_LedGpio_t
+{
+    MrvlIEtypesHeader_t Header;
+    LedGpio_t LedGpio[1];
+} __ATTRIB_PACK__ MrvlIEtypes_LedGpio_t;
+
+/** MrvlIEtypes_LedBehavior_t */
+typedef struct _MrvlIEtypes_LedBehavior_t
+{
+    MrvlIEtypesHeader_t Header;
+    u8 FirmwareState;           /* Firmware State */
+    u8 LedNum;                  /* LED # */
+    u8 LedState;                /* LED State corresponding to Firmware State */
+    u8 LedArgs;                 /* Arguments for LED State */
+} __ATTRIB_PACK__ MrvlIEtypes_LedBehavior_t;
+
+typedef struct _PA_Group_t
+{
+    u16 PowerAdaptLevel;
+    u16 RateBitmap;
+    u32 Reserved;
+} __ATTRIB_PACK__ PA_Group_t;
+
+/** MrvlIEtypes_PA_Group_t */
+typedef struct _MrvlIEtypes_PowerAdapt_Group_t
+{
+    MrvlIEtypesHeader_t Header;
+    PA_Group_t PA_Group[MAX_POWER_ADAPT_GROUP];
+} __ATTRIB_PACK__ MrvlIEtypes_PowerAdapt_Group_t;
+
+typedef struct _AutoTx_MacFrame_t
+{
+    u16 Interval;               /* in seconds */
+    u8 Priority;                /* User Priority: 0~7, ignored if non-WMM */
+    u8 Reserved;                /* set to 0 */
+    u16 FrameLen;               /* Length of MAC frame payload */
+    u8 DestMacAddr[ETH_ALEN];
+    u8 SrcMacAddr[ETH_ALEN];
+    u8 Payload[];
+} __ATTRIB_PACK__ AutoTx_MacFrame_t;
+
+/** MrvlIEtypes_AutoTx_t */
+typedef struct _MrvlIEtypes_AutoTx_t
+{
+    MrvlIEtypesHeader_t Header;
+    AutoTx_MacFrame_t AutoTx_MacFrame;
+} __ATTRIB_PACK__ MrvlIEtypes_AutoTx_t;
+
+typedef struct
+{
+    u8 value;
+    u8 Freq;
+} Threshold;
+
+typedef struct
+{
+    u16 EventsBitmap;           /* bit 0: RSSI low,  bit 1: SNR low,
+                                 * bit 2: RSSI high, bit 3: SNR high
+                                 */
+    Threshold Rssi_low;
+    Threshold Snr_low;
+    Threshold Rssi_high;
+    Threshold Snr_high;
+    u8 Rssi_low_count;
+    u8 Snr_low_count;
+    u8 Rssi_high_count;
+    u8 Snr_high_count;
+} wlan_subscribe_event;
+
+/** Auth type to be used in the Authentication portion of an Assoc seq */
+typedef struct
+{
+    MrvlIEtypesHeader_t Header;
+    u16 AuthType;
+} __ATTRIB_PACK__ MrvlIEtypes_AuthType_t;
+
+#define MRVDRV_MAX_SUBBAND_802_11D		83
+#define COUNTRY_CODE_LEN			3
+
+/** Data structure for Country IE*/
+typedef struct _IEEEtypes_SubbandSet
+{
+    u8 FirstChan;
+    u8 NoOfChan;
+    u8 MaxTxPwr;
+} __ATTRIB_PACK__ IEEEtypes_SubbandSet_t;
+
+typedef struct _IEEEtypes_CountryInfoSet
+{
+    u8 ElementId;
+    u8 Len;
+    u8 CountryCode[COUNTRY_CODE_LEN];
+    IEEEtypes_SubbandSet_t Subband[1];
+} __ATTRIB_PACK__ IEEEtypes_CountryInfoSet_t;
+
+typedef struct _IEEEtypes_CountryInfoFullSet
+{
+    u8 ElementId;
+    u8 Len;
+    u8 CountryCode[COUNTRY_CODE_LEN];
+    IEEEtypes_SubbandSet_t Subband[MRVDRV_MAX_SUBBAND_802_11D];
+} __ATTRIB_PACK__ IEEEtypes_CountryInfoFullSet_t;
+
+typedef struct _MrvlIEtypes_DomainParamSet
+{
+    MrvlIEtypesHeader_t Header;
+    u8 CountryCode[COUNTRY_CODE_LEN];
+    IEEEtypes_SubbandSet_t Subband[1];
+} __ATTRIB_PACK__ MrvlIEtypes_DomainParamSet_t;
+
+/** Size of a TSPEC.  Used to allocate necessary buffer space in commands */
+#define WMM_TSPEC_SIZE              63
+
+/** Extra IE bytes allocated in messages for appended IEs after a TSPEC */
+#define WMM_ADDTS_EXTRA_IE_BYTES    256
+
+/** Extra TLV bytes allocated in messages for configuring WMM Queues */
+#define WMM_QUEUE_CONFIG_EXTRA_TLV_BYTES 64
+/** Maximum number of AC QOS queues available in the driver/firmware */
+#define MAX_AC_QUEUES 4
+
+/** enum of WMM AC_QUEUES */
+typedef enum
+{
+    WMM_AC_BK,
+    WMM_AC_BE,
+    WMM_AC_VI,
+    WMM_AC_VO,
+} __ATTRIB_PACK__ wlan_wmm_ac_e;
+
+/** data structure of WMM QoS information */
+typedef struct
+{
+    u8 ParaSetCount:4;
+    u8 Reserved:3;
+    u8 QosUAPSD:1;
+} __ATTRIB_PACK__ IEEEtypes_WmmQosInfo_t;
+
+typedef struct
+{
+    u8 Aifsn:4;
+    u8 Acm:1;
+    u8 Aci:2;
+    u8 Reserved:1;
+} __ATTRIB_PACK__ IEEEtypes_WmmAciAifsn_t;
+
+/**  data structure of WMM ECW */
+typedef struct
+{
+    u8 EcwMin:4;
+    u8 EcwMax:4;
+} __ATTRIB_PACK__ IEEEtypes_WmmEcw_t;
+
+/** data structure of WMM AC parameters  */
+typedef struct
+{
+    IEEEtypes_WmmAciAifsn_t AciAifsn;
+    IEEEtypes_WmmEcw_t Ecw;
+    u16 TxopLimit;
+} __ATTRIB_PACK__ IEEEtypes_WmmAcParameters_t;
+
+/** data structure of WMM Info IE  */
+typedef struct
+{
+
+    /**
+     * WMM Info IE - Vendor Specific Header:
+     *   ElementId   [221/0xdd]
+     *   Len         [7] 
+     *   Oui         [00:50:f2]
+     *   OuiType     [2]
+     *   OuiSubType  [0]
+     *   Version     [1]
+     */
+    IEEEtypes_VendorHeader_t VendHdr;
+
+    IEEEtypes_WmmQosInfo_t QoSInfo;
+
+} __ATTRIB_PACK__ IEEEtypes_WmmInfo_t;
+
+/** data structure of WMM parameter IE  */
+typedef struct
+{
+    /**
+     * WMM Parameter IE - Vendor Specific Header:
+     *   ElementId   [221/0xdd]
+     *   Len         [24] 
+     *   Oui         [00:50:f2]
+     *   OuiType     [2]
+     *   OuiSubType  [1]
+     *   Version     [1]
+     */
+    IEEEtypes_VendorHeader_t VendHdr;
+
+    IEEEtypes_WmmQosInfo_t QoSInfo;
+    u8 Reserved;
+
+    /** AC Parameters Record WMM_AC_BE, WMM_AC_BK, WMM_AC_VI, WMM_AC_VO */
+    IEEEtypes_WmmAcParameters_t AcParams[MAX_AC_QUEUES];
+
+} __ATTRIB_PACK__ IEEEtypes_WmmParameter_t;
+
+/**
+ *  @brief Firmware command structure to retrieve the firmware WMM status.
+ *
+ *  Used to retrieve the status of each WMM AC Queue in TLV 
+ *    format (MrvlIEtypes_WmmQueueStatus_t) as well as the current WMM
+ *    parameter IE advertised by the AP.  
+ *  
+ *  Used in response to a MACREG_INT_CODE_WMM_STATUS_CHANGE event signalling
+ *    a QOS change on one of the ACs or a change in the WMM Parameter in
+ *    the Beacon.
+ *
+ *  TLV based command, byte arrays used for max sizing purpose. There are no 
+ *    arguments sent in the command, the TLVs are returned by the firmware.
+ */
+typedef struct
+{
+    u8 queueStatusTlv[sizeof(MrvlIEtypes_WmmQueueStatus_t) * MAX_AC_QUEUES];
+    u8 wmmParamTlv[sizeof(IEEEtypes_WmmParameter_t) + 2];
+
+}
+__ATTRIB_PACK__ HostCmd_DS_WMM_GET_STATUS;
+
+/**
+ *  @brief Enumeration for the command result from an ADDTS or DELTS command 
+ */
+typedef enum
+{
+    TSPEC_RESULT_SUCCESS = 0,
+    TSPEC_RESULT_EXEC_FAILURE = 1,
+    TSPEC_RESULT_TIMEOUT = 2,
+    TSPEC_RESULT_DATA_INVALID = 3,
+
+} __ATTRIB_PACK__ wlan_wmm_tspec_result_e;
+
+/**
+ *  @brief IOCTL structure to send an ADDTS request and retrieve the response.
+ *
+ *  IOCTL structure from the application layer relayed to firmware to 
+ *    instigate an ADDTS management frame with an appropriate TSPEC IE as well
+ *    as any additional IEs appended in the ADDTS Action frame.
+ *
+ *  @sa wlan_wmm_addts_req_ioctl
+ */
+typedef struct
+{
+    wlan_wmm_tspec_result_e commandResult;
+    u32 timeout_ms;
+
+    u8 ieeeStatusCode;
+
+    u8 tspecData[WMM_TSPEC_SIZE];
+
+    u8 addtsExtraIEBuf[WMM_ADDTS_EXTRA_IE_BYTES];
+
+} __ATTRIB_PACK__ wlan_ioctl_wmm_addts_req_t;
+
+/**
+ *  @brief IOCTL structure to send a DELTS request.
+ *
+ *  IOCTL structure from the application layer relayed to firmware to 
+ *    instigate an DELTS management frame with an appropriate TSPEC IE.
+ *
+ *  @sa wlan_wmm_delts_req_ioctl
+ */
+typedef struct
+{
+    wlan_wmm_tspec_result_e commandResult;      //!< Firmware execution result
+
+    u8 ieeeReasonCode;          //!< IEEE reason code sent, unused for WMM 
+
+    u8 tspecData[WMM_TSPEC_SIZE];       //!< TSPEC to send in the DELTS
+
+} __ATTRIB_PACK__ wlan_ioctl_wmm_delts_req_t;
+
+/**
+ *  @brief Internal command structure used in executing an ADDTS command.
+ *
+ *  Relay information between the IOCTL layer and the firmware command and 
+ *    command response procedures.
+ *
+ *  @sa wlan_wmm_addts_req_ioctl
+ *  @sa wlan_cmd_wmm_addts_req
+ *  @sa wlan_cmdresp_wmm_addts_req
+ */
+typedef struct
+{
+    wlan_wmm_tspec_result_e commandResult;
+    u32 timeout_ms;
+
+    u8 dialogToken;
+    u8 ieeeStatusCode;
+
+    int tspecDataLen;
+    u8 tspecData[WMM_TSPEC_SIZE];
+    u8 addtsExtraIEBuf[WMM_ADDTS_EXTRA_IE_BYTES];
+
+} wlan_cmd_wmm_addts_req_t;
+
+/**
+ *  @brief Internal command structure used in executing an DELTS command.
+ *
+ *  Relay information between the IOCTL layer and the firmware command and 
+ *    command response procedures.
+ *
+ *  @sa wlan_wmm_delts_req_ioctl
+ *  @sa wlan_cmd_wmm_delts_req
+ *  @sa wlan_cmdresp_wmm_delts_req
+ */
+typedef struct
+{
+    wlan_wmm_tspec_result_e commandResult;
+
+    u8 dialogToken;
+
+    u8 ieeeReasonCode;
+
+    int tspecDataLen;
+    u8 tspecData[WMM_TSPEC_SIZE];
+
+} wlan_cmd_wmm_delts_req_t;
+
+/**
+ *  @brief Command structure for the HostCmd_CMD_WMM_ADDTS_REQ firmware command
+ *
+ */
+typedef struct
+{
+    wlan_wmm_tspec_result_e commandResult;
+    u32 timeout_ms;
+
+    u8 dialogToken;
+    u8 ieeeStatusCode;
+    u8 tspecData[WMM_TSPEC_SIZE];
+    u8 addtsExtraIEBuf[WMM_ADDTS_EXTRA_IE_BYTES];
+
+} __ATTRIB_PACK__ HostCmd_DS_WMM_ADDTS_REQ;
+
+/**
+ *  @brief Command structure for the HostCmd_CMD_WMM_DELTS_REQ firmware command
+ */
+typedef struct
+{
+    wlan_wmm_tspec_result_e commandResult;
+    u8 dialogToken;
+    u8 ieeeReasonCode;
+    u8 tspecData[WMM_TSPEC_SIZE];
+
+} __ATTRIB_PACK__ HostCmd_DS_WMM_DELTS_REQ;
+
+/**
+ *  @brief Enumeration for the action field in the Queue configure command
+ */
+typedef enum
+{
+    WMM_QUEUE_CONFIG_ACTION_GET = 0,
+    WMM_QUEUE_CONFIG_ACTION_SET = 1,
+    WMM_QUEUE_CONFIG_ACTION_DEFAULT = 2,
+
+    WMM_QUEUE_CONFIG_ACTION_MAX
+} __ATTRIB_PACK__ wlan_wmm_queue_config_action_e;
+
+/**
+ *  @brief Command structure for the HostCmd_CMD_WMM_QUEUE_CONFIG firmware cmd
+ *
+ *  Set/Get/Default the Queue parameters for a specific AC in the firmware.
+ *
+ */
+typedef struct
+{
+    wlan_wmm_queue_config_action_e action;      //!< Set, Get, or Default
+    wlan_wmm_ac_e accessCategory;       //!< WMM_AC_BK(0) to WMM_AC_VO(3)
+
+    /** @brief MSDU lifetime expiry per 802.11e
+     *
+     *   - Ignored if 0 on a set command 
+     *   - Set to the 802.11e specified 500 TUs when defaulted
+     */
+    u16 msduLifetimeExpiry;
+
+    u8 tlvBuffer[WMM_QUEUE_CONFIG_EXTRA_TLV_BYTES];     //!< Not supported yet
+
+} __ATTRIB_PACK__ HostCmd_DS_WMM_QUEUE_CONFIG;
+
+/**
+ *  @brief Internal command structure used in executing a queue config command.
+ *
+ *  Relay information between the IOCTL layer and the firmware command and 
+ *    command response procedures.
+ *
+ *  @sa wlan_wmm_queue_config_ioctl
+ *  @sa wlan_cmd_wmm_queue_config
+ *  @sa wlan_cmdresp_wmm_queue_config
+ */
+typedef struct
+{
+    wlan_wmm_queue_config_action_e action;      //!< Set, Get, or Default
+    wlan_wmm_ac_e accessCategory;       //!< WMM_AC_BK(0) to WMM_AC_VO(3)
+    u16 msduLifetimeExpiry;     //!< lifetime expiry in TUs
+
+    int tlvBufLen;              //!< Not supported yet
+    u8 tlvBuffer[WMM_QUEUE_CONFIG_EXTRA_TLV_BYTES];     //!< Not supported yet
+
+} wlan_cmd_wmm_queue_config_t;
+
+/**
+ *  @brief IOCTL structure to configure a specific AC Queue's parameters
+ *
+ *  IOCTL structure from the application layer relayed to firmware to 
+ *    get, set, or default the WMM AC queue parameters.
+ *
+ *  - msduLifetimeExpiry is ignored if set to 0 on a set command
+ *
+ *  @sa wlan_wmm_queue_config_ioctl
+ */
+typedef struct
+{
+    wlan_wmm_queue_config_action_e action;      //!< Set, Get, or Default
+    wlan_wmm_ac_e accessCategory;       //!< WMM_AC_BK(0) to WMM_AC_VO(3)
+    u16 msduLifetimeExpiry;     //!< lifetime expiry in TUs
+
+    u8 supportedRates[10];      //!< Not supported yet
+
+} __ATTRIB_PACK__ wlan_ioctl_wmm_queue_config_t;
+
+/**
+ *   @brief Enumeration for the action field in the queue stats command
+ */
+typedef enum
+{
+    WMM_STATS_ACTION_START = 0,
+    WMM_STATS_ACTION_STOP = 1,
+    WMM_STATS_ACTION_GET_CLR = 2,
+    WMM_STATS_ACTION_SET_CFG = 3,       /* Not currently used */
+    WMM_STATS_ACTION_GET_CFG = 4,       /* Not currently used */
+
+    WMM_STATS_ACTION_MAX
+} __ATTRIB_PACK__ wlan_wmm_stats_action_e;
+
+/** Number of bins in the histogram for the HostCmd_DS_WMM_QUEUE_STATS */
+#define WMM_STATS_PKTS_HIST_BINS  7
+
+/**
+ *  @brief Command structure for the HostCmd_CMD_WMM_QUEUE_STATS firmware cmd
+ *
+ *  Turn statistical collection on/off for a given AC or retrieve the 
+ *    accumulated stats for an AC and clear them in the firmware.
+ */
+typedef struct
+{
+    wlan_wmm_stats_action_e action;     //!< Start, Stop, or Get 
+    wlan_wmm_ac_e accessCategory;       //!< WMM_AC_BK(0) to WMM_AC_VO(3)
+
+    u16 pktCount;               //!< Number of successful packets transmitted
+    u16 pktLoss;                //!< Packets lost; not included in pktCount
+    u32 avgQueueDelay;          //!< Average Queue delay in microseconds
+    u32 avgTxDelay;             //!< Average Transmission delay in microseconds
+    u32 usedTime;               //!< Calculated medium time - Not currently used
+
+    /** @brief Queue Delay Histogram; number of packets per queue delay range
+     * 
+     *  [0] -  0ms <= delay < 5ms
+     *  [1] -  5ms <= delay < 10ms
+     *  [2] - 10ms <= delay < 20ms
+     *  [3] - 20ms <= delay < 30ms
+     *  [4] - 30ms <= delay < 40ms
+     *  [5] - 40ms <= delay < 50ms
+     *  [6] - 50ms <= delay < msduLifetime (TUs)
+     */
+    u16 delayHistogram[WMM_STATS_PKTS_HIST_BINS];
+
+    u16 reserved_u16_1;
+
+} __ATTRIB_PACK__ HostCmd_DS_WMM_QUEUE_STATS;
+
+/**
+ *  @brief IOCTL structure to start, stop, and get statistics for a WMM AC
+ *
+ *  IOCTL structure from the application layer relayed to firmware to 
+ *    start or stop statistical collection for a given AC.  Also used to 
+ *    retrieve and clear the collected stats on a given AC.
+ *
+ *  @sa wlan_wmm_queue_stats_ioctl
+ */
+typedef struct
+{
+    wlan_wmm_stats_action_e action;     //!< Start, Stop, or Get 
+    wlan_wmm_ac_e accessCategory;       //!< WMM_AC_BK(0) to WMM_AC_VO(3)
+    u16 pktCount;               //!< Number of successful packets transmitted  
+    u16 pktLoss;                //!< Packets lost; not included in pktCount    
+    u32 avgQueueDelay;          //!< Average Queue delay in microseconds
+    u32 avgTxDelay;             //!< Average Transmission delay in microseconds
+    u32 usedTime;               //!< Calculated medium time 
+
+    /** @brief Queue Delay Histogram; number of packets per queue delay range
+     * 
+     *  [0] -  0ms <= delay < 5ms
+     *  [1] -  5ms <= delay < 10ms
+     *  [2] - 10ms <= delay < 20ms
+     *  [3] - 20ms <= delay < 30ms
+     *  [4] - 30ms <= delay < 40ms
+     *  [5] - 40ms <= delay < 50ms
+     *  [6] - 50ms <= delay < msduLifetime (TUs)
+     */
+    u16 delayHistogram[WMM_STATS_PKTS_HIST_BINS];
+} __ATTRIB_PACK__ wlan_ioctl_wmm_queue_stats_t;
+
+/** 
+ *  @brief IOCTL sub structure for a specific WMM AC Status
+ */
+typedef struct
+{
+    u8 wmmAcm;
+    u8 flowRequired;
+    u8 flowCreated;
+    u8 disabled;
+} __ATTRIB_PACK__ wlan_ioctl_wmm_queue_status_ac_t;
+
+/**
+ *  @brief IOCTL structure to retrieve the WMM AC Queue status
+ *
+ *  IOCTL structure from the application layer to retrieve:
+ *     - ACM bit setting for the AC
+ *     - Firmware status (flow required, flow created, flow disabled)
+ *
+ *  @sa wlan_wmm_queue_status_ioctl
+ */
+typedef struct
+{
+    wlan_ioctl_wmm_queue_status_ac_t acStatus[MAX_AC_QUEUES];
+} __ATTRIB_PACK__ wlan_ioctl_wmm_queue_status_t;
+
+/** Firmware status for a specific AC */
+typedef struct
+{
+    u8 Disabled;
+    u8 FlowRequired;
+    u8 FlowCreated;
+} WmmAcStatus_t;
+
+#endif /* _WLAN_TYPES_ */
Index: linux-2.6.29/drivers/net/wireless/marvell8686/wlan_version.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/wlan_version.h	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,18 @@
+/** @file wlan_version.h
+  * @brief This file contains wlan driver version number.
+  * 
+  *  Copyright  Marvell International Ltd. and/or its affiliates, 2003-2006
+  */
+/********************************************************
+Change log:
+	10/04/05: Add Doxygen format comments
+	
+********************************************************/
+#include "release_version.h"
+
+const char driver_version[] =
+    "sd8686-%s-" DRIVER_RELEASE_VERSION "-(" "FP" "4" ")"
+#ifdef	DEBUG_LEVEL2
+    "-dbg"
+#endif
+    " ";
Index: linux-2.6.29/drivers/net/wireless/marvell8686/wlan_wext.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/wlan_wext.c	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,8047 @@
+/** @file  wlan_wext.c 
+  * @brief This file contains ioctl functions
+  * 
+  *  Copyright ?Marvell International Ltd. and/or its affiliates, 2003-2007
+  */
+/********************************************************
+Change log:
+	10/10/05: Add Doxygen format comments
+	12/23/05: Modify FindBSSIDInList to search entire table for
+	          duplicate BSSIDs when earlier matches are not compatible
+	12/26/05: Remove errant memcpy in wlanidle_off; overwriting stack space
+	01/05/06: Add kernel 2.6.x support	
+	01/11/06: Conditionalize new scan/join functions.
+	          Update statics/externs.  Move forward decl. from wlan_decl.h
+	04/06/06: Add TSPEC, queue metrics, and MSDU expiry support
+	04/10/06: Add hostcmd generic API
+	04/18/06: Remove old Subscrive Event and add new Subscribe Event
+	          implementation through generic hostcmd API
+	05/04/06: Add IBSS coalescing related new iwpriv command
+	08/29/06: Add ledgpio private command
+	10/23/06: Validate setbcnavg/setdataavg command parameters and
+	          return error if out of range
+********************************************************/
+
+#include	"include.h"
+
+#include	"wlan_version.h"
+
+#define GETLOG_BUFSIZE  512
+
+#define MAX_SCAN_CELL_SIZE      (IW_EV_ADDR_LEN + \
+				MRVDRV_MAX_SSID_LENGTH + \
+				IW_EV_UINT_LEN + IW_EV_FREQ_LEN + \
+				IW_EV_QUAL_LEN + MRVDRV_MAX_SSID_LENGTH + \
+				IW_EV_PARAM_LEN + 40)   /* 40 for WPAIE */
+
+typedef struct _ioctl_cmd
+{
+    int cmd;
+    int subcmd;
+    BOOLEAN fixsize;
+} ioctl_cmd;
+
+static ioctl_cmd Commands_Allowed_In_DeepSleep[] = {
+    {.cmd = WLANDEEPSLEEP,.subcmd = 0,.fixsize = FALSE},
+    {.cmd = WLAN_SETONEINT_GETWORDCHAR,.subcmd = WLANVERSION,.fixsize =
+     FALSE},
+    {.cmd = WLAN_SETINT_GETINT,.subcmd = WLANSDIOCLOCK,.fixsize = TRUE},
+    {.cmd = WLAN_SET_GET_2K,.subcmd = WLAN_GET_CFP_TABLE,.fixsize = FALSE},
+#ifdef DEBUG_LEVEL1
+    {.cmd = WLAN_SET_GET_SIXTEEN_INT,.subcmd = WLAN_DRV_DBG,.fixsize = FALSE},
+#endif
+};
+
+static ioctl_cmd Commands_Allowed_In_HostSleep[] = {
+    {.cmd = WLAN_SETONEINT_GETWORDCHAR,.subcmd = WLANVERSION,.fixsize =
+     FALSE},
+    {.cmd = WLANDEEPSLEEP,.subcmd = 1,.fixsize = FALSE},
+    {.cmd = WLANDEEPSLEEP,.subcmd = 0,.fixsize = FALSE},
+    {.cmd = WLAN_SETINT_GETINT,.subcmd = WLANSDIOCLOCK,.fixsize = TRUE},
+    {.cmd = WLAN_SET_GET_2K,.subcmd = WLAN_GET_CFP_TABLE,.fixsize = FALSE},
+#ifdef DEBUG_LEVEL1
+    {.cmd = WLAN_SET_GET_SIXTEEN_INT,.subcmd = WLAN_DRV_DBG,.fixsize = FALSE},
+#endif
+};
+
+/********************************************************
+		Local Variables
+********************************************************/
+
+/********************************************************
+		Global Variables
+********************************************************/
+#ifdef DEBUG_LEVEL1
+#ifdef DEBUG_LEVEL2
+#define	DEFAULT_DEBUG_MASK	(0xffffffff & ~DBG_EVENT)
+#else
+#define DEFAULT_DEBUG_MASK	(DBG_MSG | DBG_FATAL | DBG_ERROR)
+#endif
+u32 drvdbg = DEFAULT_DEBUG_MASK;
+u32 ifdbg = 0;
+#endif
+
+/********************************************************
+		Local Functions
+********************************************************/
+static int wlan_set_rate(struct net_device *dev, struct iw_request_info *info,
+                         struct iw_param *vwrq, char *extra);
+static int wlan_get_rate(struct net_device *dev, struct iw_request_info *info,
+                         struct iw_param *vwrq, char *extra);
+
+static int wlan_get_essid(struct net_device *dev,
+                          struct iw_request_info *info, struct iw_point *dwrq,
+                          char *extra);
+
+static int wlan_set_freq(struct net_device *dev, struct iw_request_info *info,
+                         struct iw_freq *fwrq, char *extra);
+static int wlan_get_freq(struct net_device *dev, struct iw_request_info *info,
+                         struct iw_freq *fwrq, char *extra);
+
+static int wlan_set_mode(struct net_device *dev, struct iw_request_info *info,
+                         u32 * uwrq, char *extra);
+static int wlan_get_mode(struct net_device *dev, struct iw_request_info *info,
+                         u32 * uwrq, char *extra);
+
+static int wlan_set_encode(struct net_device *dev,
+                           struct iw_request_info *info,
+                           struct iw_point *dwrq, char *extra);
+static int wlan_get_encode(struct net_device *dev,
+                           struct iw_request_info *info,
+                           struct iw_point *dwrq, u8 * extra);
+
+static int wlan_set_txpow(struct net_device *dev,
+                          struct iw_request_info *info, struct iw_param *vwrq,
+                          char *extra);
+static int wlan_get_txpow(struct net_device *dev,
+                          struct iw_request_info *info, struct iw_param *vwrq,
+                          char *extra);
+
+static int wlan_set_coalescing_ioctl(wlan_private * priv, struct iwreq *wrq);
+
+extern CHANNEL_FREQ_POWER *wlan_get_region_cfp_table(u8 region, u8 band,
+                                                     int *cfp_no);
+
+/** 
+ *  @brief This function checks if the commans is allowed
+ *  in deepsleep/hostsleep mode or not.
+ * 
+ *  @param req	       A pointer to ifreq structure 
+ *  @param cmd         the command ID
+ *  @return 	   TRUE or FALSE
+ */
+static BOOLEAN
+Is_Command_Allowed_In_Sleep(struct ifreq *req, int cmd,
+                            ioctl_cmd * allowed_cmds, int count)
+{
+    int subcmd = 0;
+    struct iwreq *wrq = (struct iwreq *) req;
+    int i;
+
+    for (i = 0; i < count; i++) {
+        if (cmd == allowed_cmds[i].cmd) {
+            if (allowed_cmds[i].subcmd == 0)
+                return TRUE;
+            if (allowed_cmds[i].fixsize == TRUE)
+                subcmd = (int) req->ifr_data;
+            else
+                subcmd = wrq->u.data.flags;
+            if (allowed_cmds[i].subcmd == subcmd)
+                return TRUE;
+        }
+    }
+    return FALSE;
+}
+
+/** 
+ *  @brief This function checks if the command is allowed.
+ * 
+ *  @param priv		A pointer to wlan_private structure
+ *  @return		TRUE or FALSE
+ */
+BOOLEAN
+Is_Command_Allowed(wlan_private * priv)
+{
+    BOOLEAN ret = TRUE;
+
+    if (priv->adapter->bHostSleepConfigured) {
+        PRINTM(INFO, "IOCTLS called when WLAN access is blocked\n");
+        ret = FALSE;
+    }
+    if (!priv->adapter->IsAutoDeepSleepEnabled) {
+        if ((priv->adapter->IsDeepSleep == TRUE)) {
+            PRINTM(INFO, "IOCTLS called when station is in DeepSleep\n");
+            ret = FALSE;
+        }
+    }
+
+    return ret;
+}
+
+/** 
+ *  @brief Find a character in a string.
+ *   
+ *  @param s	   A pointer to string
+ *  @param c	   Character to be located 
+ *  @param dlen    the length of string
+ *  @return 	   A pointer to the first occurrence of c in string, or NULL if c is not found.
+ */
+static void *
+wlan_memchr(void *s, int c, int n)
+{
+    const u8 *p = s;
+
+    while (n-- != 0) {
+        if ((u8) c == *p++) {
+            return (void *) (p - 1);
+        }
+    }
+    return NULL;
+}
+
+#if WIRELESS_EXT > 14
+/** 
+ *  @brief Convert mw value to dbm value
+ *   
+ *  @param mw	   the value of mw
+ *  @return 	   the value of dbm
+ */
+static int
+mw_to_dbm(int mw)
+{
+    if (mw < 2)
+        return 0;
+    else if (mw < 3)
+        return 3;
+    else if (mw < 4)
+        return 5;
+    else if (mw < 6)
+        return 7;
+    else if (mw < 7)
+        return 8;
+    else if (mw < 8)
+        return 9;
+    else if (mw < 10)
+        return 10;
+    else if (mw < 13)
+        return 11;
+    else if (mw < 16)
+        return 12;
+    else if (mw < 20)
+        return 13;
+    else if (mw < 25)
+        return 14;
+    else if (mw < 32)
+        return 15;
+    else if (mw < 40)
+        return 16;
+    else if (mw < 50)
+        return 17;
+    else if (mw < 63)
+        return 18;
+    else if (mw < 79)
+        return 19;
+    else if (mw < 100)
+        return 20;
+    else
+        return 21;
+}
+
+/** 
+ *  @brief This function sends customized event to application.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @para str	   A pointer to event string
+ *  @return 	   n/a
+ */
+void
+send_iwevcustom_event(wlan_private * priv, s8 * str)
+{
+    union iwreq_data iwrq;
+    u8 buf[50];
+
+    ENTER();
+
+    memset(&iwrq, 0, sizeof(union iwreq_data));
+    memset(buf, 0, sizeof(buf));
+
+    snprintf(buf, sizeof(buf) - 1, "%s", str);
+
+    iwrq.data.pointer = buf;
+    iwrq.data.length = strlen(buf) + 1 + IW_EV_LCP_LEN;
+
+    /* Send Event to upper layer */
+    wireless_send_event(priv->wlan_dev.netdev, IWEVCUSTOM, &iwrq, buf);
+    PRINTM(INFO, "Wireless event %s is sent to app\n", str);
+
+    LEAVE();
+    return;
+}
+#endif
+
+/** 
+ *  @brief Find the channel frequency power info with specific channel
+ *   
+ *  @param adapter 	A pointer to wlan_adapter structure
+ *  @param band		it can be BAND_A, BAND_G or BAND_B
+ *  @param channel      the channel for looking	
+ *  @return 	   	A pointer to CHANNEL_FREQ_POWER structure or NULL if not find.
+ */
+CHANNEL_FREQ_POWER *
+find_cfp_by_band_and_channel(wlan_adapter * adapter, u8 band, u16 channel)
+{
+    CHANNEL_FREQ_POWER *cfp = NULL;
+
+    ENTER();
+
+    if (adapter->State11D.Enable11D == ENABLE_11D)
+        cfp =
+            get_cfp_by_band_and_channel(band, channel,
+                                        adapter->universal_channel);
+    else
+        cfp =
+            get_cfp_by_band_and_channel(band, channel,
+                                        adapter->region_channel);
+
+    return cfp;
+}
+
+/** 
+ *  @brief Find the channel frequency power info with specific frequency
+ *   
+ *  @param adapter  A pointer to wlan_adapter structure
+ *  @param band     it can be BAND_A, BAND_G or BAND_B
+ *  @param freq     the frequency for looking   
+ *  @return         Pointer to CHANNEL_FREQ_POWER structure; NULL if not found
+ */
+static CHANNEL_FREQ_POWER *
+find_cfp_by_band_and_freq(wlan_adapter * adapter, u8 band, u32 freq)
+{
+    CHANNEL_FREQ_POWER *cfp = NULL;
+    REGION_CHANNEL *rc;
+    int count = sizeof(adapter->region_channel) /
+        sizeof(adapter->region_channel[0]);
+    int i, j;
+
+    for (j = 0; !cfp && (j < count); j++) {
+        rc = &adapter->region_channel[j];
+
+        if (adapter->State11D.Enable11D == ENABLE_11D) {
+            rc = &adapter->universal_channel[j];
+        }
+
+        if (!rc->Valid || !rc->CFP)
+            continue;
+        if (rc->Band != band)
+            continue;
+        for (i = 0; i < rc->NrCFP; i++) {
+            if (rc->CFP[i].Freq == freq) {
+                cfp = &rc->CFP[i];
+                break;
+            }
+        }
+    }
+
+    if (!cfp && freq)
+        PRINTM(INFO, "find_cfp_by_band_and_freql(): cannot find cfp by "
+               "band %d & freq %d\n", band, freq);
+
+    return cfp;
+}
+
+#ifdef MFG_CMD_SUPPORT
+/** 
+ *  @brief Manufacturing command ioctl function
+ *   
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wrq 		A pointer to iwreq structure
+ *  @return    		WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int
+wlan_mfg_command(wlan_private * priv, struct iwreq *wrq)
+{
+    HostCmd_DS_GEN *pCmdPtr;
+    u8 *mfg_cmd;
+    u16 mfg_cmd_len;
+    int ret;
+
+    ENTER();
+
+    /* allocate MFG command buffer */
+    if (!(mfg_cmd = kmalloc(MRVDRV_SIZE_OF_CMD_BUFFER, GFP_KERNEL))) {
+        PRINTM(INFO, "allocate MFG command buffer failed!\n");
+        return -ENOMEM;
+    }
+
+    /* get MFG command header */
+    if (copy_from_user(mfg_cmd, wrq->u.data.pointer, sizeof(HostCmd_DS_GEN))) {
+        PRINTM(INFO, "copy from user failed: MFG command header\n");
+        ret = -EFAULT;
+        goto mfg_exit;
+    }
+
+    /* get the command size */
+    pCmdPtr = (HostCmd_DS_GEN *) mfg_cmd;
+    mfg_cmd_len = pCmdPtr->Size;
+    PRINTM(INFO, "MFG command len = %d\n", mfg_cmd_len);
+
+    if (mfg_cmd_len > MRVDRV_SIZE_OF_CMD_BUFFER) {
+        ret = -EINVAL;
+        goto mfg_exit;
+    }
+
+    /* get the whole command from user */
+    if (copy_from_user(mfg_cmd, wrq->u.data.pointer, mfg_cmd_len)) {
+        PRINTM(INFO, "copy from user failed: MFG command\n");
+        ret = -EFAULT;
+        goto mfg_exit;
+    }
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_MFG_COMMAND,
+                                0, HostCmd_OPTION_WAITFORRSP, 0, mfg_cmd);
+
+    /* copy the response back to user */
+    if (!ret && pCmdPtr->Size) {
+        mfg_cmd_len = MIN(pCmdPtr->Size, mfg_cmd_len);
+        if (copy_to_user(wrq->u.data.pointer, mfg_cmd, mfg_cmd_len)) {
+            PRINTM(INFO, "copy to user failed: MFG command\n");
+            ret = -EFAULT;
+        }
+        wrq->u.data.length = mfg_cmd_len;
+    }
+
+  mfg_exit:
+    kfree(mfg_cmd);
+    LEAVE();
+    return ret;
+}
+#endif
+
+/** 
+ *  @brief Check if Rate Auto
+ *   
+ *  @param priv 		A pointer to wlan_private structure
+ *  @return 	   		TRUE/FALSE
+ */
+BOOLEAN
+Is_Rate_Auto(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int i;
+    int ratenum = 0;
+    int bitsize = 0;
+    bitsize = sizeof(Adapter->RateBitmap) * 8;
+    for (i = 0; i < bitsize; i++) {
+        if (Adapter->RateBitmap & (1 << i))
+            ratenum++;
+        if (ratenum > 1)
+            break;
+    }
+    if (ratenum > 1)
+        return TRUE;
+    else
+        return FALSE;
+}
+
+/** 
+ *  @brief Covert Rate Bitmap to Rate index
+ *   
+ *  @param priv 		A pointer to wlan_private structure
+ *  @return 	   		TRUE/FALSE
+ */
+int
+GetRateIndex(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int bitsize = sizeof(Adapter->RateBitmap) * 8;
+    int i;
+    for (i = 0; i < bitsize; i++) {
+        if (Adapter->RateBitmap & (1 << i))
+            return i;
+    }
+    return 0;
+}
+
+/** 
+ *  @brief Update Current Channel 
+ *   
+ *  @param priv 		A pointer to wlan_private structure
+ *  @return 	   		WLAN_STATUS_SUCCESS--success, WLAN_STATUS_FAILURE--fail
+ */
+static int
+UpdateCurrentChannel(wlan_private * priv)
+{
+    int ret;
+
+    /*
+     ** the channel in f/w could be out of sync, get the current channel
+     */
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_RF_CHANNEL,
+                                HostCmd_OPT_802_11_RF_CHANNEL_GET,
+                                HostCmd_OPTION_WAITFORRSP, 0, NULL);
+
+    PRINTM(INFO, "Current Channel = %d\n",
+           priv->adapter->CurBssParams.BSSDescriptor.Channel);
+
+    return ret;
+}
+
+/** 
+ *  @brief Set Current Channel 
+ *   
+ *  @param priv 		A pointer to wlan_private structure
+ *  @param channel		The channel to be set. 
+ *  @return 	   		WLAN_STATUS_SUCCESS--success, WLAN_STATUS_FAILURE--fail
+ */
+static int
+SetCurrentChannel(wlan_private * priv, int channel)
+{
+    PRINTM(INFO, "Set Channel = %d\n", channel);
+
+    /* 
+     **  Current channel is not set to AdhocChannel requested, set channel
+     */
+    return (PrepareAndSendCommand(priv, HostCmd_CMD_802_11_RF_CHANNEL,
+                                  HostCmd_OPT_802_11_RF_CHANNEL_SET,
+                                  HostCmd_OPTION_WAITFORRSP, 0, &channel));
+}
+
+/** 
+ *  @brief Change Adhoc Channel
+ *   
+ *  @param priv 		A pointer to wlan_private structure
+ *  @param channel		The channel to be set. 
+ *  @return 	   		WLAN_STATUS_SUCCESS--success, WLAN_STATUS_FAILURE--fail
+ */
+static int
+ChangeAdhocChannel(wlan_private * priv, int channel)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+
+    Adapter->AdhocChannel = channel;
+
+    UpdateCurrentChannel(priv);
+
+    if (Adapter->CurBssParams.BSSDescriptor.Channel == Adapter->AdhocChannel) {
+        /* AdhocChannel is set to the current Channel already */
+        LEAVE();
+        return WLAN_STATUS_SUCCESS;
+    }
+
+    PRINTM(INFO, "Updating Channel from %d to %d\n",
+           Adapter->CurBssParams.BSSDescriptor.Channel,
+           Adapter->AdhocChannel);
+
+    SetCurrentChannel(priv, Adapter->AdhocChannel);
+
+    UpdateCurrentChannel(priv);
+
+    if (Adapter->CurBssParams.BSSDescriptor.Channel != Adapter->AdhocChannel) {
+        PRINTM(INFO, "Failed to updated Channel to %d, channel = %d\n",
+               Adapter->AdhocChannel,
+               Adapter->CurBssParams.BSSDescriptor.Channel);
+        LEAVE();
+        return WLAN_STATUS_FAILURE;
+    }
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        int i;
+        WLAN_802_11_SSID curAdhocSsid;
+
+        PRINTM(INFO, "Channel Changed while in an IBSS\n");
+
+        /* Copy the current ssid */
+        memcpy(&curAdhocSsid,
+               &Adapter->CurBssParams.BSSDescriptor.Ssid,
+               sizeof(WLAN_802_11_SSID));
+
+        /* Exit Adhoc mode */
+        PRINTM(INFO, "In ChangeAdhocChannel(): Sending Adhoc Stop\n");
+        ret = StopAdhocNetwork(priv);
+
+        if (ret) {
+            LEAVE();
+            return ret;
+        }
+
+        /* Scan for the network */
+        SendSpecificSSIDScan(priv, &curAdhocSsid);
+
+        // find out the BSSID that matches the current SSID 
+        i = FindSSIDInList(Adapter, &curAdhocSsid, NULL, Wlan802_11IBSS);
+
+        if (i >= 0) {
+            PRINTM(INFO, "SSID found at %d in List," "so join\n", i);
+            JoinAdhocNetwork(priv, &Adapter->ScanTable[i]);
+        } else {
+            // else send START command
+            PRINTM(INFO, "SSID not found in list, "
+                   "so creating adhoc with ssid = %s\n", curAdhocSsid.Ssid);
+            StartAdhocNetwork(priv, &curAdhocSsid);
+        }                       // end of else (START command)
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set/Get WPA IE   
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param ie_data_ptr  A pointer to IE
+ *  @param ie_len       Length of the IE
+ *
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_wpa_ie_helper(wlan_private * priv, u8 * ie_data_ptr, u16 ie_len)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (ie_len) {
+        if (ie_len > sizeof(Adapter->Wpa_ie)) {
+            PRINTM(INFO, "failed to copy WPA IE, too big \n");
+            return -EFAULT;
+        }
+        if (copy_from_user(Adapter->Wpa_ie, ie_data_ptr, ie_len)) {
+            PRINTM(INFO, "failed to copy WPA IE \n");
+            return -EFAULT;
+        }
+        Adapter->Wpa_ie_len = ie_len;
+        PRINTM(INFO, "Set Wpa_ie_len=%d IE=%#x\n",
+               Adapter->Wpa_ie_len, Adapter->Wpa_ie[0]);
+        HEXDUMP("Wpa_ie", Adapter->Wpa_ie, Adapter->Wpa_ie_len);
+
+        if (Adapter->Wpa_ie[0] == WPA_IE) {
+            Adapter->SecInfo.WPAEnabled = TRUE;
+        } else if (Adapter->Wpa_ie[0] == RSN_IE) {
+            Adapter->SecInfo.WPA2Enabled = TRUE;
+        } else {
+            Adapter->SecInfo.WPAEnabled = FALSE;
+            Adapter->SecInfo.WPA2Enabled = FALSE;
+        }
+    } else {
+        memset(Adapter->Wpa_ie, 0, sizeof(Adapter->Wpa_ie));
+        Adapter->Wpa_ie_len = ie_len;
+        PRINTM(INFO, "Reset Wpa_ie_len=%d IE=%#x\n",
+               Adapter->Wpa_ie_len, Adapter->Wpa_ie[0]);
+        Adapter->SecInfo.WPAEnabled = FALSE;
+        Adapter->SecInfo.WPA2Enabled = FALSE;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Set/Get WPA IE
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param req          A pointer to ifreq structure
+ *
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_wpa_ie_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    struct iwreq *wrq = (struct iwreq *) req;
+
+    return wlan_set_wpa_ie_helper(priv,
+                                  wrq->u.data.pointer, wrq->u.data.length);
+}
+
+/** 
+ *  @brief Set WPA key
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_encode_wpa(struct net_device *dev,
+                    struct iw_request_info *info,
+                    struct iw_point *dwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = dev->priv;
+    WLAN_802_11_KEY *pKey;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    pKey = (WLAN_802_11_KEY *) extra;
+
+    HEXDUMP("Key buffer: ", extra, dwrq->length);
+
+    // current driver only supports key length of up to 32 bytes
+    if (pKey->KeyLength > MRVL_MAX_WPA_KEY_LENGTH) {
+        PRINTM(INFO, " Error in key length \n");
+        return WLAN_STATUS_FAILURE;
+    }
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_KEY_MATERIAL,
+                                HostCmd_ACT_SET,
+                                HostCmd_OPTION_WAITFORRSP,
+                                KEY_INFO_ENABLED, pKey);
+
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/*
+ *  iwconfig ethX key on:	WEPEnabled;
+ *  iwconfig ethX key off:	WEPDisabled;
+ *  iwconfig ethX key [x]:	CurrentWepKeyIndex = x; WEPEnabled;
+ *  iwconfig ethX key [x] kstr:	WepKey[x] = kstr;
+ *  iwconfig ethX key kstr:	WepKey[CurrentWepKeyIndex] = kstr;
+ *
+ *  all:			Send command SET_WEP;
+ 				SetMacPacketFilter;
+ */
+
+/** 
+ *  @brief Set WEP key
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_encode_nonwpa(struct net_device *dev,
+                       struct iw_request_info *info,
+                       struct iw_point *dwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    MRVL_WEP_KEY *pWep;
+    int index, PrevAuthMode;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    if (Adapter->CurrentWepKeyIndex >= MRVL_NUM_WEP_KEY)
+        Adapter->CurrentWepKeyIndex = 0;
+    pWep = &Adapter->WepKey[Adapter->CurrentWepKeyIndex];
+    PrevAuthMode = Adapter->SecInfo.AuthenticationMode;
+
+    index = (dwrq->flags & IW_ENCODE_INDEX) - 1;
+
+    if (index >= 4) {
+        PRINTM(INFO, "Key index #%d out of range.\n", index + 1);
+        return -EINVAL;
+    }
+
+    PRINTM(INFO, "Flags=0x%x, Length=%d Index=%d CurrentWepKeyIndex=%d\n",
+           dwrq->flags, dwrq->length, index, Adapter->CurrentWepKeyIndex);
+
+    if (dwrq->length > 0) {
+        /* iwconfig ethX key [n] xxxxxxxxxxx 
+         * Key has been provided by the user 
+         */
+
+        /*
+         * Check the size of the key 
+         */
+
+        if (dwrq->length > MAX_WEP_KEY_SIZE) {
+            return -EINVAL;
+        }
+
+        /*
+         * Check the index (none -> use current) 
+         */
+
+        if (index < 0 || index > 3)     //invalid index or no index
+            index = Adapter->CurrentWepKeyIndex;
+        else                    //index is given & valid
+            pWep = &Adapter->WepKey[index];
+
+        /*
+         * Check if the key is not marked as invalid 
+         */
+        if (!(dwrq->flags & IW_ENCODE_NOKEY)) {
+            /* Cleanup */
+            memset(pWep, 0, sizeof(MRVL_WEP_KEY));
+
+            /* Copy the key in the driver */
+            memcpy(pWep->KeyMaterial, extra, dwrq->length);
+
+            /* Set the length */
+            if (dwrq->length > MIN_WEP_KEY_SIZE) {
+                pWep->KeyLength = MAX_WEP_KEY_SIZE;
+            } else {
+                if (dwrq->length > 0) {
+                    pWep->KeyLength = MIN_WEP_KEY_SIZE;
+                } else {
+                    /* Disable the key */
+                    pWep->KeyLength = 0;
+                }
+            }
+            pWep->KeyIndex = index;
+
+            if (Adapter->SecInfo.WEPStatus != Wlan802_11WEPEnabled) {
+                /*
+                 * The status is set as Key Absent 
+                 * so as to make sure we display the 
+                 * keys when iwlist ethX key is used
+                 */
+                Adapter->SecInfo.WEPStatus = Wlan802_11WEPKeyAbsent;
+            }
+
+            PRINTM(INFO, "KeyIndex=%u KeyLength=%u\n",
+                   pWep->KeyIndex, pWep->KeyLength);
+            HEXDUMP("WepKey", (u8 *) pWep->KeyMaterial, pWep->KeyLength);
+        }
+    } else {
+        /*
+         * No key provided so it is either enable key, 
+         * on or off */
+        if (dwrq->flags & IW_ENCODE_DISABLED) {
+            PRINTM(INFO, "*** iwconfig ethX key off ***\n");
+
+            Adapter->SecInfo.WEPStatus = Wlan802_11WEPDisabled;
+            if (Adapter->SecInfo.AuthenticationMode ==
+                Wlan802_11AuthModeShared)
+                Adapter->SecInfo.AuthenticationMode = Wlan802_11AuthModeOpen;
+        } else {
+            /* iwconfig ethX key [n]
+             * iwconfig ethX key on 
+             * Do we want to just set the transmit key index ? 
+             */
+
+            if (index < 0 || index > 3) {
+                PRINTM(INFO, "*** iwconfig ethX key on ***\n");
+                index = Adapter->CurrentWepKeyIndex;
+            } else {
+                PRINTM(INFO, "*** iwconfig ethX key [x=%d] ***\n", index);
+                Adapter->CurrentWepKeyIndex = index;
+            }
+
+            /* Copy the required key as the current key */
+            pWep = &Adapter->WepKey[index];
+
+            if (!pWep->KeyLength) {
+                PRINTM(INFO, "Key not set,so cannot enable it\n");
+                return -EPERM;
+            }
+
+            Adapter->SecInfo.WEPStatus = Wlan802_11WEPEnabled;
+
+            HEXDUMP("KeyMaterial", (u8 *) pWep->KeyMaterial, pWep->KeyLength);
+        }
+    }
+
+    if (pWep->KeyLength) {
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_802_11_SET_WEP,
+                                    0, HostCmd_OPTION_WAITFORRSP,
+                                    OID_802_11_ADD_WEP, NULL);
+
+        if (ret) {
+            LEAVE();
+            return ret;
+        }
+    }
+
+    if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPEnabled) {
+        Adapter->CurrentPacketFilter |= HostCmd_ACT_MAC_WEP_ENABLE;
+    } else {
+        Adapter->CurrentPacketFilter &= ~HostCmd_ACT_MAC_WEP_ENABLE;
+    }
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_MAC_CONTROL,
+                                0, HostCmd_OPTION_WAITFORRSP,
+                                0, &Adapter->CurrentPacketFilter);
+
+    if (dwrq->flags & IW_ENCODE_RESTRICTED) {
+        /* iwconfig ethX restricted key [1] */
+        Adapter->SecInfo.AuthenticationMode = Wlan802_11AuthModeShared;
+        PRINTM(INFO, "Auth mode restricted!\n");
+    } else if (dwrq->flags & IW_ENCODE_OPEN) {
+        /* iwconfig ethX key [2] open */
+        Adapter->SecInfo.AuthenticationMode = Wlan802_11AuthModeOpen;
+        PRINTM(INFO, "Auth mode open!\n");
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set RX Antenna
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param Mode			RF antenna mode
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+SetRxAntenna(wlan_private * priv, int Mode)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+
+    if (Mode != RF_ANTENNA_1 && Mode != RF_ANTENNA_2
+        && Mode != RF_ANTENNA_AUTO) {
+        return -EINVAL;
+    }
+
+    Adapter->RxAntennaMode = Mode;
+
+    PRINTM(INFO, "SET RX Antenna Mode to 0x%04x\n", Adapter->RxAntennaMode);
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_RF_ANTENNA,
+                                HostCmd_ACT_SET_RX, HostCmd_OPTION_WAITFORRSP,
+                                0, &Adapter->RxAntennaMode);
+    return ret;
+}
+
+/** 
+ *  @brief Set TX Antenna
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param Mode			RF antenna mode
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+SetTxAntenna(wlan_private * priv, int Mode)
+{
+    int ret = 0;
+    wlan_adapter *Adapter = priv->adapter;
+
+    if ((Mode != RF_ANTENNA_1) && (Mode != RF_ANTENNA_2)
+        && (Mode != RF_ANTENNA_AUTO)) {
+        return -EINVAL;
+    }
+
+    Adapter->TxAntennaMode = Mode;
+
+    PRINTM(INFO, "SET TX Antenna Mode to 0x%04x\n", Adapter->TxAntennaMode);
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_RF_ANTENNA,
+                                HostCmd_ACT_SET_TX, HostCmd_OPTION_WAITFORRSP,
+                                0, &Adapter->TxAntennaMode);
+
+    return ret;
+}
+
+/** 
+ *  @brief Get RX Antenna
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param buf			A pointer to recieve antenna mode
+ *  @return 	   		length of buf 
+ */
+static int
+GetRxAntenna(wlan_private * priv, char *buf)
+{
+    int ret = 0;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    // clear it, so we will know if the value 
+    // returned below is correct or not.
+    Adapter->RxAntennaMode = 0;
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_RF_ANTENNA,
+                                HostCmd_ACT_GET_RX, HostCmd_OPTION_WAITFORRSP,
+                                0, NULL);
+
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+
+    PRINTM(INFO, "Get Rx Antenna Mode:0x%04x\n", Adapter->RxAntennaMode);
+
+    LEAVE();
+
+    return sprintf(buf, "0x%04x", Adapter->RxAntennaMode) + 1;
+}
+
+/** 
+ *  @brief Get TX Antenna
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param buf			A pointer to recieve antenna mode
+ *  @return 	   		length of buf 
+ */
+static int
+GetTxAntenna(wlan_private * priv, char *buf)
+{
+    int ret = 0;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    // clear it, so we will know if the value 
+    // returned below is correct or not.
+    Adapter->TxAntennaMode = 0;
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_RF_ANTENNA,
+                                HostCmd_ACT_GET_TX, HostCmd_OPTION_WAITFORRSP,
+                                0, NULL);
+
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+
+    PRINTM(INFO, "Get Tx Antenna Mode:0x%04x\n", Adapter->TxAntennaMode);
+
+    LEAVE();
+
+    return sprintf(buf, "0x%04x", Adapter->TxAntennaMode) + 1;
+}
+
+/** 
+ *  @brief Set Radio On/OFF
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @option 			Radio Option
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail 
+ */
+static int
+wlan_radio_ioctl(wlan_private * priv, u8 option)
+{
+    int ret = 0;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (Adapter->RadioOn != option) {
+        if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+            PRINTM(MSG, "Cannot turn radio off in connected state.\n");
+            LEAVE();
+            return -EINVAL;
+        }
+
+        PRINTM(INFO, "Switching %s the Radio\n", option ? "On" : "Off");
+        Adapter->RadioOn = option;
+
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_802_11_RADIO_CONTROL,
+                                    HostCmd_ACT_GEN_SET,
+                                    HostCmd_OPTION_WAITFORRSP, 0, NULL);
+    }
+
+    LEAVE();
+    return ret;
+}
+
+#ifdef REASSOCIATION
+/** 
+ *  @brief Set Auto Reassociation On
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail 
+ */
+static int
+reassociation_on(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    Adapter->Reassoc_on = TRUE;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set Auto Reassociation Off
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail 
+ */
+static int
+reassociation_off(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (Adapter->ReassocTimerIsSet == TRUE) {
+        CancelTimer(&Adapter->MrvDrvTimer);
+        Adapter->ReassocTimerIsSet = FALSE;
+    }
+
+    Adapter->Reassoc_on = FALSE;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+#endif /* REASSOCIATION */
+
+/** 
+ *  @brief Set Region
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param region_code		region code
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail 
+ */
+static int
+wlan_set_region(wlan_private * priv, u16 region_code)
+{
+    int i;
+
+    ENTER();
+
+    for (i = 0; i < MRVDRV_MAX_REGION_CODE; i++) {
+        // use the region code to search for the index
+        if (region_code == RegionCodeToIndex[i]) {
+            priv->adapter->RegionCode = region_code;
+            break;
+        }
+    }
+
+    // if it's unidentified region code
+    if (i >= MRVDRV_MAX_REGION_CODE) {
+        PRINTM(INFO, "Region Code not identified\n");
+        LEAVE();
+        return WLAN_STATUS_FAILURE;
+    }
+
+    if (wlan_set_regiontable(priv, priv->adapter->RegionCode, 0)) {
+        LEAVE();
+        return -EINVAL;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Copy Rates
+ *   
+ *  @param dest                 A pointer to Dest Buf
+ *  @param src		        A pointer to Src Buf
+ *  @param len                  The len of Src Buf
+ *  @return 	   	        Number of Rates copyed 
+ */
+static inline int
+CopyRates(u8 * dest, int pos, u8 * src, int len)
+{
+    int i;
+
+    for (i = 0; i < len && src[i]; i++, pos++) {
+        if (pos >= sizeof(WLAN_802_11_RATES))
+            break;
+        dest[pos] = src[i];
+    }
+
+    return pos;
+}
+
+/** 
+ *  @brief Get active data rates
+ *   
+ *  @param Adapter          A pointer to wlan_adapter structure
+ *  @param rate             The buf to return the active rates
+ *  @return                 The number of Rates
+ */
+static int
+get_active_data_rates(wlan_adapter * Adapter, WLAN_802_11_RATES rates)
+{
+    int k = 0;
+
+    ENTER();
+
+    if (Adapter->MediaConnectStatus != WlanMediaStateConnected) {
+        if (Adapter->InfrastructureMode == Wlan802_11Infrastructure) {
+            //Infra. mode
+            PRINTM(INFO, "Infra\n");
+            k = CopyRates(rates, k, SupportedRates, sizeof(SupportedRates));
+        } else {
+            //ad-hoc mode
+            PRINTM(INFO, "Adhoc G\n");
+            k = CopyRates(rates, k, AdhocRates_G, sizeof(AdhocRates_G));
+        }
+    } else {
+        k = CopyRates(rates, 0, Adapter->CurBssParams.DataRates,
+                      Adapter->CurBssParams.NumOfRates);
+    }
+
+    LEAVE();
+
+    return k;
+}
+
+/** 
+ *  @brief Get/Set Per packet TX Control flags
+ *  
+ *  @param priv     A pointer to wlan_private structure
+ *  @param wrq      A pointer to user data
+ *  @return         WLAN_STATUS_SUCCESS--success, otherwise fail
+ */
+static int
+wlan_txcontrol(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int data[3];
+    int ret;
+
+    ENTER();
+
+    ret = WLAN_STATUS_SUCCESS;
+
+    switch (wrq->u.data.length) {
+    case 0:
+        /*
+         *  Get the Global setting for TxCtrl 
+         */
+        if (copy_to_user(wrq->u.data.pointer,
+                         &Adapter->PktTxCtrl, sizeof(u32))) {
+            PRINTM(INFO, "copy_to_user failed!\n");
+            ret = -EFAULT;
+        } else {
+            wrq->u.data.length = 1;
+        }
+        break;
+
+    case 1:
+        /*
+         *  Set the Global setting for TxCtrl
+         */
+        if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            ret = -EFAULT;
+        } else {
+            Adapter->PktTxCtrl = data[0];
+            PRINTM(INFO, "PktTxCtrl set: 0x%08x\n", Adapter->PktTxCtrl);
+        }
+        break;
+
+    case 2:
+        /*
+         *  Get the per User Priority setting for TxCtrl for the given UP
+         */
+        if (copy_from_user(data, wrq->u.data.pointer, sizeof(int) * 2)) {
+            PRINTM(INFO, "Copy from user failed\n");
+            ret = -EFAULT;
+
+        } else if (data[1] >= NELEMENTS(Adapter->wmm.userPriPktTxCtrl)) {
+            /* Range check the UP input from user space */
+            PRINTM(INFO, "User priority out of range\n");
+            ret = -EINVAL;
+
+        } else if (Adapter->wmm.userPriPktTxCtrl[data[1]]) {
+            data[2] = Adapter->wmm.userPriPktTxCtrl[data[1]];
+
+            /* User priority setting is valid, return it */
+            if (copy_to_user(wrq->u.data.pointer, data, sizeof(int) * 3)) {
+                PRINTM(INFO, "copy_to_user failed!\n");
+                ret = -EFAULT;
+            } else {
+                wrq->u.data.length = 3;
+            }
+
+        } else {
+            /* Return the global setting since the UP set is zero */
+            data[2] = Adapter->PktTxCtrl;
+
+            if (copy_to_user(wrq->u.data.pointer, data, sizeof(int) * 3)) {
+                PRINTM(INFO, "copy_to_user failed!\n");
+                ret = -EFAULT;
+            } else {
+                wrq->u.data.length = 3;
+            }
+        }
+        break;
+
+    case 3:
+        /*
+         *  Set the per User Priority setting for TxCtrl for the given UP
+         */
+
+        if (copy_from_user(data, wrq->u.data.pointer, sizeof(int) * 3)) {
+            PRINTM(INFO, "Copy from user failed\n");
+            ret = -EFAULT;
+        } else if (data[1] >= NELEMENTS(Adapter->wmm.userPriPktTxCtrl)) {
+            PRINTM(INFO, "User priority out of range\n");
+            ret = -EINVAL;
+        } else {
+            Adapter->wmm.userPriPktTxCtrl[data[1]] = data[2];
+
+            if (Adapter->wmm.userPriPktTxCtrl[data[1]] == 0) {
+                /* Return the global setting since the UP set is zero */
+                data[2] = Adapter->PktTxCtrl;
+            }
+
+            if (copy_to_user(wrq->u.data.pointer, data, sizeof(int) * 3)) {
+                PRINTM(INFO, "copy_to_user failed!\n");
+                ret = -EFAULT;
+            } else {
+                wrq->u.data.length = 3;
+            }
+        }
+        break;
+
+    default:
+        ret = -EINVAL;
+        break;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Enable/Disable atim uapsd null package generation
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wrq	   	A pointer to user data
+ *  @return 	   	WLAN_STATUS_SUCCESS--success, otherwise fail
+ */
+static int
+wlan_null_pkg_gen(wlan_private * priv, struct iwreq *wrq)
+{
+    int data;
+    wlan_adapter *Adapter = priv->adapter;
+    int *val;
+
+    ENTER();
+
+    data = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+    PRINTM(INFO, "Enable UAPSD NULL PKG: %s\n",
+           (data == CMD_ENABLED) ? "Enable" : "Disable");
+    switch (data) {
+    case CMD_ENABLED:
+        Adapter->gen_null_pkg = TRUE;
+        break;
+    case CMD_DISABLED:
+        Adapter->gen_null_pkg = FALSE;
+        break;
+    default:
+        break;
+    }
+
+    data = (Adapter->gen_null_pkg == TRUE) ? CMD_ENABLED : CMD_DISABLED;
+    val = (int *) wrq->u.name;
+    *val = data;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get/Set NULL Package generation interval
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wrq	   	A pointer to user data
+ *  @return 	   	WLAN_STATUS_SUCCESS--success, otherwise fail
+ */
+static int
+wlan_null_pkt_interval(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int data;
+    ENTER();
+
+    if ((int) wrq->u.data.length == 0) {
+        data = Adapter->NullPktInterval;
+
+        if (copy_to_user(wrq->u.data.pointer, &data, sizeof(int))) {
+            PRINTM(MSG, "copy_to_user failed!\n");
+            return -EFAULT;
+        }
+    } else {
+        if ((int) wrq->u.data.length > 1) {
+            PRINTM(MSG, "ioctl too many args!\n");
+            return -EFAULT;
+        }
+        if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+
+        Adapter->NullPktInterval = data;
+    }
+
+    wrq->u.data.length = 1;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get/Set Adhoc awake period 
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_adhoc_awake_period(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int data;
+    ENTER();
+
+    if ((int) wrq->u.data.length == 0) {
+        data = Adapter->AdhocAwakePeriod;
+        if (copy_to_user(wrq->u.data.pointer, &data, sizeof(int))) {
+            PRINTM(MSG, "copy_to_user failed!\n");
+            return -EFAULT;
+        }
+    } else {
+        if ((int) wrq->u.data.length > 1) {
+            PRINTM(MSG, "ioctl too many args!\n");
+            return -EFAULT;
+        }
+        if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+#define AWAKE_PERIOD_MIN 1
+#define AWAKE_PERIOD_MAX 31
+#define DISABLE_AWAKE_PERIOD 0xff
+        if ((((data & 0xff) >= AWAKE_PERIOD_MIN) &&
+             ((data & 0xff) <= AWAKE_PERIOD_MAX)) ||
+            ((data & 0xff) == DISABLE_AWAKE_PERIOD))
+            Adapter->AdhocAwakePeriod = (u16) data;
+        else {
+            PRINTM(INFO,
+                   "Invalid parameter, AdhocAwakePeriod not changed.\n");
+            return -EINVAL;
+
+        }
+    }
+    wrq->u.data.length = 1;
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get/Set bcn missing timeout 
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_bcn_miss_timeout(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int data;
+    ENTER();
+
+    if ((int) wrq->u.data.length == 0) {
+        data = Adapter->BCNMissTimeOut;
+        if (copy_to_user(wrq->u.data.pointer, &data, sizeof(int))) {
+            PRINTM(MSG, "copy_to_user failed!\n");
+            return -EFAULT;
+        }
+    } else {
+        if ((int) wrq->u.data.length > 1) {
+            PRINTM(MSG, "ioctl too many args!\n");
+            return -EFAULT;
+        }
+        if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+        if (((data >= 0) && (data <= 50)) || (data == 0xffff))
+            Adapter->BCNMissTimeOut = (u16) data;
+        else {
+            PRINTM(INFO,
+                   "Invalid parameter, BCN Missing timeout not changed.\n");
+            return -EINVAL;
+
+        }
+    }
+
+    wrq->u.data.length = 1;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get/Set adhoc g proctection
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_adhoc_g_protection(wlan_private * priv, struct iwreq *wrq)
+{
+    int data;
+    int *val;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+#define ADHOC_G_PROTECTION_ON		1
+#define ADHOC_G_PROTECTION_OFF		0
+    data = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+
+    switch (data) {
+    case CMD_DISABLED:
+        Adapter->CurrentPacketFilter &=
+            ~HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON;
+        break;
+    case CMD_ENABLED:
+        Adapter->CurrentPacketFilter |= HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON;
+        break;
+
+    case CMD_GET:
+        if (Adapter->
+            CurrentPacketFilter & HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON)
+            data = ADHOC_G_PROTECTION_ON;
+        else
+            data = ADHOC_G_PROTECTION_OFF;
+        break;
+
+    default:
+        return -EINVAL;
+    }
+
+    val = (int *) wrq->u.name;
+    *val = data;
+
+    LEAVE();
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+#define USE_RTS_CTS				1
+#define USE_CTS_TO_SELF			0
+/** 
+ *  @brief GetSet RTS/CTS or CTS to self.
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_rts_cts_ctrl(wlan_private * priv, struct iwreq *wrq)
+{
+    int data;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = 0;
+    ENTER();
+
+    if ((int) wrq->u.data.length == 0) {
+        if (Adapter->CurrentPacketFilter & HostCmd_ACT_MAC_RTS_CTS_ENABLE)
+            data = USE_RTS_CTS;
+        else
+            data = USE_CTS_TO_SELF;
+        if (copy_to_user(wrq->u.data.pointer, &data, sizeof(int))) {
+            PRINTM(MSG, "copy_to_user failed!\n");
+            return -EFAULT;
+        }
+    } else {
+        if ((int) wrq->u.data.length > 1) {
+            PRINTM(MSG, "ioctl too many args!\n");
+            return -EFAULT;
+        }
+        if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+        if (data == USE_RTS_CTS) {
+            Adapter->CurrentPacketFilter |= HostCmd_ACT_MAC_RTS_CTS_ENABLE;
+        } else {
+            Adapter->CurrentPacketFilter &= ~HostCmd_ACT_MAC_RTS_CTS_ENABLE;
+        }
+        PRINTM(INFO, "Adapter->CurrentPacketFilter=0x%x\n",
+               Adapter->CurrentPacketFilter);
+
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_MAC_CONTROL,
+                                    0, HostCmd_OPTION_WAITFORRSP,
+                                    0, &Adapter->CurrentPacketFilter);
+    }
+    wrq->u.data.length = 1;
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get/Set sdio mode
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_sdio_mode(wlan_private * priv, struct iwreq *wrq)
+{
+    int data;
+    int bus_width;
+    wlan_adapter *Adapter = priv->adapter;
+    ENTER();
+
+    if ((int) wrq->u.data.length == 0) {
+        data = 4;
+        if (copy_to_user(wrq->u.data.pointer, &data, sizeof(int))) {
+            PRINTM(MSG, "copy_to_user failed!\n");
+            return -EFAULT;
+        }
+    } else {
+        if ((int) wrq->u.data.length > 1) {
+            PRINTM(MSG, "ioctl too many args!\n");
+            return -EFAULT;
+        }
+        if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+        if ((data != 1) && (data != 4))
+            return -EFAULT;
+        bus_width = 4;
+        if (bus_width != data)
+            Adapter->sdiomode = (u8) data;
+    }
+    wrq->u.data.length = 1;
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get/Set LDO config
+ *  @param priv			A pointer to wlan_private structure
+ *  @param wrq			A pointer to wrq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_ldo_config(wlan_private * priv, struct iwreq *wrq)
+{
+    HostCmd_DS_802_11_LDO_CONFIG ldocfg;
+    int data = 0;
+    u16 action;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (wrq->u.data.length == 0) {
+        action = HostCmd_ACT_GEN_GET;
+    } else if (wrq->u.data.length > 1) {
+        PRINTM(MSG, "ioctl too many args!\n");
+        ret = -EFAULT;
+        goto ldoexit;
+    } else {
+        if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            ret = -EFAULT;
+            goto ldoexit;
+        }
+        if (data != LDO_INTERNAL && data != LDO_EXTERNAL) {
+            PRINTM(MSG, "Invalid parameter, LDO config not changed.\n");
+            ret = -EFAULT;
+            goto ldoexit;
+        }
+        action = HostCmd_ACT_GEN_SET;
+    }
+    ldocfg.Action = action;
+    ldocfg.PMSource = (u16) data;
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_LDO_CONFIG,
+                                action, HostCmd_OPTION_WAITFORRSP,
+                                0, (void *) &ldocfg);
+
+    if (!ret && action == HostCmd_ACT_GEN_GET) {
+        data = (int) ldocfg.PMSource;
+        if (copy_to_user(wrq->u.data.pointer, &data, sizeof(int))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            ret = -EFAULT;
+            goto ldoexit;
+        }
+        wrq->u.data.length = 1;
+    }
+
+  ldoexit:
+    LEAVE();
+    return ret;
+}
+
+#ifdef DEBUG_LEVEL1
+/** 
+ *  @brief Get/Set the bit mask of driver debug message control
+ *  @param priv			A pointer to wlan_private structure
+ *  @param wrq			A pointer to wrq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_drv_dbg(wlan_private * priv, struct iwreq *wrq)
+{
+    int data[4];
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (wrq->u.data.length == 0) {
+        data[0] = drvdbg;
+        data[1] = ifdbg;
+        /* Return the current driver debug bit masks */
+        if (copy_to_user(wrq->u.data.pointer, data, sizeof(int) * 2)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            ret = -EFAULT;
+            goto drvdbgexit;
+        }
+        wrq->u.data.length = 2;
+    } else if (wrq->u.data.length < 3) {
+        /* Get the driver debug bit masks */
+        if (copy_from_user
+            (data, wrq->u.data.pointer, sizeof(int) * wrq->u.data.length)) {
+            PRINTM(INFO, "Copy from user failed\n");
+            ret = -EFAULT;
+            goto drvdbgexit;
+        }
+        drvdbg = data[0];
+        if (wrq->u.data.length == 2)
+            ifdbg = data[1];
+    } else {
+        PRINTM(INFO, "Invalid parameter number\n");
+        goto drvdbgexit;
+    }
+
+    printk(KERN_ALERT "drvdbg = 0x%x\n", drvdbg);
+#ifdef DEBUG_LEVEL2
+    printk(KERN_ALERT "INFO  (%08x) %s\n", DBG_INFO,
+           (drvdbg & DBG_INFO) ? "X" : "");
+    printk(KERN_ALERT "WARN  (%08x) %s\n", DBG_WARN,
+           (drvdbg & DBG_WARN) ? "X" : "");
+    printk(KERN_ALERT "ENTRY (%08x) %s\n", DBG_ENTRY,
+           (drvdbg & DBG_ENTRY) ? "X" : "");
+#endif
+    printk(KERN_ALERT "FW_D  (%08x) %s\n", DBG_FW_D,
+           (drvdbg & DBG_FW_D) ? "X" : "");
+    printk(KERN_ALERT "CMD_D (%08x) %s\n", DBG_CMD_D,
+           (drvdbg & DBG_CMD_D) ? "X" : "");
+    printk(KERN_ALERT "DAT_D (%08x) %s\n", DBG_DAT_D,
+           (drvdbg & DBG_DAT_D) ? "X" : "");
+
+    printk(KERN_ALERT "INTR  (%08x) %s\n", DBG_INTR,
+           (drvdbg & DBG_INTR) ? "X" : "");
+    printk(KERN_ALERT "EVENT (%08x) %s\n", DBG_EVENT,
+           (drvdbg & DBG_EVENT) ? "X" : "");
+    printk(KERN_ALERT "CMND  (%08x) %s\n", DBG_CMND,
+           (drvdbg & DBG_CMND) ? "X" : "");
+    printk(KERN_ALERT "DATA  (%08x) %s\n", DBG_DATA,
+           (drvdbg & DBG_DATA) ? "X" : "");
+    printk(KERN_ALERT "ERROR (%08x) %s\n", DBG_ERROR,
+           (drvdbg & DBG_ERROR) ? "X" : "");
+    printk(KERN_ALERT "FATAL (%08x) %s\n", DBG_FATAL,
+           (drvdbg & DBG_FATAL) ? "X" : "");
+    printk(KERN_ALERT "MSG   (%08x) %s\n", DBG_MSG,
+           (drvdbg & DBG_MSG) ? "X" : "");
+    printk(KERN_ALERT "ifdbg = 0x%x\n", ifdbg);
+    printk(KERN_ALERT "IF_D  (%08x) %s\n", DBG_IF_D,
+           (ifdbg & DBG_IF_D) ? "X" : "");
+
+  drvdbgexit:
+    LEAVE();
+    return ret;
+}
+#endif
+
+/** 
+ *  @brief Commit handler: called after a bunch of SET operations
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_config_commit(struct net_device *dev,
+                   struct iw_request_info *info, char *cwrq, char *extra)
+{
+    ENTER();
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get protocol name 
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_name(struct net_device *dev, struct iw_request_info *info,
+              char *cwrq, char *extra)
+{
+    const char *cp;
+    char comm[6] = { "COMM-" };
+    char mrvl[6] = { "MRVL-" };
+    int cnt;
+
+    ENTER();
+
+    strcpy(cwrq, mrvl);
+
+    cp = strstr(driver_version, comm);
+    if (cp == driver_version)   //skip leading "COMM-"
+        cp = driver_version + strlen(comm);
+    else
+        cp = driver_version;
+
+    cnt = strlen(mrvl);
+    cwrq += cnt;
+    while (cnt < 16 && (*cp != '-')) {
+        *cwrq++ = toupper(*cp++);
+        cnt++;
+    }
+    *cwrq = '\0';
+
+    LEAVE();
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get frequency
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param fwrq 		A pointer to iw_freq structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_freq(struct net_device *dev, struct iw_request_info *info,
+              struct iw_freq *fwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    CHANNEL_FREQ_POWER *cfp;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    cfp = find_cfp_by_band_and_channel(Adapter, 0,
+                                       (u16) Adapter->CurBssParams.
+                                       BSSDescriptor.Channel);
+
+    if (!cfp) {
+        if (Adapter->CurBssParams.BSSDescriptor.Channel) {
+            PRINTM(INFO, "Invalid channel=%d\n",
+                   Adapter->CurBssParams.BSSDescriptor.Channel);
+        }
+        return -EINVAL;
+    }
+
+    fwrq->m = (long) cfp->Freq * 100000;
+    fwrq->e = 1;
+
+    PRINTM(INFO, "freq=%u\n", fwrq->m);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get current BSSID
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param awrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_wap(struct net_device *dev, struct iw_request_info *info,
+             struct sockaddr *awrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        memcpy(awrq->sa_data,
+               Adapter->CurBssParams.BSSDescriptor.MacAddress, ETH_ALEN);
+    } else {
+        memset(awrq->sa_data, 0, ETH_ALEN);
+    }
+    awrq->sa_family = ARPHRD_ETHER;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set Adapter Node Name
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_nick(struct net_device *dev, struct iw_request_info *info,
+              struct iw_point *dwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    /*
+     * Check the size of the string 
+     */
+
+    if (dwrq->length > 16) {
+        return -E2BIG;
+    }
+
+    memset(Adapter->nodeName, 0, sizeof(Adapter->nodeName));
+    memcpy(Adapter->nodeName, extra, dwrq->length);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get Adapter Node Name
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_nick(struct net_device *dev, struct iw_request_info *info,
+              struct iw_point *dwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    /*
+     * Get the Nick Name saved 
+     */
+
+    strncpy(extra, Adapter->nodeName, 16);
+
+    extra[16] = '\0';
+
+    /*
+     * If none, we may want to get the one that was set 
+     */
+
+    /*
+     * Push it out ! 
+     */
+#if WIRELESS_EXT > 20
+    dwrq->length = strlen(extra);
+#else
+    dwrq->length = strlen(extra) + 1;
+#endif
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set RTS threshold
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_rts(struct net_device *dev, struct iw_request_info *info,
+             struct iw_param *vwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int rthr = vwrq->value;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    if (vwrq->disabled) {
+        Adapter->RTSThsd = rthr = MRVDRV_RTS_MAX_VALUE;
+    } else {
+        if (rthr < MRVDRV_RTS_MIN_VALUE || rthr > MRVDRV_RTS_MAX_VALUE)
+            return -EINVAL;
+        Adapter->RTSThsd = rthr;
+    }
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_SNMP_MIB,
+                                HostCmd_ACT_SET, HostCmd_OPTION_WAITFORRSP,
+                                OID_802_11_RTS_THRESHOLD, &rthr);
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get RTS threshold
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_rts(struct net_device *dev, struct iw_request_info *info,
+             struct iw_param *vwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    Adapter->RTSThsd = 0;
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_SNMP_MIB,
+                                HostCmd_ACT_GET, HostCmd_OPTION_WAITFORRSP,
+                                OID_802_11_RTS_THRESHOLD, NULL);
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+
+    vwrq->value = Adapter->RTSThsd;
+    vwrq->disabled = ((vwrq->value < MRVDRV_RTS_MIN_VALUE)
+                      || (vwrq->value > MRVDRV_RTS_MAX_VALUE));
+    vwrq->fixed = 1;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set Fragment threshold
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_frag(struct net_device *dev, struct iw_request_info *info,
+              struct iw_param *vwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    int fthr = vwrq->value;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    if (vwrq->disabled) {
+        Adapter->FragThsd = fthr = MRVDRV_FRAG_MAX_VALUE;
+    } else {
+        if (fthr < MRVDRV_FRAG_MIN_VALUE || fthr > MRVDRV_FRAG_MAX_VALUE)
+            return -EINVAL;
+        Adapter->FragThsd = fthr;
+    }
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_SNMP_MIB,
+                                HostCmd_ACT_SET, HostCmd_OPTION_WAITFORRSP,
+                                OID_802_11_FRAGMENTATION_THRESHOLD, &fthr);
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get Fragment threshold
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_frag(struct net_device *dev, struct iw_request_info *info,
+              struct iw_param *vwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    Adapter->FragThsd = 0;
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_SNMP_MIB, HostCmd_ACT_GET,
+                                HostCmd_OPTION_WAITFORRSP,
+                                OID_802_11_FRAGMENTATION_THRESHOLD, NULL);
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+
+    vwrq->value = Adapter->FragThsd;
+    vwrq->disabled = ((vwrq->value < MRVDRV_FRAG_MIN_VALUE)
+                      || (vwrq->value > MRVDRV_FRAG_MAX_VALUE));
+    vwrq->fixed = 1;
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get Wlan Mode
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_mode(struct net_device *dev,
+              struct iw_request_info *info, u32 * uwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *adapter = priv->adapter;
+
+    ENTER();
+
+    switch (adapter->InfrastructureMode) {
+    case Wlan802_11IBSS:
+        *uwrq = IW_MODE_ADHOC;
+        break;
+
+    case Wlan802_11Infrastructure:
+        *uwrq = IW_MODE_INFRA;
+        break;
+
+    default:
+    case Wlan802_11AutoUnknown:
+        *uwrq = IW_MODE_AUTO;
+        break;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get Encryption key
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_encode(struct net_device *dev,
+                struct iw_request_info *info,
+                struct iw_point *dwrq, u8 * extra)
+{
+
+    wlan_private *priv = dev->priv;
+    wlan_adapter *adapter = priv->adapter;
+    int index = (dwrq->flags & IW_ENCODE_INDEX);
+
+    ENTER();
+
+    PRINTM(INFO, "flags=0x%x index=%d length=%d CurrentWepKeyIndex=%d\n",
+           dwrq->flags, index, dwrq->length, adapter->CurrentWepKeyIndex);
+    if (index < 0 || index > 4) {
+        PRINTM(INFO, "Key index #%d out of range.\n", index);
+        LEAVE();
+        return -EINVAL;
+    }
+    if (adapter->CurrentWepKeyIndex >= MRVL_NUM_WEP_KEY)
+        adapter->CurrentWepKeyIndex = 0;
+    dwrq->flags = 0;
+
+    /*
+     * Check encryption mode 
+     */
+
+    switch (adapter->SecInfo.AuthenticationMode) {
+    case Wlan802_11AuthModeOpen:
+        dwrq->flags = IW_ENCODE_OPEN;
+        break;
+
+    case Wlan802_11AuthModeShared:
+    case Wlan802_11AuthModeNetworkEAP:
+        dwrq->flags = IW_ENCODE_RESTRICTED;
+        break;
+    default:
+        dwrq->flags = IW_ENCODE_DISABLED | IW_ENCODE_OPEN;
+        break;
+    }
+
+    if ((adapter->SecInfo.WEPStatus == Wlan802_11WEPEnabled)
+        || (adapter->SecInfo.WEPStatus == Wlan802_11WEPKeyAbsent)
+        || adapter->SecInfo.WPAEnabled || adapter->SecInfo.WPA2Enabled) {
+        dwrq->flags &= ~IW_ENCODE_DISABLED;
+    } else {
+        dwrq->flags |= IW_ENCODE_DISABLED;
+    }
+
+    memset(extra, 0, 16);
+
+    if (!index) {
+        /* Handle current key request   */
+        if ((adapter->WepKey[adapter->CurrentWepKeyIndex].KeyLength) &&
+            (adapter->SecInfo.WEPStatus == Wlan802_11WEPEnabled)) {
+            index = adapter->WepKey[adapter->CurrentWepKeyIndex].KeyIndex;
+            memcpy(extra, adapter->WepKey[index].KeyMaterial,
+                   adapter->WepKey[index].KeyLength);
+            dwrq->length = adapter->WepKey[index].KeyLength;
+            /* return current key */
+            dwrq->flags |= (index + 1);
+            /* return WEP enabled */
+            dwrq->flags &= ~IW_ENCODE_DISABLED;
+        } else if ((adapter->SecInfo.WPAEnabled)
+                   || (adapter->SecInfo.WPA2Enabled)
+            ) {
+            /* return WPA enabled */
+            dwrq->flags &= ~IW_ENCODE_DISABLED;
+        } else {
+            dwrq->flags |= IW_ENCODE_DISABLED;
+        }
+    } else {
+        /* Handle specific key requests */
+        index--;
+        if (adapter->WepKey[index].KeyLength) {
+            memcpy(extra, adapter->WepKey[index].KeyMaterial,
+                   adapter->WepKey[index].KeyLength);
+            dwrq->length = adapter->WepKey[index].KeyLength;
+            /* return current key */
+            dwrq->flags |= (index + 1);
+            /* return WEP enabled */
+            dwrq->flags &= ~IW_ENCODE_DISABLED;
+        } else if ((adapter->SecInfo.WPAEnabled)
+                   || (adapter->SecInfo.WPA2Enabled)
+            ) {
+            /* return WPA enabled */
+            dwrq->flags &= ~IW_ENCODE_DISABLED;
+        } else {
+            dwrq->flags |= IW_ENCODE_DISABLED;
+        }
+    }
+
+    dwrq->flags |= IW_ENCODE_NOKEY;
+
+    PRINTM(INFO, "Key:%02x:%02x:%02x:%02x:%02x:%02x KeyLen=%d\n",
+           extra[0], extra[1], extra[2],
+           extra[3], extra[4], extra[5], dwrq->length);
+
+    PRINTM(INFO, "Return flags=0x%x\n", dwrq->flags);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get TX Power
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_txpow(struct net_device *dev,
+               struct iw_request_info *info,
+               struct iw_param *vwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_RF_TX_POWER,
+                                HostCmd_ACT_GEN_GET,
+                                HostCmd_OPTION_WAITFORRSP, 0, NULL);
+
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+
+    PRINTM(INFO, "TXPOWER GET %d dbm.\n", Adapter->TxPowerLevel);
+    vwrq->value = Adapter->TxPowerLevel;
+    vwrq->fixed = 1;
+    if (Adapter->RadioOn) {
+        vwrq->disabled = 0;
+        vwrq->flags = IW_TXPOW_DBM;
+    } else {
+        vwrq->disabled = 1;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set TX Retry Count
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_retry(struct net_device *dev, struct iw_request_info *info,
+               struct iw_param *vwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *adapter = priv->adapter;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    if (vwrq->flags == IW_RETRY_LIMIT) {
+        /* The MAC has a 4-bit Total_Tx_Count register
+           Total_Tx_Count = 1 + Tx_Retry_Count */
+#define TX_RETRY_MIN 0
+#define TX_RETRY_MAX 14
+        if (vwrq->value < TX_RETRY_MIN || vwrq->value > TX_RETRY_MAX)
+            return -EINVAL;
+
+        /* Set Tx retry count */
+        adapter->TxRetryCount = vwrq->value + 1;
+
+        ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_SNMP_MIB,
+                                    HostCmd_ACT_SET,
+                                    HostCmd_OPTION_WAITFORRSP,
+                                    OID_802_11_TX_RETRYCOUNT, NULL);
+
+        if (ret) {
+            LEAVE();
+            return ret;
+        }
+    } else {
+        return -EOPNOTSUPP;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get TX Retry Count
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_retry(struct net_device *dev, struct iw_request_info *info,
+               struct iw_param *vwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    Adapter->TxRetryCount = 0;
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_SNMP_MIB, HostCmd_ACT_GET,
+                                HostCmd_OPTION_WAITFORRSP,
+                                OID_802_11_TX_RETRYCOUNT, NULL);
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+    vwrq->disabled = 0;
+    if (!vwrq->flags) {
+        vwrq->flags = IW_RETRY_LIMIT;
+        /* Get Tx retry count */
+        vwrq->value = Adapter->TxRetryCount - 1;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Sort Channels
+ *   
+ *  @param freq 		A pointer to iw_freq structure
+ *  @param num		        number of Channels
+ *  @return 	   		NA
+ */
+static inline void
+sort_channels(struct iw_freq *freq, int num)
+{
+    int i, j;
+    struct iw_freq temp;
+
+    for (i = 0; i < num; i++)
+        for (j = i + 1; j < num; j++)
+            if (freq[i].i > freq[j].i) {
+                temp.i = freq[i].i;
+                temp.m = freq[i].m;
+
+                freq[i].i = freq[j].i;
+                freq[i].m = freq[j].m;
+
+                freq[j].i = temp.i;
+                freq[j].m = temp.m;
+            }
+}
+
+/* data rate listing
+	MULTI_BANDS:
+		abg		a	b	b/g
+   Infra 	G(12)		A(8)	B(4)	G(12)
+   Adhoc 	A+B(12)		A(8)	B(4)	B(4)
+
+	non-MULTI_BANDS:
+		   		 	b	b/g
+   Infra 	     		    	B(4)	G(12)
+   Adhoc 	      		    	B(4)	B(4)
+ */
+/** 
+ *  @brief Get Range Info
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_range(struct net_device *dev, struct iw_request_info *info,
+               struct iw_point *dwrq, char *extra)
+{
+    int i, j;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    struct iw_range *range = (struct iw_range *) extra;
+    CHANNEL_FREQ_POWER *cfp;
+    WLAN_802_11_RATES rates;
+
+    ENTER();
+
+    dwrq->length = sizeof(struct iw_range);
+    memset(range, 0, sizeof(struct iw_range));
+
+    range->min_nwid = 0;
+    range->max_nwid = 0;
+
+    memset(rates, 0, sizeof(rates));
+    range->num_bitrates = get_active_data_rates(Adapter, rates);
+    if (range->num_bitrates > sizeof(rates))
+        range->num_bitrates = sizeof(rates);
+
+    for (i = 0; i < MIN(range->num_bitrates, IW_MAX_BITRATES) && rates[i];
+         i++) {
+        range->bitrate[i] = (rates[i] & 0x7f) * 500000;
+    }
+    range->num_bitrates = i;
+    PRINTM(INFO, "IW_MAX_BITRATES=%d num_bitrates=%d\n", IW_MAX_BITRATES,
+           range->num_bitrates);
+
+    range->num_frequency = 0;
+    if (wlan_get_state_11d(priv) == ENABLE_11D &&
+        Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        u8 chan_no;
+        u8 band;
+
+        parsed_region_chan_11d_t *parsed_region_chan =
+            &Adapter->parsed_region_chan;
+
+        band = parsed_region_chan->band;
+        PRINTM(INFO, "band=%d NoOfChan=%d\n", band,
+               parsed_region_chan->NoOfChan);
+
+        for (i = 0; (range->num_frequency < IW_MAX_FREQUENCIES)
+             && (i < parsed_region_chan->NoOfChan); i++) {
+            chan_no = parsed_region_chan->chanPwr[i].chan;
+            PRINTM(INFO, "chan_no=%d\n", chan_no);
+            range->freq[range->num_frequency].i = (long) chan_no;
+            range->freq[range->num_frequency].m =
+                (long) chan_2_freq(chan_no, band) * 100000;
+            range->freq[range->num_frequency].e = 1;
+            range->num_frequency++;
+        }
+    } else {
+        for (j = 0; (range->num_frequency < IW_MAX_FREQUENCIES)
+             && (j < sizeof(Adapter->region_channel)
+                 / sizeof(Adapter->region_channel[0])); j++) {
+            cfp = Adapter->region_channel[j].CFP;
+            for (i = 0; (range->num_frequency < IW_MAX_FREQUENCIES)
+                 && Adapter->region_channel[j].Valid
+                 && cfp && (i < Adapter->region_channel[j].NrCFP); i++) {
+                range->freq[range->num_frequency].i = (long) cfp->Channel;
+                range->freq[range->num_frequency].m =
+                    (long) cfp->Freq * 100000;
+                range->freq[range->num_frequency].e = 1;
+                cfp++;
+                range->num_frequency++;
+            }
+        }
+    }
+
+    PRINTM(INFO, "IW_MAX_FREQUENCIES=%d num_frequency=%d\n",
+           IW_MAX_FREQUENCIES, range->num_frequency);
+
+    range->num_channels = range->num_frequency;
+
+    sort_channels(&range->freq[0], range->num_frequency);
+
+    /*
+     * Set an indication of the max TCP throughput in bit/s that we can
+     * expect using this interface 
+     */
+    if (i > 2)
+        range->throughput = 5000 * 1000;
+    else
+        range->throughput = 1500 * 1000;
+    range->enc_capa = IW_ENC_CAPA_WPA | IW_ENC_CAPA_WPA2 |
+                       IW_ENC_CAPA_CIPHER_TKIP | IW_ENC_CAPA_CIPHER_CCMP;
+                                
+    range->min_rts = MRVDRV_RTS_MIN_VALUE;
+    range->max_rts = MRVDRV_RTS_MAX_VALUE;
+    range->min_frag = MRVDRV_FRAG_MIN_VALUE;
+    range->max_frag = MRVDRV_FRAG_MAX_VALUE;
+
+    range->encoding_size[0] = 5;
+    range->encoding_size[1] = 13;
+    range->num_encoding_sizes = 2;
+    range->max_encoding_tokens = 4;
+
+#define IW_POWER_PERIOD_MIN 1000000     /* 1 sec */
+#define IW_POWER_PERIOD_MAX 120000000   /* 2 min */
+#define IW_POWER_TIMEOUT_MIN 1000       /* 1 ms  */
+#define IW_POWER_TIMEOUT_MAX 1000000    /* 1 sec */
+
+    /* Power Management duration & timeout */
+    range->min_pmp = IW_POWER_PERIOD_MIN;
+    range->max_pmp = IW_POWER_PERIOD_MAX;
+    range->min_pmt = IW_POWER_TIMEOUT_MIN;
+    range->max_pmt = IW_POWER_TIMEOUT_MAX;
+    range->pmp_flags = IW_POWER_PERIOD;
+    range->pmt_flags = IW_POWER_TIMEOUT;
+    range->pm_capa = IW_POWER_PERIOD | IW_POWER_TIMEOUT | IW_POWER_ALL_R;
+
+    /*
+     * Minimum version we recommend 
+     */
+    range->we_version_source = 15;
+
+    /*
+     * Version we are compiled with 
+     */
+    range->we_version_compiled = WIRELESS_EXT;
+
+    range->retry_capa = IW_RETRY_LIMIT;
+    range->retry_flags = IW_RETRY_LIMIT | IW_RETRY_MAX;
+
+    range->min_retry = TX_RETRY_MIN;
+    range->max_retry = TX_RETRY_MAX;
+
+    /*
+     * Set the qual, level and noise range values 
+     */
+    /*
+     * need to put the right values here 
+     */
+#define IW_MAX_QUAL_PERCENT 100
+#define IW_AVG_QUAL_PERCENT 70
+    range->max_qual.qual = IW_MAX_QUAL_PERCENT;
+    range->max_qual.level = 0;
+    range->max_qual.noise = 0;
+
+    range->avg_qual.qual = IW_AVG_QUAL_PERCENT;
+    range->avg_qual.level = 0;
+    range->avg_qual.noise = 0;
+
+    range->sensitivity = 0;
+    /*
+     * Setup the supported power level ranges 
+     */
+    memset(range->txpower, 0, sizeof(range->txpower));
+    range->txpower[0] = Adapter->MinTxPowerLevel;
+    range->txpower[1] = Adapter->MaxTxPowerLevel;
+    range->num_txpower = 2;
+    range->txpower_capa = IW_TXPOW_DBM | IW_TXPOW_RANGE;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief  Set power management 
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_set_power(struct net_device *dev, struct iw_request_info *info,
+               struct iw_param *vwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    /* PS is currently supported only in Infrastructure Mode 
+     * Remove this check if it is to be supported in IBSS mode also 
+     */
+
+    if (vwrq->disabled) {
+        Adapter->PSMode = Wlan802_11PowerModeCAM;
+        if (Adapter->PSState != PS_STATE_FULL_POWER) {
+            PSWakeup(priv, HostCmd_OPTION_WAITFORRSP);
+        }
+
+        return 0;
+    }
+
+    if ((vwrq->flags & IW_POWER_TYPE) == IW_POWER_TIMEOUT) {
+        PRINTM(INFO, "Setting power timeout command is not supported\n");
+        return -EINVAL;
+    } else if ((vwrq->flags & IW_POWER_TYPE) == IW_POWER_PERIOD) {
+        PRINTM(INFO, "Setting power period command is not supported\n");
+        return -EINVAL;
+    }
+
+    if (Adapter->PSMode != Wlan802_11PowerModeCAM) {
+        return WLAN_STATUS_SUCCESS;
+    }
+
+    Adapter->PSMode = Wlan802_11PowerModeMAX_PSP;
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        PSSleep(priv, HostCmd_OPTION_WAITFORRSP);
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief  Get power management 
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_power(struct net_device *dev, struct iw_request_info *info,
+               struct iw_param *vwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int mode;
+
+    ENTER();
+
+    mode = Adapter->PSMode;
+
+    if ((vwrq->disabled = (mode == Wlan802_11PowerModeCAM))
+        || Adapter->MediaConnectStatus == WlanMediaStateDisconnected) {
+        LEAVE();
+        return WLAN_STATUS_SUCCESS;
+    }
+
+    vwrq->value = 0;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief  Set sensitivity threshold
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_sens(struct net_device *dev, struct iw_request_info *info,
+              struct iw_param *vwrq, char *extra)
+{
+    ENTER();
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief  Get sensitivity threshold
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_FAILURE
+ */
+static int
+wlan_get_sens(struct net_device *dev,
+              struct iw_request_info *info, struct iw_param *vwrq,
+              char *extra)
+{
+    ENTER();
+    LEAVE();
+    return WLAN_STATUS_FAILURE;
+}
+
+/** 
+ *  @brief  Append/Reset IE buffer. 
+ *   
+ *  Pass an opaque block of data, expected to be IEEE IEs, to the driver 
+ *    for eventual passthrough to the firmware in an associate/join 
+ *    (and potentially start) command.  This function is the main body
+ *    for both wlan_set_gen_ie_ioctl and wlan_set_gen_ie
+ *
+ *  Data is appended to an existing buffer and then wrapped in a passthrough
+ *    TLV in the command API to the firmware.  The firmware treats the data
+ *    as a transparent passthrough to the transmitted management frame.
+ *
+ *  @param Adapter      A pointer to wlan_private structure
+ *  @param ie_data_ptr  A pointer to iwreq structure
+ *  @param ie_len       Length of the IE or IE block passed in ie_data_ptr
+ *
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_gen_ie_helper(wlan_private * priv, u8 * ie_data_ptr, u16 ie_len)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+    IEEEtypes_VendorHeader_t *pVendorIe;
+    const u8 wpa_oui[] = { 0x00, 0x50, 0xf2, 0x01 };
+    const u8 wps_oui[] = { 0x00, 0x50, 0xf2, 0x04 };
+    /* If the passed length is zero, reset the buffer */
+    if (ie_len == 0) {
+        Adapter->genIeBufferLen = 0;
+
+    } else if (ie_data_ptr == NULL) {
+        /* NULL check */
+        ret = -EINVAL;
+    } else {
+
+        pVendorIe = (IEEEtypes_VendorHeader_t *) ie_data_ptr;
+
+        /* Test to see if it is a WPA IE, if not, then it is a gen IE */
+        if ((pVendorIe->ElementId == RSN_IE)
+            || ((pVendorIe->ElementId == WPA_IE)
+                && (pVendorIe->OuiType == wpa_oui[3])
+                && (memcmp(pVendorIe->Oui, wpa_oui, sizeof(pVendorIe->Oui)) ==
+                    0))) {
+
+            /* IE is a WPA/WPA2 IE so call set_wpa function */
+            ret = wlan_set_wpa_ie_helper(priv, ie_data_ptr, ie_len);
+        } else if ((pVendorIe->ElementId == WPS_IE)
+                   && (memcmp(pVendorIe->Oui, wps_oui, sizeof(pVendorIe->Oui))
+                       == 0)
+                   && (pVendorIe->OuiType == wps_oui[3])) {
+            /*
+             * Discard first two byte (Element ID and Length)
+             * because they are not needed in the case of setting WPS_IE
+             */
+            if (pVendorIe->Len > 4) {
+                memcpy((u8 *) & Adapter->wps.wpsIe, ie_data_ptr, ie_len);
+                HEXDUMP("wpsIe",
+                        (u8 *) & Adapter->wps.wpsIe,
+                        Adapter->wps.wpsIe.VendHdr.Len + 2);
+
+            } else {
+                /* Only wps oui exist, reset driver wps buffer */
+                memset((u8 *) & Adapter->wps.wpsIe,
+                       0x00, sizeof(Adapter->wps.wpsIe));
+                PRINTM(INFO, "wpsIe cleared\n");
+            }
+        } else {
+            /* 
+             * Verify that the passed length is not larger than the available 
+             *   space remaining in the buffer
+             */
+            if (ie_len < (sizeof(Adapter->genIeBuffer)
+                          - Adapter->genIeBufferLen)) {
+
+                /* Append the passed data to the end of the genIeBuffer */
+                if (copy_from_user((Adapter->genIeBuffer
+                                    + Adapter->genIeBufferLen),
+                                   ie_data_ptr, ie_len)) {
+                    PRINTM(INFO, "Copy from user failed\n");
+                    ret = -EFAULT;
+
+                } else {
+                    /* Increment the stored buffer length by the size passed */
+                    Adapter->genIeBufferLen += ie_len;
+                }
+
+            } else {
+                /* Passed data does not fit in the remaining buffer space */
+                ret = WLAN_STATUS_FAILURE;
+            }
+        }
+    }
+
+    /* Return WLAN_STATUS_SUCCESS, or < 0 for error case */
+    return ret;
+}
+
+/** 
+ *  @brief  Get IE buffer from driver 
+ *   
+ *  Used to pass an opaque block of data, expected to be IEEE IEs,
+ *    back to the application.  Currently the data block passed
+ *    back to the application is the saved association response retrieved 
+ *    from the firmware.
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param ie_data_ptr  A pointer to the IE or IE block
+ *  @param ie_len_ptr   In/Out parameter pointer for the buffer length passed 
+ *                      in ie_data_ptr and the resulting data length copied
+ *
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_gen_ie_helper(wlan_private * priv,
+                       u8 * ie_data_ptr, u16 * ie_len_ptr)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    IEEEtypes_AssocRsp_t *pAssocRsp;
+    int copySize;
+
+    pAssocRsp = (IEEEtypes_AssocRsp_t *) Adapter->assocRspBuffer;
+
+    /*
+     * Set the amount to copy back to the application as the minimum of the 
+     *   available IE data or the buffer provided by the application
+     */
+    copySize = (Adapter->assocRspSize - sizeof(pAssocRsp->Capability) -
+                -sizeof(pAssocRsp->StatusCode) - sizeof(pAssocRsp->AId));
+    copySize = MIN(copySize, *ie_len_ptr);
+
+    /* Copy the IEEE TLVs in the assoc response back to the application */
+    if (copy_to_user(ie_data_ptr, (u8 *) pAssocRsp->IEBuffer, copySize)) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return -EFAULT;
+    }
+
+    /* Returned copy length */
+    *ie_len_ptr = copySize;
+
+    /* No error on return */
+    return WLAN_STATUS_SUCCESS;
+}
+
+#if (WIRELESS_EXT >= 18)
+/** 
+ *  @brief  Set IE 
+ *
+ *  Calls main function set_gen_ie_fuct that adds the inputted IE
+ *    to the genie buffer
+ *   
+ *  @param dev          A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param dwrq         A pointer to iw_point structure
+ *  @param extra        A pointer to extra data buf
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_gen_ie(struct net_device *dev,
+                struct iw_request_info *info,
+                struct iw_point *dwrq, char *extra)
+{
+    return wlan_set_gen_ie_helper(dev->priv, dwrq->pointer, dwrq->length);
+}
+
+/** 
+ *  @brief  Get IE 
+ *
+ *  Calls main function get_gen_ie_fuct that retrieves expected IEEE IEs
+ *    and places then in the iw_point structure
+ *   
+ *  @param dev          A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param dwrq         A pointer to iw_point structure
+ *  @param extra        A pointer to extra data buf
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_gen_ie(struct net_device *dev,
+                struct iw_request_info *info,
+                struct iw_point *dwrq, char *extra)
+{
+    return wlan_get_gen_ie_helper(dev->priv, dwrq->pointer, &dwrq->length);
+}
+
+/** 
+ *  @brief Set authentication mode
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_setauthalg(wlan_private * priv, int alg)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    PRINTM(INFO, "auth alg is %#x\n", alg);
+
+    switch (alg) {
+    case IW_AUTH_ALG_SHARED_KEY:
+        Adapter->SecInfo.AuthenticationMode = Wlan802_11AuthModeShared;
+        break;
+    case IW_AUTH_ALG_LEAP:
+        //clear WPA IE
+        wlan_set_wpa_ie_helper(priv, NULL, 0);
+        Adapter->SecInfo.AuthenticationMode = Wlan802_11AuthModeNetworkEAP;
+        break;
+    case IW_AUTH_ALG_OPEN_SYSTEM:
+    default:
+        Adapter->SecInfo.AuthenticationMode = Wlan802_11AuthModeOpen;
+        break;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief set authentication mode params
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_auth(struct net_device *dev, struct iw_request_info *info,
+              struct iw_param *vwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+    switch (vwrq->flags & IW_AUTH_INDEX) {
+    case IW_AUTH_CIPHER_PAIRWISE:
+    case IW_AUTH_CIPHER_GROUP:
+        if (vwrq->value & IW_AUTH_CIPHER_NONE)
+            priv->adapter->SecInfo.EncryptionMode = CIPHER_NONE;
+        else if (vwrq->value & IW_AUTH_CIPHER_WEP40)
+            priv->adapter->SecInfo.EncryptionMode = CIPHER_WEP40;
+        else if (vwrq->value & IW_AUTH_CIPHER_TKIP)
+            priv->adapter->SecInfo.EncryptionMode = CIPHER_TKIP;
+        else if (vwrq->value & IW_AUTH_CIPHER_CCMP)
+            priv->adapter->SecInfo.EncryptionMode = CIPHER_CCMP;
+        else if (vwrq->value & IW_AUTH_CIPHER_WEP104)
+            priv->adapter->SecInfo.EncryptionMode = CIPHER_WEP104;
+        break;
+    case IW_AUTH_80211_AUTH_ALG:
+        wlan_setauthalg(priv, vwrq->value);
+        break;
+    case IW_AUTH_WPA_ENABLED:
+        if (vwrq->value == FALSE)
+            wlan_set_wpa_ie_helper(priv, NULL, 0);
+        break;
+    case IW_AUTH_WPA_VERSION:
+    case IW_AUTH_KEY_MGMT:
+    case IW_AUTH_TKIP_COUNTERMEASURES:
+    case IW_AUTH_DROP_UNENCRYPTED:
+    case IW_AUTH_RX_UNENCRYPTED_EAPOL:
+    case IW_AUTH_ROAMING_CONTROL:
+    case IW_AUTH_PRIVACY_INVOKED:
+    default:
+        break;
+    }
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief  get authentication mode params 
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_auth(struct net_device *dev, struct iw_request_info *info,
+              struct iw_param *vwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    ENTER();
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+    switch (vwrq->flags & IW_AUTH_INDEX) {
+    case IW_AUTH_CIPHER_PAIRWISE:
+    case IW_AUTH_CIPHER_GROUP:
+        if (priv->adapter->SecInfo.EncryptionMode == CIPHER_NONE)
+            vwrq->value = IW_AUTH_CIPHER_NONE;
+        else if (priv->adapter->SecInfo.EncryptionMode == CIPHER_WEP40)
+            vwrq->value = IW_AUTH_CIPHER_WEP40;
+        else if (priv->adapter->SecInfo.EncryptionMode == CIPHER_TKIP)
+            vwrq->value = IW_AUTH_CIPHER_TKIP;
+        else if (priv->adapter->SecInfo.EncryptionMode == CIPHER_CCMP)
+            vwrq->value = IW_AUTH_CIPHER_CCMP;
+        else if (priv->adapter->SecInfo.EncryptionMode == CIPHER_WEP104)
+            vwrq->value = IW_AUTH_CIPHER_WEP104;
+        break;
+    case IW_AUTH_80211_AUTH_ALG:
+        if (Adapter->SecInfo.AuthenticationMode == Wlan802_11AuthModeShared)
+            vwrq->value = IW_AUTH_ALG_SHARED_KEY;
+        else if (Adapter->SecInfo.AuthenticationMode ==
+                 Wlan802_11AuthModeNetworkEAP)
+            vwrq->value = IW_AUTH_ALG_LEAP;
+        else
+            vwrq->value = IW_AUTH_ALG_OPEN_SYSTEM;
+        break;
+    case IW_AUTH_WPA_ENABLED:
+        if (Adapter->Wpa_ie_len > 0)
+            vwrq->value = TRUE;
+        else
+            vwrq->value = FALSE;
+        break;
+    case IW_AUTH_WPA_VERSION:
+    case IW_AUTH_KEY_MGMT:
+    case IW_AUTH_TKIP_COUNTERMEASURES:
+    case IW_AUTH_DROP_UNENCRYPTED:
+    case IW_AUTH_RX_UNENCRYPTED_EAPOL:
+    case IW_AUTH_ROAMING_CONTROL:
+    case IW_AUTH_PRIVACY_INVOKED:
+    default:
+        ret = -EOPNOTSUPP;
+        break;
+    }
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief  Request MLME operation 
+ *
+ *   
+ *  @param dev          A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param dwrq         A pointer to iw_point structure
+ *  @param extra        A pointer to extra data buf
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_mlme(struct net_device *dev,
+              struct iw_request_info *info,
+              struct iw_point *dwrq, char *extra)
+{
+    struct iw_mlme *mlme = (struct iw_mlme *) extra;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+    if ((mlme->cmd == IW_MLME_DEAUTH) || (mlme->cmd == IW_MLME_DISASSOC)) {
+        if (Adapter->InfrastructureMode == Wlan802_11Infrastructure &&
+            Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+            SendDeauthentication(priv);
+        } else if (Adapter->InfrastructureMode == Wlan802_11IBSS &&
+                   Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+            StopAdhocNetwork(priv);
+        }
+    }
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief  Extended version of encoding configuration 
+ *
+ *   
+ *  @param dev          A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param dwrq         A pointer to iw_point structure
+ *  @param extra        A pointer to extra data buf
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_encode_ext(struct net_device *dev,
+                    struct iw_request_info *info,
+                    struct iw_point *dwrq, char *extra)
+{
+    struct iw_encode_ext *ext = (struct iw_encode_ext *) extra;
+    wlan_private *priv = dev->priv;
+    WLAN_802_11_KEY *pkey;
+    int keyindex;
+    u8 *pKeyMaterial = NULL;
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+    keyindex = dwrq->flags & IW_ENCODE_INDEX;
+    if (keyindex > 4)
+        return -EINVAL;
+    if (ext->key_len > (dwrq->length - sizeof(struct iw_encode_ext)))
+        return -EINVAL;
+    pKeyMaterial = (u8 *) (ext + 1);
+    //Disable Key
+    if ((dwrq->flags & IW_ENCODE_DISABLED) && (ext->key_len == 0)) {
+        dwrq->length = 0;
+        wlan_set_encode_nonwpa(dev, info, dwrq, extra);
+        return WLAN_STATUS_SUCCESS;
+    }
+    //Set WEP key
+    if (ext->key_len <= MAX_WEP_KEY_SIZE) {
+        dwrq->length = ext->key_len;
+        wlan_set_encode_nonwpa(dev, info, dwrq, pKeyMaterial);
+        if (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {
+            dwrq->length = 0;
+            wlan_set_encode_nonwpa(dev, info, dwrq, extra);
+        }
+    } else {
+        pkey = kmalloc(sizeof(WLAN_802_11_KEY) + ext->key_len, GFP_KERNEL);
+        if (!pkey) {
+            PRINTM(INFO, "allocate key buffer failed!\n");
+            return -ENOMEM;
+        }
+        memset(pkey, 0, sizeof(WLAN_802_11_KEY) + ext->key_len);
+        memcpy((u8 *) pkey->BSSID, (u8 *) ext->addr.sa_data, ETH_ALEN);
+        pkey->KeyLength = ext->key_len;
+        memcpy(pkey->KeyMaterial, pKeyMaterial, ext->key_len);
+        pkey->KeyIndex = keyindex - 1;
+        if (pkey->KeyIndex == 0)
+            pkey->KeyIndex = 0x40000000;
+        if (ext->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID)
+            memcpy((u8 *) & pkey->KeyRSC, ext->rx_seq,
+                   IW_ENCODE_SEQ_MAX_SIZE);
+        pkey->Length = sizeof(WLAN_802_11_KEY) + ext->key_len;
+        wlan_set_encode_wpa(dev, info, dwrq, (u8 *) pkey);
+        kfree(pkey);
+    }
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief  Extended version of encoding configuration 
+ *
+ *   
+ *  @param dev          A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param dwrq         A pointer to iw_point structure
+ *  @param extra        A pointer to extra data buf
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_encode_ext(struct net_device *dev,
+                    struct iw_request_info *info,
+                    struct iw_point *dwrq, char *extra)
+{
+    return -EOPNOTSUPP;
+}
+#endif /* #if (WIRELESS_EXT >= 18) */
+
+/** 
+ *  @brief  Append/Reset IE buffer. 
+ *   
+ *  Pass an opaque block of data, expected to be IEEE IEs, to the driver 
+ *    for eventual passthrough to the firmware in an associate/join 
+ *    (and potentially start) command.
+ *
+ *  Data is appended to an existing buffer and then wrapped in a passthrough
+ *    TLV in the command API to the firmware.  The firmware treats the data
+ *    as a transparent passthrough to the transmitted management frame.
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param wrq          A pointer to iwreq structure    
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_gen_ie_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    return wlan_set_gen_ie_helper(priv,
+                                  wrq->u.data.pointer, wrq->u.data.length);
+}
+
+/** 
+ *  @brief  Get IE buffer from driver 
+ *   
+ *  Used to pass an opaque block of data, expected to be IEEE IEs,
+ *    back to the application.  Currently the data block passed
+ *    back to the application is the saved association response retrieved 
+ *    from the firmware.
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param wrq          A pointer to iwreq structure
+ *
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_gen_ie_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    return wlan_get_gen_ie_helper(priv,
+                                  wrq->u.data.pointer, &wrq->u.data.length);
+}
+
+/*
+ * iwconfig settable callbacks 
+ */
+static const iw_handler wlan_handler[] = {
+    (iw_handler) wlan_config_commit,    /* SIOCSIWCOMMIT */
+    (iw_handler) wlan_get_name, /* SIOCGIWNAME */
+    (iw_handler) NULL,          /* SIOCSIWNWID */
+    (iw_handler) NULL,          /* SIOCGIWNWID */
+    (iw_handler) wlan_set_freq, /* SIOCSIWFREQ */
+    (iw_handler) wlan_get_freq, /* SIOCGIWFREQ */
+    (iw_handler) wlan_set_mode, /* SIOCSIWMODE */
+    (iw_handler) wlan_get_mode, /* SIOCGIWMODE */
+    (iw_handler) wlan_set_sens, /* SIOCSIWSENS */
+    (iw_handler) wlan_get_sens, /* SIOCGIWSENS */
+    (iw_handler) NULL,          /* SIOCSIWRANGE */
+    (iw_handler) wlan_get_range,        /* SIOCGIWRANGE */
+    (iw_handler) NULL,          /* SIOCSIWPRIV */
+    (iw_handler) NULL,          /* SIOCGIWPRIV */
+    (iw_handler) NULL,          /* SIOCSIWSTATS */
+    (iw_handler) NULL,          /* SIOCGIWSTATS */
+#if WIRELESS_EXT > 15
+    iw_handler_set_spy,         /* SIOCSIWSPY */
+    iw_handler_get_spy,         /* SIOCGIWSPY */
+    iw_handler_set_thrspy,      /* SIOCSIWTHRSPY */
+    iw_handler_get_thrspy,      /* SIOCGIWTHRSPY */
+#else /* WIRELESS_EXT > 15 */
+#ifdef WIRELESS_SPY
+    (iw_handler) wlan_set_spy,  /* SIOCSIWSPY */
+    (iw_handler) wlan_get_spy,  /* SIOCGIWSPY */
+#else /* WIRELESS_SPY */
+    (iw_handler) NULL,          /* SIOCSIWSPY */
+    (iw_handler) NULL,          /* SIOCGIWSPY */
+#endif /* WIRELESS_SPY */
+    (iw_handler) NULL,          /* -- hole -- */
+    (iw_handler) NULL,          /* -- hole -- */
+#endif /* WIRELESS_EXT > 15 */
+    (iw_handler) wlan_set_wap,  /* SIOCSIWAP */
+    (iw_handler) wlan_get_wap,  /* SIOCGIWAP */
+#if WIRELESS_EXT >= 18
+    (iw_handler) wlan_set_mlme, /* SIOCSIWMLME  */
+#else
+    (iw_handler) NULL,          /* -- hole -- */
+#endif
+    //(iw_handler) wlan_get_aplist,         /* SIOCGIWAPLIST */
+    NULL,                       /* SIOCGIWAPLIST */
+#if WIRELESS_EXT > 13
+    (iw_handler) wlan_set_scan, /* SIOCSIWSCAN */
+    (iw_handler) wlan_get_scan, /* SIOCGIWSCAN */
+#else /* WIRELESS_EXT > 13 */
+    (iw_handler) NULL,          /* SIOCSIWSCAN */
+    (iw_handler) NULL,          /* SIOCGIWSCAN */
+#endif /* WIRELESS_EXT > 13 */
+    (iw_handler) wlan_set_essid,        /* SIOCSIWESSID */
+    (iw_handler) wlan_get_essid,        /* SIOCGIWESSID */
+    (iw_handler) wlan_set_nick, /* SIOCSIWNICKN */
+    (iw_handler) wlan_get_nick, /* SIOCGIWNICKN */
+    (iw_handler) NULL,          /* -- hole -- */
+    (iw_handler) NULL,          /* -- hole -- */
+    (iw_handler) wlan_set_rate, /* SIOCSIWRATE */
+    (iw_handler) wlan_get_rate, /* SIOCGIWRATE */
+    (iw_handler) wlan_set_rts,  /* SIOCSIWRTS */
+    (iw_handler) wlan_get_rts,  /* SIOCGIWRTS */
+    (iw_handler) wlan_set_frag, /* SIOCSIWFRAG */
+    (iw_handler) wlan_get_frag, /* SIOCGIWFRAG */
+    (iw_handler) wlan_set_txpow,        /* SIOCSIWTXPOW */
+    (iw_handler) wlan_get_txpow,        /* SIOCGIWTXPOW */
+    (iw_handler) wlan_set_retry,        /* SIOCSIWRETRY */
+    (iw_handler) wlan_get_retry,        /* SIOCGIWRETRY */
+    (iw_handler) NULL,          /* -- hole -- */
+    (iw_handler) wlan_get_encode,       /* SIOCGIWENCODE */
+    (iw_handler) wlan_set_power,        /* SIOCSIWPOWER */
+    (iw_handler) wlan_get_power,        /* SIOCGIWPOWER */
+#if (WIRELESS_EXT >= 18)
+    (iw_handler) NULL,          /* -- hole -- */
+    (iw_handler) NULL,          /* -- hole -- */
+    (iw_handler) wlan_set_gen_ie,       /* SIOCSIWGENIE */
+    (iw_handler) wlan_get_gen_ie,       /* SIOCGIWGENIE */
+    (iw_handler) wlan_set_auth, /* SIOCSIWAUTH  */
+    (iw_handler) wlan_get_auth, /* SIOCGIWAUTH  */
+    (iw_handler) wlan_set_encode_ext,   /* SIOCSIWENCODEEXT */
+    (iw_handler) wlan_get_encode_ext,   /* SIOCGIWENCODEEXT */
+#endif /* WIRELESSS_EXT >= 18 */
+};
+
+/*
+ * iwpriv settable callbacks 
+ */
+
+static const iw_handler wlan_private_handler[] = {
+    NULL,                       /* SIOCIWFIRSTPRIV */
+};
+
+static const struct iw_priv_args wlan_private_args[] = {
+    /*
+     * { cmd, set_args, get_args, name } 
+     */
+    {
+     WLANEXTSCAN,
+     IW_PRIV_TYPE_INT,
+     IW_PRIV_TYPE_CHAR | 2,
+     "extscan"},
+    {
+     WLANHOSTCMD,
+     IW_PRIV_TYPE_BYTE | 2047,
+     IW_PRIV_TYPE_BYTE | 2047,
+     "hostcmd"},
+    {
+     WLANARPFILTER,
+     IW_PRIV_TYPE_BYTE | 2047,
+     IW_PRIV_TYPE_BYTE | 2047,
+     "arpfilter"},
+    {
+     WLANREGRDWR,
+     IW_PRIV_TYPE_CHAR | 256,
+     IW_PRIV_TYPE_CHAR | 256,
+     "regrdwr"},
+    {
+     WLANCMD52RDWR,
+     IW_PRIV_TYPE_BYTE | 7,
+     IW_PRIV_TYPE_BYTE | 7,
+     "sdcmd52rw"},
+    {
+     WLANCMD53RDWR,
+     IW_PRIV_TYPE_CHAR | 32,
+     IW_PRIV_TYPE_CHAR | 32,
+     "sdcmd53rw"},
+    {
+     WLAN_SETCONF_GETCONF,
+     IW_PRIV_TYPE_BYTE | MAX_SETGET_CONF_SIZE,
+     IW_PRIV_TYPE_BYTE | MAX_SETGET_CONF_SIZE,
+     "setgetconf"},
+    {
+     WLANCISDUMP,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_BYTE | 512,
+     "getcis"},
+    {
+     WLANSCAN_TYPE,
+     IW_PRIV_TYPE_CHAR | 8,
+     IW_PRIV_TYPE_CHAR | 8,
+     "scantype"},
+    {
+     WLAN_SETINT_GETINT,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     ""},
+    {
+     WLANNF,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "getNF"},
+    {
+     WLANRSSI,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "getRSSI"},
+    {
+     WLANBGSCAN,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "bgscan"},
+    {
+     WLANENABLE11D,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "enable11d"},
+    {
+     WLANADHOCGRATE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "adhocgrate"},
+    {
+     WLANSDIOCLOCK,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "sdioclock"},
+    {
+     WLANWMM_ENABLE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "wmm"},
+    {
+     WLANNULLGEN,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "uapsdnullgen"},
+    {
+     WLANADHOCCSET,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "setcoalescing"},
+    {
+     WLAN_ADHOC_G_PROT,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "adhocgprot"},
+
+    {
+     WLAN_SETONEINT_GETONEINT,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_INT | 1,
+     ""},
+    {
+     WLAN_WMM_QOSINFO,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_INT | 1,
+     "wmm_qosinfo"},
+    {
+     WLAN_LISTENINTRVL,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_INT | 1,
+     "lolisteninter"},
+    {
+     WLAN_FW_WAKEUP_METHOD,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_INT | 1,
+     "fwwakeupmethod"},
+    {
+     WLAN_NULLPKTINTERVAL,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_INT | 1,
+     "psnullinterval"},
+    {
+     WLAN_BCN_MISS_TIMEOUT,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_INT | 1,
+     "bcnmisto"},
+    {
+     WLAN_ADHOC_AWAKE_PERIOD,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_INT | 1,
+     "adhocawakepd"},
+    {
+     WLAN_LDO,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_INT | 1,
+     "ldocfg"},
+    {
+     WLAN_SDIO_MODE,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_INT | 1,
+     "sdiomode"},
+    {
+     WLAN_RTS_CTS_CTRL,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_INT | 1,
+     "rtsctsctrl"},
+    {
+     WLAN_AUTODEEPSLEEP,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_INT | 1,
+     "autodeepsleep"},
+    {
+     WLAN_WAKEUP_MT,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_INT | 1,
+     "wakeupmt"},
+    /* Using iwpriv sub-command feature */
+    {
+     WLAN_SETONEINT_GETNONE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_NONE,
+     ""},
+    {
+     WLAN_SUBCMD_SETRXANTENNA,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_NONE,
+     "setrxant"},
+    {
+     WLAN_SUBCMD_SETTXANTENNA,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_NONE,
+     "settxant"},
+    {
+     WLANSETAUTHALG,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_NONE,
+     "authalgs",
+     },
+    {
+     WLANSETENCRYPTIONMODE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_NONE,
+     "encryptionmode",
+     },
+    {
+     WLANSETREGION,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_NONE,
+     "setregioncode"},
+    {
+     WLAN_SET_LISTEN_INTERVAL,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_NONE,
+     "setlisteninter"},
+    {
+     WLAN_SET_MULTIPLE_DTIM,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_NONE,
+     "setmultipledtim"},
+    {
+     WLANSETBCNAVG,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_NONE,
+     "setbcnavg"},
+    {
+     WLANSETDATAAVG,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_NONE,
+     "setdataavg"},
+    {
+     WLANASSOCIATE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_NONE,
+     "associate"},
+    {
+     WLAN_SETNONE_GETONEINT,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     ""},
+    {
+     WLANGETREGION,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "getregioncode"},
+    {
+     WLAN_GET_LISTEN_INTERVAL,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "getlisteninter"},
+    {
+     WLAN_GET_MULTIPLE_DTIM,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "getmultipledtim"},
+    {
+     WLAN_GET_TX_RATE,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "gettxrate"},
+    {
+     WLANGETBCNAVG,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "getbcnavg"},
+    {
+     WLANGETDATAAVG,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "getdataavg"},
+    {
+     WLANGETDTIM,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "getdtim"},
+    {
+     WLAN_SETNONE_GETTWELVE_CHAR,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_CHAR | 12,
+     ""},
+    {
+     WLAN_SUBCMD_GETRXANTENNA,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_CHAR | 12,
+     "getrxant"},
+    {
+     WLAN_SUBCMD_GETTXANTENNA,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_CHAR | 12,
+     "gettxant"},
+    {
+     WLAN_GET_TSF,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_CHAR | 12,
+     "gettsf"},
+    {
+     WLAN_WPS_SESSION,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_CHAR | 12,
+     "wpssession"},
+    {
+     WLANDEEPSLEEP,
+     IW_PRIV_TYPE_CHAR | 1,
+     IW_PRIV_TYPE_CHAR | 6,
+     "deepsleep"},
+    {
+     WLANHOSTSLEEPCFG,
+     IW_PRIV_TYPE_CHAR | 31,
+     IW_PRIV_TYPE_NONE,
+     "hostsleepcfg"},
+    {
+     WLAN_SETNONE_GETNONE,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_NONE,
+     ""},
+    {
+     WLANDEAUTH,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_NONE,
+     "deauth"},
+    {
+     WLANADHOCSTOP,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_NONE,
+     "adhocstop"},
+    {
+     WLANRADIOON,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_NONE,
+     "radioon"},
+    {
+     WLANRADIOOFF,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_NONE,
+     "radiooff"},
+    {
+     WLANREMOVEADHOCAES,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_NONE,
+     "rmaeskey"},
+#ifdef REASSOCIATION
+    {
+     WLANREASSOCIATIONAUTO,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_NONE,
+     "reasso-on"},
+    {
+     WLANREASSOCIATIONUSER,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_NONE,
+     "reasso-off"},
+#endif /* REASSOCIATION */
+    {
+     WLANWLANIDLEON,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_NONE,
+     "wlanidle-on"},
+    {
+     WLANWLANIDLEOFF,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_NONE,
+     "wlanidle-off"},
+    {
+     WLAN_SET64CHAR_GET64CHAR,
+     IW_PRIV_TYPE_CHAR | 64,
+     IW_PRIV_TYPE_CHAR | 64,
+     ""},
+    {
+     WLANSLEEPPARAMS,
+     IW_PRIV_TYPE_CHAR | 64,
+     IW_PRIV_TYPE_CHAR | 64,
+     "sleepparams"},
+
+    {
+     WLAN_BCA_TIMESHARE,
+     IW_PRIV_TYPE_CHAR | 64,
+     IW_PRIV_TYPE_CHAR | 64,
+     "bca-ts"},
+    {
+     WLANSCAN_MODE,
+     IW_PRIV_TYPE_CHAR | 64,
+     IW_PRIV_TYPE_CHAR | 64,
+     "scanmode"},
+    {
+     WLAN_GET_ADHOC_STATUS,
+     IW_PRIV_TYPE_CHAR | 64,
+     IW_PRIV_TYPE_CHAR | 64,
+     "getadhocstatus"},
+    {
+     WLAN_SET_GEN_IE,
+     IW_PRIV_TYPE_CHAR | 64,
+     IW_PRIV_TYPE_CHAR | 64,
+     "setgenie"},
+    {
+     WLAN_GET_GEN_IE,
+     IW_PRIV_TYPE_CHAR | 64,
+     IW_PRIV_TYPE_CHAR | 64,
+     "getgenie"},
+    {
+     WLAN_WMM_QUEUE_STATUS,
+     IW_PRIV_TYPE_CHAR | 64,
+     IW_PRIV_TYPE_CHAR | 64,
+     "qstatus"},
+    {
+     WLAN_SETWORDCHAR_GETNONE,
+     IW_PRIV_TYPE_CHAR | 32,
+     IW_PRIV_TYPE_NONE,
+     ""},
+    {
+     WLANSETADHOCAES,
+     IW_PRIV_TYPE_CHAR | 32,
+     IW_PRIV_TYPE_NONE,
+     "setaeskey"},
+    {
+     WLAN_SETONEINT_GETWORDCHAR,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_CHAR | 128,
+     ""},
+    {
+     WLANGETADHOCAES,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_CHAR | 128,
+     "getaeskey"},
+    {
+     WLANVERSION,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_CHAR | 128,
+     "version"},
+    {
+     WLANVEREXT,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_CHAR | 128,
+     "verext"},
+    {
+     WLANSETWPAIE,
+     IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | 24,
+     IW_PRIV_TYPE_NONE,
+     "setwpaie"},
+    {
+     WLANGETLOG,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_CHAR | GETLOG_BUFSIZE,
+     "getlog"},
+    {
+     WLAN_SET_GET_SIXTEEN_INT,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     ""},
+    {
+     WLAN_TPCCFG,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "tpccfg"},
+    {
+     WLAN_SCANPROBES,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "scanprobes"},
+    {
+     WLAN_LED_GPIO_CTRL,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "ledgpio"},
+    {
+     WLAN_SLEEP_PERIOD,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "sleeppd"},
+    {
+     WLAN_ADAPT_RATESET,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "rateadapt"},
+
+    {
+     WLAN_INACTIVITY_TIMEOUT,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "inactivityto"},
+    {
+     WLANSNR,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "getSNR"},
+    {
+     WLAN_GET_RATE,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "getrate"},
+    {
+     WLAN_GET_RXINFO,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "getrxinfo"},
+    {
+     WLAN_SET_ATIM_WINDOW,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "atimwindow"},
+    {
+     WLAN_BEACON_INTERVAL,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "bcninterval"},
+    {
+     WLAN_SDIO_PULL_CTRL,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "sdiopullctrl"},
+    {
+     WLAN_SCAN_TIME,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "scantime"},
+    {
+     WLAN_DATA_SUBSCRIBE_EVENT,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "dataevtcfg"},
+    {
+     WLAN_TXCONTROL,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "txcontrol"},
+    {
+     WLANHSCFG,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "hscfg"},
+    {
+     WLANHSSETPARA,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "hssetpara"},
+#ifdef DEBUG_LEVEL1
+    {
+     WLAN_DRV_DBG,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "drvdbg"},
+#endif
+    {
+     WLAN_SET_GET_2K,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     ""},
+    {
+     WLAN_SET_USER_SCAN,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     "setuserscan"},
+    {
+     WLAN_GET_SCAN_TABLE,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     "getscantable"},
+    {
+     WLAN_SET_MRVL_TLV,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     "setmrvltlv"},
+    {
+     WLAN_GET_ASSOC_RSP,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     "getassocrsp"},
+    {
+     WLAN_ADDTS_REQ,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     "addts"},
+    {
+     WLAN_DELTS_REQ,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     "delts"},
+    {
+     WLAN_QUEUE_CONFIG,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     "qconfig"},
+    {
+     WLAN_QUEUE_STATS,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     "qstats"},
+    {
+     WLAN_TX_PKT_STATS,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     "txpktstats"},
+    {
+     WLAN_GET_CFP_TABLE,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     "getcfptable"},
+};
+
+struct iw_handler_def wlan_handler_def = {
+  num_standard:sizeof(wlan_handler) / sizeof(iw_handler),
+  num_private:sizeof(wlan_private_handler) / sizeof(iw_handler),
+  num_private_args:sizeof(wlan_private_args) /
+        sizeof(struct iw_priv_args),
+  standard:(iw_handler *) wlan_handler,
+  private:(iw_handler *) wlan_private_handler,
+  private_args:(struct iw_priv_args *) wlan_private_args,
+};
+
+/** 
+ *  @brief get the channel frequency power info with specific channel
+ *   
+ *  @param band	 		it can be BAND_A, BAND_G or BAND_B
+ *  @param channel       	the channel for looking	
+ *  @param region_channel 	A pointer to REGION_CHANNEL structure
+ *  @return 	   			A pointer to CHANNEL_FREQ_POWER structure or NULL if not find.
+ */
+
+CHANNEL_FREQ_POWER *
+get_cfp_by_band_and_channel(u8 band, u16 channel,
+                            REGION_CHANNEL * region_channnel)
+{
+    REGION_CHANNEL *rc;
+    CHANNEL_FREQ_POWER *cfp = NULL;
+    int i, j;
+
+    for (j = 0; !cfp && (j < MAX_REGION_CHANNEL_NUM); j++) {
+        rc = &region_channnel[j];
+
+        if (!rc->Valid || !rc->CFP)
+            continue;
+        if (rc->Band != band)
+            continue;
+        if (channel == FIRST_VALID_CHANNEL)
+            cfp = &rc->CFP[0];
+        else {
+            for (i = 0; i < rc->NrCFP; i++) {
+                if (rc->CFP[i].Channel == channel) {
+                    cfp = &rc->CFP[i];
+                    break;
+                }
+            }
+        }
+    }
+
+    if (!cfp && channel)
+        PRINTM(INFO, "get_cfp_by_band_and_channel(): cannot find "
+               "cfp by band %d & channel %d\n", band, channel);
+
+    LEAVE();
+    return cfp;
+}
+
+/** 
+ *  @brief wlan hostcmd ioctl handler
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param req		        A pointer to ifreq structure
+ *  @param cmd			command 
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_hostcmd_ioctl(struct net_device *dev, struct ifreq *req, int cmd)
+{
+    u8 *tempResponseBuffer;
+    CmdCtrlNode *pCmdNode;
+    HostCmd_DS_GEN *pCmdPtr;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    u16 wait_option = 0;
+    struct iwreq *wrq = (struct iwreq *) req;
+
+    ENTER();
+
+    if ((wrq->u.data.pointer == NULL) || (wrq->u.data.length < S_DS_GEN)) {
+        PRINTM(INFO,
+               "wlan_hostcmd_ioctl() corrupt data: pointer=%p, length=%d\n",
+               wrq->u.data.pointer, wrq->u.data.length);
+        return -EFAULT;
+    }
+
+    /*
+     * Get a free command control node 
+     */
+    if (!(pCmdNode = GetFreeCmdCtrlNode(priv))) {
+        PRINTM(INFO, "Failed GetFreeCmdCtrlNode\n");
+        return -ENOMEM;
+    }
+
+    if (!
+        (tempResponseBuffer =
+         kmalloc(MRVDRV_SIZE_OF_CMD_BUFFER, GFP_KERNEL))) {
+        PRINTM(INFO, "ERROR: Failed to allocate response buffer!\n");
+        CleanupAndInsertCmd(priv, pCmdNode);
+        return -ENOMEM;
+    }
+
+    wait_option |= HostCmd_OPTION_WAITFORRSP;
+
+    SetCmdCtrlNode(priv, pCmdNode, 0, wait_option, NULL);
+    init_waitqueue_head(&pCmdNode->cmdwait_q);
+
+    pCmdPtr = (HostCmd_DS_GEN *) pCmdNode->BufVirtualAddr;
+
+    /*
+     * Copy the whole command into the command buffer 
+     */
+    if (copy_from_user(pCmdPtr, wrq->u.data.pointer, wrq->u.data.length)) {
+        PRINTM(INFO, "Copy from user failed\n");
+        kfree(tempResponseBuffer);
+        CleanupAndInsertCmd(priv, pCmdNode);
+        return -EFAULT;
+    }
+
+    if (pCmdPtr->Size < S_DS_GEN) {
+        PRINTM(INFO, "wlan_hostcmd_ioctl() invalid cmd size: Size=%d\n",
+               pCmdPtr->Size);
+        kfree(tempResponseBuffer);
+        CleanupAndInsertCmd(priv, pCmdNode);
+        return -EFAULT;
+    }
+
+    pCmdNode->pdata_buf = tempResponseBuffer;
+    pCmdNode->CmdFlags |= CMD_F_HOSTCMD;
+
+    pCmdPtr->Result = 0;
+
+    PRINTM(INFO, "HOSTCMD Command: 0x%04x Size: %d\n",
+           pCmdPtr->Command, pCmdPtr->Size);
+    HEXDUMP("Command Data", (u8 *) (pCmdPtr), MIN(32, pCmdPtr->Size));
+    PRINTM(INFO, "Copying data from : (user)0x%p -> 0x%p(driver)\n",
+           req->ifr_data, pCmdPtr);
+
+    pCmdNode->CmdWaitQWoken = FALSE;
+    pCmdPtr->Command = wlan_cpu_to_le16(pCmdPtr->Command);
+    pCmdPtr->Size = wlan_cpu_to_le16(pCmdPtr->Size);
+    QueueCmd(Adapter, pCmdNode, TRUE);
+    wake_up_interruptible(&priv->MainThread.waitQ);
+
+    if (wait_option & HostCmd_OPTION_WAITFORRSP) {
+        /* Sleep until response is generated by FW */
+        wait_event_interruptible(pCmdNode->cmdwait_q,
+                                 pCmdNode->CmdWaitQWoken);
+    }
+
+    /* Copy the response back to user space */
+    pCmdPtr = (HostCmd_DS_GEN *) tempResponseBuffer;
+
+    if (copy_to_user(wrq->u.data.pointer, tempResponseBuffer, pCmdPtr->Size))
+        PRINTM(INFO, "ERROR: copy_to_user failed!\n");
+    wrq->u.data.length = pCmdPtr->Size;
+    kfree(tempResponseBuffer);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief wlan arpfilter ioctl handler
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param req		        A pointer to ifreq structure
+ *  @param cmd			command 
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_arpfilter_ioctl(struct net_device *dev, struct ifreq *req, int cmd)
+{
+    wlan_private *priv = dev->priv;
+    struct iwreq *wrq = (struct iwreq *) req;
+    wlan_adapter *Adapter = priv->adapter;
+    MrvlIEtypesHeader_t hdr;
+
+    ENTER();
+
+    if ((wrq->u.data.pointer == NULL)
+        || (wrq->u.data.length < sizeof(MrvlIEtypesHeader_t))
+        || (wrq->u.data.length > sizeof(Adapter->ArpFilter))) {
+        PRINTM(INFO,
+               "wlan_arpfilter_ioctl() corrupt data: pointer=%p, length=%d\n",
+               wrq->u.data.pointer, wrq->u.data.length);
+        return -EFAULT;
+    }
+
+    if (copy_from_user(&hdr, wrq->u.data.pointer, sizeof(hdr))) {
+        PRINTM(INFO, "Copy from user failed\n");
+        return -EFAULT;
+    }
+
+    if (hdr.Len == 0) {
+        Adapter->ArpFilterSize = 0;
+        memset(Adapter->ArpFilter, 0, sizeof(Adapter->ArpFilter));
+    } else {
+        Adapter->ArpFilterSize = wrq->u.data.length;
+
+        PRINTM(INFO, "Copying data from : (user)0x%p -> 0x%p(driver)\n",
+               wrq->u.data.pointer, Adapter->ArpFilter);
+        if (copy_from_user(Adapter->ArpFilter, wrq->u.data.pointer,
+                           Adapter->ArpFilterSize)) {
+            Adapter->ArpFilterSize = 0;
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+
+        HEXDUMP("ArpFilter", Adapter->ArpFilter, Adapter->ArpFilterSize);
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get Rx Info 
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wreq		        A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success
+ */
+static int
+wlan_get_rxinfo(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int data[2];
+    ENTER();
+    data[0] = Adapter->SNR[TYPE_RXPD][TYPE_NOAVG];
+    data[1] = Adapter->RxPDRate;
+    if (copy_to_user(wrq->u.data.pointer, data, sizeof(int) * 2)) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return -EFAULT;
+    }
+    wrq->u.data.length = 2;
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get SNR 
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wreq		        A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_snr(wlan_private * priv, struct iwreq *wrq)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+    int data[4];
+
+    ENTER();
+
+    memset(data, 0, sizeof(data));
+    if (wrq->u.data.length) {
+        if (copy_from_user
+            (data, wrq->u.data.pointer,
+             MIN(wrq->u.data.length, 4) * sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+    }
+    if ((wrq->u.data.length == 0) || (data[0] == 0) || (data[0] == 1)) {
+        if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+            ret = PrepareAndSendCommand(priv,
+                                        HostCmd_CMD_802_11_RSSI,
+                                        0, HostCmd_OPTION_WAITFORRSP,
+                                        0, NULL);
+
+            if (ret) {
+                LEAVE();
+                return ret;
+            }
+        }
+    }
+
+    if (wrq->u.data.length == 0) {
+        data[0] = Adapter->SNR[TYPE_BEACON][TYPE_NOAVG];
+        data[1] = Adapter->SNR[TYPE_BEACON][TYPE_AVG];
+        if ((jiffies - Adapter->RxPDAge) > HZ)  //data expired after 1 second
+            data[2] = 0;
+        else
+            data[2] = Adapter->SNR[TYPE_RXPD][TYPE_NOAVG];
+        data[3] = Adapter->SNR[TYPE_RXPD][TYPE_AVG] / AVG_SCALE;
+        if (copy_to_user(wrq->u.data.pointer, data, sizeof(int) * 4)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return -EFAULT;
+        }
+        wrq->u.data.length = 4;
+    } else if (data[0] == 0) {
+        data[0] = Adapter->SNR[TYPE_BEACON][TYPE_NOAVG];
+        if (copy_to_user(wrq->u.data.pointer, data, sizeof(int))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return -EFAULT;
+        }
+        wrq->u.data.length = 1;
+    } else if (data[0] == 1) {
+        data[0] = Adapter->SNR[TYPE_BEACON][TYPE_AVG];
+        if (copy_to_user(wrq->u.data.pointer, data, sizeof(int))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return -EFAULT;
+        }
+        wrq->u.data.length = 1;
+    } else if (data[0] == 2) {
+        if ((jiffies - Adapter->RxPDAge) > HZ)  //data expired after 1 second
+            data[0] = 0;
+        else
+            data[0] = Adapter->SNR[TYPE_RXPD][TYPE_NOAVG];
+        if (copy_to_user(wrq->u.data.pointer, data, sizeof(int))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return -EFAULT;
+        }
+        wrq->u.data.length = 1;
+    } else if (data[0] == 3) {
+        data[0] = Adapter->SNR[TYPE_RXPD][TYPE_AVG] / AVG_SCALE;
+        if (copy_to_user(wrq->u.data.pointer, data, sizeof(int))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return -EFAULT;
+        }
+        wrq->u.data.length = 1;
+    } else {
+        return -ENOTSUPP;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get/Set SDIO PULL CTRL 
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wreq		        A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_sdio_pull_ctrl(wlan_private * priv, struct iwreq *wrq)
+{
+    int data[2];
+    HostCmd_DS_SDIO_PULL_CTRL sdio_pull_ctrl;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+    memset(&sdio_pull_ctrl, 0, sizeof(sdio_pull_ctrl));
+    if (wrq->u.data.length > 0) {
+        if (copy_from_user(data, wrq->u.data.pointer, sizeof(data))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+        PRINTM(INFO, "WLAN SET SDIO PULL CTRL: %d %d\n", data[0], data[1]);
+        sdio_pull_ctrl.Action = HostCmd_ACT_GEN_SET;
+        sdio_pull_ctrl.PullUp = data[0];
+        sdio_pull_ctrl.PullDown = data[1];
+    } else {
+        sdio_pull_ctrl.Action = HostCmd_ACT_GEN_GET;
+    }
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_SDIO_PULL_CTRL,
+                                0, HostCmd_OPTION_WAITFORRSP,
+                                0, (void *) &sdio_pull_ctrl);
+    data[0] = sdio_pull_ctrl.PullUp;
+    data[1] = sdio_pull_ctrl.PullDown;
+    wrq->u.data.length = 2;
+    if (copy_to_user
+        (wrq->u.data.pointer, data, sizeof(int) * wrq->u.data.length)) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return -EFAULT;
+    }
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get/Set scan time
+ *   
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wreq		A pointer to iwreq structure
+ *  @return    		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_scan_time(wlan_private * priv, struct iwreq *wrq)
+{
+    int data[3] = { 0, 0, 0 };
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (wrq->u.data.length > 0 && wrq->u.data.length <= 3) {
+        if (copy_from_user
+            (data, wrq->u.data.pointer, sizeof(int) * wrq->u.data.length)) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+
+        PRINTM(INFO,
+               "WLAN SET Scan Time: Specific %d, Active %d, Passive %d\n",
+               data[0], data[1], data[2]);
+        if (data[0]) {
+            if (data[0] > MRVDRV_MAX_ACTIVE_SCAN_CHAN_TIME) {
+                PRINTM(MSG,
+                       "Invalid parameter, max specific scan time is %d ms\n",
+                       MRVDRV_MAX_ACTIVE_SCAN_CHAN_TIME);
+                return -EINVAL;
+            }
+            Adapter->SpecificScanTime = data[0];
+        }
+        if (data[1]) {
+            if (data[1] > MRVDRV_MAX_ACTIVE_SCAN_CHAN_TIME) {
+                PRINTM(MSG,
+                       "Invalid parameter, max active scan time is %d ms\n",
+                       MRVDRV_MAX_ACTIVE_SCAN_CHAN_TIME);
+                return -EINVAL;
+            }
+            Adapter->ActiveScanTime = data[1];
+        }
+        if (data[2]) {
+            if (data[2] > MRVDRV_MAX_PASSIVE_SCAN_CHAN_TIME) {
+                PRINTM(MSG,
+                       "Invalid parameter, max passive scan time is %d ms\n",
+                       MRVDRV_MAX_PASSIVE_SCAN_CHAN_TIME);
+                return -EINVAL;
+            }
+            Adapter->PassiveScanTime = data[2];
+        }
+    }
+
+    data[0] = Adapter->SpecificScanTime;
+    data[1] = Adapter->ActiveScanTime;
+    data[2] = Adapter->PassiveScanTime;
+    wrq->u.data.length = 3;
+    if (copy_to_user
+        (wrq->u.data.pointer, data, sizeof(int) * wrq->u.data.length)) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return -EFAULT;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get/Set Adhoc beacon Interval 
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wreq		        A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_beacon_interval(wlan_private * priv, struct iwreq *wrq)
+{
+    int data[2];
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (wrq->u.data.length > 0) {
+        if (copy_from_user(data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+
+        PRINTM(INFO, "WLAN SET BEACON INTERVAL: %d\n", data[0]);
+        if ((data[0] > MRVDRV_MAX_BEACON_INTERVAL) ||
+            (data[0] < MRVDRV_MIN_BEACON_INTERVAL))
+            return -ENOTSUPP;
+        Adapter->BeaconPeriod = data[0];
+    }
+    data[0] = Adapter->BeaconPeriod;
+    wrq->u.data.length = 1;
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        data[1] = Adapter->CurBssParams.BSSDescriptor.BeaconPeriod;
+        wrq->u.data.length = 2;
+    }
+    if (copy_to_user
+        (wrq->u.data.pointer, data, sizeof(int) * wrq->u.data.length)) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return -EFAULT;
+    }
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get/Set Adhoc ATIM Window 
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wreq		        A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_ATIM_Window(wlan_private * priv, struct iwreq *wrq)
+{
+    int data[2];
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (wrq->u.data.length > 0) {
+        if (copy_from_user(data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+
+        PRINTM(INFO, "WLAN SET ATIM WINDOW: %d\n", data[0]);
+        Adapter->AtimWindow = data[0];
+        Adapter->AtimWindow = MIN(Adapter->AtimWindow, 50);
+    }
+    data[0] = Adapter->AtimWindow;
+    wrq->u.data.length = 1;
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        data[1] = Adapter->CurBssParams.BSSDescriptor.ATIMWindow;
+        wrq->u.data.length = 2;
+    }
+    if (copy_to_user
+        (wrq->u.data.pointer, data, sizeof(int) * wrq->u.data.length)) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return -EFAULT;
+    }
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get/Set data subscribe event
+ *   
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wreq		A pointer to iwreq structure
+ *  @return    		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_data_subscribe_event(wlan_private * priv, struct iwreq *wrq)
+{
+    int data[9];
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    memset(data, 0, sizeof(data));
+    if (wrq->u.data.length > 9)
+        return -EFAULT;
+    if (wrq->u.data.length > 0) {
+        if (copy_from_user
+            (data, wrq->u.data.pointer, sizeof(int) * wrq->u.data.length)) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+        memset(&Adapter->subevent, 0, sizeof(Adapter->subevent));
+        Adapter->subevent.EventsBitmap = (u16) data[0];
+        Adapter->subevent.Rssi_low.value = (u8) data[1];
+        Adapter->subevent.Rssi_low.Freq = (u8) data[2];
+        Adapter->subevent.Snr_low.value = (u8) data[3];
+        Adapter->subevent.Snr_low.Freq = (u8) data[4];
+        Adapter->subevent.Rssi_high.value = (u8) data[5];
+        Adapter->subevent.Rssi_high.Freq = (u8) data[6];
+        Adapter->subevent.Snr_high.value = (u8) data[7];
+        Adapter->subevent.Snr_high.Freq = (u8) data[8];
+    } else {
+        data[0] = (int) Adapter->subevent.EventsBitmap;
+        data[1] = (int) Adapter->subevent.Rssi_low.value;
+        data[2] = (int) Adapter->subevent.Rssi_low.Freq;
+        data[3] = (int) Adapter->subevent.Snr_low.value;
+        data[4] = (int) Adapter->subevent.Snr_low.Freq;
+        data[5] = (int) Adapter->subevent.Rssi_high.value;
+        data[6] = (int) Adapter->subevent.Rssi_high.Freq;
+        data[7] = (int) Adapter->subevent.Snr_high.value;
+        data[8] = (int) Adapter->subevent.Snr_high.Freq;
+    }
+    wrq->u.data.length = 9;
+    if (copy_to_user(wrq->u.data.pointer, data, sizeof(data))) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return -EFAULT;
+    }
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get RSSI 
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wreq		        A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_rssi(wlan_private * priv, struct iwreq *wrq)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+    int temp;
+    int data = 0;
+    int *val;
+
+    ENTER();
+    data = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+    if ((data == 0) || (data == 1)) {
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_802_11_RSSI,
+                                    0, HostCmd_OPTION_WAITFORRSP, 0, NULL);
+        if (ret) {
+            LEAVE();
+            return ret;
+        }
+    }
+
+    switch (data) {
+    case 0:
+
+        temp = CAL_RSSI(Adapter->SNR[TYPE_BEACON][TYPE_NOAVG],
+                        Adapter->NF[TYPE_BEACON][TYPE_NOAVG]);
+        break;
+    case 1:
+        temp = CAL_RSSI(Adapter->SNR[TYPE_BEACON][TYPE_AVG],
+                        Adapter->NF[TYPE_BEACON][TYPE_AVG]);
+        break;
+    case 2:
+        if ((jiffies - Adapter->RxPDAge) > HZ)  //data expired after 1 second
+            temp = 0;
+        else
+            temp = CAL_RSSI(Adapter->SNR[TYPE_RXPD][TYPE_NOAVG],
+                            Adapter->NF[TYPE_RXPD][TYPE_NOAVG]);
+        break;
+    case 3:
+        temp = CAL_RSSI(Adapter->SNR[TYPE_RXPD][TYPE_AVG] / AVG_SCALE,
+                        Adapter->NF[TYPE_RXPD][TYPE_AVG] / AVG_SCALE);
+        break;
+    default:
+        return -ENOTSUPP;
+    }
+    val = (int *) wrq->u.name;
+    *val = temp;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get NF
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wreq		        A pointer to iwreq structure 
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_nf(wlan_private * priv, struct iwreq *wrq)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+    int temp;
+    int data = 0;
+    int *val;
+
+    ENTER();
+    data = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+    if ((data == 0) || (data == 1)) {
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_802_11_RSSI,
+                                    0, HostCmd_OPTION_WAITFORRSP, 0, NULL);
+
+        if (ret) {
+            LEAVE();
+            return ret;
+        }
+    }
+
+    switch (data) {
+    case 0:
+        temp = Adapter->NF[TYPE_BEACON][TYPE_NOAVG];
+        break;
+    case 1:
+        temp = Adapter->NF[TYPE_BEACON][TYPE_AVG];
+        break;
+    case 2:
+        if ((jiffies - Adapter->RxPDAge) > HZ)  //data expired after 1 second
+            temp = 0;
+        else
+            temp = Adapter->NF[TYPE_RXPD][TYPE_NOAVG];
+        break;
+    case 3:
+        temp = Adapter->NF[TYPE_RXPD][TYPE_AVG] / AVG_SCALE;
+        break;
+    default:
+        return -ENOTSUPP;
+    }
+
+    temp = CAL_NF(temp);
+
+    PRINTM(INFO, "***temp = %d\n", temp);
+    val = (int *) wrq->u.name;
+    *val = temp;
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Remove AES key
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_remove_aes(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    WLAN_802_11_KEY key;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (Adapter->InfrastructureMode != Wlan802_11IBSS ||
+        Adapter->MediaConnectStatus == WlanMediaStateConnected)
+        return -EOPNOTSUPP;
+
+    Adapter->AdhocAESEnabled = FALSE;
+
+    memset(&key, 0, sizeof(WLAN_802_11_KEY));
+    PRINTM(INFO, "WPA2: DISABLE AES_KEY\n");
+    key.KeyLength = WPA_AES_KEY_LEN;
+    key.KeyIndex = 0x40000000;
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_KEY_MATERIAL,
+                                HostCmd_ACT_SET,
+                                HostCmd_OPTION_WAITFORRSP,
+                                !(KEY_INFO_ENABLED), &key);
+
+    LEAVE();
+
+    return ret;
+}
+
+/** 
+ *  @brief Get Support Rates
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wrq			A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_getrate_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    WLAN_802_11_RATES rates;
+    int rate[sizeof(rates)];
+    int i;
+
+    ENTER();
+
+    memset(rates, 0, sizeof(rates));
+    memset(rate, 0, sizeof(rate));
+    wrq->u.data.length = get_active_data_rates(Adapter, rates);
+    if (wrq->u.data.length > sizeof(rates))
+        wrq->u.data.length = sizeof(rates);
+
+    for (i = 0; i < wrq->u.data.length; i++) {
+        rates[i] &= ~0x80;
+        rate[i] = rates[i];
+    }
+
+    if (copy_to_user
+        (wrq->u.data.pointer, rate, wrq->u.data.length * sizeof(int))) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return -EFAULT;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get TxRate
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_txrate_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int *pdata;
+    struct iwreq *wrq = (struct iwreq *) req;
+    int ret = WLAN_STATUS_SUCCESS;
+    ENTER();
+    Adapter->TxRate = 0;
+    PRINTM(INFO, "wlan_get_txrate_ioctl\n");
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_TX_RATE_QUERY,
+                                HostCmd_ACT_GET, HostCmd_OPTION_WAITFORRSP,
+                                0, NULL);
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+    pdata = (int *) wrq->u.name;
+    *pdata = (int) Adapter->TxRate;
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get DTIM
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_dtim_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    struct iwreq *wrq = (struct iwreq *) req;
+    int *pdata;
+    int ret = WLAN_STATUS_FAILURE;
+
+    ENTER();
+
+    /* The DTIM value is valid only in connected state */
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        Adapter->Dtim = 0;
+        ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_SNMP_MIB,
+                                    HostCmd_ACT_GET,
+                                    HostCmd_OPTION_WAITFORRSP,
+                                    OID_802_11_DTIM, NULL);
+        if (!ret) {
+            pdata = (int *) wrq->u.name;
+            *pdata = (int) Adapter->Dtim;
+        }
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get Adhoc Status
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wrq			A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_adhoc_status_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    char status[64];
+    wlan_adapter *Adapter = priv->adapter;
+
+    memset(status, 0, sizeof(status));
+
+    switch (Adapter->InfrastructureMode) {
+    case Wlan802_11IBSS:
+        if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+            if (Adapter->AdhocCreate == TRUE)
+                strcpy(status, "AdhocStarted");
+            else
+                strcpy(status, "AdhocJoined");
+        } else {
+            strcpy(status, "AdhocIdle");
+        }
+        break;
+    case Wlan802_11Infrastructure:
+        strcpy(status, "InfraMode");
+        break;
+    default:
+        strcpy(status, "AutoUnknownMode");
+        break;
+    }
+
+    PRINTM(INFO, "Status = %s\n", status);
+    wrq->u.data.length = strlen(status) + 1;
+
+    if (wrq->u.data.pointer) {
+        if (copy_to_user(wrq->u.data.pointer, &status, wrq->u.data.length))
+            return -EFAULT;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get Driver Version
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_version_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    int len;
+    char buf[128];
+    struct iwreq *wrq = (struct iwreq *) req;
+
+    ENTER();
+
+    get_version(priv->adapter, buf, sizeof(buf) - 1);
+
+    len = strlen(buf);
+    if (wrq->u.data.pointer) {
+        if (copy_to_user(wrq->u.data.pointer, buf, len)) {
+            PRINTM(INFO, "CopyToUser failed\n");
+            return -EFAULT;
+        }
+        wrq->u.data.length = len;
+    }
+
+    PRINTM(INFO, "wlan version: %s\n", buf);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get Driver and FW version
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wrq			A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_verext_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    HostCmd_DS_VERSION_EXT versionExtCmd;
+    int len;
+
+    ENTER();
+
+    memset(&versionExtCmd, 0x00, sizeof(versionExtCmd));
+
+    if (wrq->u.data.flags == 0) {
+        //from iwpriv subcmd
+        versionExtCmd.versionStrSel =
+            *((int *) (wrq->u.name + SUBCMD_OFFSET));
+    } else {
+        if (copy_from_user(&versionExtCmd.versionStrSel,
+                           wrq->u.data.pointer,
+                           sizeof(versionExtCmd.versionStrSel))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+    }
+
+    PrepareAndSendCommand(priv,
+                          HostCmd_CMD_VERSION_EXT, 0,
+                          HostCmd_OPTION_WAITFORRSP, 0, &versionExtCmd);
+
+    len = strlen(versionExtCmd.versionStr) + 1;
+    if (wrq->u.data.pointer) {
+        if (copy_to_user(wrq->u.data.pointer, versionExtCmd.versionStr, len)) {
+            PRINTM(INFO, "CopyToUser failed\n");
+            return -EFAULT;
+        }
+        wrq->u.data.length = len;
+    }
+
+    PRINTM(INFO, "Version: %s\n", versionExtCmd.versionStr);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Read/Write adapter registers
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_regrdwr_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    wlan_ioctl_regrdwr regrdwr;
+    wlan_offset_value offval;
+    u8 *pRdeeprom;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (copy_from_user(&regrdwr, req->ifr_data, sizeof(regrdwr))) {
+        PRINTM(INFO,
+               "copy of regrdwr for wlan_regrdwr_ioctl from user failed \n");
+        LEAVE();
+        return -EFAULT;
+    }
+
+    if (regrdwr.WhichReg == REG_EEPROM) {
+        PRINTM(INFO, "Inside RDEEPROM\n");
+        pRdeeprom =
+            (char *) kmalloc((regrdwr.NOB + sizeof(regrdwr)), GFP_KERNEL);
+        if (!pRdeeprom) {
+            PRINTM(INFO, "allocate memory for EEPROM read failed\n");
+            return -ENOMEM;
+        }
+        memcpy(pRdeeprom, &regrdwr, sizeof(regrdwr));
+        PRINTM(INFO, "Action: %d, Offset: %x, NOB: %02x\n",
+               regrdwr.Action, regrdwr.Offset, regrdwr.NOB);
+
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_802_11_EEPROM_ACCESS,
+                                    regrdwr.Action, HostCmd_OPTION_WAITFORRSP,
+                                    0, pRdeeprom);
+
+        /*
+         * Return the result back to the user 
+         */
+        if (!ret && regrdwr.Action == HostCmd_ACT_GEN_READ) {
+            if (copy_to_user
+                (req->ifr_data, pRdeeprom, sizeof(regrdwr) + regrdwr.NOB)) {
+                PRINTM(INFO,
+                       "copy of regrdwr for wlan_regrdwr_ioctl to user failed \n");
+                ret = -EFAULT;
+            }
+        }
+
+        kfree(pRdeeprom);
+
+        LEAVE();
+        return ret;
+    }
+
+    offval.offset = regrdwr.Offset;
+    offval.value = (regrdwr.Action) ? regrdwr.Value : 0x00;
+
+    PRINTM(INFO, "RegAccess: %02x Action:%d "
+           "Offset: %04x Value: %04x\n",
+           regrdwr.WhichReg, regrdwr.Action, offval.offset, offval.value);
+
+    /*
+     * regrdwr.WhichReg should contain the command that
+     * corresponds to which register access is to be 
+     * performed HostCmd_CMD_MAC_REG_ACCESS 0x0019
+     * HostCmd_CMD_BBP_REG_ACCESS 0x001a 
+     * HostCmd_CMD_RF_REG_ACCESS 0x001b 
+     */
+    if (regrdwr.WhichReg == REG_MAC ||
+        regrdwr.WhichReg == REG_BBP || regrdwr.WhichReg == REG_RF) {
+        ret = PrepareAndSendCommand(priv, regrdwr.WhichReg,
+                                    regrdwr.Action, HostCmd_OPTION_WAITFORRSP,
+                                    0, &offval);
+    } else
+        ret = -EINVAL;
+
+    /*
+     * Return the result back to the user 
+     */
+    if (!ret && regrdwr.Action == HostCmd_ACT_GEN_READ) {
+        regrdwr.Value = offval.value;
+        if (copy_to_user(req->ifr_data, &regrdwr, sizeof(regrdwr))) {
+            PRINTM(INFO,
+                   "copy of regrdwr for wlan_regrdwr_ioctl to user failed \n");
+            ret = -EFAULT;
+        }
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Cmd52 read/write register
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_cmd52rdwr_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    u8 buf[7];
+    u8 rw, func, dat = 0xff;
+    u32 reg;
+
+    ENTER();
+
+    if (copy_from_user(buf, req->ifr_data, sizeof(buf))) {
+        PRINTM(INFO, "Copy from user failed\n");
+        return -EFAULT;
+    }
+
+    rw = buf[0];
+    func = buf[1];
+    reg = buf[5];
+    reg = (reg << 8) + buf[4];
+    reg = (reg << 8) + buf[3];
+    reg = (reg << 8) + buf[2];
+
+    if (rw != 0)
+        dat = buf[6];
+
+    PRINTM(INFO, "rw=%d func=%d reg=0x%08X dat=0x%02X\n", rw, func, reg, dat);
+
+    if (rw == 0) {
+        if (sbi_read_ioreg(priv, func, reg, &dat) < 0) {
+            PRINTM(INFO, "sdio_read_ioreg: reading register 0x%X failed\n",
+                   reg);
+            dat = 0xff;
+        }
+    } else {
+        if (sbi_write_ioreg(priv, func, reg, dat) < 0) {
+            PRINTM(INFO, "sdio_read_ioreg: writing register 0x%X failed\n",
+                   reg);
+            dat = 0xff;
+        }
+    }
+    if (copy_to_user(req->ifr_data, &dat, sizeof(dat))) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return -EFAULT;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Cmd53 read/write register
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_cmd53rdwr_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    return -EINVAL;
+}
+
+/** 
+ *  @brief Convert ascii string to Hex integer
+ *     
+ *  @param d                    A pointer to integer buf
+ *  @param s			A pointer to ascii string 
+ *  @param dlen			the length o fascii string
+ *  @return 	   	        number of integer  
+ */
+static int
+ascii2hex(u8 * d, char *s, u32 dlen)
+{
+    int i;
+    u8 n;
+
+    memset(d, 0x00, dlen);
+
+    for (i = 0; i < dlen * 2; i++) {
+        if ((s[i] >= 48) && (s[i] <= 57))
+            n = s[i] - 48;
+        else if ((s[i] >= 65) && (s[i] <= 70))
+            n = s[i] - 55;
+        else if ((s[i] >= 97) && (s[i] <= 102))
+            n = s[i] - 87;
+        else
+            break;
+        if ((i % 2) == 0)
+            n = n * 16;
+        d[i / 2] += n;
+    }
+
+    return i;
+}
+
+/** 
+ *  @brief Set adhoc aes key
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_setadhocaes_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    u8 key_ascii[32];
+    u8 key_hex[16];
+    int ret = 0;
+    struct iwreq *wrq = (struct iwreq *) req;
+    wlan_adapter *Adapter = priv->adapter;
+
+    WLAN_802_11_KEY key;
+
+    ENTER();
+
+    if (Adapter->InfrastructureMode != Wlan802_11IBSS)
+        return -EOPNOTSUPP;
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected)
+        return -EOPNOTSUPP;
+
+    if (copy_from_user(key_ascii, wrq->u.data.pointer, sizeof(key_ascii))) {
+        PRINTM(INFO, "wlan_setadhocaes_ioctl copy from user failed \n");
+        LEAVE();
+        return -EFAULT;
+    }
+
+    Adapter->AdhocAESEnabled = TRUE;
+    ascii2hex(key_hex, key_ascii, sizeof(key_hex));
+
+    HEXDUMP("wlan_setadhocaes_ioctl", key_hex, sizeof(key_hex));
+
+    PRINTM(INFO, "WPA2: ENABLE AES_KEY\n");
+    key.KeyLength = WPA_AES_KEY_LEN;
+    key.KeyIndex = 0x40000000;
+    memcpy(key.KeyMaterial, key_hex, key.KeyLength);
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_KEY_MATERIAL,
+                                HostCmd_ACT_SET,
+                                HostCmd_OPTION_WAITFORRSP,
+                                KEY_INFO_ENABLED, &key);
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get adhoc aes key   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_getadhocaes_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    u8 *tmp;
+    u8 key_ascii[33];
+    u8 key_hex[16];
+    int i, ret = 0;
+    struct iwreq *wrq = (struct iwreq *) req;
+    wlan_adapter *Adapter = priv->adapter;
+    WLAN_802_11_KEY key;
+
+    ENTER();
+
+    memset(key_hex, 0x00, sizeof(key_hex));
+
+    PRINTM(INFO, "WPA2: ENABLE AES_KEY\n");
+    key.KeyLength = WPA_AES_KEY_LEN;
+    key.KeyIndex = 0x40000000;
+    memcpy(key.KeyMaterial, key_hex, key.KeyLength);
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_KEY_MATERIAL,
+                                HostCmd_ACT_GET,
+                                HostCmd_OPTION_WAITFORRSP,
+                                KEY_INFO_ENABLED, &key);
+
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+
+    memcpy(key_hex, Adapter->aeskey.KeyParamSet.Key, sizeof(key_hex));
+
+    HEXDUMP("wlan_getadhocaes_ioctl", key_hex, sizeof(key_hex));
+
+    wrq->u.data.length = sizeof(key_ascii) + 1;
+
+    memset(key_ascii, 0x00, sizeof(key_ascii));
+    tmp = key_ascii;
+
+    for (i = 0; i < sizeof(key_hex); i++)
+        tmp += sprintf(tmp, "%02x", key_hex[i]);
+
+    if (wrq->u.data.pointer) {
+        if (copy_to_user(wrq->u.data.pointer, &key_ascii, sizeof(key_ascii))) {
+            PRINTM(INFO, "copy_to_user failed\n");
+            return -EFAULT;
+        }
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Set multiple dtim
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_multiple_dtim_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    struct iwreq *wrq = (struct iwreq *) req;
+    u32 mdtim;
+    int idata;
+    int ret = -EINVAL;
+
+    ENTER();
+
+    idata = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+    mdtim = (u32) idata;
+    if (((mdtim >= MRVDRV_MIN_MULTIPLE_DTIM) &&
+         (mdtim <= MRVDRV_MAX_MULTIPLE_DTIM))
+        || (mdtim == MRVDRV_IGNORE_MULTIPLE_DTIM)) {
+        priv->adapter->MultipleDtim = mdtim;
+        ret = WLAN_STATUS_SUCCESS;
+    }
+    if (ret)
+        PRINTM(INFO, "Invalid parameter, MultipleDtim not changed.\n");
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Set authentication mode
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_setauthalg_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    int alg;
+    struct iwreq *wrq = (struct iwreq *) req;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (wrq->u.data.flags == 0) {
+        //from iwpriv subcmd
+        alg = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+    } else {
+        //from wpa_supplicant subcmd
+        if (copy_from_user(&alg, wrq->u.data.pointer, sizeof(alg))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+    }
+
+    PRINTM(INFO, "auth alg is %#x\n", alg);
+
+    switch (alg) {
+    case AUTH_ALG_SHARED_KEY:
+        Adapter->SecInfo.AuthenticationMode = Wlan802_11AuthModeShared;
+        break;
+    case AUTH_ALG_NETWORK_EAP:
+        Adapter->SecInfo.AuthenticationMode = Wlan802_11AuthModeNetworkEAP;
+        break;
+    case AUTH_ALG_OPEN_SYSTEM:
+    default:
+        Adapter->SecInfo.AuthenticationMode = Wlan802_11AuthModeOpen;
+        break;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set Encryption mode
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_setencryptionmode_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    int mode;
+    struct iwreq *wrq = (struct iwreq *) req;
+
+    ENTER();
+
+    if (wrq->u.data.flags == 0) {
+        //from iwpriv subcmd
+        mode = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+    } else {
+        //from wpa_supplicant subcmd
+        if (copy_from_user(&mode, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+    }
+    PRINTM(INFO, "encryption mode is %#x\n", mode);
+    priv->adapter->SecInfo.EncryptionMode = mode;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get Rx antenna
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_subcmd_getrxantenna_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    int len;
+    char buf[8];
+    struct iwreq *wrq = (struct iwreq *) req;
+
+    ENTER();
+
+    PRINTM(INFO, "WLAN_SUBCMD_GETRXANTENNA\n");
+    len = GetRxAntenna(priv, buf);
+
+    wrq->u.data.length = len;
+    if (wrq->u.data.pointer) {
+        if (copy_to_user(wrq->u.data.pointer, &buf, len)) {
+            PRINTM(INFO, "CopyToUser failed\n");
+            return -EFAULT;
+        }
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get Tx antenna
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_subcmd_gettxantenna_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    int len;
+    char buf[8];
+    struct iwreq *wrq = (struct iwreq *) req;
+
+    ENTER();
+
+    PRINTM(INFO, "WLAN_SUBCMD_GETTXANTENNA\n");
+    len = GetTxAntenna(priv, buf);
+
+    wrq->u.data.length = len;
+    if (wrq->u.data.pointer) {
+        if (copy_to_user(wrq->u.data.pointer, &buf, len)) {
+            PRINTM(INFO, "CopyToUser failed\n");
+            return -EFAULT;
+        }
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get the MAC TSF value from the firmware
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param wrq          A pointer to iwreq structure containing buffer
+ *                      space to store a TSF value retrieved from the firmware
+ *
+ *  @return             0 if successful; IOCTL error code otherwise
+ */
+static int
+wlan_get_tsf_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    u64 tsfVal = 0;
+    int ret;
+
+    ENTER();
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_GET_TSF,
+                                0, HostCmd_OPTION_WAITFORRSP, 0, &tsfVal);
+
+    PRINTM(INFO, "IOCTL: Get TSF = 0x%016llx\n", tsfVal);
+
+    if (ret != WLAN_STATUS_SUCCESS) {
+        PRINTM(INFO, "IOCTL: Get TSF; Command exec failed\n");
+        ret = -EFAULT;
+    } else {
+        if (copy_to_user(wrq->u.data.pointer,
+                         &tsfVal,
+                         MIN(wrq->u.data.length, sizeof(tsfVal))) != 0) {
+
+            PRINTM(INFO, "IOCTL: Get TSF; Copy to user failed\n");
+            ret = -EFAULT;
+        } else {
+            ret = 0;
+        }
+    }
+
+    LEAVE();
+
+    return ret;
+}
+
+/** 
+ *  @brief  Control WPS Session Enable/Disable
+ *  @param priv         A pointer to wlan_private structure
+ *  @param req          A pointer to ifreq structure
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_do_wps_session_ioctl(wlan_private * priv, struct iwreq *req)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    char buf[8];
+    struct iwreq *wrq = (struct iwreq *) req;
+
+    ENTER();
+
+    PRINTM(INFO, "WLAN_WPS_SESSION\n");
+
+    memset(buf, 0, sizeof(buf));
+    if (copy_from_user(buf, wrq->u.data.pointer,
+                       MIN(sizeof(buf) - 1, wrq->u.data.length))) {
+        PRINTM(INFO, "Copy from user failed\n");
+        return -EFAULT;
+    }
+
+    if (buf[0] == 1)
+        Adapter->wps.SessionEnable = TRUE;
+    else
+        Adapter->wps.SessionEnable = FALSE;
+
+    PRINTM(INFO, "Adapter->wps.SessionEnable = %d\n",
+           Adapter->wps.SessionEnable);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get/Set DeepSleep mode
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_deepsleep_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    char status[128];
+    struct iwreq *wrq = (struct iwreq *) req;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        PRINTM(MSG, "Cannot enter Deep Sleep mode in connected state.\n");
+        return -EINVAL;
+    }
+
+    if (*(char *) req->ifr_data == '0') {
+        PRINTM(INFO, "Exit Deep Sleep Mode.\n");
+        sprintf(status, "setting to off ");
+        SetDeepSleep(priv, FALSE);
+    } else if (*(char *) req->ifr_data == '1') {
+        PRINTM(INFO, "Enter Deep Sleep Mode.\n");
+        sprintf(status, "setting to on ");
+        SetDeepSleep(priv, TRUE);
+    } else if (*(char *) req->ifr_data == '2') {
+        PRINTM(INFO, "Get Deep Sleep Mode.\n");
+        if (Adapter->IsDeepSleep == TRUE) {
+            sprintf(status, "on ");
+        } else {
+            sprintf(status, "off ");
+        }
+    } else {
+        PRINTM(INFO, "unknown option = %d\n", *(u8 *) req->ifr_data);
+        return -EINVAL;
+    }
+
+    if (wrq->u.data.pointer) {
+        if (copy_to_user(wrq->u.data.pointer, &status, strlen(status)))
+            return -EFAULT;
+        wrq->u.data.length = strlen(status);
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Config hostsleep parameter
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wrq			A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_do_hostsleepcfg_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    char buf[32];
+    int ret = WLAN_STATUS_SUCCESS;
+    int gpio, gap;
+
+    memset(buf, 0, sizeof(buf));
+    if (copy_from_user(buf, wrq->u.data.pointer,
+                       MIN(sizeof(buf) - 1, wrq->u.data.length))) {
+        PRINTM(INFO, "Copy from user failed\n");
+        return -EFAULT;
+    }
+    buf[sizeof(buf) - 1] = 0;
+
+    if (sscanf(buf, "%x %x %x", &Adapter->HSCfg.conditions, &gpio, &gap) != 3) {
+        PRINTM(MSG, "Invalid parameters\n");
+        return -EINVAL;
+    }
+
+    if (Adapter->HSCfg.conditions != HOST_SLEEP_CFG_CANCEL) {
+        Adapter->HSCfg.gpio = (u8) gpio;
+        Adapter->HSCfg.gap = (u8) gap;
+    }
+
+    PRINTM(INFO,
+           "hostsleepcfg: cond=%#x gpio=%#x gap=%#x PSState=%d HS_Activated=%d\n",
+           Adapter->HSCfg.conditions, Adapter->HSCfg.gpio, Adapter->HSCfg.gap,
+           Adapter->PSState, Adapter->HS_Activated);
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_HOST_SLEEP_CFG,
+                                0, HostCmd_OPTION_WAITFORRSP, 0,
+                                &Adapter->HSCfg);
+
+    return ret;
+}
+
+/** 
+ *  @brief Config Host Sleep parameters
+ *   
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wreq		A pointer to iwreq structure
+ *  @return    		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_hscfg_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int data[3] = { -1, 0xff, 0xff };
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (wrq->u.data.length >= 1 && wrq->u.data.length <= 3) {
+        if (copy_from_user
+            (data, wrq->u.data.pointer, sizeof(int) * wrq->u.data.length)) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+        PRINTM(INFO,
+               "wlan_hscfg_ioctl: data[0]=%#08x, data[1]=%#02x, data[2]=%#02x\n",
+               data[0], data[1], data[2]);
+    } else {
+        PRINTM(MSG, "Invalid Argument\n");
+        return -EINVAL;
+    }
+
+    Adapter->HSCfg.conditions = data[0];
+    if (Adapter->HSCfg.conditions != HOST_SLEEP_CFG_CANCEL) {
+        if (wrq->u.data.length == 2) {
+            Adapter->HSCfg.gpio = (u8) data[1];
+        } else if (wrq->u.data.length == 3) {
+            Adapter->HSCfg.gpio = (u8) data[1];
+            Adapter->HSCfg.gap = (u8) data[2];
+        }
+    }
+
+    PRINTM(INFO,
+           "hscfg: cond=%#x gpio=%#x gap=%#x PSState=%d HS_Activated=%d\n",
+           Adapter->HSCfg.conditions, Adapter->HSCfg.gpio, Adapter->HSCfg.gap,
+           Adapter->PSState, Adapter->HS_Activated);
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_HOST_SLEEP_CFG,
+                                0, HostCmd_OPTION_WAITFORRSP, 0,
+                                &Adapter->HSCfg);
+
+    data[0] = Adapter->HSCfg.conditions;
+    data[1] = Adapter->HSCfg.gpio;
+    data[2] = Adapter->HSCfg.gap;
+    wrq->u.data.length = 3;
+    if (copy_to_user
+        (wrq->u.data.pointer, data, sizeof(int) * wrq->u.data.length)) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return -EFAULT;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Set Host Sleep parameters
+ *   
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wreq		A pointer to iwreq structure
+ *  @return    		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_hssetpara_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int data[3] = { -1, 0xff, 0xff };
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (wrq->u.data.length >= 1 && wrq->u.data.length <= 3) {
+        if (copy_from_user
+            (data, wrq->u.data.pointer, sizeof(int) * wrq->u.data.length)) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+        PRINTM(INFO,
+               "wlan_hssetpara_ioctl: data[0]=%#08x, data[1]=%#02x, data[2]=%#02x\n",
+               data[0], data[1], data[2]);
+    }
+
+    Adapter->HSCfg.conditions = data[0];
+    if (Adapter->HSCfg.conditions != HOST_SLEEP_CFG_CANCEL) {
+        if (wrq->u.data.length == 2) {
+            Adapter->HSCfg.gpio = (u8) data[1];
+        } else if (wrq->u.data.length == 3) {
+            Adapter->HSCfg.gpio = (u8) data[1];
+            Adapter->HSCfg.gap = (u8) data[2];
+        }
+    }
+
+    PRINTM(INFO,
+           "hssetpara: cond=%#x gpio=%#x gap=%#x PSState=%d HS_Activated=%d\n",
+           Adapter->HSCfg.conditions, Adapter->HSCfg.gpio, Adapter->HSCfg.gap,
+           Adapter->PSState, Adapter->HS_Activated);
+
+    data[0] = Adapter->HSCfg.conditions;
+    data[1] = Adapter->HSCfg.gpio;
+    data[2] = Adapter->HSCfg.gap;
+    wrq->u.data.length = 3;
+    if (copy_to_user
+        (wrq->u.data.pointer, data, sizeof(int) * wrq->u.data.length)) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return -EFAULT;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get/Set Cal data ext
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_do_caldata_ext_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    HostCmd_DS_802_11_CAL_DATA_EXT *pCalData = NULL;
+    int ret = WLAN_STATUS_SUCCESS;
+    u16 action;
+
+    ENTER();
+
+    if (!(pCalData = kmalloc(MAX_SETGET_CONF_CMD_LEN, GFP_KERNEL))) {
+        PRINTM(INFO, "Allocate memory failed\n");
+        ret = -ENOMEM;
+        goto calexit;
+    }
+    memset(pCalData, 0, MAX_SETGET_CONF_CMD_LEN);
+
+    if (copy_from_user(pCalData, req->ifr_data + SKIP_CMDNUM,
+                       MAX_SETGET_CONF_CMD_LEN)) {
+        PRINTM(INFO, "Copy from user failed\n");
+        kfree(pCalData);
+        ret = -EFAULT;
+        goto calexit;
+    }
+
+    action = (pCalData->Action == HostCmd_ACT_GEN_SET) ?
+        HostCmd_ACT_GEN_SET : HostCmd_ACT_GEN_GET;
+
+    HEXDUMP("Cal data ext", (u8 *) pCalData, MAX_SETGET_CONF_CMD_LEN);
+
+    PRINTM(INFO, "CalData Action = 0x%0X\n", action);
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_CAL_DATA_EXT,
+                                action,
+                                HostCmd_OPTION_WAITFORRSP, 0, pCalData);
+
+    if (!ret && action == HostCmd_ACT_GEN_GET) {
+        if (copy_to_user(req->ifr_data + SKIP_CMDNUM, pCalData,
+                         MAX_SETGET_CONF_CMD_LEN)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            ret = -EFAULT;
+        }
+    }
+
+    kfree(pCalData);
+  calexit:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get/Set sleep period 
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wrq			A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_sleep_period(wlan_private * priv, struct iwreq *wrq)
+{
+    int ret;
+    int data;
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_SLEEP_PERIOD sleeppd;
+
+    ENTER();
+
+    if (wrq->u.data.length > 1)
+        return -ENOTSUPP;
+
+    memset(&sleeppd, 0, sizeof(sleeppd));
+    memset(&Adapter->sleep_period, 0, sizeof(SleepPeriod));
+
+    if (wrq->u.data.length == 0) {
+        sleeppd.Action = HostCmd_ACT_GEN_GET;
+    } else {
+        if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+
+        /* sleep period is 0 or 10~60 in milliseconds */
+#define MIN_SLEEP_PERIOD		10
+#define MAX_SLEEP_PERIOD		60
+#define SLEEP_PERIOD_RESERVED_FF	0xFF
+        if ((data <= MAX_SLEEP_PERIOD && data >= MIN_SLEEP_PERIOD) ||
+            (data == 0)
+            || (data == SLEEP_PERIOD_RESERVED_FF)       /* for UPSD certification tests */
+            ) {
+            sleeppd.Action = HostCmd_ACT_GEN_SET;
+            sleeppd.Period = data;
+        } else
+            return -EINVAL;
+    }
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_SLEEP_PERIOD,
+                                0, HostCmd_OPTION_WAITFORRSP,
+                                0, (void *) &sleeppd);
+
+    data = (int) Adapter->sleep_period.period;
+    if (copy_to_user(wrq->u.data.pointer, &data, sizeof(int))) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return -EFAULT;
+    }
+    wrq->u.data.length = 1;
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get/Set adapt rate 
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wrq			A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_adapt_rateset(wlan_private * priv, struct iwreq *wrq)
+{
+    int ret;
+    wlan_adapter *Adapter = priv->adapter;
+    int data[4];
+    int rateindex;
+
+    ENTER();
+    memset(data, 0, sizeof(data));
+    if (!wrq->u.data.length) {
+        PRINTM(INFO, "Get ADAPT RATE SET\n");
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_802_11_RATE_ADAPT_RATESET,
+                                    HostCmd_ACT_GEN_GET,
+                                    HostCmd_OPTION_WAITFORRSP, 0, NULL);
+        data[0] = Adapter->HWRateDropMode;
+        data[2] = Adapter->Threshold;
+        data[3] = Adapter->FinalRate;
+        wrq->u.data.length = 4;
+        data[1] = Adapter->RateBitmap;
+        if (copy_to_user
+            (wrq->u.data.pointer, data, sizeof(int) * wrq->u.data.length)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return -EFAULT;
+        }
+
+    } else {
+        PRINTM(INFO, "Set ADAPT RATE SET\n");
+        if (wrq->u.data.length > 4)
+            return -EINVAL;
+        if (copy_from_user
+            (data, wrq->u.data.pointer, sizeof(int) * wrq->u.data.length)) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+
+        if (data[0] > HW_SINGLE_RATE_DROP)
+            return -EINVAL;
+        Adapter->HWRateDropMode = data[0];
+        Adapter->Threshold = data[2];
+        Adapter->FinalRate = data[3];
+        Adapter->RateBitmap = data[1];
+        Adapter->Is_DataRate_Auto = Is_Rate_Auto(priv);
+        if (Adapter->Is_DataRate_Auto)
+            Adapter->DataRate = 0;
+        else {
+            rateindex = GetRateIndex(priv);
+            Adapter->DataRate = index_to_data_rate(rateindex);
+        }
+        PRINTM(INFO, "RateBitmap=%x,IsRateAuto=%d,DataRate=%d\n",
+               Adapter->RateBitmap, Adapter->Is_DataRate_Auto,
+               Adapter->DataRate);
+        ret =
+            PrepareAndSendCommand(priv, HostCmd_CMD_802_11_RATE_ADAPT_RATESET,
+                                  HostCmd_ACT_GEN_SET,
+                                  HostCmd_OPTION_WAITFORRSP, 0, NULL);
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get/Set inactivity timeout
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wrq			A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_inactivity_timeout(wlan_private * priv, struct iwreq *wrq)
+{
+    int ret;
+    int data = 0;
+    u16 timeout = 0;
+
+    ENTER();
+    if (wrq->u.data.length > 1)
+        return -ENOTSUPP;
+
+    if (wrq->u.data.length == 0) {
+        /* Get */
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_802_11_INACTIVITY_TIMEOUT,
+                                    HostCmd_ACT_GET,
+                                    HostCmd_OPTION_WAITFORRSP, 0, &timeout);
+        data = timeout;
+        if (copy_to_user(wrq->u.data.pointer, &data, sizeof(int))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return -EFAULT;
+        }
+    } else {
+        /* Set */
+        if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+
+        timeout = data;
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_802_11_INACTIVITY_TIMEOUT,
+                                    HostCmd_ACT_SET,
+                                    HostCmd_OPTION_WAITFORRSP, 0, &timeout);
+    }
+
+    wrq->u.data.length = 1;
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get LOG
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wrq			A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_do_getlog_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    int ret;
+    char *buf = NULL;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    PRINTM(INFO, " GET STATS\n");
+
+    if (!(buf = kmalloc(GETLOG_BUFSIZE, GFP_KERNEL))) {
+        PRINTM(INFO, "kmalloc failed!\n");
+        return -ENOMEM;
+    }
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_GET_LOG,
+                                0, HostCmd_OPTION_WAITFORRSP, 0, NULL);
+
+    if (!ret && wrq->u.data.pointer) {
+        sprintf(buf, "\n"
+                "mcasttxframe     %u\n"
+                "failed           %u\n"
+                "retry            %u\n"
+                "multiretry       %u\n"
+                "framedup         %u\n"
+                "rtssuccess       %u\n"
+                "rtsfailure       %u\n"
+                "ackfailure       %u\n"
+                "rxfrag           %u\n"
+                "mcastrxframe     %u\n"
+                "fcserror         %u\n"
+                "txframe          %u\n",
+                Adapter->LogMsg.mcasttxframe,
+                Adapter->LogMsg.failed,
+                Adapter->LogMsg.retry,
+                Adapter->LogMsg.multiretry,
+                Adapter->LogMsg.framedup,
+                Adapter->LogMsg.rtssuccess,
+                Adapter->LogMsg.rtsfailure,
+                Adapter->LogMsg.ackfailure,
+                Adapter->LogMsg.rxfrag,
+                Adapter->LogMsg.mcastrxframe,
+                Adapter->LogMsg.fcserror, Adapter->LogMsg.txframe);
+
+        wrq->u.data.length = strlen(buf) + 1;
+        if (copy_to_user(wrq->u.data.pointer, buf, wrq->u.data.length)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            ret = -EFAULT;
+        }
+    }
+
+    kfree(buf);
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief config sleep parameters
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_sleep_params_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    int ret;
+    wlan_adapter *Adapter = priv->adapter;
+    wlan_ioctl_sleep_params_config sp;
+
+    ENTER();
+
+    memset(&sp, 0, sizeof(sp));
+
+    if (!wrq->u.data.pointer)
+        return -EFAULT;
+    if (copy_from_user(&sp, wrq->u.data.pointer,
+                       MIN(sizeof(sp), wrq->u.data.length))) {
+        PRINTM(INFO, "Copy from user failed\n");
+        return -EFAULT;
+    }
+
+    memcpy(&Adapter->sp, &sp.Error, sizeof(SleepParams));
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_SLEEP_PARAMS,
+                                sp.Action, HostCmd_OPTION_WAITFORRSP,
+                                0, NULL);
+
+    if (!ret && !sp.Action) {
+        memcpy(&sp.Error, &Adapter->sp, sizeof(SleepParams));
+        if (copy_to_user(wrq->u.data.pointer, &sp, sizeof(sp))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return -EFAULT;
+        }
+        wrq->u.data.length = sizeof(sp);
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Read the CIS Table
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_do_getcis_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    struct iwreq *wrq = (struct iwreq *) req;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (wrq->u.data.pointer) {
+        if (copy_to_user(wrq->u.data.pointer, Adapter->CisInfoBuf,
+                         Adapter->CisInfoLen)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return -EFAULT;
+        }
+        wrq->u.data.length = Adapter->CisInfoLen;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Set BCA timeshare
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wrq	   	A pointer to user data
+ *  @return 	   	WLAN_STATUS_SUCCESS--success, otherwise fail
+ */
+static int
+wlan_bca_timeshare_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    int ret;
+    wlan_adapter *Adapter = priv->adapter;
+    wlan_ioctl_bca_timeshare_config bca_ts;
+
+    ENTER();
+
+    memset(&bca_ts, 0, sizeof(HostCmd_DS_802_11_BCA_TIMESHARE));
+
+    if (!wrq->u.data.pointer)
+        return -EFAULT;
+    if (copy_from_user(&bca_ts, wrq->u.data.pointer,
+                       MIN(sizeof(bca_ts), wrq->u.data.length))) {
+        PRINTM(INFO, "Copy from user failed\n");
+        return -EFAULT;
+    }
+
+    PRINTM(INFO, "TrafficType=%x TimeShareInterva=%x BTTime=%x\n",
+           bca_ts.TrafficType, bca_ts.TimeShareInterval, bca_ts.BTTime);
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_BCA_CONFIG_TIMESHARE,
+                                bca_ts.Action, HostCmd_OPTION_WAITFORRSP,
+                                0, &bca_ts);
+
+    if (!ret && !bca_ts.Action) {
+        if (copy_to_user(wrq->u.data.pointer, &Adapter->bca_ts,
+                         sizeof(bca_ts))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return -EFAULT;
+        }
+        wrq->u.data.length = sizeof(HostCmd_DS_802_11_BCA_TIMESHARE);
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Set scan type
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wrq	   	A pointer to user data
+ *  @return 	   	WLAN_STATUS_SUCCESS--success, otherwise fail
+ */
+static int
+wlan_scan_type_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    u8 buf[12];
+    u8 *option[] = { "active", "passive", "get", };
+    int i, max_options = (sizeof(option) / sizeof(option[0]));
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (wlan_get_state_11d(priv) == ENABLE_11D) {
+        PRINTM(INFO, "11D: Cannot set scantype when 11D enabled\n");
+        return -EFAULT;
+    }
+
+    memset(buf, 0, sizeof(buf));
+
+    if (copy_from_user(buf, wrq->u.data.pointer, MIN(sizeof(buf),
+                                                     wrq->u.data.length))) {
+        PRINTM(INFO, "Copy from user failed\n");
+        return -EFAULT;
+    }
+
+    PRINTM(INFO, "Scan Type Option = %s\n", buf);
+
+    buf[sizeof(buf) - 1] = '\0';
+
+    for (i = 0; i < max_options; i++) {
+        if (!strcmp(buf, option[i]))
+            break;
+    }
+
+    switch (i) {
+    case 0:
+        Adapter->ScanType = HostCmd_SCAN_TYPE_ACTIVE;
+
+        break;
+    case 1:
+        Adapter->ScanType = HostCmd_SCAN_TYPE_PASSIVE;
+        break;
+    case 2:
+        wrq->u.data.length = strlen(option[Adapter->ScanType]) + 1;
+
+        if (copy_to_user(wrq->u.data.pointer,
+                         option[Adapter->ScanType], wrq->u.data.length)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            ret = -EFAULT;
+        }
+
+        break;
+    default:
+        PRINTM(INFO, "Invalid Scan Type Ioctl Option\n");
+        ret = -EINVAL;
+        break;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Set scan mode
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wrq	   	A pointer to user data
+ *  @return 	   	WLAN_STATUS_SUCCESS--success, otherwise fail
+ */
+static int
+wlan_scan_mode_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    u8 buf[12];
+    u8 *option[] = { "bss", "ibss", "any", "get" };
+    int i, max_options = (sizeof(option) / sizeof(option[0]));
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    memset(buf, 0, sizeof(buf));
+
+    if (copy_from_user(buf, wrq->u.data.pointer, MIN(sizeof(buf),
+                                                     wrq->u.data.length))) {
+        PRINTM(INFO, "Copy from user failed\n");
+        return -EFAULT;
+    }
+
+    PRINTM(INFO, "Scan Mode Option = %s\n", buf);
+
+    buf[sizeof(buf) - 1] = '\0';
+
+    for (i = 0; i < max_options; i++) {
+        if (!strcmp(buf, option[i]))
+            break;
+    }
+
+    switch (i) {
+
+    case 0:
+        Adapter->ScanMode = HostCmd_BSS_TYPE_BSS;
+        break;
+    case 1:
+        Adapter->ScanMode = HostCmd_BSS_TYPE_IBSS;
+        break;
+    case 2:
+        Adapter->ScanMode = HostCmd_BSS_TYPE_ANY;
+        break;
+    case 3:
+
+        wrq->u.data.length = strlen(option[Adapter->ScanMode - 1]) + 1;
+
+        PRINTM(INFO, "Get Scan Mode Option = %s\n",
+               option[Adapter->ScanMode - 1]);
+
+        PRINTM(INFO, "Scan Mode Length %d\n", wrq->u.data.length);
+
+        if (copy_to_user(wrq->u.data.pointer,
+                         option[Adapter->ScanMode - 1], wrq->u.data.length)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            ret = -EFAULT;
+        }
+        PRINTM(INFO, "GET Scan Type Option after copy = %s\n",
+               (char *) wrq->u.data.pointer);
+
+        break;
+
+    default:
+        PRINTM(INFO, "Invalid Scan Mode Ioctl Option\n");
+        ret = -EINVAL;
+        break;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get/Set Adhoc G Rate
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wrq	   	A pointer to user data
+ *  @return 	   	WLAN_STATUS_SUCCESS--success, otherwise fail
+ */
+static int
+wlan_do_set_grate_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int data, data1;
+    int *val;
+
+    ENTER();
+
+    data1 = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+    switch (data1) {
+    case 0:
+        Adapter->adhoc_grate_enabled = FALSE;
+        break;
+    case 1:
+        Adapter->adhoc_grate_enabled = TRUE;
+        break;
+    case 2:
+        break;
+    default:
+        return -EINVAL;
+    }
+    data = Adapter->adhoc_grate_enabled;
+    val = (int *) wrq->u.name;
+    *val = data;
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get/Set Firmware wakeup method
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wrq	   	A pointer to user data
+ *  @return 	   	WLAN_STATUS_SUCCESS--success, otherwise fail
+ */
+static int
+wlan_cmd_fw_wakeup_method(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    u16 action;
+    u16 method;
+    int ret;
+    int data;
+
+    ENTER();
+
+    if (wrq->u.data.length == 0 || !wrq->u.data.pointer) {
+        action = HostCmd_ACT_GET;
+        method = Adapter->fwWakeupMethod;
+    } else {
+        action = HostCmd_ACT_SET;
+        if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+
+        switch (data) {
+        case 0:
+            method = WAKEUP_FW_UNCHANGED;
+            break;
+        case 1:
+            method = WAKEUP_FW_THRU_INTERFACE;
+            break;
+        case 2:
+            method = WAKEUP_FW_THRU_GPIO;
+            break;
+        default:
+            return -EINVAL;
+        }
+    }
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_FW_WAKE_METHOD, action,
+                                HostCmd_OPTION_WAITFORRSP, 0, &method);
+
+    if (action == HostCmd_ACT_GET) {
+        method = Adapter->fwWakeupMethod;
+        if (copy_to_user(wrq->u.data.pointer, &method, sizeof(method))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return -EFAULT;
+        }
+        wrq->u.data.length = 1;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get/Set Auto Deep Sleep mode
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wrq	   	A pointer to user data
+ *  @return 	   	WLAN_STATUS_SUCCESS--success, otherwise fail
+ */
+static int
+wlan_auto_deep_sleep(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int data;
+
+    ENTER();
+
+    if (wrq->u.data.length > 0 && wrq->u.data.pointer) {
+        if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+
+        switch (data) {
+        case 0:
+            if (Adapter->IsAutoDeepSleepEnabled) {
+                Adapter->IsAutoDeepSleepEnabled = FALSE;
+                /* Try to exit DS if auto DS disabled */
+                SetDeepSleep(priv, FALSE);
+            }
+            break;
+        case 1:
+            if (!Adapter->IsAutoDeepSleepEnabled) {
+                Adapter->IsAutoDeepSleepEnabled = TRUE;
+                /* Wakeup main thread to enter DS if auto DS enabled */
+                wake_up_interruptible(&priv->MainThread.waitQ);
+            }
+            break;
+        default:
+            return -EINVAL;
+        }
+    }
+
+    data = Adapter->IsAutoDeepSleepEnabled;
+    if (copy_to_user(wrq->u.data.pointer, &data, sizeof(data))) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return -EFAULT;
+    }
+    wrq->u.data.length = 1;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Get the CFP table based on the region code
+ *
+ *  @param priv     A pointer to wlan_private structure
+ *  @param wrq      A pointer to iwreq structure
+ *
+ *  @return         WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_get_cfp_table_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    pwlan_ioctl_cfp_table ioctl_cfp;
+    CHANNEL_FREQ_POWER *cfp;
+    int cfp_no;
+    int regioncode;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (wrq->u.data.length == 0 || !wrq->u.data.pointer) {
+        ret = -EINVAL;
+        goto cfpexit;
+    }
+
+    ioctl_cfp = (pwlan_ioctl_cfp_table) wrq->u.data.pointer;
+
+    if (copy_from_user(&regioncode, &ioctl_cfp->region, sizeof(int))) {
+        PRINTM(INFO, "Get CFP table: copy from user failed\n");
+        ret = -EFAULT;
+        goto cfpexit;
+    }
+
+    if (!regioncode)
+        regioncode = Adapter->RegionCode;
+
+    cfp =
+        wlan_get_region_cfp_table((u8) regioncode, BAND_G | BAND_B, &cfp_no);
+
+    if (cfp == NULL) {
+        PRINTM(MSG, "No related CFP table found, region code = 0x%x\n",
+               regioncode);
+        ret = -EFAULT;
+        goto cfpexit;
+    }
+
+    if (copy_to_user(&ioctl_cfp->cfp_no, &cfp_no, sizeof(int))) {
+        PRINTM(INFO, "Get CFP table: copy to user failed\n");
+        ret = -EFAULT;
+        goto cfpexit;
+    }
+
+    if (copy_to_user
+        (ioctl_cfp->cfp, cfp, sizeof(CHANNEL_FREQ_POWER) * cfp_no)) {
+        PRINTM(INFO, "Get CFP table: copy to user failed\n");
+        ret = -EFAULT;
+        goto cfpexit;
+    }
+
+    wrq->u.data.length =
+        sizeof(int) * 2 + sizeof(CHANNEL_FREQ_POWER) * cfp_no;
+
+  cfpexit:
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief  Retrieve transmit packet statistics from the firmware
+ *
+ *  @param priv     A pointer to wlan_private structure
+ *  @param wrq      A pointer to iwreq structure
+ *
+ *  @return         WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_tx_pkt_stats_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    HostCmd_DS_TX_PKT_STATS txPktStats;
+    int ret;
+
+    ENTER();
+
+    if (wrq->u.data.length == 0 || !wrq->u.data.pointer) {
+        LEAVE();
+        return -EINVAL;
+    }
+
+    if (wrq->u.data.length < sizeof(txPktStats)) {
+        LEAVE();
+        return -E2BIG;
+    }
+
+    memset(&txPktStats, 0x00, sizeof(txPktStats));
+
+    if ((ret = PrepareAndSendCommand(priv,
+                                     HostCmd_CMD_TX_PKT_STATS, 0,
+                                     HostCmd_OPTION_WAITFORRSP,
+                                     0, &txPktStats))) {
+        LEAVE();
+        return ret;
+    }
+
+    if (copy_to_user(wrq->u.data.pointer,
+                     (u8 *) & txPktStats, sizeof(txPktStats))) {
+        PRINTM(INFO, "TxPktStats: copy to user failed\n");
+        return -EFAULT;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/********************************************************
+		Global Functions
+********************************************************/
+/** 
+ *  @brief ioctl function - entry point
+ *  
+ *  @param dev		A pointer to net_device structure
+ *  @param req	   	A pointer to ifreq structure
+ *  @param cmd 		command
+ *  @return 	   	WLAN_STATUS_SUCCESS--success, otherwise fail
+ */
+int
+wlan_do_ioctl(struct net_device *dev, struct ifreq *req, int cmd)
+{
+    int subcmd = 0;
+    int idata = 0;
+    int *pdata;
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    struct iwreq *wrq = (struct iwreq *) req;
+
+    ENTER();
+
+    if (Adapter->bHostSleepConfigured) {
+        BOOLEAN cmd_allowed = FALSE;
+        int count = sizeof(Commands_Allowed_In_HostSleep)
+            / sizeof(Commands_Allowed_In_HostSleep[0]);
+
+        if (cmd == WLANHOSTSLEEPCFG) {
+            char buf[32];
+            u32 cond;
+
+            memset(buf, 0, sizeof(buf));
+            if (copy_from_user(buf, wrq->u.data.pointer,
+                               MIN(sizeof(buf) - 1, wrq->u.data.length))) {
+                PRINTM(INFO, "Copy from user failed\n");
+                return -EFAULT;
+            }
+            buf[sizeof(buf) - 1] = 0;
+            sscanf(buf, "%x ", &cond);
+            if (cond == HOST_SLEEP_CFG_CANCEL) {
+                cmd_allowed = TRUE;
+                if (Adapter->IsDeepSleep) {
+                    SetDeepSleep(priv, FALSE);
+                }
+            }
+        } else if (cmd == WLAN_SET_GET_SIXTEEN_INT &&
+                   ((int) wrq->u.data.flags == WLANHSCFG)) {
+            u32 cond;
+            if (copy_from_user(&cond, wrq->u.data.pointer, sizeof(cond))) {
+                PRINTM(INFO, "Copy from user failed\n");
+                return -EFAULT;
+            }
+
+            if (cond == HOST_SLEEP_CFG_CANCEL) {
+                cmd_allowed = TRUE;
+                if (Adapter->IsDeepSleep) {
+                    SetDeepSleep(priv, FALSE);
+                }
+            }
+        } else
+            if (Is_Command_Allowed_In_Sleep
+                (req, cmd, Commands_Allowed_In_HostSleep, count)) {
+            cmd_allowed = TRUE;
+        }
+        if (!cmd_allowed) {
+            PRINTM(MSG, "%s IOCTLS called when WLAN access is blocked\n",
+                   __FUNCTION__);
+            return -EBUSY;
+        }
+    }
+
+    if (!Adapter->IsAutoDeepSleepEnabled) {
+        if (Adapter->IsDeepSleep) {
+            int count = sizeof(Commands_Allowed_In_DeepSleep)
+                / sizeof(Commands_Allowed_In_DeepSleep[0]);
+
+            if (!Is_Command_Allowed_In_Sleep
+                (req, cmd, Commands_Allowed_In_DeepSleep, count)) {
+                PRINTM(MSG,
+                       "():%s IOCTLS called when station is"
+                       " in DeepSleep\n", __FUNCTION__);
+                return -EBUSY;
+            }
+        }
+    } else if (cmd == WLANDEEPSLEEP) {
+        PRINTM(MSG,
+               "DeepSleep command is not allowed in AutoDeepSleep mode\n");
+        return -EBUSY;
+    }
+
+    PRINTM(INFO, "wlan_do_ioctl: ioctl cmd = 0x%x\n", cmd);
+    switch (cmd) {
+    case WLANEXTSCAN:
+        ret = wlan_extscan_ioctl(priv, req);
+        break;
+    case WLANHOSTCMD:
+        ret = wlan_hostcmd_ioctl(dev, req, cmd);
+        break;
+    case WLANARPFILTER:
+        ret = wlan_arpfilter_ioctl(dev, req, cmd);
+        break;
+
+    case WLANCISDUMP:          /* Read CIS Table  */
+        ret = wlan_do_getcis_ioctl(priv, req);
+        break;
+
+    case WLANSCAN_TYPE:
+        PRINTM(INFO, "Scan Type Ioctl\n");
+        ret = wlan_scan_type_ioctl(priv, wrq);
+        break;
+
+#ifdef MFG_CMD_SUPPORT
+    case WLANMANFCMD:
+        PRINTM(INFO, "Entering the Manufacturing ioctl SIOCCFMFG\n");
+        ret = wlan_mfg_command(priv, wrq);
+
+        PRINTM(INFO, "Manufacturing Ioctl %s\n",
+               (ret) ? "failed" : "success");
+        break;
+#endif
+
+    case WLANREGRDWR:          /* Register read write command */
+        ret = wlan_regrdwr_ioctl(priv, req);
+        break;
+
+    case WLANCMD52RDWR:        /* CMD52 read/write command */
+        ret = wlan_cmd52rdwr_ioctl(priv, req);
+        break;
+
+    case WLANCMD53RDWR:        /* CMD53 read/write command */
+        ret = wlan_cmd53rdwr_ioctl(priv, req);
+        break;
+
+    case SIOCSIWENCODE:        /* set encoding token & mode for WPA */
+        ret = wlan_set_encode(dev, NULL, &(wrq->u.data), wrq->u.data.pointer);
+        break;
+    case WLAN_SETNONE_GETNONE: /* set WPA mode on/off ioctl #20 */
+        switch (wrq->u.data.flags) {
+        case WLANDEAUTH:
+            PRINTM(INFO, "Deauth\n");
+            if (Adapter->InfrastructureMode == Wlan802_11Infrastructure &&
+                Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+                SendDeauthentication(priv);
+            } else if (Adapter->InfrastructureMode == Wlan802_11IBSS &&
+                       Adapter->MediaConnectStatus ==
+                       WlanMediaStateConnected) {
+                StopAdhocNetwork(priv);
+            }
+            break;
+
+        case WLANADHOCSTOP:
+            PRINTM(INFO, "Adhoc stop\n");
+            ret = wlan_do_adhocstop_ioctl(priv);
+            break;
+
+        case WLANRADIOON:
+            wlan_radio_ioctl(priv, RADIO_ON);
+            break;
+
+        case WLANRADIOOFF:
+            ret = wlan_radio_ioctl(priv, RADIO_OFF);
+            break;
+        case WLANREMOVEADHOCAES:
+            ret = wlan_remove_aes(priv);
+            break;
+#ifdef REASSOCIATION
+        case WLANREASSOCIATIONAUTO:
+            reassociation_on(priv);
+            break;
+        case WLANREASSOCIATIONUSER:
+            reassociation_off(priv);
+            break;
+#endif /* REASSOCIATION */
+        case WLANWLANIDLEON:
+            wlanidle_on(priv);
+            break;
+        case WLANWLANIDLEOFF:
+            wlanidle_off(priv);
+            break;
+        }                       /* End of switch */
+        break;
+
+    case WLAN_SETWORDCHAR_GETNONE:
+        switch (wrq->u.data.flags) {
+        case WLANSETADHOCAES:
+            ret = wlan_setadhocaes_ioctl(priv, req);
+            break;
+        }
+        break;
+
+    case WLAN_SETONEINT_GETWORDCHAR:
+        switch (wrq->u.data.flags) {
+        case WLANGETADHOCAES:
+            ret = wlan_getadhocaes_ioctl(priv, req);
+            break;
+        case WLANVERSION:      /* Get driver version */
+            ret = wlan_version_ioctl(priv, req);
+            break;
+        case WLANVEREXT:
+            ret = wlan_verext_ioctl(priv, wrq);
+            break;
+        }
+        break;
+
+    case WLANSETWPAIE:
+        ret = wlan_set_wpa_ie_ioctl(priv, req);
+        break;
+    case WLAN_SETINT_GETINT:
+        /* The first 4 bytes of req->ifr_data is sub-ioctl number
+         * after 4 bytes sits the payload.
+         */
+        subcmd = (int) req->ifr_data;   //from iwpriv subcmd
+        switch (subcmd) {
+        case WLANNF:
+            ret = wlan_get_nf(priv, wrq);
+            break;
+        case WLANRSSI:
+            ret = wlan_get_rssi(priv, wrq);
+            break;
+        case WLANBGSCAN:
+            {
+                int data, data1;
+                int *val;
+                data1 = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+                switch (data1) {
+                case CMD_DISABLED:
+                    PRINTM(INFO, "Background scan is set to disable\n");
+                    ret = wlan_bg_scan_enable(priv, FALSE);
+                    val = (int *) wrq->u.name;
+                    *val = data1;
+                    break;
+                case CMD_ENABLED:
+                    PRINTM(INFO, "Background scan is set to enable\n");
+                    ret = wlan_bg_scan_enable(priv, TRUE);
+                    val = (int *) wrq->u.name;
+                    *val = data1;
+                    break;
+                case CMD_GET:
+                    data = (Adapter->bgScanConfig->Enable == TRUE) ?
+                        CMD_ENABLED : CMD_DISABLED;
+                    val = (int *) wrq->u.name;
+                    *val = data;
+                    break;
+                default:
+                    ret = -EINVAL;
+                    PRINTM(INFO, "Background scan: wrong parameter\n");
+                    break;
+                }
+            }
+            break;
+        case WLANENABLE11D:
+            ret = wlan_cmd_enable_11d(priv, wrq);
+            break;
+        case WLANADHOCGRATE:
+            ret = wlan_do_set_grate_ioctl(priv, wrq);
+            break;
+        case WLANSDIOCLOCK:
+            {
+                int data;
+                int *val;
+                data = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+                switch (data) {
+                case CMD_DISABLED:
+                    PRINTM(INFO, "SDIO clock is turned off\n");
+                    ret = sbi_set_bus_clock(priv, FALSE);
+                    break;
+                case CMD_ENABLED:
+                    PRINTM(INFO, "SDIO clock is turned on\n");
+                    ret = sbi_set_bus_clock(priv, TRUE);
+                    break;
+                case CMD_GET:  /* need an API in sdio.c to get STRPCL */
+                default:
+                    ret = -EINVAL;
+                    PRINTM(INFO, "sdioclock: wrong parameter\n");
+                    break;
+                }
+                val = (int *) wrq->u.name;
+                *val = data;
+            }
+            break;
+        case WLANWMM_ENABLE:
+            ret = wlan_wmm_enable_ioctl(priv, wrq);
+            break;
+        case WLANNULLGEN:
+            ret = wlan_null_pkg_gen(priv, wrq);
+            /* enable/disable null pkg generation */
+            break;
+        case WLANADHOCCSET:
+            ret = wlan_set_coalescing_ioctl(priv, wrq);
+            break;
+        case WLAN_ADHOC_G_PROT:
+            ret = wlan_adhoc_g_protection(priv, wrq);
+            break;
+
+        }
+        break;
+
+    case WLAN_SETONEINT_GETONEINT:
+        switch (wrq->u.data.flags) {
+
+        case WLAN_WMM_QOSINFO:
+            {
+                int data;
+                if (wrq->u.data.length == 1) {
+                    if (copy_from_user
+                        (&data, wrq->u.data.pointer, sizeof(int))) {
+                        PRINTM(INFO, "Copy from user failed\n");
+                        return -EFAULT;
+                    }
+                    Adapter->wmm.qosinfo = (u8) data;
+                } else {
+                    data = (int) Adapter->wmm.qosinfo;
+                    if (copy_to_user(wrq->u.data.pointer, &data, sizeof(int))) {
+                        PRINTM(INFO, "Copy to user failed\n");
+                        return -EFAULT;
+                    }
+                    wrq->u.data.length = 1;
+                }
+            }
+            break;
+        case WLAN_LISTENINTRVL:
+            if (!wrq->u.data.length) {
+                int data;
+                PRINTM(INFO, "Get LocalListenInterval Value\n");
+#define GET_ONE_INT	1
+                data = Adapter->LocalListenInterval;
+                if (copy_to_user(wrq->u.data.pointer, &data, sizeof(int))) {
+                    PRINTM(INFO, "Copy to user failed\n");
+                    return -EFAULT;
+                }
+
+                wrq->u.data.length = GET_ONE_INT;
+            } else {
+                int data;
+                if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+                    PRINTM(INFO, "Copy from user failed\n");
+                    return -EFAULT;
+                }
+
+                PRINTM(INFO, "Set LocalListenInterval = %d\n", data);
+#define MAX_U16_VAL	65535
+                if (data > MAX_U16_VAL) {
+                    PRINTM(INFO, "Exceeds U16 value\n");
+                    return -EINVAL;
+                }
+                Adapter->LocalListenInterval = data;
+            }
+            break;
+        case WLAN_FW_WAKEUP_METHOD:
+            ret = wlan_cmd_fw_wakeup_method(priv, wrq);
+            break;
+        case WLAN_NULLPKTINTERVAL:
+            ret = wlan_null_pkt_interval(priv, wrq);
+            break;
+        case WLAN_BCN_MISS_TIMEOUT:
+            ret = wlan_bcn_miss_timeout(priv, wrq);
+            break;
+        case WLAN_ADHOC_AWAKE_PERIOD:
+            ret = wlan_adhoc_awake_period(priv, wrq);
+            break;
+        case WLAN_LDO:
+            ret = wlan_ldo_config(priv, wrq);
+            break;
+        case WLAN_SDIO_MODE:
+            ret = wlan_sdio_mode(priv, wrq);
+            break;
+        case WLAN_RTS_CTS_CTRL:
+            ret = wlan_rts_cts_ctrl(priv, wrq);
+            break;
+        case WLAN_AUTODEEPSLEEP:
+            ret = wlan_auto_deep_sleep(priv, wrq);
+            break;
+        case WLAN_WAKEUP_MT:
+            if (wrq->u.data.length > 0)
+                Adapter->IntCounter++;
+            wake_up_interruptible(&priv->MainThread.waitQ);
+            break;
+        default:
+            ret = -EOPNOTSUPP;
+            break;
+        }
+        break;
+
+    case WLAN_SETONEINT_GETNONE:
+        /* The first 4 bytes of req->ifr_data is sub-ioctl number
+         * after 4 bytes sits the payload.
+         */
+        subcmd = wrq->u.data.flags;     //from wpa_supplicant subcmd
+
+        if (!subcmd)
+            subcmd = (int) req->ifr_data;       //from iwpriv subcmd
+
+        idata = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+
+        switch (subcmd) {
+        case WLAN_SUBCMD_SETRXANTENNA: /* SETRXANTENNA */
+            ret = SetRxAntenna(priv, idata);
+            break;
+        case WLAN_SUBCMD_SETTXANTENNA: /* SETTXANTENNA */
+            ret = SetTxAntenna(priv, idata);
+            break;
+
+        case WLANSETBCNAVG:
+            if (idata == 0)
+                Adapter->bcn_avg_factor = DEFAULT_BCN_AVG_FACTOR;
+            else if (idata > MAX_BCN_AVG_FACTOR || idata < MIN_BCN_AVG_FACTOR) {
+                PRINTM(MSG, "The value '%u' is out of the range (0-%u).\n",
+                       idata, MAX_BCN_AVG_FACTOR);
+                return -EINVAL;
+            } else
+                Adapter->bcn_avg_factor = idata;
+            break;
+        case WLANSETDATAAVG:
+            if (idata == 0)
+                Adapter->data_avg_factor = DEFAULT_DATA_AVG_FACTOR;
+            else if (idata > MAX_DATA_AVG_FACTOR
+                     || idata < MIN_DATA_AVG_FACTOR) {
+                PRINTM(MSG, "The value '%u' is out of the range (0-%u).\n",
+                       idata, MAX_DATA_AVG_FACTOR);
+                return -EINVAL;
+            } else
+                Adapter->data_avg_factor = idata;
+            memset(Adapter->rawSNR, 0x00, sizeof(Adapter->rawSNR));
+            memset(Adapter->rawNF, 0x00, sizeof(Adapter->rawNF));
+            Adapter->nextSNRNF = 0;
+            Adapter->numSNRNF = 0;
+            break;
+        case WLANASSOCIATE:
+            ret = wlan_associate_to_table_idx(priv, idata);
+            break;
+
+        case WLANSETREGION:
+            ret = wlan_set_region(priv, (u16) idata);
+            break;
+
+        case WLAN_SET_LISTEN_INTERVAL:
+            Adapter->ListenInterval = (u16) idata;
+            break;
+
+        case WLAN_SET_MULTIPLE_DTIM:
+            ret = wlan_set_multiple_dtim_ioctl(priv, req);
+            break;
+
+        case WLANSETAUTHALG:
+            ret = wlan_setauthalg_ioctl(priv, req);
+            break;
+
+        case WLANSETENCRYPTIONMODE:
+            ret = wlan_setencryptionmode_ioctl(priv, req);
+            break;
+
+        default:
+            ret = -EOPNOTSUPP;
+            break;
+        }
+
+        break;
+
+    case WLAN_SETNONE_GETTWELVE_CHAR:  /* Get Antenna settings */
+        /* 
+         * We've not used IW_PRIV_TYPE_FIXED so sub-ioctl number is
+         * in flags of iwreq structure, otherwise it will be in
+         * mode member of iwreq structure.
+         */
+        switch ((int) wrq->u.data.flags) {
+        case WLAN_SUBCMD_GETRXANTENNA: /* Get Rx Antenna */
+            ret = wlan_subcmd_getrxantenna_ioctl(priv, req);
+            break;
+
+        case WLAN_SUBCMD_GETTXANTENNA: /* Get Tx Antenna */
+            ret = wlan_subcmd_gettxantenna_ioctl(priv, req);
+            break;
+
+        case WLAN_GET_TSF:
+            ret = wlan_get_tsf_ioctl(priv, wrq);
+            break;
+
+        case WLAN_WPS_SESSION:
+            ret = wlan_do_wps_session_ioctl(priv, wrq);
+            break;
+        }
+        break;
+
+    case WLANDEEPSLEEP:
+        ret = wlan_deepsleep_ioctl(priv, req);
+        break;
+
+    case WLANHOSTSLEEPCFG:
+        ret = wlan_do_hostsleepcfg_ioctl(priv, wrq);
+        break;
+
+    case WLAN_SET64CHAR_GET64CHAR:
+        switch ((int) wrq->u.data.flags) {
+
+        case WLANSLEEPPARAMS:
+            ret = wlan_sleep_params_ioctl(priv, wrq);
+            break;
+
+        case WLAN_BCA_TIMESHARE:
+            ret = wlan_bca_timeshare_ioctl(priv, wrq);
+            break;
+        case WLANSCAN_MODE:
+            PRINTM(INFO, "Scan Mode Ioctl\n");
+            ret = wlan_scan_mode_ioctl(priv, wrq);
+            break;
+
+        case WLAN_GET_ADHOC_STATUS:
+            ret = wlan_get_adhoc_status_ioctl(priv, wrq);
+            break;
+        case WLAN_SET_GEN_IE:
+            ret = wlan_set_gen_ie_ioctl(priv, wrq);
+            break;
+        case WLAN_GET_GEN_IE:
+            ret = wlan_get_gen_ie_ioctl(priv, wrq);
+            break;
+        case WLAN_WMM_QUEUE_STATUS:
+            ret = wlan_wmm_queue_status_ioctl(priv, wrq);
+            break;
+        }
+        break;
+
+    case WLAN_SETCONF_GETCONF:
+        PRINTM(INFO, "The WLAN_SETCONF_GETCONF=0x%x is %d\n",
+               WLAN_SETCONF_GETCONF, *(u8 *) req->ifr_data);
+        switch (*(u8 *) req->ifr_data) {
+        case CAL_DATA_EXT_CONFIG:
+            ret = wlan_do_caldata_ext_ioctl(priv, req);
+            break;
+        case BG_SCAN_CONFIG:
+            ret = wlan_do_bg_scan_config_ioctl(priv, req);
+            break;
+        }
+        break;
+
+    case WLAN_SETNONE_GETONEINT:
+        switch ((int) req->ifr_data) {
+        case WLANGETBCNAVG:
+            pdata = (int *) wrq->u.name;
+            *pdata = (int) Adapter->bcn_avg_factor;
+            break;
+
+        case WLANGETDATAAVG:
+            pdata = (int *) wrq->u.name;
+            *pdata = (int) Adapter->data_avg_factor;
+            break;
+
+        case WLANGETREGION:
+            pdata = (int *) wrq->u.name;
+            *pdata = (int) Adapter->RegionCode;
+            break;
+
+        case WLAN_GET_LISTEN_INTERVAL:
+            pdata = (int *) wrq->u.name;
+            *pdata = (int) Adapter->ListenInterval;
+            break;
+
+        case WLAN_GET_MULTIPLE_DTIM:
+            pdata = (int *) wrq->u.name;
+            *pdata = (int) Adapter->MultipleDtim;
+            break;
+        case WLAN_GET_TX_RATE:
+            ret = wlan_get_txrate_ioctl(priv, req);
+            break;
+        case WLANGETDTIM:
+            ret = wlan_get_dtim_ioctl(priv, req);
+            break;
+        default:
+            ret = -EOPNOTSUPP;
+
+        }
+
+        break;
+
+    case WLANGETLOG:
+        ret = wlan_do_getlog_ioctl(priv, wrq);
+        break;
+
+    case WLAN_SET_GET_SIXTEEN_INT:
+        switch ((int) wrq->u.data.flags) {
+        case WLAN_TPCCFG:
+            {
+                int data[5];
+                HostCmd_DS_802_11_TPC_CFG cfg;
+                memset(&cfg, 0, sizeof(cfg));
+                if ((wrq->u.data.length > 1) && (wrq->u.data.length != 5))
+                    return WLAN_STATUS_FAILURE;
+
+                if (wrq->u.data.length == 0) {
+                    cfg.Action = HostCmd_ACT_GEN_GET;
+                } else {
+                    if (copy_from_user(data,
+                                       wrq->u.data.pointer,
+                                       sizeof(int) * 5)) {
+                        PRINTM(INFO, "Copy from user failed\n");
+                        return -EFAULT;
+                    }
+
+                    cfg.Action = HostCmd_ACT_GEN_SET;
+                    cfg.Enable = data[0];
+                    cfg.UseSNR = data[1];
+#define TPC_DATA_NO_CHANG	0x7f
+                    if (wrq->u.data.length == 1) {
+                        cfg.P0 = TPC_DATA_NO_CHANG;
+                        cfg.P1 = TPC_DATA_NO_CHANG;
+                        cfg.P2 = TPC_DATA_NO_CHANG;
+                    } else {
+                        cfg.P0 = data[2];
+                        cfg.P1 = data[3];
+                        cfg.P2 = data[4];
+                    }
+                }
+                ret = PrepareAndSendCommand(priv,
+                                            HostCmd_CMD_802_11_TPC_CFG, 0,
+                                            HostCmd_OPTION_WAITFORRSP, 0,
+                                            (void *) &cfg);
+
+                data[0] = cfg.Enable;
+                data[1] = cfg.UseSNR;
+                data[2] = cfg.P0;
+                data[3] = cfg.P1;
+                data[4] = cfg.P2;
+                if (copy_to_user(wrq->u.data.pointer, data, sizeof(int) * 5)) {
+                    PRINTM(INFO, "Copy to user failed\n");
+                    return -EFAULT;
+                }
+
+                wrq->u.data.length = 5;
+            }
+            break;
+
+        case WLAN_SCANPROBES:
+            {
+                int data;
+                if (wrq->u.data.length > 0) {
+                    if (copy_from_user
+                        (&data, wrq->u.data.pointer, sizeof(int))) {
+                        PRINTM(INFO, "Copy from user failed\n");
+                        return -EFAULT;
+                    }
+
+                    Adapter->ScanProbes = data;
+                } else {
+                    data = Adapter->ScanProbes;
+                    if (copy_to_user(wrq->u.data.pointer, &data, sizeof(int))) {
+                        PRINTM(INFO, "Copy to user failed\n");
+                        return -EFAULT;
+                    }
+                }
+                wrq->u.data.length = 1;
+            }
+            break;
+        case WLAN_LED_GPIO_CTRL:
+            {
+                int i;
+                int data[MAX_LEDS * 2];
+                HostCmd_DS_802_11_LED_CTRL ctrl;
+                MrvlIEtypes_LedGpio_t *gpio;
+
+                gpio = (MrvlIEtypes_LedGpio_t *) & ctrl.LedGpio;
+
+                if ((wrq->u.data.length > MAX_LEDS * 2) ||
+                    (wrq->u.data.length % 2) != 0) {
+                    PRINTM(MSG, "invalid ledgpio parameters\n");
+                    return -EINVAL;
+                }
+
+                memset(&ctrl, 0, sizeof(ctrl));
+                if (wrq->u.data.length == 0) {
+                    ctrl.Action = HostCmd_ACT_GEN_GET;
+                } else {
+                    if (copy_from_user(data, wrq->u.data.pointer,
+                                       sizeof(int) * wrq->u.data.length)) {
+                        PRINTM(INFO, "Copy from user failed\n");
+                        return -EFAULT;
+                    }
+
+                    ctrl.Action = HostCmd_ACT_GEN_SET;
+                    ctrl.LedNums = 0;
+                    gpio->Header.Type = TLV_TYPE_LED_GPIO;
+                    gpio->Header.Len = wrq->u.data.length;
+                    for (i = 0; i < wrq->u.data.length; i += 2) {
+                        gpio->LedGpio[i / 2].LedNum = data[i];
+                        gpio->LedGpio[i / 2].GpioNum = data[i + 1];
+                    }
+                }
+                ret = PrepareAndSendCommand(priv,
+                                            HostCmd_CMD_802_11_LED_CONTROL, 0,
+                                            HostCmd_OPTION_WAITFORRSP,
+                                            0, (void *) &ctrl);
+
+                for (i = 0; i < gpio->Header.Len; i += 2) {
+                    data[i] = gpio->LedGpio[i / 2].LedNum;
+                    data[i + 1] = gpio->LedGpio[i / 2].GpioNum;
+                }
+                if (copy_to_user(wrq->u.data.pointer, data,
+                                 sizeof(int) * gpio->Header.Len)) {
+                    PRINTM(INFO, "Copy to user failed\n");
+                    return -EFAULT;
+                }
+
+                wrq->u.data.length = gpio->Header.Len;
+            }
+            break;
+        case WLAN_SLEEP_PERIOD:
+            ret = wlan_sleep_period(priv, wrq);
+            break;
+        case WLAN_ADAPT_RATESET:
+            ret = wlan_adapt_rateset(priv, wrq);
+            break;
+        case WLAN_INACTIVITY_TIMEOUT:
+            ret = wlan_inactivity_timeout(priv, wrq);
+            break;
+        case WLANSNR:
+            ret = wlan_get_snr(priv, wrq);
+            break;
+        case WLAN_GET_RATE:
+            ret = wlan_getrate_ioctl(priv, wrq);
+            break;
+        case WLAN_GET_RXINFO:
+            ret = wlan_get_rxinfo(priv, wrq);
+            break;
+        case WLAN_SET_ATIM_WINDOW:
+            ret = wlan_ATIM_Window(priv, wrq);
+            break;
+        case WLAN_BEACON_INTERVAL:
+            ret = wlan_beacon_interval(priv, wrq);
+            break;
+        case WLAN_SDIO_PULL_CTRL:
+            ret = wlan_sdio_pull_ctrl(priv, wrq);
+            break;
+        case WLAN_SCAN_TIME:
+            ret = wlan_scan_time(priv, wrq);
+            break;
+        case WLAN_DATA_SUBSCRIBE_EVENT:
+            ret = wlan_data_subscribe_event(priv, wrq);
+            break;
+        case WLAN_TXCONTROL:
+            ret = wlan_txcontrol(priv, wrq);
+            break;
+        case WLANHSCFG:
+            ret = wlan_hscfg_ioctl(priv, wrq);
+            break;
+        case WLANHSSETPARA:
+            ret = wlan_hssetpara_ioctl(priv, wrq);
+            break;
+#ifdef DEBUG_LEVEL1
+        case WLAN_DRV_DBG:
+            ret = wlan_drv_dbg(priv, wrq);
+            break;
+#endif
+        }
+        break;
+
+    case WLAN_SET_GET_2K:
+        switch ((int) wrq->u.data.flags) {
+        case WLAN_SET_USER_SCAN:
+            ret = wlan_set_user_scan_ioctl(priv, wrq);
+            break;
+        case WLAN_GET_SCAN_TABLE:
+            ret = wlan_get_scan_table_ioctl(priv, wrq);
+            break;
+        case WLAN_SET_MRVL_TLV:
+            ret = wlan_set_mrvl_tlv_ioctl(priv, wrq);
+            break;
+        case WLAN_GET_ASSOC_RSP:
+            ret = wlan_get_assoc_rsp_ioctl(priv, wrq);
+            break;
+        case WLAN_ADDTS_REQ:
+            ret = wlan_wmm_addts_req_ioctl(priv, wrq);
+            break;
+        case WLAN_DELTS_REQ:
+            ret = wlan_wmm_delts_req_ioctl(priv, wrq);
+            break;
+        case WLAN_QUEUE_CONFIG:
+            ret = wlan_wmm_queue_config_ioctl(priv, wrq);
+            break;
+        case WLAN_QUEUE_STATS:
+            ret = wlan_wmm_queue_stats_ioctl(priv, wrq);
+            break;
+        case WLAN_TX_PKT_STATS:
+            ret = wlan_tx_pkt_stats_ioctl(priv, wrq);
+            break;
+        case WLAN_GET_CFP_TABLE:
+            ret = wlan_get_cfp_table_ioctl(priv, wrq);
+            break;
+        default:
+            ret = -EOPNOTSUPP;
+        }
+        break;
+
+    default:
+        ret = -EINVAL;
+        break;
+    }
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get wireless statistics
+ *
+ *  NOTE: If PrepareAndSendCommand() with wait option is issued 
+ *    in this function, a kernel dump (scheduling while atomic) 
+ *    issue may happen on some versions of kernels.
+ *
+ *  @param dev		A pointer to net_device structure
+ *  @return 	   	A pointer to iw_statistics buf
+ */
+struct iw_statistics *
+wlan_get_wireless_stats(struct net_device *dev)
+{
+    enum {
+        POOR = 30,
+        FAIR = 60,
+        GOOD = 80,
+        VERY_GOOD = 90,
+        EXCELLENT = 95,
+        PERFECT = 100
+    };
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    u8 rssi;
+    u32 rssi_qual;
+    u32 tx_qual;
+    u32 quality = 0;
+    u32 tx_retries;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return NULL;
+    }
+
+    priv->wstats.status = Adapter->InfrastructureMode;
+    priv->wstats.discard.retries = priv->stats.tx_errors;
+
+    priv->wstats.qual.level =
+        CAL_RSSI(Adapter->SNR[TYPE_BEACON][TYPE_NOAVG],
+                 Adapter->NF[TYPE_BEACON][TYPE_NOAVG]);
+    priv->wstats.qual.noise = CAL_NF(Adapter->NF[TYPE_BEACON][TYPE_NOAVG]);
+    if (Adapter->NF[TYPE_BEACON][TYPE_NOAVG] == 0
+        && Adapter->MediaConnectStatus == WlanMediaStateConnected)
+        priv->wstats.qual.noise = MRVDRV_NF_DEFAULT_SCAN_VALUE;
+    else
+        priv->wstats.qual.noise =
+            CAL_NF(Adapter->NF[TYPE_BEACON][TYPE_NOAVG]);
+
+    rssi = priv->wstats.qual.level - priv->wstats.qual.noise;
+    if (rssi < 15)
+        rssi_qual = rssi * POOR / 10;
+    else if (rssi < 20)
+        rssi_qual = (rssi - 15) * (FAIR - POOR) / 5 + POOR;
+    else if (rssi < 30)
+        rssi_qual = (rssi - 20) * (GOOD - FAIR) / 5 + FAIR;
+    else if (rssi < 40)
+        rssi_qual = (rssi - 30) * (VERY_GOOD - GOOD) / 10 + GOOD;
+    else
+        rssi_qual = (rssi - 40) * (PERFECT - VERY_GOOD) / 10 + VERY_GOOD;
+    quality = rssi_qual;
+
+    tx_retries = Adapter->LogMsg.retry;
+
+    if (tx_retries > 75)
+        tx_qual = (90 - tx_retries) * POOR / 15;
+    else if (tx_retries > 70)
+        tx_qual = (75 - tx_retries) * (FAIR - POOR) / 5 + POOR;
+    else if (tx_retries > 65)
+        tx_qual = (70 - tx_retries) * (GOOD - FAIR) / 5 + FAIR;
+    else if (tx_retries > 50)
+        tx_qual = (65 - tx_retries) * (VERY_GOOD - GOOD) / 15 + GOOD;
+    else
+        tx_qual = (50 - tx_retries) * (PERFECT - VERY_GOOD) / 50 + VERY_GOOD;
+    quality = min(quality, tx_qual);
+
+    priv->wstats.qual.qual = min_t(u8, quality, 100);
+    priv->wstats.qual.updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;
+
+    PRINTM(INFO, "Signal Level = %#x\n", priv->wstats.qual.level);
+    PRINTM(INFO, "Noise = %#x\n", priv->wstats.qual.noise);
+
+    /* send RSSI command to get beacon RSSI/NF, valid only if associated */
+    PrepareAndSendCommand(priv, HostCmd_CMD_802_11_RSSI, 0, 0, 0, NULL);
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_GET_LOG, 0,
+                                0, 0, NULL);
+
+    if (!ret) {
+        priv->wstats.discard.code = 0;
+        priv->wstats.discard.fragment = Adapter->LogMsg.fcserror;
+        priv->wstats.discard.retries = Adapter->LogMsg.retry;
+        priv->wstats.discard.misc = Adapter->LogMsg.ackfailure;
+    }
+
+    return &priv->wstats;
+}
+
+static int
+wlan_set_coalescing_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    int data;
+    int *val;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    data = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+
+    switch (data) {
+    case CMD_DISABLED:
+    case CMD_ENABLED:
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_802_11_IBSS_COALESCING_STATUS,
+                                    HostCmd_ACT_SET,
+                                    HostCmd_OPTION_WAITFORRSP, 0, &data);
+        if (ret) {
+            LEAVE();
+            return ret;
+        }
+        break;
+
+    case CMD_GET:
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_802_11_IBSS_COALESCING_STATUS,
+                                    HostCmd_ACT_GET,
+                                    HostCmd_OPTION_WAITFORRSP, 0, &data);
+        if (ret) {
+            LEAVE();
+            return ret;
+        }
+        break;
+
+    default:
+        return -EINVAL;
+    }
+
+    val = (int *) wrq->u.name;
+    *val = data;
+
+    LEAVE();
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set frequency
+ *   
+ *  @param priv 		A pointer to wlan_private structure
+ *  @param info			A pointer to iw_request_info structure 
+ *  @param fwrq			A pointer to iw_freq structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+int
+wlan_set_freq(struct net_device *dev, struct iw_request_info *info,
+              struct iw_freq *fwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int rc = -EINPROGRESS;      /* Call commit handler */
+    CHANNEL_FREQ_POWER *cfp;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+    if (Adapter->InfrastructureMode != Wlan802_11IBSS)
+        return -EOPNOTSUPP;
+
+    /*
+     * If setting by frequency, convert to a channel 
+     */
+    if (fwrq->e == 1) {
+
+        long f = fwrq->m / 100000;
+        int c = 0;
+
+        cfp = find_cfp_by_band_and_freq(Adapter, 0, f);
+        if (!cfp) {
+            PRINTM(INFO, "Invalid freq=%ld\n", f);
+            return -EINVAL;
+        }
+
+        c = (int) cfp->Channel;
+
+        if (c < 0)
+            return -EINVAL;
+
+        fwrq->e = 0;
+        fwrq->m = c;
+    }
+
+    /*
+     * Setting by channel number 
+     */
+    if (fwrq->m > 1000 || fwrq->e > 0) {
+        rc = -EOPNOTSUPP;
+    } else {
+        int channel = fwrq->m;
+
+        cfp = find_cfp_by_band_and_channel(Adapter, 0, (u16) channel);
+        if (!cfp) {
+            rc = -EINVAL;
+        } else {
+            rc = ChangeAdhocChannel(priv, channel);
+            /*  If station is WEP enabled, send the 
+             *  command to set WEP in firmware
+             */
+            if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPEnabled) {
+                PRINTM(INFO, "set_freq: WEP Enabled\n");
+                ret = PrepareAndSendCommand(priv,
+                                            HostCmd_CMD_802_11_SET_WEP,
+                                            0, HostCmd_OPTION_WAITFORRSP,
+                                            OID_802_11_ADD_WEP, NULL);
+
+                if (ret) {
+                    LEAVE();
+                    return ret;
+                }
+                Adapter->CurrentPacketFilter |= HostCmd_ACT_MAC_WEP_ENABLE;
+
+                PrepareAndSendCommand(priv,
+                                      HostCmd_CMD_MAC_CONTROL,
+                                      0, HostCmd_OPTION_WAITFORRSP,
+                                      0, &Adapter->CurrentPacketFilter);
+            }
+        }
+    }
+
+    LEAVE();
+    return rc;
+}
+
+/** 
+ *  @brief Set Deep Sleep 
+ *   
+ *  @param adapter 	A pointer to wlan_private structure
+ *  @param bDeepSleep	TRUE--enalbe deepsleep, FALSE--disable deepsleep
+ *  @return 	   	WLAN_STATUS_SUCCESS-success, otherwise fail
+ */
+
+int
+SetDeepSleep(wlan_private * priv, BOOLEAN bDeepSleep)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (bDeepSleep == TRUE) {
+        if (Adapter->IsDeepSleep != TRUE) {
+            PRINTM(INFO, "Deep Sleep: sleep\n");
+
+            // note: the command could be queued and executed later
+            //       if there is command in prigressing.
+            ret = PrepareAndSendCommand(priv,
+                                        HostCmd_CMD_802_11_DEEP_SLEEP, 0,
+                                        HostCmd_OPTION_WAITFORRSP, 0, NULL);
+
+            if (ret) {
+                LEAVE();
+                return ret;
+            }
+            wmm_stop_queue(priv);
+            os_stop_queue(priv);
+            os_carrier_off(priv);
+        }
+    } else {
+        if (Adapter->IsDeepSleep == TRUE) {
+            PRINTM(CMND, "Deep Sleep: wakeup\n");
+
+            if (Adapter->IntCounterSaved) {
+                Adapter->IntCounter = Adapter->IntCounterSaved;
+                Adapter->IntCounterSaved = 0;
+            }
+
+            if (sbi_exit_deep_sleep(priv))
+                PRINTM(ERROR, "Deep Sleep : wakeup failed\n");
+
+            if (Adapter->IsDeepSleep == TRUE) {
+
+                if (os_wait_interruptible_timeout(Adapter->ds_awake_q,
+                                                  !Adapter->IsDeepSleep,
+                                                  MRVDRV_DEEP_SLEEP_EXIT_TIMEOUT)
+                    == 0) {
+                    PRINTM(MSG, "ds_awake_q: timer expired\n");
+                }
+            }
+
+            if (Adapter->IntCounter)
+                wake_up_interruptible(&priv->MainThread.waitQ);
+        }
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief use index to get the data rate
+ *   
+ *  @param index                The index of data rate
+ *  @return 	   		data rate or 0 
+ */
+u32
+index_to_data_rate(u8 index)
+{
+    if (index >= sizeof(WlanDataRates))
+        index = 0;
+
+    return WlanDataRates[index];
+}
+
+/** 
+ *  @brief use rate to get the index
+ *   
+ *  @param rate                 data rate
+ *  @return 	   		index or 0 
+ */
+u8
+data_rate_to_index(u32 rate)
+{
+    u8 *ptr;
+
+    if (rate)
+        if ((ptr = wlan_memchr(WlanDataRates, (u8) rate,
+                               sizeof(WlanDataRates))))
+            return (ptr - WlanDataRates);
+
+    return 0;
+}
+
+/** 
+ *  @brief set data rate
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+
+int
+wlan_set_rate(struct net_device *dev, struct iw_request_info *info,
+              struct iw_param *vwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    u32 data_rate;
+    int ret = WLAN_STATUS_SUCCESS;
+    WLAN_802_11_RATES rates;
+    u8 *rate;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    PRINTM(INFO, "Vwrq->value = %d\n", vwrq->value);
+
+    if (vwrq->value == -1) {
+        Adapter->DataRate = 0;
+        Adapter->RateBitmap = 0;
+        memset(rates, 0, sizeof(rates));
+        get_active_data_rates(Adapter, rates);
+        rate = rates;
+        while (*rate) {
+            Adapter->RateBitmap |= 1 << (data_rate_to_index(*rate & 0x7f));
+            rate++;
+        }
+        Adapter->Is_DataRate_Auto = TRUE;
+    } else {
+        if ((vwrq->value % 500000)) {
+            return -EINVAL;
+        }
+
+        data_rate = vwrq->value / 500000;
+
+        memset(rates, 0, sizeof(rates));
+        get_active_data_rates(Adapter, rates);
+        rate = rates;
+        while (*rate) {
+            PRINTM(INFO, "Rate=0x%X  Wanted=0x%X\n", *rate, data_rate);
+            if ((*rate & 0x7f) == (data_rate & 0x7f))
+                break;
+            rate++;
+        }
+        if (!*rate) {
+            PRINTM(MSG, "The fixed data rate 0x%X is out "
+                   "of range.\n", data_rate);
+            return -EINVAL;
+        }
+
+        Adapter->DataRate = data_rate;
+        Adapter->RateBitmap = 1 << (data_rate_to_index(Adapter->DataRate));
+        Adapter->Is_DataRate_Auto = FALSE;
+    }
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_RATE_ADAPT_RATESET,
+                                HostCmd_ACT_GEN_SET,
+                                HostCmd_OPTION_WAITFORRSP, 0, NULL);
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief get data rate
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_get_rate(struct net_device *dev, struct iw_request_info *info,
+              struct iw_param *vwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    if (Adapter->Is_DataRate_Auto)
+        vwrq->fixed = 0;
+    else
+        vwrq->fixed = 1;
+
+    Adapter->TxRate = 0;
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_TX_RATE_QUERY,
+                                HostCmd_ACT_GET, HostCmd_OPTION_WAITFORRSP,
+                                0, NULL);
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+    vwrq->value = index_to_data_rate(Adapter->TxRate) * 500000;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief set wireless mode 
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_set_mode(struct net_device *dev,
+              struct iw_request_info *info, u32 * uwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+
+    WLAN_802_11_NETWORK_INFRASTRUCTURE WantedMode;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    switch (*uwrq) {
+    case IW_MODE_ADHOC:
+        PRINTM(INFO, "Wanted Mode is ad-hoc: current DataRate=%#x\n",
+               Adapter->DataRate);
+        WantedMode = Wlan802_11IBSS;
+        break;
+
+    case IW_MODE_INFRA:
+        PRINTM(INFO, "Wanted Mode is Infrastructure\n");
+        WantedMode = Wlan802_11Infrastructure;
+        break;
+
+    case IW_MODE_AUTO:
+        PRINTM(INFO, "Wanted Mode is Auto\n");
+        WantedMode = Wlan802_11AutoUnknown;
+        break;
+
+    default:
+        PRINTM(INFO, "Wanted Mode is Unknown: 0x%x\n", *uwrq);
+        return -EINVAL;
+    }
+
+    if (Adapter->InfrastructureMode == WantedMode ||
+        WantedMode == Wlan802_11AutoUnknown) {
+        PRINTM(INFO, "Already set to required mode! No change!\n");
+
+        Adapter->InfrastructureMode = WantedMode;
+
+        LEAVE();
+        return WLAN_STATUS_SUCCESS;
+    }
+
+    if (Adapter->InfrastructureMode == Wlan802_11Infrastructure) {
+        if (Adapter->PSState != PS_STATE_FULL_POWER) {
+            PSWakeup(priv, HostCmd_OPTION_WAITFORRSP);
+        }
+        Adapter->PSMode = Wlan802_11PowerModeCAM;
+    }
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        if (Adapter->InfrastructureMode == Wlan802_11Infrastructure) {
+            ret = SendDeauthentication(priv);
+            if (ret) {
+                LEAVE();
+                return ret;
+            }
+        } else if (Adapter->InfrastructureMode == Wlan802_11IBSS) {
+            /* If current mode is Adhoc, clean stale information */
+            ret = StopAdhocNetwork(priv);
+
+            if (ret) {
+                LEAVE();
+                return ret;
+            }
+        }
+    }
+
+    Adapter->SecInfo.AuthenticationMode = Wlan802_11AuthModeOpen;
+
+    Adapter->InfrastructureMode = WantedMode;
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_SNMP_MIB,
+                                0, HostCmd_OPTION_WAITFORRSP,
+                                OID_802_11_INFRASTRUCTURE_MODE, NULL);
+
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set Encryption key
+ *   
+ *  @param dev      A pointer to net_device structure
+ *  @param info     A pointer to iw_request_info structure
+ *  @param vwrq     A pointer to iw_param structure
+ *  @param extra    A pointer to extra data buf
+ *  @return         WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_encode(struct net_device *dev,
+                struct iw_request_info *info,
+                struct iw_point *dwrq, char *extra)
+{
+
+    WLAN_802_11_KEY *pKey = NULL;
+    int retval = -EINVAL;
+
+    ENTER();
+
+    if (dwrq->length > MAX_WEP_KEY_SIZE) {
+        pKey = (WLAN_802_11_KEY *) extra;
+        if (pKey->KeyLength <= MAX_WEP_KEY_SIZE) {
+            //dynamic WEP
+            dwrq->length = pKey->KeyLength;
+            dwrq->flags = pKey->KeyIndex + 1;
+            retval = wlan_set_encode_nonwpa(dev, info, dwrq,
+                                            pKey->KeyMaterial);
+        } else {
+            //WPA
+            retval = wlan_set_encode_wpa(dev, info, dwrq, extra);
+        }
+    } else {
+        //static WEP
+        PRINTM(INFO, "Setting WEP\n");
+        retval = wlan_set_encode_nonwpa(dev, info, dwrq, extra);
+    }
+
+    return retval;
+}
+
+/** 
+ *  @brief set tx power 
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_set_txpow(struct net_device *dev, struct iw_request_info *info,
+               struct iw_param *vwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    u16 dbm;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    if (vwrq->disabled) {
+        wlan_radio_ioctl(priv, RADIO_OFF);
+        return WLAN_STATUS_SUCCESS;
+    }
+
+    wlan_radio_ioctl(priv, RADIO_ON);
+
+#if WIRELESS_EXT > 14
+    if ((vwrq->flags & IW_TXPOW_TYPE) == IW_TXPOW_MWATT) {
+        dbm = (u16) mw_to_dbm(vwrq->value);
+    } else
+#endif
+        dbm = (u16) vwrq->value;
+
+    if ((dbm < Adapter->MinTxPowerLevel) || (dbm > Adapter->MaxTxPowerLevel)) {
+        PRINTM(MSG,
+               "The set txpower value %d dBm is out of range (%d dBm-%d dBm)!\n",
+               dbm, Adapter->MinTxPowerLevel, Adapter->MaxTxPowerLevel);
+        LEAVE();
+        return -EINVAL;
+    }
+
+    /* auto tx power control */
+
+    if (vwrq->fixed == 0)
+        dbm = 0xffff;
+
+    PRINTM(INFO, "<1>TXPOWER SET %d dbm.\n", dbm);
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_RF_TX_POWER,
+                                HostCmd_ACT_GEN_SET,
+                                HostCmd_OPTION_WAITFORRSP, 0, (void *) &dbm);
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get current essid 
+ *   
+ *  @param dev      A pointer to net_device structure
+ *  @param info     A pointer to iw_request_info structure
+ *  @param vwrq     A pointer to iw_param structure
+ *  @param extra    A pointer to extra data buf
+ *  @return         WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_get_essid(struct net_device *dev, struct iw_request_info *info,
+               struct iw_point *dwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int tblIdx = -1;
+    BSSDescriptor_t *pBSSDesc;
+
+    ENTER();
+
+    pBSSDesc = &Adapter->CurBssParams.BSSDescriptor;
+
+    /*
+     * Get the current SSID 
+     */
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+
+        tblIdx = FindSSIDInList(Adapter,
+                                &pBSSDesc->Ssid,
+                                pBSSDesc->MacAddress,
+                                Adapter->InfrastructureMode);
+
+        memcpy(extra, &pBSSDesc->Ssid.Ssid, pBSSDesc->Ssid.SsidLength);
+        extra[pBSSDesc->Ssid.SsidLength] = '\0';
+
+    } else {
+        memset(extra, 0, 32);
+        extra[pBSSDesc->Ssid.SsidLength] = '\0';
+    }
+
+    /* To make the driver backward compatible with WPA supplicant v0.2.4 */
+    if (dwrq->length == 32) {
+        dwrq->length = MIN(pBSSDesc->Ssid.SsidLength, IW_ESSID_MAX_SIZE);
+    } else {
+#if WIRELESS_EXT > 20
+        dwrq->length = pBSSDesc->Ssid.SsidLength;
+#else
+        dwrq->length = pBSSDesc->Ssid.SsidLength + 1;
+#endif
+    }
+
+    /* If the current network is in the table, return the table index */
+    if (tblIdx >= 0) {
+        dwrq->flags = (tblIdx + 1) & IW_ENCODE_INDEX;
+    } else {
+        dwrq->flags = 1;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get version 
+ *   
+ *  @param adapter              A pointer to wlan_adapter structure
+ *  @param version		A pointer to version buffer
+ *  @param maxlen		max length of version buffer
+ *  @return 	   		NA
+ */
+void
+get_version(wlan_adapter * adapter, char *version, int maxlen)
+{
+    union
+    {
+        u32 l;
+        u8 c[4];
+    } ver;
+    char fwver[32];
+
+    ver.l = adapter->FWReleaseNumber;
+    if (ver.c[3] == 0)
+        sprintf(fwver, "%u.%u.%u", ver.c[2], ver.c[1], ver.c[0]);
+    else
+        sprintf(fwver, "%u.%u.%u.p%u",
+                ver.c[2], ver.c[1], ver.c[0], ver.c[3]);
+
+    snprintf(version, maxlen, driver_version, fwver);
+}
Index: linux-2.6.29/drivers/net/wireless/marvell8686/wlan_wext.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/wlan_wext.h	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,406 @@
+/** @file wlan_wext.h
+ * @brief This file contains definition for IOCTL call.
+ *  
+ *  Copyright  Marvell International Ltd. and/or its affiliates, 2003-2007
+ */
+/********************************************************
+Change log:
+	10/11/05: Add Doxygen format comments
+	12/19/05: Correct a typo in structure _wlan_ioctl_wmm_tspec
+	01/11/06: Conditionalize new scan/join ioctls
+	04/10/06: Add hostcmd generic API
+	04/18/06: Remove old Subscrive Event and add new Subscribe Event
+	          implementation through generic hostcmd API
+	06/08/06: Add definitions of custom events
+	08/29/06: Add ledgpio private command
+********************************************************/
+
+#ifndef	_WLAN_WEXT_H_
+#define	_WLAN_WEXT_H_
+
+#include "wlan_types.h"
+
+#define SUBCMD_OFFSET			4
+/** PRIVATE CMD ID */
+#define	WLANIOCTL			0x8BE0
+
+#define WLANSETWPAIE			(WLANIOCTL + 0)
+#define WLANCISDUMP 			(WLANIOCTL + 1)
+#ifdef MFG_CMD_SUPPORT
+#define	WLANMANFCMD			(WLANIOCTL + 2)
+#endif
+#define	WLANREGRDWR			(WLANIOCTL + 3)
+#define MAX_EEPROM_DATA     			256
+#define	WLANHOSTCMD			(WLANIOCTL + 4)
+
+#define WLANHOSTSLEEPCFG		(WLANIOCTL + 5)
+#define WLANARPFILTER			(WLANIOCTL + 6)
+
+#define WLAN_SETINT_GETINT		(WLANIOCTL + 7)
+#define WLANNF					1
+#define WLANRSSI				2
+#define WLANBGSCAN				4
+#define WLANENABLE11D				5
+#define WLANADHOCGRATE				6
+#define WLANSDIOCLOCK				7
+#define WLANWMM_ENABLE				8
+#define WLANNULLGEN				10
+#define WLANADHOCCSET				11
+#define WLAN_ADHOC_G_PROT			12
+
+#define WLAN_SETNONE_GETNONE	        (WLANIOCTL + 8)
+#define WLANDEAUTH                  		1
+#define WLANRADIOON                 		2
+#define WLANRADIOOFF                		3
+#define WLANREMOVEADHOCAES          		4
+#define WLANADHOCSTOP               		5
+#ifdef REASSOCIATION
+#define WLANREASSOCIATIONAUTO			8
+#define WLANREASSOCIATIONUSER			9
+#endif /* REASSOCIATION */
+#define WLANWLANIDLEON				10
+#define WLANWLANIDLEOFF				11
+
+#define WLANGETLOG                  	(WLANIOCTL + 9)
+#define WLAN_SETCONF_GETCONF		(WLANIOCTL + 10)
+
+#define BG_SCAN_CONFIG				1
+#define CAL_DATA_EXT_CONFIG         2
+
+#define WLANSCAN_TYPE			(WLANIOCTL + 11)
+
+#define WLAN_SET_GET_2K         (WLANIOCTL + 13)
+#define WLAN_SET_USER_SCAN              1
+#define WLAN_GET_SCAN_TABLE             2
+#define WLAN_SET_MRVL_TLV               3
+#define WLAN_GET_ASSOC_RSP              4
+#define WLAN_ADDTS_REQ                  5
+#define WLAN_DELTS_REQ                  6
+#define WLAN_QUEUE_CONFIG               7
+#define WLAN_QUEUE_STATS                8
+#define WLAN_GET_CFP_TABLE              9
+#define WLAN_TX_PKT_STATS              12
+
+#define WLAN_SETNONE_GETONEINT		(WLANIOCTL + 15)
+#define WLANGETREGION				1
+#define WLAN_GET_LISTEN_INTERVAL		2
+#define WLAN_GET_MULTIPLE_DTIM			3
+#define WLAN_GET_TX_RATE			4
+#define	WLANGETBCNAVG				5
+#define WLANGETDATAAVG				6
+#define WLANGETDTIM   				7
+
+#define WLAN_SETNONE_GETTWELVE_CHAR (WLANIOCTL + 19)
+#define WLAN_SUBCMD_GETRXANTENNA    1
+#define WLAN_SUBCMD_GETTXANTENNA    2
+#define WLAN_GET_TSF                3
+#define WLAN_WPS_SESSION            4
+
+#define WLAN_SETWORDCHAR_GETNONE	(WLANIOCTL + 20)
+#define WLANSETADHOCAES				1
+
+#define WLAN_SETONEINT_GETWORDCHAR	(WLANIOCTL + 21)
+#define WLANGETADHOCAES				1
+#define WLANVERSION				2
+#define WLANVEREXT				3
+
+#define WLAN_SETONEINT_GETONEINT	(WLANIOCTL + 23)
+#define WLAN_WMM_QOSINFO			2
+#define	WLAN_LISTENINTRVL			3
+#define WLAN_FW_WAKEUP_METHOD			4
+#define WAKEUP_FW_UNCHANGED			0
+#define WAKEUP_FW_THRU_INTERFACE		1
+#define WAKEUP_FW_THRU_GPIO			2
+
+#define WLAN_NULLPKTINTERVAL			5
+#define WLAN_BCN_MISS_TIMEOUT			6
+#define WLAN_ADHOC_AWAKE_PERIOD			7
+#define WLAN_LDO				8
+#define	WLAN_SDIO_MODE				9
+#define WLAN_AUTODEEPSLEEP			12
+#define WLAN_WAKEUP_MT				13
+
+#define WLAN_RTS_CTS_CTRL			14
+
+#define WLAN_SETONEINT_GETNONE		(WLANIOCTL + 24)
+#define WLAN_SUBCMD_SETRXANTENNA		1
+#define WLAN_SUBCMD_SETTXANTENNA		2
+#define WLANSETAUTHALG				4
+#define WLANSETENCRYPTIONMODE			5
+#define WLANSETREGION				6
+#define WLAN_SET_LISTEN_INTERVAL		7
+
+#define WLAN_SET_MULTIPLE_DTIM			8
+
+#define WLANSETBCNAVG				9
+#define WLANSETDATAAVG				10
+#define WLANASSOCIATE				11
+
+#define WLAN_SET64CHAR_GET64CHAR	(WLANIOCTL + 25)
+#define WLANSLEEPPARAMS 			2
+#define	WLAN_BCA_TIMESHARE			3
+#define WLANSCAN_MODE				6
+
+#define WLAN_GET_ADHOC_STATUS			9
+
+#define WLAN_SET_GEN_IE                 	10
+#define WLAN_GET_GEN_IE                 	11
+
+#define WLAN_WMM_QUEUE_STATUS               13
+
+#define WLANEXTSCAN			(WLANIOCTL + 26)
+#define WLANDEEPSLEEP			(WLANIOCTL + 27)
+#define DEEP_SLEEP_ENABLE			1
+#define DEEP_SLEEP_DISABLE  			0
+
+#define WLAN_SET_GET_SIXTEEN_INT       (WLANIOCTL + 29)
+#define WLAN_TPCCFG                             1
+#define WLAN_LED_GPIO_CTRL			5
+#define WLAN_SCANPROBES 			6
+#define WLAN_SLEEP_PERIOD			7
+#define	WLAN_ADAPT_RATESET			8
+#define	WLAN_INACTIVITY_TIMEOUT			9
+#define WLANSNR					10
+#define WLAN_GET_RATE				11
+#define	WLAN_GET_RXINFO				12
+#define	WLAN_SET_ATIM_WINDOW			13
+#define WLAN_BEACON_INTERVAL			14
+#define WLAN_SDIO_PULL_CTRL			15
+#define WLAN_SCAN_TIME				16
+#define WLAN_DATA_SUBSCRIBE_EVENT		18
+#define WLAN_TXCONTROL				19
+#define WLANHSCFG				21
+#define WLANHSSETPARA				22
+#ifdef DEBUG_LEVEL1
+#define WLAN_DRV_DBG				25
+#endif
+
+#define WLANCMD52RDWR			(WLANIOCTL + 30)
+#define WLANCMD53RDWR			(WLANIOCTL + 31)
+#define CMD53BUFLEN				32
+
+#define	REG_MAC					0x19
+#define	REG_BBP					0x1a
+#define	REG_RF					0x1b
+#define	REG_EEPROM				0x59
+
+#define	CMD_DISABLED				0
+#define	CMD_ENABLED				1
+#define	CMD_GET					2
+#define SKIP_CMDNUM				4
+#define SKIP_TYPE				1
+#define SKIP_SIZE				2
+#define SKIP_ACTION				2
+#define SKIP_TYPE_SIZE			(SKIP_TYPE + SKIP_SIZE)
+#define SKIP_TYPE_ACTION		(SKIP_TYPE + SKIP_ACTION)
+
+#define MAX_SETGET_CONF_SIZE		2000    /* less than MRVDRV_SIZE_OF_CMD_BUFFER */
+#define MAX_SETGET_CONF_CMD_LEN		(MAX_SETGET_CONF_SIZE - SKIP_CMDNUM)
+
+/* define custom events */
+#define CUS_EVT_HS_ACTIVATED		"HS_ACTIVATED "
+#define CUS_EVT_HS_DEACTIVATED		"HS_DEACTIVATED "
+#define CUS_EVT_HS_GPIO_INT		"HS_GPIO_INT "
+#define CUS_EVT_BEACON_RSSI_LOW		"EVENT=BEACON_RSSI_LOW"
+#define CUS_EVT_BEACON_SNR_LOW		"EVENT=BEACON_SNR_LOW"
+#define CUS_EVT_BEACON_RSSI_HIGH	"EVENT=BEACON_RSSI_HIGH"
+#define CUS_EVT_BEACON_SNR_HIGH		"EVENT=BEACON_SNR_HIGH"
+#define CUS_EVT_MAX_FAIL		"EVENT=MAX_FAIL"
+#define CUS_EVT_MLME_MIC_ERR_UNI	"MLME-MICHAELMICFAILURE.indication unicast "
+#define CUS_EVT_MLME_MIC_ERR_MUL	"MLME-MICHAELMICFAILURE.indication multicast "
+
+#define CUS_EVT_DATA_RSSI_LOW		"EVENT=DATA_RSSI_LOW"
+#define CUS_EVT_DATA_SNR_LOW		"EVENT=DATA_SNR_LOW"
+#define CUS_EVT_DATA_RSSI_HIGH		"EVENT=DATA_RSSI_HIGH"
+#define CUS_EVT_DATA_SNR_HIGH		"EVENT=DATA_SNR_HIGH"
+#define CUS_EVT_PRE_BEACON_LOST		"EVENT=PRE_BEACON_LOST"
+
+#define CUS_EVT_DEEP_SLEEP_AWAKE	"EVENT=DS_AWAKE"
+
+#define CUS_EVT_ADHOC_LINK_SENSED	"EVENT=ADHOC_LINK_SENSED"
+#define CUS_EVT_ADHOC_BCN_LOST		"EVENT=ADHOC_BCN_LOST"
+
+/**
+ *  @brief Maximum number of channels that can be sent in a setuserscan ioctl
+ *
+ *  @sa wlan_ioctl_user_scan_cfg
+ */
+#define WLAN_IOCTL_USER_SCAN_CHAN_MAX  50
+
+/** wlan_ioctl */
+typedef struct _wlan_ioctl
+{
+        /** Command ID */
+    u16 command;
+        /** data length */
+    u16 len;
+        /** data pointer */
+    u8 *data;
+} wlan_ioctl;
+
+/** wlan_ioctl_rfantenna */
+typedef struct _wlan_ioctl_rfantenna
+{
+    u16 Action;
+    u16 AntennaMode;
+} wlan_ioctl_rfantenna;
+
+/** wlan_ioctl_regrdwr */
+typedef struct _wlan_ioctl_regrdwr
+{
+        /** Which register to access */
+    u16 WhichReg;
+        /** Read or Write */
+    u16 Action;
+    u32 Offset;
+    u16 NOB;
+    u32 Value;
+} wlan_ioctl_regrdwr;
+
+/** wlan_ioctl_cfregrdwr */
+typedef struct _wlan_ioctl_cfregrdwr
+{
+        /** Read or Write */
+    u8 Action;
+        /** register address */
+    u16 Offset;
+        /** register value */
+    u16 Value;
+} wlan_ioctl_cfregrdwr;
+
+/** wlan_ioctl_adhoc_key_info */
+typedef struct _wlan_ioctl_adhoc_key_info
+{
+    u16 action;
+    u8 key[16];
+    u8 tkiptxmickey[16];
+    u8 tkiprxmickey[16];
+} wlan_ioctl_adhoc_key_info;
+
+/** sleep_params */
+typedef struct _wlan_ioctl_sleep_params_config
+{
+    u16 Action;
+    u16 Error;
+    u16 Offset;
+    u16 StableTime;
+    u8 CalControl;
+    u8 ExtSleepClk;
+    u16 Reserved;
+} __ATTRIB_PACK__ wlan_ioctl_sleep_params_config,
+    *pwlan_ioctl_sleep_params_config;
+
+/** BCA TIME SHARE */
+typedef struct _wlan_ioctl_bca_timeshare_config
+{
+        /** ACT_GET/ACT_SET */
+    u16 Action;
+        /** Type: WLAN, BT */
+    u16 TrafficType;
+        /** Interval: 20msec - 60000msec */
+    u32 TimeShareInterval;
+        /** PTA arbiter time in msec */
+    u32 BTTime;
+} __ATTRIB_PACK__ wlan_ioctl_bca_timeshare_config,
+    *pwlan_ioctl_bca_timeshare_config;
+
+#define MAX_CFP_LIST_NUM	64
+
+/** wlan_ioctl_cfp_table */
+typedef struct _wlan_ioctl_cfp_table
+{
+    u32 region;
+    u32 cfp_no;
+    struct
+    {
+        u16 Channel;
+        u32 Freq;
+        u16 MaxTxPower;
+        u8 Unsupported;
+    } cfp[MAX_CFP_LIST_NUM];
+} __ATTRIB_PACK__ wlan_ioctl_cfp_table, *pwlan_ioctl_cfp_table;
+
+/**
+ *  @brief IOCTL channel sub-structure sent in wlan_ioctl_user_scan_cfg
+ *
+ *  Multiple instances of this structure are included in the IOCTL command
+ *   to configure a instance of a scan on the specific channel.
+ */
+typedef struct
+{
+    u8 chanNumber;              //!< Channel Number to scan
+    u8 radioType;               //!< Radio type: 'B/G' Band = 0, 'A' Band = 1
+    u8 scanType;                //!< Scan type: Active = 0, Passive = 1
+    u8 reserved;
+    u16 scanTime;               //!< Scan duration in milliseconds; if 0 default used
+} __ATTRIB_PACK__ wlan_ioctl_user_scan_chan;
+/**
+ *  @brief IOCTL SSID List sub-structure sent in wlan_ioctl_user_scan_cfg
+ * 
+ *  Used to specify SSID specific filters as well as SSID pattern matching
+ *    filters for scan result processing in firmware.
+ */
+typedef struct
+{
+    char ssid[MRVDRV_MAX_SSID_LENGTH + 1];
+    u8 maxLen;
+} __ATTRIB_PACK__ wlan_ioctl_user_scan_ssid;
+
+/**
+ *  @brief IOCTL input structure to configure an immediate scan cmd to firmware
+ *
+ *  Used in the setuserscan (WLAN_SET_USER_SCAN) private ioctl.  Specifies
+ *   a number of parameters to be used in general for the scan as well
+ *   as a channel list (wlan_ioctl_user_scan_chan) for each scan period
+ *   desired.
+ *
+ *  @sa wlan_set_user_scan_ioctl
+ */
+typedef struct
+{
+
+    /**
+     *  @brief Flag set to keep the previous scan table intact
+     *
+     *  If set, the scan results will accumulate, replacing any previous
+     *   matched entries for a BSS with the new scan data
+     */
+    u8 keepPreviousScan;        //!< Do not erase the existing scan results
+
+    /**
+     *  @brief BSS Type to be sent in the firmware command
+     *
+     *  Field can be used to restrict the types of networks returned in the
+     *    scan.  Valid settings are:
+     *
+     *   - WLAN_SCAN_BSS_TYPE_BSS  (infrastructure)
+     *   - WLAN_SCAN_BSS_TYPE_IBSS (adhoc)
+     *   - WLAN_SCAN_BSS_TYPE_ANY  (unrestricted, adhoc and infrastructure)
+     */
+    u8 bssType;
+
+    /**
+     *  @brief Configure the number of probe requests for active chan scans
+     */
+    u8 numProbes;
+
+    u8 reserved;
+
+    /**
+     *  @brief BSSID filter sent in the firmware command to limit the results
+     */
+    u8 specificBSSID[MRVDRV_ETH_ADDR_LEN];
+
+    /**
+     *  @brief SSID filter list used in the to limit the scan results
+     */
+    wlan_ioctl_user_scan_ssid ssidList[MRVDRV_MAX_SSID_LIST_LENGTH];
+
+    /**
+     *  @brief Variable number (fixed maximum) of channels to scan up
+     */
+    wlan_ioctl_user_scan_chan chanList[WLAN_IOCTL_USER_SCAN_CHAN_MAX];
+
+} __ATTRIB_PACK__ wlan_ioctl_user_scan_cfg;
+
+#endif /* _WLAN_WEXT_H_ */
Index: linux-2.6.29/drivers/net/wireless/marvell8686/wlan_wmm.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/wlan_wmm.c	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,1666 @@
+/** @file wlan_wmm.c
+ * @brief This file contains functions for WMM.
+ * 
+ *  Copyright  Marvell International Ltd. and/or its affiliates, 2003-2006
+ */
+/********************************************************
+Change log:
+    10/04/05: Add Doxygen format comments
+    11/11/05: Add support for WMM Status change event
+    01/05/06: Add kernel 2.6.x support  
+    01/11/06: Conditionalize new scan/join code modifications.
+    04/06/06: Add TSPEC, queue metrics, and MSDU expiry support
+********************************************************/
+#include    "include.h"
+
+/********************************************************
+        Local Variables
+********************************************************/
+
+/** Maximum value FW can accept for driver delay in packet transmission */
+#define DRV_PKT_DELAY_TO_FW_MAX   512
+
+/** Set limit of driver packet delay for use in MSDU lifetime expiry and
+ *   traffic stream metrics.
+ *
+ *   - Set to 0 to disable driver delay in firmware
+ *   - Set to DRV_PKT_DELAY_TO_FW_MAX to enable all possible values
+ */
+#define DRV_PKT_DELAY_TO_FW_LIMIT  0
+
+/** Upper and Lower threshold for packet queuing in the driver
+ *
+ *    - When the number of packets queued reaches the upper limit,
+ *      the driver will stop the net queue in the app/kernel space.
+ *
+ *    - When the number of packets drops beneath the lower limit after
+ *      having reached the upper limit, the driver will restart the net
+ *      queue.
+ */
+#define WMM_QUEUED_PACKET_LOWER_LIMIT   40
+#define WMM_QUEUED_PACKET_UPPER_LIMIT   50
+
+#define IPTOS_OFFSET 5
+
+static const u8 wmm_info_ie[] = { WMM_IE, 0x07,
+    0x00, 0x50, 0xf2, 0x02,
+    0x00, 0x01, 0x00
+};
+
+/********************************************************
+        Local Functions
+********************************************************/
+#ifdef DEBUG_LEVEL2
+/** 
+ *  @brief Debug print function to display the priority parameters for a WMM AC
+ *
+ *  @param acStr    String pointer giving the AC enumeration (BK, BE, VI, VO)
+ *  @param pACParam Pointer to the AC paramters to display
+ *
+ *  @return         void
+ */
+static void
+wmm_debugPrintAC(wlan_wmm_ac_e acVal,
+                 const IEEEtypes_WmmAcParameters_t * pACParam)
+{
+    const char *acStr[] = { "BK", "BE", "VI", "VO" };
+
+    PRINTM(INFO, "WMM AC_%s: ACI=%d, ACM=%d, Aifsn=%d, "
+           "EcwMin=%d, EcwMax=%d, TxopLimit=%d\n",
+           acStr[acVal], pACParam->AciAifsn.Aci, pACParam->AciAifsn.Acm,
+           pACParam->AciAifsn.Aifsn, pACParam->Ecw.EcwMin,
+           pACParam->Ecw.EcwMax, wlan_le16_to_cpu(pACParam->TxopLimit));
+}
+
+#define PRINTM_AC(acStr, pACParam) wmm_debugPrintAC(acStr, pACParam)
+#else
+#define PRINTM_AC(acStr, pACParam)
+#endif
+
+/**
+ *  @brief Compute the difference between two timestamps.
+ *
+ *  @param pTv1 Pointer to timestamp1
+ *  @param pTv2 Pointer to timestamp2
+ *
+ *  @return Time difference in ms between pTv1 and pTv2 (pTv1 - pTv2)
+ */
+static int
+timeval_diff_in_ms(const struct timeval *pTv1, const struct timeval *pTv2)
+{
+    int diff_ms;
+
+    diff_ms = (pTv1->tv_sec - pTv2->tv_sec) * 1000;
+    diff_ms += (pTv1->tv_usec - pTv2->tv_usec) / 1000;
+
+    return diff_ms;
+}
+
+/** 
+ *  @brief Set the WMM queue priorities to their default values
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *
+ *  @return         void
+ */
+static void
+wmm_default_queue_priorities(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    /* default queue priorities: VO->VI->BE->BK */
+    Adapter->wmm.queuePriority[0] = WMM_AC_VO;
+    Adapter->wmm.queuePriority[1] = WMM_AC_VI;
+    Adapter->wmm.queuePriority[2] = WMM_AC_BE;
+    Adapter->wmm.queuePriority[3] = WMM_AC_BK;
+}
+
+/** 
+ *  @brief Initialize WMM priority queues
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *
+ *  @return         void
+ */
+static void
+wmm_setup_queue_priorities(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    IEEEtypes_WmmParameter_t *pWmmIe;
+    wlan_wmm_ac_e acOrder[4] = { WMM_AC_BE, WMM_AC_BK,
+        WMM_AC_VI, WMM_AC_VO
+    };
+
+    u16 cwmax, cwmin, avg_back_off, tmp[4];
+    int i, j, numAc;
+
+    if (Adapter->wmm.enabled == FALSE) {
+        /* WMM is not enabled, just set the defaults and return */
+        wmm_default_queue_priorities(priv);
+        return;
+    }
+
+    pWmmIe = &Adapter->CurBssParams.BSSDescriptor.wmmIE;
+
+    HEXDUMP("WMM: setup_queue_priorities: param IE",
+            (u8 *) pWmmIe, sizeof(IEEEtypes_WmmParameter_t));
+
+    PRINTM(INFO, "WMM Parameter IE: version=%d, "
+           "QoSInfo Parameter Set Count=%d, Reserved=%#x\n",
+           pWmmIe->VendHdr.Version, pWmmIe->QoSInfo.ParaSetCount,
+           pWmmIe->Reserved);
+
+    for (numAc = 0; numAc < NELEMENTS(acOrder); numAc++) {
+        cwmax = (1 << pWmmIe->AcParams[numAc].Ecw.EcwMax) - 1;
+        cwmin = (1 << pWmmIe->AcParams[numAc].Ecw.EcwMin) - 1;
+        avg_back_off = (cwmin >> 1) + pWmmIe->AcParams[numAc].AciAifsn.Aifsn;
+        Adapter->wmm.queuePriority[numAc] = acOrder[numAc];
+        tmp[numAc] = avg_back_off;
+
+        PRINTM(INFO, "WMM: CWmax=%d CWmin=%d Avg Back-off=%d\n",
+               cwmax, cwmin, avg_back_off);
+        PRINTM_AC(acOrder[numAc], &pWmmIe->AcParams[numAc]);
+    }
+
+    HEXDUMP("WMM: avg_back_off", (u8 *) tmp, sizeof(tmp));
+    HEXDUMP("WMM: queuePriority", Adapter->wmm.queuePriority,
+            sizeof(Adapter->wmm.queuePriority));
+
+    /* bubble sort */
+    for (i = 0; i < numAc; i++) {
+        for (j = 1; j < numAc - i; j++) {
+            if (tmp[j - 1] > tmp[j]) {
+                SWAP_U16(tmp[j - 1], tmp[j]);
+                SWAP_U8(Adapter->wmm.queuePriority[j - 1],
+                        Adapter->wmm.queuePriority[j]);
+            } else if (tmp[j - 1] == tmp[j]) {
+                if (Adapter->wmm.queuePriority[j - 1]
+                    < Adapter->wmm.queuePriority[j]) {
+                    SWAP_U8(Adapter->wmm.queuePriority[j - 1],
+                            Adapter->wmm.queuePriority[j]);
+                }
+            }
+        }
+    }
+
+    HEXDUMP("WMM: avg_back_off, sort", (u8 *) tmp, sizeof(tmp));
+    HEXDUMP("WMM: queuePriority, sort", Adapter->wmm.queuePriority,
+            sizeof(Adapter->wmm.queuePriority));
+}
+
+/** 
+ *  @brief pop up the highest skb from wmm queue
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *
+ *  @return         void
+ */
+static void
+wmm_pop_highest_prio_skb(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int i;
+    u8 ac;
+
+    ENTER();
+
+    for (i = 0; i < MAX_AC_QUEUES; i++) {
+        ac = Adapter->wmm.queuePriority[i];
+        if (!list_empty((struct list_head *) &Adapter->wmm.txSkbQ[ac])) {
+            PRINTM(DATA, "WMM: Highest prio pkt in AC Queue %d\n", i);
+            Adapter->CurrentTxSkb = Adapter->wmm.txSkbQ[ac].next;
+            Adapter->wmm.packetsOut[ac]++;
+            list_del((struct list_head *) Adapter->wmm.txSkbQ[ac].next);
+            break;
+        }
+    }
+
+    LEAVE();
+}
+
+/** 
+ *  @brief Evaluate whether or not an AC is to be downgraded
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *  @param evalAC   AC to evaluate for downgrading
+ *
+ *  @return WMM AC the evalAC traffic is to be sent on.  
+ */
+static wlan_wmm_ac_e
+wmm_eval_downgrade_ac(wlan_private * priv, wlan_wmm_ac_e evalAC)
+{
+    wlan_wmm_ac_e downAC;
+    wlan_wmm_ac_e retAC;
+    WmmAcStatus_t *pACStatus;
+
+    pACStatus = &priv->adapter->wmm.acStatus[evalAC];
+
+    if (pACStatus->Disabled == FALSE) {
+        /* Okay to use this AC, its enabled */
+        return evalAC;
+    }
+
+    /* Setup a default return value of the lowest priority */
+    retAC = WMM_AC_BK;
+
+    /*
+     *  Find the highest AC that is enabled and does not require admission
+     *    control.  The spec disallows downgarding to an AC which is enabled
+     *    due to a completed admission control.  Unadmitted traffic is not 
+     *    to be sent on an AC with admitted traffic.
+     */
+    for (downAC = WMM_AC_BK; downAC < evalAC; downAC++) {
+        pACStatus = &priv->adapter->wmm.acStatus[downAC];
+
+        if ((pACStatus->Disabled == FALSE)
+            && (pACStatus->FlowRequired == FALSE)) {
+            /* AC is enabled and does not require admission control */
+            retAC = downAC;
+        }
+    }
+
+    return retAC;
+}
+
+/** 
+ *  @brief Downgrade WMM priority queue
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *
+ *  @return         void
+ */
+static void
+wmm_setup_ac_downgrade(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    wlan_wmm_ac_e acVal;
+
+    PRINTM(INFO, "WMM: AC Priorities: BK(0), BE(1), VI(2), VO(3)\n");
+
+    if (Adapter->wmm.enabled == FALSE) {
+        /* WMM is not enabled, default priorities */
+        for (acVal = WMM_AC_BK; acVal <= WMM_AC_VO; acVal++) {
+            for (acVal = WMM_AC_BK; acVal <= WMM_AC_VO; acVal++) {
+                Adapter->wmm.acDowngradedVals[acVal] = acVal;
+            }
+        }
+    } else {
+        for (acVal = WMM_AC_BK; acVal <= WMM_AC_VO; acVal++) {
+            Adapter->wmm.acDowngradedVals[acVal]
+                = wmm_eval_downgrade_ac(priv, acVal);
+            PRINTM(INFO, "WMM: AC PRIO %d maps to %d\n",
+                   acVal, Adapter->wmm.acDowngradedVals[acVal]);
+        }
+    }
+}
+
+/** 
+ *  @brief Convert the IP TOS field to an WMM AC Queue assignment
+ *
+ *  @param tos  IP TOS field
+ *
+ *  @return     WMM AC Queue mapping of the IP TOS field
+ */
+wlan_wmm_ac_e
+wmm_convert_tos_to_ac(int tos)
+{
+    u8 tosIdx;
+
+    /* Map of TOS UP values to WMM AC */
+    const wlan_wmm_ac_e tos_to_ac[] = { WMM_AC_BE,
+        WMM_AC_BK,
+        WMM_AC_BK,
+        WMM_AC_BE,
+        WMM_AC_VI,
+        WMM_AC_VI,
+        WMM_AC_VO,
+        WMM_AC_VO
+    };
+
+    tosIdx = tos >> IPTOS_OFFSET;
+
+    if (tosIdx >= NELEMENTS(tos_to_ac)) {
+        return WMM_AC_BE;
+    }
+
+    return tos_to_ac[tosIdx];
+}
+
+/** 
+ *  @brief  Evaluate a given AC and downgrade it to a lower AC if the
+ *          WMM Parameter IE received from the AP indicates that the AP
+ *          is disabled (due to call admission control (ACM bit)
+ *
+ *  @param priv   Pointer to the wlan_private driver data struct
+ *  @param acVal  AC to evaulate for downgrading
+ *
+ *  @return       Same AC as input if downgrading not required or
+ *                the AC the traffic for the given AC should be downgraded to 
+ */
+wlan_wmm_ac_e
+wmm_downgrade_ac(wlan_private * priv, wlan_wmm_ac_e acVal)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    return (Adapter->wmm.acDowngradedVals[acVal]);
+}
+
+/** 
+ *  @brief  Map the IP TOS field to a user priority value
+ *
+ *  @param tos  IP TOS field
+ *
+ *  @return     User priority tos input parameter maps to
+ */
+static u8
+wmm_tos_to_priority(u8 tos)
+{
+    u8 tosIdx;
+    const u8 tos_to_priority[] = {
+        /* Priority   DSCP_P2   DSCP_P1  DSCP_P0   WMM_AC   */
+        0x00,                   /*    0         0        0       AC_BE   */
+        0x01,                   /*    0         0        1       AC_BK   */
+        0x02,                   /*    0         1        0       AC_BK   */
+        0x03,                   /*    0         1        1       AC_BE   */
+        0x04,                   /*    1         0        0       AC_VI   */
+        0x05,                   /*    1         0        1       AC_VI   */
+        0x06,                   /*    1         1        0       AC_VO   */
+        0x07                    /*    1         1        1       AC_VO   */
+    };
+
+    tosIdx = tos >> IPTOS_OFFSET;
+
+    if (tosIdx >= NELEMENTS(tos_to_priority)) {
+        return WMM_AC_BE;
+    }
+
+    return tos_to_priority[tosIdx];
+}
+
+/**
+ *  @brief  Process a transfer of a data packet to the firmware from the 
+ *          driver queue in order to manipulate flow control in the driver.
+ *
+ *  @param priv  Pointer to the wlan_private driver data struct
+ *
+ *  @return      void
+ */
+void
+wmm_process_fw_iface_tx_xfer_start(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    if (--Adapter->wmm.packetsQueued < WMM_QUEUED_PACKET_LOWER_LIMIT) {
+        PRINTM(DATA, "WMM: FW OS+: %d\n", Adapter->wmm.packetsQueued);
+        os_start_queue(priv);
+    }
+}
+
+/**
+ *  @brief  Process the completion of a data packet transfer to the firmware 
+ *          from the driver queue in order to manipulate flow control in the
+ *          driver.
+ *
+ *  @param priv  Pointer to the wlan_private driver data struct
+ *
+ *  @return      void
+ *
+ */
+void
+wmm_process_fw_iface_tx_xfer_end(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    if (Adapter->wmm.packetsQueued) {
+        PRINTM(DATA, "WMM: FW OS-: %d\n", Adapter->wmm.packetsQueued);
+        os_stop_queue(priv);
+    }
+}
+
+/**
+ *  @brief  Process a transfer of a data packet from the OS to the driver
+ *          queue in order to manipulate flow control in the driver.
+ *
+ *  @param priv  Pointer to the wlan_private driver data struct
+ *
+ *  @return      void
+ */
+void
+wmm_process_app_iface_tx(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    Adapter->wmm.packetsQueued++;
+
+    if ((!priv->wlan_dev.dnld_sent && (Adapter->PSState != PS_STATE_SLEEP))
+        || (Adapter->wmm.packetsQueued >= WMM_QUEUED_PACKET_UPPER_LIMIT)) {
+        PRINTM(DATA, "WMM: APP OS-: %d\n", Adapter->wmm.packetsQueued);
+        os_stop_queue(priv);
+    }
+}
+
+/**
+ *  @brief  Stop the WMM data queues.  Traffic is still accepted from the
+ *          OS until the buffer limits are reached.
+ *
+ *  @param priv  Pointer to the wlan_private driver data struct
+ *
+ *  @return      void
+ */
+void
+wmm_stop_queue(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    PRINTM(DATA, "WMM: Q-: %d\n", Adapter->wmm.packetsQueued);
+    Adapter->wmm.queueStopped = TRUE;
+}
+
+/**
+ *  @brief  Start/re-start the WMM data queues and indicate to the OS layer 
+ *          that data is being accepted again.
+ *
+ *  @param priv  Pointer to the wlan_private driver data struct
+ *
+ *  @return      void
+ */
+void
+wmm_start_queue(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    PRINTM(DATA, "WMM: Q+: %d\n", Adapter->wmm.packetsQueued);
+    Adapter->wmm.queueStopped = FALSE;
+    if (Adapter->wmm.packetsQueued) {
+        wake_up_interruptible(&priv->MainThread.waitQ);
+    }
+    os_carrier_on(priv);
+    os_start_queue(priv);
+}
+
+/** 
+ *  @brief  Query the status of the WMM queues.  Determine if the driver data
+ *          path is active or not.
+ *
+ *  @param priv  Pointer to the wlan_private driver data struct
+ *
+ *  @return      TRUE if WMM queues have been stopped, FALSE if still active
+ */
+int
+wmm_is_queue_stopped(wlan_private * priv)
+{
+    return (priv->adapter->wmm.queueStopped == TRUE);
+}
+
+/** 
+ *  @brief Initialize the WMM state information and the WMM data path queues.
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *
+ *  @return         void
+ */
+void
+wmm_init(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int i;
+    memset(&Adapter->wmm, 0x00, sizeof(Adapter->wmm));
+
+    for (i = 0; i < MAX_AC_QUEUES; i++) {
+        INIT_LIST_HEAD((struct list_head *) &Adapter->wmm.txSkbQ[i]);
+    }
+
+    Adapter->wmm.required = FALSE;
+
+    Adapter->gen_null_pkg = TRUE;       /*Enable NULL Pkg generation */
+}
+
+/** 
+ *  @brief Setup the queue priorities and downgrade any queues as required
+ *         by the WMM info.  Setups default values if WMM is not active
+ *         for this association.
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *
+ *  @return         void
+ */
+void
+wmm_setup_queues(wlan_private * priv)
+{
+    wmm_setup_queue_priorities(priv);
+    wmm_setup_ac_downgrade(priv);
+}
+
+/** 
+ *  @brief implement WMM enable command
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *  @param wrq      Pointer to user data
+ *
+ *  @return         WLAN_STATUS_SUCCESS if success; otherwise <0
+ */
+int
+wlan_wmm_enable_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    ulong flags;
+    int data, data1;
+    int *val;
+
+    ENTER();
+
+    data = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+    switch (data) {
+    case CMD_DISABLED:         /* disable */
+        if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+            return -EPERM;
+        }
+
+        spin_lock_irqsave(&Adapter->CurrentTxLock, flags);
+        Adapter->wmm.required = FALSE;
+        if (!Adapter->wmm.enabled) {
+            spin_unlock_irqrestore(&Adapter->CurrentTxLock, flags);
+            data1 = Adapter->wmm.required;
+            val = (int *) wrq->u.name;
+            *val = data;
+            return WLAN_STATUS_SUCCESS;
+        } else {
+            Adapter->wmm.enabled = 0;
+        }
+
+        if (Adapter->CurrentTxSkb) {
+            kfree_skb(Adapter->CurrentTxSkb);
+            OS_INT_DISABLE;
+            Adapter->CurrentTxSkb = NULL;
+            OS_INT_RESTORE;
+            priv->stats.tx_dropped++;
+        }
+
+        spin_unlock_irqrestore(&Adapter->CurrentTxLock, flags);
+        break;
+
+    case CMD_ENABLED:          /* enable */
+        if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+            return -EPERM;
+        }
+        spin_lock_irqsave(&Adapter->CurrentTxLock, flags);
+        Adapter->wmm.required = TRUE;
+        spin_unlock_irqrestore(&Adapter->CurrentTxLock, flags);
+        break;
+
+    case CMD_GET:
+        break;
+    default:
+        PRINTM(INFO, "Invalid option\n");
+        return -EINVAL;
+    }
+
+    data = Adapter->wmm.required;
+    val = (int *) wrq->u.name;
+    *val = data;
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Implement cmd HostCmd_CMD_WMM_GET_STATUS
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *  @param cmd      Pointer to CMD buffer 
+ *  @param InfoBuf  Pointer to cmd data
+ *
+ *  @return         WLAN_STATUS_SUCCESS
+ */
+int
+wlan_cmd_wmm_get_status(wlan_private * priv,
+                        HostCmd_DS_COMMAND * cmd, void *InfoBuf)
+{
+    PRINTM(INFO, "WMM: WMM_GET_STATUS cmd sent\n");
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_WMM_GET_STATUS);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_WMM_GET_STATUS) + S_DS_GEN);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief  Send a command to firmware to retrieve the current WMM status
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *
+ *  @return         WLAN_STATUS_SUCCESS; WLAN_STATUS_FAILURE
+ */
+int
+sendWMMStatusChangeCmd(wlan_private * priv)
+{
+    return PrepareAndSendCommand(priv, HostCmd_CMD_WMM_GET_STATUS,
+                                 0, 0, 0, NULL);
+}
+
+/** 
+ *  @brief Check if wmm TX queue is empty
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *
+ *  @return         FALSE if not empty; TRUE if empty
+ */
+int
+wmm_lists_empty(wlan_private * priv)
+{
+    int i;
+
+    for (i = 0; i < MAX_AC_QUEUES; i++) {
+        if (!list_empty((struct list_head *) &priv->adapter->wmm.txSkbQ[i])) {
+            return FALSE;
+        }
+    }
+    return TRUE;
+}
+
+/** 
+ *  @brief Cleanup wmm TX queue
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *
+ *  @return         void
+ */
+void
+wmm_cleanup_queues(wlan_private * priv)
+{
+    int i;
+    struct sk_buff *delNode, *Q;
+
+    ENTER();
+
+    for (i = 0; i < MAX_AC_QUEUES; i++) {
+        Q = &priv->adapter->wmm.txSkbQ[i];
+
+        while (!list_empty((struct list_head *) Q)) {
+            delNode = Q->next;
+            list_del((struct list_head *) delNode);
+            kfree_skb(delNode);
+        }
+    }
+
+    priv->adapter->wmm.packetsQueued = 0;
+
+    LEAVE();
+}
+
+/** 
+ *  @brief Add skb to WMM queue
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *  @param skb      Pointer to sk_buff
+ *
+ *  @return         void
+ */
+void
+wmm_map_and_add_skb(wlan_private * priv, struct sk_buff *skb)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    struct ethhdr *eth;
+    struct timeval tstamp;
+    u8 tos;
+    wlan_wmm_ac_e ac;
+    wlan_wmm_ac_e ac_down;
+
+    eth = (struct ethhdr *) skb->data;
+
+    switch (eth->h_proto) {
+    case __constant_htons(ETH_P_IP):
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+        PRINTM(INFO, "packet type ETH_P_IP: %04x, tos=%#x prio=%#x\n",
+               eth->h_proto, ip_hdr(skb)->tos, skb->priority);
+        tos = IPTOS_PREC(ip_hdr(skb)->tos) >> IPTOS_OFFSET;
+#else
+        PRINTM(DATA, "packet type ETH_P_IP: %04x, tos=%#x prio=%#x\n",
+               eth->h_proto, skb->nh.iph->tos, skb->priority);
+        tos = IPTOS_PREC(skb->nh.iph->tos);
+#endif
+        break;
+    case __constant_htons(ETH_P_ARP):
+        PRINTM(DATA, "ARP packet %04x\n", eth->h_proto);
+    default:
+        tos = 0;
+        break;
+    }
+
+    ac = wmm_convert_tos_to_ac(tos);
+    ac_down = wmm_downgrade_ac(priv, ac);
+
+    skb->priority = wmm_tos_to_priority(tos);
+    PRINTM(DATA, "wmm_map: tos=%#x, ac=%#x ac_down=%#x, priority=%#x\n",
+           tos, ac, ac_down, skb->priority);
+
+    list_add_tail((struct list_head *) skb,
+                  (struct list_head *) &Adapter->wmm.txSkbQ[ac_down]);
+
+    wmm_process_app_iface_tx(priv);
+
+    /* Record the current time the packet was queued; used to determine
+     *   the amount of time the packet was queued in the driver before it 
+     *   was sent to the firmware.  The delay is then sent along with the 
+     *   packet to the firmware for aggregate delay calculation for stats
+     *   and MSDU lifetime expiry.
+     */
+    do_gettimeofday(&tstamp);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+    skb->tstamp = timeval_to_ktime(tstamp);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,14)
+    skb_set_timestamp(skb, &tstamp);
+#else
+    memcpy(&skb->stamp, &tstamp, sizeof(skb->stamp));
+#endif
+}
+
+/**
+ *  @brief Process the GET_WMM_STATUS command response from firmware
+ *
+ *  The GET_WMM_STATUS command returns multiple TLVs for:
+ *      - Each AC Queue status
+ *      - Current WMM Parameter IE
+ *
+ *  This function parses the TLVs and then calls further functions
+ *   to process any changes in the queue prioritization or state.
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param resp    Pointer to the command response buffer including TLVs
+ *                 TLVs for each queue and the WMM Parameter IE.
+ * 
+ *  @return WLAN_STATUS_SUCCESS
+ */
+int
+wlan_cmdresp_wmm_get_status(wlan_private * priv,
+                            const HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    u8 *pCurrent = (u8 *) & resp->params.getWmmStatus;
+    u32 respLen = resp->Size;
+    int valid = TRUE;
+    int enableData = TRUE;
+
+    MrvlIEtypes_Data_t *pTlvHdr;
+    MrvlIEtypes_WmmQueueStatus_t *pTlvWmmQStatus;
+    IEEEtypes_WmmParameter_t *pWmmParamIe;
+    WmmAcStatus_t *pACStatus;
+
+    PRINTM(INFO, "WMM: WMM_GET_STATUS cmdresp received: %d\n", respLen);
+    HEXDUMP("CMD_RESP: WMM_GET_STATUS", pCurrent, respLen);
+
+    while ((respLen >= sizeof(pTlvHdr->Header)) && valid) {
+        pTlvHdr = (MrvlIEtypes_Data_t *) pCurrent;
+        pTlvHdr->Header.Len = wlan_le16_to_cpu(pTlvHdr->Header.Len);
+
+        switch (wlan_le16_to_cpu(pTlvHdr->Header.Type)) {
+        case TLV_TYPE_WMMQSTATUS:
+            pTlvWmmQStatus = (MrvlIEtypes_WmmQueueStatus_t *) pTlvHdr;
+            PRINTM(INFO,
+                   "CMD_RESP: WMM_GET_STATUS: QSTATUS TLV: %d, %d, %d\n",
+                   pTlvWmmQStatus->QueueIndex, pTlvWmmQStatus->FlowRequired,
+                   pTlvWmmQStatus->Disabled);
+
+            pACStatus = &Adapter->wmm.acStatus[pTlvWmmQStatus->QueueIndex];
+            pACStatus->Disabled = pTlvWmmQStatus->Disabled;
+            pACStatus->FlowRequired = pTlvWmmQStatus->FlowRequired;
+            pACStatus->FlowCreated = pTlvWmmQStatus->FlowCreated;
+            break;
+
+        case WMM_IE:
+            /*
+             * Point the regular IEEE IE 2 bytes into the Marvell IE
+             *   and setup the IEEE IE type and length byte fields
+             */
+
+            HEXDUMP("WMM: WMM TLV:", (u8 *) pTlvHdr, pTlvHdr->Header.Len + 4);
+
+            pWmmParamIe = (IEEEtypes_WmmParameter_t *) (pCurrent + 2);
+            pWmmParamIe->VendHdr.Len = pTlvHdr->Header.Len;
+            pWmmParamIe->VendHdr.ElementId = WMM_IE;
+
+            PRINTM(INFO, "CMD_RESP: WMM_GET_STATUS: WMM Parameter Set: %d\n",
+                   pWmmParamIe->QoSInfo.ParaSetCount);
+
+            memcpy((u8 *) & Adapter->CurBssParams.BSSDescriptor.wmmIE,
+                   pWmmParamIe, pWmmParamIe->VendHdr.Len + 2);
+
+            break;
+
+        default:
+            valid = FALSE;
+            break;
+        }
+
+        pCurrent += (pTlvHdr->Header.Len + sizeof(pTlvHdr->Header));
+        respLen -= (pTlvHdr->Header.Len + sizeof(pTlvHdr->Header));
+    }
+
+    wmm_setup_queue_priorities(priv);
+    wmm_setup_ac_downgrade(priv);
+
+    if (enableData) {
+        wmm_start_queue(priv);
+        os_carrier_on(priv);
+        os_start_queue(priv);
+    }
+
+    send_iwevcustom_event(priv, WMM_CONFIG_CHANGE_INDICATION);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Call back from the command module to allow insertion of a WMM TLV
+ *   
+ *  If the BSS we are associating to supports WMM, add the required WMM
+ *    Information IE to the association request command buffer in the form
+ *    of a Marvell extended IEEE IE.
+ *     
+ *  @param priv        Pointer to the wlan_private driver data struct
+ *  @param ppAssocBuf  Output parameter: Pointer to the TLV output buffer,
+ *                     modified on return to point after the appended WMM TLV
+ *  @param pWmmIE      Pointer to the WMM IE for the BSS we are joining
+ * 
+ *  @return Length of data appended to the association tlv buffer
+ */
+u32
+wlan_wmm_process_association_req(wlan_private * priv,
+                                 u8 ** ppAssocBuf,
+                                 IEEEtypes_WmmParameter_t * pWmmIE)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    MrvlIEtypes_WmmParamSet_t *pWmmTlv;
+    u32 retLen = 0;
+
+    /* Null checks */
+    if (ppAssocBuf == 0)
+        return 0;
+    if (*ppAssocBuf == 0)
+        return 0;
+    if (pWmmIE == 0)
+        return 0;
+
+    PRINTM(INFO, "WMM: process assoc req: bss->wmmIe=%x\n",
+           pWmmIE->VendHdr.ElementId);
+
+    if (Adapter->wmm.required && pWmmIE->VendHdr.ElementId == WMM_IE) {
+        pWmmTlv = (MrvlIEtypes_WmmParamSet_t *) * ppAssocBuf;
+        pWmmTlv->Header.Type = (u16) wmm_info_ie[0];
+        pWmmTlv->Header.Type = wlan_cpu_to_le16(pWmmTlv->Header.Type);
+        pWmmTlv->Header.Len = (u16) wmm_info_ie[1];
+        pWmmTlv->Header.Len = wlan_cpu_to_le16(pWmmTlv->Header.Len);
+
+        memcpy(pWmmTlv->WmmIE, &wmm_info_ie[2], pWmmTlv->Header.Len);
+#define QOS_INFO_PARA_MASK 0x0f
+        if (pWmmIE->QoSInfo.QosUAPSD
+            && ((Adapter->wmm.qosinfo & QOS_INFO_PARA_MASK) != 0)) {
+            memcpy((u8 *) (pWmmTlv->WmmIE + pWmmTlv->Header.Len
+                           - sizeof(Adapter->wmm.qosinfo)),
+                   &Adapter->wmm.qosinfo, sizeof(Adapter->wmm.qosinfo));
+        }
+        retLen = sizeof(pWmmTlv->Header) + pWmmTlv->Header.Len;
+
+        HEXDUMP("ASSOC_CMD: WMM IE", (u8 *) pWmmTlv, retLen);
+        *ppAssocBuf += retLen;
+    }
+
+    return retLen;
+}
+
+/**
+ *   @brief Compute the time delay in the driver queues for a given skb.
+ *
+ *   When the skb is received at the OS/Driver interface, the current 
+ *     time is set in the skb structure.  The difference between the present
+ *     time and that received time is computed in this function and limited
+ *     based on pre-compiled limits in the driver.
+ *
+ *   @param skb  Pointer to a sk_buff which has been previously timestamped
+ *
+ *   @return Time delay of the packet in 2ms units after having limit applied
+ */
+u8
+wmm_compute_driver_packet_delay(const struct sk_buff * skb)
+{
+    u8 retVal;
+    struct timeval in_tv;
+    struct timeval out_tv;
+    int queue_delay;
+
+    retVal = 0;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,14)
+    skb_get_timestamp(skb, &in_tv);
+#else
+    memcpy(&in_tv, &skb->stamp, sizeof(in_tv));
+#endif
+    do_gettimeofday(&out_tv);
+
+    queue_delay = timeval_diff_in_ms(&out_tv, &in_tv);
+
+    /* Queue delay is passed as a uint8 in units of 2ms (ms shifted
+     *  by 1). Min value (other than 0) is therefore 2ms, max is 510ms.
+     *
+     * Pass max value if queue_delay is beyond the uint8 range 
+     */
+    retVal = MIN(queue_delay, DRV_PKT_DELAY_TO_FW_LIMIT) >> 1;
+
+    PRINTM(DATA, "WMM: Pkt Delay: %d ms, %d ms sent to FW\n",
+           queue_delay, retVal);
+
+    return retVal;
+}
+
+/** 
+ *  @brief Transmit the highest priority packet awaiting in the WMM Queues
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *
+ *  @return        void
+ */
+void
+wmm_process_tx(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    ulong flags;
+
+    OS_INTERRUPT_SAVE_AREA;
+
+    ENTER();
+
+    if ((Adapter->PSState == PS_STATE_SLEEP)
+        || (Adapter->PSState == PS_STATE_PRE_SLEEP)) {
+        PRINTM(INFO, "In PS State %d"
+               " - Not sending the packet\n", Adapter->PSState);
+        LEAVE();
+
+        return;
+    }
+
+    spin_lock_irqsave(&Adapter->CurrentTxLock, flags);
+
+    if (priv->wlan_dev.dnld_sent) {
+        spin_unlock_irqrestore(&Adapter->CurrentTxLock, flags);
+
+        LEAVE();
+
+        return;
+    }
+
+    UpdateTransStart(priv->wlan_dev.netdev);
+    wmm_pop_highest_prio_skb(priv);
+
+    spin_unlock_irqrestore(&Adapter->CurrentTxLock, flags);
+
+    if (Adapter->CurrentTxSkb) {
+        wlan_process_tx(priv);
+    }
+
+    LEAVE();
+}
+
+/**
+ *  @brief Private IOCTL entry to get the status of the WMM queues
+ *
+ *  Return the following information for each WMM AC:
+ *        - WMM IE Acm Required
+ *        - Firmware Flow Required 
+ *        - Firmware Flow Established
+ *        - Firmware Queue Enabled
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param wrq     A pointer to iwreq structure containing the
+ *                 wlan_ioctl_wmm_queue_status_t struct for request
+ *
+ *  @return        0 if successful; IOCTL error code otherwise
+ */
+int
+wlan_wmm_queue_status_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    wlan_ioctl_wmm_queue_status_t qstatus;
+    wlan_wmm_ac_e acVal;
+    WmmAcStatus_t *pACStatus;
+    IEEEtypes_WmmAcParameters_t *pWmmIeAC;
+
+    for (acVal = WMM_AC_BK; acVal <= WMM_AC_VO; acVal++) {
+        pACStatus = &Adapter->wmm.acStatus[acVal];
+        pWmmIeAC = &Adapter->CurBssParams.BSSDescriptor.wmmIE.AcParams[acVal];
+
+        /* Acm bit */
+        qstatus.acStatus[acVal].wmmAcm = pWmmIeAC->AciAifsn.Acm;
+
+        /* Firmware status */
+        qstatus.acStatus[acVal].flowRequired = pACStatus->FlowRequired;
+        qstatus.acStatus[acVal].flowCreated = pACStatus->FlowCreated;
+        qstatus.acStatus[acVal].disabled = pACStatus->Disabled;
+    }
+
+    if (copy_to_user(wrq->u.data.pointer, &qstatus, sizeof(qstatus))) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return -EFAULT;
+    }
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Private IOCTL entry to send an ADDTS TSPEC
+ *
+ *  Receive a ADDTS command from the application.  The command structure
+ *    contains a TSPEC and timeout in milliseconds.  The timeout is performed
+ *    in the firmware after the ADDTS command frame is sent.  
+ *
+ *  The TSPEC is received in the API as an opaque block whose length is 
+ *    calculated from the IOCTL data length.  The firmware will send the 
+ *    entire data block, including the bytes after the TSPEC.  This is done
+ *    to allow extra IEs to be packaged with the TSPEC in the ADDTS action
+ *    frame.
+ *
+ *  The IOCTL structure contains two return fields: 
+ *    - The firmware command result which indicates failure and timeouts
+ *    - The IEEE Status code which contains the corresponding value from
+ *      any ADDTS response frame received.
+ *
+ *  In addition, the opaque TSPEC data block passed in is replaced with the 
+ *    TSPEC recieved in the ADDTS response frame.  In case of failure, the
+ *    AP may modify the TSPEC on return and in the case of success, the 
+ *    medium time is returned as calculated by the AP.  Along with the TSPEC,
+ *    any IEs that are sent in the ADDTS response are also returned and can be
+ *    parsed using the IOCTL length as an indicator of extra elements.
+ *
+ *  The return value to the application layer indicates a driver execution
+ *    success or failure.  A successful return could still indicate a firmware
+ *    failure or AP negotiation failure via the commandResult field copied
+ *    back to the application.
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param wrq     A pointer to iwreq structure containing the
+ *                 wlan_ioctl_wmm_addts_req_t struct for this ADDTS request
+ *
+ *  @return        0 if successful; IOCTL error code otherwise
+ */
+int
+wlan_wmm_addts_req_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    static u8 dialogTok = 0;
+    wlan_ioctl_wmm_addts_req_t addtsIoctl;
+    wlan_cmd_wmm_addts_req_t addtsCmd;
+    int retcode;
+
+    if (copy_from_user(&addtsIoctl,
+                       wrq->u.data.pointer,
+                       MIN(wrq->u.data.length, sizeof(addtsIoctl))) != 0) {
+        /* copy_from_user failed  */
+        PRINTM(INFO, "TSPEC: ADDTS copy from user failed\n");
+        retcode = -EFAULT;
+
+    } else {
+        memset(&addtsCmd, 0x00, sizeof(addtsCmd));
+        if ((++dialogTok) == 0)
+            dialogTok = 1;
+
+        addtsCmd.dialogToken = dialogTok;
+        addtsCmd.timeout_ms = addtsIoctl.timeout_ms;
+        addtsCmd.tspecDataLen = (wrq->u.data.length
+                                 - sizeof(addtsCmd.timeout_ms)
+                                 - sizeof(addtsCmd.commandResult)
+                                 - sizeof(addtsCmd.ieeeStatusCode));
+        memcpy(addtsCmd.tspecData,
+               addtsIoctl.tspecData, addtsCmd.tspecDataLen);
+
+        retcode = PrepareAndSendCommand(priv,
+                                        HostCmd_CMD_WMM_ADDTS_REQ, 0,
+                                        HostCmd_OPTION_WAITFORRSP, 0,
+                                        &addtsCmd);
+
+        wrq->u.data.length = (sizeof(addtsIoctl.timeout_ms)
+                              + sizeof(addtsIoctl.commandResult)
+                              + sizeof(addtsIoctl.ieeeStatusCode)
+                              + addtsCmd.tspecDataLen);
+
+        addtsIoctl.commandResult = addtsCmd.commandResult;
+        addtsIoctl.ieeeStatusCode = addtsCmd.ieeeStatusCode;
+        memcpy(addtsIoctl.tspecData,
+               addtsCmd.tspecData, addtsCmd.tspecDataLen);
+
+        if (copy_to_user(wrq->u.data.pointer,
+                         &addtsIoctl, sizeof(addtsIoctl))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return -EFAULT;
+        }
+
+        if (retcode) {
+            return -EFAULT;
+        }
+    }
+
+    return retcode;
+}
+
+/**
+ *  @brief Private IOCTL entry to send a DELTS TSPEC
+ *
+ *  Receive a DELTS command from the application.  The command structure
+ *    contains a TSPEC and reason code along with space for a command result
+ *    to be returned.  The information is packaged is sent to the wlan_cmd.c
+ *    firmware command prep and send routines for execution in the firmware.
+ *
+ *  The reason code is not used for WMM implementations but is indicated in
+ *    the 802.11e specification.
+ *
+ *  The return value to the application layer indicates a driver execution
+ *    success or failure.  A successful return could still indicate a firmware
+ *    failure via the commandResult field copied back to the application.
+ *  
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param wrq     A pointer to iwreq structure containing the
+ *                 wlan_ioctl_wmm_delts_req_t struct for this DELTS request
+ *
+ *  @return        0 if successful; IOCTL error code otherwise
+ */
+int
+wlan_wmm_delts_req_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_ioctl_wmm_delts_req_t deltsIoctl;
+    wlan_cmd_wmm_delts_req_t deltsCmd;
+    int retcode;
+
+    if (copy_from_user(&deltsIoctl,
+                       wrq->u.data.pointer,
+                       MIN(wrq->u.data.length, sizeof(deltsIoctl))) != 0) {
+        /* copy_from_user failed  */
+        PRINTM(INFO, "TSPEC: DELTS copy from user failed\n");
+        retcode = -EFAULT;
+
+    } else {
+        memset(&deltsCmd, 0x00, sizeof(deltsCmd));
+
+        /* Dialog token unused for WMM implementations */
+        deltsCmd.dialogToken = 0;
+
+        deltsCmd.ieeeReasonCode = deltsIoctl.ieeeReasonCode;
+
+        /* Calculate the length of the TSPEC and any other IEs */
+        deltsCmd.tspecDataLen = (wrq->u.data.length
+                                 - sizeof(deltsCmd.commandResult)
+                                 - sizeof(deltsCmd.ieeeReasonCode));
+        memcpy(deltsCmd.tspecData,
+               deltsIoctl.tspecData, deltsCmd.tspecDataLen);
+
+        /* Send the DELTS request to firmware, wait for a response */
+        retcode = PrepareAndSendCommand(priv,
+                                        HostCmd_CMD_WMM_DELTS_REQ, 0,
+                                        HostCmd_OPTION_WAITFORRSP, 0,
+                                        &deltsCmd);
+
+        /* Return the firmware command result back to the application layer */
+        deltsIoctl.commandResult = deltsCmd.commandResult;
+
+        if (copy_to_user(wrq->u.data.pointer,
+                         &deltsCmd,
+                         MIN(wrq->u.data.length, sizeof(deltsIoctl)))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return -EFAULT;
+        }
+
+        if (retcode) {
+            retcode = -EFAULT;
+        }
+    }
+
+    return retcode;
+}
+
+/**
+ *  @brief Process the ADDTS_REQ command response from firmware
+ *
+ *  Return the ADDTS firmware response to the calling thread that sent 
+ *    the command.  The result is then relayed back the app layer.
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param resp    Pointer to the command response buffer including the 
+ *                 command result and any returned ADDTS response TSPEC
+ *                 elements 
+ * 
+ *  @return WLAN_STATUS_SUCCESS
+ *
+ *  @sa wlan_wmm_addts_req_ioctl
+ */
+int
+wlan_cmdresp_wmm_addts_req(wlan_private * priv,
+                           const HostCmd_DS_COMMAND * resp)
+{
+    wlan_cmd_wmm_addts_req_t *pAddTsCmd;
+    const HostCmd_DS_WMM_ADDTS_REQ *pCmdResp;
+
+    /* Cast the NULL pointer of the buffer the IOCTL sent in the command req */
+    pAddTsCmd = (wlan_cmd_wmm_addts_req_t *) priv->adapter->CurCmd->pdata_buf;
+
+    /* Convenience variable for the ADDTS response from the firmware */
+    pCmdResp = &resp->params.addTsReq;
+
+    /* Assign return data */
+    pAddTsCmd->commandResult = pCmdResp->commandResult;
+
+    if (pCmdResp->commandResult == TSPEC_RESULT_SUCCESS) {
+        pAddTsCmd->dialogToken = pCmdResp->dialogToken;
+        pAddTsCmd->ieeeStatusCode = pCmdResp->ieeeStatusCode;
+
+        /* The tspecData field is potentially variable in size due to extra IEs
+         *   that may have been in the ADDTS response action frame.  Calculate
+         *   the data length from the firmware command response.
+         */
+        pAddTsCmd->tspecDataLen = (resp->Size
+                                   - sizeof(pCmdResp->commandResult)
+                                   - sizeof(pCmdResp->timeout_ms)
+                                   - sizeof(pCmdResp->dialogToken)
+                                   - sizeof(pCmdResp->ieeeStatusCode)
+                                   - S_DS_GEN);
+
+        /* Copy the TSPEC data include any extra IEs after the TSPEC */
+        memcpy(pAddTsCmd->tspecData,
+               pCmdResp->tspecData,
+               MIN(pAddTsCmd->tspecDataLen, sizeof(pAddTsCmd->tspecData)
+                   + sizeof(pAddTsCmd->addtsExtraIEBuf)));
+    } else {
+        pAddTsCmd->dialogToken = 0;
+        pAddTsCmd->ieeeStatusCode = 0;
+        pAddTsCmd->tspecDataLen = 0;
+    }
+
+    PRINTM(INFO, "TSPEC: ADDTS ret = %d,%d sz=%d\n",
+           pAddTsCmd->commandResult, pAddTsCmd->ieeeStatusCode,
+           pAddTsCmd->tspecDataLen);
+
+    HEXDUMP("TSPEC: ADDTS data",
+            pAddTsCmd->tspecData, pAddTsCmd->tspecDataLen);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Process the DELTS_REQ command response from firmware
+ *
+ *  Return the DELTS firmware response to the calling thread that sent 
+ *    the command.  The result is then relayed back the app layer.
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param resp    Pointer to the command response buffer with the command
+ *                 result.  No other response information is passed back 
+ *                 to the driver.
+ * 
+ *  @return WLAN_STATUS_SUCCESS
+ *
+ *  @sa wlan_wmm_delts_req_ioctl
+ */
+int
+wlan_cmdresp_wmm_delts_req(wlan_private * priv,
+                           const HostCmd_DS_COMMAND * resp)
+{
+    wlan_cmd_wmm_delts_req_t *pDelTsCmd;
+
+    /* Cast the NULL pointer of the buffer the IOCTL sent in the command req */
+    pDelTsCmd = (wlan_cmd_wmm_delts_req_t *) priv->adapter->CurCmd->pdata_buf;
+
+    pDelTsCmd->commandResult =
+        wlan_le16_to_cpu(resp->params.delTsReq.commandResult);
+
+    PRINTM(INFO, "TSPEC: DELTS result = %d\n", pDelTsCmd->commandResult);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Implement cmd HostCmd_DS_WMM_ADDTS_REQ
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param cmd     Pointer to CMD buffer 
+ *  @param InfoBuf Pointer to cmd data
+ *
+ *  @return        WLAN_STATUS_SUCCESS
+ *
+ *  @sa wlan_wmm_addts_req_ioctl
+ */
+int
+wlan_cmd_wmm_addts_req(wlan_private * priv,
+                       HostCmd_DS_COMMAND * cmd, void *InfoBuf)
+{
+    wlan_cmd_wmm_addts_req_t *pAddTsCmd;
+    int tspecCopySize;
+
+    pAddTsCmd = (wlan_cmd_wmm_addts_req_t *) InfoBuf;
+
+    cmd->params.addTsReq.timeout_ms = pAddTsCmd->timeout_ms;
+    cmd->params.addTsReq.dialogToken = pAddTsCmd->dialogToken;
+
+    tspecCopySize = MIN(pAddTsCmd->tspecDataLen,
+                        sizeof(cmd->params.addTsReq.tspecData));
+    memcpy(&cmd->params.addTsReq.tspecData,
+           pAddTsCmd->tspecData, tspecCopySize);
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_WMM_ADDTS_REQ);
+    cmd->Size = wlan_cpu_to_le16(sizeof(cmd->params.addTsReq.dialogToken)
+                                 + sizeof(cmd->params.addTsReq.timeout_ms)
+                                 + sizeof(cmd->params.addTsReq.commandResult)
+                                 + sizeof(cmd->params.addTsReq.ieeeStatusCode)
+                                 + tspecCopySize + S_DS_GEN);
+
+    cmd->params.addTsReq.timeout_ms
+        = wlan_cpu_to_le32(cmd->params.addTsReq.timeout_ms);
+
+    PRINTM(INFO, "WMM: ADDTS Cmd: Data Len = %d\n", pAddTsCmd->tspecDataLen);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Implement cmd HostCmd_DS_WMM_DELTS_REQ
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *  @param cmd      Pointer to CMD buffer 
+ *  @param InfoBuf  Void pointer cast of a wlan_cmd_wmm_delts_req_t struct
+ *
+ *  @return         WLAN_STATUS_SUCCESS
+ *
+ *  @sa wlan_wmm_delts_req_ioctl
+ */
+int
+wlan_cmd_wmm_delts_req(wlan_private * priv,
+                       HostCmd_DS_COMMAND * cmd, void *InfoBuf)
+{
+    wlan_cmd_wmm_delts_req_t *pDelTsCmd;
+    int tspecCopySize;
+
+    pDelTsCmd = (wlan_cmd_wmm_delts_req_t *) InfoBuf;
+
+    cmd->params.delTsReq.dialogToken = pDelTsCmd->dialogToken;
+    cmd->params.delTsReq.ieeeReasonCode = pDelTsCmd->ieeeReasonCode;
+
+    tspecCopySize = MIN(pDelTsCmd->tspecDataLen,
+                        sizeof(cmd->params.delTsReq.tspecData));
+    memcpy(&cmd->params.delTsReq.tspecData,
+           pDelTsCmd->tspecData, tspecCopySize);
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_WMM_DELTS_REQ);
+    cmd->Size = wlan_cpu_to_le16(sizeof(cmd->params.delTsReq.dialogToken)
+                                 + sizeof(cmd->params.delTsReq.commandResult)
+                                 + sizeof(cmd->params.delTsReq.ieeeReasonCode)
+                                 + tspecCopySize + S_DS_GEN);
+
+    PRINTM(INFO, "WMM: DELTS Cmd prepared\n");
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Prepare the firmware command buffer for the WMM_QUEUE_CONFIG command
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *  @param cmd      Pointer to CMD buffer 
+ *  @param InfoBuf  Void pointer cast of a wlan_cmd_wmm_queue_config_t struct
+ *
+ *  @return         WLAN_STATUS_SUCCESS
+ */
+int
+wlan_cmd_wmm_queue_config(wlan_private * priv,
+                          HostCmd_DS_COMMAND * cmd, void *InfoBuf)
+{
+    wlan_cmd_wmm_queue_config_t *pQConfigCmd;
+    int tlvCopySize;
+
+    pQConfigCmd = (wlan_cmd_wmm_queue_config_t *) InfoBuf;
+
+    cmd->params.queueConfig.action = pQConfigCmd->action;
+    cmd->params.queueConfig.accessCategory = pQConfigCmd->accessCategory;
+    cmd->params.queueConfig.msduLifetimeExpiry
+        = wlan_cpu_to_le16(pQConfigCmd->msduLifetimeExpiry);
+
+    tlvCopySize = MIN(pQConfigCmd->tlvBufLen,
+                      sizeof(cmd->params.queueConfig.tlvBuffer));
+    memcpy(&cmd->params.queueConfig.tlvBuffer,
+           pQConfigCmd->tlvBuffer, tlvCopySize);
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_WMM_QUEUE_CONFIG);
+    cmd->Size = wlan_cpu_to_le16(sizeof(cmd->params.queueConfig.action)
+                                 +
+                                 sizeof(cmd->params.queueConfig.
+                                        accessCategory)
+                                 +
+                                 sizeof(cmd->params.queueConfig.
+                                        msduLifetimeExpiry)
+                                 + tlvCopySize + S_DS_GEN);
+
+    PRINTM(INFO, "WMM: QUEUE CONFIG Cmd prepared\n");
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Process the WMM_QUEUE_CONFIG command response from firmware
+ *
+ *  Return the firmware command response to the blocked IOCTL caller function.
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param resp    Pointer to the command response buffer with:
+ *                      - action code
+ *                      - access category
+ *                      - collected statistics if requested 
+ *
+ *  @return WLAN_STATUS_SUCCESS
+ *
+ *  @sa wlan_wmm_queue_config_ioctl
+ */
+int
+wlan_cmdresp_wmm_queue_config(wlan_private * priv,
+                              const HostCmd_DS_COMMAND * resp)
+{
+    wlan_cmd_wmm_queue_config_t *pQConfigCmd;
+    const HostCmd_DS_WMM_QUEUE_CONFIG *pCmdResp;
+
+    pQConfigCmd =
+        (wlan_cmd_wmm_queue_config_t *) (priv->adapter->CurCmd->pdata_buf);
+    pCmdResp = &resp->params.queueConfig;
+
+    pQConfigCmd->action = pCmdResp->action;
+    pQConfigCmd->accessCategory = pCmdResp->accessCategory;
+    pQConfigCmd->msduLifetimeExpiry
+        = wlan_le16_to_cpu(pCmdResp->msduLifetimeExpiry);
+
+    pQConfigCmd->tlvBufLen = (resp->Size - sizeof(pCmdResp->action)
+                              - sizeof(pCmdResp->accessCategory)
+                              - sizeof(pCmdResp->msduLifetimeExpiry)
+                              - S_DS_GEN);
+
+    memcpy(pQConfigCmd->tlvBuffer,
+           pCmdResp->tlvBuffer, pQConfigCmd->tlvBufLen);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Private IOCTL entry to get/set a specified AC Queue's parameters
+ *
+ *  Receive a AC Queue configuration command which is used to get, set, or 
+ *    default the parameters associated with a specific WMM AC Queue.
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param wrq     A pointer to iwreq structure containing the
+ *                 wlan_ioctl_wmm_queue_config_t struct
+ *
+ *  @return        0 if successful; IOCTL error code otherwise
+ */
+int
+wlan_wmm_queue_config_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_ioctl_wmm_queue_config_t queueConfigIoctl;
+    wlan_cmd_wmm_queue_config_t queueConfigCmd;
+    int retcode;
+
+    PRINTM(INFO, "WMM: Queue Config IOCTL Enter\n");
+
+    if (copy_from_user(&queueConfigIoctl,
+                       wrq->u.data.pointer,
+                       MIN(wrq->u.data.length,
+                           sizeof(queueConfigIoctl))) != 0) {
+        /* copy_from_user failed  */
+        PRINTM(INFO, "WMM: Queue Config: copy from user failed\n");
+        retcode = -EFAULT;
+
+    } else {
+        memset(&queueConfigCmd, 0x00, sizeof(queueConfigCmd));
+
+        queueConfigCmd.action = queueConfigIoctl.action;
+        queueConfigCmd.accessCategory = queueConfigIoctl.accessCategory;
+        queueConfigCmd.msduLifetimeExpiry
+            = queueConfigIoctl.msduLifetimeExpiry;
+
+        /* Create a rates TLV from the supportedRates[] ioctl field */
+        queueConfigCmd.tlvBufLen = 0;
+
+        retcode = PrepareAndSendCommand(priv,
+                                        HostCmd_CMD_WMM_QUEUE_CONFIG, 0,
+                                        HostCmd_OPTION_WAITFORRSP, 0,
+                                        &queueConfigCmd);
+        if (retcode) {
+            retcode = -EFAULT;
+        } else {
+            memset(&queueConfigIoctl, 0x00, sizeof(queueConfigIoctl));
+
+            queueConfigIoctl.action = queueConfigCmd.action;
+            queueConfigIoctl.accessCategory = queueConfigCmd.accessCategory;
+            queueConfigIoctl.msduLifetimeExpiry
+                = queueConfigCmd.msduLifetimeExpiry;
+
+            wrq->u.data.length = sizeof(queueConfigIoctl);
+
+            if (copy_to_user(wrq->u.data.pointer,
+                             &queueConfigIoctl, sizeof(queueConfigIoctl))) {
+                PRINTM(INFO, "Copy to user failed\n");
+                retcode = -EFAULT;
+            }
+        }
+    }
+
+    return retcode;
+}
+
+/** 
+ *  @brief Prepare the firmware command buffer for the WMM_QUEUE_STATS command
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *  @param cmd      pointer to CMD buffer 
+ *  @param InfoBuf  void pointer cast of a HostCmd_CMD_WMM_QUEUE_STATS struct
+ *
+ *  @return         WLAN_STATUS_SUCCESS
+ */
+int
+wlan_cmd_wmm_queue_stats(wlan_private * priv,
+                         HostCmd_DS_COMMAND * cmd, void *InfoBuf)
+{
+    memcpy(&cmd->params.queueStats, InfoBuf, sizeof(cmd->params.queueStats));
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_WMM_QUEUE_STATS);
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_WMM_QUEUE_STATS)
+                                 + S_DS_GEN);
+
+    PRINTM(INFO, "WMM: QUEUE STATS Cmd prepared\n");
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Process the WMM_QUEUE_STATS command response from firmware
+ *
+ *  Return the firmware command response to the blocked IOCTL caller function.
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param resp    Pointer to the command response buffer with:
+ *                      - action code
+ *                      - access category
+ *                      - collected statistics if requested 
+ *
+ *  @return WLAN_STATUS_SUCCESS
+ *
+ *  @sa wlan_wmm_queue_stats_ioctl
+ */
+int
+wlan_cmdresp_wmm_queue_stats(wlan_private * priv,
+                             const HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_WMM_QUEUE_STATS *pQueueStats =
+        (HostCmd_DS_WMM_QUEUE_STATS *) priv->adapter->CurCmd->pdata_buf;
+
+    memcpy(pQueueStats, &resp->params.queueStats, (resp->Size - S_DS_GEN));
+
+    pQueueStats->pktCount = wlan_le16_to_cpu(pQueueStats->pktCount);
+    pQueueStats->pktLoss = wlan_le16_to_cpu(pQueueStats->pktLoss);
+    pQueueStats->avgQueueDelay = wlan_le32_to_cpu(pQueueStats->avgQueueDelay);
+    pQueueStats->avgTxDelay = wlan_le32_to_cpu(pQueueStats->avgTxDelay);
+    pQueueStats->usedTime = wlan_le32_to_cpu(pQueueStats->usedTime);
+
+    PRINTM(INFO, "WMM: Queue Stats response: %d\n", resp->Size - S_DS_GEN);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Private IOCTL entry to get and start/stop queue stats on a WMM AC
+ *
+ *  Receive a AC Queue statistics command from the application for a specific
+ *    WMM AC.  The command can:
+ *         - Turn stats on
+ *         - Turn stats off
+ *         - Collect and clear the stats 
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param wrq     A pointer to iwreq structure containing the
+ *                 wlan_ioctl_wmm_queue_stats_t struct
+ *
+ *  @return        0 if successful; IOCTL error code otherwise
+ */
+int
+wlan_wmm_queue_stats_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_ioctl_wmm_queue_stats_t queueStatsIoctl;
+    HostCmd_DS_WMM_QUEUE_STATS queueStatsCmd;
+    int retcode;
+
+    if (copy_from_user(&queueStatsIoctl,
+                       wrq->u.data.pointer,
+                       MIN(wrq->u.data.length,
+                           sizeof(queueStatsIoctl))) != 0) {
+        /* copy_from_user failed  */
+        PRINTM(INFO, "WMM: Queue Stats: copy from user failed\n");
+        retcode = -EFAULT;
+
+    } else {
+        memcpy(&queueStatsCmd, &queueStatsIoctl, sizeof(queueStatsIoctl));
+
+        PRINTM(INFO, "WMM: QUEUE STATS Ioctl: %d, %d\n",
+               queueStatsCmd.action, queueStatsCmd.accessCategory);
+
+        retcode = PrepareAndSendCommand(priv,
+                                        HostCmd_CMD_WMM_QUEUE_STATS, 0,
+                                        HostCmd_OPTION_WAITFORRSP, 0,
+                                        &queueStatsCmd);
+        if (retcode) {
+            retcode = -EFAULT;
+        } else {
+            if (copy_to_user(wrq->u.data.pointer,
+                             &queueStatsCmd,
+                             MIN(wrq->u.data.length,
+                                 sizeof(queueStatsCmd)))) {
+                PRINTM(INFO, "Copy to user failed\n");
+                retcode = -EFAULT;
+            }
+        }
+    }
+
+    if (retcode != WLAN_STATUS_SUCCESS) {
+        PRINTM(INFO, "WMM: QUEUE STATS Ioctl FAILED: %d, %d\n",
+               queueStatsIoctl.action, queueStatsIoctl.accessCategory);
+    }
+
+    return retcode;
+}
Index: linux-2.6.29/drivers/net/wireless/marvell8686/wlan_wmm.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/net/wireless/marvell8686/wlan_wmm.h	2010-04-05 23:04:01.000000000 -0400
@@ -0,0 +1,111 @@
+/** @file wlan_wmm.h
+ * @brief This file contains related macros, enum, and struct
+ * of wmm functionalities
+ *
+ *  Copyright  Marvell International Ltd. and/or its affiliates, 2003-2006
+ */
+/****************************************************
+Change log:
+    09/26/05: add Doxygen format comments 
+    04/06/06: Add TSPEC, queue metrics, and MSDU expiry support
+****************************************************/
+
+#ifndef __WLAN_WMM_H
+#define __WLAN_WMM_H
+
+/** Custom indiciation message sent to the application layer for WMM changes */
+#define WMM_CONFIG_CHANGE_INDICATION  "WMM_CONFIG_CHANGE.indication"
+
+/** Highest priority setting for a packet (uses voice AC) */
+#define WMM_HIGHEST_PRIORITY  7
+
+#ifdef __KERNEL__
+
+/** struct of WMM DESC */
+typedef struct
+{
+    u8 required;
+    u8 enabled;
+    u8 packetsQueued;
+    u8 queueStopped;
+    u32 packetsOut[MAX_AC_QUEUES];
+    u32 userPriPktTxCtrl[WMM_HIGHEST_PRIORITY + 1];     /* UP: 0 to 7 */
+
+    struct sk_buff txSkbQ[MAX_AC_QUEUES];
+    WmmAcStatus_t acStatus[MAX_AC_QUEUES];
+    wlan_wmm_ac_e acDowngradedVals[MAX_AC_QUEUES];
+
+    /** wmm queue priority table*/
+    u8 queuePriority[MAX_AC_QUEUES];
+
+    u8 qosinfo;
+} __ATTRIB_PACK__ WMM_DESC;
+
+extern void wmm_map_and_add_skb(wlan_private * priv, struct sk_buff *);
+extern u8 wmm_compute_driver_packet_delay(const struct sk_buff *skb);
+#endif
+
+extern int sendWMMStatusChangeCmd(wlan_private * priv);
+extern int wmm_lists_empty(wlan_private * priv);
+extern void wmm_cleanup_queues(wlan_private * priv);
+extern void wmm_process_tx(wlan_private * priv);
+
+extern void wmm_init(wlan_private * priv);
+extern void wmm_setup_queues(wlan_private * priv);
+extern void wmm_start_queue(wlan_private * priv);
+extern void wmm_stop_queue(wlan_private * priv);
+extern int wmm_is_queue_stopped(wlan_private * priv);
+
+extern void wmm_process_fw_iface_tx_xfer_start(wlan_private * priv);
+extern void wmm_process_fw_iface_tx_xfer_end(wlan_private * priv);
+extern void wmm_process_app_iface_tx(wlan_private * priv);
+extern wlan_wmm_ac_e wmm_convert_tos_to_ac(int tos);
+extern wlan_wmm_ac_e wmm_downgrade_ac(wlan_private * priv,
+                                      wlan_wmm_ac_e acVal);
+
+extern u32 wlan_wmm_process_association_req(wlan_private * priv,
+                                            u8 ** ppAssocBuf,
+                                            IEEEtypes_WmmParameter_t *
+                                            pWmmIE);
+
+/* 
+ *  Functions used in the cmd handling routine
+ */
+extern int wlan_cmd_wmm_get_status(wlan_private * priv,
+                                   HostCmd_DS_COMMAND * cmd, void *InfoBuf);
+extern int wlan_cmd_wmm_addts_req(wlan_private * priv,
+                                  HostCmd_DS_COMMAND * cmd, void *InfoBuf);
+extern int wlan_cmd_wmm_delts_req(wlan_private * priv,
+                                  HostCmd_DS_COMMAND * cmd, void *InfoBuf);
+extern int wlan_cmd_wmm_queue_config(wlan_private * priv,
+                                     HostCmd_DS_COMMAND * cmd, void *InfoBuf);
+extern int wlan_cmd_wmm_queue_stats(wlan_private * priv,
+                                    HostCmd_DS_COMMAND * cmd, void *InfoBuf);
+
+/* 
+ *  Functions used in the cmdresp handling routine
+ */
+extern int wlan_cmdresp_wmm_get_status(wlan_private * priv,
+                                       const HostCmd_DS_COMMAND * resp);
+extern int wlan_cmdresp_wmm_addts_req(wlan_private * priv,
+                                      const HostCmd_DS_COMMAND * resp);
+extern int wlan_cmdresp_wmm_delts_req(wlan_private * priv,
+                                      const HostCmd_DS_COMMAND * resp);
+extern int wlan_cmdresp_wmm_queue_config(wlan_private * priv,
+                                         const HostCmd_DS_COMMAND * resp);
+extern int wlan_cmdresp_wmm_queue_stats(wlan_private * priv,
+                                        const HostCmd_DS_COMMAND * resp);
+
+/* 
+ * IOCTLs 
+ */
+extern int wlan_wmm_enable_ioctl(wlan_private * priv, struct iwreq *wrq);
+extern int wlan_wmm_queue_status_ioctl(wlan_private * priv,
+                                       struct iwreq *wrq);
+
+extern int wlan_wmm_addts_req_ioctl(wlan_private * priv, struct iwreq *wrq);
+extern int wlan_wmm_delts_req_ioctl(wlan_private * priv, struct iwreq *wrq);
+extern int wlan_wmm_queue_config_ioctl(wlan_private * priv,
+                                       struct iwreq *wrq);
+extern int wlan_wmm_queue_stats_ioctl(wlan_private * priv, struct iwreq *wrq);
+#endif /* __WLAN_WMM_H */
